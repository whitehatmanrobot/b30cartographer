(rc != 0)
		{
			return(rc);
		}
	}

	// UNDONE: Test IPSFactoryBuffer::CreateStub

	Release(ppsfb, true);

	return(0);
}


int DoCoGetClass(REFCLSID clsid, REFIID iid)
{
	IUnknown *punkClass = (IUnknown *) (intptr_t) -1;

	HRESULT hr = CoGetClassObject(clsid,
		dwClsctx,
		NULL,
		IID_PPV_ARGS(&punkClass));

	if (hr == REGDB_E_CLASSNOTREG)
	{
		// It is possible to receive REGDB_E_CLASSNOTREG even when a CLSID is registered.  This may happen
		// when the supplied CLSCTX allows multiple mechanisms (e.g. InprocServer32 and LocalServer32), the
		// class fails DllGetClassObject, and COM continue on to try another mechanism for which there
		// is no registration.  COM should return the last real HRESULT but does not for compatibilty.
		// See CProcessActivator::ActivateByContext in nt\com\ole32\com\objact\actvator.cxx

		if ((dwClsctx & CLSCTX_INPROC_SERVER) != 0)
		{
			hr = CoGetClassObject(clsid,
				dwClsctx & CLSCTX_INPROC_SERVER,
				NULL,
				IID_PPV_ARGS(&punkClass));

			if (SUCCEEDED(hr))
			{
				// UNDONE: Something screwed up
			}
		}
		if (hr == REGDB_E_CLASSNOTREG)
		{
			if ((dwClsctx & CLSCTX_INPROC_HANDLER) != 0)
			{
				hr = CoGetClassObject(clsid,
					dwClsctx & CLSCTX_INPROC_HANDLER,
					NULL,
					IID_PPV_ARGS(&punkClass));

				if (SUCCEEDED(hr))
				{
					// UNDONE: Something screwed up
				}
			}

			if (hr == REGDB_E_CLASSNOTREG)
			{
				if ((dwClsctx & CLSCTX_LOCAL_SERVER) != 0)
				{
					hr = CoGetClassObject(clsid,
						dwClsctx & CLSCTX_LOCAL_SERVER,
						NULL,
						IID_PPV_ARGS(&punkClass));

					if (SUCCEEDED(hr))
					{
						// UNDONE: Something screwed up
					}
				}
			}
		}
	}
	if (FAILED(hr))
	{
		ReportFailure(0x2A01, false, NULL, 0, L"CoGetClassObject(IUnknown) failed.  hr = %08X", hr);

		// Note that we return 0 not 1

		return(0);
	}

	dwClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	// Do not free unused libraries here because class objects do not need to
	// affect DllCanUnloadNow.

	// Test the class object.

	szQualifier = L" (CO)";

	int rc = TestInterface(punkClass, NULL, true, true);

	if (rc != 0)
	{
		return(rc);
	}

	if (!Interface::FPush(punkClass, true))
	{
		// This is not possible

		DebugBreak();
	}

	szQualifier = L" (CO)";

	bool fIClassFactorySupported = true;

	rc = CheckIClassFactory(clsid, iid, punkClass);

	if (rc == -1)
	{
		fIClassFactorySupported = false;
	}

	else if (rc != 0)
	{

		return(rc);
	}

	szQualifier = L" (CO)";

	bool fIParseDisplayNameSupported = true;

	rc = CheckIParseDisplayName(clsid, iid, punkClass);

	if (rc == -1)
	{
		fIParseDisplayNameSupported = false;
	}

	else if (rc != 0)
	{
		return(rc);
	}

	szQualifier = L" (CO)";

	bool fIPSFactoryBufferSupported = true;

	rc = CheckIPSFactoryBuffer(clsid, iid, punkClass);

	if (rc == -1)
	{
		fIPSFactoryBufferSupported = false;
	}

	else if (rc != 0)
	{
		return(rc);
	}

	szQualifier = L" (CO)";

	if (!fIClassFactorySupported && !fIParseDisplayNameSupported && !fIPSFactoryBufferSupported)
	{
		ReportFailure(0x2A02, false, punkClass, 0, L"Neither IClassFactory*, IParseDisplayName, nor IPSFactoryBuffer supported");
	}

#if 0
	// Capture address of Release() method since after release the memory may be gone

	const void *pvRelease = PvMethod(punkClass, 2);
#endif

	ULONG cref = Interface::PopAndRelease();

#if 0
	// Don't check.  AtlComModuleGetClassObject or similar caches class objects

	if (cref != 0)
	{
		ReportFailure(0x2A03, false, pvRelease, -1, L"IUnknown::Release returned %u", cref);
	}
#endif

	return(0);
}


int DoCoCreate(REFCLSID clsid, REFIID iid)
{
	COuter *pouter = NULL;

	if (fAggregate)
	{
		pouter = new COuter;
	}

	IUnknown *punk = (IUnknown *) (intptr_t) -1;

	HRESULT hr = CoCreateInstance(clsid,
		pouter,
		dwClsctx,
		iid,
		(void **) &punk);

	if (hr == REGDB_E_CLASSNOTREG)
	{
		// It is possible to receive REGDB_E_CLASSNOTREG even when a CLSID is registered.  This may happen
		// when the supplied CLSCTX allows multiple mechanisms (e.g. InprocServer32 and LocalServer32), the
		// class fails DllGetClassObject, and COM continue on to try another mechanism for which there
		// is no registration.  COM should return the last real HRESULT but does not for compatibilty.
		// See CProcessActivator::ActivateByContext in nt\com\ole32\com\objact\actvator.cxx

		if ((dwClsctx & CLSCTX_INPROC_SERVER) != 0)
		{
			hr = CoCreateInstance(clsid,
				pouter,
				dwClsctx & CLSCTX_INPROC_SERVER,
				iid,
				(void **) &punk);

			if (SUCCEEDED(hr))
			{
				// UNDONE: Something screwed up
			}
		}

		if (hr == REGDB_E_CLASSNOTREG)
		{
			if ((dwClsctx & CLSCTX_INPROC_HANDLER) != 0)
			{
				hr = CoCreateInstance(clsid,
					pouter,
					dwClsctx & CLSCTX_INPROC_HANDLER,
					iid,
					(void **) &punk);

				if (SUCCEEDED(hr))
				{
					// UNDONE: Something screwed up
				}
			}

			if (hr == REGDB_E_CLASSNOTREG)
			{
				if ((dwClsctx & CLSCTX_LOCAL_SERVER) != 0)
				{
					hr = CoCreateInstance(clsid,
						pouter,
						dwClsctx & CLSCTX_LOCAL_SERVER,
						iid,
						(void **) &punk);

					if (SUCCEEDED(hr))
					{
						// UNDONE: Something screwed up
					}
				}
			}
		}
	}


	if (FAILED(hr))
	{
		if (!fAggregate || (hr != CLASS_E_NOAGGREGATION))
		{
			ReportFailure(0x2B01, false, NULL, 0, L"CoCreateInstance(%s, %s) failed.  hr = %08X", szClsid, SzIidDisplay(), hr);
		}

		if (punk != NULL)
		{
			ReportFailure(0x2B02, false, NULL, 0, L"CoCreateInstance(%s, %s) failure did not set *ppvObject = NULL", szClsid, SzIidDisplay());
		}

		// Note that we return 0 not 1

		return(0);
	}

	if (punk == NULL)
	{
		ReportFailure(0x2B03, false, NULL, 0, L"CoCreateInstance(%s, %s) succeeded but *ppvObject == NULL", szClsid, SzIidDisplay());

		return(0x2B03);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	if (fAggregate)
	{
		pouter->m_punkInner = punk;

		int rc = TestInnerInterface(pouter, NULL, 0, L"CoCreateInstance", punk, 1);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!FTestClass(punk, clsid))
	{
		// We don't want to test this class

		ReportFailure(0x2B04, false, NULL, 0, L"Skipped");

		Release(fAggregate ? pouter : punk, false);

		return(0);
	}

	if (fCreateOnly || fSDL)
	{
		ReportFailure(0x2B05, fCreateOnly || fSDL, NULL, 0, L"CoCreateInstance(%s, %s) succeeded", szClsid, SzIidDisplay());
	}

	return(TestAndReleaseInterface(fAggregate ? pouter : punk, &clsid, fAggregate || IsEqualGUID(iid, IID_IUnknown), false, true));
}


void DisplayLogo()
{
	if (fIsChild)			// no logo on child processes
	{
		return;
	}

	_putws(L"Microsoft (R) COM Checker " BUILD_VERSION_STR L"\n"
		L"Copyright (C) Microsoft Corporation. All rights reserved.\n"
		L"\n"
		L"Microsoft Confidential - For Internal Use Only\n");
}


void DisplayUsage()
{
	DisplayLogo();

	_putws(L"Usage: comchk <options>...\n"
		L"\n"
		L"Options:\n"
		L"\n"
		L"\t-addtodocument {after|before|no}\n"
		L"\t-aggregate\n"
		L"\t-bindtoobject\n"
		L"\t-bindtostorage\n"
		L"\t-checksafety\n"
		L"\t-clsctx <clsctx>\n"
		L"\t-clsid {guid}\n"
		L"\t-createonly\n"
		L"\t-data {url}\n"
		L"\t-dispatchmax <count>\n"
		L"\t-fakedebugger\n"
		L"\t-freeco\n"
		L"\t-html\n"
		L"\t-hookdll <path>\n"
		L"\t-ignorerpcexcept\n"
		L"\t-iid {guid}\n"
		L"\t-invoke <exe-path>\n"
		L"\t-invokeprefix <text>\n"
		L"\t-level <level>\n"
		L"\t-moniker <moniker-format>\n"
		L"\t-mt {mta|sta}\n"
		L"\t-mta\n"
		L"\t-nocategorycheck\n"
		L"\t-noexcept\n"
		L"\t-nofakedebugger\n"
		L"\t-nofree\n"
		L"\t-noidispatch\n"
		L"\t-noidispatchfuzz\n"
		L"\t-noignorebreakpoint\n"
		L"\t-noignoreclrexcept\n"
		L"\t-noignorecppexcept\n"
		L"\t-noignoredelayloadexcept\n"
		L"\t-noignorefloatexcept\n"
		L"\t-noignorexmlexcept\n"
		L"\t-nooverridesafety\n"
		L"\t-nopatchbreakpoint\n"
		L"\t-nowindowhook\n"
		L"\t-objref\n"
		L"\t-out <filename>\n"
		L"\t-prefix <prefix>\n"
		L"\t-progid <progid>\n"
		L"\t-removeprivileges\n"
		L"\t-safeforinitializing\n"
		L"\t-safeforscripting\n"
		L"\t-sad <filename>\n"
		L"\t-sdl\n"
		L"\t-silent\n"
		L"\t-stdmodes\n"
		L"\t-timeout <seconds>\n"
		L"\t-tryqi\n"
		L"\t-url <url>\n"
		L"\t-urlmoniker\n"
		L"\t-usecf\n"
		L"\t-useps\n"
		L"\t-verbose\n"
		L"\t-webbrowser\n"
		L"\t-zone <zone>\n");
}

int DoTests()
{
	fExistsA = _waccess_s(L"A", 0) == 0;

	CTrigger ctrigger;

	DWORD dwRegister;

	HRESULT hr = CoRegisterClassObject(__uuidof(CTrigger),
		&ctrigger,
		CLSCTX_INPROC_SERVER,
		REGCLS_MULTIPLEUSE,
		&dwRegister);

	if (FAILED(hr))
	{
		wprintf(L"CoRegisterClassObject failed.  hr = %08\n", hr);
	}

	int rc;

	if (szMoniker != NULL)
	{
		rc = DoMoniker(iid);
	}

	else if (fHTML)
	{
		wchar_t szClassid[6 + 36 + 1];

		swprintf(szClassid, _countof(szClassid), L"clsid:%.36s", szClsid + 1);

		if (fWebBrowser)
		{
			rc = DoHTMLWebBrowser(szClassid, &clsid);
		}

		else
		{
			rc = DoHTML(szClassid, &clsid);
		}
	}
	else if (fUseCF || fUsePS)
	{
		rc = DoCoGetClass(clsid, iid);
	}
	else
	{
		rc = DoCoCreate(clsid, iid);
	}

	if (SUCCEEDED(hr))
	{
		hr = CoRevokeClassObject(dwRegister);

		if (FAILED(hr))
		{
			wprintf(L"CoRevokeClassObject failed.  hr = %08\n", hr);
		}
	}

	return(rc);
}

DWORD WINAPI DoTestsThread(void *)
{
	HRESULT hr = CoInitializeEx(NULL, dwCoinit2);

	if (FAILED(hr))
	{
		wprintf(L"CoInitializeEx() failed.  hr = %08X\n", hr);
		return(1);
	}

	int rc = DoTests();

	CoUninitialize();

	return((DWORD) rc);
}

enum flag
{
	f_Error,
	f_addtodocument,
	f_aggregate,
	f_bindtoobject,
	f_bindtostorage,
	f_checksafety,
	f_clsctx,
	f_clsid,
	f_createonly,
	f_data,
	f_dispatchmax,
	f_fakedebugger,
	f_freeco,
	f_html,
	f_hookdll,
	f_ignorerpcexcept,
	f_iid,
	f_invoke,
	f_invokeprefix,
	f_moniker,
	f_mt,
	f_mta,
	f_nocategorycheck,
	f_noexcept,
	f_nofakedebugger,
	f_nofree,
	f_noidispatch,
	f_noidispatchfuzz,
	f_noignorebreakpoint,
	f_noignoreclrexcept,
	f_noignorecppexcept,
	f_noignoredelayloadexcept,
	f_noignorefloatexcept,
	f_noignorexmlexcept,
	f_nooverridesafety,
	f_nopatchbreakpoint,
	f_nowindowhook,
	f_objref,
	f_out,
	f_prefix,
	f_progid,
	f_removeprivileges,
	f_safeforinitializing,
	f_safeforscripting,
	f_sdl,
	f_sdlout,
	f_level,
	f_silent,
	f_stdmodes,
	f_timeout,
	f_tryqi,
	f_url,
	f_urlmoniker,
	f_usecf,
	f_useps,
	f_verbose,
	f_webbrowser,
	f_zone,
	f_sad
};

flag ParseFlag(const wchar_t *szArg)
{
	if ((szArg[0] != '/') &&
		(szArg[0] != '-') &&
		(szArg[0] != 0x2013)			// OK -- this looks dumb but is actually a dash from email
		) return f_Error;
	szArg++;
	if (_wcsicmp(szArg, L"addtodocument") == 0) return f_addtodocument;
	if (_wcsicmp(szArg, L"aggregate") == 0) return f_aggregate;
	if (_wcsicmp(szArg, L"bindtoobject") == 0) return f_bindtoobject;
	if (_wcsicmp(szArg, L"bindtostorage") == 0) return f_bindtostorage;
	if (_wcsicmp(szArg, L"checksafety") == 0) return f_checksafety;
	if (_wcsicmp(szArg, L"clsctx") == 0) return f_clsctx;
	if (_wcsicmp(szArg, L"clsid") == 0) return f_clsid;
	if (_wcsicmp(szArg, L"createonly") == 0) return f_createonly;
	if (_wcsicmp(szArg, L"data") == 0) return f_data;
	if (_wcsicmp(szArg, L"dispatchmax") == 0) return f_dispatchmax;
	if (_wcsicmp(szArg, L"fakedebugger") == 0) return f_fakedebugger;
	if (_wcsicmp(szArg, L"freeco") == 0) return f_freeco;
	if (_wcsicmp(szArg, L"html") == 0) return f_html;
	if (_wcsicmp(szArg, L"hookdll") == 0) return f_hookdll;
	if (_wcsicmp(szArg, L"ignorerpcexcept") == 0) return f_ignorerpcexcept;
	if (_wcsicmp(szArg, L"iid") == 0) return f_iid;
	if (_wcsicmp(szArg, L"invoke") == 0) return f_invoke;
	if (_wcsicmp(szArg, L"invokeprefix") == 0) return f_invokeprefix;
	if (_wcsicmp(szArg, L"moniker") == 0) return f_moniker;
	if (_wcsicmp(szArg, L"mt") == 0) return f_mt;
	if (_wcsicmp(szArg, L"mta") == 0) return f_mta;
	if (_wcsicmp(szArg, L"nocategorycheck") == 0) return f_nocategorycheck;
	if (_wcsicmp(szArg, L"noexcept") == 0) return f_noexcept;
	if (_wcsicmp(szArg, L"nofakedebugger") == 0) return f_nofakedebugger;
	if (_wcsicmp(szArg, L"nofree") == 0) return f_nofree;
	if (_wcsicmp(szArg, L"noidispatch") == 0) return f_noidispatch;
	if (_wcsicmp(szArg, L"noidispatchfuzz") == 0) return f_noidispatchfuzz;
	if (_wcsicmp(szArg, L"noignorebreakpoint") == 0) return f_noignorebreakpoint;
	if (_wcsicmp(szArg, L"noignoreclrexcept") == 0) return f_noignoreclrexcept;
	if (_wcsicmp(szArg, L"noignorecppexcept") == 0) return f_noignorecppexcept;
	if (_wcsicmp(szArg, L"noignoredelayloadexcept") == 0) return f_noignoredelayloadexcept;
	if (_wcsicmp(szArg, L"noignorefloatexcept") == 0) return f_noignorefloatexcept;
	if (_wcsicmp(szArg, L"noignorexmlexcept") == 0) return f_noignorexmlexcept;
	if (_wcsicmp(szArg, L"nooverridesafety") == 0) return f_nooverridesafety;
	if (_wcsicmp(szArg, L"nopatchbreakpoint") == 0) return f_nopatchbreakpoint;
	if (_wcsicmp(szArg, L"nowindowhook") == 0) return f_nowindowhook;
	if (_wcsicmp(szArg, L"objref") == 0) return f_objref;
	if (_wcsicmp(szArg, L"out") == 0) return f_out;
	if (_wcsicmp(szArg, L"prefix") == 0) return f_prefix;
	if (_wcsicmp(szArg, L"progid") == 0) return f_progid;
	if (_wcsicmp(szArg, L"removeprivileges") == 0) return f_removeprivileges;
	if (_wcsicmp(szArg, L"safeforinitializing") == 0) return f_safeforinitializing;
	if (_wcsicmp(szArg, L"safeforscripting") == 0) return f_safeforscripting;
	if (_wcsicmp(szArg, L"sdl") == 0) return f_sdl;
	if (_wcsicmp(szArg, L"sdlout") == 0) return f_sdlout;
	if (_wcsicmp(szArg, L"level") == 0) return f_level;
	if (_wcsicmp(szArg, L"silent") == 0) return f_silent;
	if (_wcsicmp(szArg, L"stdmodes") == 0) return f_stdmodes;
	if (_wcsicmp(szArg, L"timeout") == 0) return f_timeout;
	if (_wcsicmp(szArg, L"tryqi") == 0) return f_tryqi;
	if (_wcsicmp(szArg, L"url") == 0) return f_url;
	if (_wcsicmp(szArg, L"urlmoniker") == 0) return f_urlmoniker;
	if (_wcsicmp(szArg, L"usecf") == 0) return f_usecf;
	if (_wcsicmp(szArg, L"useps") == 0) return f_useps;
	if (_wcsicmp(szArg, L"verbose") == 0) return f_verbose;
	if (_wcsicmp(szArg, L"webbrowser") == 0) return f_webbrowser;
	if (_wcsicmp(szArg, L"zone") == 0) return f_zone;
	if (_wcsicmp(szArg, L"sad") == 0) return f_sad;
	
	return f_Error;
}

int wmain(int argc, wchar_t *argv[])
{
	printf("\n");  // No, I don't know why this is needed, but if I don't do it I don't get output from children.
	SetErrorMode(SEM_FAILCRITICALERRORS);

	if (argc < 2)
	{
		DisplayUsage();
		return(1);
	}

	for (int iarg = 1; iarg < argc; iarg++)
	{
		const wchar_t *szArg = argv[iarg];

		flag f = ParseFlag(szArg);

		switch(f)
		{
			case f_addtodocument:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szAddToDocument = argv[iarg];
				break;
			case f_aggregate:
				fAggregate = true;
				break;
			case f_bindtoobject:
				fBindToObject = true;
				break;
			case f_bindtostorage:
				fBindToStorage = true;
				break;
			case f_checksafety:
				fCheckSafety = true;
				break;
			case f_clsctx:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szClsctx = argv[iarg];
				break;
			case f_clsid:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szClsid = argv[iarg];
				break;
			case f_createonly:
				fCreateOnly = true;
				break;
			case f_data:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szData = argv[iarg];
				break;
			case f_dispatchmax:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szDispatchMax = argv[iarg];
				break;
			case f_fakedebugger:
				fFakeDebugger = true;
				break;
			case f_freeco:
				fFreeCO = true;
				break;
			case f_html:
				fHTML = true;
				break;
			case f_hookdll:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szHookDll = argv[iarg];
				break;
			case f_ignorerpcexcept:
				fIgnoreRpcExcept = true;
				break;
			case f_iid:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szIid = argv[iarg];
				break;
			case f_invoke:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szInvoke = argv[iarg];
				break;
			case f_invokeprefix:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szInvokePrefix = argv[iarg];
				break;
			case f_moniker:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szMoniker = argv[iarg];
				break;
			case f_mt:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szMT = argv[iarg];
				break;
			case f_mta:
				fMTA = true;
				break;
			case f_nocategorycheck:
				fNoCategoryCheck = true;
				break;
			case f_noexcept:
				fNoVectoredExceptions = true;
				break;
			case f_nofakedebugger:
				fNoFakeDebugger = true;
				break;
			case f_nofree:
				fNoFree = true;
				break;
			case f_noidispatch:
				fNoIDispatch = true;
				break;
			case f_noidispatchfuzz:
				fNoIDispatchFuzz = true;
				break;
			case f_noignorebreakpoint:
				fNoIgnoreBreakpoint = true;
				break;
			case f_noignoreclrexcept:
				fNoIgnoreClrExcept = true;
				break;
			case f_noignorecppexcept:
				fNoIgnoreCppExcept = true;
				break;
			case f_noignoredelayloadexcept:
				fNoIgnoreDelayLoadExcept = true;
				break;
			case f_noignorefloatexcept:
				fNoIgnoreFloatExcept = true;
				break;
			case f_noignorexmlexcept:
				fNoIgnoreXmlExcept = true;
				break;
			case f_nooverridesafety:
				fNoOverrideSafety = true;
				break;
			case f_nopatchbreakpoint:
				fNoPatchBreakpoint = true;
				break;
			case f_nowindowhook:
				fNoWindowHook = true;
				break;
			case f_objref:
				fObjrefMoniker = true;
				break;
			case f_out:
				if (++iarg == argc)
				{	
					DisplayUsage();
					return 1;
				}
				szOut = argv[iarg];
				break;
			case f_prefix:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szPrefix = argv[iarg];
				break;
			case f_progid:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szProgid = argv[iarg];
				break;
			case f_removeprivileges:
				fRemovePrivileges = true;
				break;
			case f_safeforinitializing:
				fSafeForInitializing = true;
				break;
			case f_safeforscripting:
				fSafeForScripting = true;
				break;
			case f_sdl:
				fSDL = true;
				fStdModes = true;
				if (!blevel)
					ilevel = 3;
				break;
			case f_sdlout:
				fSDL = true;
				if (!blevel)
					ilevel = 3;
				break;
			case f_level:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				ilevel = _wtoi(argv[iarg]);
				blevel = true;
				break;
			case f_silent:
				fSilent = true;
				break;
			case f_stdmodes:
				fStdModes = true;
				break;
			case f_timeout:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szTimeout = argv[iarg];
				break;
			case f_tryqi:
				fTryQI = true;
				break;
			case f_url:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szUrl = argv[iarg];
				break;
			case f_urlmoniker:
				fUrlMoniker = true;
				break;
			case f_usecf:
				fUseCF = true;
				break;
			case f_useps:
				fUsePS = true;
				break;
			case f_verbose:
				fVerbose = true;
				break;
			case f_webbrowser:
				fWebBrowser = true;
				fHTML = true;		       // -webbrowser implies -html
				break;
			case f_zone:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szZone = argv[iarg];
				break;
			case f_sad:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szSad = argv[iarg];
				break;
			case f_Error:
			default:
				DisplayUsage();
				return 1;
		}
	}

	if (fRemovePrivileges)
	{
		RemovePrivileges();
	}

	if (fFakeDebugger || (!fNoFakeDebugger && !FDefaultNoFakeDebugger()))
	{
		// Set the BeingDebugged field in the PEB.  This is necessary so that
		// output from DebugPrint is reported via DBG_PRINTEXCEPTION_C on
		// pre-Longhorn systems.

#if	defined(_M_IX86)

		BYTE *pbPeb = (BYTE *) __readfsdword(0x30);

		pbPeb[2] = 0x01;

#elif	defined(_M_AMD64)

		BYTE *pbPeb = (BYTE *) __readgsqword(0x60);

		pbPeb[2] = 0x01;

#endif
	}

	HRESULT hr = CoInitializeEx(NULL, fMTA ? COINIT_MULTITHREADED : COINIT_APARTMENTTHREADED);

	if (FAILED(hr))
	{
		wprintf(L"CoInitializeEx() failed.  hr = %08X\n", hr);
		return(1);
	}

	wchar_t szClsidT[39];

	if (szClsid != NULL)
	{
		if (fUsePS)
		{
			_putws(L"-useps invalid with -clsid\n");
			return(1);
		}

		if (szProgid != NULL)
		{
			wprintf(L"Only one of -clsid or -progid may be specified");
			return(1);
		}

		if (wcscmp(szClsid, L"*") == 0)
		{
			fAllClsids = true;
		}

		else if (szClsid[0] == L'@')
		{
			fClsidsFromFile = true;
		}

		else if (szClsid[0] != L'{')
		{
			wprintf(L"Invalid CLSID \"%s\"\n", szClsid);
			return(1);
		}

		else
		{
			hr = CLSIDFromString(szClsid, &clsid);

			if (FAILED(hr))
			{
				wprintf(L"Invalid CLSID \"%s\".  HRESULT = %08X\n", szClsid, hr);
				return(1);
			}

			if (szPrefix == NULL)
			{
				szPrefix = szClsid;
			}
		}
	}

	else if (szProgid != NULL)
	{
		if (fUsePS)
		{
			_putws(L"-useps invalid with -progid\n");
			return(1);
		}

		if (wcscmp(szProgid, L"*") == 0)
		{
			fAllProgids = true;
		}

		else if (szProgid[0] == L'@')
		{
			fProgidsFromFile = true;
		}

		else
		{
			hr = CLSIDFromProgID(szProgid, &clsid);

			if (FAILED(hr))
			{
				wprintf(L"Invalid ProgID \"%s\".  HRESULT = %08X\n", szProgid, hr);
				return(1);
			}

			if (StringFromGUID2(clsid, szClsidT, _countof(szClsidT)) == 0)
			{
				wprintf(L"StringFromGUID2 failed.  hr = %08X\n", hr);
				return(1);
			}

			szClsid = szClsidT;

			if (szPrefix == NULL)
			{
				szPrefix = szProgid;
			}
		}
	}

	else if (!fUsePS)
	{
		_putws(L"One of -clsid or -progid must be specified");
		return(1);
	}

	if (szIid != NULL)
	{
		if (wcscmp(szIid, L"*") == 0)
		{
			fAllIids = true;
		}

		else if (szIid[0] == L'@')
		{
			fIidsFromFile = true;
		}

		else
		{
			hr = IIDFromString(szIid, &iid);

			if (FAILED(hr))
			{
				wprintf(L"Invalid IID \"%s\".  HRESULT = %08X\n", szIid, hr);
				return(1);
			}

			if (fTryQI)
			{
				_putws(L"-tryqi requires -iid * or -iid @filename");
				return(1);
			}

			if (fUsePS && !fStdModes)
			{
				if (szPrefix == NULL)
				{
					szPrefix = szIid;
				}

				// There is a bug in CoGetPSClsid that causes it to return success when it fails.
				// We check for this by checking for CLSID_NULL.

				clsid = CLSID_NULL;

				hr = CoGetPSClsid(iid, &clsid);

				if (FAILED(hr))
				{
					if (!fSilent)
					{
						wprintf(L"%s: CoGetPSClsid failed.  hr = %08X\n", szIid, hr);
					}

					// Note that we return 0 not 1

					return(0);
				}

				else if (clsid == CLSID_NULL)
				{
					if (!fSilent)
					{
						wprintf(L"%s: CoGetPSClsid didn't return a CLSID.  (Windows OS #1290702)\n", szIid);
					}

					// Note that we return 0 not 1

					return(0);
				}

				if (StringFromGUID2(clsid, szClsidT, _countof(szClsidT)) == 0)
				{
					wprintf(L"StringFromGUID2 failed.  hr = %08X\n", hr);
					return(1);
				}

				szClsid = szClsidT;
			}
		}
	}

	else if (fTryQI)
	{
		_putws(L"-tryqi requires -iid");
		return(1);
	}

	else if (fUsePS)
	{
		_putws(L"-useps requires -iid");
		return(1);
	}

	if (szClsctx != NULL)
	{
		if (_wcsicmp(szClsctx, L"all") == 0)
		{
			dwClsctx = CLSCTX_ALL;
		}

		else if (_wcsicmp(szClsctx, L"inproc") == 0)
		{
			dwClsctx = CLSCTX_INPROC;
		}

		else if (_wcsicmp(szClsctx, L"inproc_handler") == 0)
		{
			dwClsctx = CLSCTX_INPROC_HANDLER;
		}

		else if (_wcsicmp(szClsctx, L"inproc_server") == 0)
		{
			dwClsctx = CLSCTX_INPROC_SERVER;
		}

		else if (_wcsicmp(szClsctx, L"local_server") == 0)
		{
			dwClsctx = CLSCTX_LOCAL_SERVER;
		}

		else if (_wcsicmp(szClsctx, L"remote_server") == 0)
		{
			dwClsctx = CLSCTX_REMOTE_SERVER;
		}

		else if (_wcsicmp(szClsctx, L"server") == 0)
		{
			dwClsctx = CLSCTX_SERVER;
		}

		else
		{
			dwClsctx = wcstoul(szClsctx, NULL, 10);
		}
	}

	if (szDispatchMax != NULL)
	{
		dwDispatchMax = wcstoul(szDispatchMax, NULL, 10);
	}

	if (szMT != NULL)
	{
		if (_wcsicmp(szMT, L"mta") == 0)
		{
			dwCoinit2 = COINIT_MULTITHREADED;
		}

		else if (_wcsicmp(szMT, L"sta") == 0)
		{
			dwCoinit2 = COINIT_APARTMENTTHREADED;
		}

		else
		{
			dwCoinit2 = wcstoul(szMT, NULL, 10);
		}
	}

	if (szTimeout != NULL)
	{
		dwTimeout = wcstoul(szTimeout, NULL, 10);

		if (dwTimeout == 0)
		{
			dwTimeout = INFINITE;
		}
	}

	if (szZone != NULL)
	{
		if (_wcsicmp(szZone, L"local_machine") == 0)
		{
			dwZone = URLZONE_LOCAL_MACHINE;
		}

		else if (_wcsicmp(szZone, L"intranet") == 0)
		{
			dwZone = URLZONE_INTRANET;
		}

		else if (_wcsicmp(szZone, L"trusted") == 0)
		{
			dwZone = URLZONE_TRUSTED;
		}

		else if (_wcsicmp(szZone, L"internet") == 0)
		{
			dwZone = URLZONE_INTERNET;
		}

		else if (_wcsicmp(szZone, L"untrusted") == 0)
		{
			dwZone = URLZONE_UNTRUSTED;
		}

		else
		{
			dwZone = wcstoul(szZone, NULL, 10);
		}
	}

	if (fHTML)
	{
		if ((szClsid == NULL) && (szMoniker == NULL))
		{
			_putws(L"-html requires -clsid or -moniker\n");
			return(1);
		}

		if (szAddToDocument != NULL)
		{
			if (_wcsicmp(szAddToDocument, L"after") == 0)
			{
				atd = atdAfter;
			}

			else if (_wcsicmp(szAddToDocument, L"before") == 0)
			{
				atd = atdBefore;
			}

			else if (_wcsicmp(szAddToDocument, L"no") == 0)
			{
				atd = atdNo;
			}

			else
			{
				_putws(L"Invalid -addtodocument option\n");
				return(1);
			}
		}

		if (szClsctx)
		{
			_putws(L"-clsctx invalid with -html\n");
			return(1);
		}

		if (fUrlMoniker)
		{
			_putws(L"-urlmoniker invalid with -html\n");
			return(1);
		}

		if (fUseCF)
		{
			_putws(L"-usecf invalid with -html\n");
			return(1);
		}

		if (fUsePS)
		{
			_putws(L"-useps invalid with -html\n");
			return(1);
		}
	}

	else
	{
		if (szAddToDocument)
		{
			_putws(L"-addtodocument requires -html\n");
			return(1);
		}

		if (szData != NULL)
		{
			_putws(L"-data requires -html\n");
			return(1);
		}
	}

	if (fStdModes)
	{
		if (fAggregate)
		{
			_putws(L"-aggregate invalid with -stdmodes\n");
			return(1);
		}

		if (fWebBrowser)
		{
			_putws(L"-webbrowser invalid with -stdmodes\n");
			return(1);
		}

		if (fHTML)
		{
			_putws(L"-html invalid with -stdmodes\n");
			return(1);
		}

		if (fMTA)
		{
			_putws(L"-mta invalid with -stdmodes\n");
			return(1);
		}

		if (fUseCF)
		{
			_putws(L"-usecf invalid with -stdmodes\n");
			return(1);
		}
	}

	FILE *pfileOut = NULL;

	if (szOut != NULL)
	{
		if (_wfreopen_s(&pfileOut, szOut, L"wt", stdout) != 0)
		{
			pfileOut = NULL;
		}
	}

	// Try to open pipe.

		// create first instance
	HANDLE hPipe = CreateNamedPipe( 
			L"\\\\.\\pipe\\COMChk_CommPipe",             // pipe name 
			PIPE_ACCESS_INBOUND,       // read access 
			PIPE_TYPE_MESSAGE |       // message type pipe 
			PIPE_READMODE_MESSAGE |   // message-read mode 
			PIPE_WAIT,                // blocking mode 
			PIPE_UNLIMITED_INSTANCES, // max. instances  
			4096,                  // output buffer size 
			4096,                  // input buffer size 
			NMPWAIT_USE_DEFAULT_WAIT, // client time-out 
			NULL);                    // default security attribute 

	if (hPipe != INVALID_HANDLE_VALUE) 
	{
		DWORD dwThreadID;
		HANDLE hThread = CreateThread(NULL, 0, PipeServerThread, (LPVOID)hPipe, 0, &dwThreadID);
		if (hThread == NULL)
		{
			printf("CreateThread failed\n");
			return 0;
		}
		CloseHandle(hThread);
	}
	else
		fIsChild = true;

	DisplayLogo();


	//
	// Now open the pipe as a client.

	while (1) 
	{ 
		hPipeInfoSend = CreateFile( 
			L"\\\\.\\pipe\\COMChk_CommPipe",   // pipe name 
			GENERIC_WRITE,  // write access 
			0,              // no sharing 
			NULL,           // default security attributes
			OPEN_EXISTING,  // opens existing pipe 
			0,              // default attributes 
			NULL);          // no template file 

		// Break if the pipe handle is valid. 

		if (hPipeInfoSend != INVALID_HANDLE_VALUE) 
			break; 

		// Exit if an error other than ERROR_PIPE_BUSY occurs. 

		DWORD iErr = GetLastError();
		if (iErr != ERROR_PIPE_BUSY) 
		{
			printf("Could not open pipe, err %d", iErr); 
			return 0;
		}

		// All pipe instances are busy, so wait for 20 seconds. 

		if (!WaitNamedPipe(L"\\\\.\\pipe\\COMChk_CommPipe", 20000)) 
		{ 
			printf("Could not open pipe"); 
			return 0;
		} 
	} 
	// The pipe connected; change to message-read mode. 

	DWORD dwMode = PIPE_READMODE_MESSAGE; 
	BOOL fSuccess = SetNamedPipeHandleState( 
		hPipeInfoSend,    // pipe handle 
		&dwMode,  // new pipe mode 
		NULL,     // don't set maximum bytes 
		NULL);    // don't set maximum time 
	if (!fSuccess) 
	{
		printf("SetNamedPipeHandleState failed"); 
		return 0;
	}

	// Send a message to the pipe server. 


	// open XML SAD output for Master
	if (szSad != NULL)
	{
		sad = new SAD(szSad);
	}


	int iret;

	if (fAllClsids)
	{
		iret = DoAllClsids();
		goto cleanup;
	}

	if (fClsidsFromFile)
	{
		iret = DoClsidsFromFile(szClsid + 1);
		goto cleanup;
	}

	if (fAllProgids)
	{
		iret = DoAllProgids();
		goto cleanup;
	}

	if (fProgidsFromFile)
	{
		iret = DoProgidsFromFile(szProgid + 1);
		goto cleanup;
	}

	if (!fTryQI) 		       // Don't recurse with -tryqi
	{
		if (fAllIids)
		{
			iret = DoAllIids();
			goto cleanup;
		}

		if (fIidsFromFile)
		{
			iret = DoIidsFromFile(szIid + 1);
			goto cleanup;
		}
	}

	if (fStdModes)
	{
		iret = DoStdModes();
		goto cleanup;
	}

	//
	// At this point, we are testing one object.
	// Identified by clsid.
	// So log to parent (or me).

	PipeMsg pmObj;
	pmObj.AddDWORD(1);	// code for Object message
	LPOLESTR lpo;
	StringFromCLSID(clsid, &lpo);
	pmObj.AddString(lpo);
	CoTaskMemFree(lpo);
	pmObj.Send(hPipeInfoSend);

	//
	// Now dump the command line to the output also.

	PipeMsg pmTR;
	pmTR.AddDWORD(2);
	pmTR.AddString(GetCommandLine());
	pmTR.Send(hPipeInfoSend);

	SetMyUnhandledExceptionFilter(false);

	if (!fNoVectoredExceptions)
	{
		PVOID pvHandler = AddVectoredExceptionHandler(TRUE, &VectoredExceptionHandler);

		if (pvHandler == NULL)
		{
			wprintf(L"AddVectoredExceptionHandler failed.  GetLastError() = %u\n", GetLastError());
			return(1);
		}
	}

	if (!fNoWindowHook)
	{
		const wchar_t *szDll = (szHookDll != NULL) ? szHookDll : L"comchkhk.dll";

		hmodHook = LoadLibraryEx(szDll, 0, LOAD_WITH_ALTERED_SEARCH_PATH);

		if (hmodHook == NULL)
		{
			wprintf(L"LoadLibraryEx(\"%s\") failed.  GetLastError() = %u.  -nowindowhook assumed\n", szDll, GetLastError());

			fNoWindowHook = true;
		}

		else
		{
			*(FARPROC *) &pfnInstallHook = GetProcAddress(hmodHook, "InstallHook");
			*(FARPROC *) &pfnUninstallHook = GetProcAddress(hmodHook, "UninstallHook");

			if ((pfnInstallHook == 0) || (pfnUninstallHook == 0))
			{
				_putws(L"Can't find InstallHook or UninstallHook.  -nowindowhook assumed\n");

				FreeLibrary(hmodHook);
				hmodHook = NULL;

				fNoWindowHook = true;
			}

			else
			{
				hhook = (*pfnInstallHook)(&WindowHookCallback);
			}
		}
	}

	if (!fNoCategoryCheck && !fUsePS)
	{
		QueryComponentCategories(clsid);
	}


	if (szMT != NULL)
	{
		HANDLE hThread = CreateThread(NULL, 0, &DoTestsThread, NULL, 0, NULL);

		if (hThread == NULL)
		{
			wprintf(L"CreateThread failed.  GetLastError() = %u\n", GetLastError());
			return(1);
		}

		DWORD dw = WaitForSingleObject(hThread, INFINITE);

		if (!GetExitCodeThread(hThread, &dw))
		{
			wprintf(L"GetExitCodeThread failed.  GetLastError() = %u\n", GetLastError());
			return(1);
		}

		iret = (int) dw;

		CloseHandle(hThread);
	}

	else
	{
		iret = DoTests();
	}

	FreeUnusedLibraries();

	if (!fNoWindowHook)
	{
		(*pfnUninstallHook)(hhook);

		FreeLibrary(hmodHook);
	}

	if (pfileOut != NULL)
	{
		fclose(pfileOut);
	}
cleanup:

	if (sad) delete sad;


	CoUninitialize();
	return(iret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\comchk.h ===
#pragma once

#include "cache.h"

//
// COMChk definitions.

// Globals.

class SAD;
extern SAD *sad;

//
// warning routines.
bool FindWarningInfo(DWORD rc, LPWSTR *pName, int *pLvl);

// Pipe stuff for interprocess comm
DWORD WINAPI PipeServerThread(LPVOID lpvParam);
DWORD WINAPI InstanceThread(LPVOID lpvParam);
class PipeMsg
{
	char acBfr[4092];
	int iPos;
public:
	void AddDWORD(DWORD i);
	void AddString(LPWSTR str);
	void AddFormatString(const wchar_t * format, ...);
	void AppendFormatString(const wchar_t * format, ...);
	void AddFormatVString(const wchar_t * format, va_list argptr);
	void AppendFormatVString(const wchar_t * format, va_list argptr);
	int Send(HANDLE hPipe);
	PipeMsg();
};

// SAD output classes

class OutCOMCtrl;

class OutInstance
{
	int _idx;
	OutCOMCtrl *_CC;
	FILE *_pfsad;
public:
	OutInstance(OutCOMCtrl *CC, LPWSTR cmdline, FILE *pf);
	void OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr);
	void OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr);
	void OutputTimeout(LPWSTR CmdLine);
	void OutputUnknown(LPWSTR CmdLine);

	~OutInstance();
};

class OutCOMCtrl
{
	FILE *_pfsad;
	int _idx;
	SAD *_sad;
	CLSID _clsid;
	OutInstance *_InstCurrent;
public:
	OutCOMCtrl(SAD *, LPWSTR, FILE *);
	~OutCOMCtrl();
	BOOL IsThisClsid(LPWSTR clsid);
	int GetTarget();
	void SetInstance(LPWSTR wcCmdLine);
	void OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr);
	void OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr);
	void OutputTimeout(LPWSTR CmdLine);
	void OutputUnknown(LPWSTR CmdLine);
	int GetAndIncrementIdx();

    int AddInterfaceEntry(LPWSTR clsid, int target);
    int AddFileEntry(LPWSTR path);
};

class SAD
{
	CRITICAL_SECTION _cs;
	FILE *_pfsad;
	OutCOMCtrl *_CCCurrent;
	void FillInCollectionNode();
	int _idx;
    CCache<INT> _InterfaceCache;
    CCache<INT> _FileCache;
public:
	SAD(wchar_t *XMLFile);
	~SAD();
	void SetCOMCtrl(LPWSTR clsid);
	void SetInstance(LPWSTR lpCmdLine);
	void OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr);
	void OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr);
	void OutputTimeout(LPWSTR CmdLine);
	void OutputUnknown(LPWSTR CmdLine);
	int GetAndIncrementIdx();

    int AddInterfaceEntry(LPWSTR clsid, int target);
    int AddFileEntry(LPWSTR path);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\pipethreads.cpp ===
#include <stdio.h>

#define STRICT
#include "windows.h"

#include "verstamp.h"
#include "comchk.h"

/////////////////////////
//  Client side
//
//  Simple pipe

PipeMsg::PipeMsg()
{
	iPos = 0;
}
void PipeMsg::AddDWORD(DWORD i)
{
	DWORD *p = (DWORD *)(acBfr+iPos);
	*p = i;
	iPos += sizeof(DWORD);
}

void PipeMsg::AddString(LPWSTR str)
{
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	wcscpy(p, str);
	iPos += 2+2*wcslen(str);
}

void PipeMsg::AddFormatString(const wchar_t * format, ...)
{
	va_list valist;
	va_start(valist, format);
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
	va_end(valist);
}
// back up one word to overwrite terminator and append info.
void PipeMsg::AppendFormatString(const wchar_t * format, ...)
{
	va_list valist;
	va_start(valist, format);
	iPos-=2;
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
	va_end(valist);
}

void PipeMsg::AddFormatVString(const wchar_t * format, va_list valist)
{
//	va_start(valist, format);
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
//	va_end(valist);
}
// back up one word to overwrite terminator and append info.
void PipeMsg::AppendFormatVString(const wchar_t * format, va_list valist)
{
//	va_start(valist, format);
	iPos-=2;
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
//	va_end(valist);
}

int PipeMsg::Send(HANDLE hPipe)
{
   DWORD cbWritten;
   BOOL fSuccess = WriteFile( 
      hPipe,                  // pipe handle 
      acBfr,             // message 
      iPos, // message length 
      &cbWritten,             // bytes written 
      NULL);                  // not overlapped 
   if (!fSuccess) 
   {
      printf("WriteFile failed"); 
      return 0;
   }
	return 1;

}

////////////////////////
///  Server side
//
// Listen on pipe and spawn thread.

DWORD WINAPI PipeServerThread(LPVOID lpvParam)
{
	HANDLE hPipe = (HANDLE)lpvParam;	// original created by first thread

   for (;;) 
   { 
 
      // Wait for the client to connect; if it succeeds, 
      // the function returns a nonzero value. If the function
      // returns zero, GetLastError returns ERROR_PIPE_CONNECTED. 
 
      bool fConnected = ConnectNamedPipe(hPipe, NULL) ? 
         TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 
 
      if (fConnected) 
      { 
      // Create a thread for this client. 
		  DWORD dwThreadId;
         HANDLE hThread = CreateThread( 
            NULL,              // no security attribute 
            0,                 // default stack size 
            InstanceThread,    // thread proc
            (LPVOID) hPipe,    // thread parameter 
            0,                 // not suspended 
            &dwThreadId);      // returns thread ID 

         if (hThread == NULL) 
         {
            printf("CreateThread failed"); 
            return 0;
         }
         else CloseHandle(hThread); 
       } 
      else 
        // The client could not connect, so close the pipe. 
         CloseHandle(hPipe); 

	  // create another instance
      hPipe = CreateNamedPipe( 
          L"\\\\.\\pipe\\COMChk_CommPipe",             // pipe name 
          PIPE_ACCESS_INBOUND,       // read access 
          PIPE_TYPE_MESSAGE |       // message type pipe 
          PIPE_READMODE_MESSAGE |   // message-read mode 
          PIPE_WAIT,                // blocking mode 
          PIPE_UNLIMITED_INSTANCES, // max. instances  
          4096,                  // output buffer size 
          4096,                  // input buffer size 
          NMPWAIT_USE_DEFAULT_WAIT, // client time-out 
          NULL);                    // default security attribute 

      if (hPipe == INVALID_HANDLE_VALUE) 
      {
          printf("CreatePipe failed"); 
          return 0;
      }

   } 
   return 1; 

}

//
// buffer format
// 0-3 code (1)
// 4-  unicode string for clsid
void OpenNewObject(char *pvBuf)
{	
	if (sad == NULL) return;
	LPWSTR p = (LPWSTR)(pvBuf+4);	// string for clsid
	sad->SetCOMCtrl(p);	
}

// buffer format:
// 0-3 code (2)
// 4-  cmd line
void OpenNewTestRun(char *pvBuf)
{
	// buffer is 4 bytes followed by a UNICODE string.  Just sleaze it.

	if (sad == NULL) return;
	sad->SetInstance((LPWSTR)(pvBuf+4));
}

// buffer format:
// 0-3 code (4)
// 4-7 exception code
// 8-  unicode string of cmd line
//     unicode string of address (or just second null)
void OutputException(char *pvBuf)
{
	if (sad == NULL) return;
	DWORD rc = *(DWORD *)(pvBuf+4);			// exception code
	LPWSTR pStuff = (LPWSTR)(pvBuf+8);
	LPWSTR pCmdLine = pStuff;
	LPWSTR pAddr = pCmdLine + wcslen(pCmdLine)+1;
	if (*pAddr == 0) 
	{
		pAddr = NULL;				// potentially nothing there.
	}
	sad->OutputException(rc, pCmdLine, pAddr);
}

//
// buffer format:
// 0-3 code (5)
// 4-  null-terminated unicode string of cmd line
void OutputTimeout(char *pvBuf)
{
	if (sad == NULL) return;
	LPWSTR pStuff = (LPWSTR)(pvBuf+4);
	LPWSTR pCmdLine = pStuff;

	sad->OutputTimeout(pCmdLine);
}

//
// buffer format:
// 0-3 code (6)
// 4-  null-terminated unicode string of cmd line
void OutputUnknown(char *pvBuf)
{
	if (sad == NULL) return;
	LPWSTR pStuff = (LPWSTR)(pvBuf+4);
	LPWSTR pCmdLine = pStuff;

	sad->OutputUnknown(pCmdLine);
}

//
// buffer format:
// 0-3 code (3)
// 4-7 error code
// 8-  null terminated unicode string for identity of control
//     null terminated unicode string for text of warning
//     either another null or a null-terminated unicode string of address of problem
void OutputWarning(char *pvBuf)
{
	if (sad == NULL) return;
	DWORD rc = *(DWORD *)(pvBuf+4);
	LPWSTR pStuff = (LPWSTR)(pvBuf+8);
	LPWSTR pIdent = pStuff;
	LPWSTR pText = pIdent + wcslen(pIdent)+1;
	LPWSTR pAddr = pText + wcslen(pText)+1;
	if (*pAddr == 0) 
	{
		pAddr = NULL;				// potentially nothing there.
	}
	sad->OutputWarning(rc, pIdent, pText, pAddr);
}

DWORD WINAPI InstanceThread(LPVOID lpvParam)
{   
	HANDLE hPipe; 
// The thread's parameter is a handle to a pipe instance. 
 
	hPipe = (HANDLE) lpvParam; 
	char acBuf[4096];
	DWORD cbBytesRead;

	while (1)
	{
   // Read client requests from the pipe. 
      BOOL fSuccess = ReadFile( 
         hPipe,        // handle to pipe 
         acBuf,    // buffer to receive data 
         4096, // size of buffer 
         &cbBytesRead, // number of bytes read 
         NULL);        // not overlapped I/O 
      if (! fSuccess || cbBytesRead == 0) 
         break; 

	  DWORD dwType = *(DWORD *)acBuf;
	  switch(dwType)
	  {
	  case 1:
		  OpenNewObject(acBuf);
		  break;
	  case 2:
		  OpenNewTestRun(acBuf);
		  break;
	  case 3:
		  OutputWarning(acBuf);
		  break;
	  case 4:
		  OutputException(acBuf);
		  break;
	  case 5:
		  OutputTimeout(acBuf);
		  break;
	  case 6:
		  OutputUnknown(acBuf);
		  break;
	  }
	}

	DisconnectNamedPipe(hPipe); 
	CloseHandle(hPipe); 

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\comchkhk.cpp ===
/***********************************************************************
* Microsoft COMCHK
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#define _UNICODE
#define UNICODE

#define _CRT_SECURE_NO_DEPRECATE

#define STRICT
#include "windows.h"


#ifdef	_M_IA64

#pragma section(".base", long, read, write)

__declspec(allocate(".base"))
extern "C" IMAGE_DOS_HEADER __ImageBase;

#else	// !_M_IA64

extern "C" IMAGE_DOS_HEADER __ImageBase;

#endif	// !_M_IA64


#pragma section(".shared", read, write, shared)

__declspec(allocate(".shared")) bool fInitialized;
__declspec(allocate(".shared")) wchar_t szExe[MAX_PATH];


void (*pfnCallback)(HWND);


BOOL APIENTRY DllEntry(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      DisableThreadLibraryCalls(hInstance);

      wchar_t szExeT[MAX_PATH];

      DWORD cch = GetModuleFileName(NULL, szExeT, _countof(szExeT));

      if (szExe[0] != L'\0')
      {
	 // This is not the first instance of this being loaded
	 // Don't allow it to be loaded in any process except
	 // those using the same EXE as the first load.

	 return(lstrcmpiW(szExe, szExeT) == 0);
      }

      for (DWORD ich = 0; ich <= cch; ich++)
      {
	 szExe[ich] = szExeT[ich];
      }
   }

   return(TRUE);
}


LRESULT CALLBACK CbtHook(int nCode, WPARAM wParam, LPARAM lParam)
{
   if (nCode == HCBT_ACTIVATE)
   {
      if (pfnCallback != 0)
      {
	 HWND hwnd = (HWND) wParam;

	 (*pfnCallback)(hwnd);

	 if (!SendNotifyMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_CLOSE, 0, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDCANCEL, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDNO, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDCLOSE, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDIGNORE, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDOK, 0))
	 {
	 }
      }
   }

   return(CallNextHookEx(NULL, nCode, wParam, lParam));
}


HHOOK InstallHook(void (*pfn)(HWND))
{
   pfnCallback = pfn;

   if (fInitialized)
   {
      // This is not the initial process

      return(NULL);
   }

   return(SetWindowsHookEx(WH_CBT, &CbtHook, (HMODULE) &__ImageBase, 0));
}


void UninstallHook(HHOOK hhook)
{
   if (hhook != NULL)
   {
      UnhookWindowsHookEx(hhook);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\cache.h ===
/**************************************************************************************
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved. *
***************************************************************************************/
#pragma once

#include <list>

template <class T_ITEM>
class CCache
{
public:
    DWORD Add(__in PWSTR pwszKey, __in T_ITEM tItem);
    T_ITEM Find(__in PWSTR pwszKey);
    VOID Clear(__in_opt VOID *(T_ITEM) = NULL);

private:
    DWORD QuickHash(__in PWSTR pwszString);

    class CNode
    {
      public:
        CNode(__in PWSTR pwszKey, __in DWORD dwHash, __in T_ITEM tItem);
        ~CNode();

        BOOL Is(__in PWSTR pwszKey, __in DWORD dwHash);
        T_ITEM Item();

      private:
        DWORD m_cchKey;
        PWSTR m_pwszKey;
        DWORD m_dwHash;

        T_ITEM m_tItem;
    };

    std::list<CNode> m_Items;
};

template <class T_ITEM>
VOID CCache<T_ITEM>::Clear(__in_opt VOID *pfnHandler(T_ITEM))
{
    while (!m_Items.empty())
    {
        if (pfnHandler != NULL)
        {
            pfnHandler(m_Items.First());
        }

        m_Items.pop_first();
    }
}

template <class T_ITEM>
DWORD CCache<T_ITEM>::Add(__in PWSTR pwszKey, __in T_ITEM tItem)
{
    DWORD dwHash = QuickHash(pwszKey);

    CNode *pNode = new CNode(pwszKey, dwHash, tItem);

    if (pNode == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    m_Items.push_back(*pNode);
    return ERROR_SUCCESS;
}

template <class T_ITEM>
T_ITEM CCache<T_ITEM>::Find(__in PWSTR pwszKey)
{
    DWORD dwHash = QuickHash(pwszKey);

    for (std::list<CNode>::iterator irNode = m_Items.begin(); irNode != m_Items.end(); ++irNode)
    {
        if (irNode->Is(pwszKey, dwHash))
        {
            return irNode->Item();
        }
    }

    return (T_ITEM)0;
}

template <class T_ITEM>
DWORD CCache<T_ITEM>::QuickHash(__in PWSTR pwszString)
{
    DWORD dwHash = 0;

    for (; *pwszString != 0; ++pwszString)
    {
        if (dwHash != 0)
        {
            dwHash = dwHash << 1;
        }

        dwHash += (DWORD)towupper(*pwszString);
    }

    return dwHash;
}

template <class T_ITEM>
CCache<T_ITEM>::CNode::CNode(__in PWSTR pwszKey, __in DWORD dwHash, __in T_ITEM tItem)
{
    m_cchKey = wcslen(pwszKey);
    m_pwszKey = new WCHAR[m_cchKey + 1];
    memcpy(m_pwszKey, pwszKey, (m_cchKey + 1)*sizeof(WCHAR));
    m_dwHash = dwHash;
    m_tItem = tItem;
}

template <class T_ITEM>
CCache<T_ITEM>::CNode::~CNode()
{
    if (m_pwszKey != NULL)
    {
        delete[](m_pwszKey);
    }
}

template <class T_ITEM>
BOOL CCache<T_ITEM>::CNode::Is(__in PWSTR pwszKey, __in DWORD dwHash)
{
    if (dwHash != m_dwHash)
    {
        return FALSE;
    }

    if (wcsicmp(pwszKey, m_pwszKey) != 0)
    {
        return FALSE;
    }

    return TRUE;
}

template <class T_ITEM>
T_ITEM CCache<T_ITEM>::CNode::Item()
{
    return m_tItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\sadoutput.cpp ===
/***********************************************************************
* Microsoft COMCHK
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#define STRICT
#include "windows.h"

#include "verstamp.h"
#include "comchk.h"

// TODO: Filename universalization (must be handled in ComChk core)

//
// Convert a string to something XML likes.
//
#ifndef SET_PTR_VALUE
#define SET_PTR_VALUE(p, v) if ((p) != NULL) (*(p)) = (v)
#endif

DWORD
XmlEncodeString_Alloc(
    __in PWSTR pwszString,
    __out PWSTR *ppwszResult,
    __out_opt DWORD *pcchResult)
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwIdx;
    PWSTR pwszResult;
    DWORD cchResult = 0;
    DWORD cchIllegalChars = 0;

    // Preset
    *ppwszResult = NULL;
    SET_PTR_VALUE(pcchResult, 0);

    // Count special chars
    for (dwIdx = 0; pwszString[dwIdx] != 0; ++dwIdx)
    {
        if (pwszString[dwIdx] == L'&')
        {
            cchResult += 5;
        }
        else if (pwszString[dwIdx] == L'<')
        {
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'>')
        {
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'\'')
        {
            cchResult += 6;
        }
        else if (pwszString[dwIdx] == L'\"')
        {
            cchResult += 6;
        }
        else
        {
            // Non-printable character?
            if (!iswprint(pwszString[dwIdx]) &&
                pwszString[dwIdx] != L'\r' &&
                pwszString[dwIdx] != L'\n' &&
                pwszString[dwIdx] != L'\t')
            {
                ++cchIllegalChars;
            }

            ++cchResult;
        }
	}
	//
	// Do we want to do this?
    if (dwIdx == cchResult &&
        cchIllegalChars == 0)
    {
        goto CLEANUP_AND_RETURN;
    }
    pwszResult = (PWSTR) LocalAlloc(LPTR, (cchResult + 1)*sizeof(WCHAR));

    if (pwszResult == NULL)
    {
        dwResult = ERROR_OUTOFMEMORY;
        goto CLEANUP_AND_RETURN;
    }

    cchResult = 0;

    // Replace special chars
    for (dwIdx = 0; pwszString[dwIdx] != 0; ++dwIdx)
    {
        if (pwszString[dwIdx] == L'&')
        {
            CopyMemory(pwszResult + cchResult, L"&amp;", 10);
            cchResult += 5;
        }
        else if (pwszString[dwIdx] == L'<')
        {
            CopyMemory(pwszResult + cchResult, L"&lt;", 8);
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'>')
        {
            CopyMemory(pwszResult + cchResult, L"&gt;", 8);
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'\'')
        {
            CopyMemory(pwszResult + cchResult, L"&apos;", 12);
            cchResult += 6;
        }
        else if (pwszString[dwIdx] == L'\"')
        {
            CopyMemory(pwszResult + cchResult, L"&quot;", 12);
            cchResult += 6;
        }
        else
        {
            // Non-printable character?
            if (!iswprint(pwszString[dwIdx]) &&
                pwszString[dwIdx] != L'\r' &&
                pwszString[dwIdx] != L'\n' &&
                pwszString[dwIdx] != L'\t')
            {
                pwszResult[cchResult] = L'?';
            }
            else
            {
                pwszResult[cchResult] = pwszString[dwIdx];
            }

            ++cchResult;
        }

	}
    pwszResult[cchResult] = 0;

    *ppwszResult = pwszResult;
    SET_PTR_VALUE(pcchResult, cchResult);

CLEANUP_AND_RETURN:
    return dwResult;
}

void OutputAttributeString(FILE *pf, LPWSTR name, LPWSTR value)
{
	LPWSTR pAlloc = NULL;
	DWORD res = XmlEncodeString_Alloc(value, &pAlloc, NULL);

	if (pAlloc)
	{
		fwprintf_s(pf, L"%ws=\"%ws\" ", name, pAlloc);
		LocalFree(pAlloc);
	} else
	{
		fwprintf_s(pf, L"%ws=\"%ws\" ", name, value);
	}
}

OutInstance::OutInstance(OutCOMCtrl *CC, LPWSTR cmdline, FILE *pf)
{
	_pfsad = pf;
    _CC = CC;
    // Now build node and add attributes
    //

	fwprintf_s(_pfsad, L"<instance ");
    _idx = _CC->GetAndIncrementIdx();
	fwprintf_s(_pfsad, L"idx=\"%d\" ", _idx);
	fwprintf_s(_pfsad, L"target=\"%d\" ", _CC->GetTarget());
    OutputAttributeString(_pfsad, L"cmdline", cmdline);
	fwprintf_s(_pfsad, L"/>\n");
}

void OutInstance::OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr)
{
    int iInterfaceIdx = 0;

    // Text contains IID?
    if (text != NULL &&
        wcsnicmp(text, L"IID =", 5) == 0)
    {
        // Extract IID string
        PWSTR pwszInterface = text + 5 + wcsspn(text + 5, L" \t");
        pwszInterface[38] = 0;
        text = pwszInterface + 39 + wcsspn(pwszInterface + 39, L".,;: \t");

        // Add interface element (or get idx if already added)
        iInterfaceIdx = _CC->AddInterfaceEntry(pwszInterface, _CC->GetTarget());
    }

    int iFileIdx = 0;

    // Address provided?
    if (addr != NULL)
    {
        // Extract file string
        INT cLen = wcscspn(addr, L".,;: \t");
        addr[cLen] = 0;
        PWSTR pwszFile = addr + cLen + 1 + wcscspn(addr + cLen + 1, L"(") + 1;
        cLen = wcscspn(pwszFile, L")");
        pwszFile[cLen] = 0;

        // Add file element (or get idx if already added)
        iFileIdx = _CC->AddFileEntry(pwszFile);
    }

	fwprintf_s(_pfsad, L"<check ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"name=\"%ws\" ", L"COMChk");
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);
    fwprintf_s(_pfsad, L"result=\"0x%04X\" ", rc);

    if (iInterfaceIdx != 0)
    {
        fwprintf_s(_pfsad, L"interface=\"%d\" ", iInterfaceIdx);
    }

/* PJM... Unused
    if (ident)
    {
        SetEntryAttribute(pEle, L"identity", ident);
    }
*/
    if (iFileIdx != 0)
    {
        fwprintf_s(_pfsad, L"file=\"%d\" ", iFileIdx);
    }
    if (addr)
    {
		// addr should not contain special characters
        fwprintf_s(_pfsad, L"address=\"0x%ws\" ", addr);
    }
    if (text)
    {
        OutputAttributeString(_pfsad, L"text", text);
    }
	fwprintf_s(_pfsad, L"/>\n");   
}

void OutInstance::OutputException(DWORD rc, LPWSTR cmdline, LPWSTR addr)
{
    int iFileIdx = 0;

    // Address provided?
    if (addr != NULL)
    {
        // Extract file string
        UINT cLen = wcscspn(addr, L".,;: \t");
        addr[cLen] = 0;
        PWSTR pwszFile = addr + cLen + 1 + wcscspn(addr + cLen + 1, L"(") + 1;
        cLen = wcscspn(pwszFile, L")");
        pwszFile[cLen] = 0;

        // Add file element (or get idx if already added)
        iFileIdx = _CC->AddFileEntry(pwszFile);
    }

	fwprintf_s(_pfsad, L"<exception ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);
    fwprintf_s(_pfsad, L"code=\"0x%08X\" ", rc);

/* PJM... Unused
    if (cmdline)
    {
        SetEntryAttribute(pEle, L"cmdline", cmdline);
    }
*/

    if (iFileIdx != 0)
    {
        fwprintf_s(_pfsad, L"file=\"%d\" ", iFileIdx);
    }
    if (addr)
    {
		// addr should not contain special characters
        fwprintf_s(_pfsad, L"address=\"0x%ws\" ", addr);
    }
	fwprintf_s(_pfsad, L"/>\n");   
}

void OutInstance::OutputTimeout(LPWSTR cmdline)
{
	fwprintf_s(_pfsad, L"<timeout ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);

/* PJM... Unused
    if (cmdline)
    {
        SetEntryAttribute(pEle, L"cmdline", cmdline);
    }
*/
	fwprintf_s(_pfsad, L"/>\n");   
}

void OutInstance::OutputUnknown(LPWSTR cmdline)
{
	fwprintf_s(_pfsad, L"<unknown ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);

/* PJM... Unused
    if (cmdline)
    {
        SetEntryAttribute(pEle, L"cmdline", cmdline);
    }
*/

	fwprintf_s(_pfsad, L"/>\n");  
}

OutInstance::~OutInstance()
{
}

int OutCOMCtrl::GetTarget()
{
    return _idx;
}

BOOL OutCOMCtrl::IsThisClsid(LPWSTR sclsid)
{
    CLSID clsid;
    CLSIDFromString(sclsid, &clsid);
    return IsEqualCLSID(clsid, _clsid);
}

int OutCOMCtrl::GetAndIncrementIdx()
{
    return _sad->GetAndIncrementIdx();
}

int OutCOMCtrl::AddInterfaceEntry(LPWSTR clsid, int control)
{
    return _sad->AddInterfaceEntry(clsid, control);
}

int OutCOMCtrl::AddFileEntry(LPWSTR path)
{
    return _sad->AddFileEntry(path);
}

OutCOMCtrl::OutCOMCtrl(SAD *sad, LPWSTR sclsid, FILE *pf)
{
    _sad = sad;
	_pfsad = pf;
    CLSIDFromString(sclsid, &_clsid);
    _InstCurrent = NULL;
    //
    // Now build node and add attributes
    //

	fwprintf_s(_pfsad, L"<comctrl ");   
    _idx = _sad->GetAndIncrementIdx(); // save for target

	fwprintf_s(_pfsad, L"idx=\"%d\" ", _idx);
    LPOLESTR lpo;
    StringFromCLSID(_clsid, &lpo);
    OutputAttributeString(_pfsad, L"clsid", lpo);
    CoTaskMemFree(lpo);
	fwprintf_s(_pfsad, L"/>\n");
}

void OutCOMCtrl::OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr)
{
    _InstCurrent->OutputWarning(rc, ident, text, addr);
}
void OutCOMCtrl::OutputException(DWORD rc, LPWSTR cmdline, LPWSTR addr)
{
    _InstCurrent->OutputException(rc, cmdline, addr);
}
void OutCOMCtrl::OutputTimeout(LPWSTR cmdline)
{
    _InstCurrent->OutputTimeout(cmdline);
}
void OutCOMCtrl::OutputUnknown(LPWSTR cmdline)
{
    _InstCurrent->OutputUnknown(cmdline);
}
void OutCOMCtrl::SetInstance(LPWSTR wcCmdLine)
{
    if (_InstCurrent) 
	{
		delete _InstCurrent;
		_InstCurrent = NULL;
	}
    _InstCurrent = new OutInstance(this, wcCmdLine, _pfsad);
}

OutCOMCtrl::~OutCOMCtrl()
{
    if (_InstCurrent) delete _InstCurrent;
}

void SAD::OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputWarning(rc, ident, text, addr);

    LeaveCriticalSection(&_cs);
}

void SAD::OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputException(rc, CmdLine, addr);

    LeaveCriticalSection(&_cs);
}

void SAD::OutputTimeout(LPWSTR CmdLine)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputTimeout(CmdLine);

    LeaveCriticalSection(&_cs);
}

void SAD::OutputUnknown(LPWSTR CmdLine)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputUnknown(CmdLine);

    LeaveCriticalSection(&_cs);
}

// Note, this comes from a thread handling the pipe, so we really need to use a critsect.
void SAD::SetInstance(LPWSTR lpCmdLine)
{
    EnterCriticalSection(&_cs);
//	printf("SetInstance, cmd line %ws\n", lpCmdLine);
    _CCCurrent->SetInstance(lpCmdLine);
    LeaveCriticalSection(&_cs);

}

// Note, this comes from a thread handling the pipe, so we really need to use a critsect.
void SAD::SetCOMCtrl(LPWSTR clsid)
{
    EnterCriticalSection(&_cs);
    if (_CCCurrent)
    {
        if(_CCCurrent->IsThisClsid(clsid)) 
        {
            LeaveCriticalSection(&_cs);
            return;
        }
        delete _CCCurrent;
		_CCCurrent = NULL;
    }
    _CCCurrent = new OutCOMCtrl(this, clsid, _pfsad);
    LeaveCriticalSection(&_cs);
}

int SAD::GetAndIncrementIdx()
{
    return _idx++;
}


//
// Fill in attributes of the collection node.
// Split out for tidiness sake.
void SAD::FillInCollectionNode()
{
	fwprintf_s(_pfsad, L"tool=\"COMChk\" ");
	fwprintf_s(_pfsad, L"version=\"%d.%d.%d.%d\" ", rmj, rmm, rup, qfe);
    WCHAR wszMachine[256];
    DWORD csz = 256;
    GetComputerNameW(wszMachine, &csz);

	OutputAttributeString(_pfsad, L"machine", wszMachine);

    csz = 256;
    WCHAR wszDomain[256];
    GetComputerNameExW(ComputerNameDnsDomain, wszDomain, &csz);

    OutputAttributeString(_pfsad, L"domain", wszDomain);

    UINT64 uTime;
    GetSystemTimeAsFileTime((PFILETIME)&uTime);

    fwprintf_s(_pfsad, L"time=\"0x%016I64X\" ", uTime);
}

int SAD::AddInterfaceEntry(LPWSTR clsid, int control)
{
    // Create the key by combining the clsid and control index
    DWORD cchClsId = wcslen(clsid);
    LPWSTR pwszKey = new WCHAR[cchClsId + 64];
    wsprintf(pwszKey, L"%s.%i", clsid, control);

//	int iIdx = 0;
    int iIdx = _InterfaceCache.Find(pwszKey);

    // Already Added?
    if (iIdx != 0)
    {
        goto CLEANUP_AND_RETURN;
    }

    iIdx = GetAndIncrementIdx();

	fwprintf_s(_pfsad, L"<comint ");
	fwprintf_s(_pfsad, L"idx=\"%d\" ", iIdx);
    OutputAttributeString(_pfsad, L"clsid", clsid);
    fwprintf_s(_pfsad, L"control=\"%d\" ", control);
	fwprintf_s(_pfsad, L"/>\n");

    // Cache
    _InterfaceCache.Add(pwszKey, iIdx);

CLEANUP_AND_RETURN:
    delete[] pwszKey;
    return iIdx;
}

int SAD::AddFileEntry(LPWSTR path)
{
//    int iIdx = 0;
 int iIdx = _FileCache.Find(path);

    // Already Added?
    if (iIdx != 0)
    {
        goto CLEANUP_AND_RETURN;
    }

    iIdx = GetAndIncrementIdx();

	fwprintf_s(_pfsad, L"<file ");
	fwprintf_s(_pfsad, L"idx=\"%d\" ", iIdx);
    OutputAttributeString(_pfsad, L"path", path);
	fwprintf_s(_pfsad, L"/>\n");

    // Cache
    _FileCache.Add(path, iIdx);

CLEANUP_AND_RETURN:
    return iIdx;
}

SAD::SAD(wchar_t *pXMLFile)
{
    InitializeCriticalSection(&_cs);
    _idx = 0;

    _CCCurrent = NULL;
	errno_t errno;
	errno = _wfopen_s(&_pfsad, pXMLFile, L"wt");
	if (errno)
	{
		printf("ERROR opening SAD output file, error number %d\n", errno);
	}

    //
    // Now set up beginning goo.
    //
	fwprintf_s(_pfsad, L"<?xml version=\"1.0\"?>\n");
	fwprintf_s(_pfsad, L"<securityAnalysisData>\n");

    // now add the one and only collection node.
	fwprintf_s(_pfsad, L"<collection ");
    FillInCollectionNode();
	fwprintf_s(_pfsad, L">\n");

    // now add platform node.

	fwprintf_s(_pfsad, L"<platform ");
    OSVERSIONINFOEX VersionInfo = {sizeof(OSVERSIONINFOEX)};
    GetVersionEx((POSVERSIONINFO)&VersionInfo);

    UINT64 uTime;
    GetSystemTimeAsFileTime((PFILETIME)&uTime);

	fwprintf_s(_pfsad, L"idx=\"%d\" ", _idx++);
    fwprintf_s(_pfsad, L"majorVersion=\"%d\" ", VersionInfo.dwMajorVersion);
    fwprintf_s(_pfsad, L"minorVersion=\"%d\" ", VersionInfo.dwMinorVersion);
    fwprintf_s(_pfsad, L"buildNumber=\"%d\" ", VersionInfo.dwBuildNumber);
    fwprintf_s(_pfsad, L"platformId=\"%d\" ", VersionInfo.dwPlatformId);
    OutputAttributeString(_pfsad, L"csdVersion", VersionInfo.szCSDVersion);
    fwprintf_s(_pfsad, L"servicePackMajor=\"%d\" ", VersionInfo.wServicePackMajor);
    fwprintf_s(_pfsad, L"servicePackMinor=\"%d\" ", VersionInfo.wServicePackMinor);
    fwprintf_s(_pfsad, L"suiteMask=\"%d\" ", VersionInfo.wSuiteMask);
    fwprintf_s(_pfsad, L"productType=\"%d\" ", VersionInfo.wProductType);
    fwprintf_s(_pfsad, L"time=\"0x%016I64X\" ", uTime);

	fwprintf_s(_pfsad, L"/>\n");
}

SAD::~SAD()
{
    HRESULT hr;
    VARIANT var;

	fwprintf_s(_pfsad, L"</collection>\n");
	fwprintf_s(_pfsad, L"</securityAnalysisData>\n");
	fclose(_pfsad);

	if (_CCCurrent != NULL)
	{
		delete _CCCurrent;
		_CCCurrent = NULL;
	}
    DeleteCriticalSection(&_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\comchk.h ===
#pragma once

#include "cache.h"

//
// COMChk definitions.

// Globals.

class SAD;
extern SAD *sad;

//
// warning routines.
bool FindWarningInfo(DWORD rc, LPWSTR *pName, int *pLvl);

// Pipe stuff for interprocess comm
DWORD WINAPI PipeServerThread(LPVOID lpvParam);
DWORD WINAPI InstanceThread(LPVOID lpvParam);
class PipeMsg
{
	char acBfr[4092];
	int iPos;
public:
	void AddDWORD(DWORD i);
	void AddString(LPWSTR str);
	void AddFormatString(const wchar_t * format, ...);
	void AppendFormatString(const wchar_t * format, ...);
	void AddFormatVString(const wchar_t * format, va_list argptr);
	void AppendFormatVString(const wchar_t * format, va_list argptr);
	int Send(HANDLE hPipe);
	PipeMsg();
};

// SAD output classes

class OutCOMCtrl;

class OutInstance
{
	int _idx;
	OutCOMCtrl *_CC;
	FILE *_pfsad;
public:
	OutInstance(OutCOMCtrl *CC, LPWSTR cmdline, FILE *pf);
	void OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr);
	void OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr);
	void OutputTimeout(LPWSTR CmdLine);
	void OutputUnknown(LPWSTR CmdLine);

	~OutInstance();
};

class OutCOMCtrl
{
	FILE *_pfsad;
	int _idx;
	SAD *_sad;
	CLSID _clsid;
	OutInstance *_InstCurrent;
public:
	OutCOMCtrl(SAD *, LPWSTR, FILE *);
	~OutCOMCtrl();
	BOOL IsThisClsid(LPWSTR clsid);
	int GetTarget();
	void SetInstance(LPWSTR wcCmdLine);
	void OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr);
	void OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr);
	void OutputTimeout(LPWSTR CmdLine);
	void OutputUnknown(LPWSTR CmdLine);
	int GetAndIncrementIdx();

    int AddInterfaceEntry(LPWSTR clsid, int target);
    int AddFileEntry(LPWSTR path);
};

class SAD
{
	CRITICAL_SECTION _cs;
	FILE *_pfsad;
	OutCOMCtrl *_CCCurrent;
	void FillInCollectionNode();
	int _idx;
    CCache<INT> _InterfaceCache;
    CCache<INT> _FileCache;
public:
	SAD(wchar_t *XMLFile);
	~SAD();
	void SetCOMCtrl(LPWSTR clsid);
	void SetInstance(LPWSTR lpCmdLine);
	void OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr);
	void OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr);
	void OutputTimeout(LPWSTR CmdLine);
	void OutputUnknown(LPWSTR CmdLine);
	int GetAndIncrementIdx();

    int AddInterfaceEntry(LPWSTR clsid, int target);
    int AddFileEntry(LPWSTR path);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\pipethreads.cpp ===
#include <stdio.h>

#define STRICT
#include "windows.h"

#include "verstamp.h"
#include "comchk.h"

/////////////////////////
//  Client side
//
//  Simple pipe

PipeMsg::PipeMsg()
{
	iPos = 0;
}
void PipeMsg::AddDWORD(DWORD i)
{
	DWORD *p = (DWORD *)(acBfr+iPos);
	*p = i;
	iPos += sizeof(DWORD);
}

void PipeMsg::AddString(LPWSTR str)
{
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	wcscpy(p, str);
	iPos += 2+2*wcslen(str);
}

void PipeMsg::AddFormatString(const wchar_t * format, ...)
{
	va_list valist;
	va_start(valist, format);
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
	va_end(valist);
}
// back up one word to overwrite terminator and append info.
void PipeMsg::AppendFormatString(const wchar_t * format, ...)
{
	va_list valist;
	va_start(valist, format);
	iPos-=2;
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
	va_end(valist);
}

void PipeMsg::AddFormatVString(const wchar_t * format, va_list valist)
{
//	va_start(valist, format);
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
//	va_end(valist);
}
// back up one word to overwrite terminator and append info.
void PipeMsg::AppendFormatVString(const wchar_t * format, va_list valist)
{
//	va_start(valist, format);
	iPos-=2;
	LPWSTR p = (WCHAR *)(acBfr+iPos);
	int i = _vsnwprintf(p, (4096-iPos)/2, format, valist);
	iPos += (2+2*i);
	
//	va_end(valist);
}

int PipeMsg::Send(HANDLE hPipe)
{
   DWORD cbWritten;
   BOOL fSuccess = WriteFile( 
      hPipe,                  // pipe handle 
      acBfr,             // message 
      iPos, // message length 
      &cbWritten,             // bytes written 
      NULL);                  // not overlapped 
   if (!fSuccess) 
   {
      printf("WriteFile failed"); 
      return 0;
   }
	return 1;

}

////////////////////////
///  Server side
//
// Listen on pipe and spawn thread.

DWORD WINAPI PipeServerThread(LPVOID lpvParam)
{
	HANDLE hPipe = (HANDLE)lpvParam;	// original created by first thread

   for (;;) 
   { 
 
      // Wait for the client to connect; if it succeeds, 
      // the function returns a nonzero value. If the function
      // returns zero, GetLastError returns ERROR_PIPE_CONNECTED. 
 
      bool fConnected = ConnectNamedPipe(hPipe, NULL) ? 
         TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 
 
      if (fConnected) 
      { 
      // Create a thread for this client. 
		  DWORD dwThreadId;
         HANDLE hThread = CreateThread( 
            NULL,              // no security attribute 
            0,                 // default stack size 
            InstanceThread,    // thread proc
            (LPVOID) hPipe,    // thread parameter 
            0,                 // not suspended 
            &dwThreadId);      // returns thread ID 

         if (hThread == NULL) 
         {
            printf("CreateThread failed"); 
            return 0;
         }
         else CloseHandle(hThread); 
       } 
      else 
        // The client could not connect, so close the pipe. 
         CloseHandle(hPipe); 

	  // create another instance
      hPipe = CreateNamedPipe( 
          L"\\\\.\\pipe\\COMChk_CommPipe",             // pipe name 
          PIPE_ACCESS_INBOUND,       // read access 
          PIPE_TYPE_MESSAGE |       // message type pipe 
          PIPE_READMODE_MESSAGE |   // message-read mode 
          PIPE_WAIT,                // blocking mode 
          PIPE_UNLIMITED_INSTANCES, // max. instances  
          4096,                  // output buffer size 
          4096,                  // input buffer size 
          NMPWAIT_USE_DEFAULT_WAIT, // client time-out 
          NULL);                    // default security attribute 

      if (hPipe == INVALID_HANDLE_VALUE) 
      {
          printf("CreatePipe failed"); 
          return 0;
      }

   } 
   return 1; 

}

//
// buffer format
// 0-3 code (1)
// 4-  unicode string for clsid
void OpenNewObject(char *pvBuf)
{	
	if (sad == NULL) return;
	LPWSTR p = (LPWSTR)(pvBuf+4);	// string for clsid
	sad->SetCOMCtrl(p);	
}

// buffer format:
// 0-3 code (2)
// 4-  cmd line
void OpenNewTestRun(char *pvBuf)
{
	// buffer is 4 bytes followed by a UNICODE string.  Just sleaze it.

	if (sad == NULL) return;
	sad->SetInstance((LPWSTR)(pvBuf+4));
}

// buffer format:
// 0-3 code (4)
// 4-7 exception code
// 8-  unicode string of cmd line
//     unicode string of address (or just second null)
void OutputException(char *pvBuf)
{
	if (sad == NULL) return;
	DWORD rc = *(DWORD *)(pvBuf+4);			// exception code
	LPWSTR pStuff = (LPWSTR)(pvBuf+8);
	LPWSTR pCmdLine = pStuff;
	LPWSTR pAddr = pCmdLine + wcslen(pCmdLine)+1;
	if (*pAddr == 0) 
	{
		pAddr = NULL;				// potentially nothing there.
	}
	sad->OutputException(rc, pCmdLine, pAddr);
}

//
// buffer format:
// 0-3 code (5)
// 4-  null-terminated unicode string of cmd line
void OutputTimeout(char *pvBuf)
{
	if (sad == NULL) return;
	LPWSTR pStuff = (LPWSTR)(pvBuf+4);
	LPWSTR pCmdLine = pStuff;

	sad->OutputTimeout(pCmdLine);
}

//
// buffer format:
// 0-3 code (6)
// 4-  null-terminated unicode string of cmd line
void OutputUnknown(char *pvBuf)
{
	if (sad == NULL) return;
	LPWSTR pStuff = (LPWSTR)(pvBuf+4);
	LPWSTR pCmdLine = pStuff;

	sad->OutputUnknown(pCmdLine);
}

//
// buffer format:
// 0-3 code (3)
// 4-7 error code
// 8-  null terminated unicode string for identity of control
//     null terminated unicode string for text of warning
//     either another null or a null-terminated unicode string of address of problem
void OutputWarning(char *pvBuf)
{
	if (sad == NULL) return;
	DWORD rc = *(DWORD *)(pvBuf+4);
	LPWSTR pStuff = (LPWSTR)(pvBuf+8);
	LPWSTR pIdent = pStuff;
	LPWSTR pText = pIdent + wcslen(pIdent)+1;
	LPWSTR pAddr = pText + wcslen(pText)+1;
	if (*pAddr == 0) 
	{
		pAddr = NULL;				// potentially nothing there.
	}
	sad->OutputWarning(rc, pIdent, pText, pAddr);
}

DWORD WINAPI InstanceThread(LPVOID lpvParam)
{   
	HANDLE hPipe; 
// The thread's parameter is a handle to a pipe instance. 
 
	hPipe = (HANDLE) lpvParam; 
	char acBuf[4096];
	DWORD cbBytesRead;

	while (1)
	{
   // Read client requests from the pipe. 
      BOOL fSuccess = ReadFile( 
         hPipe,        // handle to pipe 
         acBuf,    // buffer to receive data 
         4096, // size of buffer 
         &cbBytesRead, // number of bytes read 
         NULL);        // not overlapped I/O 
      if (! fSuccess || cbBytesRead == 0) 
         break; 

	  DWORD dwType = *(DWORD *)acBuf;
	  switch(dwType)
	  {
	  case 1:
		  OpenNewObject(acBuf);
		  break;
	  case 2:
		  OpenNewTestRun(acBuf);
		  break;
	  case 3:
		  OutputWarning(acBuf);
		  break;
	  case 4:
		  OutputException(acBuf);
		  break;
	  case 5:
		  OutputTimeout(acBuf);
		  break;
	  case 6:
		  OutputUnknown(acBuf);
		  break;
	  }
	}

	DisconnectNamedPipe(hPipe); 
	CloseHandle(hPipe); 

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\comchkhk.cpp ===
/***********************************************************************
* Microsoft COMCHK
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#define _UNICODE
#define UNICODE

#define _CRT_SECURE_NO_DEPRECATE

#define STRICT
#include "windows.h"


#ifdef	_M_IA64

#pragma section(".base", long, read, write)

__declspec(allocate(".base"))
extern "C" IMAGE_DOS_HEADER __ImageBase;

#else	// !_M_IA64

extern "C" IMAGE_DOS_HEADER __ImageBase;

#endif	// !_M_IA64


#pragma section(".shared", read, write, shared)

__declspec(allocate(".shared")) bool fInitialized;
__declspec(allocate(".shared")) wchar_t szExe[MAX_PATH];


void (*pfnCallback)(HWND);


BOOL APIENTRY DllEntry(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      DisableThreadLibraryCalls(hInstance);

      wchar_t szExeT[MAX_PATH];

      DWORD cch = GetModuleFileName(NULL, szExeT, _countof(szExeT));

      if (szExe[0] != L'\0')
      {
	 // This is not the first instance of this being loaded
	 // Don't allow it to be loaded in any process except
	 // those using the same EXE as the first load.

	 return(lstrcmpiW(szExe, szExeT) == 0);
      }

      for (DWORD ich = 0; ich <= cch; ich++)
      {
	 szExe[ich] = szExeT[ich];
      }
   }

   return(TRUE);
}


LRESULT CALLBACK CbtHook(int nCode, WPARAM wParam, LPARAM lParam)
{
   if (nCode == HCBT_ACTIVATE)
   {
      if (pfnCallback != 0)
      {
	 HWND hwnd = (HWND) wParam;

	 (*pfnCallback)(hwnd);

	 if (!SendNotifyMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_CLOSE, 0, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDCANCEL, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDNO, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDCLOSE, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDIGNORE, 0))
	 {
	 }

	 else if (!IsWindow(hwnd) || !SendNotifyMessage(hwnd, WM_COMMAND, IDOK, 0))
	 {
	 }
      }
   }

   return(CallNextHookEx(NULL, nCode, wParam, lParam));
}


HHOOK InstallHook(void (*pfn)(HWND))
{
   pfnCallback = pfn;

   if (fInitialized)
   {
      // This is not the initial process

      return(NULL);
   }

   return(SetWindowsHookEx(WH_CBT, &CbtHook, (HMODULE) &__ImageBase, 0));
}


void UninstallHook(HHOOK hhook)
{
   if (hhook != NULL)
   {
      UnhookWindowsHookEx(hhook);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\warninfo.cpp ===
#include <stdio.h>

#define STRICT
#include "windows.h"

#include "verstamp.h"
#include "comchk.h"

typedef struct 
{
	LPWSTR Name;
	int Lvl;
} WARNLVLINFO, *PWARNLVLINFO;

WARNLVLINFO wliUninitPtr = {L"UninitializedPointer",1};
WARNLVLINFO wliUninitMem = {L"UninitializedMemory", 2};
WARNLVLINFO wliRetCode = {L"IncorrectReturnCode",8};
WARNLVLINFO wliDebug = {L"DebugCode", 1};
WARNLVLINFO wliConfirm = {L"Confirmation", 1};
WARNLVLINFO wliInfo = {L"Information", 9};
WARNLVLINFO wliRefCnt = {L"ReferenceCount", 3};
WARNLVLINFO wliFail = {L"TestFailure",1};
WARNLVLINFO wliIOS = {L"IObjectSafety",2};
WARNLVLINFO wliBad = {L"BadCode", 5};

typedef struct
{
	DWORD w;
	PWARNLVLINFO pi;
} WARNING, *PWARNING;

WARNING Warnings[] =
{
	{0x0101, &wliDebug},
	{0x0102, &wliDebug},
	{0x0103, &wliDebug},
	{0x0104, &wliDebug},
	{0x0105, &wliDebug},
	{0x0106, &wliDebug},
	{0x0107, &wliInfo},
	{0x0201, &wliInfo},
	{0x0301, &wliFail},
	{0x0302, &wliFail},
	{0x0303, &wliFail},
	{0x0401, &wliRetCode},
	{0x0402, &wliUninitPtr},
	{0x0501, &wliInfo},
	{0x0502, &wliBad},
	{0x0601, &wliInfo},
	{0x0602, &wliBad},
	{0x0701, &wliInfo},
	{0x0801, &wliInfo},
	{0x0901, &wliBad},
	{0x0902, &wliInfo},
	{0x0903, &wliBad},
	{0x0904, &wliBad},
	{0x0905, &wliInfo},
	{0x0906, &wliInfo},
	{0x0A01, &wliBad},
	{0x0A02, &wliIOS},
	{0x0A03, &wliRetCode},
	{0x0B01, &wliBad},
	{0x0B02, &wliIOS},
	{0x0B03, &wliBad},
	{0x0B04, &wliBad},
	{0x0B05, &wliBad},
	{0x0B06, &wliBad},
	{0x0B07, &wliBad},
	{0x0B08, &wliIOS},
	{0x0B09, &wliBad},
	{0x0B0A, &wliBad},
	{0x0B0B, &wliBad},
	{0x0B0C, &wliIOS},
	{0x0B0D, &wliBad},
	{0x0B0E, &wliBad},
	{0x0B0F, &wliBad},
	{0x0C01, &wliUninitPtr},
	{0x0C02, &wliUninitPtr},
	{0x0C03, &wliBad},
	{0x0C04, &wliUninitMem},
	{0x0C05, &wliUninitMem},
	{0x0C06, &wliUninitMem},
	{0x0C07, &wliBad},
	{0x0D01, &wliBad},
	{0x0D02, &wliBad},
	{0x0D03, &wliRetCode},
	{0x0D04, &wliUninitPtr},
	{0x0D05, &wliInfo},
	{0x0D06, &wliRetCode},
	{0x0D07, &wliUninitPtr},
	{0x0D08, &wliBad},
	{0x0D09, &wliRetCode},
	{0x0D0A, &wliUninitPtr},
	{0x0E01, &wliBad},
	{0x0E02, &wliBad},
	{0x0E03, &wliBad},
	{0x0E04, &wliBad},
	{0x0E05, &wliUninitPtr},
	{0x0E06, &wliInfo},
	{0x0E07, &wliBad},
	{0x0F01, &wliRetCode},
	{0x0F02, &wliBad},
	{0x0F03, &wliBad},
	{0x0F04, &wliRetCode},
	{0x0F05, &wliBad},
	{0x0F06, &wliRetCode},
	{0x0F07, &wliBad},
	{0x0F08, &wliUninitPtr},
	{0x0F09, &wliRetCode},	
	{0x0F0A, &wliUninitPtr},
	{0x0F0B, &wliRetCode},
	{0x0F0C, &wliUninitPtr},
	{0x0F0D, &wliRetCode},
	{0x0F0E, &wliBad},
	{0x1001, &wliBad},
	{0x1002, &wliBad},
	{0x1003, &wliBad},
	{0x1004, &wliBad},
	{0x1005, &wliBad},
	{0x1006, &wliBad},
	{0x1007, &wliBad},
	{0x1008, &wliBad},
	{0x1009, &wliBad},
	{0x100A, &wliBad},
	{0x100B, &wliBad},
	{0x1101, &wliBad},
	{0x1102, &wliBad},
	{0x1103, &wliBad},
	{0x1104, &wliBad},
	{0x1105, &wliBad},
	{0x1106, &wliBad},
	{0x1107, &wliBad},
	{0x1108, &wliBad},
	{0x1109, &wliBad},
	{0x1201, &wliBad},
	{0x1202, &wliBad},
	{0x1203, &wliBad},
	{0x1204, &wliBad},
	{0x1205, &wliBad},
	{0x1206, &wliBad},
	{0x1207, &wliBad},
	{0x1208, &wliBad},
	{0x1209, &wliBad},
	{0x1301, &wliBad},
	{0x1302, &wliBad},
	{0x1303, &wliBad},
	{0x1304, &wliBad},
	{0x1305, &wliBad},
	{0x1306, &wliBad},
	{0x1307, &wliBad},
	{0x1308, &wliBad},
	{0x1309, &wliBad},
	{0x1401, &wliBad},
	{0x1402, &wliBad},
	{0x1403, &wliBad},
	{0x1404, &wliBad},
	{0x1405, &wliBad},
	{0x1406, &wliBad},
	{0x1407, &wliBad},
	{0x1408, &wliBad},
	{0x1409, &wliBad},
	{0x1501, &wliBad},
	{0x1502, &wliRetCode},
	{0x1503, &wliBad},
	{0x1504, &wliBad},
	{0x1505, &wliBad},
	{0x1506, &wliBad},
	{0x1507, &wliBad},
	{0x1508, &wliBad},
	{0x1509, &wliBad},
	{0x150A, &wliBad},
	{0x150B, &wliBad},
	{0x150C, &wliBad},
	{0x15FF, &wliBad},
	{0x1601, &wliBad},
	{0x1602, &wliBad},
	{0x1603, &wliBad},
	{0x1604, &wliRetCode},
	{0x1605, &wliRetCode},
	{0x1606, &wliRetCode},
	{0x1607, &wliBad},
	{0x1608, &wliRetCode},
	{0x1609, &wliBad},
	{0x160A, &wliRetCode},
	{0x1701, &wliRetCode},
	{0x1702, &wliBad},
	{0x1703, &wliBad},
	{0x1704, &wliBad},
	{0x1705, &wliBad},
	{0x1706, &wliBad},
	{0x1707, &wliBad},
	{0x1708, &wliBad},
	{0x1709, &wliBad},
	{0x170A, &wliBad},
	{0x170B, &wliBad},
	{0x170C, &wliBad},
	{0x170D, &wliBad},
	{0x170E, &wliBad},
	{0x1801, &wliInfo},
	{0x1802, &wliInfo},
	{0x1901, &wliBad},
	{0x1902, &wliInfo},
	{0x1903, &wliInfo},
	{0x1904, &wliRefCnt},
	{0x1905, &wliRefCnt},
	{0x1906, &wliBad},
	{0x1907, &wliBad},
	{0x1908, &wliRefCnt},
	{0x1909, &wliBad},
	{0x190A, &wliBad},
	{0x1B01, &wliBad},
	{0x1B02, &wliBad},
	{0x1B03, &wliBad},
	{0x1B04, &wliBad},
	{0x1B05, &wliBad},
	{0x1C01, &wliBad},
	{0x1C02, &wliBad},
	{0x1C03, &wliBad},
	{0x1C04, &wliBad},
	{0x1C05, &wliBad},
	{0x1C06, &wliBad},
	{0x1C07, &wliBad},
	{0x1C08, &wliBad},
	{0x1C09, &wliBad},
	{0x1C0A, &wliBad},
	{0x1C0B, &wliBad},
	{0x1D01, &wliBad},
	{0x1D02, &wliBad},
	{0x1D03, &wliBad},
	{0x1D04, &wliBad},
	{0x1E01, &wliBad},
	{0x1E02, &wliBad},
	{0x1E03, &wliBad},
	{0x1E04, &wliBad},
	{0x1E05, &wliBad},
	{0x1E06, &wliBad},
	{0x1E07, &wliBad},
	{0x1E08, &wliBad},
	{0x1E09, &wliBad},
	{0x1E0A, &wliBad},
	{0x1E0B, &wliBad},
	{0x1E0C, &wliBad},
	{0x1F01, &wliBad},
	{0x1F02, &wliBad},
	{0x1F03, &wliInfo},
	{0x1F04, &wliBad},
	{0x1F05, &wliBad},
	{0x1F06, &wliUninitPtr},
	{0x2001, &wliInfo},
	{0x2101, &wliBad},
	{0x2102, &wliBad},
	{0x2103, &wliBad},
	{0x2104, &wliBad},
	{0x2105, &wliBad},
	{0x2106, &wliBad},
	{0x2201, &wliBad},
	{0x2202, &wliBad},
	{0x2203, &wliFail},
	{0x2204, &wliBad},
	{0x2205, &wliBad},
	{0x2206, &wliBad},
	{0x2207, &wliFail},
	{0x2208, &wliBad},
	{0x2209, &wliFail},
	{0x220A, &wliInfo},
	{0x220B, &wliBad},
	{0x220C, &wliBad},
	{0x220D, &wliInfo},
	{0x220E, &wliBad},
	{0x220F, &wliBad},
	{0x2210, &wliBad},
	{0x2301, &wliFail},
	{0x2302, &wliBad},
	{0x2303, &wliBad},
	{0x2304, &wliBad},
	{0x2401, &wliBad},
	{0x2402, &wliBad},
	{0x2403, &wliBad},
	{0x2404, &wliBad},
	{0x2405, &wliBad},
	{0x2406, &wliFail},
	{0x2407, &wliFail},
	{0x2408, &wliBad},
	{0x2409, &wliBad},
	{0x240A, &wliFail},
	{0x240B, &wliBad},
	{0x240C, &wliBad},
	{0x240D, &wliBad},
	{0x240E, &wliBad},
	{0x240F, &wliBad},
	{0x2410, &wliBad},
	{0x2411, &wliBad},
	{0x2501, &wliFail},
	{0x2502, &wliFail},
	{0x2503, &wliBad},
	{0x2504, &wliBad},
	{0x2505, &wliBad},
	{0x2506, &wliBad},
	{0x2507, &wliBad},
	{0x2508, &wliBad},
	{0x2509, &wliBad},
	{0x2601, &wliFail},
	{0x2602, &wliInfo},
	{0x2603, &wliBad},
	{0x2604, &wliInfo},
	{0x2701, &wliInfo},
	{0x2702, &wliBad},
	{0x2703, &wliInfo},
	{0x2704, &wliBad},
	{0x2705, &wliBad},
	{0x2706, &wliBad},
	{0x2707, &wliBad},
	{0x2708, &wliUninitPtr},
	{0x2709, &wliBad},
	{0x270A, &wliRetCode},
	{0x270B, &wliBad},
	{0x270C, &wliInfo},
	{0x270D, &wliBad},
	{0x270E, &wliUninitPtr},
	{0x270F, &wliUninitPtr},
	{0x2710, &wliInfo},
	{0x2711, &wliInfo},
	{0x2712, &wliInfo},
	{0x2713, &wliInfo},
	{0x2714, &wliConfirm},
	{0x2801, &wliInfo},
	{0x2802, &wliUninitPtr},
	{0x2803, &wliInfo},
	{0x2804, &wliInfo},
	{0x2901, &wliBad},
	{0x2902, &wliUninitPtr},
	{0x2903, &wliUninitPtr},
	{0x2904, &wliInfo},
	{0x2905, &wliBad},
	{0x2906, &wliBad},
	{0x2A01, &wliBad},
	{0x2A02, &wliBad},
	{0x2A03, &wliInfo},
	{0x2B01, &wliFail},
	{0x2B02, &wliUninitPtr},
	{0x2B03, &wliBad},
	{0x2B04, &wliInfo},
	{0x2B05, &wliConfirm},
	{0x2C01, &wliInfo},
	{0x2D01, &wliInfo},
	{0x2D02, &wliUninitPtr},
	{0x2D03, &wliInfo},
	{0x2D04, &wliUninitPtr},
	{0x2D05, &wliInfo},
	{0x2D06, &wliUninitPtr},
	{0x2D07, &wliBad},
	{0x2D08, &wliInfo},
	{0x2D09, &wliBad},
	{0x2E01, &wliBad},
	{0x2E02, &wliBad},
	{0x2E03, &wliBad},
	{0x2E04, &wliBad},
	{0x2E05, &wliUninitPtr},
	{0x2E06, &wliInfo},
	{0x2E07, &wliBad},
	{0x2F01, &wliBad},
	{0x2F02, &wliBad},
	{0x2F03, &wliBad},
	{0x2F04, &wliBad},
	{0x2F05, &wliBad},
	{0x2F06, &wliBad},
	{0x2F07, &wliBad},
	{0x2F08, &wliBad},
	{0x2F09, &wliUninitPtr},
	{0x2F0A, &wliRetCode},
	{0x2F0B, &wliUninitPtr},
	{0x2F0C, &wliRetCode},
	{0x2F0D, &wliRetCode},
	{0x2F0E, &wliBad},
	{0x2F0F, &wliUninitPtr},
	{0x2F10, &wliInfo},
	{0x2F11, &wliInfo},
	{0x2F12, &wliBad},
	{0x2F13, &wliUninitPtr},
	{0x2F14, &wliInfo},
	{0x2F15, &wliBad},
	{0x3001, &wliBad},
	{0x3002, &wliBad},
	{0x3003, &wliBad},
	{0x3004, &wliBad},
	{0x3005, &wliBad},
	{0x3006, &wliBad},
	{0x3007, &wliFail},
	{0x3008, &wliFail},
	{0x3009, &wliFail},
	{0x300A, &wliBad},
	{0x300B, &wliFail},
	{0x300C, &wliBad},
	{0x300D, &wliBad},
	{0x300E, &wliBad},
	{0x3101, &wliBad},
	{0x3102, &wliBad},
	{0x3103, &wliBad},
	{0x3104, &wliBad},
	{0x3105, &wliBad},
	{0x3106, &wliBad},
	{0x3107, &wliBad},
	{0x3108, &wliFail},
	{0x3109, &wliFail},
	{0x310A, &wliFail},
	{0x310B, &wliBad},
	{0x310C, &wliFail},
	{0x310D, &wliBad},
	{0x310E, &wliBad},
	{0x310F, &wliBad},
	{0x3201, &wliBad},
	{0XFFFF, &wliFail},

};

// Binary search!  Remember Knuth!
PWARNLVLINFO FindWarnInfo(DWORD rc, int l, int u)
{
	if (l >= u) return NULL;
	int t = (l+u) >>1;
	if (rc == Warnings[t].w) return Warnings[t].pi;
	if (rc < Warnings[t].w) return FindWarnInfo(rc, l, t);
	return FindWarnInfo(rc, t+1, u);
}
bool FindWarningInfo(DWORD rc, LPWSTR *pName, int *pLvl)
{
	PWARNLVLINFO p = FindWarnInfo(rc, 0, sizeof(Warnings)/sizeof(Warnings[0]));
	if (p == NULL)	return false;

	*pName = p->Name;
	*pLvl = p->Lvl;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\comchk.cpp ===
/***********************************************************************
* Microsoft COMCHK
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#define _CRT_SECURE_NO_DEPRECATE
// #define _HAS_EXCEPTIONS 0

#include <map>
#include <share.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>

#define STRICT
#include "windows.h"

#include "activscp.h"
#include "comcat.h"
#include "dispex.h"
#include "idispids.h"
#include "msdatsrc.h"
#include "mshtml.h"
#include "mshtmdid.h"
#include "mshtmhst.h"
#include "objsafe.h"
#include "perhist.h"
#include "shlguid.h"

#include "delayimp.h"

#include "verstamp.h"
#include "comchk.h"

#define DBG_PRINTEXCEPTION_C  0x40010006
#define DBG_RIPEXCEPTION      0x40010007

#define EXCEPTION_MSVC	      0xE06D7363    // 0xE0000000 | 'msc'
#define EXCEPTION_COMPLUS     0xE0434F4D    // 0xE0000000 | 'COM'
#define EXCEPTION_MSXML       0xE0000001

#ifndef IID_PPV_ARGS
#define IID_PPV_ARGS(ppType) __uuidof(**(ppType)), (static_cast<IUnknown *>(*(ppType)),reinterpret_cast<void**>(ppType))
#endif


struct __declspec(uuid("BBCBDE60-C3FF-11CE-8350-444553540000")) Folder;
struct __declspec(uuid("F0D2D8EF-3890-11D2-BF8B-00C04FB93661")) Folder2;
struct __declspec(uuid("A7AE5F64-C4D7-4D7F-9307-4D24EE54B841")) Folder3;
struct __declspec(uuid("c7c3f5a4-88a3-11d0-abcb-00a0c90fffc0")) IFile;		    // SCRRUN.DLL
struct __declspec(uuid("0AB5A3D0-E5B6-11D0-ABF5-00A0C90FFFC0")) IFileSystem;	    // SCRRUN.DLL
struct __declspec(uuid("2A0B9D10-4B87-11d3-A97A-00104B365C9F")) IFileSystem3;	    // SCRRUN.DLL
struct __declspec(uuid("c7c3f5a2-88a3-11d0-abcb-00a0c90fffc0")) IFolder;	    // SCRRUN.DLL
struct __declspec(uuid("c7c3f5a3-88a3-11d0-abcb-00a0c90fffc0")) IFolderCollection;  // SCRRUN.DLL
struct __declspec(uuid("736a9095-a80e-4f47-a0a6-87f43d57027c")) ILogonUser;


enum ATD
{
	atdNo,
	atdBefore,
	atdAfter,
};


struct ARG
{
	VARENUM  vt;
	bool     fIn;
	bool     fOut;
	bool     fOptional;
	bool     fDidOptional;
	unsigned iValue;
	unsigned iType;
};


ATD atd = atdBefore;
size_t ciMax = 10;
CLSID clsid;
DISPID dispidMax = 300;
DWORD dwClass;
DWORD dwClassLocked;
DWORD dwClsctx = CLSCTX_ALL;
DWORD dwCoinit2;
DWORD dwDebugSequence;
DWORD dwDispatchMax = 1000;
DWORD dwNonClass;
DWORD dwTimeout = 30000;
DWORD dwZone;
bool fAggregate;
bool fAllClsids;
bool fAllIids;
bool fAllProgids;
bool fBindToObject;
bool fBindToStorage;
bool fCheckSafety;
bool fClsidsFromFile;
bool fCreateOnly;
bool fExistsA;
bool fFakeDebugger;
bool fFreeCO;
bool fHTML;
bool fIgnoreRpcExcept;
bool fIsChild = false;
bool fIidsFromFile;
bool fInReportFailure;
bool fMTA;
bool fNoCategoryCheck;
bool fNoFakeDebugger;
bool fNoFree;
bool fNoIDispatch;
bool fNoIDispatchFuzz;
bool fNoIgnoreBreakpoint;
bool fNoIgnoreClrExcept;
bool fNoIgnoreCppExcept;
bool fNoIgnoreDelayLoadExcept;
bool fNoIgnoreFloatExcept;
bool fNoIgnoreXmlExcept;
bool fNoOverrideSafety;
bool fNoPatchBreakpoint;
bool fNoVectoredExceptions;
bool fNoWindowHook;
bool fObjrefMoniker;
bool fProgidsFromFile;
bool fRemovePrivileges;
bool fSafeForInitializing;
bool fSafeForScripting;
bool fSDL;
bool fSilent;
bool fStdModes;
bool fTryQI;
bool fUrlMoniker;
bool fUseCF;
bool fUsePS;
bool fVerbose;
bool fWebBrowser;
int	 ilevel = 9;			// default level for output
bool blevel = false;		// was a non-default level specified
HHOOK hhook;
HMODULE hmodHook;
IID iid = IID_IUnknown;
HHOOK (*pfnInstallHook)(void (*pfn)(HWND));
void (*pfnUninstallHook)(HHOOK);
wchar_t *szAddToDocument;
wchar_t *szClsctx;
wchar_t *szClsid;
wchar_t *szData;
wchar_t *szDispatchMax;
wchar_t *szHookDll;
wchar_t *szIid;
wchar_t *szInvoke;
wchar_t *szInvokePrefix;
wchar_t *szMoniker;
wchar_t *szMT;
wchar_t *szOut;
wchar_t *szSad = NULL;		// filename for SAD output (master copy only)
const wchar_t *szPrefix;
const wchar_t *szQualifier;
wchar_t *szProgid;
wchar_t *szTimeout;
wchar_t *szUrl;
wchar_t *szZone;


HANDLE hPipeInfoSend = INVALID_HANDLE_VALUE;    // pipe handle for sending data

SAD *sad = NULL;


const IID iidUndefined =	       // f63f9e48-593f-4413-bc80-11734f40ef8a
{
	0xF63F9E48,
	0x593F,
	0x4413,
	{ 0xBC, 0x80, 0x11, 0x73, 0x4F, 0x40, 0xEF, 0x8A }
};


enum COMCAT
{
#if 0
	// activaut.h

	comcatActiveScriptAuthor,
#endif

#if 0				       // Defined in header but not present in uuid.lib
	// activscp.h

	comcatActiveScript,
	comcatActiveScriptParse,
	comcatActiveScriptEncode,
#endif

	// cguid.h

	comcatMARSHALER,

#if 0
	// cluscfgguids.h

	comcatClusCfgCapabilities,
	comcatEnumClusCfgManagedResources,
	comcatClusCfgResourceTypes,
	comcatClusCfgMemberSetChangeListeners,
	comcatClusCfgStartupListeners,
	comcatClusCfgEvictListeners,
#endif

	// comcat.h

	comcatInsertable,
	comcatControl,
	comcatProgrammable,
	comcatIsShortcut,
	comcatNeverShowExt,
	comcatDocObject,
	comcatPrintable,
	comcatRequiresDataPathHost,
	comcatPersistsToMoniker,
	comcatPersistsToStorage,
	comcatPersistsToStreamInit,
	comcatPersistsToStream,
	comcatPersistsToMemory,
	comcatPersistsToFile,
	comcatPersistsToPropertyBag,
	comcatInternetAware,
	comcatDesignTimeUIActivatableControl,

#if 0
	// dxtrans.h

	comcatDXImageTransform,
	comcatDX3DTransform,
	comcatDXAuthoringTransform,
	comcatDXSurface,
#endif

#if 0
	// nt\admin\activec\nodemgr\guids.h

	catidConsoleControl,
	catidConsoleMonitorControl,
#endif

#if 0
	// junkfilter.h

	comcatJunkFilters
#endif

#if 0				       // Declared but never defined
	// msdatsrc.h

	comcatDataSource,
	comcatDataConsumer,
#endif

#if 0
	// msoav.h

	comcatMSOfficeAntiVirus,
#endif

	// objsafe.h

	comcatSafeForScripting,
	comcatSafeForInitializing,

	// shlguid.h

	comcatBrowsableShellExt,
	comcatBrowseInPlace,
	comcatDeskBand,
	comcatInfoBand,
	comcatCommBand,

#if 0
	// wincodec.h

	comcatWICBitmapDecoders,
	comcatWICBitmapEncoders,
	comcatWICPixelFormats,
	comcatWICFormatConverters,
	comcatWICMetadataReader,
	comcatWICMetadataWriter,
#endif

#if 0
	// wmscatid.h

	comcatIWMSControlProtocols,
	comcatIWMSAuthentication,
	comcatIWMSEventPlugins,
	comcatIWMSDataProtocols,
	comcatIWMSFeedbackProtocols,
	comcatIWMSUnicastDataSinks,
	comcatIWMSAuthenticationResponse,
	comcatIWMSCredentialPlugins,
	comcatIWMSPlaylistParsers,
	comcatIWMSStorageSystem,
	comcatIWMSNetworkSource,
	comcatIWMSMediaParsers,
	comcatIWMSCacheProxyPlugins,
	comcatIWMSBroadcastDataSinks,
#endif

	comcatMax
};



const CATID rgcatid[] =
{
#if 0
	// activaut.h

	CATID_ActiveScriptAuthor,
#endif

#if 0				       // Defined in header but not present in uuid.lib
	// activscp.h

	CATID_ActiveScript,
	CATID_ActiveScriptParse,
	CATID_ActiveScriptEncode,
#endif

	// cguid.h

	CATID_MARSHALER,

#if 0
	// cluscfgguids.h

	CATID_ClusCfgCapabilities,
	CATID_EnumClusCfgManagedResources,
	CATID_ClusCfgResourceTypes,
	CATID_ClusCfgMemberSetChangeListeners,
	CATID_ClusCfgStartupListeners,
	CATID_ClusCfgEvictListeners,
#endif

	// comcat.h

	CATID_Insertable,
	CATID_Control,
	CATID_Programmable,
	CATID_IsShortcut,
	CATID_NeverShowExt,
	CATID_DocObject,
	CATID_Printable,
	CATID_RequiresDataPathHost,
	CATID_PersistsToMoniker,
	CATID_PersistsToStorage,
	CATID_PersistsToStreamInit,
	CATID_PersistsToStream,
	CATID_PersistsToMemory,
	CATID_PersistsToFile,
	CATID_PersistsToPropertyBag,
	CATID_InternetAware,
	CATID_DesignTimeUIActivatableControl,

#if 0
	// dxtrans.h

	CATID_DXImageTransform,
	CATID_DX3DTransform,
	CATID_DXAuthoringTransform,
	CATID_DXSurface,
#endif

#if 0
	// nt\admin\activec\nodemgr\guids.h

	CATID_ConsoleControl,
	CATID_ConsoleMonitorControl,
#endif

#if 0
	// junkfilter.h

	CATID_JunkFilters
#endif

#if 0				       // Declared but never defined
	// msdatsrc.h

	CATID_DataSource,
	CATID_DataConsumer,
#endif

#if 0
	// msoav.h

	CATID_MSOfficeAntiVirus,
#endif

	// objsafe.h

	CATID_SafeForScripting,
	CATID_SafeForInitializing,

	// shlguid.h

	CATID_BrowsableShellExt,
	CATID_BrowseInPlace,
	CATID_DeskBand,
	CATID_InfoBand,
	CATID_CommBand,

#if 0
	// wincodec.h

	CATID_WICBitmapDecoders,
	CATID_WICBitmapEncoders,
	CATID_WICPixelFormats,
	CATID_WICFormatConverters,
	CATID_WICMetadataReader,
	CATID_WICMetadataWriter,
#endif

#if 0
	// wmscatid.h

	CATID_IWMSControlProtocols,
	CATID_IWMSAuthentication,
	CATID_IWMSEventPlugins,
	CATID_IWMSDataProtocols,
	CATID_IWMSFeedbackProtocols,
	CATID_IWMSUnicastDataSinks,
	CATID_IWMSAuthenticationResponse,
	CATID_IWMSCredentialPlugins,
	CATID_IWMSPlaylistParsers,
	CATID_IWMSStorageSystem,
	CATID_IWMSNetworkSource,
	CATID_IWMSMediaParsers,
	CATID_IWMSCacheProxyPlugins,
	CATID_IWMSBroadcastDataSinks,
#endif
};

const size_t ccatid = _countof(rgcatid);

bool rgfCatid[ccatid];

int TestAndReleaseInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject, bool fCheckRefCount);
int TestInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject);

const void *PvMethod(const void *pv, int ifn)
{
	const void * const *pvVtbl = *(const void * const **) pv;

	const void *pvMethod = pvVtbl[ifn];

	return(pvMethod);
}


void ReportFailure(int rc, bool fStdout, const void *pv, int ifn, const wchar_t *szMsg, ...)
{
	int lvl;
	LPWSTR pName;
	bool b = FindWarningInfo(rc, &pName, &lvl);
	bool bOutput = true;
	if (lvl >= ilevel) bOutput = false;

	va_list valist;
	va_start(valist, szMsg);

	if (!fSilent || fStdout)
	{
		const void *pvReport = pv;

		if ((pvReport != NULL) && (ifn >= 0))
		{
			// We have a vtable index.  Index into the vtable

			// UNDONE: Ugly hack.	We need to supress the vectored exception handlers
			// UNDONE: first chance handling of access violations for the next block.
			// UNDONE: Currently this can only happen for the main thread so we
			// UNDONE: cheat and use a global.

			fInReportFailure = true;

			__try
			{
				pvReport = PvMethod(pv, ifn);
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				pvReport = NULL;
			}

			fInReportFailure = false;
		}

		wchar_t szModule[_MAX_PATH];
		const wchar_t *szFilename = NULL;

		if (pvReport != NULL)
		{
			MEMORY_BASIC_INFORMATION mbi;

			if (VirtualQuery(pvReport, &mbi, sizeof(mbi)) != 0)
			{
				if ((mbi.State & MEM_COMMIT) != 0)
				{
					static HMODULE hmodOLEAUT32 = GetModuleHandle(L"OLEAUT32.DLL");
					static HMODULE hmodRPCRT4 = GetModuleHandle(L"RPCRT4.DLL");

					HMODULE hmod = HMODULE(mbi.AllocationBase);

					if (hmod == NULL)
					{
						// Do not treat NULL as a module handle as it maps to the current EXE

						pvReport = NULL;
					}

					else if (fMTA && (ifn >= 0) && ((hmod == hmodOLEAUT32) || (hmod == hmodRPCRT4)))
					{
						// Don't display method addresses within OLEAUT32 or RPCRT4.
						// These are usually proxy addresses

						pvReport = NULL;
					}

					else if (GetModuleFileName(hmod, szModule, _countof(szModule)) != 0)
					{
						szFilename = szModule;
					}
				}
			}
		}

		// Lock stream to prevent other thread from entering in the middle of this.
		// While most code occurs on a single thread, WindowHookCallback and unhandled
		// exceptions can and do occur on other threads

		//
		// Also send info to master.

		PipeMsg pmWarn;
		pmWarn.AddDWORD(3);
		pmWarn.AddDWORD(rc);

		_lock_file(stdout);

		if (bOutput)
			wprintf(L"%08X: %s%s: ", rc, szPrefix, (szQualifier != NULL) ? szQualifier : L"");
		pmWarn.AddFormatString(L"%s%s", szPrefix, (szQualifier != NULL) ? szQualifier : L"");

		if (bOutput)
			vwprintf(szMsg, valist);
		pmWarn.AddFormatVString(szMsg, valist);

		if (pvReport != NULL)
		{	 
			if (bOutput)
				wprintf(L": %p", pvReport);

			pmWarn.AddFormatString(L"%p", pvReport);

			if (szFilename != NULL)
			{
				if (bOutput)
					wprintf(L" (%s)", szFilename);
				pmWarn.AppendFormatString(L" (%s)", szFilename);
			}
		}
		else
		{
			pmWarn.AddDWORD(0);	// extra terminator (OK, two of them)
		}

		if (bOutput)
		{
			_fputwc_nolock(L'\n', stdout);
			_fflush_nolock(stdout);
		}

		pmWarn.Send(hPipeInfoSend);

		_unlock_file(stdout);
	}
	va_end(valist);

}


bool FDefaultNoFakeDebugger()
{
	OSVERSIONINFO ovi;

	ovi.dwOSVersionInfoSize = sizeof(ovi);

	if (!GetVersionEx(&ovi))
	{
		return(false);
	}

	if (ovi.dwMajorVersion < 6)
	{
		// For pre-Longhorn we do fake the debugger by default

		return(false);
	}

	if ((ovi.dwMajorVersion > 6) || (ovi.dwMinorVersion > 0))
	{
		// For post-Longhorn we do not fake the debugger by default

		return(true);
	}

	// Longhorn winmain build 5438 does not need to fake being a debugger

	return(ovi.dwBuildNumber >= 5438);
}


bool FRemovePrivilege(HANDLE hToken, const wchar_t *szPrivilege)
{
	LUID luid;

	if (!LookupPrivilegeValue(NULL, szPrivilege, &luid))
	{
		return(false);
	}

	TOKEN_PRIVILEGES tp;

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_REMOVED;

	if (!AdjustTokenPrivileges(hToken,
		FALSE,
		&tp,
		sizeof(tp),
		NULL,
		NULL))
	{
		return(false);
	}

	if (fVerbose && (GetLastError() == ERROR_SUCCESS))
	{
		wprintf(L"Removed privilege %s\n", szPrivilege);
	}

	return(true);
}


void RemovePrivileges()
{
	HANDLE hToken;

	if (!OpenProcessToken(GetCurrentProcess(),
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		&hToken))
	{
		wprintf(L"OpenProcessToken failed.  GetLastError() = %u\n", GetLastError());
		return;
	}

	static const wchar_t * const rgszPrivilege[] =
	{
		SE_CREATE_TOKEN_NAME,
		SE_ASSIGNPRIMARYTOKEN_NAME,
		SE_LOCK_MEMORY_NAME,
		SE_INCREASE_QUOTA_NAME,
		SE_UNSOLICITED_INPUT_NAME,
		SE_MACHINE_ACCOUNT_NAME,
		SE_TCB_NAME,
		SE_SECURITY_NAME,
		SE_TAKE_OWNERSHIP_NAME,
		SE_LOAD_DRIVER_NAME,
		SE_SYSTEM_PROFILE_NAME,
		SE_SYSTEMTIME_NAME,
		SE_PROF_SINGLE_PROCESS_NAME,
		SE_INC_BASE_PRIORITY_NAME,
		SE_CREATE_PAGEFILE_NAME,
		SE_CREATE_PERMANENT_NAME,
		SE_BACKUP_NAME,
		SE_RESTORE_NAME,
		SE_SHUTDOWN_NAME,
		SE_DEBUG_NAME,
		SE_AUDIT_NAME,
		SE_SYSTEM_ENVIRONMENT_NAME,
		//	SE_CHANGE_NOTIFY_NAME,
		SE_REMOTE_SHUTDOWN_NAME,
		SE_UNDOCK_NAME,
		SE_SYNC_AGENT_NAME,
		SE_ENABLE_DELEGATION_NAME,
		SE_MANAGE_VOLUME_NAME,
		SE_IMPERSONATE_NAME,
		SE_CREATE_GLOBAL_NAME,

		// The following are ifdefed to support old build
		// environments like that used by SWI.

#ifdef	SE_TRUSTED_CREDMAN_ACCESS_NAME
		SE_TRUSTED_CREDMAN_ACCESS_NAME,
#endif
#ifdef	SE_RELABEL_NAME
		SE_RELABEL_NAME,
#endif
#ifdef	SE_INC_WORKING_SET_NAME
		SE_INC_WORKING_SET_NAME,
#endif
#ifdef	SE_TIME_ZONE_NAME
		SE_TIME_ZONE_NAME,
#endif
#ifdef	SE_CREATE_SYMBOLIC_LINK_NAME
		SE_CREATE_SYMBOLIC_LINK_NAME,
#endif
	};

	const size_t cszPrivilege = _countof(rgszPrivilege);

	for (size_t isz = 0; isz < cszPrivilege; isz++)
	{
		FRemovePrivilege(hToken, rgszPrivilege[isz]);
	}

	CloseHandle(hToken);
}


HHOOK InstallHookStub(void (*pfn)(HWND))
{
	_putws(L"COMCHKHK.DLL is missing.  -nowindowhook assumed\n");

	fNoWindowHook = true;

	return(NULL);
}


LONG WINAPI MyUnhandledExceptionFilter(EXCEPTION_POINTERS *pep)
{
	_lock_file(stdout);

	PipeMsg pmExcept;

	pmExcept.AddDWORD(4);	// msg id
	pmExcept.AddDWORD(pep->ExceptionRecord->ExceptionCode);
	pmExcept.AddString(GetCommandLine());
	pmExcept.AddFormatString(L"%p", pep->ExceptionRecord->ExceptionAddress);
	wprintf(L"%08X: %s: %p", pep->ExceptionRecord->ExceptionCode, GetCommandLine(), pep->ExceptionRecord->ExceptionAddress);
	MEMORY_BASIC_INFORMATION mbi;

	if (VirtualQuery((void *) pep->ExceptionRecord->ExceptionAddress, &mbi, sizeof(mbi)) != 0)
	{
		if ((mbi.State & MEM_COMMIT) != 0)
		{
			HMODULE hmod = HMODULE(mbi.AllocationBase);

			wchar_t szFilename[_MAX_PATH];

			if (GetModuleFileName(hmod, szFilename, _countof(szFilename)) != 0)
			{
				pmExcept.AppendFormatString(L" (%s)", szFilename);
				wprintf(L" (%s)", szFilename);

			}
		}
	}
	pmExcept.Send(hPipeInfoSend);

	_fputwc_nolock(L'\n', stdout);
	_fflush_nolock(stdout);
	_unlock_file(stdout);

	TerminateProcess(GetCurrentProcess(), 0);

	__assume(0);
}


void SetMyUnhandledExceptionFilter(bool fCheckCurrent)
{
	LPTOP_LEVEL_EXCEPTION_FILTER pfnFilterPrev = SetUnhandledExceptionFilter(&MyUnhandledExceptionFilter);

	if (fCheckCurrent && (pfnFilterPrev != &MyUnhandledExceptionFilter))
	{
		ReportFailure(0x2C01, false, (void *) pfnFilterPrev, -1, L"UnhandledExceptionFilter changed");
	}
}


void DoOutputDebugString(const char *sz, size_t cch)
{
	char *szT = (char *) _alloca(cch);

	while (cch != 0)
	{
		size_t ich = 0;

		while (cch != 0)
		{
			cch--;

			char ch = *sz++;

			if (ch == '\0')
			{
				break;
			}

			if (ch == '\r')
			{
				// Ignore CR

				continue;
			}

			if (ch == '\n')
			{
				// Treat LF as line break

				break;
			}

			szT[ich++] = ch;
		}

		if (ich != 0)
		{
			szT[ich] = '\0';

			// Increment sequence so that when output is sorted these remain in order

			DWORD dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

			ReportFailure(0x0101, false, NULL, 0, L"%08X OutputDebugString: \"%hs\"", dwSequence, szT);
		}
	}
}


bool FDoBreakpoint(EXCEPTION_POINTERS *pep)
{
#if	defined(_M_IX86)

	// From nt\base\published\nti386.w

	//
	//  Values put in ExceptionRecord.ExceptionInformation[0]
	//  First parameter is always in ExceptionInformation[1],
	//  Second parameter is always in ExceptionInformation[2]
	//

#define BREAKPOINT_BREAK	    0
#define BREAKPOINT_PRINT	    1
#define BREAKPOINT_PROMPT	    2
#define BREAKPOINT_LOAD_SYMBOLS     3
#define BREAKPOINT_UNLOAD_SYMBOLS   4
#define BREAKPOINT_COMMAND_STRING   5

	BYTE *pb = (BYTE *) pep->ContextRecord->Eip;

	// Under WoW64 the exception address is a RET not an Int 3 and we don't do anything
	// If you ignore this you will find that at least on x64 the exception arguments
	// are not correct as the special breakpoints are handled by 64-bit code not 32-bit.

	if (*pb == 0xCC)
	{
		if (pep->ExceptionRecord->NumberParameters > 0)
		{
			DWORD dwType = (DWORD) pep->ExceptionRecord->ExceptionInformation[0];

			switch (dwType)
			{
				DWORD dwSequence;
				const char *pch;
				size_t cch;
				char *pchIn;
				size_t cchIn;

			case BREAKPOINT_BREAK :
				ReportFailure(0x0103, false, pb, -1, L"Breakpoint");
				break;

			case BREAKPOINT_PROMPT :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				pch = (char *) pep->ContextRecord->Ecx;
				cch = (size_t) pep->ContextRecord->Edx;
				pchIn = (char *) pep->ContextRecord->Ebx;
				cchIn = (size_t) pep->ContextRecord->Edi;

				ReportFailure(0x0104, false, NULL, 0, L"%08X DebugPrompt: %*S", dwSequence, cch, pch);

				if (cchIn == 0)
				{
					pep->ContextRecord->Eax = 0;
				}

				else
				{
					*pchIn = 'I';        // Ignore

					pep->ContextRecord->Eax = 1;
				}
				break;

			default :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				ReportFailure(0x0105, false, pb, -1, L"%08X Breakpoint(%08X)", dwSequence, dwType);
				break;
			}
		}

		else
		{
			ReportFailure(0x0106, false, pb, -1, L"Breakpoint");
		}

		if (!fNoPatchBreakpoint)
		{
			DWORD dwOldProtect;

			if (VirtualProtect(pb, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				// Replace INT 3 with NOP

				*pb = 0x90;

				// Restore protection and ignore any error

				DWORD dwT;

				VirtualProtect(pb, 1, dwOldProtect, &dwT);
			}
		}

		pep->ContextRecord->Eip += 1;

		return(true);
	}

#elif	defined(_M_AMD64)

	// From nt\base\published\ntamd64.w

	//
	//  ?? Values put in ExceptionRecord.ExceptionInformation[0]
	//  ?? First parameter is always in ExceptionInformation[1],
	//  ?? Second parameter is always in ExceptionInformation[2]
	//

#define BREAKPOINT_BREAK 0
#define BREAKPOINT_PRINT 1
#define BREAKPOINT_PROMPT 2
#define BREAKPOINT_LOAD_SYMBOLS 3
#define BREAKPOINT_UNLOAD_SYMBOLS 4
#define BREAKPOINT_COMMAND_STRING 5

	BYTE *pb = (BYTE *) pep->ContextRecord->Rip;

	if (*pb == 0xCC)
	{
		if (pep->ExceptionRecord->NumberParameters > 0)
		{
			DWORD dwType = (DWORD) pep->ExceptionRecord->ExceptionInformation[0];

			switch (dwType)
			{
				DWORD dwSequence;
				const char *pch;
				size_t cch;
				char *pchIn;
				size_t cchIn;

			case BREAKPOINT_BREAK :
				ReportFailure(0x0103, false, pb, -1, L"Breakpoint");
				break;

			case BREAKPOINT_PROMPT :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				pch = (char *) pep->ContextRecord->Rcx;
				cch = (WORD) pep->ContextRecord->Rdx;
				pchIn = (char *) pep->ContextRecord->R8;
				cchIn = (WORD) pep->ContextRecord->R9;

				ReportFailure(0x0104, false, NULL, 0, L"%08X DebugPrompt: %*S", dwSequence, cch, pch);

				if (cchIn == 0)
				{
					pep->ContextRecord->Rax = 0;
				}

				else
				{
					*pchIn = 'I';        // Ignore

					pep->ContextRecord->Rax = 1;
				}
				break;

			default :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				ReportFailure(0x0105, false, pb, -1, L"%08X Breakpoint(%08X)", dwSequence, dwType);
				break;
			}
		}

		else
		{
			ReportFailure(0x0106, false, pb, -1, L"Breakpoint");
		}

		if (!fNoPatchBreakpoint)
		{
			DWORD dwOldProtect;

			if (VirtualProtect(pb, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				// Replace INT 3 with NOP

				*pb = 0x90;

				// Restore protection and ignore any error

				DWORD dwT;

				VirtualProtect(pb, 1, dwOldProtect, &dwT);
			}
		}

		pep->ContextRecord->Rip += 1;

		return(true);
	}

#endif

	return(false);
}


LONG NTAPI VectoredExceptionHandler(EXCEPTION_POINTERS *pep)
{
	bool fFatal;
	DWORD dwSequence;

	DWORD ExceptionCode = pep->ExceptionRecord->ExceptionCode;

	switch (ExceptionCode)
	{
		size_t cch;
		const char *sz;
		DWORD dwType;
		DWORD dwError;

	case RPC_X_NO_MORE_ENTRIES :
	case RPC_X_SS_CHAR_TRANS_OPEN_FAIL :
	case RPC_X_SS_CHAR_TRANS_SHORT_FILE :
	case RPC_X_SS_IN_NULL_CONTEXT :
	case RPC_X_SS_CONTEXT_DAMAGED :
	case RPC_X_SS_HANDLES_MISMATCH :
	case RPC_X_SS_CANNOT_GET_CALL_HANDLE :
		//	case RPC_X_NULL_REF_POINTER :
	case RPC_X_ENUM_VALUE_OUT_OF_RANGE :
	case RPC_X_BYTE_COUNT_TOO_SMALL :
	case RPC_X_BAD_STUB_DATA :
	case RPC_X_INVALID_ES_ACTION :
	case RPC_X_WRONG_ES_VERSION :
	case RPC_X_WRONG_STUB_VERSION :
	case RPC_X_INVALID_PIPE_OBJECT :
	case RPC_X_WRONG_PIPE_ORDER :
	case RPC_X_WRONG_PIPE_VERSION :
	case RPC_X_PIPE_CLOSED :
	case RPC_X_PIPE_DISCIPLINE_ERROR :
	case RPC_X_PIPE_EMPTY :
		fFatal = !fIgnoreRpcExcept;
		break;

	case DBG_PRINTEXCEPTION_C :
		cch = pep->ExceptionRecord->ExceptionInformation[0];
		sz = (char *) pep->ExceptionRecord->ExceptionInformation[1];

		DoOutputDebugString(sz, cch);
		return(EXCEPTION_CONTINUE_EXECUTION);

	case DBG_RIPEXCEPTION :
		dwError = (DWORD) pep->ExceptionRecord->ExceptionInformation[0];
		dwType  = (DWORD) pep->ExceptionRecord->ExceptionInformation[1];

		dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);
		ReportFailure(0x0102, false, NULL, 0, L"%08X RIP: Error=%08X, Type=%08X", dwSequence, dwError, dwType);
		return(EXCEPTION_CONTINUE_EXECUTION);

	case EXCEPTION_COMPLUS :
		fFatal = fNoIgnoreClrExcept;
		break;

	case EXCEPTION_MSVC :
		fFatal = fNoIgnoreCppExcept;
		break;

	case EXCEPTION_MSXML :
		fFatal = fNoIgnoreXmlExcept;
		break;

	case VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND) :
	case VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND) :
		fFatal = fNoIgnoreDelayLoadExcept;
		break;

	case STATUS_BREAKPOINT :
		if (!fNoIgnoreBreakpoint && FDoBreakpoint(pep))
		{
			return(EXCEPTION_CONTINUE_EXECUTION);
		}

		fFatal = true;
		break;

	case STATUS_FLOAT_DENORMAL_OPERAND :
	case STATUS_FLOAT_DIVIDE_BY_ZERO :
	case STATUS_FLOAT_INEXACT_RESULT :
	case STATUS_FLOAT_INVALID_OPERATION :
	case STATUS_FLOAT_OVERFLOW :
	case STATUS_FLOAT_STACK_CHECK :
	case STATUS_FLOAT_UNDERFLOW :
		fFatal = fNoIgnoreFloatExcept;
		break;

	case STATUS_ACCESS_VIOLATION :
		if (fInReportFailure)
		{
			return(EXCEPTION_CONTINUE_SEARCH);
		}

		// Fall through

	default:
		// Error code have the high 2 bits set

		fFatal = (ExceptionCode & 0xC0000000) == 0xC0000000;
		break;
	}

	if (fFatal)
	{
		return(MyUnhandledExceptionFilter(pep));
	}

	dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

	ReportFailure(0x0107, false, pep->ExceptionRecord->ExceptionAddress, -1, L"%08X Exception %08X", dwSequence, pep->ExceptionRecord->ExceptionCode);

	return(EXCEPTION_CONTINUE_SEARCH);
}


void WindowHookCallback(HWND hwnd)
{
	wchar_t szTitle[256];

	if (GetWindowText(hwnd, szTitle, _countof(szTitle)) == 0)
	{
		szTitle[0] = L'\0';
	}

	szTitle[_countof(szTitle) - 1] = L'\0';

	ReportFailure(0x0201, false, NULL, 0, L"Window hook caught window %p \"%s\"", hwnd, szTitle);
}


void QueryComponentCategories(REFCLSID clsid)
{
	ICatInformation *pici;

	HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
		NULL,
		CLSCTX_ALL,
		IID_PPV_ARGS(&pici));

	if (FAILED(hr))
	{
		ReportFailure(0x0301, false, NULL, 0, L"CoCreateInstance(CLSID_StdComponentCategoriesMgr) failed.  hr = %08X", hr);
		return;
	}

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	for (size_t icatid = 0; icatid < ccatid; icatid++)
	{
		hr = pici->IsClassOfCategories(clsid, 1, (CATID *) &rgcatid[icatid], ((ULONG) -1), NULL);

		if (hr == S_OK)
		{
			rgfCatid[icatid] = true;
		}

		else if (hr == S_FALSE)
		{
			rgfCatid[icatid] = false;
		}

		else if (FAILED(hr))
		{
			// Don't report ERROR_FILE_NOT_FOUND.  This is returned when the CLSID is not registered

			if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
			{
				ReportFailure(0x0302, false, NULL, 0, L"ICatInformation::IsClassOfCategories failed.  hr = %08X", hr);
			}
		}

		else
		{
			ReportFailure(0x0303, false, NULL, 0, L"ICatInformation::IsClassOfCategories returned %08X", hr);
		}
	}

	pici->Release();
}


const wchar_t *SzIidDisplay()
{
	if (szIid != NULL)
	{
		return(szIid);
	}

	return L"IUnknown";
}


void FreeUnusedLibraries()
{
	if (fNoFree)
	{
		return;
	}

	if (!fFreeCO && (dwClass != 0) && (dwClassLocked == 0) && (dwNonClass == 0))
	{
		return;
	}

	CoFreeUnusedLibrariesEx(0, 0);
	CoFreeUnusedLibrariesEx(0, 0);

	SetMyUnhandledExceptionFilter(true);
}


void IncrementObjectCount(bool fClassObject)
{
	if (fClassObject)
	{
		dwClass++;
	}

	else
	{
		dwNonClass++;
	}
}


ULONG Release(IUnknown *punk, bool fClassObject)
{
	ULONG cref = punk->Release();

	if (fClassObject)
	{
		dwClass--;
	}

	else
	{
		dwNonClass--;
	}

	FreeUnusedLibraries();

	return(cref);
}


class Interface sealed
{
public:
	static bool FNoQINullCheck()
	{
		return(piHead->m_fNoQINullCheck);
	}

	static bool FNoRefCountCheck()
	{
		return(piHead->m_fNoRefCountCheck);
	}

	static bool FPush(IUnknown *punk, bool fClassObject)
	{
		for (Interface *pi = piHead; pi != NULL; pi = pi->m_piNext)
		{
			if (pi->m_punk == punk)
			{
				if (fVerbose)
				{
					wprintf(L"********: Skipping interface already on stack\n");
				}

				return(false);
			}
		}

		if (ci == ciMax)
		{
			if (fVerbose)
			{
				wprintf(L"********: Skipping interface because recursion limit\n");
			}

			return(false);
		}

		Interface *pi = new Interface(punk, fClassObject);

		return(true);
	}

	static ULONG PopAndRelease()
	{
		Interface *pi = piHead;

		piHead = pi->m_piNext;

		ULONG cref = Release(pi->m_punk, pi->m_fClassObject);

		delete pi;

		ci--;

		return(cref);
	}

	static void SetNoQINullCheck()
	{
		piHead->m_fNoQINullCheck = true;
	}

	static void SetNoRefCountCheck()
	{
		piHead->m_fNoRefCountCheck = true;
	}

private:
	Interface(IUnknown *punk, bool fClassObject) : m_punk(punk), m_fClassObject(fClassObject)
	{
#if 0
		wprintf(L"--> %*s punk = %p, vtbl = %p, QI = %p\n",
			ci, L"",
			punk,
			*(intptr_t *) punk,
			**(intptr_t **) punk);
#endif

		m_fNoQINullCheck = false;
		m_fNoRefCountCheck = false;

		ci++;

		m_piNext = piHead;

		piHead = this;
	}

	static Interface *piHead;
	static size_t ci;

	IUnknown *m_punk;
	bool m_fClassObject;
	bool m_fNoQINullCheck;
	bool m_fNoRefCountCheck;
	Interface *m_piNext;
};


size_t Interface::ci;
Interface *Interface::piHead;


HRESULT HrQueryInterface(IUnknown *punk, bool fClassObject, const wchar_t *szIid, REFIID riid, void **ppvObject)
{
	*ppvObject = (void *) (intptr_t) -1;

	HRESULT hr = punk->QueryInterface(riid, ppvObject);

	if (SUCCEEDED(hr))
	{
		IncrementObjectCount(fClassObject);
	}

	else
	{
		if (hr != E_NOINTERFACE)
		{
			ReportFailure(0x0401, false, punk, 0, L"QueryInterface(%s) failure did not E_NOINTERFACE.  hr = %08X", szIid, hr);
		}

		if (*ppvObject != NULL)
		{
			if (!Interface::FNoQINullCheck())
			{
				Interface::SetNoQINullCheck();

				ReportFailure(0x0402, false, punk, 0, L"QueryInterface(%s) failure did not set *ppvObject = NULL", szIid);
			}

			*ppvObject = NULL;
		}
	}

	FreeUnusedLibraries();

	return(hr);
}


void MyVariantInit(VARIANT *pvar)
{
	// Use memset and assignment of the vt member instead of VariantInit.  This
	// is because VariantInit doesn't initialize all the fields and we want to
	// catch access to the other members that should be guarded by checking the
	// type.

	memset(pvar, -1, sizeof(*pvar));

	pvar->vt = VT_EMPTY;
}


bool FSafeForInitializing(IUnknown *punk, REFCLSID clsid)
{
	if (rgfCatid[comcatSafeForInitializing])
	{
		return(true);
	}

	IObjectSafety *pios;

	HRESULT hr = punk->QueryInterface(IID_PPV_ARGS(&pios));

	if (FAILED(hr))
	{
		return(false);
	}

	static const IID rgiid[] =
	{
		IID_IPersist,
		IID_IPersistFile,
#if 0
		IID_IPersistHistory,
#endif
		IID_IPersistMoniker,
		IID_IPersistPropertyBag,
		IID_IPersistPropertyBag2,
		IID_IPersistStorage,
		IID_IPersistStream,
		IID_IPersistStreamInit,
	};

	const size_t ciid = _countof(rgiid);

	bool fSafe = false;

	for (size_t iiid = 0; iiid < ciid; iiid++)
	{
		DWORD dwSupported;
		DWORD dwEnabled;

		hr = pios->GetInterfaceSafetyOptions(rgiid[iiid], &dwSupported, &dwEnabled);

		if (SUCCEEDED(hr))
		{
			if ((dwSupported & INTERFACESAFE_FOR_UNTRUSTED_DATA) != 0)
			{
				fSafe = true;
				break;
			}
		}
	}

	pios->Release();

	return(fSafe);
}


bool FSafeForScripting(IUnknown *punk, REFCLSID clsid)
{
	if (rgfCatid[comcatSafeForScripting])
	{
		return(true);
	}

	IObjectSafety *pios;

	HRESULT hr = punk->QueryInterface(IID_PPV_ARGS(&pios));

	if (FAILED(hr))
	{
		return(false);
	}

	static const IID rgiid[] =
	{
		IID_IActiveScript,
		IID_IActiveScriptParse,
		IID_IDispatch,
		IID_IDispatchEx,
	};

	const size_t ciid = _countof(rgiid);

	bool fSafe = false;

	for (size_t iiid = 0; iiid < ciid; iiid++)
	{
		DWORD dwSupported;
		DWORD dwEnabled;

		hr = pios->GetInterfaceSafetyOptions(rgiid[iiid], &dwSupported, &dwEnabled);

		if (SUCCEEDED(hr))
		{
			if ((dwSupported & INTERFACESAFE_FOR_UNTRUSTED_CALLER) != 0)
			{
				fSafe = true;
				break;
			}
		}
	}

	pios->Release();

	return(fSafe);
}


bool FTestClass(IUnknown *punk, REFCLSID clsid)
{
	if (!fSafeForInitializing && !fSafeForScripting)
	{
		return(true);
	}

	if (fSafeForInitializing && FSafeForInitializing(punk, clsid))
	{
		return(true);
	}

	if (fSafeForScripting && FSafeForScripting(punk, clsid))
	{
		return(true);
	}

	return(false);
}


int SetSiteAlways(IUnknown *punk, IOleClientSite *piocs)
{
	IOleObject *pioo;

	HRESULT hr = HrQueryInterface(punk, false, L"IOleObject", IID_PPV_ARGS(&pioo));

	if (SUCCEEDED(hr))
	{
		hr = pioo->SetClientSite(piocs);

		if (FAILED(hr))
		{
			ReportFailure(0x0501, false, pioo, 3, L"IOleObject::SetClientSite failed.  hr = %08X", hr);
		}

		Release(pioo, false);

		return(FAILED(hr) ? 0x0501 : 0);
	}

	IObjectWithSite *piows;

	hr = HrQueryInterface(punk, false, L"IObjectWithSite", IID_PPV_ARGS(&piows));

	if (SUCCEEDED(hr))
	{
		hr = piows->SetSite(piocs);

		if (FAILED(hr))
		{
			ReportFailure(0x0502, false, piows, 3, L"IObjectWithSite::SetSite failed.  hr = %08X", hr);
		}

		Release(piows, false);

		return(FAILED(hr) ? 0x0502 : 0);
	}

	return(-1);
}


int SetSite(IUnknown *punk, IOleClientSite *piocs)
{
	if (fHTML)
	{
		// With -html we don't want to override the HTML site

		return(-1);
	}

	return(SetSiteAlways(punk, piocs));
}

class __declspec(uuid("f52e3884-8f28-4daa-9fa8-1f49bed0d496")) CTrigger sealed : public IClassFactory
{
public:
	CTrigger() : m_cref(1), m_clock(0)
	{
	};

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvObject);
	HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

public:
	ULONG m_cref;
	ULONG m_clock;
};


HRESULT STDMETHODCALLTYPE CTrigger::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) this;
	}

	else if (IsEqualGUID(riid, IID_IClassFactory))
	{
		*ppvObject = (IClassFactory *) this;
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE CTrigger::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE CTrigger::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


HRESULT STDMETHODCALLTYPE CTrigger::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
	wchar_t szIidT[39];

	StringFromGUID2(iid, szIidT, _countof(szIidT));

	ReportFailure(0x3201, false, NULL, 0, L"CTrigger::CreateInstance(%p, %s)", punkOuter, szIidT);

	*ppvObject = NULL;

	return(E_ABORT);
}


HRESULT STDMETHODCALLTYPE CTrigger::LockServer(BOOL fLock)
{
	if (fLock)
	{
		m_clock++;
	}

	else
	{
		m_clock--;
	}

	return(S_OK);
}



class COuter sealed : public IUnknown
{
public:
	COuter() : m_cref(1), m_punkInner(NULL)
	{
	};

	~COuter();

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

public:
	ULONG m_cref;
	IUnknown *m_punkInner;
};


COuter::~COuter()
{
	if (m_punkInner != NULL)
	{
		// The inner object may call AddRef and Release on this object.
		// Dump the ref count so that this does not allow the ref count
		// to drop to zero again and reenter this code.

		AddRef();

		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(m_punkInner, 2);

		// Don't call ::Release() since it is the grandparent of this call
		// and is already decrementing dwNonClass

		ULONG cref = m_punkInner->Release();

		if (cref != 0)
		{
			ReportFailure(0x0601, false, pvRelease, -1, L"IUnknown::Release returned %u", cref);
		}

		if (m_cref != 1)
		{
			ReportFailure(0x0602, false, pvRelease, -1, L"IUnknown::Release changed ref count of punkOuter (%u)", m_cref);
		}
	}
}


HRESULT STDMETHODCALLTYPE COuter::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) this;
	}

	else if (m_punkInner != NULL)
	{
		return m_punkInner->QueryInterface(riid, ppvObject);
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE COuter::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE COuter::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


class CSite sealed : public IOleClientSite, public IOleControlSite, public IOleInPlaceSite, public IServiceProvider, public IDispatch, public IInternetSecurityManagerEx2
{
public:
	CSite() : m_cref(1) {};

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IOleClientSite

	HRESULT STDMETHODCALLTYPE SaveObject();
	HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
	HRESULT STDMETHODCALLTYPE GetContainer(IOleContainer **ppContainer);
	HRESULT STDMETHODCALLTYPE ShowObject();
	HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
	HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

	// IOleControlSite

	HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
	HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
	HRESULT STDMETHODCALLTYPE GetExtendedControl(IDispatch **ppDisp);
	HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *pMsg, DWORD grfModifiers);
	HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
	HRESULT STDMETHODCALLTYPE ShowPropertyFrame();

	// IOleWindow

	HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
	HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);

	// IOleInPlaceSite

	HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
	HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
	HRESULT STDMETHODCALLTYPE OnUIActivate();
	HRESULT STDMETHODCALLTYPE GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	HRESULT STDMETHODCALLTYPE Scroll(SIZE scrollExtant);
	HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL fUndoable);
	HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
	HRESULT STDMETHODCALLTYPE DiscardUndoState();
	HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
	HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT lprcPosRect);

	// IServiceProvider

	HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

	// IDispatch

	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

	// IInternetSecurityManager

	HRESULT STDMETHODCALLTYPE SetSecuritySite(IInternetSecurityMgrSite *pSite);
	HRESULT STDMETHODCALLTYPE GetSecuritySite(IInternetSecurityMgrSite **ppSite);
	HRESULT STDMETHODCALLTYPE MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
	HRESULT STDMETHODCALLTYPE ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

	// IInternetSecurityManagerEx

	HRESULT STDMETHODCALLTYPE ProcessUrlActionEx(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved, DWORD *pdwOutFlags);

	// IInternetSecurityManagerEx2

	HRESULT STDMETHODCALLTYPE MapUrlToZoneEx2(IUri *pUri, DWORD *pdwZone, DWORD dwFlags, LPWSTR *ppwszMappedUrl, DWORD *pdwOutFlags);
	HRESULT STDMETHODCALLTYPE ProcessUrlActionEx2(IUri *pUri, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD_PTR dwReserved, DWORD *pdwOutFlags);
	HRESULT STDMETHODCALLTYPE GetSecurityIdEx2(IUri *pUri, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
	HRESULT STDMETHODCALLTYPE QueryCustomPolicyEx2(IUri *pUri, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD_PTR dwReserved);

	// IDocHostUIHandler

	// UNDONE:

	// IDocHostUIHandler2

	// UNDONE:


public:
	ULONG m_cref;
};

HRESULT STDMETHODCALLTYPE CSite::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) (IOleClientSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleClientSite))
	{
		*ppvObject = (IOleClientSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleControlSite))
	{
		*ppvObject = (IOleControlSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleWindow))
	{
		*ppvObject = (IOleWindow *) (IOleInPlaceSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleInPlaceSite))
	{
		*ppvObject = (IOleInPlaceSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IServiceProvider))
	{
		*ppvObject = (IServiceProvider *) this;
	}

	else if (IsEqualGUID(riid, IID_IDispatch))
	{
		*ppvObject = (IDispatch *) this;
	}

	else if (IsEqualGUID(riid, __uuidof(IInternetSecurityManagerEx2)))
	{
		*ppvObject = (IInternetSecurityManagerEx2 *) this;
	}

	else if (IsEqualGUID(riid, IID_IInternetSecurityManagerEx))
	{
		*ppvObject = (IInternetSecurityManagerEx *) this;
	}

	else if (IsEqualGUID(riid, IID_IInternetSecurityManager))
	{
		*ppvObject = (IInternetSecurityManager *) this;
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE CSite::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE CSite::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


HRESULT STDMETHODCALLTYPE CSite::SaveObject()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
	*ppmk = NULL;

	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetContainer(IOleContainer **ppContainer)
{
	*ppContainer = NULL;

	return(E_NOINTERFACE);
}


HRESULT STDMETHODCALLTYPE CSite::ShowObject()
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::OnShowWindow(BOOL fShow)
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::RequestNewObjectLayout()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnControlInfoChanged()
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::LockInPlaceActive(BOOL fLock)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetExtendedControl(IDispatch **ppDisp)
{
	AddRef();

	*ppDisp = this;

	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer, DWORD dwFlags)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::TranslateAccelerator(MSG *pMsg, DWORD grfModifiers)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnFocus(BOOL fGotFocus)
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::ShowPropertyFrame()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetWindow(HWND *phwnd)
{
	*phwnd = NULL;

	return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CSite::ContextSensitiveHelp(BOOL fEnterMode)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::CanInPlaceActivate()
{
	return(S_FALSE);
}


HRESULT STDMETHODCALLTYPE CSite::OnInPlaceActivate()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnUIActivate()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	*ppFrame = NULL;
	*ppDoc = NULL;

	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::Scroll(SIZE scrollExtant)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnUIDeactivate(BOOL fUndoable)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnInPlaceDeactivate()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::DiscardUndoState()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::DeactivateAndUndo()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnPosRectChange(LPCRECT lprcPosRect)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
	// Check if marshaling between MSHTML and COMCHK is expected.  If it is
	// do not support IInternetSecurityManager* because it will not work.
	// This is because URLMON passes NULL for parameters that RPC does not
	// allow to be NULL.

	bool fMarshal = (szMT == NULL) ? fMTA : ((dwCoinit2 & COINIT_APARTMENTTHREADED) == 0);
	if (!fMarshal)
	{

		if (IsEqualGUID(guidService, SID_SInternetSecurityManagerEx2) &&
			IsEqualGUID(riid, __uuidof(IInternetSecurityManagerEx2)))
		{
			// IE 7.0 or later

			return(QueryInterface(riid, ppvObject));
		}

		else if (IsEqualGUID(guidService, SID_SInternetSecurityManagerEx) &&
			IsEqualGUID(riid, IID_IInternetSecurityManagerEx))
		{
			// IE 6.0 SP2 or later

			return(QueryInterface(riid, ppvObject));
		}

		else if (IsEqualGUID(guidService, SID_SInternetSecurityManager) &&
			IsEqualGUID(riid, IID_IInternetSecurityManager))
		{
			return(QueryInterface(riid, ppvObject));
		}
	}

	*ppvObject = NULL;

	// UNDONE: What is correct return for when service not recognized

	return(E_NOINTERFACE);
}


HRESULT STDMETHODCALLTYPE CSite::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	*ppTInfo = NULL;

	return(DISP_E_BADINDEX);
}


HRESULT STDMETHODCALLTYPE CSite::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
	for (UINT i = 0; i < cNames; i++)
	{
		rgDispId[i] = DISPID_UNKNOWN;
	}

	return(DISP_E_UNKNOWNNAME);
}


HRESULT STDMETHODCALLTYPE CSite::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	return(DISP_E_MEMBERNOTFOUND);
}

HRESULT STDMETHODCALLTYPE CSite::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
	*ppSite = NULL;

	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
	if (szZone != NULL)
	{
		*pdwZone = dwZone;

		return(S_OK);
	}

	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
	if (cbPolicy < sizeof(DWORD))
	{
		return(INET_E_DEFAULT_ACTION);
	}

	switch (dwAction)
	{
	case URLACTION_ACTIVEX_OVERRIDE_OPTIN :
	case URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION :
	case URLACTION_ACTIVEX_RUN :
	case URLACTION_BEHAVIOR_RUN :
	case URLACTION_SCRIPT_SAFE_ACTIVEX :
		break;

	case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY :
	case URLACTION_SCRIPT_OVERRIDE_SAFETY :
		if (!fNoOverrideSafety)
		{
			break;
		}

		// Fall through

	default :
		return(INET_E_DEFAULT_ACTION);
	}

	*(DWORD *) pPolicy = URLPOLICY_ALLOW;

	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CSite::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}


HRESULT STDMETHODCALLTYPE CSite::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
	return(INET_E_DEFAULT_ACTION);
}


HRESULT STDMETHODCALLTYPE CSite::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::ProcessUrlActionEx(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved, DWORD *pdwOutFlags)
{
	if (cbPolicy < sizeof(DWORD))
	{
		return(INET_E_DEFAULT_ACTION);
	}

	switch (dwAction)
	{
	case URLACTION_ACTIVEX_OVERRIDE_OPTIN :
	case URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION :
	case URLACTION_ACTIVEX_RUN :
	case URLACTION_BEHAVIOR_RUN :
	case URLACTION_SCRIPT_SAFE_ACTIVEX :
		break;

	case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY :
	case URLACTION_SCRIPT_OVERRIDE_SAFETY :
		if (!fNoOverrideSafety)
		{
			break;
		}

		// Fall through

	default :
		return(INET_E_DEFAULT_ACTION);
	}

	*(DWORD *) pPolicy = URLPOLICY_ALLOW;

	*pdwOutFlags = PUAFOUT_DEFAULT;

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::MapUrlToZoneEx2(IUri *pUri, DWORD *pdwZone, DWORD dwFlags, LPWSTR *ppwszMappedUrl, DWORD *pdwOutFlags)
{
	if (szZone != NULL)
	{
		*pdwZone = dwZone;

		return(S_OK);
	}

	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::ProcessUrlActionEx2(IUri *pUri, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD_PTR dwReserved, DWORD *pdwOutFlags)
{
	if (cbPolicy < sizeof(DWORD))
	{
		return(INET_E_DEFAULT_ACTION);
	}

	switch (dwAction)
	{
	case URLACTION_ACTIVEX_OVERRIDE_OPTIN :
	case URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION :
	case URLACTION_ACTIVEX_RUN :
	case URLACTION_BEHAVIOR_RUN :
	case URLACTION_SCRIPT_SAFE_ACTIVEX :
		break;

	case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY :
	case URLACTION_SCRIPT_OVERRIDE_SAFETY :
		if (!fNoOverrideSafety)
		{
			break;
		}

		// Fall through

	default :
		return(INET_E_DEFAULT_ACTION);
	}

	*(DWORD *) pPolicy = URLPOLICY_ALLOW;

	*pdwOutFlags = PUAFOUT_DEFAULT;

	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CSite::GetSecurityIdEx2(IUri *pUri, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}


HRESULT STDMETHODCALLTYPE CSite::QueryCustomPolicyEx2(IUri *pUri, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD_PTR dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}




class PropName
{
public:
	PropName(const wchar_t *);
	PropName(const PropName&);
	~PropName();

	wchar_t *m_sz;
};


PropName::PropName(const wchar_t *sz)
{
	m_sz = _wcsdup(sz);
}


PropName::PropName(const PropName& pn)
{
	m_sz = _wcsdup(pn.m_sz);
}


PropName::~PropName()
{
	free(m_sz);
}


bool operator<(const PropName& pnLeft, const PropName& pnRight)
{
	return(wcscmp(pnLeft.m_sz, pnRight.m_sz) < 0);
}


template<>
struct std::pair<const PropName, VARIANT>
{
	pair(const PropName&, const VARIANT&);
	pair(const pair&);
	~pair();

	PropName first;		       // the first stored value
	VARIANT second;		       // the second stored value
};


std::pair<const PropName, VARIANT>::pair(const PropName& pn, const VARIANT& var) : first(pn)
{
	VariantInit(&second);
	VariantCopy(&second, (VARIANT *) &var);
}


std::pair<const PropName, VARIANT>::pair(const pair& p) : first(p.first)
{
	VariantInit(&second);
	VariantCopy(&second, (VARIANT *) &p.second);
}


std::pair<const PropName, VARIANT>::~pair()
{
	VariantClear(&second);
}


class CPropertyBag sealed : public IPropertyBag
{
public:
	CPropertyBag() : m_cref(1) {};

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE Read(LPCOLESTR szPropName, VARIANT *pvar, IErrorLog *piel);
	HRESULT STDMETHODCALLTYPE Write(LPCOLESTR szPropName, VARIANT *pvar);

public:
	typedef std::pair<const PropName, VARIANT> NameAndValue;
	typedef std::map<const PropName, VARIANT> PropertyMap;

	ULONG m_cref;

	PropertyMap m_pm;
};


HRESULT STDMETHODCALLTYPE CPropertyBag::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) this;
	}

	else if (IsEqualGUID(riid, IID_IPropertyBag))
	{
		*ppvObject = (IPropertyBag *) this;
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE CPropertyBag::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE CPropertyBag::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


HRESULT STDMETHODCALLTYPE CPropertyBag::Read(LPCOLESTR szPropName, VARIANT *pvar, IErrorLog *piel)
{
#if 0
	wprintf(L"*** reading %s of type %u\n", szPropName, pvar->vt);
#endif

	if (piel != NULL)
	{
		TestInterface(piel, NULL, false, false);
	}

	VARTYPE vt = pvar->vt;

	// Initialize the output.  The only member that is required to be initialized
	// is vt.  Specifically, the value may be garbage.  Both VariantChangeType
	// and VariantCopy below will pass this to VariantClear which will do bad
	// things with the garbage.

	MyVariantInit(pvar);

	HRESULT hr;

	PropName pn(szPropName);

	PropertyMap::const_iterator it = m_pm.find(pn);

	if (it == m_pm.end())
	{
		// Property not found.  Always try to return some default value

		if (vt == VT_EMPTY)
		{
			// The VARIANT is already VT_EMPTY.  Don't call VariantChangeType because
			// it will store uninitialized values in the other members.  We want the
			// initialized values from MyVariantInit to be preserved.

			return(S_OK);
		}

		hr = VariantChangeType(pvar, pvar, 0, vt);

		return(SUCCEEDED(hr) ? hr : E_INVALIDARG);
	}

	if (vt == VT_EMPTY)
	{
		hr = VariantCopy(pvar, (VARIANT *) &it->second);
	}

	else
	{
		hr = VariantChangeType(pvar, (VARIANT *) &it->second, VARIANT_NOVALUEPROP, vt);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CPropertyBag::Write(LPCOLESTR szPropName, VARIANT *pvar)
{
#if 0
	wprintf(L"*** writing %s of type %u\n", szPropName, pvar->vt);
#endif

	switch (pvar->vt)
	{
	case VT_DISPATCH :
		if (V_DISPATCH(pvar) != NULL)
		{
			TestInterface(V_DISPATCH(pvar), NULL, false, false);
		}
		break;

	case VT_UNKNOWN :
		if (V_UNKNOWN(pvar) != NULL)
		{
			TestInterface(V_UNKNOWN(pvar), NULL, true, false);
		}
		break;

	case VT_STREAM :
	case VT_STORAGE :
	case VT_STREAMED_OBJECT :
	case VT_STORED_OBJECT :
	case VT_BLOB_OBJECT :
		break;
	}

	PropName pn(szPropName);
	NameAndValue nav(pn, *pvar);

	std::pair<PropertyMap::iterator, bool> pr = m_pm.insert(nav);

	if (!pr.second)
	{
		// Property already exists.  Update value

		VariantCopy(&pr.first->second, pvar);
	}

	return(S_OK);
}


void DoRecurse(const wchar_t *szPrefixT)
{
	fflush(NULL);

	STARTUPINFO si;

	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	PROCESS_INFORMATION pi;

	wchar_t szCommandLine[4096];
	const size_t cchCommandLine = _countof(szCommandLine);

	const wchar_t *szProgram = (szInvoke != NULL) ? szInvoke : _wpgmptr;

	wcscpy_s(szCommandLine, cchCommandLine, L"\"");
	wcsncat_s(szCommandLine, cchCommandLine, szProgram, _TRUNCATE);
	wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);

	if (szInvoke != NULL)
	{
		if (szInvokePrefix != NULL)
		{
			DWORD_PTR rgarg[3] =
			{
				(DWORD_PTR) szClsid,
				(DWORD_PTR) szProgid,
				(DWORD_PTR) szIid,
			};

			wchar_t *sz;

			DWORD dw = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_STRING |
				FORMAT_MESSAGE_ARGUMENT_ARRAY,
				szInvokePrefix,
				0,
				0,
				(LPWSTR) &sz,
				0,
				(va_list *) rgarg);

			if (dw == 0)
			{
				wprintf(L"FormatMessage failed.  GetLastError() = %u\n", GetLastError());
				return;
			}

			wcsncat_s(szCommandLine, cchCommandLine, L" ", _TRUNCATE);
			wcsncat_s(szCommandLine, cchCommandLine, sz, _TRUNCATE);

			LocalFree(sz);
		}

		wcsncat_s(szCommandLine, cchCommandLine, L" \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, _wpgmptr, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (blevel)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -level \"", _TRUNCATE);
		WCHAR wc[20];
		_itow(ilevel, wc, 10);
		wcsncat_s(szCommandLine, cchCommandLine, wc, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szAddToDocument)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -addtodocument \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szAddToDocument, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fAggregate)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -aggregate", _TRUNCATE);
	}

	if (fBindToObject)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -bindtoobject", _TRUNCATE);
	}

	if (fBindToStorage)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -bindtostorage", _TRUNCATE);
	}

	if (fCheckSafety)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -checksafety", _TRUNCATE);
	}

	if (szClsctx != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -clsctx \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szClsctx, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if ((szClsid != NULL) && (szProgid == NULL))
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -clsid \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szClsid, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fCreateOnly)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -createonly", _TRUNCATE);
	}

	if (szData != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -data \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szData, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szDispatchMax != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -dispatchmax \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szDispatchMax, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fFakeDebugger)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -fakedebugger", _TRUNCATE);
	}

	if (fFreeCO)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -freeco", _TRUNCATE);
	}


	if (fIgnoreRpcExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -ignorerpcexcept", _TRUNCATE);
	}

	if (fHTML && !fWebBrowser)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -html", _TRUNCATE);
	}

	if (fStdModes)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -stdmodes", _TRUNCATE);
	}

	if (szHookDll != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -hookdll \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szHookDll, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szIid != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -iid \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szIid, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szMoniker != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -moniker \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szMoniker, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szMT != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -mt \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szMT, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fMTA)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -mta", _TRUNCATE);
	}

	if (fNoCategoryCheck)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nocategorycheck", _TRUNCATE);
	}

	if (fNoVectoredExceptions)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noexcept", _TRUNCATE);
	}

	if (fNoFakeDebugger)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nofakedebugger", _TRUNCATE);
	}

	if (fNoFree)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nofree", _TRUNCATE);
	}

	if (fNoIDispatch)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noidispatch", _TRUNCATE);
	}

	if (fNoIDispatchFuzz)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noidispatchfuzz", _TRUNCATE);
	}

	if (fNoIgnoreBreakpoint)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorebreakpoint", _TRUNCATE);
	}

	if (fNoIgnoreClrExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignoreclrexcept", _TRUNCATE);
	}

	if (fNoIgnoreCppExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorecppexcept", _TRUNCATE);
	}

	if (fNoIgnoreDelayLoadExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignoredelayloadexcept", _TRUNCATE);
	}

	if (fNoIgnoreFloatExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorefloatexcept", _TRUNCATE);
	}

	if (fNoIgnoreXmlExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorexmlexcept", _TRUNCATE);
	}

	if (fNoOverrideSafety)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nooverridesafety", _TRUNCATE);
	}

	if (fNoPatchBreakpoint)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nopatchbreakpoint", _TRUNCATE);
	}

	if (fNoWindowHook)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nowindowhook", _TRUNCATE);
	}

	if (fObjrefMoniker)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -objref", _TRUNCATE);
	}

	if (szPrefixT != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -prefix \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szPrefixT, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szProgid != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -progid \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szProgid, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fSafeForInitializing)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -safeforinitializing", _TRUNCATE);
	}

	if (fSafeForScripting)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -safeforscripting", _TRUNCATE);
	}

	if (fSDL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -sdlout", _TRUNCATE);
	}

	if (fSilent)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -silent", _TRUNCATE);
	}

	if (szTimeout != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -timeout \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szTimeout, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fTryQI)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -tryqi", _TRUNCATE);
	}

	if (szUrl != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -url \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szUrl, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fUrlMoniker)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -urlmoniker", _TRUNCATE);
	}

	if (fUseCF)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -usecf", _TRUNCATE);
	}

	if (fUsePS)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -useps", _TRUNCATE);
	}

	if (fVerbose)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -verbose", _TRUNCATE);
	}

	if (fWebBrowser)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -webbrowser", _TRUNCATE);
	}

	if (szZone != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -zone \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szZone, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}


	if (!CreateProcess(szProgram,
		szCommandLine,
		NULL,
		NULL,
		FALSE,			
		0,
		NULL,
		NULL,
		&si,
		&pi))
	{
		wprintf(L"CreateProcess() failed.  GetLastError() = %u\n", GetLastError());

		return;
	}

	CloseHandle(pi.hThread);

	DWORD dw = WaitForSingleObject(pi.hProcess, fStdModes ? INFINITE : dwTimeout);

	if (dw == WAIT_TIMEOUT)
	{
		wprintf(L"*Timeout: %s\n", szCommandLine);

		PipeMsg pmTO;
		pmTO.AddDWORD(5);
		pmTO.AddString(szCommandLine);
		pmTO.Send(hPipeInfoSend);

		TerminateProcess(pi.hProcess, 0xFFFFFFFF);
	}

	else if (GetExitCodeProcess(pi.hProcess, &dw))
	{
		if (dw != 0)
		{
			// Richard -- is this necessary?  Should be already reported.
			//		   wprintf(L"%08X: %s\n", dw, szCommandLine);

		}
	}

	else
	{
		wprintf(L"????????: %s\n", szCommandLine);
		PipeMsg pmHuh;
		pmHuh.AddDWORD(6);
		pmHuh.AddString(szCommandLine);
		pmHuh.Send(hPipeInfoSend);
	}

	CloseHandle(pi.hProcess);

}




int DoStdModes()
{
	fStdModes = false;		// suppress for recursion

	_putws(L"--------: Start default parameters");

	DoRecurse(NULL);

	_putws(L"--------: Finished default parameters");

	_putws(L"--------: Start -mta");

	fMTA = true;

	DoRecurse(NULL);

	fMTA = false;

	_putws(L"--------: Finished -mta");

	_putws(L"--------: Start -aggregate");

	fAggregate = true;

	DoRecurse(NULL);

	fAggregate = false;

	_putws(L"--------: Finished -aggregate");

	_putws(L"--------: Start -aggregate -mta");

	fAggregate = true;
	fMTA = true;

	DoRecurse(NULL);

	fMTA = false;
	fAggregate = false;

	_putws(L"--------: Finished -aggregate -mta");

	if (!fUsePS)
	{
		_putws(L"--------: Start -usecf");

		fUseCF = true;

		DoRecurse(NULL);

		fUseCF = false;

		_putws(L"--------: Finished -usecf");

		_putws(L"--------: Start -mta -usecf");

		fMTA = true;
		fUseCF = true;

		DoRecurse(NULL);

		fMTA = false;
		fUseCF = false;

		_putws(L"--------: Finished -mta -usecf");

		_putws(L"--------: Start -html");

		fHTML = true;

		DoRecurse(NULL);

		fHTML = false;

		_putws(L"--------: Finished -html");

		_putws(L"--------: Start -webbrowser");

		fWebBrowser = true;

		DoRecurse(NULL);

		fWebBrowser = false;

		_putws(L"--------: Finished -webbrowser");
	}

	return(0);
}


int DoAllClsids()
{
	HKEY hkeyClsid;

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_READ, &hkeyClsid))
	{
		wprintf(L"RegOpenKeyEx() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	wchar_t szClsidT[256];

	szClsid = szClsidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(hkeyClsid, ikey, szClsidT, _countof(szClsidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		if (szClsidT[0] != L'{')
		{
			continue;
		}

		DoRecurse(NULL);
	}

	if (RegCloseKey(hkeyClsid))
	{
		wprintf(L"RegCloseKey() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	return(0);
}


int DoClsidsFromFile(const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szClsidT[256];

	while (fgetws(szClsidT, 256, pfile))
	{
		szClsid = szClsidT;

		// Skip leading white space.

		while ((szClsid[0] == L' ') || (szClsid[0] == L'\t'))
		{
			szClsid++;
		}

		if (szClsid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szClsid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szClsid;

		for (wchar_t *pch = szClsid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		DoRecurse(NULL);
	}

	fclose(pfile);

	return(0);
}


int DoAllIids()
{
	HKEY hkeyInterface;

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Interface"), 0, KEY_READ, &hkeyInterface))
	{
		wprintf(L"RegOpenKeyEx() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	wchar_t szIidT[256];

	szIid = szIidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(hkeyInterface, ikey, szIidT, _countof(szIidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		// UNDONE: Compose prefix if szProgid or szClsid != NULL

		DoRecurse(NULL);
	}

	if (RegCloseKey(hkeyInterface))
	{
		wprintf(L"RegCloseKey() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	return(0);
}


int DoIidsFromFile(const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szIidT[256];

	while (fgetws(szIidT, 256, pfile))
	{
		szIid = szIidT;

		// Skip leading white space.

		while ((szIid[0] == L' ') || (szIid[0] == L'\t'))
		{
			szIid++;
		}

		if (szIid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szIid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szIid;

		for (wchar_t *pch = szIid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		// UNDONE: Compose prefix if szProgid or szClsid != NULL

		DoRecurse(NULL);
	}

	fclose(pfile);

	return(0);
}


int QueryInterfaceAllIids(IUnknown *punk, bool fClassObject)
{
	HKEY hkeyInterface;

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Interface"), 0, KEY_READ, &hkeyInterface))
	{
		wprintf(L"RegOpenKeyEx() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	wchar_t szIidT[256];

	szIid = szIidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(hkeyInterface, ikey, szIidT, _countof(szIidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		IID iidT;

		HRESULT hr = IIDFromString(szIidT, &iidT);

		if (FAILED(hr))
		{
			wprintf(L"Invalid IID \"%s\".  HRESULT = %08X\n", szIidT, hr);
			continue;
		}

		const wchar_t *szIidName;

		wchar_t szName[256];
		long cbName = sizeof(szName);

		if (RegQueryValue(hkeyInterface, szIidT, szName, &cbName) == 0)
		{
			szName[255] = L'\0';

			szIidName = szName;
		}

		else
		{
			szIidName = szIidT;
		}

		IUnknown *punkT;

		hr = HrQueryInterface(punk, fClassObject, szIidName, iidT, (void **) &punkT);

		if (SUCCEEDED(hr))
		{
			if (szIidName != szIidT)
			{
				ReportFailure(0x0701, fCreateOnly, NULL, 0, L"QueryInterface(%s) succeeded: %s", szIidT, szIidName);
			}
			else
			{
				ReportFailure(0x0701, fCreateOnly, NULL, 0, L"QueryInterface(%s) succeeded", szIidT);
			}

			Release(punkT, fClassObject);
		}
	}

	if (RegCloseKey(hkeyInterface))
	{
		wprintf(L"RegCloseKey() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	return(0);
}


int QueryInterfaceIidsFromFile(IUnknown *punk, bool fClassObject, const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szIidT[256];

	while (fgetws(szIidT, 256, pfile))
	{
		szIid = szIidT;

		// Skip leading white space.

		while ((szIid[0] == L' ') || (szIid[0] == L'\t'))
		{
			szIid++;
		}

		if (szIid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szIid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szIid;

		for (wchar_t *pch = szIid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		IID iidT;

		HRESULT hr = IIDFromString(szIidT, &iidT);

		if (FAILED(hr))
		{
			wprintf(L"Invalid IID \"%s\".  HRESULT = %08X\n", szIidT, hr);
			continue;
		}

		IUnknown *punkT;

		hr = HrQueryInterface(punk, fClassObject, szIidT, iidT, (void **) &punkT);

		if (SUCCEEDED(hr))
		{
			ReportFailure(0x0801, fCreateOnly, NULL, 0, L"QueryInterface(%s) succeeded", szIidT);

			Release(punkT, fClassObject);
		}
	}

	fclose(pfile);

	return(0);
}


int DoAllProgids()
{
	wchar_t szProgidT[MAX_PATH];

	szProgid = szProgidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(HKEY_CLASSES_ROOT, ikey, szProgidT, _countof(szProgidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		if (szProgid[0] == L'.')
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"*") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"APPID") == 0)
		{
			continue;
		}

#if 0
		if (_wcsicmp(szProgid, L"CLSID") == 0)
		{
			continue;
		}
#endif

		if (_wcsicmp(szProgid, L"Component Categories") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"Interface") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"MIME") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"PROTOCOLS") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"SystemFileAssociations") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"TypeLib") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"Wow6432Node") == 0)
		{
			continue;
		}

		wchar_t szT[MAX_PATH + 6];

		wcscpy_s(szT, _countof(szT), szProgid);
		wcscat_s(szT, _countof(szT), L"\\CLSID");

		LONG cbClsid;

		l = RegQueryValue(HKEY_CLASSES_ROOT, szT, NULL, &cbClsid);

		if (l == ERROR_PATH_NOT_FOUND)
		{
			continue;
		}

		CLSID clsidT;

		HRESULT hr = CLSIDFromProgID(szProgid, &clsidT);

		if (FAILED(hr))
		{
			continue;
		}

		DoRecurse(NULL);
	}

	return(0);
}


int DoProgidsFromFile(const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szProgidT[256];

	while (fgetws(szProgidT, 256, pfile))
	{
		szProgid = szProgidT;

		// Skip leading white space.

		while ((szProgid[0] == L' ') || (szProgid[0] == L'\t'))
		{
			szProgid++;
		}

		if (szProgid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szProgid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szProgid;

		for (wchar_t *pch = szProgid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		DoRecurse(NULL);
	}

	fclose(pfile);

	return(0);
}


int CheckObjrefMoniker(IUnknown *punk, bool fClassObject)
{
	IMoniker *pmk;

	HRESULT hr = CreateObjrefMoniker(punk, &pmk);

	if (SUCCEEDED(hr))
	{
		IncrementObjectCount(fClassObject);

		FreeUnusedLibraries();

		IBindCtx *pbc = NULL;

		HRESULT hr = CreateBindCtx(0, &pbc);

		if (SUCCEEDED(hr))
		{
			wchar_t *szDisplayName;

			hr = pmk->GetDisplayName(pbc, NULL, &szDisplayName);

			if (SUCCEEDED(hr))
			{
#if 0
				wprintf(L"Moniker: %s\n", szDisplayName);
#endif

				DWORD cchEaten;
				IMoniker *pmk2;

				hr = MkParseDisplayName(pbc, szDisplayName, &cchEaten, &pmk2);

				if (SUCCEEDED(hr))
				{
					IncrementObjectCount(fClassObject);

					FreeUnusedLibraries();

					if (cchEaten != wcslen(szDisplayName))
					{
						ReportFailure(0x0901, false, NULL, 0, L"MkParseDisplayName consumed only part of OBJREF");
					}

					// Capture address of Release() method since after release the memory may be gone

					const void *pvRelease = PvMethod(pmk2, 2);

					ULONG cref = Release(pmk2, fClassObject);

					if (cref != 0)
					{
						ReportFailure(0x0902, false, pvRelease, -1, L"IMoniker::Release returned %u", cref);
					}
				}

				else
				{
					ReportFailure(0x0903, false, NULL, 0, L"MkParseDisplayName(\"%s\") failed.  hr = %08X", szDisplayName, hr);
				}

				CoTaskMemFree(szDisplayName);
			}

			else
			{
				ReportFailure(0x0904, false, pmk, 20, L"IMoniker::GetDisplayName failed.  hr = %08X", hr);
			}

			// Capture address of Release() method since after release the memory may be gone

			const void *pvRelease = PvMethod(pbc, 2);

			ULONG cref = pbc->Release();

			if (cref != 0)
			{
				ReportFailure(0x0905, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
			}
		}

		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(pmk, 2);

		ULONG cref = Release(pmk, fClassObject);

		if (cref != 0)
		{
			ReportFailure(0x0906, false, pvRelease, -1, L"IMoniker::Release returned %u", cref);
		}
	}

	return(0);
}



int GetInterfaceSafetyOptions(IObjectSafety *pios, REFIID iid, const wchar_t *szIid, bool *pfSupported, DWORD *pdwSupported, DWORD *pdwEnabled)
{
	HRESULT hr = pios->GetInterfaceSafetyOptions(iid, pdwSupported, pdwEnabled);

	*pfSupported = SUCCEEDED(hr);

	if (*pfSupported)
	{
		if (*pdwSupported & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_DISPEX | INTERFACE_USES_SECURITY_MANAGER))
		{
			ReportFailure(0x0A01, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s): Undefined options supported.  Supported=%08X, Enabled=%08X", szIid, *pdwSupported, *pdwEnabled);
		}

		if ((*pdwEnabled & ~*pdwSupported) != 0)
		{
			ReportFailure(0x0A02, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s): Unsupported options enabled.  Supported=%08X, Enabled=%08X", szIid, *pdwSupported, *pdwEnabled);
		}
	}

	else if (hr != E_NOINTERFACE)
	{
		ReportFailure(0x0A03, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) did not return E_NOINTERFACE.  hr = %08X", szIid, hr);
	}

	return(0);
}


int SetInterfaceSafetyOptions(IObjectSafety *pios, REFIID iid, const wchar_t *szIid, bool fSupported, DWORD dwSupported, DWORD dwEnabled)
{
	HRESULT hr = pios->SetInterfaceSafetyOptions(iid, dwSupported, dwEnabled);

	if (SUCCEEDED(hr))
	{
		if (!fSupported)
		{
			ReportFailure(0x0B01, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) succeeded when GetInterfaceSafetyOptions failed", szIid, dwSupported, dwEnabled);

			return(0x0B01);
		}

		DWORD dwSupportedT;
		DWORD dwEnabledT;

		hr = pios->GetInterfaceSafetyOptions(iid, &dwSupportedT, &dwEnabledT);

		if (SUCCEEDED(hr))
		{
			if (dwSupportedT != dwSupported)
			{
				ReportFailure(0x0B02, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported changed from %08X to %08X", szIid, dwSupported, dwSupportedT);
			}

			if (dwEnabledT != dwEnabled)
			{
				ReportFailure(0x0B03, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwEnabled changed from %08X to %08X", szIid, dwEnabled, dwEnabledT);
			}
		}

		else
		{
			ReportFailure(0x0B04, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failed.  hr = %08X", szIid, hr);

			return(0x0B04);
		}
	}

	// else if (fSupported)
	else if (fSupported && (dwSupported != 0))
	{
		ReportFailure(0x0B05, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) failed.  hr = %08X", szIid, dwSupported, dwEnabled, hr);
	}

	else
	{
		return(0);
	}

	hr = pios->SetInterfaceSafetyOptions(iid, ~dwSupported, 0);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x0B06, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) succeeded", szIid, ~dwSupported);
	}

	else if (hr != E_FAIL)
	{
		ReportFailure(0x0B07, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) did not return E_FAIL.  hr = %08X", szIid, ~dwSupported, hr);
	}

	hr = pios->SetInterfaceSafetyOptions(iid, dwSupported, 0);

	if (SUCCEEDED(hr))
	{
		DWORD dwSupportedT;
		DWORD dwEnabledT;

		hr = pios->GetInterfaceSafetyOptions(iid, &dwSupportedT, &dwEnabledT);

		if (SUCCEEDED(hr))
		{
			if (dwSupportedT != dwSupported)
			{
				ReportFailure(0x0B08, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported changed from %08X to %08X", szIid, dwSupported, dwSupportedT);
			}

			if (dwEnabledT != 0)
			{
				ReportFailure(0x0B09, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) set dwEnabled to %08X", szIid, dwSupported, dwEnabledT);
			}
		}

		else
		{
			ReportFailure(0x0B0A, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failed.  hr = %08X", szIid, hr);
		}
	}

	else
	{
		ReportFailure(0x0B0B, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) failed.  hr = %08X", szIid, dwSupported, hr);
	}

	hr = pios->SetInterfaceSafetyOptions(iid, dwSupported, dwEnabled);

	if (SUCCEEDED(hr))
	{
		DWORD dwSupportedT;
		DWORD dwEnabledT;

		hr = pios->GetInterfaceSafetyOptions(iid, &dwSupportedT, &dwEnabledT);

		if (SUCCEEDED(hr))
		{
			if (dwSupportedT != dwSupported)
			{
				ReportFailure(0x0B0C, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported changed from %08X to %08X", szIid, dwSupported, dwSupportedT);
			}

			if (dwEnabledT != dwEnabled)
			{
				ReportFailure(0x0B0D, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) set dwEnabled to %08X", szIid, dwSupported, dwEnabled, dwEnabledT);
			}
		}

		else
		{
			ReportFailure(0x0B0E, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failed.  hr = %08X", szIid, hr);
		}
	}

	else
	{
		ReportFailure(0x0B0F, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) failed.  hr = %08X", szIid, dwSupported, dwEnabled, hr);
	}

	return(0);
}


struct DISPIDS
{
	DISPID dispid;
	const wchar_t *sz;

};

const DISPIDS rgdispids[] =
{
	{ DISPID_VALUE,			     L"DISPID_VALUE"			       },
	{ DISPID_PROPERTYPUT,		     L"DISPID_PROPERTYPUT"		       },
	{ DISPID_NEWENUM,			     L"DISPID_NEWENUM"			       },
	{ DISPID_EVALUATE,			     L"DISPID_EVALUATE" 		       },
	{ DISPID_CONSTRUCTOR,		     L"DISPID_CONSTRUCTOR"		       },
	{ DISPID_DESTRUCTOR, 		     L"DISPID_DESTRUCTOR"		       },
	{ DISPID_COLLECT,			     L"DISPID_COLLECT"			       },

	{ DISPID_AUTOSIZE,			     L"DISPID_AUTOSIZE" 		       },
	{ DISPID_BACKCOLOR,			     L"DISPID_BACKCOLOR"		       },
	{ DISPID_BACKSTYLE,			     L"DISPID_BACKSTYLE"		       },
	{ DISPID_BORDERCOLOR,		     L"DISPID_BORDERCOLOR"		       },
	{ DISPID_BORDERSTYLE,		     L"DISPID_BORDERSTYLE"		       },
	{ DISPID_BORDERWIDTH,		     L"DISPID_BORDERWIDTH"		       },
	{ DISPID_DRAWMODE,			     L"DISPID_DRAWMODE" 		       },
	{ DISPID_DRAWSTYLE,			     L"DISPID_DRAWSTYLE"		       },
	{ DISPID_DRAWWIDTH,			     L"DISPID_DRAWWIDTH"		       },
	{ DISPID_FILLCOLOR,			     L"DISPID_FILLCOLOR"		       },
	{ DISPID_FILLSTYLE,			     L"DISPID_FILLSTYLE"		       },
	{ DISPID_FONT,			     L"DISPID_FONT"			       },
	{ DISPID_FORECOLOR,			     L"DISPID_FORECOLOR"		       },
	{ DISPID_ENABLED,			     L"DISPID_ENABLED"			       },
	{ DISPID_HWND,			     L"DISPID_HWND"			       },
	{ DISPID_TABSTOP,			     L"DISPID_TABSTOP"			       },
	{ DISPID_TEXT,			     L"DISPID_TEXT"			       },
	{ DISPID_CAPTION,			     L"DISPID_CAPTION"			       },
	{ DISPID_BORDERVISIBLE,		     L"DISPID_BORDERVISIBLE"		       },
	{ DISPID_APPEARANCE, 		     L"DISPID_APPEARANCE"		       },
	{ DISPID_MOUSEPOINTER,		     L"DISPID_MOUSEPOINTER"		       },
	{ DISPID_MOUSEICON,			     L"DISPID_MOUSEICON"		       },
	{ DISPID_PICTURE,			     L"DISPID_PICTURE"			       },
	{ DISPID_VALID,			     L"DISPID_VALID"			       },
	{ DISPID_READYSTATE, 		     L"DISPID_READYSTATE"		       },
	{ DISPID_LISTINDEX,			     L"DISPID_LISTINDEX"		       },
	{ DISPID_SELECTED,			     L"DISPID_SELECTED" 		       },
	{ DISPID_LIST,			     L"DISPID_LIST"			       },
	{ DISPID_COLUMN,			     L"DISPID_COLUMN"			       },
	{ DISPID_LISTCOUNT,			     L"DISPID_LISTCOUNT"		       },
	{ DISPID_MULTISELECT,		     L"DISPID_MULTISELECT"		       },
	{ DISPID_MAXLENGTH,			     L"DISPID_MAXLENGTH"		       },
	{ DISPID_PASSWORDCHAR,		     L"DISPID_PASSWORDCHAR"		       },
	{ DISPID_SCROLLBARS, 		     L"DISPID_SCROLLBARS"		       },
	{ DISPID_WORDWRAP,			     L"DISPID_WORDWRAP" 		       },
	{ DISPID_MULTILINE,			     L"DISPID_MULTILINE"		       },
	{ DISPID_NUMBEROFROWS,		     L"DISPID_NUMBEROFROWS"		       },
	{ DISPID_NUMBEROFCOLUMNS,		     L"DISPID_NUMBEROFCOLUMNS"		       },
	{ DISPID_DISPLAYSTYLE,		     L"DISPID_DISPLAYSTYLE"		       },
	{ DISPID_GROUPNAME,			     L"DISPID_GROUPNAME"		       },
	{ DISPID_IMEMODE,			     L"DISPID_IMEMODE"			       },
	{ DISPID_ACCELERATOR,		     L"DISPID_ACCELERATOR"		       },
	{ DISPID_ENTERKEYBEHAVIOR,		     L"DISPID_ENTERKEYBEHAVIOR" 	       },
	{ DISPID_TABKEYBEHAVIOR,		     L"DISPID_TABKEYBEHAVIOR"		       },
	{ DISPID_SELTEXT,			     L"DISPID_SELTEXT"			       },
	{ DISPID_SELSTART,			     L"DISPID_SELSTART" 		       },
	{ DISPID_SELLENGTH,			     L"DISPID_SELLENGTH"		       },
	{ DISPID_REFRESH,			     L"DISPID_REFRESH"			       },
	{ DISPID_DOCLICK,			     L"DISPID_DOCLICK"			       },
	{ DISPID_ABOUTBOX,			     L"DISPID_ABOUTBOX" 		       },
	{ DISPID_ADDITEM,			     L"DISPID_ADDITEM"			       },
	{ DISPID_CLEAR,			     L"DISPID_CLEAR"			       },
	{ DISPID_REMOVEITEM, 		     L"DISPID_REMOVEITEM"		       },
	{ DISPID_CLICK,			     L"DISPID_CLICK"			       },
	{ DISPID_DBLCLICK,			     L"DISPID_DBLCLICK" 		       },
	{ DISPID_KEYDOWN,			     L"DISPID_KEYDOWN"			       },
	{ DISPID_KEYPRESS,			     L"DISPID_KEYPRESS" 		       },
	{ DISPID_KEYUP,			     L"DISPID_KEYUP"			       },
	{ DISPID_MOUSEDOWN,			     L"DISPID_MOUSEDOWN"		       },
	{ DISPID_MOUSEMOVE,			     L"DISPID_MOUSEMOVE"		       },
	{ DISPID_MOUSEUP,			     L"DISPID_MOUSEUP"			       },
	{ DISPID_ERROREVENT, 		     L"DISPID_ERROREVENT"		       },
	{ DISPID_READYSTATECHANGE,		     L"DISPID_READYSTATECHANGE" 	       },
	{ DISPID_CLICK_VALUE,		     L"DISPID_CLICK_VALUE"		       },
	{ DISPID_RIGHTTOLEFT,		     L"DISPID_RIGHTTOLEFT"		       },
	{ DISPID_TOPTOBOTTOM,		     L"DISPID_TOPTOBOTTOM"		       },
	{ DISPID_THIS,			     L"DISPID_THIS"			       },
	{ DISPID_AMBIENT_BACKCOLOR,		     L"DISPID_AMBIENT_BACKCOLOR"	       },
	{ DISPID_AMBIENT_DISPLAYNAME,	     L"DISPID_AMBIENT_DISPLAYNAME"	       },
	{ DISPID_AMBIENT_FONT,		     L"DISPID_AMBIENT_FONT"		       },
	{ DISPID_AMBIENT_FORECOLOR,		     L"DISPID_AMBIENT_FORECOLOR"	       },
	{ DISPID_AMBIENT_LOCALEID,		     L"DISPID_AMBIENT_LOCALEID" 	       },
	{ DISPID_AMBIENT_MESSAGEREFLECT,	     L"DISPID_AMBIENT_MESSAGEREFLECT"	       },
	{ DISPID_AMBIENT_SCALEUNITS, 	     L"DISPID_AMBIENT_SCALEUNITS"	       },
	{ DISPID_AMBIENT_TEXTALIGN,		     L"DISPID_AMBIENT_TEXTALIGN"	       },
	{ DISPID_AMBIENT_USERMODE,		     L"DISPID_AMBIENT_USERMODE" 	       },
	{ DISPID_AMBIENT_UIDEAD,		     L"DISPID_AMBIENT_UIDEAD"		       },
	{ DISPID_AMBIENT_SHOWGRABHANDLES,	     L"DISPID_AMBIENT_SHOWGRABHANDLES"	       },
	{ DISPID_AMBIENT_SHOWHATCHING,	     L"DISPID_AMBIENT_SHOWHATCHING"	       },
	{ DISPID_AMBIENT_DISPLAYASDEFAULT,	     L"DISPID_AMBIENT_DISPLAYASDEFAULT"        },
	{ DISPID_AMBIENT_SUPPORTSMNEMONICS,	     L"DISPID_AMBIENT_SUPPORTSMNEMONICS"       },
	{ DISPID_AMBIENT_AUTOCLIP,		     L"DISPID_AMBIENT_AUTOCLIP" 	       },
	{ DISPID_AMBIENT_APPEARANCE, 	     L"DISPID_AMBIENT_APPEARANCE"	       },
	{ DISPID_AMBIENT_CODEPAGE,		     L"DISPID_AMBIENT_CODEPAGE" 	       },
	{ DISPID_AMBIENT_PALETTE,		     L"DISPID_AMBIENT_PALETTE"		       },
	{ DISPID_AMBIENT_CHARSET,		     L"DISPID_AMBIENT_CHARSET"		       },
	{ DISPID_AMBIENT_TRANSFERPRIORITY,	     L"DISPID_AMBIENT_TRANSFERPRIORITY"        },
	{ DISPID_AMBIENT_RIGHTTOLEFT,	     L"DISPID_AMBIENT_RIGHTTOLEFT"	       },
	{ DISPID_AMBIENT_TOPTOBOTTOM,	     L"DISPID_AMBIENT_TOPTOBOTTOM"	       },
	{ DISPID_Name,			     L"DISPID_Name"			       },
	{ DISPID_Delete,			     L"DISPID_Delete"			       },
	{ DISPID_Object,			     L"DISPID_Object"			       },
	{ DISPID_Parent,			     L"DISPID_Parent"			       },

	{ DISPID_MSDATASRCINTERFACE, 	     L"DISPID_MSDATASRCINTERFACE"	       },
	{ DISPID_ADVISEDATASRCCHANGEEVENT,	     L"DISPID_ADVISEDATASRCCHANGEEVENT"        },

	{ DISPID_AMBIENT_OFFLINEIFNOTCONNECTED,   L"DISPID_AMBIENT_OFFLINEIFNOTCONNECTED"   },
	{ DISPID_AMBIENT_SILENT,		     L"DISPID_AMBIENT_SILENT"		       },

	{ DISPID_WINDOWOBJECT,		     L"DISPID_WINDOWOBJECT"		       },
	{ DISPID_LOCATIONOBJECT,		     L"DISPID_LOCATIONOBJECT"		       },
	{ DISPID_HISTORYOBJECT,		     L"DISPID_HISTORYOBJECT"		       },
	{ DISPID_NAVIGATOROBJECT,		     L"DISPID_NAVIGATOROBJECT"		       },
	{ DISPID_SECURITYCTX,		     L"DISPID_SECURITYCTX"		       },
	{ DISPID_AMBIENT_DLCONTROL,		     L"DISPID_AMBIENT_DLCONTROL"	       },
	{ DISPID_AMBIENT_USERAGENT,		     L"DISPID_AMBIENT_USERAGENT"	       },
	{ DISPID_SECURITYDOMAIN,		     L"DISPID_SECURITYDOMAIN"		       },
	{ DISPID_DEBUG_ISSECUREPROXY,	     L"DISPID_DEBUG_ISSECUREPROXY"	       },
	{ DISPID_DEBUG_TRUSTEDPROXY, 	     L"DISPID_DEBUG_TRUSTEDPROXY"	       },
	{ DISPID_DEBUG_INTERNALWINDOW,	     L"DISPID_DEBUG_INTERNALWINDOW"	       },
	{ DISPID_DEBUG_ENABLESECUREPROXYASSERTS,  L"DISPID_DEBUG_ENABLESECUREPROXYASSERTS"  },
};

const size_t cdispids = _countof(rgdispids);


HRESULT HrCheckAndFreeExcepInfo(EXCEPINFO *pei, const void *pv, int ifn)
{
	if (pei->pfnDeferredFillIn != 0)
	{
		if (((intptr_t) pei->pfnDeferredFillIn) == -1)
		{
			ReportFailure(0x0C01, false, pv, ifn, L"EXCEPINFO::pfnDeferredFillIn %p is uninitialized", pei->pfnDeferredFillIn);
		}

		else if (IsBadCodePtr((FARPROC) pei->pfnDeferredFillIn))
		{
			ReportFailure(0x0C02, false, pv, ifn, L"EXCEPINFO::pfnDeferredFillIn %p is not valid code pointer", pei->pfnDeferredFillIn);
		}

		else
		{
			HRESULT hr = (*pei->pfnDeferredFillIn)(pei);

			if (FAILED(hr))
			{
				ReportFailure(0x0C03, false, pei->pfnDeferredFillIn, -1, L"EXCEPINFO::pfnDeferredFillIn failed.  hr = %08X", hr);
			}
		}
	}

	if (pei->wCode != 0)
	{
		ReportFailure(0x0C04, false, pv, ifn, L"EXCEPINFO::wCode == %04X", pei->wCode);
	}

	if (pei->wReserved != 0)
	{
		ReportFailure(0x0C05, false, pv, ifn, L"EXCEPINFO::wReserved == %04X", pei->wReserved);
	}

	if (pei->bstrSource != NULL)
	{
		SysFreeString(pei->bstrSource);
	}

	if (pei->bstrDescription != NULL)
	{
		SysFreeString(pei->bstrDescription);
	}

	if (pei->bstrHelpFile != NULL)
	{
		SysFreeString(pei->bstrHelpFile);
	}

	if (pei->pvReserved != 0)
	{
		ReportFailure(0x0C06, false, pv, ifn, L"EXCEPINFO::pvReserved == %p", pei->pvReserved);
	}

	if (pei->scode == 0)
	{
		ReportFailure(0x0C07, false, pv, ifn, L"EXCEPINFO::scode == 0");
	}

	return(pei->scode);
}


size_t CelemSafeArray(SAFEARRAY *psa)
{
	unsigned cdim = SafeArrayGetDim(psa);

	if (cdim == 0)
	{
		return(0);
	}

	size_t celem = 1;

	for (unsigned idim = 1; idim <= cdim; idim++)
	{
		long lbound;

		HRESULT hr = SafeArrayGetLBound(psa, idim, &lbound);

		if (FAILED(hr))
		{
			return(0);
		}

		long ubound;

		hr = SafeArrayGetUBound(psa, idim, &ubound);

		if (FAILED(hr))
		{
			return(0);
		}

		size_t celemDim = (size_t) (ubound - lbound + 1);

		celem *= celemDim;
	}

	return(celem);
}


int TestVariant(VARIANT& var)
{
	int rc = 0;

	if (var.vt == VT_DISPATCH)
	{
		if (var.pdispVal != NULL)
		{
			dwNonClass++;

			rc = TestInterface(var.pdispVal, NULL, false, false);

			dwNonClass--;
		}
	}

	else if (var.vt == VT_UNKNOWN)
	{
		if (var.punkVal != NULL)
		{
			dwNonClass++;

			rc = TestInterface(var.punkVal, NULL, true, false);

			dwNonClass--;
		}
	}

	else if (var.vt == (VT_ARRAY | VT_DISPATCH))
	{
		// UNDONE: Remove ReportFailure

		ReportFailure(0xFFFF, false, NULL, 0, L"VARIANT::vt == (VT_ARRAY | VT_DISPATCH)");

		SAFEARRAY *psa = var.parray;

		if (psa != NULL)
		{
			IDispatch **rgpid;

			HRESULT hr = SafeArrayAccessData(psa, (void **) &rgpid);

			if (SUCCEEDED(hr))
			{
				size_t celem = CelemSafeArray(psa);

				if (celem != 0)
				{
					for (size_t ielem = 0; ielem < celem; ielem++)
					{
						TestInterface(rgpid[ielem], NULL, false, false);
					}
				}

				SafeArrayUnaccessData(psa);
			}
		}
	}

	else if (var.vt == (VT_ARRAY | VT_UNKNOWN))
	{
		// UNDONE: Remove ReportFailure

		ReportFailure(0xFFFF, false, NULL, 0, L"VARIANT::vt == (VT_ARRAY | VT_UNKNOWN)");

		SAFEARRAY *psa = var.parray;

		if (psa != NULL)
		{
			IUnknown **rgpunk;

			HRESULT hr = SafeArrayAccessData(psa, (void **) &rgpunk);

			if (SUCCEEDED(hr))
			{
				size_t celem = CelemSafeArray(psa);

				if (celem != 0)
				{
					IID iidT;

					hr = SafeArrayGetIID(psa, &iidT);

					bool fIsIUnknown = SUCCEEDED(hr) && (iidT == IID_IUnknown);

					for (size_t ielem = 0; ielem < celem; ielem++)
					{
						TestInterface(rgpunk[ielem], NULL, fIsIUnknown, false);
					}
				}

				SafeArrayUnaccessData(psa);
			}
		}
	}

	else if (var.vt == (VT_ARRAY | VT_VARIANT))
	{
		SAFEARRAY *psa = var.parray;

		if (psa != NULL)
		{
			VARIANT *rgvar;

			HRESULT hr = SafeArrayAccessData(psa, (void **) &rgvar);

			if (SUCCEEDED(hr))
			{
				size_t celem = CelemSafeArray(psa);

				if (celem != 0)
				{
					for (size_t ielem = 0; ielem < celem; ielem++)
					{
						TestVariant(rgvar[ielem]);
					}
				}

				SafeArrayUnaccessData(psa);
			}
		}
	}

	else if ((var.vt & VT_BYREF) != 0)
	{
		ReportFailure(0xFFFF, false, NULL, 0, L"VARIANT::vt == %04X", var.vt);
	}

	return(rc);
}


int TestAndClearVariant(VARIANT& var)
{
	int rc = TestVariant(var);

	VariantClear(&var);

	return(rc);
}


int CheckIConnectionPointContainer(IUnknown *punk, bool fClassObject)
{
	IConnectionPointContainer *picpc;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IConnectionPointContainer", IID_PPV_ARGS(&picpc));

	if (FAILED(hr))
	{
		return(0);
	}

	IEnumConnectionPoints *piecp = (IEnumConnectionPoints *) (intptr_t) -1;

	hr = picpc->EnumConnectionPoints(&piecp);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			// OLEAUT32.DLL's CFont::EnumConnectionPoint, CPicture::EnumConnectionPoint,
			// and GEN_CPCONTAINER::EnumConnectionPoint return E_NOTIMPL.	If they don't
			// have to implement this we can't expect others to.

			ReportFailure(0x0D01, false, picpc, 3, L"IConnectionPointContainer::EnumConnectionPoints failed.  hr = %08X", hr);
		}
	}

	else
	{
		dwNonClass++;

		int rc = TestAndReleaseInterface(piecp, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

	hr = picpc->FindConnectionPoint(IID_IUnknown, &picp);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0D02, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IUnknown) succeeded");

		Release(picp, false);
	}

	else
	{
		if (hr != CONNECT_E_NOCONNECTION)
		{
			ReportFailure(0x0D03, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IUnknown) failure did not return CONNECT_E_NOCONNECTION.  hr = %08X", hr);
		}

		if (picp != NULL)
		{
			ReportFailure(0x0D04, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IUnknown) failure did not set *ppcp = NULL");
		}
	}

	picp = (IConnectionPoint *) (intptr_t) -1;

	hr = picpc->FindConnectionPoint(IID_IDispatch, &picp);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0D05, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IDispatch) succeeded");

		Release(picp, false);
	}

	else
	{
		if (hr != CONNECT_E_NOCONNECTION)
		{
			ReportFailure(0x0D06, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IDispatch) failure did not return CONNECT_E_NOCONNECTION.  hr = %08X", hr);
		}

		if (picp != NULL)
		{
			ReportFailure(0x0D07, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IDispatch) failure did not set *ppcp = NULL");
		}
	}

	picp = (IConnectionPoint *) (intptr_t) -1;

	hr = picpc->FindConnectionPoint(iidUndefined, &picp);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0D08, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(iidUndefined) succeeded");

		Release(picp, false);
	}

	else
	{
		if (hr != CONNECT_E_NOCONNECTION)
		{
			ReportFailure(0x0D09, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(iidUndefined) failure did not return CONNECT_E_NOCONNECTION.  hr = %08X", hr);
		}

		if (picp != NULL)
		{
			ReportFailure(0x0D0A, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(iidUndefined) failure did not set *ppcp = NULL");
		}
	}

	Release(picpc, fClassObject);

	return(0);
}


size_t CargInitRgarg(const FUNCDESC *pfd, ARG *rgarg)
{
	size_t carg = 0;

	for (int ied = 0; ied < pfd->cParams; ied++)
	{
		const ELEMDESC *ped = &pfd->lprgelemdescParam[ied];

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FLCID)
		{
			continue;
		}

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FRETVAL)
		{
			continue;
		}

		carg++;
	}

	if (carg > 256)
	{
		// UNDONE:

		ReportFailure(0xFFFF, false, NULL, 0, L"Argument limit of 256 exceeded (%u)", carg);

		return((size_t) -1);
	}

	size_t iarg = 0;

	for (int ied = 0; ied < pfd->cParams; ied++)
	{
		const ELEMDESC *ped = &pfd->lprgelemdescParam[ied];

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FLCID)
		{
			continue;
		}

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FRETVAL)
		{
			continue;
		}

		VARENUM vt = (VARENUM) ped->tdesc.vt;

		if (vt == VT_PTR)
		{
			vt = (VARENUM) ped->tdesc.lptdesc->vt;

			if (vt == VT_SAFEARRAY)
			{
				vt = (VARENUM) (ped->tdesc.lptdesc->lptdesc->vt | VT_ARRAY);
			}
		}

		else if (vt == VT_SAFEARRAY)
		{
			vt = (VARENUM) (ped->tdesc.lptdesc->vt | VT_ARRAY);
		}

		// UNDONE: Handle VT_CARRAY
		// UNDONE: Handle VT_USERDEFINED

		// We mark arguments as fIn if either PARAMFALG_FIN is set or neither
		// it nor PARAMFLAG_FOUT are set.  This is because some parameters may
		// have a wParamFlags value of 0.

		rgarg[iarg].vt = vt;
		rgarg[iarg].fIn = ((ped->paramdesc.wParamFlags & (PARAMFLAG_FIN | PARAMFLAG_FOUT)) != PARAMFLAG_FOUT);
		rgarg[iarg].fOut = ((ped->paramdesc.wParamFlags & PARAMFLAG_FOUT) != 0);
		rgarg[iarg].fOptional = false;
		rgarg[iarg].fDidOptional = false;
		rgarg[iarg].iValue = 0;
		rgarg[iarg].iType = 0;

		if (rgarg[iarg].fIn)
		{
			rgarg[iarg].fOptional = ((ped->paramdesc.wParamFlags & PARAMFLAG_FOPT) != 0);
		}

		iarg++;
	}

	return(carg);
}


bool FInitI2(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int16 rgi2[] =
	{
		0x0000,
		0x0001,
		-0x0001,
		0x007F,
		-0x007F,
		0x7FFF,
		-0x7FFF,
		-0x8000,
	};

	const unsigned ci2 = _countof(rgi2);

	V_VT(pvar) = VT_I2;
	V_I2(pvar) = rgi2[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci2)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitI4(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int32 rgi4[] =
	{
		0x00000000,
		0x00000001,
		-0x00000001,
		0x0000007F,
		-0x0000007F,
		0x00007FFF,
		-0x00007FFF,
		0x7FFFFFFF,
		-0x7FFFFFFF,
		-0x80000000,
	};

	const unsigned ci4 = _countof(rgi4);

	V_VT(pvar) = VT_I4;
	V_I4(pvar) = rgi4[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci4)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitR4(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const float rgr4[] =
	{
		0.0f,
		1.0f,
		-1.0f,
	};

	const unsigned cr4 = _countof(rgr4);

	V_VT(pvar) = VT_R4;
	V_R4(pvar) = rgr4[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cr4)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitR8(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const float rgr8[] =
	{
		0.0,
		1.0,
		-1.0,
	};

	const unsigned cr8 = _countof(rgr8);

	V_VT(pvar) = VT_R8;
	V_R8(pvar) = rgr8[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cr8)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitCY(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	VariantChangeType(pvar, pvar, 0, parg->vt);

	return(fAdvance);
}


bool FInitDATE(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	VariantChangeType(pvar, pvar, 0, parg->vt);

	return(fAdvance);
}


bool FInitBSTR(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const wchar_t * const rgsz[] =
	{
		//	NULL,
		L"",
		L"*",
		L"A",
		L"a",
		L"\x0001\x0002\x0003\x0004\x0005\x0006\x0007",
		L"C:\\test.txt",
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890"
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890"
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890"
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890",
	};

	const unsigned csz = _countof(rgsz);

	const wchar_t *sz = rgsz[parg->iValue];

	BSTR bstr = (sz == NULL) ? NULL : SysAllocString(sz);

	V_VT(pvar) = VT_BSTR;
	V_BSTR(pvar) = bstr;

	if (fAdvance)
	{
		if (++parg->iValue == csz)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitDISPATCH(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	pvar->vt = VT_DISPATCH;
	pvar->pdispVal = NULL;

	return(fAdvance);
}


bool FInitBOOL(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const VARIANT_BOOL rgvb[] =
	{
		VARIANT_FALSE,
		VARIANT_TRUE,
	};

	const unsigned cvb = _countof(rgvb);

	V_VT(pvar) = VT_BOOL;
	V_BOOL(pvar) = rgvb[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cvb)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitDECIMAL(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	VariantChangeType(pvar, pvar, 0, parg->vt);

	return(fAdvance);
}


bool FInitUNKNOWN(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	pvar->vt = VT_UNKNOWN;
	pvar->punkVal = NULL;

	return(fAdvance);
}


bool FInitI1(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int8 rgi1[] =
	{
		0x00,
		0x01,
		-0x01,
		0x7F,
		-0x7F,
		-0x80,
	};

	const unsigned ci1 = _countof(rgi1);

	V_VT(pvar) = VT_I1;
	V_I1(pvar) = rgi1[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci1)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI1(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int8 rgui1[] =
	{
		0x00,
		0x01,
		0x7F,
		0x80,
		0xFF,
	};

	const unsigned cui1 = _countof(rgui1);

	V_VT(pvar) = VT_UI1;
	V_UI1(pvar) = rgui1[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui1)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI2(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int16 rgui2[] =
	{
		0x0000,
		0x0001,
		0x007F,
		0x7FFF,
		0x8000,
		0xFFFF,
	};

	const unsigned cui2 = _countof(rgui2);

	V_VT(pvar) = VT_UI2;
	V_UI2(pvar) = rgui2[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui2)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI4(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int32 rgui4[] =
	{
		0x00000000,
		0x00000001,
		0x0000007F,
		0x00007FFF,
		0x7FFFFFFF,
		0x80000000,
		0xFFFFFFFF,
	};

	const unsigned cui4 = _countof(rgui4);

	V_VT(pvar) = VT_UI4;
	V_UI4(pvar) = rgui4[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui4)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitI8(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int64 rgi8[] =
	{
		0x0000000000000000,
		0x0000000000000001,
		-0x0000000000000001,
		0x000000000000007F,
		-0x000000000000007F,
		0x0000000000007FFF,
		-0x0000000000007FFF,
		0x000000007FFFFFFF,
		-0x000000007FFFFFFF,
		0x7FFFFFFFFFFFFFFF,
		-0x7FFFFFFFFFFFFFFF,
		-0x8000000000000000,
	};

	const unsigned ci8 = _countof(rgi8);

	V_VT(pvar) = VT_I8;
	V_I8(pvar) = rgi8[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci8)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI8(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int64 rgui8[] =
	{
		0x0000000000000000,
		0x0000000000000001,
		0x000000000000007F,
		0x0000000000007FFF,
		0x000000007FFFFFFF,
		0x7FFFFFFFFFFFFFFF,
		0x8000000000000000,
		0xFFFFFFFFFFFFFFFF,
	};

	const unsigned cui8 = _countof(rgui8);

	V_VT(pvar) = VT_UI8;
	V_UI8(pvar) = rgui8[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui8)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitINT(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	fAdvance = FInitI4(fAdvance, parg, pvar);

	V_VT(pvar) = VT_INT;

	return(fAdvance);
}


bool FInitUINT(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	fAdvance = FInitUI4(fAdvance, parg, pvar);

	V_VT(pvar) = VT_UINT;

	return(fAdvance);
}


bool FInitVARIANT(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const VARENUM rgvt[] =
	{
		VT_I2,
		VT_I4,
		//	VT_R4,
		VT_R8,
		//	VT_CY,
		//	VT_DATE,
		VT_BSTR,
		VT_BOOL,
		//	VT_DECIMAL,
		VT_I1,
		//	VT_UI1,
		//	VT_UI2,
		VT_UI4,
		//	VT_I8,
		//	VT_UI8,
		VT_INT,
		//	VT_UINT,
	};

	const unsigned cvt = _countof(rgvt);

	VARENUM vt = rgvt[parg->iType];

	switch (vt)
	{
	case VT_I2 :
		fAdvance = FInitI2(fAdvance, parg, pvar);
		break;

	case VT_I4 :
		fAdvance = FInitI4(fAdvance, parg, pvar);
		break;

	case VT_R4 :
		fAdvance = FInitR4(fAdvance, parg, pvar);
		break;

	case VT_R8 :
		fAdvance = FInitR8(fAdvance, parg, pvar);
		break;

	case VT_CY :
		fAdvance = FInitCY(fAdvance, parg, pvar);
		break;

	case VT_DATE :
		fAdvance = FInitDATE(fAdvance, parg, pvar);
		break;

	case VT_BSTR :
		fAdvance = FInitBSTR(fAdvance, parg, pvar);
		break;

	case VT_DISPATCH :
		fAdvance = FInitDISPATCH(fAdvance, parg, pvar);
		break;

	case VT_BOOL :
		fAdvance = FInitBOOL(fAdvance, parg, pvar);
		break;

	case VT_UNKNOWN :
		fAdvance = FInitUNKNOWN(fAdvance, parg, pvar);
		break;

	case VT_DECIMAL :
		fAdvance = FInitDECIMAL(fAdvance, parg, pvar);
		break;

	case VT_I1 :
		fAdvance = FInitI1(fAdvance, parg, pvar);
		break;

	case VT_UI1 :
		fAdvance = FInitUI1(fAdvance, parg, pvar);
		break;

	case VT_UI2 :
		fAdvance = FInitUI2(fAdvance, parg, pvar);
		break;

	case VT_UI4 :
		fAdvance = FInitUI4(fAdvance, parg, pvar);
		break;

	case VT_I8 :
		fAdvance = FInitI8(fAdvance, parg, pvar);
		break;

	case VT_UI8 :
		fAdvance = FInitUI8(fAdvance, parg, pvar);
		break;

	case VT_INT :
		fAdvance = FInitINT(fAdvance, parg, pvar);
		break;

	case VT_UINT :
		fAdvance = FInitUINT(fAdvance, parg, pvar);
		break;
	}

	if (fAdvance)
	{
		if (++parg->iType == cvt)
		{
			parg->iType = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitRgvar(size_t carg, ARG *rgarg, VARIANT *rgvar)
{
	bool fAdvance = true;

	for (size_t iarg = 0; iarg < carg; iarg++)
	{
		// VARIANTs in rgvarg are in reverse order

		size_t ivar = carg - (iarg + 1);

		VARIANT *pvar = &rgvar[ivar];

		MyVariantInit(pvar);

		ARG *parg = &rgarg[iarg];

		if (!parg->fIn)
		{
			if ((parg->vt & VT_ARRAY) != 0)
			{
				pvar->vt = parg->vt;
				pvar->parray = NULL;
			}

			continue;
		}

		if (parg->fOptional && !parg->fDidOptional)
		{
			pvar->vt = VT_ERROR;
			pvar->scode = DISP_E_PARAMNOTFOUND;

			parg->fDidOptional = fAdvance;

			fAdvance = false;

			continue;
		}

		switch (parg->vt & VT_TYPEMASK)
		{
		case VT_I2 :
			fAdvance = FInitI2(fAdvance, parg, pvar);
			break;

		case VT_I4 :
#ifndef _WIN64
		case VT_INT_PTR :
#endif
			fAdvance = FInitI4(fAdvance, parg, pvar);
			break;

		case VT_R4 :
			fAdvance = FInitR4(fAdvance, parg, pvar);
			break;

		case VT_R8 :
			fAdvance = FInitR8(fAdvance, parg, pvar);
			break;

		case VT_CY :
			fAdvance = FInitCY(fAdvance, parg, pvar);
			break;

		case VT_DATE :
			fAdvance = FInitDATE(fAdvance, parg, pvar);
			break;

		case VT_BSTR :
		case VT_LPSTR :
		case VT_LPWSTR :
			fAdvance = FInitBSTR(fAdvance, parg, pvar);
			break;

		case VT_DISPATCH :
			fAdvance = FInitDISPATCH(fAdvance, parg, pvar);
			break;

		case VT_BOOL :
			fAdvance = FInitBOOL(fAdvance, parg, pvar);
			break;

		case VT_VARIANT :
			fAdvance = FInitVARIANT(fAdvance, parg, pvar);
			break;

		case VT_UNKNOWN :
			fAdvance = FInitUNKNOWN(fAdvance, parg, pvar);
			break;

		case VT_DECIMAL :
			fAdvance = FInitDECIMAL(fAdvance, parg, pvar);
			break;

		case VT_I1 :
			fAdvance = FInitI1(fAdvance, parg, pvar);
			break;

		case VT_UI1 :
			fAdvance = FInitUI1(fAdvance, parg, pvar);
			break;

		case VT_UI2 :
			fAdvance = FInitUI2(fAdvance, parg, pvar);
			break;

		case VT_UI4 :
#ifndef _WIN64
		case VT_UINT_PTR :
#endif
			fAdvance = FInitUI4(fAdvance, parg, pvar);
			break;

		case VT_I8 :
#ifdef	_WIN64
		case VT_INT_PTR :
#endif
			fAdvance = FInitI8(fAdvance, parg, pvar);
			break;

		case VT_UI8 :
#ifdef	_WIN64
		case VT_UINT_PTR :
#endif
			fAdvance = FInitUI8(fAdvance, parg, pvar);
			break;

		case VT_INT :
			fAdvance = FInitINT(fAdvance, parg, pvar);
			break;

		case VT_UINT :
			fAdvance = FInitUINT(fAdvance, parg, pvar);
			break;

		default :
			VariantChangeType(pvar, pvar, 0, parg->vt);
			break;
		}
	}

	return(fAdvance);
}


int CheckIDispatchTypeInfo(IDispatch *pid, ITypeInfo *piti, size_t *pcfuncTotal)
{
	if (fNoIDispatchFuzz) return 0;		// don't fuzz methods -- can seriously screw up the system

	TYPEATTR *pta = (TYPEATTR *) (intptr_t) -1;

	HRESULT hr = piti->GetTypeAttr(&pta);

	if (FAILED(hr))
	{
		ReportFailure(0x0E01, false, piti, 3, L"ITypeInfo::GetTypeAttr failed.  hr = %08X", hr);

		// Indicate that GetTypetAttr fails so we can fall back to trying other DISPIDs

		return(-1);
	}

	if (pta->guid == IID_IUnknown)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 3;
		}
	}

	else if (pta->guid == IID_IDispatch)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 7;
		}
	}

	else if (pta->guid == IID_IDispatchEx)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 15;
		}
	}

	else
	{
		wchar_t szIidDispatch[39];

		StringFromGUID2(pta->guid, szIidDispatch, _countof(szIidDispatch));

		size_t cfuncBase = 0;

		if ((pta->typekind != TKIND_INTERFACE) && (pta->typekind != TKIND_DISPATCH))
		{
			ReportFailure(0x0E02, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned typekind %u", szIidDispatch, pta->typekind);
		}

		else
		{
			IUnknown *punkT;

			hr = HrQueryInterface(pid, false, szIidDispatch, pta->guid, (void **) &punkT);

			if (SUCCEEDED(hr))
			{
				Release(punkT, false);
			}

			else
			{
				ReportFailure(0x0E07, false, pid, 0, L"IDispatch::QueryInterface(%s) failed.  hr = %08X", szIidDispatch, hr);
			}

			// Check for a base interface

			if (pta->cImplTypes != 1)
			{
				// There should be only one base interface

				ReportFailure(0x0E03, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned cImplTypes = %u", szIidDispatch, pta->cImplTypes);
			}

			// Test the base interface first

			for (size_t i = 0; i < pta->cImplTypes; i++)
			{
				HREFTYPE ht = NULL;

				hr = piti->GetRefTypeOfImplType(i, &ht);

				if (SUCCEEDED(hr))
				{
					ITypeInfo *pitiImpl = (ITypeInfo *) (intptr_t) -1;

					hr = piti->GetRefTypeInfo(ht, &pitiImpl);

					if (SUCCEEDED(hr))
					{
						dwNonClass++;

						int rc = CheckIDispatchTypeInfo(pid, pitiImpl, &cfuncBase);

						Release(pitiImpl, false);

						if (rc != 0)
						{
							if (rc == -1)
							{
								// Only return -1 from top level

								rc = 0;
							}

							return(rc);
						}
					}
				}
			}
		}

		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = cfuncBase + pta->cFuncs;
		}

		size_t ifuncBase = 0;

		if ((pta->typekind == TKIND_DISPATCH) && ((pta->wTypeFlags & TYPEFLAG_FDUAL) != 0))
		{
			// For dual dispinterfaces GetFuncDesc treats the function index relative to
			// the start of the flattened interface not the start of this interface only.

			// UNDONE: Can we make this simpler?  We can if we know that all dispinterfaces
			// UNDONE: are derived from IDispatch and not other interfaces

			ifuncBase = cfuncBase;
		}

		bool fFolder = pta->guid == __uuidof(Folder);
		bool fFolder2 = pta->guid == __uuidof(Folder2);
		bool fFolder3 = pta->guid == __uuidof(Folder3);
		bool fIFile = pta->guid == __uuidof(IFile);
		bool fIFileSystem = pta->guid == __uuidof(IFileSystem);
		bool fIFileSystem3 = pta->guid == __uuidof(IFileSystem3);
		bool fIFolder = pta->guid == __uuidof(IFolder);
		bool fIFolderCollection = pta->guid == __uuidof(IFolderCollection);
		bool fILogonUser = pta->guid == __uuidof(ILogonUser);

		DISPID dispidPropertyPut = DISPID_PROPERTYPUT;

		ARG *rgarg = new ARG[256];
		VARIANT *rgvar = new VARIANT[256];

		for (size_t ifunc = ifuncBase; ifunc < pta->cFuncs; ifunc++)
		{
			FUNCDESC *pfd = (FUNCDESC *) (intptr_t) -1;

			HRESULT hr = piti->GetFuncDesc(ifunc, &pfd);

			if (FAILED(hr))
			{
				ReportFailure(0x0E04, false, piti, 5, L"IID = %s.  ITypeInfo::GetFuncDesc(%u) failed.  hr = %08X", szIidDispatch, ifunc, hr);
			}

			else
			{
				int ifn = 6;		  // Use index of Invoke as first choice

				// MSDN claims that oVft is valid for FUNC_VIRTUAL
				// only but it appears to be valid for FUNC_DISPATCH too

				if ((pfd->funckind == FUNC_VIRTUAL) || (pfd->funckind == FUNC_DISPATCH))
				{
					ifn = pfd->oVft / sizeof(void *);
				}

				BSTR bstrName;

				hr = piti->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);

				if (FAILED(hr))
				{
					bstrName = NULL;
				}

				// Count number of non-lcid non-retval arguments

				size_t carg = CargInitRgarg(pfd, rgarg);

				if (fFolder || fFolder2 || fFolder3)
				{
					if (pfd->memid == 0x60020006)
					{
						// Avoid calling Folder::NewFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020007)
					{
						// Avoid calling Folder::MoveHere

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020008)
					{
						// Avoid calling Folder::CopyHere

						carg = (size_t) -1;
					}
				}

				else if (fIFile)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1100)
					{
						// Avoid calling IFile::OpenTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFile::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFile::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFile::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFile::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFileSystem || fIFileSystem3)
				{
					if (pfd->memid == 1100)
					{
						// Avoid calling IFileSystem::OpenAsTextStream

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1120)
					{
						// Avoid calling IFileSystem::CreateFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFileSystem::DeleteFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFileSystem::DeleteFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFileSystem::CopyFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFileSystem::CopyFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFileSystem::MoveFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFileSystem::MoveFolder

						carg = (size_t) -1;
					}
				}

				else if (fIFolder)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFolder::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFolder::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFolder::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFolderCollection)
				{
					if (pfd->memid == 2)
					{
						// Avoid calling IFolderCollection::Add

						carg = (size_t) -1;
					}
				}

				else if (fILogonUser)
				{
					if (pfd->memid == 0x60020008)
					{
						// Avoid calling ILogonUser::logoff

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x6002000a)
					{
						// Avoid calling ILogonUser::makeProfilePrivate

						carg = (size_t) -1;
					}
				}

				if (carg != ((size_t) -1))
				{
					DISPPARAMS dp;
					WORD wFlags = (WORD) pfd->invkind;
					VARIANT varResult;
					VARIANT *pvarResult = &varResult;
					EXCEPINFO ei;

					dp.rgvarg = (carg == 0) ? NULL : rgvar;
					dp.cArgs = carg;

					if ((pfd->invkind == INVOKE_PROPERTYPUT) ||
						(pfd->invkind == INVOKE_PROPERTYPUTREF))
					{
						dp.rgdispidNamedArgs = &dispidPropertyPut;
						dp.cNamedArgs = 1;

						if ((carg == 1) && (rgvar[0].vt != VT_DISPATCH))
						{
							wFlags = DISPATCH_PROPERTYPUT;
						}

						pvarResult = NULL;
					}

					else
					{
						dp.rgdispidNamedArgs = NULL;
						dp.cNamedArgs = 0;
					}

					HRESULT hrLastError = S_OK;

					// Limit permutations per method

					for (DWORD dwDispatch = 0; dwDispatch < dwDispatchMax; dwDispatch++)
					{
						bool fAdvance = FInitRgvar(carg, rgarg, rgvar);

						varResult.vt = VT_ILLEGAL;

						memset(&ei, -1, sizeof(ei));

						hr = pid->Invoke((DISPID) (pfd->memid),   // dispIdMember
							IID_NULL,		    // riid
							LOCALE_SYSTEM_DEFAULT,   // lcid
							wFlags,			// wFlags
							&dp, 		    // pDispParams
							pvarResult,		    // pVarResult
							&ei, 		    // pExcepInfo
							NULL);		    // puArgErr

						SetMyUnhandledExceptionFilter(true);

						if (!fExistsA)
						{
							fExistsA = _waccess_s(L"A", 0) == 0;

							if (fExistsA)
							{
								ReportFailure(0xFFFF, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d, \"%s\") created A", szIidDispatch, pfd->memid, bstrName);
							}
						}


						if (SUCCEEDED(hr))
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								int rc = TestAndClearVariant(rgvar[ivar]);

								if (rc != 0)
								{
									return(rc);
								}
							}

							if (pvarResult != NULL)
							{
								if (varResult.vt == VT_ILLEGAL)
								{
									if (bstrName != NULL)
									{
										ReportFailure(0x0E05, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d, \"%s\") did not initialize varResult", szIidDispatch, pfd->memid, bstrName);
									}

									else
									{
										ReportFailure(0x0E05, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d) did not initialize varResult", szIidDispatch, pfd->memid);
									}
								}

								else
								{
									int rc = TestAndClearVariant(*pvarResult);

									if (rc != 0)
									{
										return(rc);
									}
								}
							}
						}

						else
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								VariantClear(&rgvar[ivar]);
							}

							if ((hr == DISP_E_MEMBERNOTFOUND) &&
								(pfd->memid >= 0) &&
								(pfd->wFuncFlags & FUNCFLAG_FRESTRICTED))
							{
								// CTypeInfo2::Invoke in OLEAUT32.DLL contains

								//     // New-format typelibs don't allow late-binding to restricted members
								//     if (memid >= 0 && (pFunc->funcflags & FUNCFLAG_FRESTRICTED)) {
								//	 return HresultOfScode(DISP_E_MEMBERNOTFOUND);
								//     }
							}

							else
							{
								if (hr == DISP_E_EXCEPTION)
								{
									hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
								}

								// Don't report invalid arguments as we try this often
								// Don't report consecutive instances of same error per method

								if ((hr != E_INVALIDARG) && (hr != hrLastError))
								{
									hrLastError = hr;

									if (bstrName != NULL)
									{
										ReportFailure(0x0E06, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d, \"%s\") failed.  hr = %08X", szIidDispatch, pfd->memid, bstrName, hr);
									}

									else
									{
										ReportFailure(0x0E06, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d) failed.  hr = %08X", szIidDispatch, pfd->memid, hr);
									}
								}
							}
						}

						if (fAdvance)
						{
							break;
						}
					}
				}

				if (bstrName != NULL)
				{
					SysFreeString(bstrName);
				}

				piti->ReleaseFuncDesc(pfd);
			}
		}

		delete [] rgvar;
		delete [] rgarg;
	}

	piti->ReleaseTypeAttr(pta);

	return(0);
}


int CheckIDispatch(IUnknown *punk, bool fClassObject)
{
	if (fNoIDispatch)
	{
		return(0);
	}

	IDispatch *pid;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IDispatch", IID_PPV_ARGS(&pid));

	if (FAILED(hr))
	{
		return(0);
	}

	bool fGetTypeInfoCountNotImpl = false;

	UINT ctinfo;

	hr = pid->GetTypeInfoCount(&ctinfo);

	if (FAILED(hr))
	{
		if (hr == E_NOTIMPL)
		{
			fGetTypeInfoCountNotImpl = true;
		}

		else
		{
			ReportFailure(0x0F01, false, pid, 3, L"IDispatch::GetTypeInfoCount failure did not return E_NOTIMPL.  hr = %08X", hr);
		}

		ctinfo = 0;
	}

	else if (ctinfo > 1)
	{
		ReportFailure(0x0F02, false, pid, 3, L"IDispatch::GetTypeInfoCount returned ctinfo of %u", ctinfo);
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pid->GetTypeInfo(ctinfo, LOCALE_NEUTRAL, &piti);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0F03, false, pid, 4, L"IDispatch::GetTypeInfo(%u) succeeded", ctinfo);

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	else if ((hr != DISP_E_BADINDEX) && !fGetTypeInfoCountNotImpl)
	{
		ReportFailure(0x0F04, false, pid, 4, L"IDispatch::GetTypeInfo(%u) failure did not return DISP_E_BADINDEX.  hr = %08X", ctinfo, hr);
	}

	if (ctinfo != 0)
	{
		piti = (ITypeInfo *) (intptr_t) -1;

		hr = pid->GetTypeInfo(0, LOCALE_NEUTRAL, &piti);

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			if (fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x0F05, false, pid, 4, L"IDispatch::GetTypeInfo(0) succeded but GetTypeInfoCount returned E_NOTIMPL");
			}

			int rc = TestInterface(piti, NULL, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			piti = NULL;

			if ((hr != E_NOTIMPL) && fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x0F06, false, pid, 4, L"IDispatch::GetTypeInfo(0) did not return E_NOTIMPL when GetTypeInfoCount did.  hr = %08X", hr);
			}
		}
	}

	else
	{
		piti = NULL;
	}

	wchar_t *rgszNames[1] =
	{
		L"Aj_34Hfm6",
	};

	DISPID dispid;

	hr = pid->GetIDsOfNames(IID_NULL,
		rgszNames,
		1,
		LOCALE_NEUTRAL,
		&dispid);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x0F0E, false, pid, 5, L"IDispatch::GetIDsOfNames(\"Aj_34Hfm6\") succeeded");
	}

	bool fMemberNotFound = false;

	DISPPARAMS dp;
	VARIANT varResult;
	EXCEPINFO ei;

	dp.rgvarg = NULL;
	dp.rgdispidNamedArgs = NULL;
	dp.cArgs = 0;
	dp.cNamedArgs = 0;

	varResult.vt = VT_ILLEGAL;

	memset(&ei, -1, sizeof(ei));

	hr = pid->Invoke(0x73529A4B, 			    // dispIdMember
		IID_NULL,				    // riid
		LOCALE_SYSTEM_DEFAULT,		    // lcid
		DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
		&dp,				    // pDispParams
		&varResult, 			    // pVarResult
		&ei,				    // pExcepInfo
		NULL);				    // puArgErr

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x0F07, false, pid, 6, L"IDispatch::Invoke(0x73529A4B) succeeded");

		if (varResult.vt == VT_ILLEGAL)
		{
			ReportFailure(0x0F08, false, pid, 6, L"IDispatch::Invoke(0x73529A4B) did not initialize varResult");
		}

		else
		{
			VariantClear(&varResult);
		}
	}

	else
	{
		if (hr == DISP_E_EXCEPTION)
		{
			hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
		}

		if (hr != DISP_E_MEMBERNOTFOUND)
		{
			fMemberNotFound = true;       // Report once only

			ReportFailure(0x0F09, false, pid, 6, L"IDispatch::Invoke(0x73529A4B) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", hr);
		}
	}

	// Try reserved DISPIDs

	for (size_t idispids = 0; idispids < cdispids; idispids++)
	{
		dispid = rgdispids[idispids].dispid;
		const wchar_t *szDispid = rgdispids[idispids].sz;

		dp.rgvarg = NULL;
		dp.rgdispidNamedArgs = NULL;
		dp.cArgs = 0;
		dp.cNamedArgs = 0;

		varResult.vt = VT_ILLEGAL;

		memset(&ei, -1, sizeof(ei));

		hr = pid->Invoke(dispid,				       // dispIdMember
			IID_NULL,			       // riid
			LOCALE_SYSTEM_DEFAULT,		       // lcid
			DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
			&dp,				       // pDispParams
			&varResult,			       // pVarResult
			&ei,				       // pExcepInfo
			NULL);				       // puArgErr

		SetMyUnhandledExceptionFilter(true);

		if (SUCCEEDED(hr))
		{
			if (varResult.vt == VT_ILLEGAL)
			{
				ReportFailure(0x0F0A, false, pid, 6, L"IDispatch::Invoke(%s) did not initialize varResult", szDispid);
			}

			else
			{
				int rc = TestAndClearVariant(varResult);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		else
		{
			if (hr == DISP_E_EXCEPTION)
			{
				hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
			}

			if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT) && !fMemberNotFound)
			{
				fMemberNotFound = true;	  // Report once only

				ReportFailure(0x0F0B, false, pid, 6, L"IDispatch::Invoke(%s) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", szDispid, hr);
			}
		}
	}

	if (piti != NULL)
	{
		int rc = CheckIDispatchTypeInfo(pid, piti, NULL);

		if (rc == -1)
		{
			// Release piti and set to NULL so that we try fallback enumeration of DISPIDs

			Release(piti, false);

			piti = NULL;
		}

		else if (rc != 0)
		{
			return(rc);
		}
	}

	if (piti == NULL)
	{
		// We don't have an ITypeInfo.  Just try a range of DISPIDs.

		for (dispid = 1; dispid < dispidMax; dispid++)
		{
			dp.rgvarg = NULL;
			dp.rgdispidNamedArgs = NULL;
			dp.cArgs = 0;
			dp.cNamedArgs = 0;

			varResult.vt = VT_ILLEGAL;

			memset(&ei, -1, sizeof(ei));

			hr = pid->Invoke(dispid,				  // dispIdMember
				IID_NULL,				  // riid
				LOCALE_SYSTEM_DEFAULT,		  // lcid
				DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
				&dp,					  // pDispParams
				&varResult,				  // pVarResult
				&ei,					  // pExcepInfo
				NULL);				  // puArgErr

			SetMyUnhandledExceptionFilter(true);

			if (SUCCEEDED(hr))
			{
				if (varResult.vt == VT_ILLEGAL)
				{
					ReportFailure(0x0F0C, false, pid, 6, L"IDispatch::Invoke(%d) did not initialize varResult", dispid);
				}

				else
				{
					int rc = TestAndClearVariant(varResult);

					if (rc != 0)
					{
						return(rc);
					}
				}
			}

			else
			{
				if (hr == DISP_E_EXCEPTION)
				{
					hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
				}

				if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT) && !fMemberNotFound)
				{
					ReportFailure(0x0F0D, false, pid, 6, L"IDispatch::Invoke(%d) failed.  hr = %08X", dispid, hr);
				}
			}
		}
	}

	else
	{
		Release(piti, false);
	}

	Release(pid, fClassObject);

	return(0);
}


int CheckIDispatchExTypeInfo(IDispatchEx *pide, ITypeInfo *piti, size_t *pcfuncTotal)
{
	if (fNoIDispatchFuzz) return 0;				// don't fuzz methods -- can seriously screw up the system
	TYPEATTR *pta = (TYPEATTR *) (intptr_t) -1;

	HRESULT hr = piti->GetTypeAttr(&pta);

	if (FAILED(hr))
	{
		ReportFailure(0x2E01, false, piti, 3, L"ITypeInfo::GetTypeAttr failed.  hr = %08X", hr);

		// Indicate that GetTypetAttr fails so we can fall back to trying other DISPIDs

		return(-1);
	}

	if (pta->guid == IID_IUnknown)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 3;
		}
	}

	else if (pta->guid == IID_IDispatch)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 7;
		}
	}

	else if (pta->guid == IID_IDispatchEx)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 15;
		}
	}

	else
	{
		wchar_t szIidDispatch[39];

		StringFromGUID2(pta->guid, szIidDispatch, _countof(szIidDispatch));

		size_t cfuncBase = 0;

		if ((pta->typekind != TKIND_INTERFACE) && (pta->typekind != TKIND_DISPATCH))
		{
			ReportFailure(0x2E02, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned typekind %u", szIidDispatch, pta->typekind);
		}

		else
		{
			IUnknown *punkT;

			hr = HrQueryInterface(pide, false, szIidDispatch, pta->guid, (void **) &punkT);

			if (SUCCEEDED(hr))
			{
				Release(punkT, false);
			}

			else
			{
				ReportFailure(0x2E07, false, pide, 0, L"IDispatch::QueryInterface(%s) failed.  hr = %08X", szIidDispatch, hr);
			}

			// Check for a base interface

			if (pta->cImplTypes != 1)
			{
				// There should be only one base interface

				ReportFailure(0x2E03, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned cImplTypes = %u", szIidDispatch, pta->cImplTypes);
			}

			// Test the base interface first

			for (size_t i = 0; i < pta->cImplTypes; i++)
			{
				HREFTYPE ht = NULL;

				hr = piti->GetRefTypeOfImplType(i, &ht);

				if (SUCCEEDED(hr))
				{
					ITypeInfo *pitiImpl = (ITypeInfo *) (intptr_t) -1;

					hr = piti->GetRefTypeInfo(ht, &pitiImpl);

					if (SUCCEEDED(hr))
					{
						dwNonClass++;

						int rc = CheckIDispatchExTypeInfo(pide, pitiImpl, &cfuncBase);

						Release(pitiImpl, false);

						if (rc != 0)
						{
							if (rc == -1)
							{
								// Only return -1 from top level

								rc = 0;
							}

							return(rc);
						}
					}
				}
			}
		}

		size_t ifuncBase = 0;

		if ((pta->typekind == TKIND_DISPATCH) && ((pta->wTypeFlags & TYPEFLAG_FDUAL) != 0))
		{
			// For dual dispinterfaces GetFuncDesc treats the function index relative to
			// the start of the flattened interface not the start of this interface only.

			// UNDONE: Can we make this simpler?  We can if we know that all dispinterfaces
			// UNDONE: are derived from IDispatch and not other interfaces

			ifuncBase = cfuncBase;
		}

		bool fFolder = pta->guid == __uuidof(Folder);
		bool fFolder2 = pta->guid == __uuidof(Folder2);
		bool fFolder3 = pta->guid == __uuidof(Folder3);
		bool fIFile = pta->guid == __uuidof(IFile);
		bool fIFileSystem = pta->guid == __uuidof(IFileSystem);
		bool fIFileSystem3 = pta->guid == __uuidof(IFileSystem3);
		bool fIFolder = pta->guid == __uuidof(IFolder);
		bool fIFolderCollection = pta->guid == __uuidof(IFolderCollection);
		bool fILogonUser = pta->guid == __uuidof(ILogonUser);

		DISPID dispidPropertyPut = DISPID_PROPERTYPUT;

		ARG *rgarg = new ARG[256];
		VARIANT *rgvar = new VARIANT[256];

		for (size_t ifunc = ifuncBase; ifunc < pta->cFuncs; ifunc++)
		{
			FUNCDESC *pfd = (FUNCDESC *) (intptr_t) -1;

			HRESULT hr = piti->GetFuncDesc(ifunc, &pfd);

			if (FAILED(hr))
			{
				ReportFailure(0x2E04, false, piti, 5, L"IID = %s.  ITypeInfo::GetFuncDesc(%u) failed.  hr = %08X", szIidDispatch, ifunc, hr);
			}

			else
			{
				int ifn = 8;		  // Use index of InvokeEx as first choice

				// MSDN claims that oVft is valid for FUNC_VIRTUAL
				// only but it appears to be valid for FUNC_DISPATCH too

				if ((pfd->funckind == FUNC_VIRTUAL) || (pfd->funckind == FUNC_DISPATCH))
				{
					ifn = pfd->oVft / sizeof(void *);
				}

				BSTR bstrName;

				hr = piti->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);

				if (FAILED(hr))
				{
					bstrName = NULL;
				}

				// Count number of non-lcid non-retval arguments

				size_t carg = CargInitRgarg(pfd, rgarg);

				if (fFolder || fFolder2 || fFolder3)
				{
					if (pfd->memid == 0x60020006)
					{
						// Avoid calling Folder::NewFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020007)
					{
						// Avoid calling Folder::MoveHere

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020008)
					{
						// Avoid calling Folder::CopyHere

						carg = (size_t) -1;
					}
				}

				else if (fIFile)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1100)
					{
						// Avoid calling IFile::OpenTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFile::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFile::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFile::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFile::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFileSystem || fIFileSystem3)
				{
					if (pfd->memid == 1100)
					{
						// Avoid calling IFileSystem::OpenAsTextStream

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1120)
					{
						// Avoid calling IFileSystem::CreateFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFileSystem::DeleteFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFileSystem::DeleteFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFileSystem::CopyFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFileSystem::CopyFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFileSystem::MoveFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFileSystem::MoveFolder

						carg = (size_t) -1;
					}
				}

				else if (fIFolder)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFolder::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFolder::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFolder::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFolderCollection)
				{
					if (pfd->memid == 2)
					{
						// Avoid calling IFolderCollection::Add

						carg = (size_t) -1;
					}
				}

				else if (fILogonUser)
				{
					if (pfd->memid == 0x60020008)
					{
						// Avoid calling ILogonUser::logoff

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x6002000a)
					{
						// Avoid calling ILogonUser::makeProfilePrivate

						carg = (size_t) -1;
					}
				}

				if (carg != ((size_t) -1))
				{
					DISPPARAMS dp;
					WORD wFlags = (WORD) pfd->invkind;
					VARIANT varResult;
					VARIANT *pvarResult = &varResult;
					EXCEPINFO ei;

					dp.rgvarg = (carg == 0) ? NULL : rgvar;
					dp.cArgs = carg;

					if ((pfd->invkind == INVOKE_PROPERTYPUT) ||
						(pfd->invkind == INVOKE_PROPERTYPUTREF))
					{
						dp.rgdispidNamedArgs = &dispidPropertyPut;
						dp.cNamedArgs = 1;

						if ((carg == 1) && (rgvar[0].vt != VT_DISPATCH))
						{
							wFlags = DISPATCH_PROPERTYPUT;
						}

						pvarResult = NULL;
					}

					else
					{
						dp.rgdispidNamedArgs = NULL;
						dp.cNamedArgs = 0;
					}

					HRESULT hrLastError = S_OK;

					// Limit permutations per method

					for (DWORD dwDispatch = 0; dwDispatch < dwDispatchMax; dwDispatch++)
					{
						bool fAdvance = FInitRgvar(carg, rgarg, rgvar);

						varResult.vt = VT_ILLEGAL;

						memset(&ei, -1, sizeof(ei));

						hr = pide->InvokeEx((DISPID) (pfd->memid),   // id
							LOCALE_SYSTEM_DEFAULT,   // lcid
							wFlags,				// wFlags
							&dp,		       // pdp
							pvarResult,	       // pVarRes
							&ei,		       // pei
							NULL);		       // pspCaller

						SetMyUnhandledExceptionFilter(true);

						if (!fExistsA)
						{
							fExistsA = _waccess_s(L"A", 0) == 0;

							if (fExistsA)
							{
								ReportFailure(0xFFFF, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d, \"%s\") created A", szIidDispatch, pfd->memid, bstrName);
							}
						}

						if (SUCCEEDED(hr))
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								int rc = TestAndClearVariant(rgvar[ivar]);

								if (rc != 0)
								{
									return(rc);
								}
							}

							if (pvarResult != NULL)
							{
								if (varResult.vt == VT_ILLEGAL)
								{
									if (bstrName != NULL)
									{
										ReportFailure(0x2E05, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d, \"%s\") did not initialize varResult", szIidDispatch, pfd->memid, bstrName);
									}

									else
									{
										ReportFailure(0x2E05, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d) did not initialize varResult", szIidDispatch, pfd->memid);
									}
								}

								else
								{
									int rc = TestAndClearVariant(*pvarResult);

									if (rc != 0)
									{
										return(rc);
									}
								}
							}
						}

						else
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								VariantClear(&rgvar[ivar]);
							}

							if ((hr == DISP_E_MEMBERNOTFOUND) &&
								(pfd->memid >= 0) &&
								(pfd->wFuncFlags & FUNCFLAG_FRESTRICTED))
							{
								// CTypeInfo2::Invoke in OLEAUT32.DLL contains

								//     // New-format typelibs don't allow late-binding to restricted members
								//     if (memid >= 0 && (pFunc->funcflags & FUNCFLAG_FRESTRICTED)) {
								//	 return HresultOfScode(DISP_E_MEMBERNOTFOUND);
								//     }
							}

							else
							{
								if (hr == DISP_E_EXCEPTION)
								{
									hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
								}

								// Don't report invalid arguments as we try this often
								// Don't report consecutive instances of same error per method

								if ((hr != E_INVALIDARG) && (hr != hrLastError))
								{
									hrLastError = hr;

									if (bstrName != NULL)
									{
										ReportFailure(0x2E06, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d, \"%s\") failed.  hr = %08X", szIidDispatch, pfd->memid, bstrName, hr);
									}

									else
									{
										ReportFailure(0x2E06, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d) failed.  hr = %08X", szIidDispatch, pfd->memid, hr);
									}
								}
							}
						}

						if (fAdvance)
						{
							break;
						}
					}
				}

				if (bstrName != NULL)
				{
					SysFreeString(bstrName);
				}

				piti->ReleaseFuncDesc(pfd);
			}
		}

		delete [] rgvar;
		delete [] rgarg;
	}

	piti->ReleaseTypeAttr(pta);

	return(0);
}


int CheckIDispatchEx(IUnknown *punk, bool fClassObject)
{
	if (fNoIDispatch)
	{
		return(-1);
	}

	IDispatchEx *pide;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IDispatchEx", IID_PPV_ARGS(&pide));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IDispatch *pid;

	hr = HrQueryInterface(punk, fClassObject, L"IDispatch", IID_PPV_ARGS(&pid));

	if (SUCCEEDED(hr))
	{
		Release(pid, fClassObject);
	}

	else
	{
		ReportFailure(0x2F01, false, punk, 0, L"IDispatchEx w/o IDispatch");
	}

	bool fGetTypeInfoCountNotImpl = false;

	UINT ctinfo;

	hr = pide->GetTypeInfoCount(&ctinfo);

	if (FAILED(hr))
	{
		if (hr == E_NOTIMPL)
		{
			fGetTypeInfoCountNotImpl = true;
		}

		else
		{
			ReportFailure(0x2F02, false, pide, 3, L"IDispatchEx::GetTypeInfoCount failure did not return E_NOTIMPL.  hr = %08X", hr);
		}

		ctinfo = 0;
	}

	else if (ctinfo > 1)
	{
		ReportFailure(0x2F03, false, pide, 3, L"IDispatchEx::GetTypeInfoCount returned ctinfo of %u", ctinfo);
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pide->GetTypeInfo(ctinfo, LOCALE_NEUTRAL, &piti);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x2F04, false, pide, 4, L"IDispatchEx::GetTypeInfo(%u) succeeded", ctinfo);

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	else if ((hr != DISP_E_BADINDEX) && !fGetTypeInfoCountNotImpl)
	{
		ReportFailure(0x2F05, false, pide, 4, L"IDispatchEx::GetTypeInfo(%u) failure did not return DISP_E_BADINDEX.  hr = %08X", ctinfo, hr);
	}

	if (ctinfo != 0)
	{
		piti = (ITypeInfo *) (intptr_t) -1;

		hr = pide->GetTypeInfo(0, LOCALE_NEUTRAL, &piti);

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			if (fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x2F06, false, pide, 4, L"IDispatchEx::GetTypeInfo(0) succeded but GetTypeInfoCount returned E_NOTIMPL");
			}

			int rc = TestInterface(piti, NULL, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			piti = NULL;

			if ((hr != E_NOTIMPL) && fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x2F07, false, pide, 4, L"IDispatchEx::GetTypeInfo(0) did not return E_NOTIMPL when GetTypeInfoCount did.  hr = %08X", hr);
			}
		}
	}

	else
	{
		piti = NULL;
	}

	wchar_t *rgszNames[1] =
	{
		L"Aj_34Hfm6",
	};

	DISPID dispid;

	hr = pide->GetIDsOfNames(IID_NULL,
		rgszNames,
		1,
		LOCALE_NEUTRAL,
		&dispid);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x2F15, false, pide, 5, L"IDispatchEx::GetIDsOfNames(\"Aj_34Hfm6\") succeeded");
	}


	bool fMemberNotFound = false;

	DISPPARAMS dp;
	VARIANT varResult;
	EXCEPINFO ei;

	dp.rgvarg = NULL;
	dp.rgdispidNamedArgs = NULL;
	dp.cArgs = 0;
	dp.cNamedArgs = 0;

	varResult.vt = VT_ILLEGAL;

	memset(&ei, -1, sizeof(ei));

	hr = pide->InvokeEx(0x73529A4B,			       // id
		LOCALE_SYSTEM_DEFAULT,		       // lcid
		DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
		&dp,				       // pdp
		&varResult,			       // pVarRes
		&ei,				       // pei
		NULL);				       // pspCaller

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x2F08, false, pide, 8, L"IDispatchEx::InvokeEx(0x73529A4B) succeeded");

		if (varResult.vt == VT_ILLEGAL)
		{
			ReportFailure(0x2F09, false, pide, 8, L"IDispatchEx::InvokeEx(0x73529A4B) did not initialize varResult");
		}

		else
		{
			VariantClear(&varResult);
		}
	}

	else
	{
		if (hr == DISP_E_EXCEPTION)
		{
			hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
		}

		if (hr != DISP_E_MEMBERNOTFOUND)
		{
			fMemberNotFound = true;       // Report once only

			ReportFailure(0x2F0A, false, pide, 8, L"IDispatchEx::InvokeEx(0x73529A4B) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", hr);
		}
	}

	// Try reserved DISPIDs

	for (size_t idispids = 0; idispids < cdispids; idispids++)
	{
		dispid = rgdispids[idispids].dispid;
		const wchar_t *szDispid = rgdispids[idispids].sz;

		// UNDONE: Use GetMemberProperties to decide how to call

		dp.rgvarg = NULL;
		dp.rgdispidNamedArgs = NULL;
		dp.cArgs = 0;
		dp.cNamedArgs = 0;

		varResult.vt = VT_ILLEGAL;

		memset(&ei, -1, sizeof(ei));

		hr = pide->InvokeEx(dispid,				  // id
			LOCALE_SYSTEM_DEFAULT,		  // lcid
			DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
			&dp,					  // pdp
			&varResult,				  // pVarRes
			&ei,					  // pei
			NULL);				  // pspCaller

		SetMyUnhandledExceptionFilter(true);

		if (SUCCEEDED(hr))
		{
			if (varResult.vt == VT_ILLEGAL)
			{
				ReportFailure(0x2F0B, false, pide, 8, L"IDispatchEx::InvokeEx(%s) did not initialize varResult", szDispid);
			}

			else
			{
				int rc = TestAndClearVariant(varResult);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		else
		{
			if (hr == DISP_E_EXCEPTION)
			{
				hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
			}

			if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT) && !fMemberNotFound)
			{
				fMemberNotFound = true;	  // Report once only

				ReportFailure(0x2F0C, false, pide, 8, L"IDispatchEx::InvokeEx(%s) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", szDispid, hr);
			}
		}
	}

	if (piti != NULL)
	{
		int rc = CheckIDispatchExTypeInfo(pide, piti, NULL);

		if (rc == -1)
		{
			// Release piti and set to NULL so that we try fallback enumeration of DISPIDs

			Release(piti, false);

			piti = NULL;
		}

		else if (rc != 0)
		{
			return(rc);
		}
	}

	if (piti == NULL)
	{
		// We don't have an ITypeInfo.  Just try a range of DISPIDs.

		bool fGetNext = false;

		dispid = DISPID_STARTENUM;

		for (;;)
		{
			DISPID dispidNext;

			hr = pide->GetNextDispID(fdexEnumAll, dispid, &dispidNext);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x2F0D, false, pide, 13, L"IDispatchEx::GetNextDispID(%d) failure did not return E_NOTIMPL.  Returned%08X", dispid, hr);
				}
				break;
			}

			if (hr == S_FALSE)
			{
				break;
			}

			fGetNext = true;

			dispid = dispidNext;

			BSTR bstrName;

			hr = pide->GetMemberName(dispid, &bstrName);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x2F0E, false, pide, 12, L"IDispatchEx::GetMemberName(%d) failed.  hr = %08X", dispid, hr);
				}

				bstrName = NULL;
			}

			// UNDONE: Use GetMemberProperties to decide how to call

			dp.rgvarg = NULL;
			dp.rgdispidNamedArgs = NULL;
			dp.cArgs = 0;
			dp.cNamedArgs = 0;

			varResult.vt = VT_ILLEGAL;

			memset(&ei, -1, sizeof(ei));

			hr = pide->InvokeEx(dispid,				     // id
				LOCALE_SYSTEM_DEFAULT,		     // lcid
				DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
				&dp,				     // pdp
				&varResult,			     // pVarRes
				&ei,				     // pei
				NULL);				     // pspCaller

			SetMyUnhandledExceptionFilter(true);

			if (SUCCEEDED(hr))
			{
				if (varResult.vt == VT_ILLEGAL)
				{
					ReportFailure(0x2F0F, false, pide, 8, L"IDispatchEx::InvokeEx(%d) did not initialize varResult", dispid);
				}

				else
				{
					int rc = TestAndClearVariant(varResult);

					if (rc != 0)
					{
						return(rc);
					}
				}
			}

			else
			{
				if (hr == DISP_E_EXCEPTION)
				{
					hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
				}

				if (hr == DISP_E_MEMBERNOTFOUND)
				{
					ReportFailure(0x2F10, false, pide, 8, L"IDispatchEx::InvokeEx(%d \"%s\") returned DISP_E_MEMBERNOTFOUND", dispid, (bstrName == NULL) ? L"" : bstrName);
				}

#if 1
				else if (hr != DISP_E_BADPARAMCOUNT)
				{
					ReportFailure(0x2F11, false, pide, 8, L"IDispatchEx::InvokeEx(%d \"%s\") failed.  hr = %08X", dispid, (bstrName == NULL) ? L"" : bstrName, hr);
				}
#endif
			}

			if (bstrName != NULL)
			{
				SysFreeString(bstrName);
			}
		}

		if (!fGetNext)
		{
			for (dispid = 1; dispid < dispidMax; dispid++)
			{
				BSTR bstrName;

				hr = pide->GetMemberName(dispid, &bstrName);

				if (FAILED(hr))
				{
					if (hr != E_NOTIMPL)
					{
						ReportFailure(0x2F12, false, pide, 12, L"IDispatchEx::GetMemberName(%d) failed.  hr = %08X", dispid, hr);
					}

					bstrName = NULL;
				}

				// UNDONE: Use GetMemberProperties to decide how to call

				dp.rgvarg = NULL;
				dp.rgdispidNamedArgs = NULL;
				dp.cArgs = 0;
				dp.cNamedArgs = 0;

				varResult.vt = VT_ILLEGAL;

				memset(&ei, -1, sizeof(ei));

				hr = pide->InvokeEx(dispid, 				// id
					LOCALE_SYSTEM_DEFAULT,			// lcid
					DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
					&dp,					// pdp
					&varResult,				// pVarRes
					&ei,					// pei
					NULL);					// pspCaller

				SetMyUnhandledExceptionFilter(true);

				if (SUCCEEDED(hr))
				{
					if (varResult.vt == VT_ILLEGAL)
					{
						ReportFailure(0x2F13, false, pide, 8, L"IDispatchEx::InvokeEx(%d) did not initialize varResult", dispid);
					}

					else
					{
						int rc = TestAndClearVariant(varResult);

						if (rc != 0)
						{
							return(rc);
						}
					}
				}

				else
				{
					if (hr == DISP_E_EXCEPTION)
					{
						hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
					}

					if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT))
					{
						if (bstrName != NULL)
						{
							ReportFailure(0x2F14, false, pide, 8, L"IDispatchEx::InvokeEx(%d \"%s\") failed.  hr = %08X", dispid, bstrName, hr);
						}

						else
						{
							ReportFailure(0x2F14, false, pide, 8, L"IDispatchEx::InvokeEx(%d) failed.  hr = %08X", dispid, hr);
						}
					}
				}

				if (bstrName != NULL)
				{
					SysFreeString(bstrName);
				}
			}
		}
	}

	else
	{
		Release(piti, false);
	}

	Release(pide, fClassObject);

	return(0);
}


int CheckIEnumConnectionPoints(IUnknown *punk, bool fClassObject)
{
	IEnumConnectionPoints *piecp;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumConnectionPoints", IID_PPV_ARGS(&piecp));

	if (FAILED(hr))
	{
		return(0);
	}

	IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

	hr = piecp->Next(1, &picp, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1001, false, piecp, 3, L"IEnumConnectionPoints::Next(1, &picp, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		if (picp == NULL)
		{
			ReportFailure(0x1002, false, piecp, 3, L"IEnumConnectionPoints::Next(1, &picp, NULL) returned NULL");
		}

		else
		{
			dwNonClass++;

			Release(picp, false);
		}
	}

	hr = piecp->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1003, false, piecp, 5, L"IEnumConnectionPoints::Reset failed.  hr = %08X", hr);
	}

	hr = piecp->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1004, false, piecp, 4, L"IEnumConnectionPoints::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piecp->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1005, false, piecp, 5, L"IEnumConnectionPoints::Reset failed.  hr = %08X", hr);
	}

	IID iidLast = iidUndefined;

	for (;;)
	{
		picp = (IConnectionPoint *) (intptr_t) -1;

		ULONG celtFetched;

		hr = piecp->Next(1, &picp, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1006, false, piecp, 3, L"IEnumConnectionPoints::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1007, false, piecp, 3, L"IEnumConnectionPoints::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1008, false, piecp, 3, L"IEnumConnectionPoints::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		if (picp != NULL)
		{
			dwNonClass++;

			IID iidT;

			hr = picp->GetConnectionInterface(&iidT);

			if (SUCCEEDED(hr))
			{
				if (iidT == iidLast)
				{
					// There looks to be an loop.  MSN Messenger has this bug.

					ReportFailure(0x1009, false, piecp, 3, L"IEnumConnectionPoints::Next returned duplicate connection point");

					Release(picp, false);
					break;
				}

				iidLast = iidT;
			}

			int rc = TestAndReleaseInterface(picp, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	IEnumConnectionPoints *piecpClone;

	hr = piecp->Clone(&piecpClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x100A, false, piecp, 6, L"IEnumConnectionPoints::Clone failed.  hr = %08X", hr);
		}
	}

	else if (piecpClone == NULL)
	{
		ReportFailure(0x100B, false, piecp, 6, L"IEnumConnectionPoints::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(piecpClone, false);
	}

	Release(piecp, fClassObject);

	return(0);
}


int CheckIEnumConnections(IUnknown *punk, bool fClassObject)
{
	IEnumConnections *piec;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumConnections", IID_PPV_ARGS(&piec));

	if (FAILED(hr))
	{
		return(0);
	}

	CONNECTDATA cd;

	cd.pUnk = (IUnknown *) (intptr_t) -1;
	cd.dwCookie = (DWORD) -1;

	hr = piec->Next(1, &cd, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1101, false, piec, 3, L"IEnumConnections::Next(1, &cd, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		dwNonClass++;

		Release(cd.pUnk, false);
	}

	hr = piec->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1102, false, piec, 5, L"IEnumConnections::Reset failed.  hr = %08X", hr);
	}

	hr = piec->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1103, false, piec, 4, L"IEnumConnections::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piec->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1104, false, piec, 5, L"IEnumConnections::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		cd.pUnk = (IUnknown *) (intptr_t) -1;
		cd.dwCookie = (DWORD) -1;

		ULONG celtFetched;

		hr = piec->Next(1, &cd, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1105, false, piec, 3, L"IEnumConnections::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1106, false, piec, 3, L"IEnumConnections::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1107, false, piec, 3, L"IEnumConnections::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		dwNonClass++;

		int rc = TestAndReleaseInterface(cd.pUnk, NULL, true, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IEnumConnections *piecClone;

	hr = piec->Clone(&piecClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1108, false, piec, 6, L"IEnumConnections::Clone failed.  hr = %08X", hr);
		}
	}

	else if (piecClone == NULL)
	{
		ReportFailure(0x1109, false, piec, 6, L"IEnumConnections::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(piecClone, false);
	}

	Release(piec, fClassObject);

	return(0);
}


int CheckIEnumMoniker(IUnknown *punk, bool fClassObject)
{
	IEnumMoniker *piem;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumMoniker", IID_PPV_ARGS(&piem));

	if (FAILED(hr))
	{
		return(0);
	}

	IMoniker *pmk = (IMoniker *) (intptr_t) -1;

	hr = piem->Next(1, &pmk, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1201, false, piem, 3, L"IEnumMoniker::Next(1, &pmk, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		dwNonClass++;

		Release(pmk, false);
	}

	hr = piem->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1202, false, piem, 5, L"IEnumMoniker::Reset failed.  hr = %08X", hr);
	}

	hr = piem->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1203, false, piem, 4, L"IEnumMoniker::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piem->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1204, false, piem, 5, L"IEnumMoniker::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		pmk = (IMoniker *) (intptr_t) -1;

		ULONG celtFetched;

		hr = piem->Next(1, &pmk, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1205, false, piem, 3, L"IEnumMoniker::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1206, false, piem, 3, L"IEnumMoniker::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1207, false, piem, 3, L"IEnumMoniker::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		if (pmk != NULL)
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(pmk, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	IEnumMoniker *piemClone;

	hr = piem->Clone(&piemClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1208, false, piem, 6, L"IEnumMoniker::Clone failed.  hr = %08X", hr);
		}
	}

	else if (piemClone == NULL)
	{
		ReportFailure(0x1209, false, piem, 6, L"IEnumMoniker::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(piemClone, false);
	}

	Release(piem, fClassObject);

	return(0);
}


int CheckIEnumUnknown(IUnknown *punk, bool fClassObject)
{
	IEnumUnknown *pieu;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumUnknown", IID_PPV_ARGS(&pieu));

	if (FAILED(hr))
	{
		return(0);
	}

	IUnknown *punkEnum = (IUnknown *) (intptr_t) -1;

	hr = pieu->Next(1, &punkEnum, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1301, false, pieu, 3, L"IEnumUnknown::Next(1, &punk, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		dwNonClass++;

		Release(punkEnum, false);
	}

	hr = pieu->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1302, false, pieu, 5, L"IEnumUnknown::Reset failed.  hr = %08X", hr);
	}

	hr = pieu->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1303, false, pieu, 4, L"IEnumUnknown::Skip(1) failed.  hr = %08X", hr);
	}

	hr = pieu->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1304, false, pieu, 5, L"IEnumUnknown::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		punkEnum = (IUnknown *) (intptr_t) -1;

		ULONG celtFetched;

		hr = pieu->Next(1, &punkEnum, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1305, false, pieu, 3, L"IEnumUnknown::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1306, false, pieu, 3, L"IEnumUnknown::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1307, false, pieu, 3, L"IEnumUnknown::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		if (punkEnum != NULL)
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(punkEnum, NULL, true, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	IEnumUnknown *pieuClone;

	hr = pieu->Clone(&pieuClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1308, false, pieu, 6, L"IEnumUnknown::Clone failed.  hr = %08X", hr);
		}
	}

	else if (pieuClone == NULL)
	{
		ReportFailure(0x1309, false, pieu, 6, L"IEnumUnknown::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(pieuClone, false);
	}

	Release(pieu, fClassObject);

	return(0);
}


int CheckIEnumVARIANT(IUnknown *punk, bool fClassObject)
{
	IEnumVARIANT *piev;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumVARIANT", IID_PPV_ARGS(&piev));

	if (FAILED(hr))
	{
		return(0);
	}

	VARIANT var;

	hr = piev->Next(1, &var, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1401, false, piev, 3, L"IEnumVARIANT::Next(1, &var, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		VariantClear(&var);
	}

	hr = piev->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1402, false, piev, 5, L"IEnumVARIANT::Reset failed.  hr = %08X", hr);
	}

	hr = piev->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1403, false, piev, 4, L"IEnumVARIANT::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piev->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1404, false, piev, 5, L"IEnumVARIANT::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		ULONG celtFetched;

		hr = piev->Next(1, &var, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1405, false, piev, 3, L"IEnumVARIANT::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1406, false, piev, 3, L"IEnumVARIANT::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1407, false, piev, 3, L"IEnumVARIANT::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		int rc = TestAndClearVariant(var);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IEnumVARIANT *pievClone;

	hr = piev->Clone(&pievClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1408, false, piev, 6, L"IEnumVARIANT::Clone failed.  hr = %08X", hr);
		}
	}

	else if (pievClone == NULL)
	{
		ReportFailure(0x1409, false, piev, 6, L"IEnumVARIANT::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(pievClone, false);
	}

	Release(piev, fClassObject);

	return(0);
}


int CheckIMoniker(IUnknown *punk, bool fClassObject)
{
	IMoniker *pmk;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IMoniker", IID_PPV_ARGS(&pmk));

	if (FAILED(hr))
	{
		return(0);
	}

	IBindCtx *pbc = NULL;

	hr = CreateBindCtx(0, &pbc);

	if (FAILED(hr))
	{
		pbc = NULL;
	}

	if (pbc != NULL)
	{
		// UNDONE: Use an IID other than IUnknown?

		IUnknown *punkBound = (IUnknown *) (intptr_t) -1;

		hr = pmk->BindToObject(pbc, pmk, IID_PPV_ARGS(&punkBound));

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(punkBound, NULL, true, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			if (hr != MK_E_NOOBJECT)
			{
				ReportFailure(0x2D01, false, pmk, 8, L"IMoniker::BindToObject failed.  hr = %08X", hr);
			}

			if (punkBound != NULL)
			{
				ReportFailure(0x2D02, false, pmk, 8, L"IMoniker::BindToObject failure did not set *ppvObject = NULL");
			}
		}
	}

	if (pbc != NULL)
	{
		// UNDONE: Use an IID other than IStream?

		IStream *pis = (IStream *) (intptr_t) -1;

		hr = pmk->BindToStorage(pbc, pmk, IID_PPV_ARGS(&pis));

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(pis, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			if ((hr != MK_E_NOSTORAGE) && (hr != E_NOINTERFACE))
			{
				ReportFailure(0x2D03, false, pmk, 9, L"IMoniker::BindToStorage failed.  hr = %08X", hr);
			}

			if (pis != NULL)
			{
				ReportFailure(0x2D04, false, pmk, 9, L"IMoniker::BindToStorage failure did not set *ppvObject = NULL");
			}
		}
	}

	IEnumMoniker *piem = (IEnumMoniker *) (intptr_t) -1;

	hr = pmk->Enum(TRUE, &piem);

	if (SUCCEEDED(hr))
	{
		// It is valid to return S_OK and piem == NULL

		if (piem != NULL)
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(piem, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	else if (piem != NULL)
	{
		ReportFailure(0x2D05, false, pmk, 12, L"IMoniker::Enum failed.  hr = %08X", hr);

		if (punk != NULL)
		{
			ReportFailure(0x2D06, false, pmk, 12, L"IMoniker::Enum failure did not set *ppenum = NULL");
		}
	}

	DWORD dwHash;

	hr = pmk->Hash(&dwHash);

	if (pbc != NULL)
	{
		wchar_t *szDisplayName;

		hr = pmk->GetDisplayName(pbc, NULL, &szDisplayName);

		if (SUCCEEDED(hr))
		{
			DWORD cchEaten;
			IMoniker *pmk2;

			hr = MkParseDisplayName(pbc, szDisplayName, &cchEaten, &pmk2);

			if (SUCCEEDED(hr))
			{
				dwNonClass++;

				FreeUnusedLibraries();

				if (cchEaten != wcslen(szDisplayName))
				{
					ReportFailure(0x2D07, false, NULL, 0, L"MkParseDisplayName consumed only part of OBJREF");
				}

				// Capture address of Release() method since after release the memory may be gone

				const void *pvRelease = PvMethod(pmk2, 2);

				ULONG cref = Release(pmk2, fClassObject);

				if (cref != 0)
				{
					ReportFailure(0x2D08, false, pvRelease, -1, L"IMoniker::Release returned %u", cref);
				}
			}

			else
			{
				ReportFailure(0x2D09, false, NULL, 0, L"MkParseDisplayName(\"%s\") failed.  hr = %08X", szDisplayName, hr);
			}

			CoTaskMemFree(szDisplayName);
		}
	}

	if (pbc != NULL)
	{
		pbc->Release();
	}

	Release(pmk, fClassObject);

	return(0);
}


int CheckIObjectSafety(IUnknown *punk, bool fClassObject)
{
	struct SAFETYINTERFACE
	{
		REFIID iid;
		const wchar_t *szIid;
	};

	static const SAFETYINTERFACE rgsi[] =
	{
		{ IID_IActiveScript,	    L"IActiveScript"	    },
		{ IID_IActiveScriptParse,     L"IActiveScriptParse"   },
		{ IID_IDispatch,		    L"IDispatch"	    },
		{ IID_IDispatchEx,	    L"IDispatchEx"	    },
		{ IID_IPersist,		    L"IPersist" 	    },
		{ IID_IPersistFile,	    L"IPersistFile"	    },
#if 0
		{ IID_IPersistHistory,	    L"IPersistHistory"	    },
#endif
		{ IID_IPersistMoniker,	    L"IPersistMoniker"	    },
		{ IID_IPersistPropertyBag,    L"IPersistPropertyBag"  },
		{ IID_IPersistPropertyBag2,   L"IPersistPropertyBag2" },
		{ IID_IPersistStorage,	    L"IPersistStorage"	    },
		{ IID_IPersistStream,	    L"IPersistStream"	    },
		{ IID_IPersistStreamInit,     L"IPersistStreamInit"   },
	};

	const size_t csi = sizeof(rgsi) / sizeof(rgsi[0]);

	IObjectSafety *pios;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IObjectSafety", IID_PPV_ARGS(&pios));

	if (FAILED(hr))
	{
		return(0);
	}

	DWORD dwSupported;
	DWORD dwEnabled;

	hr = pios->GetInterfaceSafetyOptions(iidUndefined, &dwSupported, &dwEnabled);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1501, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(iidUndefined) succeeded");
	}

	else if (hr != E_NOINTERFACE)
	{
		ReportFailure(0x1502, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(iidUndefined) failure did not return E_NOINTERFACE.  hr = %08X", hr);
	}

	int rc;

	bool rgfSupportedNoSite[csi];
	DWORD rgdwSupportedNoSite[csi];
	DWORD rgdwEnabledNoSite[csi];

	for (size_t isi = 0; isi < csi; isi++)
	{
		rc = GetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, &rgfSupportedNoSite[isi], &rgdwSupportedNoSite[isi], &rgdwEnabledNoSite[isi]);

		if (rc != 0)
		{
			Release(pios, fClassObject);

			return(rc);
		}
	}

	if (fCheckSafety)
	{
		for (size_t isi = 0; isi < csi; isi++)
		{
			if (rgfSupportedNoSite[isi])
			{
				ReportFailure(0x15FF, false, pios, 3, L"GetInterfaceSafetyOptions: dwSupported=%08X, dwEnabled=%08X, %s", rgdwSupportedNoSite[isi], rgdwEnabledNoSite[isi], rgsi[isi].szIid);
			}
		}
	}

	if (fHTML || fCheckSafety)
	{
		// With -html we don't want to override the HTML site

		Release(pios, fClassObject);

		return(0);
	}

	for (size_t isi = 0; isi < csi; isi++)
	{
		rc = SetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, rgfSupportedNoSite[isi], rgdwSupportedNoSite[isi], rgdwEnabledNoSite[isi]);

		if (rc != 0)
		{
			Release(pios, fClassObject);

			return(rc);
		}
	}

	{
		rc = SetSite(punk, NULL);

		if (rc != 0)
		{
			if (rc == -1)
			{
				// Neither IOleObject nor IObjectWithSite supported

				rc = 0;
			}

			Release(pios, fClassObject);

			return(rc);
		}

		bool rgfSupportedNullSite[csi];
		DWORD rgdwSupportedNullSite[csi];
		DWORD rgdwEnabledNullSite[csi];

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = GetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, &rgfSupportedNullSite[isi], &rgdwSupportedNullSite[isi], &rgdwEnabledNullSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = SetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, rgfSupportedNullSite[isi], rgdwSupportedNullSite[isi], rgdwEnabledNullSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			if (rgfSupportedNoSite[isi] != rgfSupportedNullSite[isi])
			{
				ReportFailure(0x1503, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failure changed between no site and NULL site", rgsi[isi].szIid);
			}

			else if (rgfSupportedNoSite[isi])
			{
				if (rgdwSupportedNoSite[isi] != rgdwSupportedNullSite[isi])
				{
					ReportFailure(0x1504, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported for no site %08X != NULL site %08X", rgsi[isi].szIid, rgdwSupportedNoSite[isi], rgdwSupportedNullSite[isi]);
				}

				if (rgdwEnabledNoSite[isi] != rgdwEnabledNullSite[isi])
				{
					ReportFailure(0x1505, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwEnabled for no site %08X != NULL site %08X", rgsi[isi].szIid, rgdwEnabledNoSite[isi], rgdwEnabledNullSite[isi]);
				}
			}
		}
	}

	{
		CSite cs;

		rc = SetSite(punk, &cs);

		if (rc != 0)
		{
			if (rc == -1)
			{
				// Neither IOleObject nor IObjectWithSite supported

				rc = 0x1506;
			}

			Release(pios, fClassObject);

			return(rc);
		}

		if (cs.m_cref <= 1)
		{
			ReportFailure(0x1507, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}

		bool rgfSupportedDumbSite[csi];
		DWORD rgdwSupportedDumbSite[csi];
		DWORD rgdwEnabledDumbSite[csi];

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = GetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, &rgfSupportedDumbSite[isi], &rgdwSupportedDumbSite[isi], &rgdwEnabledDumbSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = SetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, rgfSupportedDumbSite[isi], rgdwSupportedDumbSite[isi], rgdwEnabledDumbSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			if (rgfSupportedNoSite[isi] != rgfSupportedDumbSite[isi])
			{
				ReportFailure(0x1508, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failure changed between no site and dumb site", rgsi[isi].szIid);
			}

			else if (rgfSupportedNoSite[isi])
			{
				if (rgdwSupportedNoSite[isi] != rgdwSupportedDumbSite[isi])
				{
					ReportFailure(0x1509, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported for no site %08X != dumb site %08X", rgsi[isi].szIid, rgdwSupportedNoSite[isi], rgdwSupportedDumbSite[isi]);
				}

				if (rgdwEnabledNoSite[isi] != rgdwEnabledDumbSite[isi])
				{
					ReportFailure(0x150A, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwEnabled for no site %08X != dumb site %08X", rgsi[isi].szIid, rgdwEnabledNoSite[isi], rgdwEnabledDumbSite[isi]);
				}
			}
		}

		rc = SetSite(punk, NULL);

		if (rc != 0)
		{
			if (rc == -1)
			{
				// Neither IOleObject nor IObjectWithSite supported

				rc = 0x150B;
			}

			Release(pios, fClassObject);

			return(rc);
		}

		if (cs.m_cref != 1)
		{
			ReportFailure(0x150C, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
		}
	}

	// UNDONE: Try more site variations

	Release(pios, fClassObject);

	return(rc);
}


int CheckIOleCommandTarget(IUnknown *punk, bool fClassObject)
{
	IOleCommandTarget *pioct;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IOleCommandTarget", IID_PPV_ARGS(&pioct));

	if (FAILED(hr))
	{
		return(0);
	}

	OLECMD olecmd;

	olecmd.cmdID = 0;		       // Undefined command
	olecmd.cmdf = 0;

	hr = pioct->QueryStatus(NULL, 1, &olecmd, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1601, false, pioct, 3, L"IOleCommandTarget::QueryStatus(NULL) return %08X", hr);
	}

	if (olecmd.cmdf & OLECMDF_SUPPORTED)
	{
		ReportFailure(0x1602, false, pioct, 3, L"IOleCommandTarget::QueryStatus(NULL) CMDID == 0 supported");
	}

	hr = pioct->Exec(NULL, 0, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1603, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, 0) succeeded");
	}

	else if (hr != OLECMDERR_E_NOTSUPPORTED)
	{
		ReportFailure(0x1604, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, 0) failure did not return OLECMDERR_E_NOTSUPPORTED.  hr = %08X", hr);
	}

	hr = pioct->Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (FAILED(hr))
	{
		if (hr != OLECMDERR_E_NOTSUPPORTED)
		{
			ReportFailure(0x1605, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, OLECMDID_REFRESH) failure did not return OLECMDERR_E_NOTSUPPORTED.  hr = %08X", hr);
		}
	}

	hr = pioct->Exec(NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (FAILED(hr))
	{
		if (hr != OLECMDERR_E_NOTSUPPORTED)
		{
			ReportFailure(0x1606, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, OLECMDID_STOP) failure did not return OLECMDERR_E_NOTSUPPORTED.  hr = %08X", hr);
		}
	}

	olecmd.cmdID = 0;
	olecmd.cmdf = 0;

	hr = pioct->QueryStatus(&iidUndefined, 1, &olecmd, NULL);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1607, false, pioct, 3, L"IOleCommandTarget::QueryStatus(iidUndefined) succeeded");
	}

	else if (hr != OLECMDERR_E_UNKNOWNGROUP)
	{
		ReportFailure(0x1608, false, pioct, 3, L"IOleCommandTarget::QueryStatus(iidUndefined) failure did not return OLECMDERR_E_UNKNOWNGROUP.  hr = %08X", hr);
	}

	hr = pioct->Exec(&iidUndefined, 0, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1609, false, pioct, 4, L"IOleCommandTarget::Exec(iidUndefined) succeeded");
	}

	else if (hr != OLECMDERR_E_UNKNOWNGROUP)
	{
		ReportFailure(0x160A, false, pioct, 4, L"IOleCommandTarget::Exec(iidUndefined) failure did not return OLECMDERR_E_UNKNOWNGROUP.  hr = %08X", hr);
	}

	Release(pioct, fClassObject);

	return(0);
}


int CheckIOleControl(IUnknown *punk, bool fClassObject)
{
	IOleControl *pioc;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IOleControl", IID_PPV_ARGS(&pioc));

	if (FAILED(hr))
	{
		return(0);
	}

	CONTROLINFO ci;

	memset(&ci, 0xFF, sizeof(ci));

	ci.cb = sizeof(ci);

	hr = pioc->GetControlInfo(&ci);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1701, false, pioc, 3, L"IOleControl::GetControlInfo failure did not return E_NOTIMPL.  hr = %08X", hr);
		}

		MSG msg;

		memset(&msg, 0, sizeof(msg));

		hr = pioc->OnMnemonic(&msg);

		if (SUCCEEDED(hr))
		{
			ReportFailure(0x1702, false, pioc, 4, L"IOleControl::OnMnemonic succeeded after GetControlInfo failure");
		}

		else if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1703, false, pioc, 4, L"IOleControl::OnMnemonic() failure did not return E_NOTIMPL after GetControlInfo failure.  hr = %08X", hr);
		}
	}

	else
	{
		if (ci.cb != sizeof(ci))
		{
			ReportFailure(0x1704, false, pioc, 3, L"IOleControl::GetControlInfo returned CONTROLINFO::cb == %u", ci.cb);
		}

		if (ci.dwFlags & ~(CTRLINFO_EATS_RETURN | CTRLINFO_EATS_ESCAPE))
		{
			ReportFailure(0x1705, false, pioc, 3, L"IOleControl::GetControlInfo returned CONTROLINFO::dwFlags == %08X", ci.dwFlags);
		}

		if (ci.cAccel != 0)
		{
			ACCEL *rgaccel = new ACCEL[ci.cAccel];

			if (rgaccel == NULL)
			{
				// UNDONE: What?
			}

			else
			{
				int cAccel = CopyAcceleratorTable(ci.hAccel, NULL, 0);

				if (cAccel != ci.cAccel)
				{
					ReportFailure(0x1706, false, pioc, 3, L"IOleControl::GetControlInfo ci.hAccel size (%d) != ci.cAccel (%u)", cAccel, ci.cAccel);
				}

				else
				{
					cAccel = CopyAcceleratorTable(ci.hAccel, rgaccel, ci.cAccel);

					if (cAccel != ci.cAccel)
					{
						// UNDONE: What?
					}

					for (DWORD iaccel = 0; iaccel < ci.cAccel; iaccel++)
					{
						if (rgaccel[iaccel].fVirt & ~(FVIRTKEY | FNOINVERT | FSHIFT | FCONTROL | FALT))
						{
							ReportFailure(0x1707, false, pioc, 3, L"IOleControl::GetControlInfo rgaccel[%u].fVirt == %08X", iaccel, rgaccel[iaccel].fVirt);
						}

						// UNDONE: Call IOleControl::OnMnemonic
					}

					delete [] rgaccel;
				}
			}
		}

		else
		{
			MSG msg;

			memset(&msg, 0, sizeof(msg));

			hr = pioc->OnMnemonic(&msg);

			if (SUCCEEDED(hr))
			{
				ReportFailure(0x1708, false, pioc, 4, L"IOleControl::OnMnemonic() succeeded w/cAccel == 0");
			}

			else if (hr != E_NOTIMPL)
			{
				ReportFailure(0x1709, false, pioc, 4, L"IOleControl::OnMnemonic() failure did not return E_NOTIMPL w/cAccel == 0.  hr = %08X", hr);
			}
		}
	}

	hr = pioc->OnAmbientPropertyChange(DISPID_VALUE);

	if (hr != S_OK)
	{
		ReportFailure(0x170A, false, pioc, 5, L"IOleControl::OnAmbientPropertyChange(DISPID_VALUE) did not return S_OK.  hr = %08X", hr);
	}

	hr = pioc->OnAmbientPropertyChange(DISPID_UNKNOWN);

	if (hr != S_OK)
	{
		ReportFailure(0x170B, false, pioc, 5, L"IOleControl::OnAmbientPropertyChange(DISPID_UNKNOWN) did not return S_OK.  hr = %08X", hr);
	}

	hr = pioc->FreezeEvents(TRUE);

	if (hr != S_OK)
	{
		ReportFailure(0x170C, false, pioc, 6, L"IOleControl::FreezeEvents(TRUE) did not return S_OK.  hr = %08X", hr);
	}

	hr = pioc->FreezeEvents(FALSE);

	if (hr != S_OK)
	{
		ReportFailure(0x170E, false, pioc, 6, L"IOleControl::FreezeEvents(FALSE) did not return S_OK.  hr = %08X", hr);
	}

	Release(pioc, fClassObject);

	return(0);
}


int CheckIPersist(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersist *pip;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (FAILED(hr))
	{
		return(0);
	}

	CLSID clsid2;

	hr = pip->GetClassID(&clsid2);

	if (FAILED(hr))
	{
		ReportFailure(0x1801, false, pip, 3, L"IPersist::GetClassID failed.  hr = %08X", hr);
	}

	else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
	{
		wchar_t szClsid2[39];

		if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
		{
			wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
		}

		ReportFailure(0x1802, false, pip, 3, L"IPersist::GetClassID returned %s", szClsid2);
	}

	Release(pip, fClassObject);

	return(0);
}


int CheckIPersistHistory(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistHistory *piph;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistHistory", IID_PPV_ARGS(&piph));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x2401, false, punk, 0, L"IPersistHistory w/o IPersist");

		CLSID clsid2;

		hr = piph->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x2402, false, piph, 3, L"IPersistHistory::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x2403, false, piph, 3, L"IPersistHistory::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistHistory methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x2404, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x2411, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	DWORD dwPositionCookie;

	hr = piph->GetPositionCookie(&dwPositionCookie);

	if (FAILED(hr))
	{
		ReportFailure(0x2405, false, piph, 4, L"IPersistHistory::GetPositionCookie failed.  hr = %08X", hr);
	}

	IStream *pis = (IStream *) (intptr_t) -1;

	hr = CreateStreamOnHGlobal(NULL, TRUE, &pis);

	if (FAILED(hr))
	{
		ReportFailure(0x2406, false, NULL, 0, L"CreateStreamOnHGlobal failed.  hr = %08X", hr);
	}

	else
	{
		ULARGE_INTEGER uli0;

		uli0.QuadPart = 0;

		hr = pis->SetSize(uli0);

		if (FAILED(hr))
		{
			ReportFailure(0x2407, false, pis, 6, L"IStream::SetSize(0) failed.  hr = %08X", hr);
		}

		hr = piph->SaveHistory(pis);

		// UNDONE: We should wrap IStream so that we do not rely on system class implementation

		pis->AddRef();

		ULONG cref = pis->Release();

		if (cref != 1)
		{
			ReportFailure(0x2408, false, piph, 6, L"IPersistHistory::Save held reference to stream (%u)", cref);
		}

		if (FAILED(hr))
		{
			if (hr != E_NOTIMPL)
			{
				ReportFailure(0x2409, false, piph, 6, L"IPersistHistory::SaveHistory failed.  hr = %08X", hr);
			}
		}

		else
		{
			LARGE_INTEGER li0;

			li0.QuadPart = 0;

			unsigned __int64 ibNew;

			hr = pis->Seek(li0, STREAM_SEEK_SET, (ULARGE_INTEGER *) &ibNew);

			if (FAILED(hr))
			{
				ReportFailure(0x240A, false, pis, 5, L"IStream::Seek(0, STREAM_SEEK_SET) failed.  hr = %08X", hr);
			}

			else
			{
				IBindCtx *pbc = NULL;

				hr = CreateBindCtx(0, &pbc);

				if (SUCCEEDED(hr))
				{
					hr = piph->LoadHistory(pis, pbc);

					// UNDONE: We should wrap IStream so that we do not rely on system class implementation

					pis->AddRef();

					cref = pis->Release();

					if (cref != 1)
					{
						ReportFailure(0x240B, false, piph, 5, L"IPersistHistory::LoadHistory held reference to stream (%u)", cref);
					}

					if (FAILED(hr))
					{
						ReportFailure(0x240C, false, piph, 5, L"IPersistHistory::Load failed.  hr = %08X", hr);
					}

					// Capture address of Release() method since after release the memory may be gone

					const void *pvRelease = PvMethod(pbc, 2);

					cref = pbc->Release();

					if (cref != 0)
					{
						ReportFailure(0x240D, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
					}
				}
			}
		}

		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(pis, 2);

		cref = pis->Release();

		if (cref != 0)
		{
			ReportFailure(0x240E, false, pvRelease, -1, L"IStream::Release returned %u", cref);
		}
	}

	hr = piph->SetPositionCookie(dwPositionCookie);

	if (FAILED(hr))
	{
		ReportFailure(0x240F, false, piph, 7, L"IPersistHistory::SetPositionCookie failed.  hr = %08X", hr);
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x2410, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	Release(piph, fClassObject);

	return(0);
}


int CheckIPersistPropertyBag(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistPropertyBag *pippb;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistPropertyBag", IID_PPV_ARGS(&pippb));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x1901, false, punk, 0, L"IPersistPropertyBag w/o IPersist");

		CLSID clsid2;

		hr = pippb->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x1902, false, pippb, 3, L"IPersistPropertyBag::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x1903, false, pippb, 3, L"IPersistPropertyBag::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistPropertyBag methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x1904, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x190A, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	if (!fHTML)
	{
		hr = pippb->InitNew();

		if (FAILED(hr))
		{
			ReportFailure(0x1905, false, pippb, 4, L"IPersistPropertyBag::InitNew failed.  hr = %08X", hr);
		}
	}

	CPropertyBag *pcpb = new CPropertyBag;

	hr = pippb->Save(pcpb, FALSE, TRUE);

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1906, false, pippb, 6, L"IPersistPropertyBag::Save failed.  hr = %08X", hr);
	}

	hr = pippb->Load(pcpb, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1907, false, pippb, 5, L"IPersistPropertyBag::Load failed.  hr = %08X", hr);
	}

	if (pcpb->m_cref != 1)
	{
		ReportFailure(0x1909, false, pippb, 5, L"IPersistPropertyBag::Load held reference to property bag (%u)", pcpb->m_cref);
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x1908, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	pcpb->Release();

	Release(pippb, fClassObject);

	return(0);
}


int CheckIPersistStream(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistStream *pips;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistStream", IID_PPV_ARGS(&pips));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x3001, false, punk, 0, L"IPersistStream w/o IPersist");

		CLSID clsid2;

		hr = pips->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x3002, false, pips, 3, L"IPersistStream::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x3003, false, pips, 3, L"IPersistStream::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistStream methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x3004, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x300E, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	unsigned __int64 cb = 0;

	hr = pips->GetSizeMax((ULARGE_INTEGER *) &cb);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x3005, false, pips, 7, L"IPersistStream::GetSizeMax failed.  hr = %08X", hr);
		}

		// Let's assume 64K

		cb = 65536;
	}

	if (cb > 0x7FFFFFFF)
	{
		ReportFailure(0x3006, false, pips, 7, L"IPersistStream::GetSizeMax returned cb = %I64u", cb);
	}

	HGLOBAL hStream = GlobalAlloc(GMEM_MOVEABLE, (size_t) cb);

	if (hStream == NULL)
	{
		ReportFailure(0x3007, false, NULL, 0, L"GlobalAlloc failed.  GetLastError(%I64u) = %u", cb, GetLastError());
	}

	else
	{
		IStream *pis = (IStream *) (intptr_t) -1;

		hr = CreateStreamOnHGlobal(hStream, TRUE, &pis);

		if (FAILED(hr))
		{
			ReportFailure(0x3008, false, NULL, 0, L"CreateStreamOnHGlobal failed.  hr = %08X", hr);

			GlobalFree(hStream);
		}

		else
		{
			ULARGE_INTEGER uli0;

			uli0.QuadPart = 0;

			hr = pis->SetSize(uli0);

			if (FAILED(hr))
			{
				ReportFailure(0x3009, false, pis, 6, L"IStream::SetSize(0) failed.  hr = %08X", hr);
			}

			hr = pips->Save(pis, FALSE);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x300A, false, pips, 6, L"IPersistStream::Save failed.  hr = %08X", hr);
				}
			}

			else
			{
				LARGE_INTEGER li0;

				li0.QuadPart = 0;

				unsigned __int64 ibNew;

				hr = pis->Seek(li0, STREAM_SEEK_SET, (ULARGE_INTEGER *) &ibNew);

				if (FAILED(hr))
				{
					ReportFailure(0x300B, false, pis, 5, L"IStream::Seek(0, STREAM_SEEK_SET) failed.  hr = %08X", hr);
				}

				else
				{
					hr = pips->Load(pis);

					if (FAILED(hr))
					{
						ReportFailure(0x300C, false, pips, 5, L"IPersistStream::Load failed.  hr = %08X", hr);
					}
				}
			}

			// IPersistStream implementation may retain a reference

			pis->Release();
		}
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x300D, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	Release(pips, fClassObject);

	return(0);
}


int CheckIPersistStreamInit(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistStreamInit *pipsi;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistStreamInit", IID_PPV_ARGS(&pipsi));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x3101, false, punk, 0, L"IPersistStreamInit w/o IPersist");

		CLSID clsid2;

		hr = pipsi->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x3102, false, pipsi, 3, L"IPersistStreamInit::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x3103, false, pipsi, 3, L"IPersistStreamInit::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistStream methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x3104, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x310F, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	if (!fHTML)
	{
		hr = pipsi->InitNew();

		if (FAILED(hr) && (hr != E_NOTIMPL))
		{
			ReportFailure(0x3105, false, pipsi, 8, L"IPersistStreamInit::InitNew failed.  hr = %08X", hr);
		}
	}

	unsigned __int64 cb = 0;

	hr = pipsi->GetSizeMax((ULARGE_INTEGER *) &cb);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x3106, false, pipsi, 7, L"IPersistStreamInit::GetSizeMax failed.  hr = %08X", hr);
		}

		// Let's assume 64K

		cb = 65536;
	}

	if (cb > 0x7FFFFFFF)
	{
		ReportFailure(0x3107, false, pipsi, 7, L"IPersistStreamInit::GetSizeMax returned cb = %I64u", cb);
	}

	HGLOBAL hStream = GlobalAlloc(GMEM_MOVEABLE, (size_t) cb);

	if (hStream == NULL)
	{
		ReportFailure(0x3108, false, NULL, 0, L"GlobalAlloc failed.  GetLastError(%I64u) = %u", cb, GetLastError());
	}

	else
	{
		IStream *pis = (IStream *) (intptr_t) -1;

		hr = CreateStreamOnHGlobal(hStream, TRUE, &pis);

		if (FAILED(hr))
		{
			ReportFailure(0x3109, false, NULL, 0, L"CreateStreamOnHGlobal failed.  hr = %08X", hr);

			GlobalFree(hStream);
		}

		else
		{
			ULARGE_INTEGER uli0;

			uli0.QuadPart = 0;

			hr = pis->SetSize(uli0);

			if (FAILED(hr))
			{
				ReportFailure(0x310A, false, pis, 6, L"IStream::SetSize(0) failed.  hr = %08X", hr);
			}

			hr = pipsi->Save(pis, FALSE);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x310B, false, pipsi, 6, L"IPersistStreamInit::Save failed.  hr = %08X", hr);
				}
			}

			else
			{
				LARGE_INTEGER li0;

				li0.QuadPart = 0;

				unsigned __int64 ibNew;

				hr = pis->Seek(li0, STREAM_SEEK_SET, (ULARGE_INTEGER *) &ibNew);

				if (FAILED(hr))
				{
					ReportFailure(0x310C, false, pis, 5, L"IStream::Seek(0, STREAM_SEEK_SET) failed.  hr = %08X", hr);
				}

				else
				{
					hr = pipsi->Load(pis);

					if (FAILED(hr))
					{
						ReportFailure(0x310D, false, pipsi, 5, L"IPersistStreamInit::Load failed.  hr = %08X", hr);
					}
				}
			}

			// IPersistStream implementation may retain a reference

			pis->Release();
		}
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x310E, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	Release(pipsi, fClassObject);

	return(0);
}


int CheckIProvideClassInfo(IUnknown *punk, bool fClassObject)
{
	IProvideClassInfo *pipci;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo", IID_PPV_ARGS(&pipci));

	if (FAILED(hr))
	{
		return(0);
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pipci->GetClassInfo(&piti);

	if (FAILED(hr))
	{
		ReportFailure(0x1A01, false, pipci, 3, L"IProvideClassInfo::GetClassInfo failed.  hr = %08X", hr);
	}

	else
	{
		dwNonClass++;

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	Release(pipci, fClassObject);

	return(0);
}


int CheckIProvideClassInfo2(IUnknown *punk, bool fClassObject)
{
	IProvideClassInfo2 *pipci2;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo2", IID_PPV_ARGS(&pipci2));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IProvideClassInfo *pipci;

	hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo", IID_PPV_ARGS(&pipci));

	if (SUCCEEDED(hr))
	{
		Release(pipci, fClassObject);
	}

	else
	{
		ReportFailure(0x1B01, false, punk, 0, L"IProvideClassInfo2 w/o IProvideClassInfo");
	}

	IConnectionPointContainer *picpc;

	hr = HrQueryInterface(punk, fClassObject, L"IConnectionPointContainer", IID_PPV_ARGS(&picpc));

	if (FAILED(hr))
	{
		ReportFailure(0x1B02, false, punk, 0, L"IProvideClassInfo2 w/o IConnectionPointContainer");
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pipci2->GetClassInfo(&piti);

	if (FAILED(hr))
	{
		ReportFailure(0x1B03, false, pipci2, 3, L"IProvideClassInfo2::GetClassInfo failed.  hr = %08X", hr);
	}

	else
	{
		dwNonClass++;

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IID iidT;

	memset(&iidT, -1, sizeof(&iidT));

	hr = pipci2->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, &iidT);

	if (FAILED(hr))
	{
		ReportFailure(0x1B04, false, pipci2, 4, L"IProvideClassInfo2::GetGUID failed.  hr = %08X", hr);
	}

	else if (picpc != NULL)
	{
		IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

		hr = picpc->FindConnectionPoint(iidT, &picp);

		if (FAILED(hr))
		{
			ReportFailure(0x1B05, false, pipci2, 4, L"IConnectionPointContainer::FindConnectionPoint of IProvideClassInfo2::GetGUID failed.  hr = %08X", hr);
		}

		else
		{
			dwNonClass++;

			// Don't test this interface here.  We do in CheckIConnectionPointContainer

			Release(picp, false);
		}
	}

	if (picpc != NULL)
	{
		Release(picpc, fClassObject);
	}

	Release(pipci2, fClassObject);

	return(0);
}


int CheckIProvideMultipleClassInfo(IUnknown *punk, bool fClassObject)
{
	IProvideMultipleClassInfo *pipmci;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideMultipleClassInfo", IID_PPV_ARGS(&pipmci));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IProvideClassInfo2 *pipci2;

	hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo2", IID_PPV_ARGS(&pipci2));

	if (SUCCEEDED(hr))
	{
		Release(pipci2, fClassObject);
	}

	else
	{
		ReportFailure(0x1C01, false, punk, 0, L"IProvideMultipleClassInfo w/o IProvideClassInfo2");
	}

	IProvideClassInfo *pipci;

	hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo", IID_PPV_ARGS(&pipci));

	if (SUCCEEDED(hr))
	{
		Release(pipci, fClassObject);
	}

	else
	{
		ReportFailure(0x1C02, false, punk, 0, L"IProvideMultipleClassInfo w/o IProvideClassInfo");
	}

	IConnectionPointContainer *picpc;

	hr = HrQueryInterface(punk, fClassObject, L"IConnectionPointContainer", IID_PPV_ARGS(&picpc));

	if (FAILED(hr))
	{
		// Don't report failure yet.  GetMultiTypeInfo can be used without this
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pipmci->GetClassInfo(&piti);

	if (FAILED(hr))
	{
		ReportFailure(0x1C03, false, pipmci, 3, L"IProvideMultipleClassInfo::GetClassInfo failed.  hr = %08X", hr);
	}

	else
	{
		dwNonClass++;

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IID iidT;

	memset(&iidT, -1, sizeof(&iidT));

	hr = pipmci->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, &iidT);

	if (FAILED(hr))
	{
		ReportFailure(0x1C04, false, pipmci, 4, L"IProvideMultipleClassInfo::GetGUID failed.  hr = %08X", hr);
	}

	else if (picpc == NULL)
	{
		ReportFailure(0x1C05, false, punk, 0, L"IProvideMultipleClassInfo::GetGUID w/o IConnectionPointContainer");
	}

	else
	{
		IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

		hr = picpc->FindConnectionPoint(iidT, &picp);

		if (FAILED(hr))
		{
			ReportFailure(0x1C06, false, pipmci, 4, L"IConnectionPointContainer::FindConnectionPoint of IProvideMultipleClassInfo::GetGUID failed.  hr = %08X", hr);
		}

		else
		{
			dwNonClass++;

			// Don't test this interface here.  We do in CheckIConnectionPointContainer

			Release(picp, false);
		}
	}

	ULONG cti;

	hr = pipmci->GetMultiTypeInfoCount(&cti);

	if (FAILED(hr))
	{
		ReportFailure(0x1C07, false, pipmci, 5, L"IProvideMultipleClassInfo::GetMultiTypeInfoCount failed.  hr = %08X", hr);

		cti = 0;
	}

	for (ULONG iti = 0; iti < cti; iti++)
	{
		piti = (ITypeInfo *) (intptr_t) -1;

		DWORD dwTIFlags = (DWORD) -1;
		ULONG cdispidReserved = (ULONG) -1;
		IID iidPrimary;
		IID iidSource;

		memset(&iidPrimary, -1, sizeof(&iidPrimary));
		memset(&iidSource, -1, sizeof(&iidSource));

		hr = pipmci->GetInfoOfIndex(iti,
			MULTICLASSINFO_GETTYPEINFO |
			MULTICLASSINFO_GETNUMRESERVEDDISPIDS |
			MULTICLASSINFO_GETIIDPRIMARY |
			MULTICLASSINFO_GETIIDSOURCE,
			&piti,
			&dwTIFlags,
			&cdispidReserved,
			&iidPrimary,
			&iidSource);

		if (FAILED(hr))
		{
			ReportFailure(0x1C08, false, pipmci, 6, L"IProvideMultipleClassInfo::GetInfoOfIndex(%u) failed.  hr = %08X", iti, hr);
		}

		else
		{
			dwNonClass++;

			// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

			int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		// UNDONE: Check dwTiFlags, cdispidReserved

		if (iidPrimary != IID_NULL)
		{
			IUnknown *punkPrimary;

			HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideMultipleClassInfo::GetInfoOfIndex iidPrimary", iidPrimary, (void **) &punkPrimary);

			if (FAILED(hr))
			{
				ReportFailure(0x1C09, false, pipmci, 6, L"QueryInterface of IProvideMultipleClassInfo::GetInfoOfIndex iidPrimary failed.  hr = %08X", hr);
			}

			else
			{
				int rc = TestAndReleaseInterface(punkPrimary, NULL, false, fClassObject, false);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		if (iidSource != IID_NULL)
		{
			if (picpc == NULL)
			{
				ReportFailure(0x1C0A, false, punk, 0, L"IProvideMultipleClassInfo::GetInfoOfIndex iidSource w/o IConnectionPointContainer");
			}

			else
			{
				IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

				hr = picpc->FindConnectionPoint(iidT, &picp);

				if (FAILED(hr))
				{
					ReportFailure(0x1C0B, false, pipmci, 4, L"IConnectionPointContainer::FindConnectionPoint of IProvideMultipleClassInfo::GetInfoOfIndex iidSource failed.  hr = %08X", hr);
				}

				else
				{
					dwNonClass++;

					// Don't test this interface here.  We do in CheckIConnectionPointContainer

					Release(picp, false);
				}
			}
		}
	}

	if (picpc != NULL)
	{
		Release(picpc, fClassObject);
	}

	Release(pipmci, fClassObject);

	return(0);
}


int CheckISpecifyPropertyPages(IUnknown *punk, bool fClassObject)
{
	ISpecifyPropertyPages *pispp;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"ISpecifyPropertyPages", IID_PPV_ARGS(&pispp));

	if (FAILED(hr))
	{
		return(0);
	}

	CAUUID cauuid;

	hr = pispp->GetPages(&cauuid);

	if (FAILED(hr))
	{
		ReportFailure(0x1D01, false, pispp, 3, L"ISpecifyPropertyPages::GetPages failed.  hr = %08X", hr);
	}

	else
	{
		if (cauuid.cElems == 0)
		{
			ReportFailure(0x1D02, false, pispp, 3, L"ISpecifyPropertyPages::GetPages returned cElems == 0");
		}

		for (ULONG ielem = 0; ielem < cauuid.cElems; ielem++)
		{
			CLSID clsidPage = cauuid.pElems[ielem];

			IUnknown *punkPage = (IUnknown *) (intptr_t) -1;

			HRESULT hr = CoGetClassObject(clsidPage,
				CLSCTX_INPROC_SERVER,
				NULL,
				IID_PPV_ARGS(&punkPage));

			if (FAILED(hr))
			{
				wchar_t szClsidPage[39];

				if (StringFromGUID2(clsidPage, szClsidPage, _countof(szClsidPage)) == 0)
				{
					szClsidPage[0] = L'\0';
				}

				if (hr == REGDB_E_CLASSNOTREG)
				{
					ReportFailure(0x1D03, false, pispp, 3, L"ISpecifyPropertyPages::GetPages CLSID[%u] %s not registered", ielem, szClsidPage);
				}

				else
				{
					ReportFailure(0x1D04, false, pispp, 3, L"CoGetClassObject(%s) from ISpecifyPropertyPages::GetPages failed.  hr = %08X", szClsidPage, hr);
				}
			}

			else
			{
				// We reset the unhandled exception filter because the CRT screws with it

				SetMyUnhandledExceptionFilter(true);

				punkPage->Release();
			}
		}

		CoTaskMemFree(cauuid.pElems);
	}

	Release(pispp, fClassObject);

	return(0);
}


int TestInnerInterface(COuter *pouter, const void *pv, int ifn, const wchar_t *szMethod, IUnknown *punk, ULONG crefExpected)
{
	if (punk == pouter)
	{
		ReportFailure(0x1E01, false, pv, ifn, L"%s(%s) returned punkOuter", szMethod, szClsid);

		return(0x1E01);
	}

	if (pouter->m_cref != crefExpected)
	{
		ReportFailure(0x1E02, false, pv, ifn, L"%s(%s) changed ref count of punkOuter (%u)", szMethod, szClsid, pouter->m_cref);
	}

	// Check that AddRef and Release do not delegate to outer object

	ULONG crefSave = pouter->m_cref;

	punk->AddRef();

	dwNonClass++;

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E03, false, punk, 1, L"AddRef changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	crefSave = pouter->m_cref;

	Release(punk, false);

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E04, false, punk, 2, L"Release changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	// Check that QI(IUnknown) does not delegate to outer object

	crefSave = pouter->m_cref;

	IUnknown *punk2;

	HRESULT hr = HrQueryInterface(punk, false, L"IUnknown", IID_PPV_ARGS(&punk2));

	if (FAILED(hr))
	{
		ReportFailure(0x1E05, false, punk, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x1E05);
	}

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E06, false, punk, 0, L"QueryInterface(IUnknown) changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	if (punk != punk2)
	{
		ReportFailure(0x1E07, false, punk, 0, L"QueryInterface(IUnknown) does not match original IUnknown");

		return(0x1E07);
	}

	crefSave = pouter->m_cref;

	IUnknown *punk3;

	hr = HrQueryInterface(punk2, false, L"IUnknown", IID_PPV_ARGS(&punk3));

	if (FAILED(hr))
	{
		ReportFailure(0x1E08, false, punk2, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x1808);
	}

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E09, false, punk2, 0, L"QueryInterface(IUnknown) changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	if (punk2 != punk3)
	{
		ReportFailure(0x1E0A, false, punk2, 0, L"QueryInterface(IUnknown) does not match original IUnknown");

		return(0x1E0A);
	}

	crefSave = pouter->m_cref;

	Release(punk3, false);

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E0B, false, punk3, 2, L"Release changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	crefSave = pouter->m_cref;

	Release(punk2, false);

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E0C, false, punk2, 2, L"Release changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	return(0);
}


int TestInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject)
{
	FreeUnusedLibraries();

	if (punk == NULL)
	{
		return(0);
	}

	IUnknown *punk2;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IUnknown", IID_PPV_ARGS(&punk2));

	if (FAILED(hr))
	{
		ReportFailure(0x1F01, false, punk, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x0101);
	}

	if (fIsIUnknown && (punk != punk2))
	{
		ReportFailure(0x1F02, false, punk, 0, L"QueryInterface(IUnknown) does not match original IUnknown");
	}

	if (!Interface::FPush(punk2, fClassObject))
	{
		Release(punk2, fClassObject);

		return(0);
	}

	ULONG cref1 = punk->AddRef();

	IncrementObjectCount(fClassObject);

	ULONG cref2 = punk->AddRef();

	IncrementObjectCount(fClassObject);

	if (cref2 != (cref1 + 1))
	{
		// If this is a proxy with a CLSID from the following list it is implemented
		// by a singleton in OLEAUT32.DLL.  Don't warn if we know this to be the case

		//    CLSID_PSDispatch
		//    CLSID_PSTypeInfo
		//    CLSID_PSTypeLib
		//    CLSID_PSTypeComp
		//    CLSID_PSAutomation
		//    CLSID_PSEnumVARIANT
		//    CLSID_PSSupportErrorInfo

		ReportFailure(0x1F03, false, punk, 1, L"AddRef doesn't increment reference count by one (%u -> %u)", cref1, cref2);
	}

	Release(punk, fClassObject);
	Release(punk, fClassObject);

	IUnknown *punk3;

	hr = HrQueryInterface(punk2, fClassObject, L"IUnknown", IID_PPV_ARGS(&punk3));

	if (FAILED(hr))
	{
		ReportFailure(0x1F04, false, punk2, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x1F04);
	}

	if (punk2 != punk3)
	{
		ReportFailure(0x1F05, false, punk2, 0, L"QueryInterface(IUnknown) does not match original IUnknown");

		return(0x1F05);
	}

	Release(punk3, fClassObject);

	IUnknown *punkUndefined;

	hr = HrQueryInterface(punk, fClassObject, L"iidUndefined", iidUndefined, (void **) &punkUndefined);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1F06, false, punk, 0, L"QueryInterface(iidUndefined) succeeded");
	}

	if (fTryQI)
	{
		if (fAllIids)
		{
			QueryInterfaceAllIids(punk, fClassObject);
		}

		if (fIidsFromFile)
		{
			QueryInterfaceIidsFromFile(punk, fClassObject, szIid + 1);
		}
	}

	int rc;

	if (!fCreateOnly && !fCheckSafety)
	{
		if (fObjrefMoniker)
		{
			rc = CheckObjrefMoniker(punk, fClassObject);

			SetMyUnhandledExceptionFilter(true);

			if (rc != 0)
			{
				return(rc);
			}
		}

		rc = CheckIConnectionPointContainer(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIDispatchEx(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc == -1)
		{
			rc = CheckIDispatch(punk, fClassObject);
		}

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumConnectionPoints(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumConnections(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumMoniker(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumUnknown(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumVARIANT(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIMoniker(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!fCreateOnly)
	{
		rc = CheckIObjectSafety(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!fCreateOnly && !fCheckSafety)
	{
		rc = CheckIOleCommandTarget(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIOleControl(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersist(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistHistory(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistPropertyBag(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistStream(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistStreamInit(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIProvideMultipleClassInfo(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc == -1)
		{
			rc = CheckIProvideClassInfo2(punk, fClassObject);
		}

		SetMyUnhandledExceptionFilter(true);

		if (rc == -1)
		{
			rc = CheckIProvideClassInfo(punk, fClassObject);
		}

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckISpecifyPropertyPages(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	Interface::PopAndRelease();

	return(0);
}


int TestAndReleaseInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject, bool fCheckRefCount)
{
	int rc = TestInterface(punk, pclsid, fIsIUnknown, fClassObject);

	if (punk != NULL)
	{
		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(punk, 2);

		ULONG cref = Release(punk, fClassObject);

		if ((cref != 0) && fCheckRefCount)
		{
			ReportFailure(0x2001, false, pvRelease, -1, L"IUnknown::Release returned %u", cref);
		}
	}

	return(rc);
}

int CheckErrorInfo()
{
	IErrorInfo *piei = (IErrorInfo *) (intptr_t) -1;

	HRESULT hr = GetErrorInfo(0, &piei);

	if (FAILED(hr))
	{
		// UNDONE: Better error.	This should not fail.

		return(0xFFFF);
	}

	if (hr == S_FALSE)
	{
		return(0);
	}

	if (piei == NULL)
	{
		// UNDONE: Better error.	This should never be NULL.

		return(0xFFFF);
	}

	dwNonClass++;

	return(TestAndReleaseInterface(piei, NULL, false, false, true));
}

void PumpMessages()
{
	MSG msg;

	while (PeekMessage(&msg, NULL,  0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);

		// wprintf(L"** Dispatching message %X\n", msg.message);

		DispatchMessage(&msg);
	}
}

int AddObjectToDocument(IHTMLDocument2 *pihd2, IHTMLElement *piheObject)
{
	PumpMessages();		       // Pump in case MSHTML has something queued

	// Get the BODY element so that we can insert an OBJECT element as a child

	IHTMLElement *piheBody = (IHTMLElement *) (intptr_t) -1;

	HRESULT hr = pihd2->get_body(&piheBody);

	if (FAILED(hr))
	{
		ReportFailure(0x2101, false, NULL, 0, L"IHTMLDocument2::get_body failed.  hr = %08X", hr);

		return(0x2101);
	}

	if (piheBody == NULL)
	{
		ReportFailure(0x2102, false, NULL, 0, L"IHTMLDocument2::get_body returned NULL");

		return(0x2102);
	}

	dwNonClass++;

	int rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	IHTMLDOMNode *pihdnBody;

	hr = HrQueryInterface(piheBody, false, L"IHTMLDOMNode", IID_PPV_ARGS(&pihdnBody));

	if (FAILED(hr))
	{
		ReportFailure(0x2103, false, piheBody, 0, L"IHTMLElement::QueryInterface(IHTMLDOMNode) failed.  hr = %08X", hr);

		return(0x2103);
	}

	Release(piheBody, false);

	IHTMLDOMNode *pihdnObject;

	hr = HrQueryInterface(piheObject, false, L"IHTMLDOMNode", IID_PPV_ARGS(&pihdnObject));

	if (FAILED(hr))
	{
		ReportFailure(0x2104, false, piheObject, 0, L"IHTMLElement::QueryInterface(IHTMLDOMNode) failed.  hr = %08X", hr);

		return(0x2104);
	}

	// Append new OBJECT element as child of BODY element

	IHTMLDOMNode *pihdnObject2 = (IHTMLDOMNode *) (intptr_t) -1;

	hr = pihdnBody->appendChild(pihdnObject, &pihdnObject2);

	if (FAILED(hr))
	{
		ReportFailure(0x2105, false, pihdnBody, 19, L"IHTMLDOMNode::appendChild failed.  hr = %08X", hr);

		return(0x2105);
	}

	if (pihdnObject2 == NULL)
	{
		ReportFailure(0x2106, false, pihdnBody, 19, L"IHTMLDOMNode::appendChild returned NULL");

		return(0x2106);
	}

	dwNonClass++;

	Release(pihdnObject, false);

	Release(pihdnObject2, false);

	Release(pihdnBody, false);

	PumpMessages();		       // Pump in case MSHTML has something queued


	return(0);
}


int CreateObjectInDocument(IHTMLDocument2 *pihd2, const wchar_t *szClassid, const CLSID *pclsid)
{
	for (unsigned i = 0; i < 10; i++)
	{
		PumpMessages();		       // Pump in case MSHTML has something queued

		BSTR bstrReadyState = NULL;

		HRESULT hr = pihd2->get_readyState(&bstrReadyState);

		if (FAILED(hr))
		{
			ReportFailure(0x2201, false, pihd2, 22, L"IHTMLDocument2::get_readyState failed.  hr = %08X", hr);
		}

		else if (bstrReadyState == NULL)
		{
			ReportFailure(0x2202, false, pihd2, 22, L"IHTMLDocument2::get_readyState returned NULL");
		}

		else
		{
			bool fComplete = _wcsicmp(bstrReadyState, L"complete") == 0;

#if 0
		if (!fComplete && (i == 9))
		{
			ReportFailure(0x220F, false, pihd2, 22, L"IHTMLDocument2::get_readyState returned \"%s\"", bstrReadyState);
		}
#endif

			SysFreeString(bstrReadyState);

			if (fComplete)
			{
				break;
			}
		}

		Sleep(100);
	}

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	int rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	// Create an OBJECT element

	BSTR bstrObject = SysAllocString(L"object");

	if (bstrObject == NULL)
	{
		ReportFailure(0x2203, false, NULL, 0, L"SysAllocString(\"object\") failed");

		return(0x2203);
	}

	IHTMLElement *piheObject = (IHTMLElement *) (intptr_t) -1;

	HRESULT hr = pihd2->createElement(bstrObject, &piheObject);

	if (FAILED(hr))
	{
		ReportFailure(0x2204, false, pihd2, 72, L"IHTMLDocument2::createElement failed.  hr = %08X", hr);

		return(0x2204);
	}

	if (piheObject == NULL)
	{
		ReportFailure(0x2205, false, pihd2, 72, L"IHTMLDocument2::createElement returned NULL");

		return(0x2205);
	}

	dwNonClass++;

	rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	SysFreeString(bstrObject);

	if (atd == atdBefore)
	{
		int rc = AddObjectToDocument(pihd2, piheObject);

		if (rc != 0)
		{
			return(rc);
		}
		rc = CheckErrorInfo();

		if (rc != 0)
		{
			return(rc);
		}
	}

	// At this point we have the IHTMLDocument2 *pihd2 and IHTMLElement *piheObject

	IHTMLObjectElement2 *pihoe2Object;

	hr = HrQueryInterface(piheObject, false, L"IHTMLObjectElement2", IID_PPV_ARGS(&pihoe2Object));

	if (FAILED(hr))
	{
		ReportFailure(0x2206, false, piheObject, 0, L"IHTMLElement::QueryInterface(IHTMLObjectElement2) failed.  hr = %08X", hr);

		return(0x2206);
	}

	if (szData != NULL)
	{
		// UNDONE: Use FormatMessage to compose data URL

		BSTR bstrData = SysAllocString(szData);

		if (bstrData == NULL)
		{
			ReportFailure(0x2207, false, NULL, 0, L"SysAllocString(\"%s\") failed", szData);
		}

		else
		{
			hr = pihoe2Object->put_data(bstrData);

			if (FAILED(hr))
			{
				ReportFailure(0x2208, false, pihoe2Object, 10, L"IHTMLObjectElement2::put_data failed.  hr = %08X", hr);
			}

			rc = CheckErrorInfo();

			if (rc != 0)
			{
				return(rc);
			}

			SysFreeString(bstrData);
		}
	}

	if (szClassid != NULL)
	{
		// UNDONE: Use FormatMessage to compose classid moniker

		BSTR bstrClassid = SysAllocString(szClassid);

		if (bstrClassid == NULL)
		{
			ReportFailure(0x2209, false, NULL, 0, L"SysAllocString(\"%s\") failed", szClassid);
		}

		else
		{
			hr = pihoe2Object->put_classid(bstrClassid);

			// Don't report access denied.  It's good when that happens.

			if (FAILED(hr) && (hr != E_ACCESSDENIED))
			{
				ReportFailure(0x220A, false, pihoe2Object, 8, L"IHTMLObjectElement2::put_classid failed.  hr = %08X", hr);
			}

			rc = CheckErrorInfo();

			if (rc != 0)
			{
				return(rc);
			}

			SysFreeString(bstrClassid);
		}
	}

	Release(pihoe2Object, false);

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	PumpMessages();		       // Pump in case MSHTML has something queued

	// Wait for the OBJECT element to be ready

	IHTMLObjectElement *pihoeObject;

	hr = HrQueryInterface(piheObject, false, L"IHTMLObjectElement", IID_PPV_ARGS(&pihoeObject));

	if (FAILED(hr))
	{
		ReportFailure(0x220B, false, piheObject, 0, L"IHTMLElement::QueryInterface(IHTMLObjectElement) failed.  hr = %08X", hr);
	}

	else
	{
		for (unsigned i = 0; i < 10; i++)
		{
			long lReadyState;

			hr = pihoeObject->get_readyState(&lReadyState);

			if (FAILED(hr))
			{
				ReportFailure(0x220C, false, pihoeObject, 30, L"IHTMLObjectElement::get_readyState failed.  hr = %08X", hr);
			}

			else if (lReadyState == READYSTATE_COMPLETE)
			{
				break;
			}

			if (i == 9)
			{
				ReportFailure(0x2210, false, pihoeObject, 30, L"IHTMLObjectElement::get_readyState returned %d", lReadyState);
			}

			Sleep(100);

			PumpMessages();	       // Pump in case MSHTML has something queued
		}

		// We reset the unhandled exception filter because the CRT screws with it

		SetMyUnhandledExceptionFilter(true);
	}

	rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	if (atd == atdAfter)
	{
		int rc = AddObjectToDocument(pihd2, piheObject);

		if (rc != 0)
		{
			return(rc);
		}
	}

	PumpMessages();		       // Pump in case MSHTML has something queued


	// If we can get to the COM class while hosted with HTML do so

	if (pihoeObject != NULL)
	{
		IDispatch *pid = (IDispatch *) (intptr_t) -1;

		hr = pihoeObject->get_object(&pid);

		if (FAILED(hr))
		{
			if (hr != E_ACCESSDENIED)
			{
				ReportFailure(0x220D, false, pihoeObject, 7, L"IHTMLObjectElement::get_object failed.  hr = %08X", hr);

#if 0
				int rc = CheckIDispatchEx(pihoeObject, false);

				if (rc == -1)
				{
					rc = CheckIDispatch(pihoeObject, false);
				}

				if (rc != 0)
				{
					return(rc);
				}
#elif 0
				int rc = TestInterface(pihoeObject, pclsid, false, false);

				if (rc != 0)
				{
					return(rc);
				}
#endif
			}
		}

		else if (pid == NULL)
		{
#if 0
			ReportFailure(0x220E, false, pihoeObject, 7, L"IHTMLObjectElement::get_object returned NULL");
#endif
		}

		else
		{
			dwNonClass++;

			rc = CheckErrorInfo();

			if (rc != 0)
			{
				return(rc);
			}

			rc = TestAndReleaseInterface(pid, pclsid, false, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		Release(pihoeObject, false);
	}

	Release(piheObject, false);

	return(0);
}


int DoHTML(const wchar_t *szClassid, const CLSID *pclsid)
{
	// UNDONE: Use FormatMessage to compose URL

	const wchar_t *szUrlToLoad = (szUrl != NULL) ? szUrl : L"about:blank";

	IHTMLDocument2 *pihd2;

	HRESULT hr = CoCreateInstance(CLSID_HTMLDocument, NULL, dwClsctx, IID_PPV_ARGS(&pihd2));

	if (FAILED(hr))
	{
		ReportFailure(0x2301, false, NULL, 0, L"CoCreateInstance(CLSID_HTMLDocument) failed.  hr = %08X", hr);

		return(0x2301);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	CSite cs;

	int rc = SetSiteAlways(pihd2, &cs);

	bool fSiteSet = (rc == 0);

	IPersistMoniker *pipm;

	hr = HrQueryInterface(pihd2, false, L"IPersistMoniker", IID_PPV_ARGS(&pipm));

	if (FAILED(hr))
	{
		ReportFailure(0x2302, false, pihd2, 0, L"IHTMLDocument2::QueryInterface(IPersistMoniker) failed.  hr = %08X", hr);

		return(0x2302);
	}

	IMoniker *pmk;

	hr = CreateURLMonikerEx(NULL, szUrlToLoad, &pmk, URL_MK_UNIFORM);

	if (FAILED(hr))
	{
		ReportFailure(0x2303, false, NULL, 0, L"CreateURLMonikerEx failed.  hr = %08X", hr);

		return(0x2303);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	hr = pipm->Load(TRUE, pmk, NULL, STGM_READ);

	if (FAILED(hr))
	{
		ReportFailure(0x2304, false, pipm, 5, L"IPersistMoniker::Load failed.  hr = %08X", hr);

		return(0x2304);
	}

	Release(pipm, false);

	Release(pmk, false);

	// There should be a WM_METHODCALL message queued up.  Pump messages or else the
	// load will not complete.  With -mta the COM infrastructure will pump.

	rc = CreateObjectInDocument(pihd2, szClassid, pclsid);

	if (rc != 0)
	{
		return(rc);
	}

	PumpMessages();

	if (fSiteSet)
	{
		rc = SetSiteAlways(pihd2, NULL);
	}

	Release(pihd2, false);

	return(0);
}


int DoHTMLWebBrowser(const wchar_t *szClassid, const CLSID *pclsid)
{
	// UNDONE: Use FormatMessage to compose URL

	const wchar_t *szUrlToLoad = (szUrl != NULL) ? szUrl : L"about:blank";

	IWebBrowser2 *piwb2;

	HRESULT hr = CoCreateInstance(CLSID_WebBrowser, NULL, dwClsctx, IID_PPV_ARGS(&piwb2));

	if (FAILED(hr))
	{
		ReportFailure(0x2501, false, NULL, 0, L"CoCreateInstance(CLSID_WebBrowser) failed.  hr = %08X", hr);

		return(0x2501);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	CSite cs;

	int rc = SetSiteAlways(piwb2, &cs);

	bool fSiteSet = (rc == 0);

	BSTR bstrUrl = SysAllocString(szUrlToLoad);

	if (bstrUrl == NULL)
	{
		ReportFailure(0x2502, false, NULL, 0, L"SysAllocString(\"%s\") failed", szUrlToLoad);
	}

	else
	{
		VARIANT varFlags;
		VARIANT varTargetFrameName;
		VARIANT varPostData;
		VARIANT varHeaders;

		MyVariantInit(&varFlags);
		MyVariantInit(&varTargetFrameName);
		MyVariantInit(&varPostData);
		MyVariantInit(&varHeaders);

		hr = piwb2->Navigate(bstrUrl, &varFlags, &varTargetFrameName, &varPostData, &varHeaders);

		// We reset the unhandled exception filter because the CRT screws with it

		SetMyUnhandledExceptionFilter(true);

		if (FAILED(hr))
		{
			ReportFailure(0x2503, false, piwb2, 11, L"IWebBrowser2::Navigate failed.  hr = %08X", hr);
		}

		else
		{
			for (unsigned i = 0; i < 10; i++)
			{
				PumpMessages();	       // Pump in case SHDOCVW or MSHTML has something queued

				READYSTATE readystate;

				hr = piwb2->get_ReadyState(&readystate);

				if (FAILED(hr))
				{
					ReportFailure(0x2507, false, piwb2, 56, L"IWebBrowser2::get_ReadyState failed.  hr = %08X", hr);
				}

				else if (readystate >= READYSTATE_INTERACTIVE)
				{
					break;
				}

				if (i == 9)
				{
					ReportFailure(0x2508, false, piwb2, 56, L"IWebBrowser2::get_ReadyState returned %d", readystate);
				}

				Sleep(100);
			}

			IDispatch *pidDocument = (IDispatch *) (intptr_t) -1;

			hr = piwb2->get_Document(&pidDocument);

			if (FAILED(hr))
			{
				ReportFailure(0x2504, false, piwb2, 18, L"IWebBrowser2::get_Document failed.  hr = %08X", hr);

				return(0x2504);
			}

			else if (hr == S_FALSE)
			{
				ReportFailure(0x2509, false, piwb2, 19, L"IWebBrowser2::get_Document returned S_FALSE");

				return(0x2509);
			}

			else if (pidDocument == NULL)
			{
				ReportFailure(0x2505, false, piwb2, 18, L"IWebBrowser2::get_Document returned NULL");

				return(0x2505);
			}

			else
			{
				dwNonClass++;

				IHTMLDocument2 *pihd2;

				hr = HrQueryInterface(pidDocument, false, L"IHTMLDocument2", IID_PPV_ARGS(&pihd2));

				Release(pidDocument, false);

				if (FAILED(hr))
				{
					ReportFailure(0x2506, false, piwb2, 0, L"IDispatch::QueryInterface(IHTMLDocument2) failed.  hr = %08X", hr);
				}

				else
				{
					rc = CreateObjectInDocument(pihd2, szClassid, pclsid);

					if (rc != 0)
					{
						return(rc);
					}

					Release(pihd2, false);
				}
			}
		}
	}

	if (fSiteSet)
	{
		rc = SetSiteAlways(piwb2, NULL);
	}

	Release(piwb2, false);

	return(0);
}


int DoMoniker(REFIID iid)
{
	DWORD_PTR rgarg[2] =
	{
		(DWORD_PTR) szClsid,
		(DWORD_PTR) szProgid,
	};

	wchar_t *sz;

	DWORD dw = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_STRING |
		FORMAT_MESSAGE_ARGUMENT_ARRAY,
		szMoniker,
		0,
		0,
		(LPWSTR) &sz,
		0,
		(va_list *) rgarg);

	if (dw == 0)
	{
		wprintf(L"FormatMessage failed.  GetLastError() = %u\n", GetLastError());
		return(1);
	}

	if (fHTML)
	{
		int iret = DoHTML(sz, NULL);

		LocalFree(sz);

		return(iret);
	}

	IBindCtx *pbc = NULL;

	HRESULT hr = CreateBindCtx(0, &pbc);

	if (FAILED(hr))
	{
		wprintf(L"CreateBindCtx failed.  hr = %08X\n", hr);
		return(1);
	}

	DWORD cchEaten;
	IMoniker *pmk = (IMoniker *) (intptr_t) -1;

	if (fUrlMoniker)
	{
		hr = MkParseDisplayNameEx(pbc, sz, &cchEaten, &pmk);

		if (FAILED(hr))
		{
			ReportFailure(0x2601, false, NULL, 0, L"MkParseDisplayNameEx(\"%s\") failed.  hr = %08X", sz, hr);

			pmk = NULL;

		}
	}

	else
	{
		hr = MkParseDisplayName(pbc, sz, &cchEaten, &pmk);

		if (FAILED(hr))
		{
			ReportFailure(0x2602, false, NULL, 0, L"MkParseDisplayName(\"%s\") failed.  hr = %08X", sz, hr);

			pmk = NULL;
		}
	}

	if (cchEaten != wcslen(sz))
	{
		ReportFailure(0x2603, false, NULL, 0, L"MkParseDisplayName[Ex](\"%s\") consumed only %u characters", sz, cchEaten);
	}

	LocalFree(sz);

	if (pmk != NULL)
	{
		dwNonClass++;

		int rc = TestAndReleaseInterface(pmk, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	// Capture address of Release() method since after release the memory may be gone

	const void *pvRelease = PvMethod(pbc, 2);

	ULONG cref = pbc->Release();

	if (cref != 0)
	{
		ReportFailure(0x2604, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
	}

	return(0);
}


int CheckIClassFactory(REFCLSID clsid, REFIID iid, IUnknown *punkClass)
{
	IClassFactory *pcf;

	HRESULT hr = HrQueryInterface(punkClass, true, L"IClassFactory", IID_PPV_ARGS(&pcf));

	if (FAILED(hr))
	{
		// Set this NULL so we can test for whether this worked later

		pcf = NULL;
	}

	else
	{
		hr = pcf->LockServer(TRUE);

		if (FAILED(hr))
		{
			ReportFailure(0x2701, false, pcf, 4, L"IClassFactory::LockServer(TRUE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked++;
		}

		FreeUnusedLibraries();
	}

	IClassFactory2 *pcf2;

	hr = HrQueryInterface(punkClass, true, L"IClassFactory2", IID_PPV_ARGS(&pcf2));

	BSTR bstrKey = NULL;

	if (FAILED(hr))
	{
		// Set this NULL so we can test for whether this worked later

		pcf2 = NULL;
	}

	else
	{
		if (pcf == NULL)
		{
			ReportFailure(0x2702, false, punkClass, 0, L"Class factory supports IClassFactory2 but not IClassFactory");
		}

		hr = pcf2->LockServer(TRUE);

		if (FAILED(hr))
		{
			ReportFailure(0x2703, false, pcf2, 4, L"IClassFactory2::LockServer(TRUE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked++;
		}

		FreeUnusedLibraries();

		LICINFO li;

		li.cbLicInfo = sizeof(li);
		li.fRuntimeKeyAvail = (BOOL) -1;
		li.fLicVerified = (BOOL) -1;

		hr = pcf2->GetLicInfo(&li);

		if (FAILED(hr))
		{
			ReportFailure(0x2704, false, pcf2, 5, L"IClassFactory2::GetLicInfo failed.  hr = %08X", hr);
		}

		else
		{
			if (li.cbLicInfo != sizeof(li))
			{
				ReportFailure(0x2705, false, pcf2, 5, L"IClassFactory2::LICINFO::cb = %u", li.cbLicInfo);
			}

			if ((li.fRuntimeKeyAvail != 0) && (li.fRuntimeKeyAvail != 1))
			{
				ReportFailure(0x2706, false, pcf2, 5, L"IClassFactory2::LICINFO::fRuntimeKeyAvail = %d", li.fRuntimeKeyAvail);
			}

			if ((li.fLicVerified != 0) && (li.fLicVerified != 1))
			{
				ReportFailure(0x2707, false, pcf2, 5, L"IClassFactory2::LICINFO::fLicVerified = %d", li.fLicVerified);
			}

			if (li.fRuntimeKeyAvail)
			{
				bstrKey = (BSTR) (intptr_t) -1;

				hr = pcf2->RequestLicKey(0, &bstrKey);

				if (FAILED(hr))
				{
					if (bstrKey != NULL)
					{
						ReportFailure(0x2708, false, pcf2, 6, L"IClassFactory2::RequestLicKey failure did not set *pbstrKey = NULL");

						bstrKey = NULL;
					}

					if (li.fRuntimeKeyAvail)
					{
						ReportFailure(0x2709, false, pcf2, 6, L"IClassFactory2::RequestLicKey failed.  hr = %08X", hr);
					}

					else if (hr != CLASS_E_NOTLICENSED)
					{
						ReportFailure(0x270A, false, pcf2, 6, L"IClassFactory2::RequestLicKey failure did not return CLASS_E_NOTLICENSED w/!fRuntimeKeyAvail.  hr = %08X", hr);
					}
				}
			}
		}
	}

	IClassFactory3 *pcf3;

	hr = HrQueryInterface(punkClass, true, L"IClassFactory3", IID_PPV_ARGS(&pcf3));

	if (FAILED(hr))
	{
		// Set this NULL so we can test for whether this worked later

		pcf3 = NULL;
	}

	else
	{
		if (pcf == NULL)
		{
			ReportFailure(0x270B, false, punkClass, 0, L"Class factory supports IClassFactory3 but not IClassFactory");
		}

		hr = pcf3->LockServer(TRUE);

		if (FAILED(hr))
		{
			ReportFailure(0x270C, false, pcf3, 4, L"IClassFactory3::LockServer(TRUE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked++;
		}

		FreeUnusedLibraries();
	}

	if ((pcf == NULL) && (pcf2 == NULL) && (pcf3 == NULL))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	// Create an instance of this class

	const void *pv;
	int ifn;
	const wchar_t *szMethod;

	COuter *pouter = NULL;

	if (fAggregate)
	{
		pouter = new COuter;
	}

	IUnknown *punk = (IUnknown *) (intptr_t) -1;

	if (pcf3 != NULL)
	{
		pv = pcf3;
		ifn = 5;

		szMethod = L"IClassFactory3::CreateInstanceWithContext";

		// UNDONE: Provide meaningful context

		hr = pcf3->CreateInstanceWithContext(NULL,
			pouter,
			iid,
			(void **) &punk);
	}

	else if (pcf2 != NULL)
	{
		pv = pcf2;
		ifn = 7;

		szMethod = L"IClassFactory2::CreateInstanceLic";

		hr = pcf2->CreateInstanceLic(pouter,
			NULL,
			iid,
			bstrKey,
			(void **) &punk);
	}

	else
	{
		pv = pcf;
		ifn = 3;

		szMethod = L"IClassFactory::CreateInstance";

		hr = pcf->CreateInstance(pouter,
			iid,
			(void **) &punk);
	}

	if (FAILED(hr))
	{
		if (!fAggregate || (hr != CLASS_E_NOAGGREGATION))
		{
			ReportFailure(0x270D, false, pv, ifn, L"%s(%s) failed.  hr = %08X", szMethod, SzIidDisplay(), hr);
		}

		if (punk != NULL)
		{
			ReportFailure(0x270E, false, pv, ifn, L"%s(%s) failure did not set *ppvObject = NULL", szMethod, SzIidDisplay());

			punk = NULL;
		}
	}

	else if (punk == NULL)
	{
		ReportFailure(0x270F, false, pv, ifn, L"%s(%s) succeeded but *ppvObject == NULL", szMethod, SzIidDisplay());

		return(0x270F);
	}

	else
	{
		dwNonClass++;
	}

	if (pcf3 != NULL)
	{
		FreeUnusedLibraries();

		hr = pcf3->LockServer(FALSE);

		if (FAILED(hr))
		{
			ReportFailure(0x2710, false, pcf3, 4, L"IClassFactory3::LockServer(FALSE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked--;
		}

		// Do not free unused libraries here because class factories do not need to
		// affect DllCanUnloadNow.

		Release(pcf3, true);
	}

	if (pcf2 != NULL)
	{
		FreeUnusedLibraries();

		hr = pcf2->LockServer(FALSE);

		if (FAILED(hr))
		{
			ReportFailure(0x2711, false, pcf2, 4, L"IClassFactory2::LockServer(FALSE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked--;
		}

		// Do not free unused libraries here because class factories do not need to
		// affect DllCanUnloadNow.

		Release(pcf2, true);
	}

	if (pcf != NULL)
	{
		FreeUnusedLibraries();

		hr = pcf->LockServer(FALSE);

		if (FAILED(hr))
		{
			ReportFailure(0x2712, false, pcf, 4, L"IClassFactory::LockServer(FALSE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked--;
		}

		// Do not free unused libraries here because class factories do not need to
		// affect DllCanUnloadNow.

		Release(pcf, true);
	}

	// The class object is no longer locked

	szQualifier = NULL;

	if (punk == NULL)
	{
		if (fAggregate)
		{
			pouter->Release();
		}

		return(0);
	}

	if (fAggregate)
	{
		pouter->m_punkInner = punk;

		int rc = TestInnerInterface(pouter, pv, ifn, szMethod, punk, 1);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!FTestClass(punk, clsid))
	{
		// We don't want to test this class

		ReportFailure(0x2713, false, NULL, 0, L"Skipped");

		Release(fAggregate ? pouter : punk, false);

		return(0);
	}

	if (fCreateOnly || fSDL)
	{
		ReportFailure(0x2714, fCreateOnly || fSDL, pv, ifn, L"%s(%s) succeeded", szMethod, SzIidDisplay());
	}

	return(TestAndReleaseInterface(fAggregate ? pouter : punk, &clsid, fAggregate || IsEqualGUID(iid, IID_IUnknown), false, true));
}


int CheckIParseDisplayName(REFCLSID clsid, REFIID iid, IUnknown *punkClass)
{
	IParseDisplayName *ppdn;

	HRESULT hr = HrQueryInterface(punkClass, true, L"IParseDisplayName", IID_PPV_ARGS(&ppdn));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IBindCtx *pbc = NULL;

	hr = CreateBindCtx(0, &pbc);

	if (FAILED(hr))
	{
		wprintf(L"CreateBindCtx failed.  hr = %08X", hr);
		return(1);
	}

	ULONG cchEaten;
	IMoniker *pmk = (IMoniker *) (intptr_t) -1;

	// UNDONE: Better moniker string

	hr = ppdn->ParseDisplayName(pbc, L"moniker:xyzzy", &cchEaten, &pmk);

	if (FAILED(hr))
	{
		ReportFailure(0x2801, false, ppdn, 3, L"IParseDisplayName::ParseDisplayName failed.  hr = %08X", hr);

		if (pmk != NULL)
		{
			ReportFailure(0x2802, false, ppdn, 3, L"IParseDisplayName::ParseDisplayName failure did not set *ppmk = NULL");
		}
	}

	else
	{
		dwNonClass++;

		if (fCreateOnly)
		{
			ReportFailure(0x2803, fCreateOnly, ppdn, 3, L"IParseDisplayName::ParseDisplayName succeeded.");
		}

		szQualifier = L" (Moniker)";

		int rc = TestAndReleaseInterface(pmk, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	// Capture address of Release() method since after release the memory may be gone

	const void *pvRelease = PvMethod(pbc, 2);

	ULONG cref = pbc->Release();

	if (cref != 0)
	{
		ReportFailure(0x2804, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
	}

	Release(ppdn, true);

	return(0);
}


int CheckIPSFactoryBuffer(REFCLSID clsid, REFIID iid, IUnknown *punkClass)
{
	IPSFactoryBuffer *ppsfb;

	HRESULT hr = HrQueryInterface(punkClass, true, L"IPSFactoryBuffer", IID_PPV_ARGS(&ppsfb));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	COuter *pouter = NULL;

	if (fAggregate)
	{
		pouter = new COuter;
	}

	IRpcProxyBuffer *prpb = (IRpcProxyBuffer *) (intptr_t) -1;
	IUnknown *punk = (IUnknown *) (intptr_t) -1;

	hr = ppsfb->CreateProxy(pouter,
		iid,
		&prpb,
		(void **) &punk);

	if (FAILED(hr))
	{
		// Don't display an error if this is an unsupported interface and -useps not specified

		if ((hr != E_NOINTERFACE) || fUsePS)
		{
			ReportFailure(0x2901, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy failed.  hr = %08X", hr);
		}

		if (prpb != NULL)
		{
			ReportFailure(0x2902, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy failure did not set *ppProxy = NULL");
		}

		if (punk != NULL)
		{
			ReportFailure(0x2903, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy failure did not set *ppvObject = NULL");
		}
	}

	else
	{
		if (fCreateOnly)
		{
			ReportFailure(0x2904, fCreateOnly, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy succeeded.  CLSID = %s", szClsid);
		}

		if (prpb == NULL)
		{
			ReportFailure(0x2905, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy succeeded but *ppProxy == NULL");

			if (fAggregate)
			{
				pouter->Release();

				pouter = NULL;
			}
		}

		else
		{
			dwNonClass++;

			if (fAggregate)
			{
				pouter->m_punkInner = prpb;

				int rc = TestInnerInterface(pouter, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy", prpb, (punk == NULL) ? 1 : 2);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		if (punk == NULL)
		{
			// If this is a proxy with a CLSID from the following list it is implemented
			// by OLEAUT32.DLL which doesn't return a proxy up front

			//    CLSID_PSDispatch
			//    CLSID_PSTypeInfo
			//    CLSID_PSTypeLib
			//    CLSID_PSTypeComp
			//    CLSID_PSAutomation
			//    CLSID_PSEnumVARIANT
			//    CLSID_PSSupportErrorInfo

#if 0
			ReportFailure(0x2906, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy succeeded but *ppv == NULL");
#endif
		}

		else
		{
			dwNonClass++;

			szQualifier = L" (Proxy)";

			int rc = TestAndReleaseInterface(punk, NULL, IsEqualGUID(iid, IID_IUnknown), false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		szQualifier = L" (ProxyBuffer)";

		int rc = TestAndReleaseInterface(fAggregate ? pouter : (IUnknown *) prpb, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	// UNDONE: Test IPSFactoryBuffer::CreateStub

	Release(ppsfb, true);

	return(0);
}


int DoCoGetClass(REFCLSID clsid, REFIID iid)
{
	IUnknown *punkClass = (IUnknown *) (intptr_t) -1;

	HRESULT hr = CoGetClassObject(clsid,
		dwClsctx,
		NULL,
		IID_PPV_ARGS(&punkClass));

	if (hr == REGDB_E_CLASSNOTREG)
	{
		// It is possible to receive REGDB_E_CLASSNOTREG even when a CLSID is registered.  This may happen
		// when the supplied CLSCTX allows multiple mechanisms (e.g. InprocServer32 and LocalServer32), the
		// class fails DllGetClassObject, and COM continue on to try another mechanism for which there
		// is no registration.  COM should return the last real HRESULT but does not for compatibilty.
		// See CProcessActivator::ActivateByContext in nt\com\ole32\com\objact\actvator.cxx

		if ((dwClsctx & CLSCTX_INPROC_SERVER) != 0)
		{
			hr = CoGetClassObject(clsid,
				dwClsctx & CLSCTX_INPROC_SERVER,
				NULL,
				IID_PPV_ARGS(&punkClass));

			if (SUCCEEDED(hr))
			{
				// UNDONE: Something screwed up
			}
		}
		if (hr == REGDB_E_CLASSNOTREG)
		{
			if ((dwClsctx & CLSCTX_INPROC_HANDLER) != 0)
			{
				hr = CoGetClassObject(clsid,
					dwClsctx & CLSCTX_INPROC_HANDLER,
					NULL,
					IID_PPV_ARGS(&punkClass));

				if (SUCCEEDED(hr))
				{
					// UNDONE: Something screwed up
				}
			}

			if (hr == REGDB_E_CLASSNOTREG)
			{
				if ((dwClsctx & CLSCTX_LOCAL_SERVER) != 0)
				{
					hr = CoGetClassObject(clsid,
						dwClsctx & CLSCTX_LOCAL_SERVER,
						NULL,
						IID_PPV_ARGS(&punkClass));

					if (SUCCEEDED(hr))
					{
						// UNDONE: Something screwed up
					}
				}
			}
		}
	}
	if (FAILED(hr))
	{
		ReportFailure(0x2A01, false, NULL, 0, L"CoGetClassObject(IUnknown) failed.  hr = %08X", hr);

		// Note that we return 0 not 1

		return(0);
	}

	dwClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	// Do not free unused libraries here because class objects do not need to
	// affect DllCanUnloadNow.

	// Test the class object.

	szQualifier = L" (CO)";

	int rc = TestInterface(punkClass, NULL, true, true);

	if (rc != 0)
	{
		return(rc);
	}

	if (!Interface::FPush(punkClass, true))
	{
		// This is not possible

		DebugBreak();
	}

	szQualifier = L" (CO)";

	bool fIClassFactorySupported = true;

	rc = CheckIClassFactory(clsid, iid, punkClass);

	if (rc == -1)
	{
		fIClassFactorySupported = false;
	}

	else if (rc != 0)
	{

		return(rc);
	}

	szQualifier = L" (CO)";

	bool fIParseDisplayNameSupported = true;

	rc = CheckIParseDisplayName(clsid, iid, punkClass);

	if (rc == -1)
	{
		fIParseDisplayNameSupported = false;
	}

	else if (rc != 0)
	{
		return(rc);
	}

	szQualifier = L" (CO)";

	bool fIPSFactoryBufferSupported = true;

	rc = CheckIPSFactoryBuffer(clsid, iid, punkClass);

	if (rc == -1)
	{
		fIPSFactoryBufferSupported = false;
	}

	else if (rc != 0)
	{
		return(rc);
	}

	szQualifier = L" (CO)";

	if (!fIClassFactorySupported && !fIParseDisplayNameSupported && !fIPSFactoryBufferSupported)
	{
		ReportFailure(0x2A02, false, punkClass, 0, L"Neither IClassFactory*, IParseDisplayName, nor IPSFactoryBuffer supported");
	}

#if 0
	// Capture address of Release() method since after release the memory may be gone

	const void *pvRelease = PvMethod(punkClass, 2);
#endif

	ULONG cref = Interface::PopAndRelease();

#if 0
	// Don't check.  AtlComModuleGetClassObject or similar caches class objects

	if (cref != 0)
	{
		ReportFailure(0x2A03, false, pvRelease, -1, L"IUnknown::Release returned %u", cref);
	}
#endif

	return(0);
}


int DoCoCreate(REFCLSID clsid, REFIID iid)
{
	COuter *pouter = NULL;

	if (fAggregate)
	{
		pouter = new COuter;
	}

	IUnknown *punk = (IUnknown *) (intptr_t) -1;

	HRESULT hr = CoCreateInstance(clsid,
		pouter,
		dwClsctx,
		iid,
		(void **) &punk);

	if (hr == REGDB_E_CLASSNOTREG)
	{
		// It is possible to receive REGDB_E_CLASSNOTREG even when a CLSID is registered.  This may happen
		// when the supplied CLSCTX allows multiple mechanisms (e.g. InprocServer32 and LocalServer32), the
		// class fails DllGetClassObject, and COM continue on to try another mechanism for which there
		// is no registration.  COM should return the last real HRESULT but does not for compatibilty.
		// See CProcessActivator::ActivateByContext in nt\com\ole32\com\objact\actvator.cxx

		if ((dwClsctx & CLSCTX_INPROC_SERVER) != 0)
		{
			hr = CoCreateInstance(clsid,
				pouter,
				dwClsctx & CLSCTX_INPROC_SERVER,
				iid,
				(void **) &punk);

			if (SUCCEEDED(hr))
			{
				// UNDONE: Something screwed up
			}
		}

		if (hr == REGDB_E_CLASSNOTREG)
		{
			if ((dwClsctx & CLSCTX_INPROC_HANDLER) != 0)
			{
				hr = CoCreateInstance(clsid,
					pouter,
					dwClsctx & CLSCTX_INPROC_HANDLER,
					iid,
					(void **) &punk);

				if (SUCCEEDED(hr))
				{
					// UNDONE: Something screwed up
				}
			}

			if (hr == REGDB_E_CLASSNOTREG)
			{
				if ((dwClsctx & CLSCTX_LOCAL_SERVER) != 0)
				{
					hr = CoCreateInstance(clsid,
						pouter,
						dwClsctx & CLSCTX_LOCAL_SERVER,
						iid,
						(void **) &punk);

					if (SUCCEEDED(hr))
					{
						// UNDONE: Something screwed up
					}
				}
			}
		}
	}


	if (FAILED(hr))
	{
		if (!fAggregate || (hr != CLASS_E_NOAGGREGATION))
		{
			ReportFailure(0x2B01, false, NULL, 0, L"CoCreateInstance(%s, %s) failed.  hr = %08X", szClsid, SzIidDisplay(), hr);
		}

		if (punk != NULL)
		{
			ReportFailure(0x2B02, false, NULL, 0, L"CoCreateInstance(%s, %s) failure did not set *ppvObject = NULL", szClsid, SzIidDisplay());
		}

		// Note that we return 0 not 1

		return(0);
	}

	if (punk == NULL)
	{
		ReportFailure(0x2B03, false, NULL, 0, L"CoCreateInstance(%s, %s) succeeded but *ppvObject == NULL", szClsid, SzIidDisplay());

		return(0x2B03);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	if (fAggregate)
	{
		pouter->m_punkInner = punk;

		int rc = TestInnerInterface(pouter, NULL, 0, L"CoCreateInstance", punk, 1);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!FTestClass(punk, clsid))
	{
		// We don't want to test this class

		ReportFailure(0x2B04, false, NULL, 0, L"Skipped");

		Release(fAggregate ? pouter : punk, false);

		return(0);
	}

	if (fCreateOnly || fSDL)
	{
		ReportFailure(0x2B05, fCreateOnly || fSDL, NULL, 0, L"CoCreateInstance(%s, %s) succeeded", szClsid, SzIidDisplay());
	}

	return(TestAndReleaseInterface(fAggregate ? pouter : punk, &clsid, fAggregate || IsEqualGUID(iid, IID_IUnknown), false, true));
}


void DisplayLogo()
{
	if (fIsChild)			// no logo on child processes
	{
		return;
	}

	_putws(L"Microsoft (R) COM Checker " BUILD_VERSION_STR L"\n"
		L"Copyright (C) Microsoft Corporation. All rights reserved.\n"
		L"\n"
		L"Microsoft Confidential - For Internal Use Only\n");
}


void DisplayUsage()
{
	DisplayLogo();

	_putws(L"Usage: comchk <options>...\n"
		L"\n"
		L"Options:\n"
		L"\n"
		L"\t-addtodocument {after|before|no}\n"
		L"\t-aggregate\n"
		L"\t-bindtoobject\n"
		L"\t-bindtostorage\n"
		L"\t-checksafety\n"
		L"\t-clsctx <clsctx>\n"
		L"\t-clsid {guid}\n"
		L"\t-createonly\n"
		L"\t-data {url}\n"
		L"\t-dispatchmax <count>\n"
		L"\t-fakedebugger\n"
		L"\t-freeco\n"
		L"\t-html\n"
		L"\t-hookdll <path>\n"
		L"\t-ignorerpcexcept\n"
		L"\t-iid {guid}\n"
		L"\t-invoke <exe-path>\n"
		L"\t-invokeprefix <text>\n"
		L"\t-level <level>\n"
		L"\t-moniker <moniker-format>\n"
		L"\t-mt {mta|sta}\n"
		L"\t-mta\n"
		L"\t-nocategorycheck\n"
		L"\t-noexcept\n"
		L"\t-nofakedebugger\n"
		L"\t-nofree\n"
		L"\t-noidispatch\n"
		L"\t-noidispatchfuzz\n"
		L"\t-noignorebreakpoint\n"
		L"\t-noignoreclrexcept\n"
		L"\t-noignorecppexcept\n"
		L"\t-noignoredelayloadexcept\n"
		L"\t-noignorefloatexcept\n"
		L"\t-noignorexmlexcept\n"
		L"\t-nooverridesafety\n"
		L"\t-nopatchbreakpoint\n"
		L"\t-nowindowhook\n"
		L"\t-objref\n"
		L"\t-out <filename>\n"
		L"\t-prefix <prefix>\n"
		L"\t-progid <progid>\n"
		L"\t-removeprivileges\n"
		L"\t-safeforinitializing\n"
		L"\t-safeforscripting\n"
		L"\t-sad <filename>\n"
		L"\t-sdl\n"
		L"\t-silent\n"
		L"\t-stdmodes\n"
		L"\t-timeout <seconds>\n"
		L"\t-tryqi\n"
		L"\t-url <url>\n"
		L"\t-urlmoniker\n"
		L"\t-usecf\n"
		L"\t-useps\n"
		L"\t-verbose\n"
		L"\t-webbrowser\n"
		L"\t-zone <zone>\n");
}

int DoTests()
{
	fExistsA = _waccess_s(L"A", 0) == 0;

	CTrigger ctrigger;

	DWORD dwRegister;

	HRESULT hr = CoRegisterClassObject(__uuidof(CTrigger),
		&ctrigger,
		CLSCTX_INPROC_SERVER,
		REGCLS_MULTIPLEUSE,
		&dwRegister);

	if (FAILED(hr))
	{
		wprintf(L"CoRegisterClassObject failed.  hr = %08\n", hr);
	}

	int rc;

	if (szMoniker != NULL)
	{
		rc = DoMoniker(iid);
	}

	else if (fHTML)
	{
		wchar_t szClassid[6 + 36 + 1];

		swprintf(szClassid, _countof(szClassid), L"clsid:%.36s", szClsid + 1);

		if (fWebBrowser)
		{
			rc = DoHTMLWebBrowser(szClassid, &clsid);
		}

		else
		{
			rc = DoHTML(szClassid, &clsid);
		}
	}
	else if (fUseCF || fUsePS)
	{
		rc = DoCoGetClass(clsid, iid);
	}
	else
	{
		rc = DoCoCreate(clsid, iid);
	}

	if (SUCCEEDED(hr))
	{
		hr = CoRevokeClassObject(dwRegister);

		if (FAILED(hr))
		{
			wprintf(L"CoRevokeClassObject failed.  hr = %08\n", hr);
		}
	}

	return(rc);
}

DWORD WINAPI DoTestsThread(void *)
{
	HRESULT hr = CoInitializeEx(NULL, dwCoinit2);

	if (FAILED(hr))
	{
		wprintf(L"CoInitializeEx() failed.  hr = %08X\n", hr);
		return(1);
	}

	int rc = DoTests();

	CoUninitialize();

	return((DWORD) rc);
}

enum flag
{
	f_Error,
	f_addtodocument,
	f_aggregate,
	f_bindtoobject,
	f_bindtostorage,
	f_checksafety,
	f_clsctx,
	f_clsid,
	f_createonly,
	f_data,
	f_dispatchmax,
	f_fakedebugger,
	f_freeco,
	f_html,
	f_hookdll,
	f_ignorerpcexcept,
	f_iid,
	f_invoke,
	f_invokeprefix,
	f_moniker,
	f_mt,
	f_mta,
	f_nocategorycheck,
	f_noexcept,
	f_nofakedebugger,
	f_nofree,
	f_noidispatch,
	f_noidispatchfuzz,
	f_noignorebreakpoint,
	f_noignoreclrexcept,
	f_noignorecppexcept,
	f_noignoredelayloadexcept,
	f_noignorefloatexcept,
	f_noignorexmlexcept,
	f_nooverridesafety,
	f_nopatchbreakpoint,
	f_nowindowhook,
	f_objref,
	f_out,
	f_prefix,
	f_progid,
	f_removeprivileges,
	f_safeforinitializing,
	f_safeforscripting,
	f_sdl,
	f_sdlout,
	f_level,
	f_silent,
	f_stdmodes,
	f_timeout,
	f_tryqi,
	f_url,
	f_urlmoniker,
	f_usecf,
	f_useps,
	f_verbose,
	f_webbrowser,
	f_zone,
	f_sad
};

flag ParseFlag(const wchar_t *szArg)
{
	if ((szArg[0] != '/') &&
		(szArg[0] != '-') &&
		(szArg[0] != 0x2013)			// OK -- this looks dumb but is actually a dash from email
		) return f_Error;
	szArg++;
	if (_wcsicmp(szArg, L"addtodocument") == 0) return f_addtodocument;
	if (_wcsicmp(szArg, L"aggregate") == 0) return f_aggregate;
	if (_wcsicmp(szArg, L"bindtoobject") == 0) return f_bindtoobject;
	if (_wcsicmp(szArg, L"bindtostorage") == 0) return f_bindtostorage;
	if (_wcsicmp(szArg, L"checksafety") == 0) return f_checksafety;
	if (_wcsicmp(szArg, L"clsctx") == 0) return f_clsctx;
	if (_wcsicmp(szArg, L"clsid") == 0) return f_clsid;
	if (_wcsicmp(szArg, L"createonly") == 0) return f_createonly;
	if (_wcsicmp(szArg, L"data") == 0) return f_data;
	if (_wcsicmp(szArg, L"dispatchmax") == 0) return f_dispatchmax;
	if (_wcsicmp(szArg, L"fakedebugger") == 0) return f_fakedebugger;
	if (_wcsicmp(szArg, L"freeco") == 0) return f_freeco;
	if (_wcsicmp(szArg, L"html") == 0) return f_html;
	if (_wcsicmp(szArg, L"hookdll") == 0) return f_hookdll;
	if (_wcsicmp(szArg, L"ignorerpcexcept") == 0) return f_ignorerpcexcept;
	if (_wcsicmp(szArg, L"iid") == 0) return f_iid;
	if (_wcsicmp(szArg, L"invoke") == 0) return f_invoke;
	if (_wcsicmp(szArg, L"invokeprefix") == 0) return f_invokeprefix;
	if (_wcsicmp(szArg, L"moniker") == 0) return f_moniker;
	if (_wcsicmp(szArg, L"mt") == 0) return f_mt;
	if (_wcsicmp(szArg, L"mta") == 0) return f_mta;
	if (_wcsicmp(szArg, L"nocategorycheck") == 0) return f_nocategorycheck;
	if (_wcsicmp(szArg, L"noexcept") == 0) return f_noexcept;
	if (_wcsicmp(szArg, L"nofakedebugger") == 0) return f_nofakedebugger;
	if (_wcsicmp(szArg, L"nofree") == 0) return f_nofree;
	if (_wcsicmp(szArg, L"noidispatch") == 0) return f_noidispatch;
	if (_wcsicmp(szArg, L"noidispatchfuzz") == 0) return f_noidispatchfuzz;
	if (_wcsicmp(szArg, L"noignorebreakpoint") == 0) return f_noignorebreakpoint;
	if (_wcsicmp(szArg, L"noignoreclrexcept") == 0) return f_noignoreclrexcept;
	if (_wcsicmp(szArg, L"noignorecppexcept") == 0) return f_noignorecppexcept;
	if (_wcsicmp(szArg, L"noignoredelayloadexcept") == 0) return f_noignoredelayloadexcept;
	if (_wcsicmp(szArg, L"noignorefloatexcept") == 0) return f_noignorefloatexcept;
	if (_wcsicmp(szArg, L"noignorexmlexcept") == 0) return f_noignorexmlexcept;
	if (_wcsicmp(szArg, L"nooverridesafety") == 0) return f_nooverridesafety;
	if (_wcsicmp(szArg, L"nopatchbreakpoint") == 0) return f_nopatchbreakpoint;
	if (_wcsicmp(szArg, L"nowindowhook") == 0) return f_nowindowhook;
	if (_wcsicmp(szArg, L"objref") == 0) return f_objref;
	if (_wcsicmp(szArg, L"out") == 0) return f_out;
	if (_wcsicmp(szArg, L"prefix") == 0) return f_prefix;
	if (_wcsicmp(szArg, L"progid") == 0) return f_progid;
	if (_wcsicmp(szArg, L"removeprivileges") == 0) return f_removeprivileges;
	if (_wcsicmp(szArg, L"safeforinitializing") == 0) return f_safeforinitializing;
	if (_wcsicmp(szArg, L"safeforscripting") == 0) return f_safeforscripting;
	if (_wcsicmp(szArg, L"sdl") == 0) return f_sdl;
	if (_wcsicmp(szArg, L"sdlout") == 0) return f_sdlout;
	if (_wcsicmp(szArg, L"level") == 0) return f_level;
	if (_wcsicmp(szArg, L"silent") == 0) return f_silent;
	if (_wcsicmp(szArg, L"stdmodes") == 0) return f_stdmodes;
	if (_wcsicmp(szArg, L"timeout") == 0) return f_timeout;
	if (_wcsicmp(szArg, L"tryqi") == 0) return f_tryqi;
	if (_wcsicmp(szArg, L"url") == 0) return f_url;
	if (_wcsicmp(szArg, L"urlmoniker") == 0) return f_urlmoniker;
	if (_wcsicmp(szArg, L"usecf") == 0) return f_usecf;
	if (_wcsicmp(szArg, L"useps") == 0) return f_useps;
	if (_wcsicmp(szArg, L"verbose") == 0) return f_verbose;
	if (_wcsicmp(szArg, L"webbrowser") == 0) return f_webbrowser;
	if (_wcsicmp(szArg, L"zone") == 0) return f_zone;
	if (_wcsicmp(szArg, L"sad") == 0) return f_sad;
	
	return f_Error;
}

int wmain(int argc, wchar_t *argv[])
{
	printf("\n");  // No, I don't know why this is needed, but if I don't do it I don't get output from children.
	SetErrorMode(SEM_FAILCRITICALERRORS);

	if (argc < 2)
	{
		DisplayUsage();
		return(1);
	}

	for (int iarg = 1; iarg < argc; iarg++)
	{
		const wchar_t *szArg = argv[iarg];

		flag f = ParseFlag(szArg);

		switch(f)
		{
			case f_addtodocument:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szAddToDocument = argv[iarg];
				break;
			case f_aggregate:
				fAggregate = true;
				break;
			case f_bindtoobject:
				fBindToObject = true;
				break;
			case f_bindtostorage:
				fBindToStorage = true;
				break;
			case f_checksafety:
				fCheckSafety = true;
				break;
			case f_clsctx:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szClsctx = argv[iarg];
				break;
			case f_clsid:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szClsid = argv[iarg];
				break;
			case f_createonly:
				fCreateOnly = true;
				break;
			case f_data:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szData = argv[iarg];
				break;
			case f_dispatchmax:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szDispatchMax = argv[iarg];
				break;
			case f_fakedebugger:
				fFakeDebugger = true;
				break;
			case f_freeco:
				fFreeCO = true;
				break;
			case f_html:
				fHTML = true;
				break;
			case f_hookdll:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szHookDll = argv[iarg];
				break;
			case f_ignorerpcexcept:
				fIgnoreRpcExcept = true;
				break;
			case f_iid:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szIid = argv[iarg];
				break;
			case f_invoke:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szInvoke = argv[iarg];
				break;
			case f_invokeprefix:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szInvokePrefix = argv[iarg];
				break;
			case f_moniker:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szMoniker = argv[iarg];
				break;
			case f_mt:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szMT = argv[iarg];
				break;
			case f_mta:
				fMTA = true;
				break;
			case f_nocategorycheck:
				fNoCategoryCheck = true;
				break;
			case f_noexcept:
				fNoVectoredExceptions = true;
				break;
			case f_nofakedebugger:
				fNoFakeDebugger = true;
				break;
			case f_nofree:
				fNoFree = true;
				break;
			case f_noidispatch:
				fNoIDispatch = true;
				break;
			case f_noidispatchfuzz:
				fNoIDispatchFuzz = true;
				break;
			case f_noignorebreakpoint:
				fNoIgnoreBreakpoint = true;
				break;
			case f_noignoreclrexcept:
				fNoIgnoreClrExcept = true;
				break;
			case f_noignorecppexcept:
				fNoIgnoreCppExcept = true;
				break;
			case f_noignoredelayloadexcept:
				fNoIgnoreDelayLoadExcept = true;
				break;
			case f_noignorefloatexcept:
				fNoIgnoreFloatExcept = true;
				break;
			case f_noignorexmlexcept:
				fNoIgnoreXmlExcept = true;
				break;
			case f_nooverridesafety:
				fNoOverrideSafety = true;
				break;
			case f_nopatchbreakpoint:
				fNoPatchBreakpoint = true;
				break;
			case f_nowindowhook:
				fNoWindowHook = true;
				break;
			case f_objref:
				fObjrefMoniker = true;
				break;
			case f_out:
				if (++iarg == argc)
				{	
					DisplayUsage();
					return 1;
				}
				szOut = argv[iarg];
				break;
			case f_prefix:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szPrefix = argv[iarg];
				break;
			case f_progid:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szProgid = argv[iarg];
				break;
			case f_removeprivileges:
				fRemovePrivileges = true;
				break;
			case f_safeforinitializing:
				fSafeForInitializing = true;
				break;
			case f_safeforscripting:
				fSafeForScripting = true;
				break;
			case f_sdl:
				fSDL = true;
				fStdModes = true;
				if (!blevel)
					ilevel = 3;
				break;
			case f_sdlout:
				fSDL = true;
				if (!blevel)
					ilevel = 3;
				break;
			case f_level:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				ilevel = _wtoi(argv[iarg]);
				blevel = true;
				break;
			case f_silent:
				fSilent = true;
				break;
			case f_stdmodes:
				fStdModes = true;
				break;
			case f_timeout:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szTimeout = argv[iarg];
				break;
			case f_tryqi:
				fTryQI = true;
				break;
			case f_url:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szUrl = argv[iarg];
				break;
			case f_urlmoniker:
				fUrlMoniker = true;
				break;
			case f_usecf:
				fUseCF = true;
				break;
			case f_useps:
				fUsePS = true;
				break;
			case f_verbose:
				fVerbose = true;
				break;
			case f_webbrowser:
				fWebBrowser = true;
				fHTML = true;		       // -webbrowser implies -html
				break;
			case f_zone:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szZone = argv[iarg];
				break;
			case f_sad:
				if (++iarg == argc)
				{
					DisplayUsage();
					return 1;
				}
				szSad = argv[iarg];
				break;
			case f_Error:
			default:
				DisplayUsage();
				return 1;
		}
	}

	if (fRemovePrivileges)
	{
		RemovePrivileges();
	}

	if (fFakeDebugger || (!fNoFakeDebugger && !FDefaultNoFakeDebugger()))
	{
		// Set the BeingDebugged field in the PEB.  This is necessary so that
		// output from DebugPrint is reported via DBG_PRINTEXCEPTION_C on
		// pre-Longhorn systems.

#if	defined(_M_IX86)

		BYTE *pbPeb = (BYTE *) __readfsdword(0x30);

		pbPeb[2] = 0x01;

#elif	defined(_M_AMD64)

		BYTE *pbPeb = (BYTE *) __readgsqword(0x60);

		pbPeb[2] = 0x01;

#endif
	}

	HRESULT hr = CoInitializeEx(NULL, fMTA ? COINIT_MULTITHREADED : COINIT_APARTMENTTHREADED);

	if (FAILED(hr))
	{
		wprintf(L"CoInitializeEx() failed.  hr = %08X\n", hr);
		return(1);
	}

	wchar_t szClsidT[39];

	if (szClsid != NULL)
	{
		if (fUsePS)
		{
			_putws(L"-useps invalid with -clsid\n");
			return(1);
		}

		if (szProgid != NULL)
		{
			wprintf(L"Only one of -clsid or -progid may be specified");
			return(1);
		}

		if (wcscmp(szClsid, L"*") == 0)
		{
			fAllClsids = true;
		}

		else if (szClsid[0] == L'@')
		{
			fClsidsFromFile = true;
		}

		else if (szClsid[0] != L'{')
		{
			wprintf(L"Invalid CLSID \"%s\"\n", szClsid);
			return(1);
		}

		else
		{
			hr = CLSIDFromString(szClsid, &clsid);

			if (FAILED(hr))
			{
				wprintf(L"Invalid CLSID \"%s\".  HRESULT = %08X\n", szClsid, hr);
				return(1);
			}

			if (szPrefix == NULL)
			{
				szPrefix = szClsid;
			}
		}
	}

	else if (szProgid != NULL)
	{
		if (fUsePS)
		{
			_putws(L"-useps invalid with -progid\n");
			return(1);
		}

		if (wcscmp(szProgid, L"*") == 0)
		{
			fAllProgids = true;
		}

		else if (szProgid[0] == L'@')
		{
			fProgidsFromFile = true;
		}

		else
		{
			hr = CLSIDFromProgID(szProgid, &clsid);

			if (FAILED(hr))
			{
				wprintf(L"Invalid ProgID \"%s\".  HRESULT = %08X\n", szProgid, hr);
				return(1);
			}

			if (StringFromGUID2(clsid, szClsidT, _countof(szClsidT)) == 0)
			{
				wprintf(L"StringFromGUID2 failed.  hr = %08X\n", hr);
				return(1);
			}

			szClsid = szClsidT;

			if (szPrefix == NULL)
			{
				szPrefix = szProgid;
			}
		}
	}

	else if (!fUsePS)
	{
		_putws(L"One of -clsid or -progid must be specified");
		return(1);
	}

	if (szIid != NULL)
	{
		if (wcscmp(szIid, L"*") == 0)
		{
			fAllIids = true;
		}

		else if (szIid[0] == L'@')
		{
			fIidsFromFile = true;
		}

		else
		{
			hr = IIDFromString(szIid, &iid);

			if (FAILED(hr))
			{
				wprintf(L"Invalid IID \"%s\".  HRESULT = %08X\n", szIid, hr);
				return(1);
			}

			if (fTryQI)
			{
				_putws(L"-tryqi requires -iid * or -iid @filename");
				return(1);
			}

			if (fUsePS && !fStdModes)
			{
				if (szPrefix == NULL)
				{
					szPrefix = szIid;
				}

				// There is a bug in CoGetPSClsid that causes it to return success when it fails.
				// We check for this by checking for CLSID_NULL.

				clsid = CLSID_NULL;

				hr = CoGetPSClsid(iid, &clsid);

				if (FAILED(hr))
				{
					if (!fSilent)
					{
						wprintf(L"%s: CoGetPSClsid failed.  hr = %08X\n", szIid, hr);
					}

					// Note that we return 0 not 1

					return(0);
				}

				else if (clsid == CLSID_NULL)
				{
					if (!fSilent)
					{
						wprintf(L"%s: CoGetPSClsid didn't return a CLSID.  (Windows OS #1290702)\n", szIid);
					}

					// Note that we return 0 not 1

					return(0);
				}

				if (StringFromGUID2(clsid, szClsidT, _countof(szClsidT)) == 0)
				{
					wprintf(L"StringFromGUID2 failed.  hr = %08X\n", hr);
					return(1);
				}

				szClsid = szClsidT;
			}
		}
	}

	else if (fTryQI)
	{
		_putws(L"-tryqi requires -iid");
		return(1);
	}

	else if (fUsePS)
	{
		_putws(L"-useps requires -iid");
		return(1);
	}

	if (szClsctx != NULL)
	{
		if (_wcsicmp(szClsctx, L"all") == 0)
		{
			dwClsctx = CLSCTX_ALL;
		}

		else if (_wcsicmp(szClsctx, L"inproc") == 0)
		{
			dwClsctx = CLSCTX_INPROC;
		}

		else if (_wcsicmp(szClsctx, L"inproc_handler") == 0)
		{
			dwClsctx = CLSCTX_INPROC_HANDLER;
		}

		else if (_wcsicmp(szClsctx, L"inproc_server") == 0)
		{
			dwClsctx = CLSCTX_INPROC_SERVER;
		}

		else if (_wcsicmp(szClsctx, L"local_server") == 0)
		{
			dwClsctx = CLSCTX_LOCAL_SERVER;
		}

		else if (_wcsicmp(szClsctx, L"remote_server") == 0)
		{
			dwClsctx = CLSCTX_REMOTE_SERVER;
		}

		else if (_wcsicmp(szClsctx, L"server") == 0)
		{
			dwClsctx = CLSCTX_SERVER;
		}

		else
		{
			dwClsctx = wcstoul(szClsctx, NULL, 10);
		}
	}

	if (szDispatchMax != NULL)
	{
		dwDispatchMax = wcstoul(szDispatchMax, NULL, 10);
	}

	if (szMT != NULL)
	{
		if (_wcsicmp(szMT, L"mta") == 0)
		{
			dwCoinit2 = COINIT_MULTITHREADED;
		}

		else if (_wcsicmp(szMT, L"sta") == 0)
		{
			dwCoinit2 = COINIT_APARTMENTTHREADED;
		}

		else
		{
			dwCoinit2 = wcstoul(szMT, NULL, 10);
		}
	}

	if (szTimeout != NULL)
	{
		dwTimeout = wcstoul(szTimeout, NULL, 10);

		if (dwTimeout == 0)
		{
			dwTimeout = INFINITE;
		}
	}

	if (szZone != NULL)
	{
		if (_wcsicmp(szZone, L"local_machine") == 0)
		{
			dwZone = URLZONE_LOCAL_MACHINE;
		}

		else if (_wcsicmp(szZone, L"intranet") == 0)
		{
			dwZone = URLZONE_INTRANET;
		}

		else if (_wcsicmp(szZone, L"trusted") == 0)
		{
			dwZone = URLZONE_TRUSTED;
		}

		else if (_wcsicmp(szZone, L"internet") == 0)
		{
			dwZone = URLZONE_INTERNET;
		}

		else if (_wcsicmp(szZone, L"untrusted") == 0)
		{
			dwZone = URLZONE_UNTRUSTED;
		}

		else
		{
			dwZone = wcstoul(szZone, NULL, 10);
		}
	}

	if (fHTML)
	{
		if ((szClsid == NULL) && (szMoniker == NULL))
		{
			_putws(L"-html requires -clsid or -moniker\n");
			return(1);
		}

		if (szAddToDocument != NULL)
		{
			if (_wcsicmp(szAddToDocument, L"after") == 0)
			{
				atd = atdAfter;
			}

			else if (_wcsicmp(szAddToDocument, L"before") == 0)
			{
				atd = atdBefore;
			}

			else if (_wcsicmp(szAddToDocument, L"no") == 0)
			{
				atd = atdNo;
			}

			else
			{
				_putws(L"Invalid -addtodocument option\n");
				return(1);
			}
		}

		if (szClsctx)
		{
			_putws(L"-clsctx invalid with -html\n");
			return(1);
		}

		if (fUrlMoniker)
		{
			_putws(L"-urlmoniker invalid with -html\n");
			return(1);
		}

		if (fUseCF)
		{
			_putws(L"-usecf invalid with -html\n");
			return(1);
		}

		if (fUsePS)
		{
			_putws(L"-useps invalid with -html\n");
			return(1);
		}
	}

	else
	{
		if (szAddToDocument)
		{
			_putws(L"-addtodocument requires -html\n");
			return(1);
		}

		if (szData != NULL)
		{
			_putws(L"-data requires -html\n");
			return(1);
		}
	}

	if (fStdModes)
	{
		if (fAggregate)
		{
			_putws(L"-aggregate invalid with -stdmodes\n");
			return(1);
		}

		if (fWebBrowser)
		{
			_putws(L"-webbrowser invalid with -stdmodes\n");
			return(1);
		}

		if (fHTML)
		{
			_putws(L"-html invalid with -stdmodes\n");
			return(1);
		}

		if (fMTA)
		{
			_putws(L"-mta invalid with -stdmodes\n");
			return(1);
		}

		if (fUseCF)
		{
			_putws(L"-usecf invalid with -stdmodes\n");
			return(1);
		}
	}

	FILE *pfileOut = NULL;

	if (szOut != NULL)
	{
		if (_wfreopen_s(&pfileOut, szOut, L"wt", stdout) != 0)
		{
			pfileOut = NULL;
		}
	}

	// Try to open pipe.

		// create first instance
	HANDLE hPipe = CreateNamedPipe( 
			L"\\\\.\\pipe\\COMChk_CommPipe",             // pipe name 
			PIPE_ACCESS_INBOUND,       // read access 
			PIPE_TYPE_MESSAGE |       // message type pipe 
			PIPE_READMODE_MESSAGE |   // message-read mode 
			PIPE_WAIT,                // blocking mode 
			PIPE_UNLIMITED_INSTANCES, // max. instances  
			4096,                  // output buffer size 
			4096,                  // input buffer size 
			NMPWAIT_USE_DEFAULT_WAIT, // client time-out 
			NULL);                    // default security attribute 

	if (hPipe != INVALID_HANDLE_VALUE) 
	{
		DWORD dwThreadID;
		HANDLE hThread = CreateThread(NULL, 0, PipeServerThread, (LPVOID)hPipe, 0, &dwThreadID);
		if (hThread == NULL)
		{
			printf("CreateThread failed\n");
			return 0;
		}
		CloseHandle(hThread);
	}
	else
		fIsChild = true;

	DisplayLogo();


	//
	// Now open the pipe as a client.

	while (1) 
	{ 
		hPipeInfoSend = CreateFile( 
			L"\\\\.\\pipe\\COMChk_CommPipe",   // pipe name 
			GENERIC_WRITE,  // write access 
			0,              // no sharing 
			NULL,           // default security attributes
			OPEN_EXISTING,  // opens existing pipe 
			0,              // default attributes 
			NULL);          // no template file 

		// Break if the pipe handle is valid. 

		if (hPipeInfoSend != INVALID_HANDLE_VALUE) 
			break; 

		// Exit if an error other than ERROR_PIPE_BUSY occurs. 

		DWORD iErr = GetLastError();
		if (iErr != ERROR_PIPE_BUSY) 
		{
			printf("Could not open pipe, err %d", iErr); 
			return 0;
		}

		// All pipe instances are busy, so wait for 20 seconds. 

		if (!WaitNamedPipe(L"\\\\.\\pipe\\COMChk_CommPipe", 20000)) 
		{ 
			printf("Could not open pipe"); 
			return 0;
		} 
	} 
	// The pipe connected; change to message-read mode. 

	DWORD dwMode = PIPE_READMODE_MESSAGE; 
	BOOL fSuccess = SetNamedPipeHandleState( 
		hPipeInfoSend,    // pipe handle 
		&dwMode,  // new pipe mode 
		NULL,     // don't set maximum bytes 
		NULL);    // don't set maximum time 
	if (!fSuccess) 
	{
		printf("SetNamedPipeHandleState failed"); 
		return 0;
	}

	// Send a message to the pipe server. 


	// open XML SAD output for Master
	if (szSad != NULL)
	{
		sad = new SAD(szSad);
	}


	int iret;

	if (fAllClsids)
	{
		iret = DoAllClsids();
		goto cleanup;
	}

	if (fClsidsFromFile)
	{
		iret = DoClsidsFromFile(szClsid + 1);
		goto cleanup;
	}

	if (fAllProgids)
	{
		iret = DoAllProgids();
		goto cleanup;
	}

	if (fProgidsFromFile)
	{
		iret = DoProgidsFromFile(szProgid + 1);
		goto cleanup;
	}

	if (!fTryQI) 		       // Don't recurse with -tryqi
	{
		if (fAllIids)
		{
			iret = DoAllIids();
			goto cleanup;
		}

		if (fIidsFromFile)
		{
			iret = DoIidsFromFile(szIid + 1);
			goto cleanup;
		}
	}

	if (fStdModes)
	{
		iret = DoStdModes();
		goto cleanup;
	}

	//
	// At this point, we are testing one object.
	// Identified by clsid.
	// So log to parent (or me).

	PipeMsg pmObj;
	pmObj.AddDWORD(1);	// code for Object message
	LPOLESTR lpo;
	StringFromCLSID(clsid, &lpo);
	pmObj.AddString(lpo);
	CoTaskMemFree(lpo);
	pmObj.Send(hPipeInfoSend);

	//
	// Now dump the command line to the output also.

	PipeMsg pmTR;
	pmTR.AddDWORD(2);
	pmTR.AddString(GetCommandLine());
	pmTR.Send(hPipeInfoSend);

	SetMyUnhandledExceptionFilter(false);

	if (!fNoVectoredExceptions)
	{
		PVOID pvHandler = AddVectoredExceptionHandler(TRUE, &VectoredExceptionHandler);

		if (pvHandler == NULL)
		{
			wprintf(L"AddVectoredExceptionHandler failed.  GetLastError() = %u\n", GetLastError());
			return(1);
		}
	}

	if (!fNoWindowHook)
	{
		const wchar_t *szDll = (szHookDll != NULL) ? szHookDll : L"comchkhk.dll";

		hmodHook = LoadLibraryEx(szDll, 0, LOAD_WITH_ALTERED_SEARCH_PATH);

		if (hmodHook == NULL)
		{
			wprintf(L"LoadLibraryEx(\"%s\") failed.  GetLastError() = %u.  -nowindowhook assumed\n", szDll, GetLastError());

			fNoWindowHook = true;
		}

		else
		{
			*(FARPROC *) &pfnInstallHook = GetProcAddress(hmodHook, "InstallHook");
			*(FARPROC *) &pfnUninstallHook = GetProcAddress(hmodHook, "UninstallHook");

			if ((pfnInstallHook == 0) || (pfnUninstallHook == 0))
			{
				_putws(L"Can't find InstallHook or UninstallHook.  -nowindowhook assumed\n");

				FreeLibrary(hmodHook);
				hmodHook = NULL;

				fNoWindowHook = true;
			}

			else
			{
				hhook = (*pfnInstallHook)(&WindowHookCallback);
			}
		}
	}

	if (!fNoCategoryCheck && !fUsePS)
	{
		QueryComponentCategories(clsid);
	}


	if (szMT != NULL)
	{
		HANDLE hThread = CreateThread(NULL, 0, &DoTestsThread, NULL, 0, NULL);

		if (hThread == NULL)
		{
			wprintf(L"CreateThread failed.  GetLastError() = %u\n", GetLastError());
			return(1);
		}

		DWORD dw = WaitForSingleObject(hThread, INFINITE);

		if (!GetExitCodeThread(hThread, &dw))
		{
			wprintf(L"GetExitCodeThread failed.  GetLastError() = %u\n", GetLastError());
			return(1);
		}

		iret = (int) dw;

		CloseHandle(hThread);
	}

	else
	{
		iret = DoTests();
	}

	FreeUnusedLibraries();

	if (!fNoWindowHook)
	{
		(*pfnUninstallHook)(hhook);

		FreeLibrary(hmodHook);
	}

	if (pfileOut != NULL)
	{
		fclose(pfileOut);
	}
cleanup:

	if (sad) delete sad;


	CoUninitialize();
	return(iret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\warninfo.cpp ===
#include <stdio.h>

#define STRICT
#include "windows.h"

#include "verstamp.h"
#include "comchk.h"

typedef struct 
{
	LPWSTR Name;
	int Lvl;
} WARNLVLINFO, *PWARNLVLINFO;

WARNLVLINFO wliUninitPtr = {L"UninitializedPointer",1};
WARNLVLINFO wliUninitMem = {L"UninitializedMemory", 2};
WARNLVLINFO wliRetCode = {L"IncorrectReturnCode",8};
WARNLVLINFO wliDebug = {L"DebugCode", 1};
WARNLVLINFO wliConfirm = {L"Confirmation", 1};
WARNLVLINFO wliInfo = {L"Information", 9};
WARNLVLINFO wliRefCnt = {L"ReferenceCount", 3};
WARNLVLINFO wliFail = {L"TestFailure",1};
WARNLVLINFO wliIOS = {L"IObjectSafety",2};
WARNLVLINFO wliBad = {L"BadCode", 5};

typedef struct
{
	DWORD w;
	PWARNLVLINFO pi;
} WARNING, *PWARNING;

WARNING Warnings[] =
{
	{0x0101, &wliDebug},
	{0x0102, &wliDebug},
	{0x0103, &wliDebug},
	{0x0104, &wliDebug},
	{0x0105, &wliDebug},
	{0x0106, &wliDebug},
	{0x0107, &wliInfo},
	{0x0201, &wliInfo},
	{0x0301, &wliFail},
	{0x0302, &wliFail},
	{0x0303, &wliFail},
	{0x0401, &wliRetCode},
	{0x0402, &wliUninitPtr},
	{0x0501, &wliInfo},
	{0x0502, &wliBad},
	{0x0601, &wliInfo},
	{0x0602, &wliBad},
	{0x0701, &wliInfo},
	{0x0801, &wliInfo},
	{0x0901, &wliBad},
	{0x0902, &wliInfo},
	{0x0903, &wliBad},
	{0x0904, &wliBad},
	{0x0905, &wliInfo},
	{0x0906, &wliInfo},
	{0x0A01, &wliBad},
	{0x0A02, &wliIOS},
	{0x0A03, &wliRetCode},
	{0x0B01, &wliBad},
	{0x0B02, &wliIOS},
	{0x0B03, &wliBad},
	{0x0B04, &wliBad},
	{0x0B05, &wliBad},
	{0x0B06, &wliBad},
	{0x0B07, &wliBad},
	{0x0B08, &wliIOS},
	{0x0B09, &wliBad},
	{0x0B0A, &wliBad},
	{0x0B0B, &wliBad},
	{0x0B0C, &wliIOS},
	{0x0B0D, &wliBad},
	{0x0B0E, &wliBad},
	{0x0B0F, &wliBad},
	{0x0C01, &wliUninitPtr},
	{0x0C02, &wliUninitPtr},
	{0x0C03, &wliBad},
	{0x0C04, &wliUninitMem},
	{0x0C05, &wliUninitMem},
	{0x0C06, &wliUninitMem},
	{0x0C07, &wliBad},
	{0x0D01, &wliBad},
	{0x0D02, &wliBad},
	{0x0D03, &wliRetCode},
	{0x0D04, &wliUninitPtr},
	{0x0D05, &wliInfo},
	{0x0D06, &wliRetCode},
	{0x0D07, &wliUninitPtr},
	{0x0D08, &wliBad},
	{0x0D09, &wliRetCode},
	{0x0D0A, &wliUninitPtr},
	{0x0E01, &wliBad},
	{0x0E02, &wliBad},
	{0x0E03, &wliBad},
	{0x0E04, &wliBad},
	{0x0E05, &wliUninitPtr},
	{0x0E06, &wliInfo},
	{0x0E07, &wliBad},
	{0x0F01, &wliRetCode},
	{0x0F02, &wliBad},
	{0x0F03, &wliBad},
	{0x0F04, &wliRetCode},
	{0x0F05, &wliBad},
	{0x0F06, &wliRetCode},
	{0x0F07, &wliBad},
	{0x0F08, &wliUninitPtr},
	{0x0F09, &wliRetCode},	
	{0x0F0A, &wliUninitPtr},
	{0x0F0B, &wliRetCode},
	{0x0F0C, &wliUninitPtr},
	{0x0F0D, &wliRetCode},
	{0x0F0E, &wliBad},
	{0x1001, &wliBad},
	{0x1002, &wliBad},
	{0x1003, &wliBad},
	{0x1004, &wliBad},
	{0x1005, &wliBad},
	{0x1006, &wliBad},
	{0x1007, &wliBad},
	{0x1008, &wliBad},
	{0x1009, &wliBad},
	{0x100A, &wliBad},
	{0x100B, &wliBad},
	{0x1101, &wliBad},
	{0x1102, &wliBad},
	{0x1103, &wliBad},
	{0x1104, &wliBad},
	{0x1105, &wliBad},
	{0x1106, &wliBad},
	{0x1107, &wliBad},
	{0x1108, &wliBad},
	{0x1109, &wliBad},
	{0x1201, &wliBad},
	{0x1202, &wliBad},
	{0x1203, &wliBad},
	{0x1204, &wliBad},
	{0x1205, &wliBad},
	{0x1206, &wliBad},
	{0x1207, &wliBad},
	{0x1208, &wliBad},
	{0x1209, &wliBad},
	{0x1301, &wliBad},
	{0x1302, &wliBad},
	{0x1303, &wliBad},
	{0x1304, &wliBad},
	{0x1305, &wliBad},
	{0x1306, &wliBad},
	{0x1307, &wliBad},
	{0x1308, &wliBad},
	{0x1309, &wliBad},
	{0x1401, &wliBad},
	{0x1402, &wliBad},
	{0x1403, &wliBad},
	{0x1404, &wliBad},
	{0x1405, &wliBad},
	{0x1406, &wliBad},
	{0x1407, &wliBad},
	{0x1408, &wliBad},
	{0x1409, &wliBad},
	{0x1501, &wliBad},
	{0x1502, &wliRetCode},
	{0x1503, &wliBad},
	{0x1504, &wliBad},
	{0x1505, &wliBad},
	{0x1506, &wliBad},
	{0x1507, &wliBad},
	{0x1508, &wliBad},
	{0x1509, &wliBad},
	{0x150A, &wliBad},
	{0x150B, &wliBad},
	{0x150C, &wliBad},
	{0x15FF, &wliBad},
	{0x1601, &wliBad},
	{0x1602, &wliBad},
	{0x1603, &wliBad},
	{0x1604, &wliRetCode},
	{0x1605, &wliRetCode},
	{0x1606, &wliRetCode},
	{0x1607, &wliBad},
	{0x1608, &wliRetCode},
	{0x1609, &wliBad},
	{0x160A, &wliRetCode},
	{0x1701, &wliRetCode},
	{0x1702, &wliBad},
	{0x1703, &wliBad},
	{0x1704, &wliBad},
	{0x1705, &wliBad},
	{0x1706, &wliBad},
	{0x1707, &wliBad},
	{0x1708, &wliBad},
	{0x1709, &wliBad},
	{0x170A, &wliBad},
	{0x170B, &wliBad},
	{0x170C, &wliBad},
	{0x170D, &wliBad},
	{0x170E, &wliBad},
	{0x1801, &wliInfo},
	{0x1802, &wliInfo},
	{0x1901, &wliBad},
	{0x1902, &wliInfo},
	{0x1903, &wliInfo},
	{0x1904, &wliRefCnt},
	{0x1905, &wliRefCnt},
	{0x1906, &wliBad},
	{0x1907, &wliBad},
	{0x1908, &wliRefCnt},
	{0x1909, &wliBad},
	{0x190A, &wliBad},
	{0x1B01, &wliBad},
	{0x1B02, &wliBad},
	{0x1B03, &wliBad},
	{0x1B04, &wliBad},
	{0x1B05, &wliBad},
	{0x1C01, &wliBad},
	{0x1C02, &wliBad},
	{0x1C03, &wliBad},
	{0x1C04, &wliBad},
	{0x1C05, &wliBad},
	{0x1C06, &wliBad},
	{0x1C07, &wliBad},
	{0x1C08, &wliBad},
	{0x1C09, &wliBad},
	{0x1C0A, &wliBad},
	{0x1C0B, &wliBad},
	{0x1D01, &wliBad},
	{0x1D02, &wliBad},
	{0x1D03, &wliBad},
	{0x1D04, &wliBad},
	{0x1E01, &wliBad},
	{0x1E02, &wliBad},
	{0x1E03, &wliBad},
	{0x1E04, &wliBad},
	{0x1E05, &wliBad},
	{0x1E06, &wliBad},
	{0x1E07, &wliBad},
	{0x1E08, &wliBad},
	{0x1E09, &wliBad},
	{0x1E0A, &wliBad},
	{0x1E0B, &wliBad},
	{0x1E0C, &wliBad},
	{0x1F01, &wliBad},
	{0x1F02, &wliBad},
	{0x1F03, &wliInfo},
	{0x1F04, &wliBad},
	{0x1F05, &wliBad},
	{0x1F06, &wliUninitPtr},
	{0x2001, &wliInfo},
	{0x2101, &wliBad},
	{0x2102, &wliBad},
	{0x2103, &wliBad},
	{0x2104, &wliBad},
	{0x2105, &wliBad},
	{0x2106, &wliBad},
	{0x2201, &wliBad},
	{0x2202, &wliBad},
	{0x2203, &wliFail},
	{0x2204, &wliBad},
	{0x2205, &wliBad},
	{0x2206, &wliBad},
	{0x2207, &wliFail},
	{0x2208, &wliBad},
	{0x2209, &wliFail},
	{0x220A, &wliInfo},
	{0x220B, &wliBad},
	{0x220C, &wliBad},
	{0x220D, &wliInfo},
	{0x220E, &wliBad},
	{0x220F, &wliBad},
	{0x2210, &wliBad},
	{0x2301, &wliFail},
	{0x2302, &wliBad},
	{0x2303, &wliBad},
	{0x2304, &wliBad},
	{0x2401, &wliBad},
	{0x2402, &wliBad},
	{0x2403, &wliBad},
	{0x2404, &wliBad},
	{0x2405, &wliBad},
	{0x2406, &wliFail},
	{0x2407, &wliFail},
	{0x2408, &wliBad},
	{0x2409, &wliBad},
	{0x240A, &wliFail},
	{0x240B, &wliBad},
	{0x240C, &wliBad},
	{0x240D, &wliBad},
	{0x240E, &wliBad},
	{0x240F, &wliBad},
	{0x2410, &wliBad},
	{0x2411, &wliBad},
	{0x2501, &wliFail},
	{0x2502, &wliFail},
	{0x2503, &wliBad},
	{0x2504, &wliBad},
	{0x2505, &wliBad},
	{0x2506, &wliBad},
	{0x2507, &wliBad},
	{0x2508, &wliBad},
	{0x2509, &wliBad},
	{0x2601, &wliFail},
	{0x2602, &wliInfo},
	{0x2603, &wliBad},
	{0x2604, &wliInfo},
	{0x2701, &wliInfo},
	{0x2702, &wliBad},
	{0x2703, &wliInfo},
	{0x2704, &wliBad},
	{0x2705, &wliBad},
	{0x2706, &wliBad},
	{0x2707, &wliBad},
	{0x2708, &wliUninitPtr},
	{0x2709, &wliBad},
	{0x270A, &wliRetCode},
	{0x270B, &wliBad},
	{0x270C, &wliInfo},
	{0x270D, &wliBad},
	{0x270E, &wliUninitPtr},
	{0x270F, &wliUninitPtr},
	{0x2710, &wliInfo},
	{0x2711, &wliInfo},
	{0x2712, &wliInfo},
	{0x2713, &wliInfo},
	{0x2714, &wliConfirm},
	{0x2801, &wliInfo},
	{0x2802, &wliUninitPtr},
	{0x2803, &wliInfo},
	{0x2804, &wliInfo},
	{0x2901, &wliBad},
	{0x2902, &wliUninitPtr},
	{0x2903, &wliUninitPtr},
	{0x2904, &wliInfo},
	{0x2905, &wliBad},
	{0x2906, &wliBad},
	{0x2A01, &wliBad},
	{0x2A02, &wliBad},
	{0x2A03, &wliInfo},
	{0x2B01, &wliFail},
	{0x2B02, &wliUninitPtr},
	{0x2B03, &wliBad},
	{0x2B04, &wliInfo},
	{0x2B05, &wliConfirm},
	{0x2C01, &wliInfo},
	{0x2D01, &wliInfo},
	{0x2D02, &wliUninitPtr},
	{0x2D03, &wliInfo},
	{0x2D04, &wliUninitPtr},
	{0x2D05, &wliInfo},
	{0x2D06, &wliUninitPtr},
	{0x2D07, &wliBad},
	{0x2D08, &wliInfo},
	{0x2D09, &wliBad},
	{0x2E01, &wliBad},
	{0x2E02, &wliBad},
	{0x2E03, &wliBad},
	{0x2E04, &wliBad},
	{0x2E05, &wliUninitPtr},
	{0x2E06, &wliInfo},
	{0x2E07, &wliBad},
	{0x2F01, &wliBad},
	{0x2F02, &wliBad},
	{0x2F03, &wliBad},
	{0x2F04, &wliBad},
	{0x2F05, &wliBad},
	{0x2F06, &wliBad},
	{0x2F07, &wliBad},
	{0x2F08, &wliBad},
	{0x2F09, &wliUninitPtr},
	{0x2F0A, &wliRetCode},
	{0x2F0B, &wliUninitPtr},
	{0x2F0C, &wliRetCode},
	{0x2F0D, &wliRetCode},
	{0x2F0E, &wliBad},
	{0x2F0F, &wliUninitPtr},
	{0x2F10, &wliInfo},
	{0x2F11, &wliInfo},
	{0x2F12, &wliBad},
	{0x2F13, &wliUninitPtr},
	{0x2F14, &wliInfo},
	{0x2F15, &wliBad},
	{0x3001, &wliBad},
	{0x3002, &wliBad},
	{0x3003, &wliBad},
	{0x3004, &wliBad},
	{0x3005, &wliBad},
	{0x3006, &wliBad},
	{0x3007, &wliFail},
	{0x3008, &wliFail},
	{0x3009, &wliFail},
	{0x300A, &wliBad},
	{0x300B, &wliFail},
	{0x300C, &wliBad},
	{0x300D, &wliBad},
	{0x300E, &wliBad},
	{0x3101, &wliBad},
	{0x3102, &wliBad},
	{0x3103, &wliBad},
	{0x3104, &wliBad},
	{0x3105, &wliBad},
	{0x3106, &wliBad},
	{0x3107, &wliBad},
	{0x3108, &wliFail},
	{0x3109, &wliFail},
	{0x310A, &wliFail},
	{0x310B, &wliBad},
	{0x310C, &wliFail},
	{0x310D, &wliBad},
	{0x310E, &wliBad},
	{0x310F, &wliBad},
	{0x3201, &wliBad},
	{0XFFFF, &wliFail},

};

// Binary search!  Remember Knuth!
PWARNLVLINFO FindWarnInfo(DWORD rc, int l, int u)
{
	if (l >= u) return NULL;
	int t = (l+u) >>1;
	if (rc == Warnings[t].w) return Warnings[t].pi;
	if (rc < Warnings[t].w) return FindWarnInfo(rc, l, t);
	return FindWarnInfo(rc, t+1, u);
}
bool FindWarningInfo(DWORD rc, LPWSTR *pName, int *pLvl)
{
	PWARNLVLINFO p = FindWarnInfo(rc, 0, sizeof(Warnings)/sizeof(Warnings[0]));
	if (p == NULL)	return false;

	*pName = p->Name;
	*pLvl = p->Lvl;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x86\sadoutput.cpp ===
/***********************************************************************
* Microsoft COMCHK
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#define STRICT
#include "windows.h"

#include "verstamp.h"
#include "comchk.h"

// TODO: Filename universalization (must be handled in ComChk core)

//
// Convert a string to something XML likes.
//
#ifndef SET_PTR_VALUE
#define SET_PTR_VALUE(p, v) if ((p) != NULL) (*(p)) = (v)
#endif

DWORD
XmlEncodeString_Alloc(
    __in PWSTR pwszString,
    __out PWSTR *ppwszResult,
    __out_opt DWORD *pcchResult)
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwIdx;
    PWSTR pwszResult;
    DWORD cchResult = 0;
    DWORD cchIllegalChars = 0;

    // Preset
    *ppwszResult = NULL;
    SET_PTR_VALUE(pcchResult, 0);

    // Count special chars
    for (dwIdx = 0; pwszString[dwIdx] != 0; ++dwIdx)
    {
        if (pwszString[dwIdx] == L'&')
        {
            cchResult += 5;
        }
        else if (pwszString[dwIdx] == L'<')
        {
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'>')
        {
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'\'')
        {
            cchResult += 6;
        }
        else if (pwszString[dwIdx] == L'\"')
        {
            cchResult += 6;
        }
        else
        {
            // Non-printable character?
            if (!iswprint(pwszString[dwIdx]) &&
                pwszString[dwIdx] != L'\r' &&
                pwszString[dwIdx] != L'\n' &&
                pwszString[dwIdx] != L'\t')
            {
                ++cchIllegalChars;
            }

            ++cchResult;
        }
	}
	//
	// Do we want to do this?
    if (dwIdx == cchResult &&
        cchIllegalChars == 0)
    {
        goto CLEANUP_AND_RETURN;
    }
    pwszResult = (PWSTR) LocalAlloc(LPTR, (cchResult + 1)*sizeof(WCHAR));

    if (pwszResult == NULL)
    {
        dwResult = ERROR_OUTOFMEMORY;
        goto CLEANUP_AND_RETURN;
    }

    cchResult = 0;

    // Replace special chars
    for (dwIdx = 0; pwszString[dwIdx] != 0; ++dwIdx)
    {
        if (pwszString[dwIdx] == L'&')
        {
            CopyMemory(pwszResult + cchResult, L"&amp;", 10);
            cchResult += 5;
        }
        else if (pwszString[dwIdx] == L'<')
        {
            CopyMemory(pwszResult + cchResult, L"&lt;", 8);
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'>')
        {
            CopyMemory(pwszResult + cchResult, L"&gt;", 8);
            cchResult += 4;
        }
        else if (pwszString[dwIdx] == L'\'')
        {
            CopyMemory(pwszResult + cchResult, L"&apos;", 12);
            cchResult += 6;
        }
        else if (pwszString[dwIdx] == L'\"')
        {
            CopyMemory(pwszResult + cchResult, L"&quot;", 12);
            cchResult += 6;
        }
        else
        {
            // Non-printable character?
            if (!iswprint(pwszString[dwIdx]) &&
                pwszString[dwIdx] != L'\r' &&
                pwszString[dwIdx] != L'\n' &&
                pwszString[dwIdx] != L'\t')
            {
                pwszResult[cchResult] = L'?';
            }
            else
            {
                pwszResult[cchResult] = pwszString[dwIdx];
            }

            ++cchResult;
        }

	}
    pwszResult[cchResult] = 0;

    *ppwszResult = pwszResult;
    SET_PTR_VALUE(pcchResult, cchResult);

CLEANUP_AND_RETURN:
    return dwResult;
}

void OutputAttributeString(FILE *pf, LPWSTR name, LPWSTR value)
{
	LPWSTR pAlloc = NULL;
	DWORD res = XmlEncodeString_Alloc(value, &pAlloc, NULL);

	if (pAlloc)
	{
		fwprintf_s(pf, L"%ws=\"%ws\" ", name, pAlloc);
		LocalFree(pAlloc);
	} else
	{
		fwprintf_s(pf, L"%ws=\"%ws\" ", name, value);
	}
}

OutInstance::OutInstance(OutCOMCtrl *CC, LPWSTR cmdline, FILE *pf)
{
	_pfsad = pf;
    _CC = CC;
    // Now build node and add attributes
    //

	fwprintf_s(_pfsad, L"<instance ");
    _idx = _CC->GetAndIncrementIdx();
	fwprintf_s(_pfsad, L"idx=\"%d\" ", _idx);
	fwprintf_s(_pfsad, L"target=\"%d\" ", _CC->GetTarget());
    OutputAttributeString(_pfsad, L"cmdline", cmdline);
	fwprintf_s(_pfsad, L"/>\n");
}

void OutInstance::OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr)
{
    int iInterfaceIdx = 0;

    // Text contains IID?
    if (text != NULL &&
        wcsnicmp(text, L"IID =", 5) == 0)
    {
        // Extract IID string
        PWSTR pwszInterface = text + 5 + wcsspn(text + 5, L" \t");
        pwszInterface[38] = 0;
        text = pwszInterface + 39 + wcsspn(pwszInterface + 39, L".,;: \t");

        // Add interface element (or get idx if already added)
        iInterfaceIdx = _CC->AddInterfaceEntry(pwszInterface, _CC->GetTarget());
    }

    int iFileIdx = 0;

    // Address provided?
    if (addr != NULL)
    {
        // Extract file string
        INT cLen = wcscspn(addr, L".,;: \t");
        addr[cLen] = 0;
        PWSTR pwszFile = addr + cLen + 1 + wcscspn(addr + cLen + 1, L"(") + 1;
        cLen = wcscspn(pwszFile, L")");
        pwszFile[cLen] = 0;

        // Add file element (or get idx if already added)
        iFileIdx = _CC->AddFileEntry(pwszFile);
    }

	fwprintf_s(_pfsad, L"<check ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"name=\"%ws\" ", L"COMChk");
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);
    fwprintf_s(_pfsad, L"result=\"0x%04X\" ", rc);

    if (iInterfaceIdx != 0)
    {
        fwprintf_s(_pfsad, L"interface=\"%d\" ", iInterfaceIdx);
    }

/* PJM... Unused
    if (ident)
    {
        SetEntryAttribute(pEle, L"identity", ident);
    }
*/
    if (iFileIdx != 0)
    {
        fwprintf_s(_pfsad, L"file=\"%d\" ", iFileIdx);
    }
    if (addr)
    {
		// addr should not contain special characters
        fwprintf_s(_pfsad, L"address=\"0x%ws\" ", addr);
    }
    if (text)
    {
        OutputAttributeString(_pfsad, L"text", text);
    }
	fwprintf_s(_pfsad, L"/>\n");   
}

void OutInstance::OutputException(DWORD rc, LPWSTR cmdline, LPWSTR addr)
{
    int iFileIdx = 0;

    // Address provided?
    if (addr != NULL)
    {
        // Extract file string
        UINT cLen = wcscspn(addr, L".,;: \t");
        addr[cLen] = 0;
        PWSTR pwszFile = addr + cLen + 1 + wcscspn(addr + cLen + 1, L"(") + 1;
        cLen = wcscspn(pwszFile, L")");
        pwszFile[cLen] = 0;

        // Add file element (or get idx if already added)
        iFileIdx = _CC->AddFileEntry(pwszFile);
    }

	fwprintf_s(_pfsad, L"<exception ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);
    fwprintf_s(_pfsad, L"code=\"0x%08X\" ", rc);

/* PJM... Unused
    if (cmdline)
    {
        SetEntryAttribute(pEle, L"cmdline", cmdline);
    }
*/

    if (iFileIdx != 0)
    {
        fwprintf_s(_pfsad, L"file=\"%d\" ", iFileIdx);
    }
    if (addr)
    {
		// addr should not contain special characters
        fwprintf_s(_pfsad, L"address=\"0x%ws\" ", addr);
    }
	fwprintf_s(_pfsad, L"/>\n");   
}

void OutInstance::OutputTimeout(LPWSTR cmdline)
{
	fwprintf_s(_pfsad, L"<timeout ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);

/* PJM... Unused
    if (cmdline)
    {
        SetEntryAttribute(pEle, L"cmdline", cmdline);
    }
*/
	fwprintf_s(_pfsad, L"/>\n");   
}

void OutInstance::OutputUnknown(LPWSTR cmdline)
{
	fwprintf_s(_pfsad, L"<unknown ");   
    fwprintf_s(_pfsad, L"idx=\"%d\" ", _CC->GetAndIncrementIdx());
    fwprintf_s(_pfsad, L"target=\"%d\" ", _idx);

/* PJM... Unused
    if (cmdline)
    {
        SetEntryAttribute(pEle, L"cmdline", cmdline);
    }
*/

	fwprintf_s(_pfsad, L"/>\n");  
}

OutInstance::~OutInstance()
{
}

int OutCOMCtrl::GetTarget()
{
    return _idx;
}

BOOL OutCOMCtrl::IsThisClsid(LPWSTR sclsid)
{
    CLSID clsid;
    CLSIDFromString(sclsid, &clsid);
    return IsEqualCLSID(clsid, _clsid);
}

int OutCOMCtrl::GetAndIncrementIdx()
{
    return _sad->GetAndIncrementIdx();
}

int OutCOMCtrl::AddInterfaceEntry(LPWSTR clsid, int control)
{
    return _sad->AddInterfaceEntry(clsid, control);
}

int OutCOMCtrl::AddFileEntry(LPWSTR path)
{
    return _sad->AddFileEntry(path);
}

OutCOMCtrl::OutCOMCtrl(SAD *sad, LPWSTR sclsid, FILE *pf)
{
    _sad = sad;
	_pfsad = pf;
    CLSIDFromString(sclsid, &_clsid);
    _InstCurrent = NULL;
    //
    // Now build node and add attributes
    //

	fwprintf_s(_pfsad, L"<comctrl ");   
    _idx = _sad->GetAndIncrementIdx(); // save for target

	fwprintf_s(_pfsad, L"idx=\"%d\" ", _idx);
    LPOLESTR lpo;
    StringFromCLSID(_clsid, &lpo);
    OutputAttributeString(_pfsad, L"clsid", lpo);
    CoTaskMemFree(lpo);
	fwprintf_s(_pfsad, L"/>\n");
}

void OutCOMCtrl::OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr)
{
    _InstCurrent->OutputWarning(rc, ident, text, addr);
}
void OutCOMCtrl::OutputException(DWORD rc, LPWSTR cmdline, LPWSTR addr)
{
    _InstCurrent->OutputException(rc, cmdline, addr);
}
void OutCOMCtrl::OutputTimeout(LPWSTR cmdline)
{
    _InstCurrent->OutputTimeout(cmdline);
}
void OutCOMCtrl::OutputUnknown(LPWSTR cmdline)
{
    _InstCurrent->OutputUnknown(cmdline);
}
void OutCOMCtrl::SetInstance(LPWSTR wcCmdLine)
{
    if (_InstCurrent) 
	{
		delete _InstCurrent;
		_InstCurrent = NULL;
	}
    _InstCurrent = new OutInstance(this, wcCmdLine, _pfsad);
}

OutCOMCtrl::~OutCOMCtrl()
{
    if (_InstCurrent) delete _InstCurrent;
}

void SAD::OutputWarning(DWORD rc, LPWSTR ident, LPWSTR text, LPWSTR addr)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputWarning(rc, ident, text, addr);

    LeaveCriticalSection(&_cs);
}

void SAD::OutputException(DWORD rc, LPWSTR CmdLine, LPWSTR addr)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputException(rc, CmdLine, addr);

    LeaveCriticalSection(&_cs);
}

void SAD::OutputTimeout(LPWSTR CmdLine)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputTimeout(CmdLine);

    LeaveCriticalSection(&_cs);
}

void SAD::OutputUnknown(LPWSTR CmdLine)
{
    EnterCriticalSection(&_cs);
    _CCCurrent->OutputUnknown(CmdLine);

    LeaveCriticalSection(&_cs);
}

// Note, this comes from a thread handling the pipe, so we really need to use a critsect.
void SAD::SetInstance(LPWSTR lpCmdLine)
{
    EnterCriticalSection(&_cs);
//	printf("SetInstance, cmd line %ws\n", lpCmdLine);
    _CCCurrent->SetInstance(lpCmdLine);
    LeaveCriticalSection(&_cs);

}

// Note, this comes from a thread handling the pipe, so we really need to use a critsect.
void SAD::SetCOMCtrl(LPWSTR clsid)
{
    EnterCriticalSection(&_cs);
    if (_CCCurrent)
    {
        if(_CCCurrent->IsThisClsid(clsid)) 
        {
            LeaveCriticalSection(&_cs);
            return;
        }
        delete _CCCurrent;
		_CCCurrent = NULL;
    }
    _CCCurrent = new OutCOMCtrl(this, clsid, _pfsad);
    LeaveCriticalSection(&_cs);
}

int SAD::GetAndIncrementIdx()
{
    return _idx++;
}


//
// Fill in attributes of the collection node.
// Split out for tidiness sake.
void SAD::FillInCollectionNode()
{
	fwprintf_s(_pfsad, L"tool=\"COMChk\" ");
	fwprintf_s(_pfsad, L"version=\"%d.%d.%d.%d\" ", rmj, rmm, rup, qfe);
    WCHAR wszMachine[256];
    DWORD csz = 256;
    GetComputerNameW(wszMachine, &csz);

	OutputAttributeString(_pfsad, L"machine", wszMachine);

    csz = 256;
    WCHAR wszDomain[256];
    GetComputerNameExW(ComputerNameDnsDomain, wszDomain, &csz);

    OutputAttributeString(_pfsad, L"domain", wszDomain);

    UINT64 uTime;
    GetSystemTimeAsFileTime((PFILETIME)&uTime);

    fwprintf_s(_pfsad, L"time=\"0x%016I64X\" ", uTime);
}

int SAD::AddInterfaceEntry(LPWSTR clsid, int control)
{
    // Create the key by combining the clsid and control index
    DWORD cchClsId = wcslen(clsid);
    LPWSTR pwszKey = new WCHAR[cchClsId + 64];
    wsprintf(pwszKey, L"%s.%i", clsid, control);

//	int iIdx = 0;
    int iIdx = _InterfaceCache.Find(pwszKey);

    // Already Added?
    if (iIdx != 0)
    {
        goto CLEANUP_AND_RETURN;
    }

    iIdx = GetAndIncrementIdx();

	fwprintf_s(_pfsad, L"<comint ");
	fwprintf_s(_pfsad, L"idx=\"%d\" ", iIdx);
    OutputAttributeString(_pfsad, L"clsid", clsid);
    fwprintf_s(_pfsad, L"control=\"%d\" ", control);
	fwprintf_s(_pfsad, L"/>\n");

    // Cache
    _InterfaceCache.Add(pwszKey, iIdx);

CLEANUP_AND_RETURN:
    delete[] pwszKey;
    return iIdx;
}

int SAD::AddFileEntry(LPWSTR path)
{
//    int iIdx = 0;
 int iIdx = _FileCache.Find(path);

    // Already Added?
    if (iIdx != 0)
    {
        goto CLEANUP_AND_RETURN;
    }

    iIdx = GetAndIncrementIdx();

	fwprintf_s(_pfsad, L"<file ");
	fwprintf_s(_pfsad, L"idx=\"%d\" ", iIdx);
    OutputAttributeString(_pfsad, L"path", path);
	fwprintf_s(_pfsad, L"/>\n");

    // Cache
    _FileCache.Add(path, iIdx);

CLEANUP_AND_RETURN:
    return iIdx;
}

SAD::SAD(wchar_t *pXMLFile)
{
    InitializeCriticalSection(&_cs);
    _idx = 0;

    _CCCurrent = NULL;
	errno_t errno;
	errno = _wfopen_s(&_pfsad, pXMLFile, L"wt");
	if (errno)
	{
		printf("ERROR opening SAD output file, error number %d\n", errno);
	}

    //
    // Now set up beginning goo.
    //
	fwprintf_s(_pfsad, L"<?xml version=\"1.0\"?>\n");
	fwprintf_s(_pfsad, L"<securityAnalysisData>\n");

    // now add the one and only collection node.
	fwprintf_s(_pfsad, L"<collection ");
    FillInCollectionNode();
	fwprintf_s(_pfsad, L">\n");

    // now add platform node.

	fwprintf_s(_pfsad, L"<platform ");
    OSVERSIONINFOEX VersionInfo = {sizeof(OSVERSIONINFOEX)};
    GetVersionEx((POSVERSIONINFO)&VersionInfo);

    UINT64 uTime;
    GetSystemTimeAsFileTime((PFILETIME)&uTime);

	fwprintf_s(_pfsad, L"idx=\"%d\" ", _idx++);
    fwprintf_s(_pfsad, L"majorVersion=\"%d\" ", VersionInfo.dwMajorVersion);
    fwprintf_s(_pfsad, L"minorVersion=\"%d\" ", VersionInfo.dwMinorVersion);
    fwprintf_s(_pfsad, L"buildNumber=\"%d\" ", VersionInfo.dwBuildNumber);
    fwprintf_s(_pfsad, L"platformId=\"%d\" ", VersionInfo.dwPlatformId);
    OutputAttributeString(_pfsad, L"csdVersion", VersionInfo.szCSDVersion);
    fwprintf_s(_pfsad, L"servicePackMajor=\"%d\" ", VersionInfo.wServicePackMajor);
    fwprintf_s(_pfsad, L"servicePackMinor=\"%d\" ", VersionInfo.wServicePackMinor);
    fwprintf_s(_pfsad, L"suiteMask=\"%d\" ", VersionInfo.wSuiteMask);
    fwprintf_s(_pfsad, L"productType=\"%d\" ", VersionInfo.wProductType);
    fwprintf_s(_pfsad, L"time=\"0x%016I64X\" ", uTime);

	fwprintf_s(_pfsad, L"/>\n");
}

SAD::~SAD()
{
    HRESULT hr;
    VARIANT var;

	fwprintf_s(_pfsad, L"</collection>\n");
	fwprintf_s(_pfsad, L"</securityAnalysisData>\n");
	fclose(_pfsad);

	if (_CCCurrent != NULL)
	{
		delete _CCCurrent;
		_CCCurrent = NULL;
	}
    DeleteCriticalSection(&_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ConsoleFileLog\code\ConsoleFileLog.cs ===
//-----------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   common library for logging
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace ConsoleFileLog
{
    using System;
    using System.IO;

    /// <summary>
    /// Class to log
    /// </summary>
    public class LogWriter : IDisposable
    {
        private bool attachConsole;
        private object lockObject = new object();
        private StreamWriter streamWriterConsole = new StreamWriter(Console.OpenStandardOutput());
        private StreamWriter streamWriterFile;

        public LogWriter()
        {
        }

        /// <summary>
        /// <summary>
        /// Attach the console standard output stream to the log object
        /// </summary>
        public void AttachConsole()
        {
            lock (this.lockObject)
            {
                this.attachConsole = true;
            }
        }

        /// <summary>
        /// Attach the file stream to the log object
        /// </summary>
        /// <param name="fileName"></param>
        public void AttachFile(string fileName)
        {
            lock (this.lockObject)
            {
                this.streamWriterFile = new StreamWriter(fileName, false, System.Text.Encoding.UTF8);
            }
        }

        /// <summary>
        /// Detach the console standard output stream from the log object
        /// </summary>
        public void DetachConsole()
        {
            lock (this.lockObject)
            {
                this.attachConsole = false;
            }
        }

        /// <summary>
        /// Detach the file stream from the log object
        /// </summary>
        public void DetachFile()
        {
            lock (this.lockObject)
            {
                this.streamWriterFile.Close();
                this.streamWriterFile = null;
            }
        }

        /// Dispose of this object
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
        }

        /// <summary>
        /// Dispose of this object
        /// </summary>
        /// <param name="disposing">If disposing equals true, managed and unmanaged resources can be disposed.  If disposing equals false, only unmanaged resources can be disposed.</param>
        private void Dispose(bool disposing)
        {
            if (true == disposing)
            {
                // dispose of the console stream
                this.streamWriterConsole.Dispose();

                if (null != this.streamWriterFile)
                {
                    this.streamWriterFile.Close();
                }
            }
        }

        /// <summary>
        /// Write the log string to all attached streams for the specified log level
        /// </summary>
        /// <param name="value"></param>
        public void Write(string value)
        {
            lock (this.lockObject)
            {
                // check if string should be written to console
                if (true == this.attachConsole)
                {
                    this.streamWriterConsole.Write(value);
                    this.streamWriterConsole.Flush();
                }

                // check if string should be written to file
                if (null != this.streamWriterFile)
                {
                    this.streamWriterFile.Write(value);
                    this.streamWriterFile.Flush();
                }
            }
        }

        /// <summary>
        /// Write the specified array of objects to all attached streams for the specified log level
        /// </summary>
        /// <param name="value"></param>
        /// <param name="objectArray"></param>
        public void Write(string value, params object[] valueArray)
        {
            this.Write(String.Format(value, valueArray));
        }

        /// <summary>
        /// Write an empty line to all attached streams for the specified log level
        /// </summary>
        public void WriteLine()
        {
            this.WriteLine(null);
        }

        /// <summary>
        /// Write the log string to all attached streams for the specified log level
        /// </summary>
        /// <param name="value"></param>
        public void WriteLine(string value)
        {
            this.Write(String.Format("{0}\r\n", value));
        }

        /// <summary>
        /// Write the specified array of objects to all attached streams for the specified log level
        /// </summary>
        /// <param name="value"></param>
        /// <param name="objectArray"></param>
        public void WriteLine(string value, params object[] valueArray)
        {
            this.WriteLine(String.Format(value, valueArray));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ConsoleFileLog\code\Properties\AssemblyInfo.cs ===
//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConsoleFileLog")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ConsoleFileLog")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("66a388f7-7b14-4b64-9143-67312bb0db12")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("2.0.0.0")]
[assembly: AssemblyFileVersion("2.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DatabaseObject.cs ===
//-----------------------------------------------------------------------
// <copyright file="DatabaseObject.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a database object
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Data;

    /// <summary>
    /// Represents a database object such as a table or stored procedure
    /// </summary>
    internal class DatabaseObject : SchemaObject
    {
        /// <summary>
        /// The collection of database objects this database object depends on
        /// </summary>
        private NameCollection<DatabaseObject> collectionDependsOn = new NameCollection<DatabaseObject>();

        /// <summary>
        /// The collection of columns or parameters for this database object
        /// </summary>
        private List<SchemaElement> listSchemaElements = new List<SchemaElement>();

        /// <summary>
        /// Initializes a new instance of the DatabaseObject class with the specified name
        /// </summary>
        /// <param name="schema">The specified schema</param>
        /// <param name="name">The specified name</param>
        public DatabaseObject(string schema, string name)
            : base(schema, name)
        {
        }

        /// <summary>
        /// Gets the collection of database objects this database object depends on
        /// </summary>
        public NameCollection<DatabaseObject> DependsOn
        {
            get { return this.collectionDependsOn; }
        }

        /// <summary>
        /// Gets the collection of schema elements for this object
        /// </summary>
        public List<SchemaElement> Elements
        {
            get { return this.listSchemaElements; }
        }

        /// <summary>
        /// Gets the sql data type of the specified element
        /// </summary>
        /// <param name="element">The specified element</param>
        /// <returns>The sql data type of the specified element</returns>
        public SqlDbType GetElementType(string element)
        {
            foreach (SchemaElement schemaElement in this.listSchemaElements)
            {
                if (schemaElement.Name == element)
                {
                    return schemaElement.SqlDbType;
                }
            }

            throw new ArgumentException(String.Format("'{0}' does not contain specified element '{1}'", this.Name, element));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DatabaseProcedure.cs ===
//-----------------------------------------------------------------------
// <copyright file="DatabaseProcedure.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a database procedure
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Represents a database stored procedure
    /// </summary>
    internal sealed class DatabaseProcedure : DatabaseObject
    {
        /// <summary>
        /// The text definition for the object
        /// </summary>
        private StringBuilder stringBuilderText = new StringBuilder();

        /// <summary>
        /// The text definition for the object
        /// </summary>
        private string text;

        /// <summary>
        /// Specifies if the text definition for the object has been finalized
        /// </summary>
        private bool textFinalized;

        /// <summary>
        /// Initializes a new instance of the DatabaseProcedure class with the specified name
        /// </summary>
        /// <param name="name">The specified schema</param>
        /// <param name="name">The specified name</param>
        public DatabaseProcedure(string schema, string name)
            : base(schema, name)
        {
        }

        /// <summary>
        /// Gets the text definition for this object
        /// </summary>
        public string Text
        {
            get
            {
                lock (this)
                {
                    if (false == this.textFinalized)
                    {
                        // setup the regex options
                        RegexOptions regexOptions = new RegexOptions();
                        regexOptions |= RegexOptions.IgnoreCase;
                        regexOptions |= RegexOptions.Singleline;

                        // strip the comments from the procedure text
                        this.text = this.stringBuilderText.ToString();
                        this.text = Regex.Replace(this.text, @"/\*(.*?)\*/", String.Empty, regexOptions);
                        this.text = Regex.Replace(this.text, @"--.*", String.Empty);

                        this.textFinalized = true;
                    }
                }

                return this.text;
            }
        }

        /// <summary>
        /// Appends a copy of the specified string to the end of the text definition for this object
        /// </summary>
        /// <param name="value">the string to append</param>
        public void AppendText(string value)
        {
            this.stringBuilderText.Append(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DatabaseTable.cs ===
//-----------------------------------------------------------------------
// <copyright file="DatabaseTable.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a database table
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Represents a database table
    /// </summary>
    internal sealed class DatabaseTable : DatabaseObject
    {
        /// <summary>
        /// collectionForeignKeys is the collection of foreign keys of the table
        /// </summary>
        private NameCollection<ForeignKey> collectionForeignKeys = new NameCollection<ForeignKey>();

        /// <summary>
        /// primaryKey is the primary key of the table
        /// </summary>
        private PrimaryKey primaryKey;

        /// <summary>
        /// Initializes a new instance of the DatabaseTable class with the specified name
        /// </summary>
        /// <param name="schema">The specified schema</param>
        /// <param name="name">The specified name</param>
        public DatabaseTable(string schema, string name)
            : base(schema, name)
        {
        }

        /// <summary>
        /// Gets the collection of foreign keys of the table
        /// </summary>
        public NameCollection<ForeignKey> ForeignKeys
        {
            get { return this.collectionForeignKeys; }
        }

        /// <summary>
        /// Gets or sets the primary key of the table
        /// </summary>
        public PrimaryKey PrimaryKey
        {
            get { return this.primaryKey; }
            set { this.primaryKey = value; }
        }

        /// <summary>
        /// Checks if the specified element name is required by key
        /// </summary>
        /// <param name="name">The specified element name</param>
        /// <returns>true if the element is required; otherwise, false</returns>
        public bool IsElementRequired(string name)
        {
            if (null != this.primaryKey)
            {
                if (true == this.primaryKey.Fields.Contains(name))
                {
                    return true;
                }
            }

            foreach (ForeignKey foreignKey in this.collectionForeignKeys)
            {
                if (true == foreignKey.Fields.Contains(name))
                {
                    return true;
                }
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchemaDocument.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaDocument.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   load and validate a document
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.IO;
    using System.Xml.Schema;
    using System.Xml.XPath;

    /// <summary>
    /// Provides methods to load and validate an xml document
    /// </summary>
    public static class DBSchemaDocument
    {
        /// <summary>
        /// Load and validate the specified xml document
        /// </summary>
        /// <param name="xpathNavigator">An xpath navigator to the current node</param>
        /// <param name="xmlSchemaSet">The specified schema set for validation</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        public static XPathNavigator LoadDocument(XPathNavigator xpathNavigator, XmlSchemaSet xmlSchemaSet, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            using (StringReader stringReader = new StringReader(xpathNavigator.OuterXml))
            {
                return XmlHelper.Validate(stringReader, xmlSchemaSet, ignoreRestrictions, veh);
            }
        }

        /// <summary>
        /// Load and validate the specified xml document
        /// </summary>
        /// <param name="xpathNavigator">An xpath navigator to the current node</param>
        /// <param name="xsdFileName">The file name containing the xml schema</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        public static XPathNavigator LoadDocument(XPathNavigator xpathNavigator, string xsdFileName, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // load the schema set
            XmlSchemaSet xmlSchemaSet = XmlHelper.LoadSchemaSet(xsdFileName, veh);

            using (StringReader stringReader = new StringReader(xpathNavigator.OuterXml))
            {
                return XmlHelper.Validate(stringReader, xmlSchemaSet, ignoreRestrictions, veh);
            }
        }

        /// <summary>
        /// Load and validate the specified xml document
        /// </summary>
        /// <param name="fileName">The file name containing the xml data</param>
        /// <param name="xsdFileName">The file name containing the xml schema</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        public static XPathNavigator LoadDocument(string fileName, string xsdFileName, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // load the schema set
            XmlSchemaSet xmlSchemaSet = XmlHelper.LoadSchemaSet(xsdFileName, veh);

            // load the document
            return XmlHelper.LoadDocument(fileName, xmlSchemaSet, ignoreRestrictions, veh);
        }

        /// <summary>
        /// Load and validate the specified xml document
        /// </summary>
        /// <param name="fileName">The file name containing the xml data</param>
        /// <param name="xmlSchemaSet">The specified schema set for validation</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        public static XPathNavigator LoadDocument(string fileName, XmlSchemaSet xmlSchemaSet, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // load the document
            return XmlHelper.LoadDocument(fileName, xmlSchemaSet, ignoreRestrictions, veh);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchemaConstants.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaConstants.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents the constants for the assembly
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Represents the assembly constants
    /// </summary>
    internal static class DBSchemaConstants
    {
        /// <summary>
        /// The schema element name
        /// </summary>
        public static readonly string Name = "DBSchema";

        /// <summary>
        /// The config schema element name
        /// </summary>
        public static readonly string NameConfig = "DBSchemaConfig";

        /// <summary>
        /// The search condition schema element name
        /// </summary>
        public static readonly string NameSearchCondition = "DBSchemaSearchCondition";

        /// <summary>
        /// The schema namespace
        /// </summary>
        public static readonly string Namespace = "urn:dbschema";

        /// <summary>
        /// The config schema namespace
        /// </summary>
        public static readonly string NamespaceConfig = "urn:dbschema-config";

        /// <summary>
        /// The search condition schema namespace
        /// </summary>
        public static readonly string NamespaceSearchCondition = "urn:dbschema-searchcondition";

        /// <summary>
        /// The schema namespace
        /// </summary>
        public static readonly string NamespaceSchema = "http://www.w3.org/2001/XMLSchema";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchema.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchema.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   common library for working with the database schema
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchemaConfig.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaConfig.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   load, validate and parse config settings for generating schema
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;

    /// <summary>
    /// Represents the configuration settings that modify the schema generation
    /// </summary>
    public sealed class DBSchemaConfig
    {
        /// <summary>
        /// xmlSchemaSetConfig is the schema set to validate the config xml document
        /// </summary>
        private static XmlSchemaSet xmlSchemaSetConfig = XmlHelper.LoadSchemaSetFromResource("Config.xsd", DBSchemaConstants.NamespaceConfig);

        /// <summary>
        /// collectionExternalSchemaReferencesByType is the collection of external schema references by type
        /// </summary>
        private NameCollection<ExternalSchemaReferencesByType> collectionExternalSchemaReferencesByType = new NameCollection<ExternalSchemaReferencesByType>();

        /// <summary>
        /// collectionExternalSchemas is the collection of external schemas
        /// </summary>
        private NameCollection<ExternalSchema> collectionExternalSchemas = new NameCollection<ExternalSchema>();

        /// <summary>
        /// collectionLogicalObjects is the collection of logical objects
        /// </summary>
        private NameCollection<LogicalObject> collectionLogicalObjects = new NameCollection<LogicalObject>();

        /// <summary>
        /// collectionOptionalElements is the collection of elements that should be optional in the schema
        /// </summary>
        private NameCollection<string> collectionOptionalElements = new NameCollection<string>();

        /// <summary>
        /// collectionOptionalElements is the collection of elements optional by type
        /// </summary>
        private NameCollection<ElementsByType> collectionOptionalElementsByType = new NameCollection<ElementsByType>();

        /// <summary>
        /// collectionPublishSchemas is the collection of schemas to be published
        /// </summary>
        private NameCollection<PublishSchema> collectionPublishSchemas = new NameCollection<PublishSchema>();

        /// <summary>
        /// collectionSuppressElements is the collection of elements that should be suppressed from the schema
        /// </summary>
        private NameCollection<string> collectionSuppressElements = new NameCollection<string>();

        /// <summary>
        /// collectionSuppressElements is the collection of elements suppressed by type
        /// </summary>
        private NameCollection<ElementsByType> collectionSuppressElementsByType = new NameCollection<ElementsByType>();

        /// <summary>
        /// collectionSuppressTypes is the collection of regular expressions describing the type names that should be suppressed from the schema
        /// </summary>
        private NameCollection<string> collectionSuppressTypes = new NameCollection<string>();

        /// <summary>
        /// collectionTypeDependencies is the collection of a type dependencies
        /// </summary>
        private NameCollection<DatabaseObject> collectionTypeDependencies = new NameCollection<DatabaseObject>();

        /// <summary>
        /// collectionWarnings is the read only collection of warnings
        /// </summary>
        private ReadOnlyCollection<string> collectionWarnings = null;

        /// <summary>
        /// fileNameConfig is the absolute path of config file name
        /// </summary>
        private string fileNameConfig;

        /// <summary>
        /// listWarnings is the list of warnings encountered while loading the config settings
        /// </summary>
        private List<string> listWarnings = new List<string>();

        /// <summary>
        /// xpathNavigatorRoot is the config xml document
        /// </summary>
        private XPathNavigator xpathNavigatorRoot;

        /// <summary>
        /// xmlNamespaceManager is the XmlNamespaceManager object providing scope management for the config xml document
        /// </summary>
        private XmlNamespaceManager xmlNamespaceManager;

        /// <summary>
        /// Initializes a new instance of the DBSchemaConfig class
        /// </summary>
        public DBSchemaConfig()
        {
        }

        /// <summary>
        /// Gets the list of warnings that occurred while loading the config
        /// </summary>
        public ReadOnlyCollection<string> Warnings
        {
            get
            {
                if (null == this.collectionWarnings)
                {
                    this.collectionWarnings = new ReadOnlyCollection<string>(this.listWarnings);
                }

                return this.collectionWarnings;
            }
        }

        /// <summary>
        /// Gets the collection of logical objects
        /// </summary>
        internal NameCollection<LogicalObject> LogicalObjects
        {
            get { return this.collectionLogicalObjects; }
        }

        /// <summary>
        /// Gets the collection of schemas to be published
        /// </summary>
        internal NameCollection<PublishSchema> PublishSchemas
        {
            get { return this.collectionPublishSchemas; }
        }

        /// <summary>
        /// Gets the collection of type dependencies
        /// </summary>
        internal NameCollection<DatabaseObject> TypeDependencies
        {
            get { return this.collectionTypeDependencies; }
        }

        /// <summary>
        /// Loads, validates and parses the config file
        /// </summary>
        /// <param name="fileName">The config file to load</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        public void LoadConfig(string fileName, ValidationEventHandler veh)
        {
            // clear any existing config
            this.Clear();

            // load and validate the config
            this.xpathNavigatorRoot = XmlHelper.LoadDocument(Path.GetFullPath(fileName), xmlSchemaSetConfig, false, veh);

            // setup the namespace
            this.xmlNamespaceManager = new XmlNamespaceManager(this.xpathNavigatorRoot.NameTable);
            this.xmlNamespaceManager.AddNamespace("ns", DBSchemaConstants.NamespaceConfig);

            // validate the root element
            XPathNavigator xpathNavigatorElement = this.xpathNavigatorRoot.SelectSingleNode(".//ns:" + DBSchemaConstants.NameConfig, this.xmlNamespaceManager);
            if (null == xpathNavigatorElement)
            {
                throw new XmlSchemaValidationException("The XML root element or namespace is invalid.");
            }

            // set the config file name
            this.fileNameConfig = Path.GetFullPath(fileName);

            // parse the suppress types
            this.ParseSuppressTypes();

            // parse the suppress elements
            this.ParseSuppressElements();

            // parse the optional elements
            this.ParseOptionalElements();

            // parse the type dependencies
            this.ParseTypeDependencies();

            // parse the external schema references
            this.ParseExternalSchemaReferences();

            // parse the publish schemas
            this.ParsePublishSchemas();

            // parse the logical objects
            this.ParseLogicalObjects();
        }

        /// <summary>
        /// Checks if the specified element name has an external schema reference
        /// </summary>
        /// <param name="typeName">The specified type name</param>
        /// <param name="elementName">The specified element name</param>
        /// <returns>An ExternalSchemaReference object if the specified element name has an external schema reference; otherwise, null</returns>
        internal ExternalSchemaReference GetExternalSchemaReference(string typeName, string elementName)
        {
            ExternalSchemaReference externalSchemaReference = null;
            ExternalSchemaReferencesByType externalSchemaReferencesByType = this.collectionExternalSchemaReferencesByType[typeName];
            if (null != externalSchemaReferencesByType)
            {
                externalSchemaReference = externalSchemaReferencesByType.ExternalSchemaReferences[elementName];
            }

            return externalSchemaReference;
        }

        /// <summary>
        /// Checks if the specified element name is optional
        /// </summary>
        /// <param name="typeName">The specified type name</param>
        /// <param name="elementName">The specified element name</param>
        /// <returns>true if the specified element name is optional; otherwise, false</returns>
        internal bool IsElementOptional(string typeName, string elementName)
        {
            ElementsByType elementsByType = this.collectionOptionalElementsByType[typeName];
            if (null != elementsByType)
            {
                return elementsByType.Elements.Contains(elementName);
            }

            return this.collectionOptionalElements.Contains(elementName);
        }

        /// <summary>
        /// Checks if the specified element name is suppressed
        /// </summary>
        /// <param name="typeName">The specified type name</param>
        /// <param name="elementName">The specified element name</param>
        /// <returns>true if the specified element name is suppressed; otherwise, false</returns>
        internal bool IsElementSuppressed(string typeName, string elementName)
        {
            ElementsByType elementsByType = this.collectionSuppressElementsByType[typeName];
            if (null != elementsByType)
            {
                return elementsByType.Elements.Contains(elementName);
            }

            return this.collectionSuppressElements.Contains(elementName);
        }

        /// <summary>
        /// Checks if the specified type name is suppressed
        /// </summary>
        /// <param name="typeName">The specified type name</param>
        /// <returns>true if the specified type name is suppressed; otherwise, false</returns>
        internal bool IsTypeSuppressed(string typeName)
        {
            foreach (string regex in this.collectionSuppressTypes)
            {
                if (true == Regex.IsMatch(typeName, regex))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Validates the references of a logical object key
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="logicalObjectKey">The logical object key</param>
        private static void ValidateLogicalObjectKeyRefs(LogicalObject logicalObject, LogicalObjectKey logicalObjectKey)
        {
            // enumerate each key ref
            foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
            {
                if (logicalObjectKey.Fields.Count != logicalObjectKeyRef.Fields.Count)
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' Key/KeyRef '{1}' Fields do not match.", logicalObject.Name, logicalObjectKey.Selector));
                }

                // validate the key ref
                DBSchemaConfig.ValidateLogicalObjectSelector(logicalObject, logicalObjectKeyRef.Selector);
            }
        }

        /// <summary>
        /// Validates the keys of a logical object
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        private static void ValidateLogicalObjectKeys(LogicalObject logicalObject)
        {
            // enumerate each key
            foreach (LogicalObjectKey logicalObjectKey in logicalObject.Keys)
            {
                // validate the key
                DBSchemaConfig.ValidateLogicalObjectSelector(logicalObject, logicalObjectKey.Selector);

                // validate the key refs
                DBSchemaConfig.ValidateLogicalObjectKeyRefs(logicalObject, logicalObjectKey);
            }
        }

        /// <summary>
        /// Validates the logical object key/keyref selector
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="selector">The key/keyref selector</param>
        private static void ValidateLogicalObjectSelector(LogicalObject logicalObject, string selector)
        {
            // validate the selector
            if (false == logicalObject.Selectors.Contains(selector))
            {
                throw new InvalidOperationException(String.Format("Logical Object '{0}' does not contain specified Key/KeyRef Selector '{1}'.", logicalObject.Name, selector));
            }

            // split the selector into each individual selector
            string[] selectors = selector.Split('/');

            // validate each individual selector except the final selector refers to a logical object
            StringBuilder stringBuilderSelector = null;
            LogicalObject logicalObjectSelector = logicalObject;
            for (int index = 0; index < selectors.Length - 1; index++)
            {
                if (null == stringBuilderSelector)
                {
                    stringBuilderSelector = new StringBuilder();
                }
                else
                {
                    stringBuilderSelector.Append("/");
                }

                stringBuilderSelector.Append(selectors[index]);

                foreach (LogicalObjectInclude logicalObjectInclude in logicalObjectSelector.Includes)
                {
                    if (logicalObjectInclude.Name == selectors[index])
                    {
                        if (false == (logicalObjectInclude.SchemaObject is LogicalObject))
                        {
                            throw new InvalidOperationException(String.Format("Logical Object '{0}' Key/KeyRef Selector '{1}' is not an expected Logical Object.", logicalObject.Name, stringBuilderSelector.ToString()));
                        }

                        logicalObjectSelector = logicalObjectInclude.SchemaObject as LogicalObject;
                        break;
                    }
                }
            }

            // validate final selector refers to a table or procedure
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObjectSelector.Includes)
            {
                if (logicalObjectInclude.Name == selectors[selectors.Length - 1])
                {
                    if (null != logicalObjectInclude.SchemaObject)
                    {
                        throw new InvalidOperationException(String.Format("Logical Object '{0}' Key/KeyRef Selector '{1}' is not an expected Database Object.", logicalObject.Name, selector));
                    }
                }
            }
        }

        /// <summary>
        /// Clears the current config
        /// </summary>
        private void Clear()
        {
            this.collectionExternalSchemaReferencesByType.Clear();
            this.collectionExternalSchemas.Clear();
            this.collectionLogicalObjects.Clear();
            this.collectionOptionalElements.Clear();
            this.collectionOptionalElementsByType.Clear();
            this.collectionPublishSchemas.Clear();
            this.collectionSuppressElements.Clear();
            this.collectionSuppressElementsByType.Clear();
            this.collectionSuppressTypes.Clear();
            this.collectionTypeDependencies.Clear();
            this.fileNameConfig = null;
            this.listWarnings.Clear();
            this.xpathNavigatorRoot = null;
            this.xmlNamespaceManager = null;
        }

        /// <summary>
        /// Parses the external schema references from the config xml document
        /// </summary>
        private void ParseExternalSchemaReferences()
        {
            NameCollection<string> collectionInvalidSchemas = new NameCollection<string>();

            // get the external schema references by type
            XPathNodeIterator xpathNodeIteratorType = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:ExternalSchemaReferencesByType/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIteratorType.MoveNext())
            {
                string typeName = xpathNodeIteratorType.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManager).Value;

                ExternalSchemaReferencesByType externalSchemaReferencesByType = new ExternalSchemaReferencesByType(typeName);
                this.collectionExternalSchemaReferencesByType.Add(externalSchemaReferencesByType);

                // get the external schema references for this type
                XPathNodeIterator xpathNodeIteratorSchema = xpathNodeIteratorType.Current.Select("ns:ExternalSchemaReference", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorSchema.MoveNext())
                {
                    string elementName = xpathNodeIteratorSchema.Current.SelectSingleNode("ns:Element", this.xmlNamespaceManager).Value;
                    string fileName = xpathNodeIteratorSchema.Current.SelectSingleNode("ns:File", this.xmlNamespaceManager).Value;
                    string nodeName = xpathNodeIteratorSchema.Current.SelectSingleNode("ns:Node", this.xmlNamespaceManager).Value;

                    ExternalSchemaReference externalSchemaReference = new ExternalSchemaReference(elementName);
                    externalSchemaReferencesByType.ExternalSchemaReferences.Add(externalSchemaReference);

                    // check if the external schema has already been loaded
                    ExternalSchema externalSchema = this.collectionExternalSchemas[fileName];
                    if (null != externalSchema)
                    {
                        // set the external schema reference
                        externalSchemaReference.ExternalSchema = externalSchema;
                        externalSchemaReference.Node = externalSchema.GetName(nodeName);

                        continue;
                    }

                    // check if the external schema has already been determined to be invalid
                    if (true == collectionInvalidSchemas.Contains(fileName))
                    {
                        continue;
                    }

                    // load the external schema
                    externalSchema = new ExternalSchema();
                    List<string> listErrors = externalSchema.LoadSchemaSet(Path.GetDirectoryName(this.fileNameConfig), fileName);

                    if (0 == listErrors.Count)
                    {
                        // add the external schema to the collection
                        this.collectionExternalSchemas.Add(externalSchema);

                        // set the external schema reference
                        externalSchemaReference.ExternalSchema = externalSchema;
                        externalSchemaReference.Node = externalSchema.GetName(nodeName);
                    }
                    else
                    {
                        // add the list of schema errors to the list of config warnings
                        this.listWarnings.AddRange(listErrors);

                        // mark the external schema as invalid
                        collectionInvalidSchemas.Add(fileName);
                    }
                }
            }
        }

        /// <summary>
        /// Parses the logical object includes from the config xml node
        /// </summary>
        /// <param name="logicalObject">The LogicalObject object to which to add the includes</param>
        /// <param name="xpathNavigator">The config xml node</param>
        private void ParseLogicalObjectIncludes(LogicalObject logicalObject, XPathNavigator xpathNavigator)
        {
            XPathNodeIterator xpathNodeIterator = xpathNavigator.Select("ns:Includes/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the include type name
                string name = xpathNodeIterator.Current.Value;

                if (true == String.IsNullOrEmpty(name))
                {
                    continue;
                }

                // create the include object
                LogicalObjectInclude logicalObjectInclude = new LogicalObjectInclude(name);

                if (true == logicalObject.Includes.Contains(logicalObjectInclude))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' Includes '{1}' is defined multiple times.", logicalObject.Name, logicalObjectInclude.Name));
                }

                // get the min and max occurrences
                logicalObjectInclude.MinOccurs = xpathNodeIterator.Current.GetAttribute("minOccurs", String.Empty);
                logicalObjectInclude.MaxOccurs = xpathNodeIterator.Current.GetAttribute("maxOccurs", String.Empty);

                logicalObject.Includes.Add(logicalObjectInclude);
            }
        }

        /// <summary>
        /// Parses the logical object key ref hints from the config xml node
        /// </summary>
        /// <param name="logicalObject">The LogicalObject object to which to add the key ref hints</param>
        /// <param name="xpathNavigator">The config xml node</param>
        private void ParseLogicalObjectKeyRefHints(LogicalObject logicalObject, XPathNavigator xpathNavigator)
        {
            XPathNodeIterator xpathNodeIteratorKeyRefHint = xpathNavigator.Select("ns:KeyRefHints/ns:KeyRefHint", this.xmlNamespaceManager);
            while (true == xpathNodeIteratorKeyRefHint.MoveNext())
            {
                // get the selector
                string selector = xpathNodeIteratorKeyRefHint.Current.SelectSingleNode("ns:Selector", this.xmlNamespaceManager).Value;

                // create the key ref hint object
                LogicalObjectKeyRefHint logicalObjectKeyRefHint = new LogicalObjectKeyRefHint(selector);

                if (true == logicalObject.KeyRefHints.Contains(logicalObjectKeyRefHint))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' KeyRefHint '{1}' is defined multiple times.", logicalObject.Name, logicalObjectKeyRefHint.Name));
                }

                // get the fields
                XPathNodeIterator xpathNodeIteratorField = xpathNodeIteratorKeyRefHint.Current.Select("ns:Fields/ns:Field", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorField.MoveNext())
                {
                    logicalObjectKeyRefHint.Fields.Add(xpathNodeIteratorField.Current.Value);
                }

                logicalObject.KeyRefHints.Add(logicalObjectKeyRefHint);
            }
        }

        /// <summary>
        /// Parses the logical object key refs from the config xml node
        /// </summary>
        /// <param name="logicalObject">The LogicalObject object to which to add the keys</param>
        /// <param name="logicalObjectKey">The LogicalObjectKey object to which to add the key refs</param>
        /// <param name="xpathNavigator">The config xml node</param>
        private void ParseLogicalObjectKeyRefs(LogicalObject logicalObject, LogicalObjectKey logicalObjectKey, XPathNavigator xpathNavigator)
        {
            XPathNodeIterator xpathNodeIteratorKeyRef = xpathNavigator.Select("ns:KeyRefs/ns:KeyRef", this.xmlNamespaceManager);
            while (true == xpathNodeIteratorKeyRef.MoveNext())
            {
                // get the selector
                string selector = xpathNodeIteratorKeyRef.Current.SelectSingleNode("ns:Selector", this.xmlNamespaceManager).Value;

                // create the key ref object
                LogicalObjectKeyRef logicalObjectKeyRef = new LogicalObjectKeyRef("FK_Config", logicalObject.Name, selector);

                if (true == logicalObjectKey.KeyRefs.Contains(logicalObjectKeyRef))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' Key '{1}' KeyRef '{2}' is defined multiple times.", logicalObject.Name, logicalObjectKey.Name, logicalObjectKeyRef.Name));
                }

                logicalObjectKeyRef.Key = logicalObjectKey;

                // get the fields
                XPathNodeIterator xpathNodeIteratorField = xpathNodeIteratorKeyRef.Current.Select("ns:Fields/ns:Field", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorField.MoveNext())
                {
                    string field = xpathNodeIteratorField.Current.Value;

                    if (true == logicalObjectKeyRef.Fields.Contains(field))
                    {
                        throw new InvalidOperationException(String.Format("Logical Object '{0}' Key '{1}' KeyRef '{2}' Field '{3}' is defined multiple times.", logicalObject.Name, logicalObjectKey.Name, logicalObjectKeyRef.Name, field));
                    }

                    logicalObjectKeyRef.Fields.Add(field);
                }

                logicalObjectKey.KeyRefs.Add(logicalObjectKeyRef);
            }
        }

        /// <summary>
        /// Parses the logical object keys from the config xml node
        /// </summary>
        /// <param name="logicalObject">The LogicalObject object to which to add the keys</param>
        /// <param name="xpathNavigator">The config xml node</param>
        private void ParseLogicalObjectKeys(LogicalObject logicalObject, XPathNavigator xpathNavigator)
        {
            XPathNodeIterator xpathNodeIteratorKey = xpathNavigator.Select("ns:Keys/ns:Key", this.xmlNamespaceManager);
            while (true == xpathNodeIteratorKey.MoveNext())
            {
                // get the selector
                string selector = xpathNodeIteratorKey.Current.SelectSingleNode("ns:Selector", this.xmlNamespaceManager).Value;

                // create the key object
                LogicalObjectKey logicalObjectKey = new LogicalObjectKey("PK_Config", logicalObject.Name, selector);

                if (true == logicalObject.Keys.Contains(logicalObjectKey))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' Key '{1}' is defined multiple times.", logicalObject.Name, logicalObjectKey.Name));
                }

                // get the fields
                XPathNodeIterator xpathNodeIteratorField = xpathNodeIteratorKey.Current.Select("ns:Fields/ns:Field", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorField.MoveNext())
                {
                    string field = xpathNodeIteratorField.Current.Value;

                    if (true == logicalObjectKey.Fields.Contains(field))
                    {
                        throw new InvalidOperationException(String.Format("Logical Object '{0}' Key '{1}' Field '{2}' is defined multiple times.", logicalObject.Name, logicalObjectKey.Name, field));
                    }

                    logicalObjectKey.Fields.Add(field);
                }

                logicalObject.Keys.Add(logicalObjectKey);

                // parse the logical object key references
                this.ParseLogicalObjectKeyRefs(logicalObject, logicalObjectKey, xpathNodeIteratorKey.Current);
            }
        }

        /// <summary>
        /// Parses the logical objects from the config xml document
        /// </summary>
        private void ParseLogicalObjects()
        {
            // collectionLogicalObjectTypes is the collection of logical object types
            NameCollection<LogicalObject> collectionLogicalObjectTypes = new NameCollection<LogicalObject>();

            // get the logical object type
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:LogicalObjects/ns:Types/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the logical object name
                LogicalObject logicalObject = new LogicalObject(xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManager).Value);

                if (true == collectionLogicalObjectTypes.Contains(logicalObject))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' is defined multiple times.", logicalObject.Name));
                }

                collectionLogicalObjectTypes.Add(logicalObject);

                // parse the logical object includes
                this.ParseLogicalObjectIncludes(logicalObject, xpathNodeIterator.Current);

                // parse the logical object keys
                this.ParseLogicalObjectKeys(logicalObject, xpathNodeIterator.Current);

                // parse the logical object key ref hints
                this.ParseLogicalObjectKeyRefHints(logicalObject, xpathNodeIterator.Current);

                // parse the logical object search conditions
                XPathNavigator xpathNavigator = xpathNodeIterator.Current.SelectSingleNode("ns:DBSchemaSearchCondition", this.xmlNamespaceManager);
                if (null != xpathNavigator)
                {
                    logicalObject.SearchConditionCollection = SearchCondition.LoadSearchConditions(xpathNavigator, null);
                }
            }

            // get the logical object elements
            xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:LogicalObjects/ns:Elements/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the logical object
                LogicalObject logicalObject = collectionLogicalObjectTypes[xpathNodeIterator.Current.Value];

                if (null == logicalObject)
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' is not defined.", xpathNodeIterator.Current.Value));
                }

                // validate the logical object
                this.ValidateLogicalObject(logicalObject, collectionLogicalObjectTypes, new StackHelper());

                // add the logical object
                this.collectionLogicalObjects.Add(logicalObject);
            }
        }

        /// <summary>
        /// Parses the optional elements from the config xml document
        /// </summary>
        private void ParseOptionalElements()
        {
            // get the optional elements
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:OptionalElements/ns:Name", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                this.collectionOptionalElements.Add(xpathNodeIterator.Current.Value);
            }

            // get the optional elements by type
            xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:OptionalElementsByType/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                ElementsByType elementsByType = new ElementsByType(xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManager).Value);

                XPathNodeIterator xpathNodeIteratorElement = xpathNodeIterator.Current.Select("ns:OptionalElements/ns:Name", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorElement.MoveNext())
                {
                    elementsByType.Elements.Add(xpathNodeIteratorElement.Current.Value);
                }

                this.collectionOptionalElementsByType.Add(elementsByType);
            }
        }

        /// <summary>
        /// Parses the publish schemas from the config xml document
        /// </summary>
        private void ParsePublishSchemas()
        {
            // get the publish schemas
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:PublishSchemas/ns:Schema", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                PublishSchema publishSchema = new PublishSchema(xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManager).Value);

                if (true == this.collectionPublishSchemas.Contains(publishSchema))
                {
                    throw new InvalidOperationException(String.Format("PublishSchema Schema '{0}' is defined multiple times.", publishSchema.Name));
                }

                XPathNodeIterator xpathNodeIteratorElement = xpathNodeIterator.Current.Select("ns:Elements/ns:Name", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorElement.MoveNext())
                {
                    publishSchema.Elements.Add(xpathNodeIteratorElement.Current.Value);
                }

                this.collectionPublishSchemas.Add(publishSchema);
            }
        }

        /// <summary>
        /// Parses the suppress elements from the config xml document
        /// </summary>
        private void ParseSuppressElements()
        {
            // get the suppress elements
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:SuppressElements/ns:Name", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                this.collectionSuppressElements.Add(xpathNodeIterator.Current.Value);
            }

            // get the suppress elements by type
            xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:SuppressElementsByType/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                ElementsByType elementsByType = new ElementsByType(xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManager).Value);

                XPathNodeIterator xpathNodeIteratorElement = xpathNodeIterator.Current.Select("ns:SuppressElements/ns:Name", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorElement.MoveNext())
                {
                    elementsByType.Elements.Add(xpathNodeIteratorElement.Current.Value);
                }

                this.collectionSuppressElementsByType.Add(elementsByType);
            }
        }

        /// <summary>
        /// Parses the suppress types from the config xml document
        /// </summary>
        private void ParseSuppressTypes()
        {
            // get the suppress types by name
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:SuppressTypes/ns:Name", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                // add the name as a regex
                this.collectionSuppressTypes.Add("^" + xpathNodeIterator.Current.Value + "$");
            }

            // get the suppress types by regex
            xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:SuppressTypes/ns:Regex", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                this.collectionSuppressTypes.Add(xpathNodeIterator.Current.Value);
            }
        }

        /// <summary>
        /// Parses the type dependencies from the config xml document
        /// </summary>
        private void ParseTypeDependencies()
        {
            // get the type dependencies
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:" + DBSchemaConstants.NameConfig + "/ns:TypeDependencies/ns:Type", this.xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the schema and name
                string[] databaseObjectSplits = xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManager).Value.Split('.');
                string databaseObjectSchema = (1 == databaseObjectSplits.Length) ? "dbo" : databaseObjectSplits[0];
                string databaseObjectName = (1 == databaseObjectSplits.Length) ? databaseObjectSplits[0] : databaseObjectSplits[1];

                DatabaseObject databaseObject = new DatabaseObject(databaseObjectSchema, databaseObjectName);

                XPathNodeIterator xpathNodeIteratorElement = xpathNodeIterator.Current.Select("ns:DependsOn/ns:Name", this.xmlNamespaceManager);
                while (true == xpathNodeIteratorElement.MoveNext())
                {
                    // get the schema and name
                    string[] databaseObjectDependsOnSplits = xpathNodeIteratorElement.Current.Value.Split('.');
                    string databaseObjectDependsOnSchema = (1 == databaseObjectDependsOnSplits.Length) ? "dbo" : databaseObjectDependsOnSplits[0];
                    string databaseObjectDependsOnName = (1 == databaseObjectDependsOnSplits.Length) ? databaseObjectDependsOnSplits[0] : databaseObjectDependsOnSplits[1];

                    databaseObject.DependsOn.Add(new DatabaseObject(databaseObjectDependsOnSchema, databaseObjectDependsOnName));
                }

                this.collectionTypeDependencies.Add(databaseObject);
            }
        }

        /// <summary>
        /// Validates the logical object
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="collectionLogicalObjectTypes">The collection of logical object types</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        private void ValidateLogicalObject(LogicalObject logicalObject, NameCollection<LogicalObject> collectionLogicalObjectTypes, StackHelper stackHelper)
        {
            // check if this logical object has already been validated
            if (0 != logicalObject.Selectors.Count)
            {
                return;
            }

            // check if this logical object causes a circular dependency
            if (true == stackHelper.Contains(logicalObject.Name))
            {
                throw new InvalidOperationException(String.Format("Logical Object '{0}' has a circular dependency at '{1}'.", stackHelper.GetRoot(), stackHelper.ToString()));
            }

            // add this type to the stack
            stackHelper.Push(logicalObject.Name);

            // validate the includes
            this.ValidateLogicalObjectIncludes(logicalObject, collectionLogicalObjectTypes, stackHelper);

            // validate the keys
            DBSchemaConfig.ValidateLogicalObjectKeys(logicalObject);

            stackHelper.Pop();
        }

        /// <summary>
        /// Validates the included types of a logical object
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="collectionLogicalObjectTypes">The collection of logical object types</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        private void ValidateLogicalObjectIncludes(LogicalObject logicalObject, NameCollection<LogicalObject> collectionLogicalObjectTypes, StackHelper stackHelper)
        {
            // enumerate each included type
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                // check if this is a logical object
                LogicalObject logicalObjectType = collectionLogicalObjectTypes[logicalObjectInclude.Name];

                if (null != logicalObjectType)
                {
                    // validate the logical object
                    this.ValidateLogicalObject(logicalObjectType, collectionLogicalObjectTypes, stackHelper);

                    // add this object's selectors to the selectors
                    foreach (string selector in logicalObjectType.Selectors)
                    {
                        logicalObject.Selectors.Add(logicalObjectType.Name + "/" + selector);
                    }

                    // iterate the object's search conditions and add to the search conditions
                    foreach (SearchCondition searchCondition in logicalObjectType.SearchConditionCollection)
                    {
                        SearchCondition searchConditionParent = new SearchCondition();
                        searchConditionParent.InheritChild(logicalObject.Name, logicalObjectType.Name, searchCondition);

                        logicalObject.SearchConditionCollection.Add(searchConditionParent);
                    }

                    // set the schema object with this logical object
                    logicalObjectInclude.SchemaObject = logicalObjectType;
                }
                else
                {
                    // add this object to the selectors
                    logicalObject.Selectors.Add(logicalObjectInclude.Name);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\ExternalSchemaReferencesByType.cs ===
//-----------------------------------------------------------------------
// <copyright file="ExternalSchemaReferencesByType.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents the external schema references for a type
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Represents a type and its collection of references to external schemas
    /// </summary>
    internal sealed class ExternalSchemaReferencesByType
    {
        /// <summary>
        /// collectionExternalSchemaReferences is the collection of external schema references for this type
        /// </summary>
        private NameCollection<ExternalSchemaReference> collectionExternalSchemaReferences = new NameCollection<ExternalSchemaReference>();

        /// <summary>
        /// The name for this type
        /// </summary>
        private string name;

        /// <summary>
        /// Initializes a new instance of the ExternalSchemaReferencesByType class with the specified object name
        /// </summary>
        /// <param name="name">The specified object name</param>
        public ExternalSchemaReferencesByType(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Gets the collection of external schema references for this type
        /// </summary>
        public NameCollection<ExternalSchemaReference> ExternalSchemaReferences
        {
            get { return this.collectionExternalSchemaReferences; }
        }

        /// <summary>
        /// Gets the name for this element
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\ExternalSchemaReference.cs ===
//-----------------------------------------------------------------------
// <copyright file="ExternalSchemaReference.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents the external schema reference for an element
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Represents an element and its reference to an external schema
    /// </summary>
    internal sealed class ExternalSchemaReference
    {
        /// <summary>
        /// The external schema for this element
        /// </summary>
        private ExternalSchema externalSchema;

        /// <summary>
        /// The name for this element
        /// </summary>
        private string name;

        /// <summary>
        /// The schema node for this element
        /// </summary>
        private string node;

        /// <summary>
        /// Initializes a new instance of the ExternalSchemaReference class with the specified element name
        /// </summary>
        /// <param name="name">The specified element name</param>
        public ExternalSchemaReference(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Gets or sets the external schema for this element
        /// </summary>
        public ExternalSchema ExternalSchema
        {
            get { return this.externalSchema; }
            set { this.externalSchema = value; }
        }

        /// <summary>
        /// Gets the name for this element
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets or sets the node for this element
        /// </summary>
        public string Node
        {
            get { return this.node; }
            set { this.node = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchemaType.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaType.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   specify the type of schema object
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Enum to specify the type of schema object: unknown, schema, table, stored procedure, logical object
    /// </summary>
    public enum DBSchemaType
    {
        /// <summary>
        /// Unknown Type
        /// </summary>
        Unknown,

        /// <summary>
        /// Schema Type
        /// </summary>
        Schema,

        /// <summary>
        /// Database Table Type
        /// </summary>
        Table,

        /// <summary>
        /// Database Stored Procedure Type
        /// </summary>
        StoredProcedure,

        /// <summary>
        /// Logical Object Type
        /// </summary>
        LogicalObject
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\ElementsByType.cs ===
//-----------------------------------------------------------------------
// <copyright file="ElementsByType.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a type and its elements
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Represents a type and its collection of elements 
    /// </summary>
    internal sealed class ElementsByType
    {
        /// <summary>
        /// The collection of elements for this object
        /// </summary>
        private NameCollection<string> collectionElements = new NameCollection<string>();

        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// Initializes a new instance of the ElementsByType class with the specified object name
        /// </summary>
        /// <param name="name">The specified object name</param>
        public ElementsByType(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Gets the list of elements for this object
        /// </summary>
        public NameCollection<string> Elements
        {
            get { return this.collectionElements; }
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchemaTransaction.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaTransaction.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents the sql transaction to be made to the sql database
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Data;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;

    /// <summary>
    /// Represents the sql transaction to be made to the sql database
    /// </summary>
    public sealed class DBSchemaTransaction
    {
        /// <summary>
        /// dbSchemaSet is the db schema set
        /// </summary>
        private DBSchemaSet dbSchemaSet;

        /// <summary>
        /// collectionSearchConditions is the collection of search conditions
        /// </summary>
        private SearchConditionCollection collectionSearchConditionsRoot;

        /// <summary>
        /// includeNullElements specifies if null elements should be included in the select condition
        /// </summary>
        private bool includeNullElements;

        /// <summary>
        /// timeout is the sql command timeout
        /// </summary>
        private int timeout = 30;

        /// <summary>
        /// transactionResult is the transaction result
        /// </summary>
        private TransactionResult transactionResultRoot;

        /// <summary>
        /// xpathNavigator is the xml document
        /// </summary>
        private XPathNavigator xpathNavigatorRoot;

        /// <summary>
        /// Initializes a new instance of the DBSchemaTransaction class
        /// </summary>
        /// <param name="dbSchemaSet">The db schema set for this transaction</param>
        /// <param name="xpathNavigator">The xpath navigator of the xml document</param>
        internal DBSchemaTransaction(DBSchemaSet dbSchemaSet, XPathNavigator xpathNavigator)
        {
            this.dbSchemaSet = dbSchemaSet;

            // get the root element
            this.xpathNavigatorRoot = xpathNavigator.SelectSingleNode(".//" + DBSchemaConstants.Name);
        }

        /// <summary>
        /// Initializes a new instance of the DBSchemaTransaction class
        /// </summary>
        /// <param name="dbSchemaSet">The db schema set for this transaction</param>
        /// <param name="collectionSearchConditions">The collection of search conditions</param>
        internal DBSchemaTransaction(DBSchemaSet dbSchemaSet, SearchConditionCollection collectionSearchConditions)
        {
            this.dbSchemaSet = dbSchemaSet;
            this.collectionSearchConditionsRoot = collectionSearchConditions;
        }

        /// <summary>
        /// Enum to specify the type of sql transaction action: execute or delete
        /// </summary>
        private enum Action
        {
            /// <summary>
            /// Select Action
            /// </summary>
            Select,

            /// <summary>
            /// Execute Action
            /// </summary>
            Execute,

            /// <summary>
            /// Delete Action
            /// </summary>
            Delete
        }

        /// <summary>
        /// Gets or sets the value to include null elements in the select condition
        /// </summary>
        public bool IncludeNullElements
        {
            get { return this.includeNullElements; }
            set { this.includeNullElements = value; }
        }

        /// <summary>
        /// Gets the collection of transaction results for this object
        /// </summary>
        public ReadOnlyCollection<TransactionResult> Results
        {
            get { return this.transactionResultRoot.Results; }
        }

        /// <summary>
        /// Gets or sets the timeout value for the transaction
        /// </summary>
        public int Timeout
        {
            get { return this.timeout; }
            set { this.timeout = value; }
        }

        /// <summary>
        /// Perform a series of delete sql transactions against the specified xml document or collection of search conditions
        /// </summary>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        public void Delete(TransactionEventHandler teh, object context)
        {
            this.Clear();

            if (null != this.xpathNavigatorRoot)
            {
                this.TransactDocument(Action.Delete, teh, context);
            }
            else
            {
                this.DeleteSearchConditions(teh, context);
            }
        }

        /// <summary>
        /// Perform a series of sql transactions (insert, update or execute) against the specified xml document
        /// </summary>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        public void Execute(TransactionEventHandler teh, object context)
        {
            this.Clear();

            this.TransactDocument(Action.Execute, teh, context);
        }

        /// <summary>
        /// Perform a series of select sql transactions against the specified collection of search conditions
        /// </summary>
        /// <param name="fileName">The file to which to write</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        public void Select(string fileName, TransactionEventHandler teh, object context)
        {
            this.Clear();

            // set up the xml file to write the xml data to
            using (StreamWriter streamWriter = new StreamWriter(fileName, false, System.Text.Encoding.UTF8))
            {
                this.Select(streamWriter, teh, context);
            }
        }

        /// <summary>
        /// Perform a series of select sql transactions against the specified collection of search conditions
        /// </summary>
        /// <param name="stream">The specified stream against which to write</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        public void Select(Stream stream, TransactionEventHandler teh, object context)
        {
            this.Clear();

            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Indent = true;

            using (XmlWriter xmlWriter = XmlWriter.Create(stream, xmlWriterSettings))
            {
                this.Select(xmlWriter, teh, context);
            }
        }

        /// <summary>
        /// Perform a series of select sql transactions against the specified collection of search conditions
        /// </summary>
        /// <param name="textWriter">The specified text writer against which to write</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        public void Select(TextWriter textWriter, TransactionEventHandler teh, object context)
        {
            this.Clear();

            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Indent = true;

            using (XmlWriter xmlWriter = XmlWriter.Create(textWriter, xmlWriterSettings))
            {
                this.Select(xmlWriter, teh, context);
            }
        }

        /// <summary>
        /// Executes the specified sql command to execute the specified stored procedure
        /// </summary>
        /// <param name="sqlCommandBuilder">The sql command builder object specifying the sql command</param>
        /// <param name="timeout">The timeout value of the sql command</param>
        /// <param name="transactionResult">The transaction result object to populate with the result</param>
        private static void ExecuteProcedure(SqlCommandBuilder sqlCommandBuilder, int timeout, TransactionResult transactionResult)
        {
            transactionResult.Action = SqlAction.Execute;

            // get the sql command
            SqlCommand sqlCommand = sqlCommandBuilder.GetSqlCommand(SqlAction.Execute);
            sqlCommand.CommandTimeout = timeout;

            // create the sql parameter for the return value
            SqlParameter sqlParameterReturnValue = new SqlParameter("@RETURN_VALUE", SqlDbType.Int);
            sqlParameterReturnValue.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(sqlParameterReturnValue);

            try
            {
                // execute the sql command
                SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                // create the new data set
                DataSet dataSet = new DataSet();
                dataSet.Locale = CultureInfo.InvariantCulture;

                do
                {
                    // create the new table for the results
                    DataTable dataTableResults = new DataTable();
                    dataTableResults.Locale = CultureInfo.InvariantCulture;

                    // create the columns
                    for (int field = 0; field < sqlDataReader.FieldCount; field++)
                    {
                        dataTableResults.Columns.Add(sqlDataReader.GetName(field), sqlDataReader.GetFieldType(field));
                    }

                    // check if this is an xml result
                    StringBuilder stringBuilder = null;
                    DataRow dataRowResult = null;

                    if ((1 == sqlDataReader.FieldCount) && (true == Regex.IsMatch(sqlDataReader.GetName(0), @"^XML_[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")))
                    {
                        // this is an xml result
                        stringBuilder = new StringBuilder();
                        dataRowResult = dataTableResults.NewRow();
                    }

                    // read each row and add to the table
                    while (true == sqlDataReader.Read())
                    {
                        if (null == stringBuilder)
                        {
                            dataRowResult = dataTableResults.NewRow();
                        }

                        // read each column and add to the row
                        for (int field = 0; field < sqlDataReader.FieldCount; field++)
                        {
                            if (null == stringBuilder)
                            {
                                dataRowResult[field] = sqlDataReader[field];
                            }
                            else
                            {
                                stringBuilder.Append(sqlDataReader.GetString(field));
                            }
                        }

                        // add to the table
                        if (null == stringBuilder)
                        {
                            dataTableResults.Rows.Add(dataRowResult);
                        }
                    }

                    // add the results table to the result set, if necessaru
                    if (0 < dataTableResults.Columns.Count)
                    {
                        dataSet.Tables.Add(dataTableResults);
                    }

                    // if this is an xml result, populate the row and add to the table
                    if (null != stringBuilder)
                    {
                        dataRowResult[0] = stringBuilder.ToString();
                        dataTableResults.Rows.Add(dataRowResult);
                    }
                } while (true == sqlDataReader.NextResult());

                // create the new table for the outputs
                DataTable dataTableOutputs = new DataTable("Outputs");
                dataTableOutputs.Locale = CultureInfo.InvariantCulture;

                // create the new row for the outputs
                DataRow dataRowOutputs = dataTableOutputs.NewRow();
                dataTableOutputs.Rows.Add(dataRowOutputs);

                // iterate the sql parameters for outputs
                foreach (SqlParameter sqlParameter in sqlCommand.Parameters)
                {
                    if ((ParameterDirection.Input == sqlParameter.Direction) || (ParameterDirection.ReturnValue == sqlParameter.Direction))
                    {
                        continue;
                    }

                    // create the column
                    dataTableOutputs.Columns.Add(sqlParameter.ParameterName);

                    // add the value
                    dataRowOutputs[sqlParameter.ParameterName] = sqlParameter.Value;
                }

                // add the outputs table to the result set, if necessary
                if (0 < dataTableOutputs.Columns.Count)
                {
                    dataSet.Tables.Add(dataTableOutputs);
                }

                // add the data set, if necessary
                if (0 < dataSet.Tables.Count)
                {
                    transactionResult.DataSet = dataSet;
                }

                sqlDataReader.Close();

                transactionResult.Result = Convert.ToInt32(sqlParameterReturnValue.Value);
            }
            catch (SqlException ex)
            {
                transactionResult.Exception = ex;
            }
        }

        /// <summary>
        /// Performs an xpath expression to select the elements of the key reference based on the element of the key
        /// </summary>
        /// <param name="xpathNavigator">The previously queried key reference element</param>
        /// <param name="logicalObjectKeyRef">The logical object key reference</param>
        /// <param name="xpathNodeIterator">The xpath node iterator object to iterate the elements of the key</param>
        /// <param name="xmlNamespaceManager">The xml namespace manager for namespace resolution of the xpath node iterator object</param>
        private static XPathNavigator SelectLogicalObjectKeyRefsFromElement(XPathNavigator xpathNavigator, LogicalObjectKeyRef logicalObjectKeyRef, XPathNodeIterator xpathNodeIterator, XmlNamespaceManager xmlNamespaceManager)
        {
            // get the logical object key
            LogicalObjectKey logicalObjectKey = logicalObjectKeyRef.Key;

            // stringBuilderInner is the outer xpath expression
            StringBuilder stringBuilderOuter = null;

            while (true == xpathNodeIterator.MoveNext())
            {
                // stringBuilder is the inner xpath expression
                StringBuilder stringBuilderInner = null;

                // check for key references that use the same selector
                foreach (LogicalObjectKeyRef logicalObjectKeyRefOther in logicalObjectKey.KeyRefs)
                {
                    if (logicalObjectKeyRef != logicalObjectKeyRefOther)
                    {
                        continue;
                    }

                    // get the logical object key
                    for (int index = 0; index < logicalObjectKey.Fields.Count; index++)
                    {
                        string fieldKey = logicalObjectKey.Fields[index];
                        string fieldKeyRef = logicalObjectKeyRefOther.Fields[index];

                        // get the value
                        string value = xpathNodeIterator.Current.SelectSingleNode("ns:" + fieldKey, xmlNamespaceManager).Value;

                        // add to the xpath expressions
                        if (null == stringBuilderInner)
                        {
                            stringBuilderInner = new StringBuilder();
                        }
                        else
                        {
                            stringBuilderInner.Append(" and ");
                        }

                        stringBuilderInner.Append("ns:" + fieldKeyRef + " = \"" + value + "\"");
                    }
                }

                // append this xpath expression to the inner xpath expression
                if (null == stringBuilderOuter)
                {
                    stringBuilderOuter = stringBuilderInner;
                }
                else
                {
                    stringBuilderOuter.Append(" or " + stringBuilderInner.ToString());
                }
            }

            // execute the xpath expressions
            XPathNodeIterator xpathNodeIteratorElements = xpathNavigator.Select(".//ns:" + DBSchemaConstants.Name + "/ns:" + logicalObjectKeyRef.DatabaseObjectName + "[" + stringBuilderOuter.ToString() + "]", xmlNamespaceManager);

            // return the new xpath navigator
            return XmlHelper.WriteXPathNodeIterator(xpathNodeIteratorElements, DBSchemaConstants.Name, DBSchemaConstants.Namespace);
        }

        /// <summary>
        /// Executes the specified sql command to insert, update, or delete the specified data
        /// </summary>
        /// <param name="sqlCommandBuilder">The sql command build object specifying the sql command</param>
        /// <param name="transactionResult">The transaction result object to populate with the result</param>
        /// <param name="sqlAction">The sql action to perform (insert, update, or delete)</param>
        private static void TransactTable(SqlCommandBuilder sqlCommandBuilder, int timeout, TransactionResult transactionResult, SqlAction sqlAction)
        {
            transactionResult.Action = sqlAction;

            // get the sql command
            SqlCommand sqlCommand = sqlCommandBuilder.GetSqlCommand(sqlAction);
            sqlCommand.CommandTimeout = timeout;

            try
            {
                // execute the sql command
                SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                while (true == sqlDataReader.Read())
                {
                    transactionResult.Result = sqlDataReader.GetInt32(0);
                }

                sqlDataReader.Close();
            }
            catch (SqlException ex)
            {
                transactionResult.Exception = ex;
            }
        }

        /// <summary>
        /// Writes the logical object to the specified xml writer
        /// </summary>
        /// <param name="xmlWriter">The xml writer instance to write the xml data</param>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        /// <param name="dictionaryElements">The dictionary of selectors already resolved to xml elements</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private static void WriteLogicalObject(XmlWriter xmlWriter, LogicalObject logicalObject, StackHelper stackHelper, List<string> listToWrite, List<string> listWritten, Dictionary<string, XPathNavigator> dictionaryElements, TransactionResult transactionResult, TransactionEventHandler teh, object context)
        {
            // create a new transaction result object
            TransactionResult transactionResultLogicalObject = transactionResult.AddResult(logicalObject.Name);
            transactionResultLogicalObject.SchemaType = DBSchemaType.LogicalObject;

            // begin
            if (null != teh)
            {
                teh(transactionResultLogicalObject, context);
            }

            // add the start element
            listToWrite.Add(logicalObject.Name);

            // iterate the includes
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                if (true == (logicalObjectInclude.SchemaObject is DatabaseTable))
                {
                    // get the element for this selector
                    XPathNavigator xpathNavigator = dictionaryElements[stackHelper.ToString() + logicalObjectInclude.Name];

                    // create the namespace manager
                    XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xpathNavigator.NameTable);
                    xmlNamespaceManager.AddNamespace("ns", DBSchemaConstants.Namespace);

                    // get the list of elements
                    XPathNodeIterator xpathNodeIterator = xpathNavigator.Select(".//ns:" + DBSchemaConstants.Name + "/ns:" + logicalObjectInclude.Name, xmlNamespaceManager);
                    if (0 == xpathNodeIterator.Count)
                    {
                        continue;
                    }

                    // write all start elements in the to write list
                    foreach (string startElement in listToWrite)
                    {
                        xmlWriter.WriteStartElement(startElement);
                        listWritten.Add(startElement);
                    }

                    // clear the to write list
                    listToWrite.Clear();

                    // create a new transaction result object
                    TransactionResult transactionResultElement = transactionResultLogicalObject.AddResult(logicalObjectInclude.Name);
                    transactionResultElement.SchemaType = DBSchemaType.Table;

                    // begin
                    if (null != teh)
                    {
                        teh(transactionResultElement, context);
                    }

                    // write the element
                    while (true == xpathNodeIterator.MoveNext())
                    {
                        xmlWriter.WriteNode(xpathNodeIterator.Current, false);
                    }

                    // end
                    transactionResultElement.Action = SqlAction.Select;
                    transactionResultElement.Result = xpathNodeIterator.Count;

                    if (null != teh)
                    {
                        teh(transactionResultElement, context);
                    }
                }
                else
                {
                    stackHelper.Push(logicalObjectInclude.Name);

                    DBSchemaTransaction.WriteLogicalObject(xmlWriter, logicalObjectInclude.SchemaObject as LogicalObject, stackHelper, listToWrite, listWritten, dictionaryElements, transactionResultLogicalObject, teh, context);

                    stackHelper.Pop();
                }
            }

            if ((0 < listWritten.Count) && (logicalObject.Name == listWritten[listWritten.Count - 1]))
            {
                // write the end element
                xmlWriter.WriteEndElement();
                listWritten.RemoveAt(listWritten.Count - 1);
            }

            if ((0 < listToWrite.Count) && (logicalObject.Name == listToWrite[listToWrite.Count - 1]))
            {
                // remove the start element
                listToWrite.RemoveAt(listToWrite.Count - 1);
            }

            // end
            transactionResultLogicalObject.Action = SqlAction.End;

            if (null != teh)
            {
                teh(transactionResultLogicalObject, context);
            }
        }

        /// <summary>
        /// Clears the current transaction
        /// </summary>
        private void Clear()
        {
            this.transactionResultRoot = new TransactionResult(DBSchemaConstants.Name, DBSchemaType.Schema);
        }

        /// <summary>
        /// Perform a series of delete sql transactions against the specified collection of search conditions
        /// </summary>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private void DeleteSearchConditions(TransactionEventHandler teh, object context)
        {
            // open the sql connection
            using (SqlConnection sqlConnection = new SqlConnection(this.dbSchemaSet.ConnectionString))
            {
                sqlConnection.Open();

                // iterate all schema objects
                foreach (SchemaObject schemaObject in this.dbSchemaSet.SchemaObjectsReverse)
                {
                    // get the search condition matching the current schema object
                    SearchCondition searchCondition = this.collectionSearchConditionsRoot[schemaObject.Name];

                    if (null == searchCondition)
                    {
                        continue;
                    }

                    if (true == (schemaObject is DatabaseTable))
                    {
                        // create a new transaction result object
                        TransactionResult transactionResult = this.transactionResultRoot.AddResult(schemaObject.Name);

                        // notify the callback of the begin
                        if (null != teh)
                        {
                            teh(transactionResult, context);
                        }

                        // build the sql command
                        SqlCommandBuilder sqlCommandBuilder = new SqlCommandBuilder(sqlConnection, null, schemaObject as DatabaseTable, searchCondition);

                        // try the transaction
                        DBSchemaTransaction.TransactTable(sqlCommandBuilder, this.timeout, transactionResult, SqlAction.Delete);

                        // notify the callback of the end
                        if (null != teh)
                        {
                            teh(transactionResult, context);
                        }
                    }
                    else
                    {
                        // select the logical object
                        StringBuilder stringBuilder = new StringBuilder();
                        using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
                        {
                            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                            xmlWriterSettings.Indent = true;

                            using (XmlWriter xmlWriter = XmlWriter.Create(stringWriterUTF8, xmlWriterSettings))
                            {
                                DBSchemaTransaction dbSchemaTransactionSelect = new DBSchemaTransaction(this.dbSchemaSet, this.collectionSearchConditionsRoot);
                                dbSchemaTransactionSelect.Select(xmlWriter, null, null);
                            }
                        }

                        // delete the logical object
                        DBSchemaTransaction dbSchemaTransactionDelete = new DBSchemaTransaction(this.dbSchemaSet, XmlHelper.GetNavigator(stringBuilder.ToString()));
                        dbSchemaTransactionDelete.Delete(teh, context);

                        this.transactionResultRoot = dbSchemaTransactionDelete.transactionResultRoot;
                    }
                }
            }
        }

        /// <summary>
        /// Perform a series of select sql transactions against the specified collection of search conditions
        /// </summary>
        /// <param name="xmlWriter">The xml writer instance to write the xml data</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private void Select(XmlWriter xmlWriter, TransactionEventHandler teh, object context)
        {
            // open the sql connection
            using (SqlConnection sqlConnection = new SqlConnection(this.dbSchemaSet.ConnectionString))
            {
                sqlConnection.Open();

                // write the start element
                xmlWriter.WriteStartElement(DBSchemaConstants.Name, DBSchemaConstants.Namespace);

                // iterate all search conditions
                foreach (SearchCondition searchCondition in this.collectionSearchConditionsRoot)
                {
                    // get the schema object
                    SchemaObject schemaObject = this.dbSchemaSet.GetSchemaObject(searchCondition.SchemaObjectName);

                    if (true == (schemaObject is DatabaseTable))
                    {
                        this.SelectTable(this.transactionResultRoot, sqlConnection, this.timeout, schemaObject as DatabaseTable, searchCondition, xmlWriter, teh, context);
                    }
                    else
                    {
                        // get the logical object
                        LogicalObject logicalObject = schemaObject as LogicalObject;

                        // seed the logical object
                        XPathNodeIterator xpathNodeIterator = this.SelectLogicalObjectSeed(sqlConnection, schemaObject as LogicalObject, searchCondition);
                        while (true == xpathNodeIterator.MoveNext())
                        {
                            // create the dictionary of queried elements
                            Dictionary<string, XPathNavigator> dictionaryElements = new Dictionary<string, XPathNavigator>();
                            dictionaryElements[logicalObject.SearchCondition.Name] = XmlHelper.ImportNavigator(xpathNodeIterator.Current, DBSchemaConstants.Name, DBSchemaConstants.Namespace);

                            int count = 0;
                            do
                            {
                                count = dictionaryElements.Count;
                                this.SelectLogicalObject(sqlConnection, logicalObject.Name, logicalObject.SearchConditionCollection, logicalObject, new StackHelper(), dictionaryElements);
                            } while (count < dictionaryElements.Count);

                            // write the logical object
                            DBSchemaTransaction.WriteLogicalObject(xmlWriter, logicalObject, new StackHelper(), new List<string>(), new List<string>(), dictionaryElements, this.transactionResultRoot, teh, context);
                        }
                    }
                }

                // write the end element
                xmlWriter.WriteEndElement();
            }
        }

        /// <summary>
        /// Performs a series of sql transactions to select the elements of the logical object
        /// </summary>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="logicalObjectName">The name of the root logical object</param>
        /// <param name="collectionSearchConditions">The collection of search conditions that limits the query beyond the root search condition</param>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        /// <param name="dictionaryElements">The dictionary of selectors already resolved to xml elements</param>
        private void SelectLogicalObject(SqlConnection sqlConnection, string logicalObjectName, SearchConditionCollection collectionSearchConditions, LogicalObject logicalObject, StackHelper stackHelper, Dictionary<string, XPathNavigator> dictionaryElements)
        {
            // get the string representation of the previously encountered logical objects
            string stack = stackHelper.ToString();

            // iterate the keys
            foreach (LogicalObjectKey logicalObjectKey in logicalObject.Keys)
            {
                // check if the key has already been queried
                if (true == dictionaryElements.ContainsKey(stack + logicalObjectKey.Selector))
                {
                    this.SelectLogicalObjectKeyRefs(sqlConnection, logicalObjectName, collectionSearchConditions, logicalObjectKey, stackHelper, dictionaryElements);
                }
                else
                {
                    // check if any key refs have already been reached
                    foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
                    {
                        if (true == dictionaryElements.ContainsKey(stack + logicalObjectKeyRef.Selector))
                        {
                            this.SelectLogicalObjectKey(sqlConnection, logicalObjectName, collectionSearchConditions, logicalObjectKeyRef, stackHelper, dictionaryElements);
                        }
                    }
                }
            }

            // iterate the includes
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                if (true == (logicalObjectInclude.SchemaObject is LogicalObject))
                {
                    stackHelper.Push(logicalObjectInclude.Name);

                    this.SelectLogicalObject(sqlConnection, logicalObjectName, collectionSearchConditions, logicalObjectInclude.SchemaObject as LogicalObject, stackHelper, dictionaryElements);

                    stackHelper.Pop();
                }
            }
        }

        /// <summary>
        /// Performs a sql transaction to select the element of the key based on the element of the key reference
        /// </summary>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="logicalObjectName">The name of the root logical object</param>
        /// <param name="collectionSearchConditions">The collection of search conditions that limits the query beyond the root search condition</param>
        /// <param name="logicalObjectKeyRef">The logical object key reference</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        /// <param name="dictionaryElements">The dictionary of selectors already resolved to xml elements</param>
        private void SelectLogicalObjectKey(SqlConnection sqlConnection, string logicalObjectName, SearchConditionCollection collectionSearchConditions, LogicalObjectKeyRef logicalObjectKeyRef, StackHelper stackHelper, Dictionary<string, XPathNavigator> dictionaryElements)
        {
            // get the string representation of the previously encountered logical objects
            string stack = stackHelper.ToString();

            // get the xpath navigator
            XPathNavigator xpathNavigator = dictionaryElements[stack + logicalObjectKeyRef.Selector];

            // create the namespace manager
            XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xpathNavigator.NameTable);
            xmlNamespaceManager.AddNamespace("ns", DBSchemaConstants.Namespace);

            // check if this is a non-empty element
            XPathNodeIterator xpathNodeIterator = xpathNavigator.Select(".//ns:" + DBSchemaConstants.Name + "/ns:" + logicalObjectKeyRef.DatabaseObjectName, xmlNamespaceManager);
            if (0 == xpathNodeIterator.Count)
            {
                return;
            }

            // get the logical object key
            LogicalObjectKey logicalObjectKey = logicalObjectKeyRef.Key;
            string logicalObjectKeySelector = stack + logicalObjectKey.Selector;

            // build the inner search condition
            SearchCondition searchConditionInner = null;

            // iterate each available element
            while (true == xpathNodeIterator.MoveNext())
            {
                // create a new search condition for this element
                SearchCondition searchCondition = new SearchCondition();

                for (int index = 0; index < logicalObjectKey.Fields.Count; index++)
                {
                    string fieldKey = logicalObjectKey.Fields[index];
                    string fieldKeyRef = logicalObjectKeyRef.Fields[index];

                    // get the value
                    string value = xpathNodeIterator.Current.SelectSingleNode("ns:" + fieldKeyRef, xmlNamespaceManager).Value;

                    // add to the search condition
                    searchCondition.Append(logicalObjectName, SearchCondition.LogicalOperation.And, logicalObjectKeySelector + "/" + fieldKey, SearchCondition.Operation.Equals, value);
                }

                // append this search condition to the inner search condition
                if (null == searchConditionInner)
                {
                    searchConditionInner = searchCondition;
                }
                else
                {
                    searchConditionInner.Append(SearchCondition.LogicalOperation.Or, searchCondition);
                }
            }

            // check if there is a search condition for this selector
            SearchCondition searchConditionOuter = collectionSearchConditions[logicalObjectKeySelector];

            // build the search condition
            SearchCondition searchConditionKey = null;
            if (null == searchConditionOuter)
            {
                searchConditionKey = searchConditionInner;
            }
            else
            {
                searchConditionKey = new SearchCondition();
                searchConditionKey.Append(SearchCondition.LogicalOperation.And, searchConditionOuter);
                searchConditionKey.Append(SearchCondition.LogicalOperation.And, searchConditionInner);
            }

            // execute the query of the search condition
            XPathNavigator xpathNavigatorKey = this.SelectSearchCondition(sqlConnection, searchConditionKey);
            dictionaryElements[logicalObjectKeySelector] = xpathNavigatorKey;
        }

        /// <summary>
        /// Performs a series of sql transaction or xpath expression to select the elements of the key references based on the element of the key
        /// </summary>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="logicalObjectName">The name of the root logical object</param>
        /// <param name="collectionSearchConditions">The collection of search conditions that limits the query beyond the root search condition</param>
        /// <param name="logicalObjectKey">The logical object key</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        /// <param name="dictionaryElements">The dictionary of selectors already resolved to xml elements</param>
        private void SelectLogicalObjectKeyRefs(SqlConnection sqlConnection, string logicalObjectName, SearchConditionCollection collectionSearchConditions, LogicalObjectKey logicalObjectKey, StackHelper stackHelper, Dictionary<string, XPathNavigator> dictionaryElements)
        {
            // get the string representation of the previously encountered logical objects
            string stack = stackHelper.ToString();

            // get the xpath navigator
            XPathNavigator xpathNavigator = dictionaryElements[stack + logicalObjectKey.Selector];

            // create the namespace manager
            XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xpathNavigator.NameTable);
            xmlNamespaceManager.AddNamespace("ns", DBSchemaConstants.Namespace);

            // iterate the key refs
            foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
            {
                string logicalObjectKeyRefSelector = stack + logicalObjectKeyRef.Selector;

                // iterate each available element
                XPathNodeIterator xpathNodeIterator = xpathNavigator.Select(".//ns:" + DBSchemaConstants.Name + "/ns:" + logicalObjectKey.DatabaseObjectName, xmlNamespaceManager);
                if (0 == xpathNodeIterator.Count)
                {
                    // empty element, so nothing can derive from it
                    dictionaryElements[logicalObjectKeyRefSelector] = XmlHelper.CreateEmptyNavigator(DBSchemaConstants.Name, DBSchemaConstants.Namespace);
                    continue;
                }

                // check if this selector has already been queried
                XPathNavigator xpathNavigatorKeyRefOld = null;
                XPathNavigator xpathNavigatorKeyRefNew = null;
                if (true == dictionaryElements.TryGetValue(logicalObjectKeyRefSelector, out xpathNavigatorKeyRefOld))
                {
                    // already queried, so use xpath to selector the subset of appropriate elements
                    xpathNavigatorKeyRefNew = DBSchemaTransaction.SelectLogicalObjectKeyRefsFromElement(xpathNavigatorKeyRefOld, logicalObjectKeyRef, xpathNodeIterator, xmlNamespaceManager);
                }
                else
                {
                    // not already queried, so query the database
                    xpathNavigatorKeyRefNew = this.SelectLogicalObjectKeyRefsFromSql(sqlConnection, logicalObjectName, collectionSearchConditions, logicalObjectKeyRefSelector, logicalObjectKeyRef, xpathNodeIterator, xmlNamespaceManager);
                }

                dictionaryElements[logicalObjectKeyRefSelector] = xpathNavigatorKeyRefNew;
            }
        }

        /// <summary>
        /// Performs a series of sql transactions to select the elements of the key references based on the element of the key
        /// </summary>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="logicalObjectName">The name of the root logical object</param>
        /// <param name="collectionSearchConditions">The collection of search conditions that limits the query beyond the root search condition</param>
        /// <param name="logicalObjectKeyRefSelector">The logical object key reference selector</param>
        /// <param name="logicalObjectKeyRef">The logical object key reference</param>
        /// <param name="xpathNodeIterator">The xpath node iterator object to iterate the elements of the key</param>
        /// <param name="xmlNamespaceManager">The xml namespace manager for namespace resolution of the xpath node iterator object</param>
        private XPathNavigator SelectLogicalObjectKeyRefsFromSql(SqlConnection sqlConnection, string logicalObjectName, SearchConditionCollection collectionSearchConditions, string logicalObjectKeyRefSelector, LogicalObjectKeyRef logicalObjectKeyRef, XPathNodeIterator xpathNodeIterator, XmlNamespaceManager xmlNamespaceManager)
        {
            // get the logical object key
            LogicalObjectKey logicalObjectKey = logicalObjectKeyRef.Key;

            // build the inner search condition
            SearchCondition searchConditionInner = null;

            while (true == xpathNodeIterator.MoveNext())
            {
                // create a new search condition for this element
                SearchCondition searchCondition = new SearchCondition();

                // check for key references that use the same selector
                foreach (LogicalObjectKeyRef logicalObjectKeyRefOther in logicalObjectKey.KeyRefs)
                {
                    if (logicalObjectKeyRef != logicalObjectKeyRefOther)
                    {
                        continue;
                    }

                    // get the logical object key
                    for (int index = 0; index < logicalObjectKey.Fields.Count; index++)
                    {
                        string fieldKey = logicalObjectKey.Fields[index];
                        string fieldKeyRef = logicalObjectKeyRefOther.Fields[index];

                        // get the value
                        string value = xpathNodeIterator.Current.SelectSingleNode("ns:" + fieldKey, xmlNamespaceManager).Value;

                        // add to the search condition
                        searchCondition.Append(logicalObjectName, SearchCondition.LogicalOperation.And, logicalObjectKeyRefSelector + "/" + fieldKeyRef, SearchCondition.Operation.Equals, value);
                    }
                }

                // append this search condition to the inner search condition
                if (null == searchConditionInner)
                {
                    searchConditionInner = searchCondition;
                }
                else
                {
                    searchConditionInner.Append(SearchCondition.LogicalOperation.Or, searchCondition);
                }
            }

            // check if there is a search condition for this selector
            SearchCondition searchConditionOuter = collectionSearchConditions[logicalObjectKeyRefSelector];

            // build the search condition
            SearchCondition searchConditionKeyRef = null;
            if (null == searchConditionOuter)
            {
                searchConditionKeyRef = searchConditionInner;
            }
            else
            {
                searchConditionKeyRef = new SearchCondition();
                searchConditionKeyRef.Append(SearchCondition.LogicalOperation.And, searchConditionOuter);
                searchConditionKeyRef.Append(SearchCondition.LogicalOperation.And, searchConditionInner);
            }

            // execute the query of the search condition
            return this.SelectSearchCondition(sqlConnection, searchConditionKeyRef);
        }

        /// <summary>
        /// Performs a sql transaction to select the seed values for the logical object
        /// </summary>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="searchCondition">The search condition that limits the query beyond the root search condition</param>
        /// <returns>An xpath node iterator object that iterates over the collection of seed values returned from the query</returns>
        private XPathNodeIterator SelectLogicalObjectSeed(SqlConnection sqlConnection, LogicalObject logicalObject, SearchCondition searchCondition)
        {
            // create the dictionary of queried elements
            Dictionary<string, XPathNavigator> dictionaryElements = new Dictionary<string, XPathNavigator>();

            // build the seed search condition
            SearchCondition searchConditionSeed = new SearchCondition();

            if (logicalObject.Name != searchCondition.Name)
            {
                searchConditionSeed.Append(SearchCondition.LogicalOperation.And, searchCondition);
            }

            if ((logicalObject.Name == searchCondition.Name) || (logicalObject.SearchCondition.Name == searchCondition.Name))
            {
                searchConditionSeed.Append(SearchCondition.LogicalOperation.And, logicalObject.SearchCondition);
            }

            // select the seed search condition
            dictionaryElements[searchConditionSeed.Name] = this.SelectSearchCondition(sqlConnection, searchConditionSeed);

            while (false == dictionaryElements.ContainsKey(logicalObject.SearchCondition.Name))
            {
                this.SelectLogicalObject(sqlConnection, logicalObject.Name, logicalObject.SearchConditionCollection, logicalObject, new StackHelper(), dictionaryElements);
            }

            // get the root
            XPathNavigator xpathNavigator = dictionaryElements[logicalObject.SearchCondition.Name];

            // create the namespace manager
            XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xpathNavigator.NameTable);
            xmlNamespaceManager.AddNamespace("ns", DBSchemaConstants.Namespace);

            return xpathNavigator.Select(".//ns:" + DBSchemaConstants.Name + "/ns:" + logicalObject.SearchCondition.DatabaseObjectName, xmlNamespaceManager);
        }

        /// <summary>
        /// Performs a sql transaction to select the search condition
        /// </summary>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="searchCondition">The search condition that defines the query</param>
        /// <returns>An xpath navigator object that contains the results of the query</returns>
        private XPathNavigator SelectSearchCondition(SqlConnection sqlConnection, SearchCondition searchCondition)
        {
            // resolve the search condition
            searchCondition.Resolve(this.dbSchemaSet);

            // get the database table
            DatabaseTable databaseTable = this.dbSchemaSet.GetSchemaObject(searchCondition.DatabaseObjectName) as DatabaseTable;

            // build the sql command
            SqlCommandBuilder sqlCommandBuilder = new SqlCommandBuilder(sqlConnection, null, databaseTable, searchCondition);

            // build a transaction result
            TransactionResult transactionResult = new TransactionResult(searchCondition.Name);

            // execute the query
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriter = new StringWriterUTF8(stringBuilder))
            {
                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                xmlWriterSettings.Indent = true;

                using (XmlWriter xmlWriter = XmlWriter.Create(stringWriter, xmlWriterSettings))
                {
                    // write the start element
                    xmlWriter.WriteStartElement(DBSchemaConstants.Name, DBSchemaConstants.Namespace);

                    this.SelectTable(sqlCommandBuilder, this.timeout, transactionResult, xmlWriter);

                    // write the end element
                    xmlWriter.WriteEndElement();
                }
            }

            // build the document
            using (StringReader stringReader = new StringReader(stringBuilder.ToString()))
            {
                return new XPathDocument(stringReader).CreateNavigator();
            }
        }

        /// <summary>
        /// Executes the specified sql command to select the specified data
        /// </summary>
        /// <param name="sqlCommandBuilder">The sql command build object specifying the sql command</param>
        /// <param name="timeout">The timeout value of the sql command</param>
        /// <param name="transactionResult">The transaction result object to populate with the result</param>
        /// <param name="xmlWriter">The xml writer to write the xml data to</param>
        private void SelectTable(SqlCommandBuilder sqlCommandBuilder, int timeout, TransactionResult transactionResult, XmlWriter xmlWriter)
        {
            transactionResult.Action = SqlAction.Select;

            // get the sql command
            SqlCommand sqlCommand = sqlCommandBuilder.GetSqlCommand(SqlAction.Select);
            sqlCommand.CommandTimeout = timeout;

            try
            {
                // execute the sql command
                SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                while (true == sqlDataReader.Read())
                {
                    string databaseObjectName = sqlCommandBuilder.DatabaseObjectName;

                    databaseObjectName = ReplaceChars.Replace(databaseObjectName);

                    // write the start element
                    xmlWriter.WriteStartElement(databaseObjectName);

                    for (int index = 0; index < sqlDataReader.FieldCount; index++)
                    {
                        string elementName = sqlDataReader.GetName(index);
                        string elementType = sqlDataReader.GetDataTypeName(index);

                        elementName = ReplaceChars.Replace(elementName);

                        if (false == sqlDataReader.IsDBNull(index))
                        {
                            // write the start element
                            xmlWriter.WriteStartElement(elementName);

                            // write the element
                            if ("uniqueidentifier" == elementType)
                            {
                                xmlWriter.WriteString("{");
                                xmlWriter.WriteString(Convert.ToString(sqlDataReader[index]).ToUpper());
                            }
                            else if (("binary" == elementType) || ("image" == elementType) || ("timestamp" == elementType) || ("varbinary" == elementType))
                            {
                                xmlWriter.WriteString(Convert.ToBase64String(sqlDataReader.GetSqlBinary(index).Value));
                            }
                            else if ("datetime" == elementType)
                            {
                                DateTime dateTime = sqlDataReader.GetDateTime(index);
                                xmlWriter.WriteString(dateTime.ToString("yyyy-MM-dd") + "T" + dateTime.ToString("HH:mm:ss"));
                            }
                            else if ("bit" == elementType)
                            {
                                xmlWriter.WriteValue(sqlDataReader.GetBoolean(index));
                            }
                            else
                            {
                                xmlWriter.WriteString(Convert.ToString(sqlDataReader[index]));
                            }

                            if ("uniqueidentifier" == elementType)
                            {
                                xmlWriter.WriteString("}");
                            }

                            // write the end element
                            xmlWriter.WriteEndElement();
                        }
                        else if (true == this.includeNullElements)
                        {
                            // write the element
                            xmlWriter.WriteStartElement(elementName);
                            xmlWriter.WriteEndElement();
                        }
                    }

                    // write the end element
                    xmlWriter.WriteEndElement();
                }

                sqlDataReader.NextResult();

                while (true == sqlDataReader.Read())
                {
                    transactionResult.Result = sqlDataReader.GetInt32(0);
                }

                sqlDataReader.Close();
            }
            catch (SqlException ex)
            {
                transactionResult.Exception = ex;
            }
        }

        /// <summary>
        /// Perform a select sql transaction against the specified search condition
        /// </summary>
        /// <param name="transactionResult">The transaction result object to populate with the result</param>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="timeout">The timeout value of the sql command</param>
        /// <param name="databaseTable">The schema object that represents the database table</param>
        /// <param name="searchCondition">The search condition that represents the query</param>
        /// <param name="xmlWriter">The xml writer to write the xml data to</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private void SelectTable(TransactionResult transactionResult, SqlConnection sqlConnection, int timeout, DatabaseTable databaseTable, SearchCondition searchCondition, XmlWriter xmlWriter, TransactionEventHandler teh, object context)
        {
            // create a new transaction result object
            transactionResult = transactionResult.AddResult(databaseTable.Name);

            // notify the callback of the begin
            if (null != teh)
            {
                teh(transactionResult, context);
            }

            // build the sql command
            SqlCommandBuilder sqlCommandBuilder = new SqlCommandBuilder(sqlConnection, null, databaseTable, searchCondition);

            // try the transaction
            this.SelectTable(sqlCommandBuilder, timeout, transactionResult, xmlWriter);

            // notify the callback of the end
            if (null != teh)
            {
                teh(transactionResult, context);
            }
        }

        /// <summary>
        /// Perform a series of sql transactions (insert, update, delete or execute) against the specified xml document
        /// </summary>
        /// <param name="action">Specifies the transaction action: execute (insert, update or execute) or delete (delete)</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private void TransactDocument(Action action, TransactionEventHandler teh, object context)
        {
            // open the sql connection
            using (SqlConnection sqlConnection = new SqlConnection(this.dbSchemaSet.ConnectionString))
            {
                sqlConnection.Open();

                // iterate all schema objects
                IEnumerable<SchemaObject> schemaObjects = (Action.Execute == action) ? this.dbSchemaSet.SchemaObjects : this.dbSchemaSet.SchemaObjectsReverse;
                foreach (SchemaObject schemaObject in schemaObjects)
                {
                    // select any nodes matching the current schema object
                    XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(schemaObject.Name);
                    while (true == xpathNodeIterator.MoveNext())
                    {
                        // begin a sql transaction, if a logical object
                        SqlTransaction sqlTransaction = null;
                        if (true == (schemaObject is LogicalObject))
                        {
                            sqlTransaction = sqlConnection.BeginTransaction();
                        }

                        try
                        {
                            // try the transaction
                            this.TransactDocument(action, this.transactionResultRoot, sqlConnection, sqlTransaction, schemaObject, xpathNodeIterator.Current, teh, context);

                            // commit the transaction
                            if (null != sqlTransaction)
                            {
                                sqlTransaction.Commit();
                            }
                        }
                        catch (SqlException)
                        {
                            if (null != sqlTransaction)
                            {
                                try
                                {
                                    // attempt to rollback the transaction
                                    sqlTransaction.Rollback();
                                }
                                catch (SqlException)
                                {
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Execute a sql transaction (insert, update or execute) against the specified xml element
        /// </summary>
        /// <param name="action">Specifies the transaction action: execute (insert, update or execute) or delete (delete)</param>
        /// <param name="transactionResult">The transaction result object to populate with the result</param>
        /// <param name="sqlConnection">The sql connection currently open against the database</param>
        /// <param name="sqlTransaction">The sql transaction currently in progress against the database</param>
        /// <param name="schemaObject">The schema object that represents the database table or stored procedure or logical object of the specified xml element</param>
        /// <param name="xpathNavigator">The xpath navigator object to the specified xml element</param>
        /// <param name="teh">Refers to the callback method that will handle transaction events and the TransactionResult</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private void TransactDocument(Action action, TransactionResult transactionResult, SqlConnection sqlConnection, SqlTransaction sqlTransaction, SchemaObject schemaObject, XPathNavigator xpathNavigator, TransactionEventHandler teh, object context)
        {
            // create a new transaction result object
            transactionResult = transactionResult.AddResult(schemaObject.Name);

            if (true == (schemaObject is DatabaseTable))
            {
                transactionResult.SchemaType = DBSchemaType.Table;
            }
            else if (true == (schemaObject is DatabaseProcedure))
            {
                transactionResult.SchemaType = DBSchemaType.StoredProcedure;
            }
            else
            {
                transactionResult.SchemaType = DBSchemaType.LogicalObject;
            }

            // notify the callback of the begin
            if (null != teh)
            {
                teh(transactionResult, context);
            }

            // check if this is a logical object, which needs to be iterated
            if (DBSchemaType.LogicalObject == transactionResult.SchemaType)
            {
                try
                {
                    // get the logical object
                    LogicalObject logicalObject = schemaObject as LogicalObject;

                    // iterate all includes
                    IEnumerable<LogicalObjectInclude> logicalObjectIncludes = (Action.Execute == action) ? logicalObject.Includes : logicalObject.IncludesReverse;
                    foreach (LogicalObjectInclude logicalObjectInclude in logicalObjectIncludes)
                    {
                        // select any nodes matching the include
                        XPathNodeIterator xpathNodeIterator = xpathNavigator.Select(logicalObjectInclude.Name);
                        while (true == xpathNodeIterator.MoveNext())
                        {
                            this.TransactDocument(action, transactionResult, sqlConnection, sqlTransaction, logicalObjectInclude.SchemaObject, xpathNodeIterator.Current, teh, context);
                        }
                    }
                }
                catch (SqlException ex)
                {
                    transactionResult.Exception = ex;
                }

                // set the end
                transactionResult.Action = SqlAction.End;
            }
            else
            {
                if (Action.Execute == action)
                {
                    // build the sql command
                    SqlCommandBuilder sqlCommandBuilder = new SqlCommandBuilder(sqlConnection, sqlTransaction, schemaObject as DatabaseObject, xpathNavigator);

                    if (true == (schemaObject is DatabaseTable))
                    {
                        // try to insert
                        DBSchemaTransaction.TransactTable(sqlCommandBuilder, this.timeout, transactionResult, SqlAction.Insert);

                        // check if an exception occurred that is caused by a pk violation
                        if ((null != transactionResult.Exception) && (2627 == transactionResult.Exception.Number) && (true == transactionResult.Exception.Message.StartsWith("Violation of PRIMARY KEY")))
                        {
                            // try to update
                            transactionResult.Exception = null;
                            DBSchemaTransaction.TransactTable(sqlCommandBuilder, this.timeout, transactionResult, SqlAction.Update);
                        }
                    }
                    else
                    {
                        DBSchemaTransaction.ExecuteProcedure(sqlCommandBuilder, this.timeout, transactionResult);
                    }
                }
                else
                {
                    if (true == (schemaObject is DatabaseTable))
                    {
                        // build the sql command
                        SqlCommandBuilder sqlCommandBuilder = new SqlCommandBuilder(sqlConnection, sqlTransaction, schemaObject as DatabaseObject, xpathNavigator);

                        // try to delete
                        DBSchemaTransaction.TransactTable(sqlCommandBuilder, this.timeout, transactionResult, SqlAction.Delete);
                    }
                    else
                    {
                        transactionResult.Action = SqlAction.Skipped;
                    }
                }
            }

            // notify the callback of the end
            if (null != teh)
            {
                teh(transactionResult, context);
            }

            if (null != transactionResult.Exception)
            {
                throw transactionResult.Exception;
            }
        }

        /// <summary>
        /// Class to build the sql command
        /// </summary>
        private class SqlCommandBuilder
        {
            /// <summary>
            /// databaseObject is the database table or stored procedure
            /// </summary>
            private DatabaseObject databaseObject;

            /// <summary>
            /// delete is the sql command text to delete the data
            /// </summary>
            private string delete;

            /// <summary>
            /// dictionaryValues is the collection of names and values for the command text
            /// </summary>
            private Dictionary<string, string> dictionaryValues = new Dictionary<string, string>();

            /// <summary>
            /// dictionaryWhere is the collection of names and values for the where clause
            /// </summary>
            private Dictionary<string, string> dictionaryWhere = new Dictionary<string, string>();

            /// <summary>
            /// insert is the sql command text to insert the data
            /// </summary>
            private string insert;

            /// <summary>
            /// listSqlParameters is the list of sql parameters for the query
            /// </summary>
            private List<SqlParameter> listSqlParameters = new List<SqlParameter>();

            /// <summary>
            /// select is the sql command text to insert the data
            /// </summary>
            private string select;

            /// <summary>
            /// sqlConnection is the open sql connection
            /// </summary>
            private SqlConnection sqlConnection;

            /// <summary>
            /// sqlTransaction is the open sql transaction
            /// </summary>
            private SqlTransaction sqlTransaction;

            /// <summary>
            /// update is the sql command text to update the data
            /// </summary>
            private string update;

            /// <summary>
            /// Initializes a new instance of the SqlCommandBuilder class
            /// </summary>
            /// <param name="sqlConnection">The sql connection currently open against the database</param>
            /// <param name="sqlTransaction">The sql transaction currently in progress against the database</param>
            /// <param name="databaseObject">The schema object that represents the database table or stored procedure of the specified xml element</param>
            /// <param name="xpathNavigator">The xpath navigator object to the specified xml element</param>
            public SqlCommandBuilder(SqlConnection sqlConnection, SqlTransaction sqlTransaction, DatabaseObject databaseObject, XPathNavigator xpathNavigator)
            {
                this.sqlConnection = sqlConnection;
                this.sqlTransaction = sqlTransaction;
                this.databaseObject = databaseObject;

                // get the primary key
                PrimaryKey primaryKey = null;

                if (true == (this.databaseObject is DatabaseTable))
                {
                    primaryKey = (this.databaseObject as DatabaseTable).PrimaryKey;
                }

                // iterate all elements of this database object
                foreach (SchemaElement schemaElement in this.databaseObject.Elements)
                {
                    if (true == schemaElement.Suppressed)
                    {
                        continue;
                    }

                    // get the parameter value
                    XPathNavigator xpathNavigatorElement = xpathNavigator.SelectSingleNode(schemaElement.Name);

                    if ((null == xpathNavigatorElement) && (true == schemaElement.Optional))
                    {
                        continue;
                    }

                    // build the sql parameter
                    SqlParameter sqlParameter = new SqlParameter();

                    if (-1 < schemaElement.MaxLength)
                    {
                        sqlParameter = new SqlParameter("@" + schemaElement.NameRaw, schemaElement.SqlDbType, schemaElement.MaxLength);
                    }
                    else
                    {
                        sqlParameter = new SqlParameter("@" + schemaElement.NameRaw, schemaElement.SqlDbType);
                    }

                    sqlParameter.Direction = schemaElement.Direction;

                    if (null == xpathNavigatorElement)
                    {
                        sqlParameter.Value = Convert.DBNull;
                    }
                    else if (SqlDbType.UniqueIdentifier == schemaElement.SqlDbType)
                    {
                        sqlParameter.Value = new Guid(xpathNavigatorElement.Value);
                    }
                    else if ((SqlDbType.Binary == schemaElement.SqlDbType) || (SqlDbType.Image == schemaElement.SqlDbType) || (SqlDbType.Timestamp == schemaElement.SqlDbType) || (SqlDbType.VarBinary == schemaElement.SqlDbType))
                    {
                        sqlParameter.Value = Convert.FromBase64String(xpathNavigatorElement.Value);
                    }
                    else if (SqlDbType.Bit == schemaElement.SqlDbType)
                    {
                        try
                        {
                            sqlParameter.Value = Convert.ToBoolean(xpathNavigatorElement.Value);
                        }
                        catch (FormatException)
                        {
                            sqlParameter.Value = Convert.ToBoolean(Convert.ToInt32(xpathNavigatorElement.Value));
                        }
                    }
                    else if (("xml" == schemaElement.DataType) || (SqlDbType.Xml == schemaElement.SqlDbType))
                    {
                        sqlParameter.Value = xpathNavigatorElement.InnerXml;
                    }
                    else
                    {
                        sqlParameter.Value = xpathNavigatorElement.Value;
                    }

                    this.listSqlParameters.Add(sqlParameter);

                    // add the names and values
                    this.dictionaryValues[schemaElement.Name] = sqlParameter.ParameterName;

                    // check if there is a primary key
                    // if no primary key, add the names and values to the where
                    // if primary key, check if the current element exists as a field in the primary key
                    // if it does, add the names and values to the where
                    if ((null == primaryKey) || (true == primaryKey.Fields.Contains(schemaElement.NameRaw)))
                    {
                        this.dictionaryWhere[schemaElement.Name] = sqlParameter.ParameterName;
                    }
                }

                // build the command texts
                if (true == (this.databaseObject is DatabaseTable))
                {
                    this.BuildCommandTexts();
                }
            }

            /// <summary>
            /// Initializes a new instance of the SqlCommandBuilder class
            /// </summary>
            /// <param name="sqlConnection">The sql connection currently open against the database</param>
            /// <param name="sqlTransaction">The sql transaction currently in progress against the database</param>
            /// <param name="databaseTable">The schema object that represents the database table or stored procedure of the specified xml element</param>
            /// <param name="searchCondition">The search condition that represents the query</param>
            public SqlCommandBuilder(SqlConnection sqlConnection, SqlTransaction sqlTransaction, DatabaseTable databaseTable, SearchCondition searchCondition)
            {
                this.sqlConnection = sqlConnection;
                this.sqlTransaction = sqlTransaction;
                this.databaseObject = databaseTable;

                StringBuilder stringBuilderColumns = null;
                StringBuilder stringBuilderOrderBy = null;

                // get the primary key
                PrimaryKey primaryKey = (this.databaseObject as DatabaseTable).PrimaryKey;

                // iterate all elements of this database object
                foreach (SchemaElement schemaElement in this.databaseObject.Elements)
                {
                    if (true == schemaElement.Suppressed)
                    {
                        continue;
                    }

                    if (null == stringBuilderColumns)
                    {
                        stringBuilderColumns = new StringBuilder();
                    }
                    else
                    {
                        stringBuilderColumns.Append(", ");
                    }

                    stringBuilderColumns.Append("[" + schemaElement.NameRaw + "]");

                    // check if there is a primary key
                    // if no primary key, add the names and values to the where
                    // if primary key, check if the current element exists as a field in the primary key
                    // if it does, add the names and values to the where
                    if (((null == primaryKey) || (true == primaryKey.Fields.Contains(schemaElement.NameRaw))) && (SqlDbType.Image != schemaElement.SqlDbType) && (SqlDbType.NText != schemaElement.SqlDbType) && (SqlDbType.Text != schemaElement.SqlDbType))
                    {
                        if (null == stringBuilderOrderBy)
                        {
                            stringBuilderOrderBy = new StringBuilder();
                        }
                        else
                        {
                            stringBuilderOrderBy.Append(", ");
                        }

                        stringBuilderOrderBy.Append("[" + schemaElement.NameRaw + "]");
                    }
                }

                if (true == string.IsNullOrEmpty(searchCondition.Condition))
                {
                    if (null != stringBuilderOrderBy)
                    {
                        this.select = String.Format("SELECT {0} FROM {1} ORDER BY {2} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", stringBuilderColumns.ToString(), this.databaseObject.QualifiedName, stringBuilderOrderBy.ToString());
                    }
                    else
                    {
                        this.select = String.Format("SELECT {0} FROM {1} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", stringBuilderColumns.ToString(), this.databaseObject.QualifiedName);
                    }

                    this.delete = String.Format("DELETE FROM {0} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", this.databaseObject.QualifiedName);
                }
                else
                {
                    if (null != stringBuilderOrderBy)
                    {
                        this.select = String.Format("SELECT {0} FROM {1} WHERE {2} ORDER BY {3} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", stringBuilderColumns.ToString(), this.databaseObject.QualifiedName, searchCondition.Condition, stringBuilderOrderBy.ToString());
                    }
                    else
                    {
                        this.select = String.Format("SELECT {0} FROM {1} WHERE {2} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", stringBuilderColumns.ToString(), this.databaseObject.QualifiedName, searchCondition.Condition);
                    }

                    this.delete = String.Format("DELETE FROM {0} WHERE {1} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", this.databaseObject.QualifiedName, searchCondition.Condition);
                }

                this.listSqlParameters.AddRange(searchCondition.SqlParameters);
            }

            /// <summary>
            /// Gets the database object name
            /// </summary>
            public string DatabaseObjectName
            {
                get { return this.databaseObject.Name; }
            }

            /// <summary>
            /// Gets the sql command
            /// </summary>
            /// <param name="sqlAction">The sql action specifying insert, update, delete or execute</param>
            /// <returns>A sql command object</returns>
            public SqlCommand GetSqlCommand(SqlAction sqlAction)
            {
                // set the connection and transaction
                SqlCommand sqlCommand = this.sqlConnection.CreateCommand();
                sqlCommand.Connection = this.sqlConnection;

                if (null != this.sqlTransaction)
                {
                    sqlCommand.Transaction = this.sqlTransaction;
                }

                // set the text
                if (SqlAction.Select == sqlAction)
                {
                    sqlCommand.CommandText = this.select;
                }
                else if (SqlAction.Insert == sqlAction)
                {
                    sqlCommand.CommandText = this.insert;
                }
                else if (SqlAction.Update == sqlAction)
                {
                    sqlCommand.CommandText = this.update;
                }
                else if (SqlAction.Delete == sqlAction)
                {
                    sqlCommand.CommandText = this.delete;
                }
                else if (SqlAction.Execute == sqlAction)
                {
                    sqlCommand.CommandText = this.databaseObject.QualifiedName;
                    sqlCommand.CommandType = CommandType.StoredProcedure;
                }

                if (true == String.IsNullOrEmpty(sqlCommand.CommandText))
                {
                    throw new InvalidOperationException(String.Format("'{0}' is invalid for the object's current state.", sqlAction));
                }

                // add the parameters
                foreach (SqlParameter sqlParameter in this.listSqlParameters)
                {
                    SqlParameter sqlParameterClone = (sqlParameter as ICloneable).Clone() as SqlParameter;
                    sqlCommand.Parameters.Add(sqlParameterClone);
                }

                return sqlCommand;
            }

            /// <summary>
            /// Builds the command text strings
            /// </summary>
            private void BuildCommandTexts()
            {
                StringBuilder stringBuilderNames = null;
                StringBuilder stringBuilderSet = null;
                StringBuilder stringBuilderValues = null;
                StringBuilder stringBuilderWhere = null;

                // iterate each name from the names and values
                foreach (string name in this.dictionaryValues.Keys)
                {
                    // get the value
                    string value = this.dictionaryValues[name];

                    if (null == stringBuilderNames)
                    {
                        stringBuilderNames = new StringBuilder();
                        stringBuilderSet = new StringBuilder();
                        stringBuilderValues = new StringBuilder();
                    }
                    else
                    {
                        stringBuilderNames.Append(", ");
                        stringBuilderSet.Append(", ");
                        stringBuilderValues.Append(", ");
                    }

                    stringBuilderNames.Append(name);
                    stringBuilderSet.Append(name + " = " + value);
                    stringBuilderValues.Append(value);

                    string where = String.Empty;

                    if (true == this.dictionaryWhere.TryGetValue(name, out where))
                    {
                        if (null == stringBuilderWhere)
                        {
                            stringBuilderWhere = new StringBuilder();
                        }
                        else
                        {
                            stringBuilderWhere.Append(" AND ");
                        }

                        stringBuilderWhere.Append(name + " = " + where);
                    }
                }

                this.delete = String.Format("DELETE FROM {0} WHERE {1} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", this.databaseObject.QualifiedName, stringBuilderWhere.ToString());
                this.insert = String.Format("INSERT INTO {0} ({1}) VALUES ({2}) SELECT @@ROWCOUNT AS '@@ROWCOUNT'", this.databaseObject.QualifiedName, stringBuilderNames.ToString(), stringBuilderValues.ToString());
                this.update = String.Format("UPDATE {0} SET {1} WHERE {2} SELECT @@ROWCOUNT AS '@@ROWCOUNT'", this.databaseObject.QualifiedName, stringBuilderSet.ToString(), stringBuilderWhere.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\ForeignKey.cs ===
//-----------------------------------------------------------------------
// <copyright file="ForeignKey.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a foreign key and its fields
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Collections.Generic;

    /// <summary>
    /// Class to represent a foreign key
    /// </summary>
    internal sealed class ForeignKey
    {
        /// <summary>
        /// databaseTable is the database table this foreign key refers to
        /// </summary>
        private DatabaseTable databaseTable;

        /// <summary>
        /// fields is the list of columns composing the primary key
        /// </summary>
        private List<string> fields = new List<string>();

        /// <summary>
        /// name is the name of the foreign key
        /// </summary>
        private string name;

        /// <summary>
        /// Initializes a new instance of the ForeignKey class with the specified name
        /// </summary>
        /// <param name="name">The name of the foreign key</param>
        /// <param name="databaseTable">The database table this foreign key refers to</param>
        public ForeignKey(string name, DatabaseTable databaseTable)
        {
            this.name = name;
            this.databaseTable = databaseTable;
        }

        /// <summary>
        /// Gets the list of columns composing the primary key
        /// </summary>
        public List<string> Fields
        {
            get { return this.fields; }
        }

        /// <summary>
        /// Gets the name of the primary key
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the database table this foreign key refers to
        /// </summary>
        public DatabaseTable Table
        {
            get { return this.databaseTable; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\ExternalSchema.cs ===
//-----------------------------------------------------------------------
// <copyright file="ExternalSchema.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   load an external schema
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;
    using System.Xml.Xsl;

    /// <summary>
    /// Represents an external schema
    /// </summary>
    internal sealed class ExternalSchema
    {
        /// <summary>
        /// xslCompiledTransformRenameElements is the XslCompiledTransform object to execute an XSLT transformation that renames the elements in an xml document to the original names
        /// </summary>
        private static XslCompiledTransform xslCompiledTransformRenameElements = XmlHelper.LoadTransformFromResource("RenameElements.xslt");

        /// <summary>
        /// xslCompiledTransformRenameTypes is the XslCompiledTransform object to execute an XSLT transformation that renames the types in an xml schema to reflect the schema file name
        /// </summary>
        private static XslCompiledTransform xslCompiledTransformRenameTypes = XmlHelper.LoadTransformFromResource("RenameTypes.xslt");

        /// <summary>
        /// collectionComplexTypes is the collection of schema complex types
        /// </summary>
        private NameCollection<XmlSchemaComplexType> collectionComplexTypes = new NameCollection<XmlSchemaComplexType>();

        /// <summary>
        /// collectionElements is the collection of schema elements
        /// </summary>
        private NameCollection<XmlSchemaElement> collectionElements = new NameCollection<XmlSchemaElement>();

        /// <summary>
        /// collectionNames is the collection of names where the key is the new name and the value is the old name
        /// </summary>
        private Dictionary<string, string> collectionNames = new Dictionary<string, string>();

        /// <summary>
        /// collectionSimpleTypes is the collection of schema simple types
        /// </summary>
        private NameCollection<XmlSchemaSimpleType> collectionSimpleTypes = new NameCollection<XmlSchemaSimpleType>();

        /// <summary>
        /// The name for this schema
        /// </summary>
        private string name;

        /// <summary>
        /// The xpath node iterator to rename the elements
        /// </summary>
        private XPathNodeIterator xpathNodeIteratorRenameElements;

        /// <summary>
        /// Gets the collection of xml schema complex types
        /// </summary>
        public NameCollection<XmlSchemaComplexType> ComplexTypes
        {
            get { return this.collectionComplexTypes; }
        }

        /// <summary>
        /// Gets the collection of xml schema elements
        /// </summary>
        public NameCollection<XmlSchemaElement> Elements
        {
            get { return this.collectionElements; }
        }

        /// <summary>
        /// Gets the collection of xml schema simple types
        /// </summary>
        public NameCollection<XmlSchemaSimpleType> SimpleTypes
        {
            get { return this.collectionSimpleTypes; }
        }

        /// <summary>
        /// Gets the name for this schema
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Adds the types and elements from the specified external schema
        /// </summary>
        /// <param name="externalSchema">The specified external schema</param>
        public void Add(ExternalSchema externalSchema)
        {
            // add the simple types
            this.collectionSimpleTypes.AddRange(externalSchema.SimpleTypes);

            // add the complex types
            this.collectionComplexTypes.AddRange(externalSchema.ComplexTypes);

            // add the elements
            this.collectionElements.AddRange(externalSchema.Elements);

            // add the names
            foreach (string newName in externalSchema.collectionNames.Keys)
            {
                this.collectionNames[newName] = externalSchema.collectionNames[newName];
            }
        }

        /// <summary>
        /// Gets the new name for the original name
        /// </summary>
        /// <param name="value">The original name</param>
        /// <returns>The new name</returns>
        public string GetName(string value)
        {
            return ExternalSchema.GetName(this.name, value);
        }

        /// <summary>
        /// Load the specified schema
        /// </summary>
        /// <param name="directoryName">The directory name to search for the specified schema</param>
        /// <param name="fileName">The file name of the specified schema</param>
        /// <returns>The list of errors encountered while loading the specified schema</returns>
        public List<string> LoadSchemaSet(string directoryName, string fileName)
        {
            this.name = fileName;
            List<string> listErrors = new List<string>();

            try
            {
                // create the schema set
                XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
                xmlSchemaSet.XmlResolver = new XmlUrlResolver();

                // load the schema and any included schemas into the schema set
                this.LoadSchema(xmlSchemaSet, directoryName, fileName);

                // compile the schema to force validation
                xmlSchemaSet.Compile();

                // rename the types in the schema
                XmlSchemaSet xmlSchemaSetRenamedTypes = this.RenameTypesInSchemaSet(xmlSchemaSet);

                // compile the schema to force validation
                xmlSchemaSetRenamedTypes.Compile();

                // add the types into the appropriate collection
                foreach (XmlSchemaType xmlSchemaType in xmlSchemaSetRenamedTypes.GlobalTypes.Values)
                {
                    this.AddXmlSchemaObject(xmlSchemaType);
                }

                // add the elements into the appropriate collection
                foreach (XmlSchemaElement xmlSchemaElement in xmlSchemaSetRenamedTypes.GlobalElements.Values)
                {
                    this.AddXmlSchemaObject(xmlSchemaElement);
                }
            }
            catch (IOException e)
            {
                listErrors.Add("IOException: " + e.Message);
            }
            catch (XmlException e)
            {
                listErrors.Add("XmlException: " + e.Message);
            }
            catch (XmlSchemaException e)
            {
                listErrors.Add("XmlSchemaException: " + e.Message);
            }

            return listErrors;
        }

        /// <summary>
        /// Rename the elements in the document to the original names
        /// </summary>
        /// <param name="xpathNavigator">The xml document</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        public XPathNavigator RenameElementsInDocument(XPathNavigator xpathNavigator)
        {
            // create the xml document to rename the elements in the document
            XPathNodeIterator xpathNodeIterator = this.BuildRenameElements();

            // create the argument list for the xslt transform
            XsltArgumentList xsltArgumentList = new XsltArgumentList();
            xsltArgumentList.AddParam("elements", String.Empty, xpathNodeIterator);

            // run the transform to rename the elements
            StringBuilder stringBuilderRenamedElements = new StringBuilder();

            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Fragment;

            using (XmlWriter xmlWriter = XmlWriter.Create(stringBuilderRenamedElements, xmlWriterSettings))
            {
                xslCompiledTransformRenameElements.Transform(xpathNavigator, xsltArgumentList, xmlWriter);
            }

            // return the new xpath navigator
            return XmlHelper.GetNavigator(stringBuilderRenamedElements.ToString());
        }

        /// <summary>
        /// Gets the new name for the original name
        /// </summary>
        /// <param name="fileName">The schema file name</param>
        /// <param name="typeName">The original type name</param>
        /// <returns>The new name</returns>
        private static string GetName(string fileName, string typeName)
        {
            return Path.GetFileName(fileName) + "." + typeName;
        }

        /// <summary>
        /// Rename the types in the schema to reflect the xml schema file name
        /// </summary>
        /// <param name="xmlSchema">The xml schema</param>
        /// <param name="xpathNodeIterator">The xpath node iterator to iterate over the types in the schema</param>
        /// <returns>An XmlSchema object with the renamed types</returns>
        private static XmlSchema RenameTypesInSchema(XmlSchema xmlSchema, XPathNodeIterator xpathNodeIterator)
        {
            // create the argument list for the xslt transform
            XsltArgumentList xsltArgumentList = new XsltArgumentList();
            xsltArgumentList.AddParam("types", String.Empty, xpathNodeIterator);

            // create the xml document representation of the xml schema
            XPathNavigator xpathNavigator = XmlHelper.GetSchemaNavigator(xmlSchema);

            // run the transform to rename the types
            StringBuilder stringBuilderRenamedTypes = new StringBuilder();

            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Fragment;

            using (XmlWriter xmlWriter = XmlWriter.Create(stringBuilderRenamedTypes, xmlWriterSettings))
            {
                xslCompiledTransformRenameTypes.Transform(xpathNavigator, xsltArgumentList, xmlWriter);
            }

            // load the renamed types schema
            xpathNavigator = XmlHelper.GetNavigator(stringBuilderRenamedTypes.ToString());

            // change the schema namespace and return
            return XmlHelper.ChangeSchemaNamespace(xpathNavigator, DBSchemaConstants.Namespace);
        }

        /// <summary>
        /// Add the schema object to the appropriate collection
        /// </summary>
        /// <param name="xmlSchemaObject">The schema object</param>
        private void AddXmlSchemaObject(XmlSchemaObject xmlSchemaObject)
        {
            if (true == (xmlSchemaObject is XmlSchemaSimpleType))
            {
                this.collectionSimpleTypes.Add(xmlSchemaObject as XmlSchemaSimpleType);
            }
            else if (true == (xmlSchemaObject is XmlSchemaComplexType))
            {
                this.collectionComplexTypes.Add(xmlSchemaObject as XmlSchemaComplexType);
            }
            else if (true == (xmlSchemaObject is XmlSchemaElement))
            {
                this.collectionElements.Add(xmlSchemaObject as XmlSchemaElement);
            }
        }

        /// <summary>
        /// Build the xml document to rename the elements in the document to the original values
        /// </summary>
        /// <returns>An XPathNodeIterator object used to iterate over the renamed elements specified in the xml document</returns>
        private XPathNodeIterator BuildRenameElements()
        {
            if (null != this.xpathNodeIteratorRenameElements)
            {
                return this.xpathNodeIteratorRenameElements;
            }

            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.AppendChild(xmlDocument.CreateElement("RenameElements"));

            // enumerate each name
            foreach (string nameNew in this.collectionNames.Keys)
            {
                // rename the element from the renamed type to the original type
                XmlElement xmlElement = xmlDocument.CreateElement("RenameElement");
                xmlElement.SetAttribute("nameOld", nameNew);
                xmlElement.InnerText = this.collectionNames[nameNew];

                xmlDocument.DocumentElement.AppendChild(xmlElement);
            }

            this.xpathNodeIteratorRenameElements = xmlDocument.CreateNavigator().Select("/RenameElements/RenameElement");

            return this.xpathNodeIteratorRenameElements;
        }

        /// <summary>
        /// Rename the type from 'typeName' to 'fileName.typeName'
        /// </summary>
        /// <param name="xmlDocument">The xml document used to rename the types in the schema</param>
        /// <param name="fileName">The schema file name</param>
        /// <param name="typeName">The type name to rename</param>
        private void BuildRenameType(XmlDocument xmlDocument, string fileName, string typeName)
        {
            // rename the type from 'typeName' to 'fileName.typeName'
            XmlElement xmlElement = xmlDocument.CreateElement("RenameType");
            xmlElement.SetAttribute("nameOld", typeName);
            xmlElement.InnerText = ExternalSchema.GetName(fileName, typeName);

            xmlDocument.DocumentElement.AppendChild(xmlElement);

            // add the renamed type to the collection
            this.collectionNames[xmlElement.InnerText] = typeName;
        }

        /// <summary>
        /// Build the xml document to rename the types in the schema to reflect the xml schema file name
        /// </summary>
        /// <param name="xmlSchemaSet">The xml schema set</param>
        /// <returns>An XPathNodeIterator object used to iterate over the renamed types specified in the xml document</returns>
        private XPathNodeIterator BuildRenameTypes(XmlSchemaSet xmlSchemaSet)
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.AppendChild(xmlDocument.CreateElement("RenameTypes"));

            // enumerate each schema
            foreach (XmlSchema xmlSchema in xmlSchemaSet.Schemas())
            {
                // enumerate each type
                foreach (XmlSchemaType xmlSchemaType in xmlSchema.SchemaTypes.Values)
                {
                    // rename the type
                    this.BuildRenameType(xmlDocument, xmlSchema.SourceUri, xmlSchemaType.Name);
                }

                // enumerate each element
                foreach (XmlSchemaElement xmlSchemaElement in xmlSchema.Elements.Values)
                {
                    // rename the element
                    this.BuildRenameType(xmlDocument, xmlSchema.SourceUri, xmlSchemaElement.Name);
                }
            }

            return xmlDocument.CreateNavigator().Select("/RenameTypes/RenameType");
        }

        /// <summary>
        /// Load the specified schema and add it to the schema set
        /// </summary>
        /// <param name="xmlSchemaSet">The XmlSchemaSet object to which to add the specified schema</param>
        /// <param name="directoryName">The directory name to search for the specified schema</param>
        /// <param name="fileName">The file name of the specified schema</param>
        private void LoadSchema(XmlSchemaSet xmlSchemaSet, string directoryName, string fileName)
        {
            // load the specified schema
            string pathXSD = Path.Combine(directoryName, "XSD");
            string pathFile = Path.Combine(pathXSD, fileName);
            using (XmlReader xmlReader = XmlReader.Create(pathFile))
            {
                XmlSchema xmlSchema = XmlSchema.Read(xmlReader, null);

                // load any included schemas
                foreach (XmlSchemaExternal xmlSchemaExternal in xmlSchema.Includes)
                {
                    this.LoadSchema(xmlSchemaSet, directoryName, xmlSchemaExternal.SchemaLocation);
                }

                // clear the includes so the schemas will not be included again
                xmlSchema.Includes.Clear();

                // add the schema to the schema set
                xmlSchemaSet.Add(xmlSchema);
            }
        }

        /// <summary>
        /// Rename the types in the schema set to reflect the xml schema file name
        /// </summary>
        /// <param name="xmlSchemaSet">The xml schema set</param>
        /// <returns>An XmlSchemaSet object with the renamed types</returns>
        private XmlSchemaSet RenameTypesInSchemaSet(XmlSchemaSet xmlSchemaSet)
        {
            // create the xml document to rename the types in the schema set
            XmlSchemaSet xmlSchemaSetRenamedTypes = new XmlSchemaSet();
            XPathNodeIterator xpathNodeIterator = this.BuildRenameTypes(xmlSchemaSet);

            foreach (XmlSchema xmlSchema in xmlSchemaSet.Schemas())
            {
                // rename the types in the schema
                XmlSchema xmlSchemaRenamedTypes = ExternalSchema.RenameTypesInSchema(xmlSchema, xpathNodeIterator);
                xmlSchemaSetRenamedTypes.Add(xmlSchemaRenamedTypes);
            }

            return xmlSchemaSetRenamedTypes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\DBSchemaSet.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaSet.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   load and generate a schema
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Data;
    using System.Data.SqlClient;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;

    /// <summary>
    /// Represents the database schema
    /// </summary>
    public sealed class DBSchemaSet
    {
        /// <summary>
        /// sqlQueryObjects1 is the sql script to query the stored procedures and stored procedure definitions
        /// </summary>
        private static string sqlQueryObjects1 = SqlHelper.LoadScript("QueryObjects1.sql");

        /// <summary>
        /// sqlQueryObjects2 is the sql script to query the tables
        /// </summary>
        private static string sqlQueryObjects2 = SqlHelper.LoadScript("QueryObjects2.sql");

        /// <summary>
        /// sqlQueryObjects3 is the sql script to query the primary and foreign keys
        /// </summary>
        private static string sqlQueryObjects3 = SqlHelper.LoadScript("QueryObjects3.sql");

        /// <summary>
        /// sqlQueryObjectsOrder1 is the sql script to build the temporary tables for the objects order
        /// </summary>
        private static string sqlQueryObjectsOrder1 = SqlHelper.LoadScript("QueryObjectsOrder1.sql");

        /// <summary>
        /// sqlQueryObjectsOrder2 is the sql script to insert the object dependencies into the temporary tables for the objects order
        /// </summary>
        private static string sqlQueryObjectsOrder2 = SqlHelper.LoadScript("QueryObjectsOrder2.sql");

        /// <summary>
        /// assemblyName is the assembly name, expressed as: thisAssemblyName vVersion - callingAssemblyName vVersion
        /// </summary>
        private string assemblyName;

        /// <summary>
        /// collectionComplexTypes is the collection of complex types for the schema
        /// </summary>
        private NameCollection<XmlSchemaComplexType> collectionComplexTypes = new NameCollection<XmlSchemaComplexType>();

        /// <summary>
        /// collectionElements is the collection of elements for the schema
        /// </summary>
        private NameCollection<XmlSchemaElement> collectionElements = new NameCollection<XmlSchemaElement>();

        /// <summary>
        /// collectionPublishSchemas is the read only collection of publish schemas
        /// </summary>
        private ReadOnlyCollection<PublishSchema> collectionPublishSchemas;

        /// <summary>
        /// collectionRootElements is the collection of elements within the root element
        /// </summary>
        private NameCollection<XmlSchemaElement> collectionRootElements = new NameCollection<XmlSchemaElement>();

        /// <summary>
        /// collectionDatabaseObjects is the collection of tables, stored procedures and logical objects
        /// </summary>
        private NameCollection<SchemaObject> collectionSchemaObjects = new NameCollection<SchemaObject>();

        /// <summary>
        /// collectionSimpleTypes is the collection of simple types for the schema
        /// </summary>
        private NameCollection<XmlSchemaSimpleType> collectionSimpleTypes = new NameCollection<XmlSchemaSimpleType>();

        /// <summary>
        /// collectionWarnings is the read only collection of warnings
        /// </summary>
        private ReadOnlyCollection<string> collectionWarnings = null;

        /// <summary>
        /// connectionString is the sql connection string
        /// </summary>
        private string connectionString;

        /// <summary>
        /// databaseName is the name of the sql database
        /// </summary>
        private string databaseName;

        /// <summary>
        /// The config settings for generating the schema
        /// </summary>
        private DBSchemaConfig dbSchemaConfig = new DBSchemaConfig();

        /// <summary>
        /// ExternalSchemas is the collection of types and elements from the external schemas
        /// </summary>
        private ExternalSchema externalSchema = new ExternalSchema();

        /// <summary>
        /// listPublishSchemas is the list of publish schemas
        /// </summary>
        private List<PublishSchema> listPublishSchemas = new List<PublishSchema>();

        /// <summary>
        /// listSchemaObjects is the list of tables, stored procedures and logical objects, in dependency order
        /// </summary>
        private List<SchemaObject> listSchemaObjects = new List<SchemaObject>();

        /// <summary>
        /// listSchemaObjectsReverse is the list of tables, stored procedures and logical objects, in reverse dependency order
        /// </summary>
        private List<SchemaObject> listSchemaObjectsReverse;

        /// <summary>
        /// listWarnings is the list of warnings encountered while loading the config settings
        /// </summary>
        private List<string> listWarnings = new List<string>();

        /// <summary>
        /// schemaOrdered is the string representation of the ordered schema
        /// </summary>
        private string schemaOrdered;

        /// <summary>
        /// schemaSorted is the string representation of the sorted schema
        /// </summary>
        private string schemaSorted;

        /// <summary>
        /// serverName is the name of the sql server
        /// </summary>
        private string serverName;

        /// <summary>
        /// password is the password for the sql connection
        /// </summary>
        private string password;

        /// <summary>
        /// timeout is the sql command timeout
        /// </summary>
        private int timeout = 30;

        /// <summary>
        /// userName is the user id for the sql connection
        /// </summary>
        private string userName;

        /// <summary>
        /// xmlSchemaSetOrdered is the schema set ordered by dependency
        /// </summary>
        private XmlSchemaSet xmlSchemaSetOrdered = new XmlSchemaSet();

        /// <summary>
        /// xmlSchemaSetSorted is the schema set sorted by name
        /// </summary>
        private XmlSchemaSet xmlSchemaSetSorted = new XmlSchemaSet();

        /// <summary>
        /// Initializes a new instance of the DBSchemaSet class
        /// </summary>
        public DBSchemaSet()
        {
            string[] thisAssemblyNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');
            string[] thisAssemblyVersionDelimited = thisAssemblyNameDelimited[1].Split('=');

            string[] callingAssemblyNameDelimited = Assembly.GetCallingAssembly().FullName.Split(',');
            string[] callingAssemblyVersionDelimited = callingAssemblyNameDelimited[1].Split('=');

            this.assemblyName = String.Format("{0} v{1} - {2} v{3}", thisAssemblyNameDelimited[0], thisAssemblyVersionDelimited[1], callingAssemblyNameDelimited[0], callingAssemblyVersionDelimited[1]);
        }

        /// <summary>
        /// Gets the collection of publish schemas
        /// </summary>
        public ReadOnlyCollection<PublishSchema> PublishSchemas
        {
            get
            {
                if (null == this.collectionPublishSchemas)
                {
                    this.collectionPublishSchemas = new ReadOnlyCollection<PublishSchema>(this.listPublishSchemas);
                }

                return this.collectionPublishSchemas;
            }
        }

        /// <summary>
        /// Gets the string representation of the schema
        /// </summary>
        public string Schema
        {
            get { return this.schemaSorted; }
        }

        /// <summary>
        /// Gets the string representation of the ordered schema
        /// </summary>
        public string SchemaOrdered
        {
            get { return this.schemaOrdered; }
        }

        /// <summary>
        /// Gets or sets the timeout value for the transaction
        /// </summary>
        public int Timeout
        {
            get { return this.timeout; }
            set { this.timeout = value; }
        }

        /// <summary>
        /// Gets the loaded xml schema set
        /// </summary>
        public XmlSchemaSet XmlSchemaSet
        {
            get
            {
                // build the schema
                XmlSchema xmlSchema = new XmlSchema();
                XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
                using (StringReader stringReader = new StringReader(this.schemaSorted))
                {
                    xmlSchema = XmlSchema.Read(stringReader, null);
                }

                // remove the sqltypes import since it was included above
                xmlSchema.Includes.Clear();

                // add the schemas to the schema set
                xmlSchemaSet.Add(xmlSchema);

                // load the sqltypes import
                xmlSchemaSet.Add(XmlHelper.LoadSchemaFromResource("SqlTypes.xsd"));

                // compile the schema set
                xmlSchemaSet.Compile();

                return xmlSchemaSet;
            }
        }

        /// <summary>
        /// Gets the list of warnings that occurred while loading the config
        /// </summary>
        public ReadOnlyCollection<string> Warnings
        {
            get
            {
                if (null == this.collectionWarnings)
                {
                    this.collectionWarnings = new ReadOnlyCollection<string>(this.listWarnings);
                }

                return collectionWarnings;
            }
        }

        /// <summary>
        /// Gets the sql connection string
        /// </summary>
        internal string ConnectionString
        {
            get { return this.connectionString; }
        }

        /// <summary>
        /// Gets the schema objects in order by dependency
        /// </summary>
        internal IEnumerable<SchemaObject> SchemaObjects
        {
            get { return this.listSchemaObjects; }
        }

        /// <summary>
        /// Gets the schema objects in order by dependency
        /// </summary>
        internal IEnumerable<SchemaObject> SchemaObjectsReverse
        {
            get
            {
                if (null == this.listSchemaObjectsReverse)
                {
                    this.listSchemaObjectsReverse = new List<SchemaObject>(this.listSchemaObjects);
                    this.listSchemaObjectsReverse.Reverse();
                }

                return this.listSchemaObjectsReverse;
            }
        }

        /// <summary>
        /// Create a DBSchemaTransaction object to perform a sql transaction (select or delete) against all objects
        /// </summary>
        /// <returns>The new DBSchemaTransaction object</returns>
        public DBSchemaTransaction CreateTransaction()
        {
            List<SearchCondition> listSearchConditions = new List<SearchCondition>();

            foreach (SchemaObject schemaObject in this.collectionSchemaObjects)
            {
                if (false == (schemaObject is DatabaseTable))
                {
                    continue;
                }

                listSearchConditions.Add(new SearchCondition(schemaObject.Name));
            }

            return this.CreateTransaction(new SearchConditionCollection(listSearchConditions));
        }

        /// <summary>
        /// Create a DBSchemaTransaction object to perform a sql transaction (insert, update, delete or execute) against the specified xml element
        /// </summary>
        /// <param name="xpathNavigator">The xpath navigator to the element</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>The new DBSchemaTransaction object</returns>
        public DBSchemaTransaction CreateTransaction(XPathNavigator xpathNavigator, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // check if this is an element
            if (XPathNodeType.Element != xpathNavigator.NodeType)
            {
                throw new ArgumentException("xpathNavigator is not a valid element.");
            }

            // load the document
            xpathNavigator = this.LoadDocument(xpathNavigator, ignoreRestrictions, veh);

            return new DBSchemaTransaction(this, xpathNavigator);
        }

        /// <summary>
        /// Create a DBSchemaTransaction object to perform a series of sql transactions (insert, update or execute) against the specified xml document
        /// </summary>
        /// <param name="fileName">The file name containing the xml data</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>The new DBSchemaTransaction object</returns>
        public DBSchemaTransaction CreateTransaction(string fileName, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // load the document
            XPathNavigator xpathNavigator = this.LoadDocument(fileName, ignoreRestrictions, veh);

            return new DBSchemaTransaction(this, xpathNavigator);
        }

        /// <summary>
        /// Create a DBSchemaTransaction object to perform a sql transaction (select or delete) against the specified search condition
        /// </summary>
        /// <param name="searchCondition">The specified search condition</param>
        /// <returns>The new DBSchemaTransaction object</returns>
        public DBSchemaTransaction CreateTransaction(SearchCondition searchCondition)
        {
            // create the transaction
            return this.CreateTransaction(new SearchConditionCollection(searchCondition));
        }

        /// <summary>
        /// Create a DBSchemaTransaction object to perform a sql transaction (select or delete) against the specified search conditions
        /// </summary>
        /// <param name="searchConditionCollection">The specified search conditions</param>
        /// <returns>The new DBSchemaTransaction object</returns>
        public DBSchemaTransaction CreateTransaction(SearchConditionCollection searchConditionCollection)
        {
            // clone the search condition collection
            SearchConditionCollection searchConditionCollectionClone = (searchConditionCollection as ICloneable).Clone() as SearchConditionCollection;

            // resolve the search conditions
            searchConditionCollectionClone.Resolve(this);

            return new DBSchemaTransaction(this, searchConditionCollectionClone);
        }

        /// <summary>
        /// Gets the schema type of the specified type name
        /// </summary>
        /// <param name="typeName">The specified type name</param>
        /// <returns>The schema type of the specified type name</returns>
        public DBSchemaType GetSchemaType(string typeName)
        {
            SchemaObject schemaObject = this.collectionSchemaObjects[typeName];
            if (null != schemaObject)
            {
                if (schemaObject is DatabaseTable)
                {
                    return DBSchemaType.Table;
                }

                if (schemaObject is DatabaseProcedure)
                {
                    return DBSchemaType.StoredProcedure;
                }

                return DBSchemaType.LogicalObject;
            }

            if (DBSchemaConstants.Name == typeName)
            {
                return DBSchemaType.Schema;
            }

            return DBSchemaType.Unknown;
        }

        /// <summary>
        /// Loads and generates the schema from the specified database
        /// </summary>
        /// <param name="dbSchemaConfig">The DBSchemaConfig object that modifies the default schema generation</param>
        /// <param name="serverName">The sql server name</param>
        /// <param name="databaseName">The sql database name</param>
        /// <param name="userName">The user id for the sql connection</param>
        /// <param name="password">The password for the sql connection</param>
        public void LoadSchema(DBSchemaConfig dbSchemaConfig, string serverName, string databaseName, string userName, string password)
        {
            // clear any existing schema
            this.Clear();

            if (true == String.IsNullOrEmpty(serverName))
            {
                throw new ArgumentException("serverName must be a valid server name.");
            }

            if (true == String.IsNullOrEmpty(databaseName))
            {
                throw new ArgumentException("databaseName must be a valid database name.");
            }

            if (null != dbSchemaConfig)
            {
                this.dbSchemaConfig = dbSchemaConfig;
            }

            // resolve the server name
            this.serverName = serverName;
            this.databaseName = databaseName;
            this.userName = userName;
            this.password = password;

            // build the connection string
            this.BuildConnectionString();

            // query the server
            this.ServerQuery();

            // validate the logical objects
            this.ValidateLogicalObjects();

            // create the types
            this.BuildTypes();

            // add the types and elements from the external schemas
            this.AddExternalSchemas();

            // create the schema set
            this.BuildSchemaSets();

            // build the publish schemas
            this.BuildPublishSchemas();
        }

        /// <summary>
        /// Gets the schema object with the specified type name
        /// </summary>
        /// <param name="typeName">The specified type name</param>
        /// <returns>The schema object with the specified type name</returns>
        internal SchemaObject GetSchemaObject(string typeName)
        {
            return this.collectionSchemaObjects[typeName];
        }

        /// <summary>
        /// Builds the xml schema element keys and key refs based on the specified logical object
        /// </summary>
        /// <param name="xmlSchemaElement">The xml schema element</param>
        /// <param name="logicalObject">The specified logical object</param>
        /// <param name="keyPrefix">The key prefix</param>
        private static void BuildElementKeys(XmlSchemaElement xmlSchemaElement, LogicalObject logicalObject, string keyPrefix)
        {
            foreach (LogicalObjectKey logicalObjectKey in logicalObject.Keys)
            {
                // create the key
                XmlSchemaKey xmlSchemaKey = new XmlSchemaKey();

                if (true == String.IsNullOrEmpty(keyPrefix))
                {
                    xmlSchemaKey.Name = logicalObjectKey.Name;
                }
                else
                {
                    xmlSchemaKey.Name = keyPrefix + "_" + logicalObjectKey.Name;
                }

                // create the selector
                xmlSchemaKey.Selector = new XmlSchemaXPath();
                xmlSchemaKey.Selector.XPath = logicalObjectKey.Selector;

                // create the fields
                foreach (string field in logicalObjectKey.Fields)
                {
                    XmlSchemaXPath xmlSchemaXPath = new XmlSchemaXPath();
                    xmlSchemaXPath.XPath = field;
                    xmlSchemaKey.Fields.Add(xmlSchemaXPath);
                }

                // add the key
                xmlSchemaElement.Constraints.Add(xmlSchemaKey);

                // create the key refs
                foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
                {
                    // create the key ref
                    XmlSchemaKeyref xmlSchemaKeyRef = new XmlSchemaKeyref();

                    if (true == String.IsNullOrEmpty(keyPrefix))
                    {
                        xmlSchemaKeyRef.Name = logicalObjectKeyRef.Name;
                        xmlSchemaKeyRef.Refer = new XmlQualifiedName(logicalObjectKeyRef.Key.Name);
                    }
                    else
                    {
                        xmlSchemaKeyRef.Name = keyPrefix + "_" + logicalObjectKeyRef.Name;
                        xmlSchemaKeyRef.Refer = new XmlQualifiedName(keyPrefix + "_" + logicalObjectKeyRef.Key.Name);
                    }

                    // create the selector
                    xmlSchemaKeyRef.Selector = new XmlSchemaXPath();
                    xmlSchemaKeyRef.Selector.XPath = logicalObjectKeyRef.Selector;

                    // create the fields
                    foreach (string field in logicalObjectKeyRef.Fields)
                    {
                        XmlSchemaXPath xmlSchemaXPath = new XmlSchemaXPath();
                        xmlSchemaXPath.XPath = field;
                        xmlSchemaKeyRef.Fields.Add(xmlSchemaXPath);
                    }

                    // add the key ref
                    xmlSchemaElement.Constraints.Add(xmlSchemaKeyRef);
                }
            }
        }

        /// <summary>
        /// Build the publish schema
        /// </summary>
        /// <param name="publishSchemaInternal">The publis schema to build</param>
        private static void BuildPublishSchema(PublishSchemaInternal publishSchemaInternal)
        {
            // create the schema
            XmlSchema xmlSchema = XmlHelper.CreateSchemaWithSqlTypes(DBSchemaConstants.Namespace);

            // create the complex type
            XmlSchemaComplexType xmlSchemaComplexTypeRoot = new XmlSchemaComplexType();

            // create the sequence
            XmlSchemaSequence xmlSchemaSequenceRoot = new XmlSchemaSequence();

            xmlSchemaComplexTypeRoot.Particle = xmlSchemaSequenceRoot;

            foreach (XmlSchemaElement xmlSchemaElement in publishSchemaInternal.RootElements)
            {
                // add the element to the sequence
                xmlSchemaSequenceRoot.Items.Add(xmlSchemaElement);
            }

            // create the element
            XmlSchemaElement xmlSchemaElementRoot = new XmlSchemaElement();

            xmlSchemaElementRoot.Name = DBSchemaConstants.Name;
            xmlSchemaElementRoot.SchemaType = xmlSchemaComplexTypeRoot;

            xmlSchema.Items.Add(xmlSchemaElementRoot);

            // add the elements
            foreach (XmlSchemaElement xmlSchemaElement in publishSchemaInternal.Elements)
            {
                xmlSchema.Items.Add(xmlSchemaElement);
            }

            // add the simple types
            foreach (XmlSchemaSimpleType xmlSchemaSimpleType in publishSchemaInternal.SimpleTypes)
            {
                xmlSchema.Items.Add(xmlSchemaSimpleType);
            }

            // add the complex types
            foreach (XmlSchemaComplexType xmlSchemaComplexType in publishSchemaInternal.ComplexTypes)
            {
                xmlSchema.Items.Add(xmlSchemaComplexType);
            }

            // build the schema string
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriter = new StringWriterUTF8(stringBuilder))
            {
                xmlSchema.Write(stringWriter);
            }

            publishSchemaInternal.PublishSchema.Schema = stringBuilder.ToString();
        }

        /// <summary>
        /// Builds the collection of selectors reachable by key / key references
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        /// <param name="collectionSelectorsReachable">The collection of reachable selectors</param>
        private static void BuildReachableSelectors(LogicalObject logicalObject, StackHelper stackHelper, NameCollection<string> collectionSelectorsReachable)
        {
            // get the string representation of the previously encountered logical objects
            string stack = stackHelper.ToString();

            // iterate the keys
            foreach (LogicalObjectKey logicalObjectKey in logicalObject.Keys)
            {
                // check if the key has already been reached
                if (true == collectionSelectorsReachable.Contains(stack + logicalObjectKey.Selector))
                {
                    // add the key ref selectors
                    foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
                    {
                        collectionSelectorsReachable.Add(stack + logicalObjectKeyRef.Selector);
                    }
                }
                else
                {
                    // check if any key refs have already been reached
                    foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
                    {
                        if (true == collectionSelectorsReachable.Contains(stack + logicalObjectKeyRef.Selector))
                        {
                            // add the key selector
                            collectionSelectorsReachable.Add(stack + logicalObjectKey.Selector);
                        }
                    }
                }
            }

            // iterate the includes
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                if (true == (logicalObjectInclude.SchemaObject is LogicalObject))
                {
                    stackHelper.Push(logicalObjectInclude.Name);

                    DBSchemaSet.BuildReachableSelectors(logicalObjectInclude.SchemaObject as LogicalObject, stackHelper, collectionSelectorsReachable);

                    stackHelper.Pop();
                }
            }
        }

        /// <summary>
        /// Check if this logical object key already exists under a different name
        /// </summary>
        /// <param name="logicalObject">The logical object that owns the logical object key</param>
        /// <param name="logicalObjectKey">The logical object key</param>
        private static void CheckLogicalObjectKeyExists(LogicalObject logicalObject, LogicalObjectKey logicalObjectKey)
        {
            // check if this logical object key already exists under a different name
            LogicalObjectKey logicalObjectKeyRemove = null;
            foreach (LogicalObjectKey logicalObjectKeyOther in logicalObject.Keys)
            {
                if (logicalObjectKey != logicalObjectKeyOther)
                {
                    continue;
                }

                // copy the key references to the new logical object
                foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKeyOther.KeyRefs)
                {
                    logicalObjectKeyRef.Key = logicalObjectKey;
                    logicalObjectKey.KeyRefs.Add(logicalObjectKeyRef);
                }

                // flag the old logical object key for removal
                logicalObjectKeyRemove = logicalObjectKeyOther;
                break;
            }

            // remove the old logical object key
            if (null != logicalObjectKeyRemove)
            {
                logicalObject.Keys.Remove(logicalObjectKeyRemove);
            }
        }

        /// <summary>
        /// Parse the stored procedure definition for optional parameters
        /// </summary>
        /// <param name="databaseProcedure">The stored procedure database object</param>
        private static void ParseProcedureParameters(DatabaseProcedure databaseProcedure)
        {
            if (0 == databaseProcedure.Elements.Count)
            {
                // no parameters, so nothing to do
                return;
            }

            // setup the regex options
            RegexOptions regexOptions = new RegexOptions();
            regexOptions |= RegexOptions.IgnoreCase;

            // iterate the parameters
            foreach (SchemaElement schemaElement in databaseProcedure.Elements)
            {
                // find the parameter
                string regexParameter = String.Format(@"@{0}(?:\s+AS)?\s+\w+(?:\s*\([^\)]+\))?(\s*=)?", schemaElement.Name);

                Match matchParameter = Regex.Match(databaseProcedure.Text, regexParameter, regexOptions);

                // check if parameter is optional
                schemaElement.Optional = matchParameter.Groups[1].Success;
            }
        }

        /// <summary>
        /// Add the types and elements from the external schemas
        /// </summary>
        private void AddExternalSchemas()
        {
            // add the simple types
            this.collectionSimpleTypes.AddRange(this.externalSchema.SimpleTypes);

            // add the complex types
            this.collectionComplexTypes.AddRange(this.externalSchema.ComplexTypes);

            // add the elements
            this.collectionElements.AddRange(this.externalSchema.Elements);
        }

        /// <summary>
        /// Builds the sql connection string
        /// </summary>
        private void BuildConnectionString()
        {
            // build the connection string
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            sqlConnectionStringBuilder.ApplicationName = this.assemblyName;
            sqlConnectionStringBuilder.DataSource = this.serverName;
            sqlConnectionStringBuilder.InitialCatalog = this.databaseName;

            if (true == String.IsNullOrEmpty(this.userName))
            {
                sqlConnectionStringBuilder.IntegratedSecurity = true;
            }
            else
            {
                sqlConnectionStringBuilder.IntegratedSecurity = false;
                sqlConnectionStringBuilder.UserID = this.userName;
                sqlConnectionStringBuilder.Password = this.password;
            }

            this.connectionString = sqlConnectionStringBuilder.ConnectionString;
        }

        /// <summary>
        /// Build the schema element
        /// </summary>
        /// <param name="xmlSchema">The xml schema object to add the xml element to</param>
        /// <param name="enumerableSchemaObjects">The collection of schema objects to enumerate for the xml elements</param>
        private void BuildElement(XmlSchema xmlSchema, IEnumerable<SchemaObject> enumerableSchemaObjects)
        {
            // create the complex type
            XmlSchemaComplexType xmlSchemaComplexTypeRoot = new XmlSchemaComplexType();

            // create the sequence
            XmlSchemaSequence xmlSchemaSequenceRoot = new XmlSchemaSequence();

            xmlSchemaComplexTypeRoot.Particle = xmlSchemaSequenceRoot;

            foreach (SchemaObject schemaObject in enumerableSchemaObjects)
            {
                // create the element
                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();

                xmlSchemaElement.Name = schemaObject.Name;
                xmlSchemaElement.SchemaTypeName = new XmlQualifiedName(schemaObject.Name);
                xmlSchemaElement.MinOccurs = 0;
                xmlSchemaElement.MaxOccursString = "unbounded";

                // add the element to the sequence
                xmlSchemaSequenceRoot.Items.Add(xmlSchemaElement);
                this.collectionRootElements.Add(xmlSchemaElement);

                if (false == (schemaObject is LogicalObject))
                {
                    continue;
                }

                // create the keys
                DBSchemaSet.BuildElementKeys(xmlSchemaElement, schemaObject as LogicalObject, String.Empty);
            }

            // create the element
            XmlSchemaElement xmlSchemaElementRoot = new XmlSchemaElement();

            xmlSchemaElementRoot.Name = DBSchemaConstants.Name;
            xmlSchemaElementRoot.SchemaType = xmlSchemaComplexTypeRoot;

            xmlSchema.Items.Add(xmlSchemaElementRoot);
        }

        /// <summary>
        /// Builds logical object keys from primary and foreign keys
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        private void BuildLogicalObjectKeys(LogicalObject logicalObject)
        {
            // enumerate each selector
            foreach (string selector in logicalObject.Selectors)
            {
                // get the final selector
                string selectorLeaf = selector.Substring(selector.LastIndexOf('/') + 1);

                // get the table
                DatabaseTable databaseTable = this.collectionSchemaObjects[selectorLeaf] as DatabaseTable;

                // enumerate the table's foreign keys
                bool multipleReferences = false;
                NameCollection<PrimaryKey> collectionPrimaryKeys = new NameCollection<PrimaryKey>();
                foreach (ForeignKey foreignKey in databaseTable.ForeignKeys)
                {
                    // check if the foreign key's primary key table exists in the selectors
                    if (false == logicalObject.Selectors.Contains(foreignKey.Table.Name))
                    {
                        continue;
                    }

                    // check if there is a hint for this selector
                    LogicalObjectKeyRefHint logicalObjectKeyRefHint = logicalObject.KeyRefHints[selector];
                    if (null != logicalObjectKeyRefHint)
                    {
                        // check if this hint resolves to this foreign key
                        bool hintResolved = true;
                        foreach (string field in logicalObjectKeyRefHint.Fields)
                        {
                            hintResolved &= foreignKey.Fields.Contains(field);
                        }

                        if (false == hintResolved)
                        {
                            // it does not, so ignore this foreign key
                            continue;
                        }
                    }

                    // check if the primary key is already referenced
                    if (true == collectionPrimaryKeys.Contains(foreignKey.Table.PrimaryKey))
                    {
                        multipleReferences = true;
                        break;
                    }

                    // add the reference to the primary key
                    collectionPrimaryKeys.Add(foreignKey.Table.PrimaryKey);
                }

                // check for multiple references
                if (true == multipleReferences)
                {
                    this.listWarnings.Add(String.Format("Logical Object '{0}' KeyRefHint needed at '{1}'.", logicalObject.Name, selector));
                    continue;
                }

                // enumerate the table's foreign keys
                foreach (ForeignKey foreignKey in databaseTable.ForeignKeys)
                {
                    // get the primary key
                    PrimaryKey primaryKey = foreignKey.Table.PrimaryKey;

                    // check if the foreign key's primary key is referenced
                    if (false == collectionPrimaryKeys.Contains(primaryKey))
                    {
                        continue;
                    }

                    // check if there is a hint for this selector
                    LogicalObjectKeyRefHint logicalObjectKeyRefHint = logicalObject.KeyRefHints[selector];
                    if (null != logicalObjectKeyRefHint)
                    {
                        // check if this hint resolves to this foreign key
                        bool hintResolved = true;
                        foreach (string field in logicalObjectKeyRefHint.Fields)
                        {
                            hintResolved &= foreignKey.Fields.Contains(field);
                        }

                        if (false == hintResolved)
                        {
                            // it does not, so ignore this foreign key
                            continue;
                        }
                    }

                    // get the name of the logical object key
                    string logicalObjectKeyName = LogicalObjectKey.GetName(primaryKey.Name, logicalObject.Name, foreignKey.Table.Name);

                    // check if the logical object key already exists
                    LogicalObjectKey logicalObjectKey = logicalObject.Keys[logicalObjectKeyName];
                    if (null == logicalObjectKey)
                    {
                        // if not, create the new logical object key
                        logicalObjectKey = new LogicalObjectKey(primaryKey.Name, logicalObject.Name, foreignKey.Table.Name);

                        // get the primary key
                        logicalObjectKey.Fields.AddRange(primaryKey.Fields);

                        // check if this logical object key already exists under a different name
                        DBSchemaSet.CheckLogicalObjectKeyExists(logicalObject, logicalObjectKey);

                        logicalObject.Keys.Add(logicalObjectKey);
                    }

                    // create the logical object key ref
                    LogicalObjectKeyRef logicalObjectKeyRef = new LogicalObjectKeyRef(foreignKey.Name, logicalObject.Name, selector);
                    logicalObjectKeyRef.Fields.AddRange(foreignKey.Fields);
                    logicalObjectKeyRef.Key = logicalObjectKey;

                    // add the key ref
                    logicalObjectKey.KeyRefs.Add(logicalObjectKeyRef);
                }
            }
        }

        /// <summary>
        /// Build the collection of stored procedure database objects
        /// </summary>
        /// <param name="sqlDataReader">The stream of rows returned from the sql query representing the stored procedures</param>
        private void BuildProcedureCollection(SqlDataReader sqlDataReader)
        {
            // stored procedures
            string procedureLast = null;
            DatabaseProcedure databaseProcedure = null;

            while (true == sqlDataReader.Read())
            {
                // get the current procedure name
                string procedureCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(1));

                // check if procedure is suppressed
                if (true == this.dbSchemaConfig.IsTypeSuppressed(procedureCurrent))
                {
                    continue;
                }

                // check if the current procedure equals the last procedure
                if (procedureCurrent != procedureLast)
                {
                    // if not, new procedure
                    procedureLast = procedureCurrent;
                    databaseProcedure = new DatabaseProcedure(sqlDataReader.GetString(0), sqlDataReader.GetString(1));
                    this.collectionSchemaObjects.Add(databaseProcedure);
                }

                // check if this procedure has no parameters
                if (true == sqlDataReader.IsDBNull(2))
                {
                    continue;
                }

                // get the parameter name
                string name = sqlDataReader.GetString(2).TrimStart('@');

                // get the parameter direction
                string parameterDirection = sqlDataReader.GetString(3);

                // get the parameter sql data type friendly name
                string dataType = sqlDataReader.GetString(4);

                // get the parameter maximum length
                int maxLength = 0;
                if (false == sqlDataReader.IsDBNull(5))
                {
                    maxLength = sqlDataReader.GetInt32(5);
                }

                // create the new schema element
                SchemaElement schemaElement = new SchemaElement(name, parameterDirection, false, dataType, maxLength);

                // add the schema element to the list of schema elements
                databaseProcedure.Elements.Add(schemaElement);
            }
        }

        /// <summary>
        /// Build the stored procedure definition
        /// </summary>
        /// <param name="sqlDataReader">The stream of rows returned from the sql query representing the stored procedure definitions</param>
        private void BuildProcedureText(SqlDataReader sqlDataReader)
        {
            // stored procedures text
            string procedureLast = null;
            DatabaseProcedure databaseProcedure = null;

            while (true == sqlDataReader.Read())
            {
                // check if the procedure definition is empty
                if (true == sqlDataReader.IsDBNull(2))
                {
                    continue;
                }

                // get the current procedure name
                string procedureCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(1));

                // check if the current procedure equals the last procedure
                if (procedureCurrent != procedureLast)
                {
                    procedureLast = procedureCurrent;
                    databaseProcedure = this.collectionSchemaObjects[procedureCurrent] as DatabaseProcedure;
                }

                // append procedure text
                if (null != databaseProcedure)
                {
                    databaseProcedure.AppendText(sqlDataReader.GetString(2));
                }
            }
        }

        /// <summary>
        /// Build the publish schema with the specified database object
        /// </summary>
        /// <param name="publishSchemaInternal">The publish schema to add the specified database object to</param>
        /// <param name="databaseObject">The specified database object</param>
        private void BuildPublishSchemaDatabaseObject(PublishSchemaInternal publishSchemaInternal, DatabaseObject databaseObject)
        {
            // add the complex type for this database object
            publishSchemaInternal.ComplexTypes.Add(this.collectionComplexTypes[databaseObject.Name]);

            // enumerate each element for external schemas
            foreach (SchemaElement schemaElement in databaseObject.Elements)
            {
                ExternalSchemaReference externalSchemaReference = this.dbSchemaConfig.GetExternalSchemaReference(databaseObject.Name, schemaElement.Name);

                if ((null == externalSchemaReference) || (null == externalSchemaReference.ExternalSchema))
                {
                    continue;
                }

                // add the simple types from the external schema
                publishSchemaInternal.SimpleTypes.AddRange(externalSchemaReference.ExternalSchema.SimpleTypes);

                // add the complex types from the external schema
                publishSchemaInternal.ComplexTypes.AddRange(externalSchemaReference.ExternalSchema.ComplexTypes);

                // add the elements from the external schema
                publishSchemaInternal.Elements.AddRange(externalSchemaReference.ExternalSchema.Elements);
            }
        }

        /// <summary>
        /// Build the publish schema with the specified logical object
        /// </summary>
        /// <param name="publishSchemaInternal">The publish schema to add the specified database object to</param>
        /// <param name="logicalObject">The specified logical object</param>
        private void BuildPublishSchemaLogicalObject(PublishSchemaInternal publishSchemaInternal, LogicalObject logicalObject)
        {
            // add the complex type for this logical object
            publishSchemaInternal.ComplexTypes.Add(this.collectionComplexTypes[logicalObject.Name]);

            // enumerate the includes
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                if (true == (logicalObjectInclude.SchemaObject is DatabaseObject))
                {
                    this.BuildPublishSchemaDatabaseObject(publishSchemaInternal, logicalObjectInclude.SchemaObject as DatabaseObject);
                }
                else
                {
                    this.BuildPublishSchemaLogicalObject(publishSchemaInternal, logicalObjectInclude.SchemaObject as LogicalObject);
                }
            }
        }

        /// <summary>
        /// Build the publish schemas
        /// </summary>
        private void BuildPublishSchemas()
        {
            // enumerate each publish schema
            foreach (PublishSchema publishSchema in this.dbSchemaConfig.PublishSchemas)
            {
                // create an internal publish schema
                PublishSchemaInternal publishSchemaInternal = new PublishSchemaInternal(publishSchema);

                // enumerate each element of the publish schema
                foreach (string element in publishSchema.Elements)
                {
                    // get the root element for this include
                    SchemaObject schemaObject = this.collectionSchemaObjects[element];
                    XmlSchemaElement xmlSchemaElement = this.collectionRootElements[element];

                    // verify the schema object exists
                    if ((null == schemaObject) || (null == xmlSchemaElement))
                    {
                        this.listWarnings.Add(String.Format("Publish Schema '{0}' Element '{1}' is not defined.", publishSchema.Name, element));
                        continue;
                    }

                    // add the schema object
                    publishSchemaInternal.RootElements.Add(xmlSchemaElement);

                    if (true == (schemaObject is DatabaseObject))
                    {
                        this.BuildPublishSchemaDatabaseObject(publishSchemaInternal, schemaObject as DatabaseObject);
                    }
                    else
                    {
                        this.BuildPublishSchemaLogicalObject(publishSchemaInternal, schemaObject as LogicalObject);
                    }
                }

                // build the publish schema
                DBSchemaSet.BuildPublishSchema(publishSchemaInternal);

                // add the publish schema to the list
                this.listPublishSchemas.Add(publishSchemaInternal.PublishSchema);
            }
        }

        /// <summary>
        /// Build the schema sets
        /// </summary>
        private void BuildSchemaSets()
        {
            // initialize a new schema
            XmlSchema xmlSchemaOrdered = XmlHelper.CreateSchemaWithSqlTypes(DBSchemaConstants.Namespace);
            XmlSchema xmlSchemaSorted = XmlHelper.CreateSchemaWithSqlTypes(DBSchemaConstants.Namespace);

            // create the element
            this.BuildElement(xmlSchemaOrdered, this.listSchemaObjects);
            this.BuildElement(xmlSchemaSorted, this.collectionSchemaObjects);

            // add the elements to the schema
            foreach (XmlSchemaElement xmlSchemaElement in this.collectionElements)
            {
                xmlSchemaOrdered.Items.Add(xmlSchemaElement);
                xmlSchemaSorted.Items.Add(xmlSchemaElement);
            }

            // add the simple types to the schema
            foreach (XmlSchemaSimpleType xmlSchemaSimpleType in this.collectionSimpleTypes)
            {
                xmlSchemaOrdered.Items.Add(xmlSchemaSimpleType);
                xmlSchemaSorted.Items.Add(xmlSchemaSimpleType);
            }

            // add the complex types to the schema
            foreach (XmlSchemaComplexType xmlSchemaComplexType in this.collectionComplexTypes)
            {
                xmlSchemaOrdered.Items.Add(xmlSchemaComplexType);
                xmlSchemaSorted.Items.Add(xmlSchemaComplexType);
            }

            // build the schema strings
            StringBuilder stringBuilderOrdered = new StringBuilder();
            using (StringWriterUTF8 stringWriterOrdered = new StringWriterUTF8(stringBuilderOrdered))
            {
                xmlSchemaOrdered.Write(stringWriterOrdered);
            }

            this.schemaOrdered = stringBuilderOrdered.ToString();

            StringBuilder stringBuilderSorted = new StringBuilder();
            using (StringWriterUTF8 stringWriterSorted = new StringWriterUTF8(stringBuilderSorted))
            {
                xmlSchemaSorted.Write(stringWriterSorted);
            }

            this.schemaSorted = stringBuilderSorted.ToString();

            // get the schemas
            using (StringReader stringReader = new StringReader(this.schemaOrdered))
            {
                xmlSchemaOrdered = XmlSchema.Read(stringReader, null);
            }

            using (StringReader stringReader = new StringReader(this.schemaSorted))
            {
                xmlSchemaSorted = XmlSchema.Read(stringReader, null);
            }

            // remove the sqltypes import since it was included above
            xmlSchemaOrdered.Includes.Clear();
            xmlSchemaSorted.Includes.Clear();

            // add the schemas to the schema sets
            this.xmlSchemaSetOrdered.Add(xmlSchemaOrdered);
            this.xmlSchemaSetSorted.Add(xmlSchemaSorted);

            // load the sqltypes import
            XmlSchema xmlSchema = XmlHelper.LoadSchemaFromResource("SqlTypes.xsd");
            this.xmlSchemaSetOrdered.Add(xmlSchema);
            this.xmlSchemaSetSorted.Add(xmlSchema);

            // compile the schema sets
            this.xmlSchemaSetOrdered.Compile();
            this.xmlSchemaSetSorted.Compile();
        }

        /// <summary>
        /// Build the collection of table database objects
        /// </summary>
        /// <param name="sqlDataReader">The stream of rows returned from the sql query representing the tables</param>
        private void BuildTableCollection(SqlDataReader sqlDataReader)
        {
            // tables
            string tableLast = null;
            DatabaseTable databaseTable = null;

            while (true == sqlDataReader.Read())
            {
                // get the current table name
                string tableCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(1));

                // check if table is suppressed
                if (true == this.dbSchemaConfig.IsTypeSuppressed(tableCurrent))
                {
                    continue;
                }

                // check if the current table equals the last table
                if (tableCurrent != tableLast)
                {
                    // if not, new table
                    tableLast = tableCurrent;
                    databaseTable = new DatabaseTable(sqlDataReader.GetString(0), sqlDataReader.GetString(1));
                    this.collectionSchemaObjects.Add(databaseTable);
                }

                // get the column name
                string name = sqlDataReader.GetString(2);

                // get if the column has a default
                // get if the column is optional
                bool optional = false;
                if ((false == sqlDataReader.IsDBNull(3)) || ("YES" == sqlDataReader.GetString(4)))
                {
                    optional = true;
                }

                // get the column sql data type friendly name
                string dataType = sqlDataReader.GetString(5);

                // get the column maximum length
                int maxLength = 0;
                if (false == sqlDataReader.IsDBNull(6))
                {
                    maxLength = sqlDataReader.GetInt32(6);
                }

                // create the new schema element
                SchemaElement schemaElement = new SchemaElement(name, "IN", optional, dataType, maxLength);

                // add the schema element to the list of schema elements
                databaseTable.Elements.Add(schemaElement);
            }
        }

        /// <summary>
        /// Build the table foreign keys
        /// </summary>
        /// <param name="sqlDataReader">The stream of rows returned from the sql query representing the foreign keys</param>
        private void BuildTableForeignKeys(SqlDataReader sqlDataReader)
        {
            // tables
            string tableLast = null;
            string foreignKeyLast = null;
            DatabaseTable databaseTable = null;
            ForeignKey foreignKey = null;

            while (true == sqlDataReader.Read())
            {
                // get the current table name
                string tableCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(1));

                // check if the current table equals the last table
                if (tableCurrent != tableLast)
                {
                    // if not, new table
                    tableLast = tableCurrent;
                    databaseTable = this.collectionSchemaObjects[tableCurrent] as DatabaseTable;
                }

                if (null == databaseTable)
                {
                    continue;
                }

                // get the current foreign key name
                string foreignKeyCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(2));

                // check if the current foreign key equals the last foreign key
                if (foreignKeyCurrent != foreignKeyLast)
                {
                    // if not, new foreign key
                    foreignKeyLast = foreignKeyCurrent;

                    // get the foreign key table name
                    string tableForeignKey = SchemaObject.GetName(sqlDataReader.GetString(4), sqlDataReader.GetString(5));
                    DatabaseTable databaseTableForeignKey = this.collectionSchemaObjects[tableForeignKey] as DatabaseTable;

                    if (null == databaseTableForeignKey)
                    {
                        continue;
                    }

                    foreignKey = new ForeignKey(foreignKeyCurrent, databaseTableForeignKey);
                    databaseTable.ForeignKeys.Add(foreignKey);
                }

                if (null == foreignKey)
                {
                    continue;
                }

                // add the field
                foreignKey.Fields.Add(sqlDataReader.GetString(3));
            }
        }

        /// <summary>
        /// Build the table primary keys
        /// </summary>
        /// <param name="sqlDataReader">The stream of rows returned from the sql query representing the primary keys</param>
        private void BuildTablePrimaryKeys(SqlDataReader sqlDataReader)
        {
            // tables
            string tableLast = null;
            DatabaseTable databaseTable = null;

            while (true == sqlDataReader.Read())
            {
                // get the current table name
                string tableCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(1));

                // check if the current table equals the last table
                if (tableCurrent != tableLast)
                {
                    // if not, new table
                    tableLast = tableCurrent;
                    databaseTable = this.collectionSchemaObjects[tableCurrent] as DatabaseTable;
                }

                if (null == databaseTable)
                {
                    continue;
                }

                if (null == databaseTable.PrimaryKey)
                {
                    string primaryKeyCurrent = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(2));
                    databaseTable.PrimaryKey = new PrimaryKey(primaryKeyCurrent);
                }

                // add the field
                databaseTable.PrimaryKey.Fields.Add(sqlDataReader.GetString(3));
            }
        }

        /// <summary>
        /// Build the xml schema complex type based on the specified database object
        /// </summary>
        /// <param name="databaseObject">The specified database object</param>
        private void BuildTypeDatabaseObject(DatabaseObject databaseObject)
        {
            // check if this type is suppressed
            if (true == this.dbSchemaConfig.IsTypeSuppressed(databaseObject.Name))
            {
                return;
            }

            // create the complex type
            XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();

            xmlSchemaComplexType.Name = databaseObject.Name;

            // create the sequence
            XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();

            xmlSchemaComplexType.Particle = xmlSchemaSequence;

            // create the elements
            foreach (SchemaElement schemaElement in databaseObject.Elements)
            {
                // check if this element is output
                if (ParameterDirection.Output == schemaElement.Direction)
                {
                    continue;
                }

                // check if this element is required by key
                bool required = false;
                if (true == (databaseObject is DatabaseTable))
                {
                    required = (databaseObject as DatabaseTable).IsElementRequired(schemaElement.NameRaw);
                }

                // check if this element is suppressed by config
                if ((false == required) && (true == this.dbSchemaConfig.IsElementSuppressed(databaseObject.Name, schemaElement.Name)))
                {
                    schemaElement.Suppressed = true;
                    continue;
                }

                // create the element
                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();

                // check if this element has a external schema reference
                ExternalSchemaReference externalSchemaReference = this.dbSchemaConfig.GetExternalSchemaReference(databaseObject.Name, schemaElement.Name);
                if (null != externalSchemaReference)
                {
                    schemaElement.DataType = "xml";
                }

                xmlSchemaElement.Name = schemaElement.Name;

                if ((null != externalSchemaReference) && (null != externalSchemaReference.ExternalSchema))
                {
                    XmlSchemaComplexType xmlSchemaComplexTypeExternalSchemaReference = new XmlSchemaComplexType();
                    XmlSchemaSequence xmlSchemaSequenceExternalSchemaReference = new XmlSchemaSequence();
                    xmlSchemaComplexTypeExternalSchemaReference.Particle = xmlSchemaSequenceExternalSchemaReference;

                    XmlSchemaElement xmlSchemaElementExternalSchemaReference = new XmlSchemaElement();
                    xmlSchemaElementExternalSchemaReference.RefName = new XmlQualifiedName(externalSchemaReference.Node);

                    xmlSchemaSequenceExternalSchemaReference.Items.Add(xmlSchemaElementExternalSchemaReference);

                    xmlSchemaElement.SchemaType = xmlSchemaComplexTypeExternalSchemaReference;
                }
                else if ((0 == schemaElement.MaxLength) || (-1 == schemaElement.MaxLength))
                {
                    // set the element type
                    if ("uniqueidentifier" == schemaElement.DataType)
                    {
                        xmlSchemaElement.SchemaTypeName = new XmlQualifiedName("uniqueidentifier");
                    }
                    else
                    {
                        xmlSchemaElement.SchemaTypeName = new XmlQualifiedName("sqlTypes:" + schemaElement.DataType);
                    }
                }
                else
                {
                    xmlSchemaElement.Name = schemaElement.Name;

                    // set the restriction
                    XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();

                    xmlSchemaSimpleTypeRestriction.BaseTypeName = new XmlQualifiedName("sqlTypes:" + schemaElement.DataType);

                    // set the max length
                    XmlSchemaMaxLengthFacet xmlSchemaMaxLengthFacet = new XmlSchemaMaxLengthFacet();

                    xmlSchemaMaxLengthFacet.Value = schemaElement.MaxLength.ToString();

                    xmlSchemaSimpleTypeRestriction.Facets.Add(xmlSchemaMaxLengthFacet);

                    // set the simple type (restriction and max length)
                    XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();

                    xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeRestriction;

                    xmlSchemaElement.SchemaType = xmlSchemaSimpleType;
                }

                // check if the element is optional
                if ((true == schemaElement.Optional) || ((false == required) && (true == this.dbSchemaConfig.IsElementOptional(databaseObject.Name, schemaElement.Name))))
                {
                    xmlSchemaElement.MinOccurs = 0;
                }

                // add the element to the sequence
                xmlSchemaSequence.Items.Add(xmlSchemaElement);

                // add the external schema
                if ((null != externalSchemaReference) && (null != externalSchemaReference.ExternalSchema))
                {
                    this.externalSchema.Add(externalSchemaReference.ExternalSchema);
                }
            }

            // add the complex type to the schema
            this.collectionComplexTypes.Add(xmlSchemaComplexType);
        }

        /// <summary>
        /// Build the xml schema complex type based on the specified logical object
        /// </summary>
        /// <param name="logicalObject">The specified logical object</param>
        private void BuildTypeLogicalObject(LogicalObject logicalObject)
        {
            // create the complex type
            XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();

            xmlSchemaComplexType.Name = logicalObject.Name;

            // create the sequence
            XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();

            xmlSchemaComplexType.Particle = xmlSchemaSequence;

            // create the elements
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                // check if the included object is a logical object and has been created as a complex object
                if ((true == (logicalObjectInclude.SchemaObject is LogicalObject)) && (false == this.collectionComplexTypes.Contains(logicalObjectInclude.Name)))
                {
                    this.BuildTypeLogicalObject(logicalObjectInclude.SchemaObject as LogicalObject);
                }

                // create the element
                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();

                xmlSchemaElement.Name = logicalObjectInclude.Name;
                xmlSchemaElement.SchemaTypeName = new XmlQualifiedName(logicalObjectInclude.Name);

                if (false == String.IsNullOrEmpty(logicalObjectInclude.MinOccurs))
                {
                    xmlSchemaElement.MinOccursString = logicalObjectInclude.MinOccurs;
                }

                if (false == String.IsNullOrEmpty(logicalObjectInclude.MaxOccurs))
                {
                    xmlSchemaElement.MaxOccursString = logicalObjectInclude.MaxOccurs;
                }

                // add the element to the sequence
                xmlSchemaSequence.Items.Add(xmlSchemaElement);

                if (false == (logicalObjectInclude.SchemaObject is LogicalObject))
                {
                    continue;
                }

                // create the keys
                DBSchemaSet.BuildElementKeys(xmlSchemaElement, logicalObjectInclude.SchemaObject as LogicalObject, logicalObject.Name);
            }

            // add the complex type to the schema
            this.collectionComplexTypes.Add(xmlSchemaComplexType);
        }

        /// <summary>
        /// Builds the schema types
        /// </summary>
        private void BuildTypes()
        {
            // map sqlTypes:uniqueIdentifier to string type with pattern so it can be validated

            // set the restriction
            XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestrictionUniqueIdentifier = new XmlSchemaSimpleTypeRestriction();
            xmlSchemaSimpleTypeRestrictionUniqueIdentifier.BaseTypeName = new XmlQualifiedName("xs:string");

            // set the pattern
            XmlSchemaPatternFacet xmlSchemaPatternFacetUniqueIdentifier = new XmlSchemaPatternFacet();
            xmlSchemaPatternFacetUniqueIdentifier.Value = "^\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}$";
            xmlSchemaSimpleTypeRestrictionUniqueIdentifier.Facets.Add(xmlSchemaPatternFacetUniqueIdentifier);

            // set the simple type (restriction and pattern)
            XmlSchemaSimpleType xmlSchemaSimpleTypeUniqueIdentifier = new XmlSchemaSimpleType();
            xmlSchemaSimpleTypeUniqueIdentifier.Name = "uniqueidentifier";
            xmlSchemaSimpleTypeUniqueIdentifier.Content = xmlSchemaSimpleTypeRestrictionUniqueIdentifier;

            this.collectionSimpleTypes.Add(xmlSchemaSimpleTypeUniqueIdentifier);

            // iterate all tables, stored procedures and logical objects
            foreach (SchemaObject schemaObject in this.collectionSchemaObjects)
            {
                if (true == (schemaObject is DatabaseObject))
                {
                    this.BuildTypeDatabaseObject(schemaObject as DatabaseObject);
                }
                else
                {
                    this.BuildTypeLogicalObject(schemaObject as LogicalObject);
                }
            }
        }

        /// <summary>
        /// Clears the current schema
        /// </summary>
        private void Clear()
        {
            this.collectionComplexTypes.Clear();
            this.collectionElements.Clear();
            this.collectionRootElements.Clear();
            this.collectionSchemaObjects.Clear();
            this.collectionSimpleTypes.Clear();
            this.connectionString = null;
            this.databaseName = null;
            this.dbSchemaConfig = new DBSchemaConfig();
            this.externalSchema = new ExternalSchema();
            this.listPublishSchemas.Clear();
            this.listSchemaObjects.Clear();
            this.listSchemaObjectsReverse = null;
            this.listWarnings.Clear();
            this.schemaOrdered = null;
            this.schemaSorted = null;
            this.serverName = null;
            this.password = null;
            this.userName = null;
            this.xmlSchemaSetOrdered = new XmlSchemaSet();
            this.xmlSchemaSetSorted = new XmlSchemaSet();
        }

        /// <summary>
        /// Insert the object dependencies into the temporary table for the subsequent objects order query
        /// </summary>
        /// <param name="sqlConnection">The open connection to the sql database</param>
        private void InsertObjectDependencies(SqlConnection sqlConnection)
        {
            // bulk insert the dependencies
            SqlCommand sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.CommandTimeout = this.timeout;

            StringBuilder stringBuilderCommandText = new StringBuilder();

            foreach (DatabaseObject databaseObject in this.dbSchemaConfig.TypeDependencies)
            {
                if (false == this.collectionSchemaObjects.Contains(databaseObject))
                {
                    continue;
                }

                foreach (DatabaseObject databaseObjectDependsOn in databaseObject.DependsOn)
                {
                    if (false == this.collectionSchemaObjects.Contains(databaseObjectDependsOn))
                    {
                        continue;
                    }

                    // append the command text
                    stringBuilderCommandText.Append("INSERT INTO #tblObjectsDependsOn VALUES (");
                    stringBuilderCommandText.Append("'" + databaseObject.SchemaRaw + "', ");
                    stringBuilderCommandText.Append("'" + databaseObject.NameRaw + "', ");
                    stringBuilderCommandText.Append("'" + databaseObjectDependsOn.SchemaRaw + "', ");
                    stringBuilderCommandText.Append("'" + databaseObjectDependsOn.NameRaw + "')");
                    stringBuilderCommandText.AppendLine();
                }
            }

            foreach (SchemaObject schemaObject in this.collectionSchemaObjects)
            {
                if (false == schemaObject is DatabaseProcedure)
                {
                    continue;
                }

                DatabaseProcedure databaseProcedure = schemaObject as DatabaseProcedure;

                foreach (DatabaseObject databaseObjectDependsOn in databaseProcedure.DependsOn)
                {
                    // append the command text
                    stringBuilderCommandText.Append("INSERT INTO #tblObjectsDependsOn VALUES (");
                    stringBuilderCommandText.Append("'" + databaseProcedure.SchemaRaw + "', ");
                    stringBuilderCommandText.Append("'" + databaseProcedure.NameRaw + "', ");
                    stringBuilderCommandText.Append("'" + databaseObjectDependsOn.SchemaRaw + "', ");
                    stringBuilderCommandText.Append("'" + databaseObjectDependsOn.NameRaw + "')");
                    stringBuilderCommandText.AppendLine();
                }
            }

            // execute the query
            if (0 < stringBuilderCommandText.Length)
            {
                sqlCommand.CommandText = stringBuilderCommandText.ToString();
                sqlCommand.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Load and validate the specified xml document
        /// </summary>
        /// <param name="xpathNavigator">An xpath navigator to the current node</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        private XPathNavigator LoadDocument(XPathNavigator xpathNavigator, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            if (true == String.IsNullOrEmpty(this.schemaSorted))
            {
                throw new InvalidOperationException("The DBSchemaSet object has not been initialized with a call to LoadSchema.");
            }

            // wrap the old xml in a dbschema element for verification
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                using (XmlTextWriterNoNamespace xmlTextWriter = new XmlTextWriterNoNamespace(stringWriterUTF8))
                {
                    // write the start element
                    xmlTextWriter.WriteStartElementWithNamespace(String.Empty, DBSchemaConstants.Name, DBSchemaConstants.Namespace);

                    // ignore namespaces in the old xml
                    xmlTextWriter.IgnoreNamespace = true;

                    // write the old xml
                    // check if this is the root element and inner xml should be written or individual element should be written
                    if (DBSchemaConstants.Name == xpathNavigator.Name)
                    {
                        XPathNodeIterator xpathNodeIterator = xpathNavigator.SelectChildren(XPathNodeType.Element);
                        while (true == xpathNodeIterator.MoveNext())
                        {
                            xmlTextWriter.WriteNode(xpathNodeIterator.Current, false);
                        }
                    }
                    else
                    {
                        xmlTextWriter.WriteNode(xpathNavigator, false);
                    }

                    // write the end element
                    xmlTextWriter.WriteEndElement();
                }
            }

            // validate the new document
            using (StringReader stringReader = new StringReader(stringBuilder.ToString()))
            {
                xpathNavigator = XmlHelper.Validate(stringReader, this.xmlSchemaSetSorted, ignoreRestrictions, veh);
            }

            // rename the elements
            return this.externalSchema.RenameElementsInDocument(xpathNavigator);
        }

        /// <summary>
        /// Load and validate the specified xml document
        /// </summary>
        /// <param name="fileName">The file name containing the xml data</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An xpath navigator object with the elements renamed to the original names</returns>
        private XPathNavigator LoadDocument(string fileName, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            if (true == String.IsNullOrEmpty(this.schemaSorted))
            {
                throw new InvalidOperationException("The DBSchemaSet object has not been initialized with a call to LoadSchema.");
            }

            // load the document
            XPathNavigator xpathNavigator = XmlHelper.LoadDocument(fileName, this.xmlSchemaSetSorted, ignoreRestrictions, veh);

            // rename the elements
            return this.externalSchema.RenameElementsInDocument(xpathNavigator);
        }

        /// <summary>
        /// Parse the stored procedure definition for dependencies to other objects
        /// </summary>
        /// <param name="databaseProcedure">The stored procedure database object</param>
        private void ParseProcedureDependencies(DatabaseProcedure databaseProcedure)
        {
            // setup the regex options
            RegexOptions regexOptions = new RegexOptions();
            regexOptions |= RegexOptions.IgnoreCase;
            regexOptions |= RegexOptions.Singleline;

            // get the clauses
            string regexClause = @"\b(?:DELETE|EXEC|FROM|INSERT|INTO|JOIN|UPDATE)\s+((?:\s*[\w.\[\]]+\s*(?:AS|=)?\s*\w*,)*\s*[\w.\[\]]+)";
            MatchCollection matchCollectionClauses = Regex.Matches(databaseProcedure.Text, regexClause, regexOptions);

            string regexObject = @"(?:\[?(\w+)\]?\.)?(?:\[?(\w+)\]?\.)?(?:\[?(\w+)\]?\.)?\[?(\w+)\]?";

            foreach (Match match in matchCollectionClauses)
            {
                // get the object
                GroupCollection groupCollection = Regex.Match(match.Groups[1].Value, regexObject, regexOptions).Groups;

                string partDatabaseName = this.databaseName;
                string partSchema = databaseProcedure.SchemaRaw;
                string partObject = groupCollection[4].Value;

                // check if this is a dotted-4 name ([server].[database].[schema].[object])
                if (true == groupCollection[3].Success)
                {
                    continue;
                }

                // check if this is a dotted-3 name ([database].[schema].[object])
                // check if this is a dotted-2 name ([schema].[object])
                if (true == groupCollection[2].Success)
                {
                    partDatabaseName = groupCollection[1].Value;
                    partSchema = groupCollection[2].Value;
                }
                else if (true == groupCollection[1].Success)
                {
                    partSchema = groupCollection[1].Value;
                }

                // check if database name matches current database name
                if (0 != String.Compare(partDatabaseName, this.databaseName, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                // get the name of the dependency
                string dependencyName = SchemaObject.GetName(partSchema, partObject);

                // check if the dependency is a known table or procedure
                DatabaseObject databaseObjectDependsOn = this.collectionSchemaObjects[dependencyName] as DatabaseObject;
                if (null != databaseObjectDependsOn)
                {
                    databaseProcedure.DependsOn.Add(databaseObjectDependsOn);
                }
            }
        }

        /// <summary>
        /// Parse the stored procedure definitions for dependencies and optional parameters
        /// </summary>
        private void ParseProcedureText()
        {
            // enumerate each database object for procedures
            foreach (SchemaObject schemaObject in this.collectionSchemaObjects)
            {
                if (false == schemaObject is DatabaseProcedure)
                {
                    continue;
                }

                DatabaseProcedure databaseProcedure = schemaObject as DatabaseProcedure;

                // parse the procedure text for dependencies
                this.ParseProcedureDependencies(databaseProcedure);

                // parse the procedure definition for optional parameters
                DBSchemaSet.ParseProcedureParameters(databaseProcedure);
            }
        }

        /// <summary>
        /// Query the server for the tables, stored procedures, and the objects order
        /// </summary>
        private void ServerQuery()
        {
            // query for objects order
            try
            {
                using (SqlConnection sqlConnection = new SqlConnection(this.ConnectionString))
                {
                    sqlConnection.Open();

                    // create the query context for the objects query
                    QueryContext queryContext = new QueryContext();

                    // create the thread to query for tables and stored procedures
                    Thread threadQueryObjects1 = new Thread(this.ServerQueryObjects1);

                    // start the thread for the tables and stored procedures query
                    threadQueryObjects1.Start(queryContext);

                    // build temporary tables
                    SqlCommand sqlCommand1 = sqlConnection.CreateCommand();
                    sqlCommand1.CommandText = sqlQueryObjectsOrder1;
                    sqlCommand1.CommandTimeout = this.timeout;
                    sqlCommand1.ExecuteNonQuery();

                    // wait for the table and stored procedure query
                    threadQueryObjects1.Join();

                    // check for an exception
                    if (null != queryContext.Exception)
                    {
                        throw queryContext.Exception;
                    }

                    // create the thread to query for primary and foreign keys
                    Thread threadQueryObjects3 = new Thread(this.ServerQueryObjects3);

                    // start the thread for the primary and foreign keys query
                    threadQueryObjects3.Start(queryContext);

                    // insert procedure dependencies
                    this.InsertObjectDependencies(sqlConnection);

                    // get objects order
                    SqlCommand sqlCommand2 = sqlConnection.CreateCommand();
                    sqlCommand2.CommandText = sqlQueryObjectsOrder2;
                    sqlCommand2.CommandTimeout = this.timeout;

                    SqlDataReader sqlDataReader = sqlCommand2.ExecuteReader();

                    while (true == sqlDataReader.Read())
                    {
                        // get the object name
                        string databaseObjectName = SchemaObject.GetName(sqlDataReader.GetString(0), sqlDataReader.GetString(1));

                        // check if this is a known object
                        SchemaObject schemaObject = this.collectionSchemaObjects[databaseObjectName];
                        if (null != schemaObject)
                        {
                            // add the object to the ordered list
                            this.listSchemaObjects.Add(schemaObject);
                        }
                    }

                    sqlDataReader.Close();

                    // wait for the primary and foreign keys query
                    threadQueryObjects3.Join();

                    // check for an exception
                    if (null != queryContext.Exception)
                    {
                        throw queryContext.Exception;
                    }
                }
            }
            catch (SqlException)
            {
                throw;
            }
        }

        /// <summary>
        /// Query the server for the tables, stored procedures, and stored procedure definitions
        /// </summary>
        /// <param name="threadContext">The QueryContext object, which can return the exception, if any</param>
        private void ServerQueryObjects1(object threadContext)
        {
            QueryContext queryContext = threadContext as QueryContext;

            try
            {
                using (SqlConnection sqlConnection = new SqlConnection(this.connectionString))
                {
                    sqlConnection.Open();

                    // create the thread to query for tables
                    Thread threadQueryObjects2 = new Thread(this.ServerQueryObjects2);

                    // start the thread
                    threadQueryObjects2.Start(queryContext);

                    // query for stored procedures and stored procedure definitions
                    SqlCommand sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandText = sqlQueryObjects1;
                    sqlCommand.CommandTimeout = this.timeout;

                    SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                    // stored procedures
                    this.BuildProcedureCollection(sqlDataReader);
                    sqlDataReader.NextResult();

                    // wait for the tables query
                    threadQueryObjects2.Join();

                    // check for an exception
                    if (null != queryContext.Exception)
                    {
                        throw queryContext.Exception;
                    }

                    // stored procedure definitions
                    this.BuildProcedureText(sqlDataReader);
                    sqlDataReader.Close();
                }

                // parse the stored procedure definitions
                this.ParseProcedureText();
            }
            catch (SqlException ex)
            {
                queryContext.Exception = ex;
            }
        }

        /// <summary>
        /// Query the server for the tables
        /// </summary>
        /// <param name="threadContext">The QueryContext object, which can return the exception, if any</param>
        private void ServerQueryObjects2(object threadContext)
        {
            QueryContext queryContext = threadContext as QueryContext;

            try
            {
                using (SqlConnection sqlConnection = new SqlConnection(this.connectionString))
                {
                    sqlConnection.Open();

                    // query for tables
                    SqlCommand sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandText = sqlQueryObjects2;
                    sqlCommand.CommandTimeout = this.timeout;

                    SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                    // tables
                    this.BuildTableCollection(sqlDataReader);
                    sqlDataReader.Close();
                }
            }
            catch (SqlException ex)
            {
                queryContext.Exception = ex;
            }
        }

        /// <summary>
        /// Query the server for the primary and foreign keys
        /// </summary>
        /// <param name="threadContext">The QueryContext object, which can return the exception, if any</param>
        private void ServerQueryObjects3(object threadContext)
        {
            QueryContext queryContext = threadContext as QueryContext;

            try
            {
                using (SqlConnection sqlConnection = new SqlConnection(this.connectionString))
                {
                    sqlConnection.Open();

                    // query for primary and foreign keys
                    SqlCommand sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandText = sqlQueryObjects3;
                    sqlCommand.CommandTimeout = this.timeout;

                    SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                    // primary keys
                    this.BuildTablePrimaryKeys(sqlDataReader);
                    sqlDataReader.NextResult();

                    // foreign keys
                    this.BuildTableForeignKeys(sqlDataReader);
                    sqlDataReader.Close();
                }
            }
            catch (SqlException ex)
            {
                queryContext.Exception = ex;
            }
        }

        /// <summary>
        /// Validates the logical object
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        private void ValidateLogicalObject(LogicalObject logicalObject, StackHelper stackHelper)
        {
            // add this type to the stack
            stackHelper.Push(logicalObject.Name);

            // validate the includes
            this.ValidateLogicalObjectIncludes(logicalObject, stackHelper);

            // validate the keys
            this.ValidateLogicalObjectKeys(logicalObject);

            // build the keys from primary and foreign keys
            this.BuildLogicalObjectKeys(logicalObject);

            stackHelper.Pop();
        }

        /// <summary>
        /// Validates the logical object is complete and selectable (all selectors can be reached by search conditions and key / key references)
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        private void ValidateLogicalObjectComplete(LogicalObject logicalObject)
        {
            // searchCondition is the root search condition
            SearchCondition searchCondition = null;

            // the collection of selectors reachable by key / key reference
            NameCollection<string> collectionSelectorsReachable = new NameCollection<string>();

            // check if the root selector has a defined search condition
            foreach (string selector in logicalObject.Selectors)
            {
                searchCondition = logicalObject.SearchConditionCollection[selector];

                if (null == logicalObject.SearchConditionCollection[selector])
                {
                    this.listWarnings.Add(String.Format("Logical Object '{0}' SearchCondition needed at '{1}'.", logicalObject.Name, selector));
                    return;
                }

                collectionSelectorsReachable.Add(selector);
                break;
            }

            // build the collection of reachable selectors
            int count = 0;
            do
            {
                count = collectionSelectorsReachable.Count;
                DBSchemaSet.BuildReachableSelectors(logicalObject, new StackHelper(), collectionSelectorsReachable);
            } while ((count < collectionSelectorsReachable.Count) && (logicalObject.Selectors.Count > collectionSelectorsReachable.Count));

            // iterate the logical object selectors
            List<string> listSelectors = new List<string>(logicalObject.Selectors);
            foreach (string selector in collectionSelectorsReachable)
            {
                listSelectors.Remove(selector);
            }

            // check if all logical object selectors were reached
            foreach (string selector in listSelectors)
            {
                this.listWarnings.Add(String.Format("Logical Object '{0}' is not complete.  '{1}' is not reachable.", logicalObject.Name, selector));
            }

            // set the root search condition
            if (0 == listSelectors.Count)
            {
                logicalObject.SearchCondition = searchCondition;
            }
        }

        /// <summary>
        /// Validates the included types of a logical object
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="stackHelper">The stack of previously encountered logical objects</param>
        private void ValidateLogicalObjectIncludes(LogicalObject logicalObject, StackHelper stackHelper)
        {
            // enumerate each included type
            foreach (LogicalObjectInclude logicalObjectInclude in logicalObject.Includes)
            {
                // check if this is a table or procedure
                DatabaseObject databaseObject = this.collectionSchemaObjects[logicalObjectInclude.Name] as DatabaseObject;

                // check for a valid object
                if ((null == databaseObject) && (false == (logicalObjectInclude.SchemaObject is LogicalObject)))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' Includes '{1}' is not defined.", logicalObject.Name, logicalObjectInclude.Name));
                }

                if (null != databaseObject)
                {
                    if (true == (logicalObjectInclude.SchemaObject is LogicalObject))
                    {
                        throw new InvalidOperationException(String.Format("Logical Object '{0}' conflicts with Database Object.", logicalObjectInclude.Name));
                    }

                    if (false == (databaseObject is DatabaseTable))
                    {
                        throw new InvalidOperationException(String.Format("Logical Object '{0}' Includes '{1}' is not a Table.", logicalObject.Name, logicalObjectInclude.Name));
                    }

                    // set the schema object with this table
                    logicalObjectInclude.SchemaObject = databaseObject;
                }
                else
                {
                    // validate the logical object
                    this.ValidateLogicalObject(logicalObjectInclude.SchemaObject as LogicalObject, stackHelper);
                }
            }
        }

        /// <summary>
        /// Validate the logical objects
        /// </summary>
        private void ValidateLogicalObjects()
        {
            // enumerate each logical object
            foreach (LogicalObject logicalObject in this.dbSchemaConfig.LogicalObjects)
            {
                // clone the logical object for use with this schema set
                LogicalObject logicalObjectClone = (logicalObject as ICloneable).Clone() as LogicalObject;

                try
                {
                    // validate this logical object
                    this.ValidateLogicalObject(logicalObjectClone, new StackHelper());

                    // add this logical object to the collection
                    this.collectionSchemaObjects.Add(logicalObjectClone);
                    this.listSchemaObjects.Add(logicalObjectClone);

                    // resolve the search conditions
                    logicalObjectClone.SearchConditionCollection.Resolve(this);

                    // check if this logical object is complete
                    this.ValidateLogicalObjectComplete(logicalObjectClone);
                }
                catch (ArgumentException ex)
                {
                    this.listWarnings.Add(ex.Message);
                }
                catch (InvalidOperationException ex)
                {
                    this.listWarnings.Add(ex.Message);
                }
            }
        }

        /// <summary>
        /// Validates the references of a logical object key
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        /// <param name="logicalObjectKey">The logical object key</param>
        private void ValidateLogicalObjectKeyRefs(LogicalObject logicalObject, LogicalObjectKey logicalObjectKey)
        {
            // get the key final selector
            string selectorKeyLeaf = logicalObjectKey.Selector.Substring(logicalObjectKey.Selector.LastIndexOf('/') + 1);

            // get the key database object
            DatabaseObject databaseObjectKey = this.collectionSchemaObjects[selectorKeyLeaf] as DatabaseObject;

            // create the list of invalid key refs
            NameCollection<LogicalObjectKeyRef> collectionLogicalObjectKeyRefsInvalid = new NameCollection<LogicalObjectKeyRef>();

            // enumerate each key ref
            foreach (LogicalObjectKeyRef logicalObjectKeyRef in logicalObjectKey.KeyRefs)
            {
                // get the key ref final selector
                string selectorKeyRefLeaf = logicalObjectKeyRef.Selector.Substring(logicalObjectKeyRef.Selector.LastIndexOf('/') + 1);

                // get the key ref database object
                DatabaseObject databaseObjectKeyRef = this.collectionSchemaObjects[selectorKeyRefLeaf] as DatabaseObject;

                // validate the fields
                for (int index = 0; index < logicalObjectKey.Fields.Count; index++)
                {
                    try
                    {
                        SqlDbType sqlDbTypeKey = databaseObjectKey.GetElementType(logicalObjectKey.Fields[index]);
                        SqlDbType sqlDbTypeKeyRef = databaseObjectKeyRef.GetElementType(logicalObjectKeyRef.Fields[index]);

                        if (sqlDbTypeKey != sqlDbTypeKeyRef)
                        {
                            this.listWarnings.Add(String.Format("Logical Object '{0}' Key/KeyRef '{1}' Fields do not match.", logicalObject.Name, logicalObjectKey.Selector));
                            collectionLogicalObjectKeyRefsInvalid.Add(logicalObjectKeyRef);
                        }
                    }
                    catch (ArgumentException ex)
                    {
                        this.listWarnings.Add(String.Format("Logical Object '{0}' {1}", logicalObject.Name, ex.Message));
                        collectionLogicalObjectKeyRefsInvalid.Add(logicalObjectKeyRef);
                    }
                }
            }

            // remove the invalid key refs
            foreach (LogicalObjectKeyRef logicalObjectKeyRef in collectionLogicalObjectKeyRefsInvalid)
            {
                logicalObjectKey.KeyRefs.Remove(logicalObjectKeyRef);
            }
        }

        /// <summary>
        /// Validates the keys of a logical object
        /// </summary>
        /// <param name="logicalObject">The logical object</param>
        private void ValidateLogicalObjectKeys(LogicalObject logicalObject)
        {
            // create the list of invalid keys
            NameCollection<LogicalObjectKey> collectionLogicalObjectKeysInvalid = new NameCollection<LogicalObjectKey>();

            // enumerate each key
            foreach (LogicalObjectKey logicalObjectKey in logicalObject.Keys)
            {
                // validate the key refs
                this.ValidateLogicalObjectKeyRefs(logicalObject, logicalObjectKey);

                if (0 == logicalObjectKey.KeyRefs.Count)
                {
                    collectionLogicalObjectKeysInvalid.Add(logicalObjectKey);
                }
            }

            // remove the invalid keys
            foreach (LogicalObjectKey logicalObjectKey in collectionLogicalObjectKeysInvalid)
            {
                logicalObject.Keys.Remove(logicalObjectKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\LogicalObjectKeyRefHint.cs ===
//-----------------------------------------------------------------------
// <copyright file="LogicalObjectKeyRefHint.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a hint to resolve a logical object key ref
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Collections.Generic;

    /// <summary>
    /// Represents a hint to resolve a key reference for a logical object
    /// </summary>
    internal sealed class LogicalObjectKeyRefHint
    {
        /// <summary>
        /// The collection of fields that apply as children for the xpath expression selector
        /// </summary>
        private List<string> listFields = new List<string>();

        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// Initializes a new instance of the LogicalObjectKeyRefHint class with the specified name
        /// </summary>
        /// <param name="selector">The xpath expression selector element</param>
        public LogicalObjectKeyRefHint(string selector)
        {
            this.name = selector;
        }

        /// <summary>
        /// Gets the collection of fields that apply as children for the xpath expression selector
        /// </summary>
        public List<string> Fields
        {
            get { return this.listFields; }
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\LogicalObjectInclude.cs ===
//-----------------------------------------------------------------------
// <copyright file="LogicalObjectInclude.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a logical object include
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;

    /// <summary>
    /// Represents an included schema object for a logical object
    /// </summary>
    internal sealed class LogicalObjectInclude : ICloneable
    {
        /// <summary>
        /// The minimum occurrences of this object
        /// </summary>
        private string minOccurs;

        /// <summary>
        /// The maximum occurrences of this object
        /// </summary>
        private string maxOccurs;

        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// The schema object included by this object
        /// </summary>
        private SchemaObject schemaObject;

        /// <summary>
        /// Initializes a new instance of the LogicalObjectInclude class
        /// </summary>
        /// <param name="name">The specified name</param>
        public LogicalObjectInclude(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Gets or sets the maximum occurrences of this object
        /// </summary>
        public string MaxOccurs
        {
            get { return this.maxOccurs; }
            set { this.maxOccurs = value; }
        }

        /// <summary>
        /// Gets or sets the minimum occurrences of this object
        /// </summary>
        public string MinOccurs
        {
            get { return this.minOccurs; }
            set { this.minOccurs = value; }
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets or sets the schema object included by this object
        /// </summary>
        public SchemaObject SchemaObject
        {
            get { return this.schemaObject; }
            set { this.schemaObject = value; }
        }

        /// <summary>
        /// Creates a new object that is a copy of the current instance
        /// </summary>
        /// <returns>A new object that is a copy of the current instance</returns>
        object System.ICloneable.Clone()
        {
            // create a new logical object include
            LogicalObjectInclude logicalObjectIncludeClone = new LogicalObjectInclude(this.Name);

            logicalObjectIncludeClone.maxOccurs = this.maxOccurs;
            logicalObjectIncludeClone.minOccurs = this.minOccurs;

            if (null != this.schemaObject)
            {
                logicalObjectIncludeClone.schemaObject = (this.schemaObject as ICloneable).Clone() as SchemaObject;
            }

            return logicalObjectIncludeClone;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\LogicalObjectKeyRef.cs ===
//-----------------------------------------------------------------------
// <copyright file="LogicalObjectKeyRef.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a logical object key reference
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Represents the key reference for a logical object
    /// </summary>
    internal sealed class LogicalObjectKeyRef : IEquatable<LogicalObjectKeyRef>
    {
        /// <summary>
        /// The database object name for this object
        /// </summary>
        private string databaseObjectName;

        /// <summary>
        /// The collection of fields that apply as children for the xpath expression selector
        /// </summary>
        private List<string> listFields = new List<string>();

        /// <summary>
        /// The logical object key for this reference
        /// </summary>
        private LogicalObjectKey logicalObjectKey;

        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// The xpath expression selector element
        /// </summary>
        private string selector;

        /// <summary>
        /// Initializes a new instance of the LogicalObjectKeyRef class with the specified name
        /// </summary>
        /// <param name="keyPrefix">The key prefix</param>
        /// <param name="typeName">The logical object type name</param>
        /// <param name="selector">The xpath expression selector element</param>
        public LogicalObjectKeyRef(string keyPrefix, string typeName, string selector)
        {
            this.name = LogicalObjectKeyRef.GetName(keyPrefix, typeName, selector);
            this.selector = selector;

            // get the database object name
            string[] xpaths = selector.Split('/');
            this.databaseObjectName = xpaths[xpaths.Length - 1];
        }

        /// <summary>
        /// Gets the database object name for this object
        /// </summary>
        public string DatabaseObjectName
        {
            get { return this.databaseObjectName; }
        }

        /// <summary>
        /// Gets the collection of fields that apply as children for the xpath expression selector
        /// </summary>
        public List<string> Fields
        {
            get { return this.listFields; }
        }

        /// <summary>
        /// Gets or sets the logical object key for this object
        /// </summary>
        public LogicalObjectKey Key
        {
            get { return this.logicalObjectKey; }
            set { this.logicalObjectKey = value; }
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the xpath expression selector element
        /// </summary>
        public string Selector
        {
            get { return this.selector; }
        }

        /// <summary>
        /// Determines whether the two logical object key refs are equal
        /// </summary>
        /// <param name="left">The left comparand</param>
        /// <param name="right">The right comparand</param>
        /// <returns>true if the value of left and right are the same; otherwise, false</returns>
        public static bool operator ==(LogicalObjectKeyRef left, LogicalObjectKeyRef right)
        {
            if (true == System.Object.ReferenceEquals(left, right))
            {
                return true;
            }

            if ((null == left) || (null == right))
            {
                return false;
            }

            return left.Equals(right);
        }

        /// <summary>
        /// Determines whether the two logical object key refs are different
        /// </summary>
        /// <param name="left">The left comparand</param>
        /// <param name="right">The right comparand</param>
        /// <returns>true if the value of left and right are different; otherwise, false</returns>
        public static bool operator !=(LogicalObjectKeyRef left, LogicalObjectKeyRef right)
        {
            return !(left == right);
        }

        /// <summary>
        /// Returns a qualified name
        /// </summary>
        /// <param name="keyPrefix">The key prefix</param>
        /// <param name="typeName">The logical object type name</param>
        /// <param name="selector">The xpath expression selector element</param>
        /// <returns>The qualified name</returns>
        public static string GetName(string keyPrefix, string typeName, string selector)
        {
            return keyPrefix + "_" + typeName + "_" + selector.Replace('/', '_');
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="obj">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public override bool Equals(object obj)
        {
            if (false == (obj is LogicalObjectKeyRef))
            {
                return false;
            }

            return this.Equals(obj as LogicalObjectKeyRef);
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="other">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public bool Equals(LogicalObjectKeyRef other)
        {
            if (true == System.Object.ReferenceEquals(this, other))
            {
                return true;
            }

            if (null == other)
            {
                return false;
            }

            if (this.databaseObjectName != other.databaseObjectName)
            {
                return false;
            }

            if (this.logicalObjectKey != other.logicalObjectKey)
            {
                return false;
            }

            if (this.selector != other.selector)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns the hash code for the current object
        /// </summary>
        /// <returns>The hash code for the current object</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\LogicalObjectKey.cs ===
//-----------------------------------------------------------------------
// <copyright file="LogicalObjectKey.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a logical object key
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Represents the key for a logical object
    /// </summary>
    internal sealed class LogicalObjectKey : IEquatable<LogicalObjectKey>
    {
        /// <summary>
        /// The database object name for this object
        /// </summary>
        private string databaseObjectName;

        /// <summary>
        /// collectionLogicalObjectKeyRefs is the collection of key references to this key
        /// </summary>
        private NameCollection<LogicalObjectKeyRef> collectionLogicalObjectKeyRefs = new NameCollection<LogicalObjectKeyRef>();

        /// <summary>
        /// The collection of fields that apply as children for the xpath expression selector
        /// </summary>
        private List<string> listFields = new List<string>();

        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// The xpath expression selector element
        /// </summary>
        private string selector;

        /// <summary>
        /// Initializes a new instance of the LogicalObjectKey class with the specified name
        /// </summary>
        /// <param name="keyPrefix">The key prefix</param>
        /// <param name="typeName">The logical object type name</param>
        /// <param name="selector">The xpath expression selector element</param>
        public LogicalObjectKey(string keyPrefix, string typeName, string selector)
        {
            this.name = LogicalObjectKey.GetName(keyPrefix, typeName, selector);
            this.selector = selector;

            // get the database object name
            string[] xpaths = selector.Split('/');
            this.databaseObjectName = xpaths[xpaths.Length - 1];
        }

        /// <summary>
        /// Gets the database object name for this object
        /// </summary>
        public string DatabaseObjectName
        {
            get { return this.databaseObjectName; }
        }

        /// <summary>
        /// Gets the collection of fields that apply as children for the xpath expression selector
        /// </summary>
        public List<string> Fields
        {
            get { return this.listFields; }
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the collection of key references for this key
        /// </summary>
        public NameCollection<LogicalObjectKeyRef> KeyRefs
        {
            get { return this.collectionLogicalObjectKeyRefs; }
        }

        /// <summary>
        /// Gets the xpath expression selector element
        /// </summary>
        public string Selector
        {
            get { return this.selector; }
        }

        /// <summary>
        /// Determines whether the two logical object keys are equal
        /// </summary>
        /// <param name="left">The left comparand</param>
        /// <param name="right">The right comparand</param>
        /// <returns>true if the value of left and right are the same; otherwise, false</returns>
        public static bool operator ==(LogicalObjectKey left, LogicalObjectKey right)
        {
            if (true == System.Object.ReferenceEquals(left, right))
            {
                return true;
            }

            if ((null == left) || (null == right))
            {
                return false;
            }

            return left.Equals(right);
        }

        /// <summary>
        /// Determines whether the two logical object keys are different
        /// </summary>
        /// <param name="left">The left comparand</param>
        /// <param name="right">The right comparand</param>
        /// <returns>true if the value of left and right are different; otherwise, false</returns>
        public static bool operator !=(LogicalObjectKey left, LogicalObjectKey right)
        {
            return !(left == right);
        }

        /// <summary>
        /// Returns a qualified name
        /// </summary>
        /// <param name="keyPrefix">The key prefix</param>
        /// <param name="typeName">The logical object type name</param>
        /// <param name="selector">The xpath expression selector element</param>
        /// <returns>The qualified name</returns>
        public static string GetName(string keyPrefix, string typeName, string selector)
        {
            return keyPrefix + "_" + typeName + "_" + selector.Replace('/', '_');
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="obj">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public override bool Equals(object obj)
        {
            if (false == (obj is LogicalObjectKey))
            {
                return false;
            }

            return this.Equals(obj as LogicalObjectKey);
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="other">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public bool Equals(LogicalObjectKey other)
        {
            if (true == System.Object.ReferenceEquals(this, other))
            {
                return true;
            }

            if (null == other)
            {
                return false;
            }

            if (this.databaseObjectName != other.databaseObjectName)
            {
                return false;
            }

            if (this.listFields.Count != other.listFields.Count)
            {
                return false;
            }

            for (int index = 0; index < this.listFields.Count; index++)
            {
                if (this.listFields[index] != other.listFields[index])
                {
                    return false;
                }
            }

            if (this.selector != other.selector)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns the hash code for the current object
        /// </summary>
        /// <returns>The hash code for the current object</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\LogicalObject.cs ===
//-----------------------------------------------------------------------
// <copyright file="LogicalObject.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a logical object
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Represents a logical object
    /// </summary>
    internal sealed class LogicalObject : SchemaObject, ICloneable
    {
        /// <summary>
        /// collectionLogicalObjectKeyRefHints is the collection of key ref hints for this object
        /// </summary>
        private NameCollection<LogicalObjectKeyRefHint> collectionLogicalObjectKeyRefHints = new NameCollection<LogicalObjectKeyRefHint>();

        /// <summary>
        /// collectionLogicalObjectKeys is the collection of keys for this object
        /// </summary>
        private NameCollection<LogicalObjectKey> collectionLogicalObjectKeys = new NameCollection<LogicalObjectKey>();

        /// <summary>
        /// listLogicalObjectIncludes is the list of includes for this object
        /// </summary>
        private List<LogicalObjectInclude> listLogicalObjectIncludes = new List<LogicalObjectInclude>();

        /// <summary>
        /// listLogicalObjectIncludes is the list of includes for this object in reverse order
        /// </summary>
        private List<LogicalObjectInclude> listLogicalObjectIncludesReverse;

        /// <summary>
        /// listSelectors is the list of xpath expression selector elements for this object
        /// </summary>
        private List<string> listSelectors = new List<string>();

        /// <summary>
        /// searchConditionRoot is the search condition to populate the root of this object
        /// </summary>
        private SearchCondition searchConditionRoot;

        /// <summary>
        /// searchConditionCollection is the collection of search conditions for this object
        /// </summary>
        private SearchConditionCollection searchConditionCollection = new SearchConditionCollection();

        /// <summary>
        /// Initializes a new instance of the LogicalObject class with the specified name
        /// </summary>
        /// <param name="name">The specified name</param>
        public LogicalObject(string name)
            : base("dbo", name)
        {
        }

        /// <summary>
        /// Gets the list of includes for this object
        /// </summary>
        public List<LogicalObjectInclude> Includes
        {
            get { return this.listLogicalObjectIncludes; }
        }

        /// <summary>
        /// Gets the list of includes for this object in reverse order
        /// </summary>
        public List<LogicalObjectInclude> IncludesReverse
        {
            get
            {
                if (null == this.listLogicalObjectIncludesReverse)
                {
                    this.listLogicalObjectIncludesReverse = new List<LogicalObjectInclude>(this.listLogicalObjectIncludes);
                    this.listLogicalObjectIncludesReverse.Reverse();
                }

                return this.listLogicalObjectIncludesReverse;
            }
        }

        /// <summary>
        /// Gets the collection of key ref hints for this object
        /// </summary>
        public NameCollection<LogicalObjectKeyRefHint> KeyRefHints
        {
            get { return this.collectionLogicalObjectKeyRefHints; }
        }

        /// <summary>
        /// Gets the collection of keys for this object
        /// </summary>
        public NameCollection<LogicalObjectKey> Keys
        {
            get { return this.collectionLogicalObjectKeys; }
        }

        /// <summary>
        /// Gets or sets the search condition root for this object
        /// </summary>
        public SearchCondition SearchCondition
        {
            get { return this.searchConditionRoot; }
            set { this.searchConditionRoot = value; }
        }

        /// <summary>
        /// Gets or sets the search condition collection for this object
        /// </summary>
        public SearchConditionCollection SearchConditionCollection
        {
            get { return this.searchConditionCollection; }
            set { this.searchConditionCollection = value; }
        }

        /// <summary>
        /// Gets the list of xpath expression selector elements for this object
        /// </summary>
        public List<string> Selectors
        {
            get { return this.listSelectors; }
        }

        /// <summary>
        /// Creates a new object that is a copy of the current instance
        /// </summary>
        /// <returns>A new object that is a copy of the current instance</returns>
        object System.ICloneable.Clone()
        {
            // create a new logical object
            LogicalObject logicalObjectClone = new LogicalObject(this.Name);

            // key ref hints can be a reference, since they are not modified by the schema set
            logicalObjectClone.collectionLogicalObjectKeyRefHints = this.collectionLogicalObjectKeyRefHints;

            // copy the keys, since additional keys will be generated by the schema set
            logicalObjectClone.collectionLogicalObjectKeys.AddRange(this.collectionLogicalObjectKeys);

            // clone the includes, since they are modified by the schema set
            foreach (LogicalObjectInclude logicalObjectInclude in this.listLogicalObjectIncludes)
            {
                logicalObjectClone.listLogicalObjectIncludes.Add((logicalObjectInclude as ICloneable).Clone() as LogicalObjectInclude);
            }

            // the includes reverse is generated when needed
            logicalObjectClone.listLogicalObjectIncludesReverse = null;

            // keep selectors, since they are not modified by the schema set
            logicalObjectClone.listSelectors = this.listSelectors;

            // clone search condition collection
            logicalObjectClone.searchConditionCollection = (this.searchConditionCollection as ICloneable).Clone() as SearchConditionCollection;

            return logicalObjectClone;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\PrimaryKey.cs ===
//-----------------------------------------------------------------------
// <copyright file="PrimaryKey.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a primary key and its fields
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Collections.Generic;

    /// <summary>
    /// Class to represent a primary key
    /// </summary>
    internal sealed class PrimaryKey
    {
        /// <summary>
        /// fields is the list of columns composing the primary key
        /// </summary>
        private List<string> fields = new List<string>();

        /// <summary>
        /// name is the name of the primary key
        /// </summary>
        private string name;

        /// <summary>
        /// Initializes a new instance of the PrimaryKey class with the specified name
        /// </summary>
        /// <param name="name">The name of the primary key</param>
        public PrimaryKey(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Gets the list of columns composing the primary key
        /// </summary>
        public List<string> Fields
        {
            get { return this.fields; }
        }

        /// <summary>
        /// Gets the name of the primary key
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\NameCollection.cs ===
//-----------------------------------------------------------------------
// <copyright file="NameCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a sorted collection of objects exposing a Name property
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Reflection;

    /// <summary>
    /// Represents a collection of objects sorted by the objects' Name property
    /// </summary>
    /// <typeparam name="T">The strongly typed object for the class</typeparam>
    internal sealed class NameCollection<T> : IEnumerable<T>
    {
        /// <summary>
        /// dictionaryNameObjects is the dictionary of objects where the key is the Name property of the object
        /// </summary>
        private Dictionary<string, T> dictionaryNameObjects = new Dictionary<string, T>();

        /// <summary>
        /// Specifies if the list needs to be sorted before an operation
        /// </summary>
        private bool dirty = false;

        /// <summary>
        /// listNameObjects is the sorted list of objects
        /// </summary>
        private List<T> listNameObjects = new List<T>();

        /// <summary>
        /// Initializes a new instance of the NameCollection class
        /// </summary>
        public NameCollection()
        {
            if ((typeof(string) != typeof(T)) && (null == typeof(T).GetProperty("Name", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)))
            {
                throw new ArgumentException(String.Format("Type '{0}' does not expose a 'Name' public property.", typeof(T).Name));
            }
        }

        /// <summary>
        /// Gets the number of objects in the collection
        /// </summary>
        public int Count
        {
            get { return this.dictionaryNameObjects.Count; }
        }

        /// <summary>
        /// Returns the object at the specified index in the collection
        /// </summary>
        /// <param name="index">The name of the object to return</param>
        /// <returns>The object at the specified index if it exists; otherwise, null</returns>
        public T this[string index]
        {
            get
            {
                if (false == this.dictionaryNameObjects.ContainsKey(index))
                {
                    return default(T);
                }

                return this.dictionaryNameObjects[index];
            }

            set
            {
                this.dictionaryNameObjects[index] = value;
            }
        }

        /// <summary>
        /// Adds the specified object to the collection
        /// </summary>
        /// <param name="item">The object to add to the collection</param>
        public void Add(T item)
        {
            string name = null;

            if (typeof(string) == typeof(T))
            {
                name = item as string;
            }
            else
            {
                name = typeof(T).GetProperty("Name", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static).GetValue(item, null) as string;
            }

            if (true == String.IsNullOrEmpty(name))
            {
                return;
            }

            // check if the item already exists in the collection
            if (false == this.dictionaryNameObjects.ContainsKey(name))
            {
                // it does not, so safe to add to the list
                this.dictionaryNameObjects[name] = item;

                lock (this.listNameObjects)
                {
                    this.listNameObjects.Add(item);
                    this.dirty = true;
                }
            }
            else
            {
                // it does exist, so do some checks if it needs to be replaced

                // if it is a string, it does not need to be replaced since it is identical
                if (typeof(string) == typeof(T))
                {
                    return;
                }

                // not a string, so get the existing item
                T itemExisting = this.dictionaryNameObjects[name];

                // check if the new item is the same as the existing item
                if (false == System.Object.ReferenceEquals(item, itemExisting))
                {
                    // it is a different item, so replace existing item with new item
                    this.dictionaryNameObjects[name] = item;

                    lock (this.listNameObjects)
                    {
                        // get the index of the existing item
                        int index = this.listNameObjects.IndexOf(itemExisting);

                        // replace the item
                        this.listNameObjects[index] = item;
                    }
                }
            }
        }

        /// <summary>
        /// Adds the elements of the specified collection to the collection
        /// </summary>
        /// <param name="collection">The collection whose elements should be added to the collection</param>
        public void AddRange(IEnumerable<T> collection)
        {
            foreach (T item in collection)
            {
                this.Add(item);
            }
        }

        /// <summary>
        /// Removes all objects from the collection
        /// </summary>
        public void Clear()
        {
            this.dictionaryNameObjects.Clear();

            lock (this.listNameObjects)
            {
                this.listNameObjects.Clear();
                this.dirty = false;
            }
        }

        /// <summary>
        /// Determines whether an object is in the collection
        /// </summary>
        /// <param name="item">The object to locate in the collection</param>
        /// <returns>true if object is found in the collection; otherwise, false</returns>
        public bool Contains(T item)
        {
            string name = null;

            if (typeof(string) == typeof(T))
            {
                name = item as string;
            }
            else
            {
                name = typeof(T).GetProperty("Name", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static).GetValue(item, null) as string;
            }

            if (true == String.IsNullOrEmpty(name))
            {
                return false;
            }

            return this.Contains(name);
        }

        /// <summary>
        /// Determines whether an object is in the collection
        /// </summary>
        /// <param name="index">The object name to locate in the collection</param>
        /// <returns>true if object is found in the collection; otherwise, false</returns>
        public bool Contains(string index)
        {
            return this.dictionaryNameObjects.ContainsKey(index);
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            lock (this.listNameObjects)
            {
                if (true == this.dirty)
                {
                    this.listNameObjects.Sort(new NameComparer());
                    this.dirty = false;
                }
            }

            foreach (T obj in this.listNameObjects)
            {
                yield return obj;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Removes the specified object from the collection
        /// </summary>
        /// <param name="item">The object to add to the collection</param>
        public void Remove(T item)
        {
            string name = null;

            if (typeof(string) == typeof(T))
            {
                name = item as string;
            }
            else
            {
                name = typeof(T).GetProperty("Name", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static).GetValue(item, null) as string;
            }

            if (true == String.IsNullOrEmpty(name))
            {
                return;
            }

            // get the existing item
            T itemExisting = this[name];

            if (null == itemExisting)
            {
                // nothing to do
                return;
            }

            this.dictionaryNameObjects.Remove(name);

            lock (this.listNameObjects)
            {
                this.listNameObjects.Remove(itemExisting);
            }
        }

        /// <summary>
        /// Defines a method that NameCollection invokes to compare two objects
        /// </summary>
        private class NameComparer : IComparer<T>
        {
            /// <summary>
            /// Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other
            /// </summary>
            /// <param name="x">The first object to compare</param>
            /// <param name="y">The second object to compare</param>
            /// <returns>A value less than zero, x is less than y; zero, x equals y; greater than zero, x is greater than y</returns>
            public int Compare(T x, T y)
            {
                string nameX = null;
                string nameY = null;

                if (typeof(string) == typeof(T))
                {
                    nameX = x as string;
                    nameY = y as string;
                }
                else
                {
                    nameX = typeof(T).GetProperty("Name", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static).GetValue(x, null) as string;
                    nameY = typeof(T).GetProperty("Name", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static).GetValue(y, null) as string;
                }

                return String.Compare(nameX, nameY, StringComparison.OrdinalIgnoreCase);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\ReplaceChars.cs ===
//-----------------------------------------------------------------------
// <copyright file="ReplaceChars.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   map the sql character set to the xml character set
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Text;

    /// <summary>
    /// Class to map the sql character set to the xml character set
    /// </summary>
    internal static class ReplaceChars
    {
        /// <summary>
        /// charMap is the character map from old character to new string
        /// </summary>
        private static Dictionary<int, string> charMap = new Dictionary<int, string>();

        /// <summary>
        /// replaceChars is the collection of old characters to be replace
        /// </summary>
        private static readonly int[] replaceChars = {
            0x20, // space
            0x21, // exclamation mark
            0x23, // number sign
            0x24, // dollar sign
            0x25, // percent sign
            0x26, // amphersand
            0x27, // apostrophe
            0x28, // left parenthesis
            0x29, // right parenthesis
            0x2A, // asterisk
            0x2B, // plus sign
            0x2C, // comma
            0x2D, // hyphen
            0x2F, // slash
            0x3A, // colon
            0x3B, // semicolon
            0x3C, // less than sign
            0x3D, // equals sign
            0x3E, // greater than sign
            0x3F, // question mark
            0x40, // at sign
            0x5C, // backslash
            0x5E, // caret
            0x60, // grave accent
            0x7B, // left bracket
            0x7D, // right bracket
            0x7C, // vertical bar
            0x7E  // tilde
        };

        /// <summary>
        /// Initializes a new instance of the ReplaceChars class
        /// </summary>
        static ReplaceChars()
        {
            // iterate the predefined characters in the array
            foreach (int replaceChar in ReplaceChars.replaceChars)
            {
                ReplaceChars.charMap[replaceChar] = String.Format("_x{0:X4}_", replaceChar);
            }
        }

        /// <summary>
        /// Replaces the sql characters in the string that cannot be mapped to the xml character set
        /// </summary>
        /// <param name="sqlString">The string of sql characters</param>
        /// <returns>The string of xml characters</returns>
        internal static string Replace(string sqlString)
        {
            StringBuilder stringBuilder = new StringBuilder();

            // get the first character - if a number it must be replaced
            string newValue = String.Empty;
            if (true == ReplaceChars.charMap.TryGetValue(sqlString[0], out newValue))
            {
                stringBuilder.Append(newValue);
            }
            else if ((0x30 <= sqlString[0]) && (0x39 >= sqlString[0]))
            {
                stringBuilder.Append(String.Format("_x{0:X4}_", (int)sqlString[0]));
            }
            else
            {
                stringBuilder.Append(sqlString[0]);
            }

            // iterate the remaining old values in the string and replace if necessary
            for (int index = 1; index < sqlString.Length; index++)
            {
                int oldValue = sqlString[index];

                if (true == ReplaceChars.charMap.TryGetValue(oldValue, out newValue))
                {
                    stringBuilder.Append(newValue);
                }
                else
                {
                    stringBuilder.Append((char)oldValue);
                }
            }

            return stringBuilder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\PublishSchemaInternal.cs ===
//-----------------------------------------------------------------------
// <copyright file="PublishSchemaInternal.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a public schema for internal use
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Xml.Schema;

    /// <summary>
    /// Represents an additional schema that should be published for internal use
    /// </summary>
    internal sealed class PublishSchemaInternal
    {
        /// <summary>
        /// collectionComplexTypes is the collection of complex types for the schema
        /// </summary>
        private NameCollection<XmlSchemaComplexType> collectionComplexTypes = new NameCollection<XmlSchemaComplexType>();

        /// <summary>
        /// collectionElements is the collection of elements for the schema
        /// </summary>
        private NameCollection<XmlSchemaElement> collectionElements = new NameCollection<XmlSchemaElement>();

        /// <summary>
        /// collectionRootElements is the collection of elements within the root element
        /// </summary>
        private NameCollection<XmlSchemaElement> collectionRootElements = new NameCollection<XmlSchemaElement>();

        /// <summary>
        /// collectionSimpleTypes is the collection of simple types for the schema
        /// </summary>
        private NameCollection<XmlSchemaSimpleType> collectionSimpleTypes = new NameCollection<XmlSchemaSimpleType>();

        /// <summary>
        /// The publish schema for this object
        /// </summary>
        private PublishSchema publishSchema;

        /// <summary>
        /// Initializes a new instance of the PublishSchemaInternal class with the specified publish schema
        /// </summary>
        /// <param name="publishSchema">The specified publish schema</param>
        public PublishSchemaInternal(PublishSchema publishSchema)
        {
            this.publishSchema = publishSchema;
        }

        /// <summary>
        /// Gets the collection of xml schema complex types
        /// </summary>
        public NameCollection<XmlSchemaComplexType> ComplexTypes
        {
            get { return this.collectionComplexTypes; }
        }

        /// <summary>
        /// Gets the collection of xml schema elements
        /// </summary>
        public NameCollection<XmlSchemaElement> Elements
        {
            get { return this.collectionElements; }
        }

        /// <summary>
        /// Gets the publis schema
        /// </summary>
        public PublishSchema PublishSchema
        {
            get { return this.publishSchema; }
        }

        /// <summary>
        ///  Gets the collection of xml schema elements for the root
        /// </summary>
        public NameCollection<XmlSchemaElement> RootElements
        {
            get { return this.collectionRootElements; }
        }

        /// <summary>
        /// Gets the collection of xml schema simple types
        /// </summary>
        public NameCollection<XmlSchemaSimpleType> SimpleTypes
        {
            get { return this.collectionSimpleTypes; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\QueryContext.cs ===
//-----------------------------------------------------------------------
// <copyright file="QueryContext.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a context for the query work items
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;

    /// <summary>
    /// Represents the context information for the query work items
    /// </summary>
    internal sealed class QueryContext
    {
        /// <summary>
        /// The exception that occurred, if any
        /// </summary>
        private Exception ex;

        /// <summary>
        /// Initializes a new instance of the QueryContext class
        /// </summary>
        public QueryContext()
        {
        }

        /// <summary>
        /// Gets or sets the exception that occurred, if any
        /// </summary>
        public Exception Exception
        {
            get { return this.ex; }
            set { this.ex = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SchemaElement.cs ===
//-----------------------------------------------------------------------
// <copyright file="SchemaElement.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a schema element
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Data;

    /// <summary>
    /// Class to represent a schema element (column and type for tables, parameter and type for stored procs)
    /// </summary>
    internal sealed class SchemaElement
    {
        /// <summary>
        /// Specifies the string representation of the sql data type for the column or parameter
        /// </summary>
        private string dataType;

        /// <summary>
        /// Specifies the column or parameter maximum length
        /// </summary>
        private int maxLength;

        /// <summary>
        /// Specifies the column or parameter name
        /// </summary>
        private string name;

        /// <summary>
        /// Specifies the column or parameter raw name
        /// </summary>
        private string nameRaw;

        /// <summary>
        /// Specifies if the column or parameter is optional
        /// </summary>
        private bool optional;

        /// <summary>
        /// Specifies the parameter direction (Input for tables)
        /// </summary>
        private ParameterDirection parameterDirection = ParameterDirection.Input;

        /// <summary>
        /// Specifies the sql data type for the column or parameter
        /// </summary>
        private SqlDbType sqlDbType;

        /// <summary>
        /// Specifies if the column or parameter is suppressed
        /// </summary>
        private bool suppressed;

        /// <summary>
        /// Initializes a new instance of the SchemaElement class
        /// 
        /// </summary>
        /// <param name="name">The column or parameter name</param>
        /// <param name="parameterDirection">The parameter direction</param>
        /// <param name="optional">Specifies if the column or parameter is optional</param>
        /// <param name="dataType">Specifies the sql data type for the column or parameter</param>
        /// <param name="maxLength">Specifies the column or parameter maximum length</param>
        public SchemaElement(string name, string parameterDirection, bool optional, string dataType, int maxLength)
        {
            this.name = ReplaceChars.Replace(name);
            this.nameRaw = name;

            if ("INOUT" == parameterDirection)
            {
                this.parameterDirection = ParameterDirection.InputOutput;
            }
            else if ("OUT" == parameterDirection)
            {
                this.parameterDirection = ParameterDirection.Output;
            }
            else
            {
                this.parameterDirection = ParameterDirection.Input;
            }

            this.optional = optional;
            this.dataType = dataType;
            this.sqlDbType = SqlDataType.GetSqlDbType(dataType);
            this.maxLength = maxLength;
        }

        /// <summary>
        /// Gets or sets the string representation of the sql data type for the column or parameter
        /// </summary>
        public string DataType
        {
            get { return this.dataType; }
            set { this.dataType = value; }
        }

        /// <summary>
        /// Gets the parameter direction
        /// </summary>
        public ParameterDirection Direction
        {
            get { return this.parameterDirection; }
        }

        /// <summary>
        /// Gets the column or parameter maximum length
        /// </summary>
        public int MaxLength
        {
            get { return this.maxLength; }
        }

        /// <summary>
        /// Gets the column or parameter name
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the column or parameter raw name
        /// </summary>
        public string NameRaw
        {
            get { return this.nameRaw; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the column or parameter is optional
        /// </summary>
        public bool Optional
        {
            get { return this.optional; }
            set { this.optional = value; }
        }

        /// <summary>
        /// Gets the sql db type for the column or parameter
        /// </summary>
        public SqlDbType SqlDbType
        {
            get { return this.sqlDbType; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the column or parameter is suppressed
        /// </summary>
        public bool Suppressed
        {
            get { return this.suppressed; }
            set { this.suppressed = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\PublishSchema.cs ===
//-----------------------------------------------------------------------
// <copyright file="PublishSchema.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a public schema and its elements
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Represents an additional schema that should be published
    /// </summary>
    public sealed class PublishSchema
    {
        /// <summary>
        /// The collection of elements for this object
        /// </summary>
        private NameCollection<string> collectionElements = new NameCollection<string>();

        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// The schema for this object
        /// </summary>
        private string schema;

        /// <summary>
        /// Initializes a new instance of the PublishSchema class with the specified object name
        /// </summary>
        /// <param name="name">The specified object name</param>
        internal PublishSchema(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the schema for this object
        /// </summary>
        public string Schema
        {
            get { return this.schema; }
            internal set { this.schema = value; }
        }

        /// <summary>
        /// Gets the list of elements for this object
        /// </summary>
        internal NameCollection<string> Elements
        {
            get { return this.collectionElements; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SchemaObject.cs ===
//-----------------------------------------------------------------------
// <copyright file="SchemaObject.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a schema object
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;

    /// <summary>
    /// Represents a schema object, such as a table, stored procedure, or logical object
    /// </summary>
    internal abstract class SchemaObject : IEquatable<SchemaObject>
    {
        /// <summary>
        /// The name for this object
        /// </summary>
        private string name;

        /// <summary>
        /// The raw name for this object
        /// </summary>
        private string nameRaw;

        /// <summary>
        /// The raw schema for this object
        /// </summary>
        private string schemaRaw;

        /// <summary>
        /// Initializes a new instance of the SchemaObject class with the specified name
        /// </summary>
        /// <param name="schema">The specified schema</param>
        /// <param name="name">The specified name</param>
        public SchemaObject(string schema, string name)
        {
            this.schemaRaw = schema;
            this.nameRaw = name;

            this.name = SchemaObject.GetName(this.schemaRaw, this.nameRaw);
        }

        /// <summary>
        /// Gets the name for this object
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the raw name for this object
        /// </summary>
        public string NameRaw
        {
            get { return this.nameRaw; }
        }

        /// <summary>
        /// Gets the qualified name for this object
        /// </summary>
        public string QualifiedName
        {
            get { return "[" + this.schemaRaw + "].[" + this.nameRaw + "]"; }
        }

        /// <summary>
        /// Gets the schema for this object
        /// </summary>
        public string SchemaRaw
        {
            get { return this.schemaRaw; }
        }

        /// <summary>
        /// Returns a qualified name, excepting the dbo schema
        /// </summary>
        /// <param name="schema">The schema object schema</param>
        /// <param name="name">The schema object name</param>
        /// <returns>The qualified name, excepting the dbo schema</returns>
        public static string GetName(string schema, string name)
        {
            schema = ReplaceChars.Replace(schema);
            name = ReplaceChars.Replace(name);

            // check if the object is owned by the dbo schema
            if ("dbo" == schema)
            {
                // if so, default to the name only
                return name;
            }

            // else, use fully qualified name
            return schema + "." + name;
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="obj">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public override bool Equals(object obj)
        {
            if (false == (obj is SchemaObject))
            {
                return false;
            }

            return this.Equals(obj as SchemaObject);
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="other">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public bool Equals(SchemaObject other)
        {
            return this.Name == other.Name;
        }

        /// <summary>
        /// Returns the hash code for the current object
        /// </summary>
        /// <returns>The hash code for the current object</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SearchConditionCollection.cs ===
//-----------------------------------------------------------------------
// <copyright file="SearchConditionCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents a collection of search conditions
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Represents the search condition for a sql query
    /// </summary>
    public sealed class SearchConditionCollection : ICloneable, IEnumerable<SearchCondition>
    {
        // collectionSearchConditions is the collection of search conditions
        private NameCollection<SearchCondition> collectionSearchConditions = new NameCollection<SearchCondition>();

        /// <summary>
        /// Initializes a new instance of the SearchConditionCollection class
        /// </summary>
        public SearchConditionCollection()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SearchConditionCollection class
        /// </summary>
        /// <param name="searchCondition">The search condition for this object</param>
        public SearchConditionCollection(SearchCondition searchCondition)
        {
            this.collectionSearchConditions.Add(searchCondition);
        }

        /// <summary>
        /// Initializes a new instance of the SearchConditionCollection class
        /// </summary>
        /// <param name="searchConditions">The collection of search conditions for this object</param>
        public SearchConditionCollection(IEnumerable<SearchCondition> searchConditions)
        {
            foreach (SearchCondition searchCondition in searchConditions)
            {
                if (true == this.collectionSearchConditions.Contains(searchCondition))
                {
                    throw new InvalidOperationException(String.Format("Search Condition '{0}' is defined multiple times.", searchCondition.Name));
                }

                this.collectionSearchConditions.Add(searchCondition);
            }
        }

        /// <summary>
        /// Returns the object at the specified index in the collection
        /// </summary>
        /// <param name="index">The name of the object to return</param>
        /// <returns>The object at the specified index if it exists; otherwise, null</returns>
        public SearchCondition this[string index]
        {
            get { return this.collectionSearchConditions[index]; }
        }

        /// <summary>
        /// Adds the specified search condition to the collection
        /// </summary>
        /// <param name="searchCondition">The specified search condition</param>
        public void Add(SearchCondition searchCondition)
        {
            if (true == this.collectionSearchConditions.Contains(searchCondition))
            {
                throw new InvalidOperationException(String.Format("Search Condition '{0}' is defined multiple times.", searchCondition.Name));
            }

            // clone the search condition and add
            SearchCondition searchConditionClone = (searchCondition as ICloneable).Clone() as SearchCondition;
            this.collectionSearchConditions.Add(searchConditionClone);
        }

        /// <summary>
        /// Creates a new object that is a copy of the current instance
        /// </summary>
        /// <returns>A new object that is a copy of the current instance</returns>
        object System.ICloneable.Clone()
        {
            // create a new search condition collection
            SearchConditionCollection searchConditionCollectionClone = new SearchConditionCollection();

            // clone each search condition and add to the new search condition collection
            foreach (SearchCondition searchCondition in this.collectionSearchConditions)
            {
                searchConditionCollectionClone.collectionSearchConditions.Add((searchCondition as ICloneable).Clone() as SearchCondition);
            }

            return searchConditionCollectionClone;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<SearchCondition> IEnumerable<SearchCondition>.GetEnumerator()
        {
            foreach (SearchCondition searchCondition in this.collectionSearchConditions)
            {
                yield return searchCondition;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Resolves the search conditions in the collection using the specified schema set
        /// </summary>
        /// <param name="dbSchemaSet">The specified schema set</param>
        internal void Resolve(DBSchemaSet dbSchemaSet)
        {
            foreach (SearchCondition searchCondition in this.collectionSearchConditions)
            {
                searchCondition.Resolve(dbSchemaSet);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SqlDataType.cs ===
//-----------------------------------------------------------------------
// <copyright file="SqlDataType.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   maps a friendly name to SqlDbType enum
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Data;

    /// <summary>
    /// Class to map a friendly name to SqlDbType enum
    /// </summary>
    internal static class SqlDataType
    {
        /// <summary>
        /// dictionary to map the friendly name to the sql db type enum
        /// </summary>
        private static Dictionary<string, SqlDbType> dictionarySqlDataType = new Dictionary<string, SqlDbType>(StringComparer.InvariantCultureIgnoreCase);

        /// <summary>
        /// Gets the sql db type enum represented by the friendly name
        /// </summary>
        /// <param name="dataType">The sql data type friendly name</param>
        /// <returns>The sql db type enum</returns>
        public static SqlDbType GetSqlDbType(string dataType)
        {
            // check if the dictionary has been initialized
            lock (dictionarySqlDataType)
            {
                if (0 == dictionarySqlDataType.Count)
                {
                    // initialize the dictionary
                    foreach (SqlDbType sqlDataType in Enum.GetValues(typeof(SqlDbType)))
                    {
                        dictionarySqlDataType[sqlDataType.ToString()] = sqlDataType;
                    }

                    dictionarySqlDataType["sql_variant"] = SqlDbType.Variant;
                    dictionarySqlDataType["numeric"] = SqlDbType.Decimal;
                }
            }

            // map the friendly name to the sql db type enum
            return dictionarySqlDataType[dataType];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SqlAction.cs ===
//-----------------------------------------------------------------------
// <copyright file="SqlAction.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   specify the type of sql action
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    /// <summary>
    /// Enum to specify the type of sql action: begin, insert, update, execute, delete, skipped or end
    /// </summary>
    public enum SqlAction
    {
        /// <summary>
        /// Begin Action
        /// </summary>
        Begin,

        /// <summary>
        /// Selected Object
        /// </summary>
        Select,

        /// <summary>
        /// Inserted Object
        /// </summary>
        Insert,

        /// <summary>
        /// Updated Object
        /// </summary>
        Update,

        /// <summary>
        /// Executed Object
        /// </summary>
        Execute,

        /// <summary>
        /// Deleted Object
        /// </summary>
        Delete,

        /// <summary>
        /// Skipped Object
        /// </summary>
        Skipped,

        /// <summary>
        /// End Action
        /// </summary>
        End
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\StackHelper.cs ===
//-----------------------------------------------------------------------
// <copyright file="StackHelper.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   resolve stack to a friendly string
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Collections.Generic;
    using System.Text;

    /// <summary>
    /// Implements a Stack for returning string representations of the stack
    /// </summary>
    internal sealed class StackHelper : Stack<string>
    {
        /// <summary>
        /// Returns the root element of the stack
        /// </summary>
        /// <returns>The root element of the stack</returns>
        public string GetRoot()
        {
            string[] stackElements = this.ToArray();

            return stackElements[stackElements.Length - 1];
        }

        /// <summary>
        /// Returns a string representation of the stack
        /// </summary>
        /// <returns>The string representation of the stack</returns>
        public override string ToString()
        {
            string[] stackElements = this.ToArray();
            StringBuilder stringBuilder = new StringBuilder();

            for (int index = stackElements.Length - 1; index >= 0; index--)
            {
                stringBuilder.Append(stackElements[index]);
                stringBuilder.Append("/");
            }

            return stringBuilder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\StringWriterUTF8.cs ===
//-----------------------------------------------------------------------
// <copyright file="StringWriterUTF8.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   implements a TextWriter for writing information to a UTF8 encoded string
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.IO;
    using System.Text;

    /// <summary>
    /// Implements a TextWriter for writing information to a UTF8 encoded string
    /// </summary>
    internal sealed class StringWriterUTF8 : StringWriter
    {
        /// <summary>
        /// Initializes a new instance of the StringWriterUTF8 class that writes to the specified StringBuilder
        /// </summary>
        /// <param name="stringBuilder">The StringBuilder to write to</param>
        public StringWriterUTF8(StringBuilder stringBuilder)
            : base(stringBuilder)
        {
        }

        /// <summary>
        /// Gets the Encoding in which the output is written (UTF8)
        /// </summary>
        public override Encoding Encoding
        {
            get { return Encoding.UTF8; }
        }

        /// <summary>
        /// Releases all the unmanaged resources used by the StringWriterUTF8 and optionally releases the managed resources
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SearchCondition.cs ===
//-----------------------------------------------------------------------
// <copyright file="SearchCondition.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represents the search condition for a sql query
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;

    /// <summary>
    /// Represents the search condition for a sql query
    /// </summary>
    public sealed class SearchCondition : ICloneable
    {
        /// <summary>
        /// xmlSchemaSetSearchCondition is the schema set to validate the search condition xml document
        /// </summary>
        private static XmlSchemaSet xmlSchemaSetSearchCondition = XmlHelper.LoadSchemaSetFromResource("SearchCondition.xsd", DBSchemaConstants.NamespaceSearchCondition);

        /// <summary>
        /// The condition for this search condition
        /// </summary>
        private string condition;

        /// <summary>
        /// The database object name for this search condition
        /// </summary>
        private string databaseObjectName;

        /// <summary>
        /// The list of predicates for this search condition
        /// </summary>
        private List<Predicate> listPredicates = new List<Predicate>();

        /// <summary>
        /// The list of sql parameters for this search condition
        /// </summary>
        private List<SqlParameter> listSqlParameters = new List<SqlParameter>();

        /// <summary>
        /// The selector for the logical object, if any
        /// </summary>
        private string selector;

        /// <summary>
        /// The schema object name for this search condition
        /// </summary>
        private string schemaObjectName;

        /// <summary>
        /// Initializes a new instance of the SearchCondition class
        /// </summary>
        public SearchCondition()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SearchCondition class
        /// </summary>
        /// <param name="typeName">The type name for the predicate</param>
        public SearchCondition(string typeName)
        {
            this.schemaObjectName = typeName;
            this.selector = typeName;
        }

        /// <summary>
        /// Specifies the search condition logical operation
        /// </summary>
        public enum LogicalOperation
        {
            /// <summary>
            /// Combine the two search conditions and return TRUE when both are TRUE
            /// </summary>
            And,

            /// <summary>
            /// Combine the two search conditions and return TRUE when the first is TRUE and the second is FALSE
            /// </summary>
            AndNot,

            /// <summary>
            /// Combine the two search conditions and return TRUE when either is TRUE
            /// </summary>
            Or,

            /// <summary>
            /// Combine the two search conditions and return TRUE when the first is TRUE or the second is FALSE
            /// </summary>
            OrNot
        }

        /// <summary>
        /// Specifies the search condition operation
        /// </summary>
        public enum Operation
        {
            /// <summary>
            /// The search condition is null
            /// </summary>
            IsNull,

            /// <summary>
            /// The search condition is not null
            /// </summary>
            IsNotNull,

            /// <summary>
            /// The search condition equals the specified value
            /// </summary>
            Equals,

            /// <summary>
            /// The search condition does not equal the specified value
            /// </summary>
            NotEquals,

            /// <summary>
            /// The search condition is less than the specified value
            /// </summary>
            LessThan,

            /// <summary>
            /// The search condition is less than or equals the specified value
            /// </summary>
            LessThanOrEquals,

            /// <summary>
            /// The search condition is greater than the specified value
            /// </summary>
            GreaterThan,

            /// <summary>
            /// The search condition is greater than or equals the specified value
            /// </summary>
            GreaterThanOrEquals,

            /// <summary>
            /// The search condition matches the specified pattern
            /// </summary>
            Like,

            /// <summary>
            /// The search condition does not match the specified pattern
            /// </summary>
            NotLike
        }

        /// <summary>
        /// Gets the condition for this search condition
        /// </summary>
        internal string Condition
        {
            get { return this.condition; }
        }

        /// <summary>
        /// Gets the database object name for this search condition
        /// </summary>
        internal string DatabaseObjectName
        {
            get { return this.databaseObjectName; }
        }

        /// <summary>
        /// Gets the name of this search condition
        /// </summary>
        internal string Name
        {
            get { return this.selector; }
        }

        /// <summary>
        /// Gets the schema object name for this search condition
        /// </summary>
        internal string SchemaObjectName
        {
            get { return this.schemaObjectName; }
        }

        /// <summary>
        /// Gets the collection of sql parameters for this search condition
        /// </summary>
        internal IEnumerable<SqlParameter> SqlParameters
        {
            get { return this.listSqlParameters; }
        }

        /// <summary>
        /// Load, validate, and parse the search conditions from the specified xml document
        /// </summary>
        /// <param name="xpathNavigator">An xpath navigator to the current node</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>A collection of search conditions</returns>
        public static SearchConditionCollection LoadSearchConditions(XPathNavigator xpathNavigator, ValidationEventHandler veh)
        {
            // wrap the old xml in a dbschemasearchcondition element for verification
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                using (XmlTextWriterNoNamespace xmlTextWriter = new XmlTextWriterNoNamespace(stringWriterUTF8))
                {
                    // write the start element
                    xmlTextWriter.WriteStartElementWithNamespace(String.Empty, DBSchemaConstants.NameSearchCondition, DBSchemaConstants.NamespaceSearchCondition);

                    // ignore namespaces in the old xml
                    xmlTextWriter.IgnoreNamespace = true;

                    // write the old xml
                    // check if this is the root element and inner xml should be written or individual element should be written
                    if (DBSchemaConstants.NameSearchCondition == xpathNavigator.Name)
                    {
                        XPathNodeIterator xpathNodeIterator = xpathNavigator.SelectChildren(XPathNodeType.Element);
                        while (true == xpathNodeIterator.MoveNext())
                        {
                            xmlTextWriter.WriteNode(xpathNodeIterator.Current, false);
                        }
                    }
                    else
                    {
                        xmlTextWriter.WriteNode(xpathNavigator, false);
                    }

                    // write the end element
                    xmlTextWriter.WriteEndElement();
                }
            }

            // validate the new document
            using (StringReader stringReader = new StringReader(stringBuilder.ToString()))
            {
                xpathNavigator = XmlHelper.Validate(stringReader, SearchCondition.xmlSchemaSetSearchCondition, false, veh);
            }

            return SearchCondition.LoadSearchConditions(xpathNavigator);
        }

        /// <summary>
        /// Load, validate, and parse the search conditions from the specified xml document
        /// </summary>
        /// <param name="fileName">The file name containing the xml data</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>A collection of search conditions</returns>
        public static SearchConditionCollection LoadSearchConditions(string fileName, ValidationEventHandler veh)
        {
            // load the document
            XPathNavigator xpathNavigator = XmlHelper.LoadDocument(fileName, SearchCondition.xmlSchemaSetSearchCondition, false, veh);

            return SearchCondition.LoadSearchConditions(xpathNavigator);
        }

        /// <summary>
        /// Appends the specified search condition to this search condition
        /// </summary>
        /// <param name="logicalOperation">The specified logical operation for the specified search condition</param>
        /// <param name="searchCondition">The specified search condition</param>
        public void Append(LogicalOperation logicalOperation, SearchCondition searchCondition)
        {
            // validate the search condition
            this.Validate(searchCondition.schemaObjectName, searchCondition.databaseObjectName, searchCondition.selector);

            // create the predicate
            this.listPredicates.Add(new PredicateGroup(logicalOperation, searchCondition));
        }

        /// <summary>
        /// Appends the specified predicate to the search condition
        /// </summary>
        /// <param name="typeName">The specified type name for this predicate</param>
        /// <param name="logicalOperation">The specified logical operation for this predicate</param>
        /// <param name="xpath">The specified selector and field for this predicate</param>
        /// <param name="operation">The specified operation for this predicate</param>
        /// <param name="value">The specified value for this predicate</param>
        public void Append(string typeName, LogicalOperation logicalOperation, string xpath, Operation operation, string value)
        {
            // field is the field for this predicate
            string field = null;

            // check if the xpath suggests a table or a logical object
            string[] xpaths = xpath.Split('/');

            if (1 == xpaths.Length)
            {
                // suggests a table
                this.Validate(typeName, typeName, typeName);

                field = xpath;
            }
            else
            {
                // suggests a logical object
                this.Validate(typeName, xpaths[xpaths.Length - 2], xpath.Remove(xpath.LastIndexOf('/')));

                field = xpaths[xpaths.Length - 1];
            }

            // add the predicate
            this.listPredicates.Add(new PredicateSingle(logicalOperation, field, operation, value));
        }

        /// <summary>
        /// Creates a new object that is a copy of the current instance
        /// </summary>
        /// <returns>A new object that is a copy of the current instance</returns>
        object System.ICloneable.Clone()
        {
            // create a new search condition
            SearchCondition searchConditionClone = new SearchCondition();

            searchConditionClone.condition = this.condition;

            foreach (Predicate predicate in this.listPredicates)
            {
                searchConditionClone.listPredicates.Add((predicate as ICloneable).Clone() as Predicate);
            }

            foreach (SqlParameter sqlParameter in this.listSqlParameters)
            {
                searchConditionClone.listSqlParameters.Add((sqlParameter as ICloneable).Clone() as SqlParameter);
            }

            searchConditionClone.schemaObjectName = this.schemaObjectName;
            searchConditionClone.databaseObjectName = this.databaseObjectName;
            searchConditionClone.selector = this.selector;

            return searchConditionClone;
        }

        /// <summary>
        /// Inherits the specified search condition as a child
        /// </summary>
        /// <param name="parentName">The specified schema object name of the parent</param>
        /// <param name="childName">The specified schema object name of the child</param>
        /// <param name="searchCondition">The specified search condition</param>
        internal void InheritChild(string parentName, string childName, SearchCondition searchCondition)
        {
            this.schemaObjectName = parentName;
            this.databaseObjectName = searchCondition.databaseObjectName;
            this.selector = childName + "/" + searchCondition.selector;

            foreach (Predicate predicate in searchCondition.listPredicates)
            {
                Predicate predicateClone = (predicate as ICloneable).Clone() as Predicate;
                this.listPredicates.Add(predicateClone);
            }
        }

        /// <summary>
        /// Resolves the search condition using the specified schema set
        /// </summary>
        /// <param name="dbSchemaSet">The specified schema set</param>
        internal void Resolve(DBSchemaSet dbSchemaSet)
        {
            this.condition = null;
            this.listSqlParameters.Clear();

            // check if the search condition is defined
            if (null == this.schemaObjectName)
            {
                throw new InvalidOperationException("SearchCondition is not defined.");
            }

            // check if the search condition is just a type name only
            if (0 == this.listPredicates.Count)
            {
                // get the schema object
                SchemaObject schemaObject = dbSchemaSet.GetSchemaObject(this.schemaObjectName);

                if ((null == schemaObject) || (true == (schemaObject is DatabaseProcedure)))
                {
                    throw new ArgumentException(String.Format("'{0}' is not a defined Table or Logical Object.", this.schemaObjectName));
                }

                if ((true == (schemaObject is LogicalObject)) && (null == (schemaObject as LogicalObject).SearchCondition))
                {
                    throw new InvalidOperationException(String.Format("Logical Object '{0}' is not complete.", this.schemaObjectName));
                }
            }
            else
            {
                // get the schema object
                DatabaseTable databaseTable = this.ResolveDatabaseTable(dbSchemaSet);

                this.ResolvePredicates(dbSchemaSet, databaseTable);
            }
        }

        /// <summary>
        /// Builds a search condition from the xml element
        /// </summary>
        /// <param name="typeName">The type name of the search condition</param>
        /// <param name="xpathNavigator">The xpath navigator to the xml element</param>
        /// <param name="xmlNamespaceManager">The xml namespace manager object for namespace resolution of the specified xml element</param>
        /// <returns>A new search condition object</returns>
        private static SearchCondition BuildSearchCondition(string typeName, XPathNavigator xpathNavigator, XmlNamespaceManager xmlNamespaceManager)
        {
            SearchCondition searchCondition = new SearchCondition();

            // get the children
            XPathNodeIterator xpathNodeIterator = xpathNavigator.SelectChildren(XPathNodeType.Element);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the logical operator
                string logicalOperationText = xpathNodeIterator.Current.GetAttribute("LogicalOperation", String.Empty);
                SearchCondition.LogicalOperation logicalOperation = (SearchCondition.LogicalOperation)Enum.Parse(typeof(SearchCondition.LogicalOperation), logicalOperationText, true);

                // check if this is a group or a predicate
                if ("Group" == xpathNodeIterator.Current.Name)
                {
                    // build the nested search condition as a group and append
                    searchCondition.Append(logicalOperation, SearchCondition.BuildSearchCondition(typeName, xpathNodeIterator.Current, xmlNamespaceManager));
                }
                else
                {
                    // get the xpath
                    string xpath = xpathNodeIterator.Current.GetAttribute("XPath", String.Empty);

                    // get the operator
                    string operationText = xpathNodeIterator.Current.GetAttribute("Operation", String.Empty);
                    SearchCondition.Operation operation = (SearchCondition.Operation)Enum.Parse(typeof(SearchCondition.Operation), operationText, true);

                    // get the value
                    string value = null;
                    if ((SearchCondition.Operation.IsNull != operation) && (SearchCondition.Operation.IsNotNull != operation))
                    {
                        value = xpathNodeIterator.Current.Value;
                    }

                    // append the predicate
                    searchCondition.Append(typeName, logicalOperation, xpath, operation, value);
                }
            }

            return searchCondition;
        }

        /// <summary>
        /// Load, validate, and parse the search conditions from the specified xml document
        /// </summary>
        /// <param name="xpathNavigator">An xpath navigator to the current node</param>
        /// <returns>A collection of search conditions</returns>
        private static SearchConditionCollection LoadSearchConditions(XPathNavigator xpathNavigator)
        {
            // setup the namespace
            XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xpathNavigator.NameTable);
            xmlNamespaceManager.AddNamespace("ns", DBSchemaConstants.NamespaceSearchCondition);

            // validate the root element
            XPathNavigator xpathNavigatorElement = xpathNavigator.SelectSingleNode(".//ns:" + DBSchemaConstants.NameSearchCondition, xmlNamespaceManager);
            if (null == xpathNavigatorElement)
            {
                throw new XmlSchemaValidationException("The XML root element or namespace is invalid.");
            }

            // create the list of search conditions
            List<SearchCondition> listSearchConditions = new List<SearchCondition>();

            // get the search conditions
            XPathNodeIterator xpathNodeIterator = xpathNavigator.Select(".//ns:" + DBSchemaConstants.NameSearchCondition + "/ns:SearchCondition", xmlNamespaceManager);
            while (true == xpathNodeIterator.MoveNext())
            {
                string typeName = xpathNodeIterator.Current.GetAttribute("Type", String.Empty);

                if (0 < xpathNodeIterator.Current.SelectChildren(XPathNodeType.Element).Count)
                {
                    listSearchConditions.Add(SearchCondition.BuildSearchCondition(typeName, xpathNodeIterator.Current, xmlNamespaceManager));
                }
                else
                {
                    listSearchConditions.Add(new SearchCondition(typeName));
                }
            }

            return new SearchConditionCollection(listSearchConditions);
        }

        /// <summary>
        /// Resolves the database table specified by this search condition
        /// </summary>
        /// <param name="dbSchemaSet">The specified schema set</param>
        /// <returns>The database table specified by this search condition</returns>
        private DatabaseTable ResolveDatabaseTable(DBSchemaSet dbSchemaSet)
        {
            SchemaObject schemaObject = dbSchemaSet.GetSchemaObject(this.schemaObjectName);

            if ((null == schemaObject) || (true == (schemaObject is DatabaseProcedure)))
            {
                throw new ArgumentException(String.Format("'{0}' is not a defined Table or Logical Object.", this.schemaObjectName));
            }

            if (false == (schemaObject is LogicalObject))
            {
                // get the database table
                return schemaObject as DatabaseTable;
            }
            else
            {
                LogicalObject logicalObject = schemaObject as LogicalObject;

                // validate the xpath for this logical object
                if (false == logicalObject.Selectors.Contains(this.selector))
                {
                    throw new ArgumentException(String.Format("'{0}' is not a valid XPath for Logical Object '{1}'.", this.selector, this.schemaObjectName));
                }

                // get the database table
                return dbSchemaSet.GetSchemaObject(this.databaseObjectName) as DatabaseTable;
            }
        }

        /// <summary>
        /// Resolves the predicates within this search condition using the specified schema set
        /// </summary>
        /// <param name="dbSchemaSet">The specified schema set</param>
        /// <param name="databaseTable">The database table referenced by this search condition</param>
        private void ResolvePredicates(DBSchemaSet dbSchemaSet, DatabaseTable databaseTable)
        {
            // build the condition
            StringBuilder stringBuilderCondition = null;

            // iterate each predicate
            foreach (Predicate predicate in this.listPredicates)
            {
                if (null == stringBuilderCondition)
                {
                    stringBuilderCondition = new StringBuilder();

                    if (LogicalOperation.AndNot == predicate.LogicalOperation)
                    {
                        stringBuilderCondition.Append("NOT ");
                    }
                }
                else
                {
                    switch (predicate.LogicalOperation)
                    {
                        case LogicalOperation.And:
                            stringBuilderCondition.Append(" AND ");
                            break;

                        case LogicalOperation.AndNot:
                            stringBuilderCondition.Append(" AND NOT ");
                            break;
                        case LogicalOperation.Or:
                            stringBuilderCondition.Append(" OR ");
                            break;
                        case LogicalOperation.OrNot:
                            stringBuilderCondition.Append(" OR NOT ");
                            break;
                    }
                }

                if (true == (predicate is PredicateSingle))
                {
                    // single predicate
                    PredicateSingle predicateSingle = predicate as PredicateSingle;

                    // resolve the predicate
                    predicateSingle.Resolve(databaseTable);

                    // append the condition
                    stringBuilderCondition.Append(predicateSingle.Condition);

                    // append the sql parameter
                    if (null != predicateSingle.SqlParameter)
                    {
                        this.listSqlParameters.Add((predicateSingle.SqlParameter as ICloneable).Clone() as SqlParameter);
                    }
                }
                else
                {
                    // group predicate
                    PredicateGroup predicateGroup = predicate as PredicateGroup;

                    // resolve the group predicate
                    predicateGroup.SearchCondition.Resolve(dbSchemaSet);

                    // append the condition
                    stringBuilderCondition.Append("(" + predicateGroup.SearchCondition.Condition + ")");

                    // append the sql parameters
                    this.listSqlParameters.AddRange(predicateGroup.SearchCondition.SqlParameters);
                }
            }

            // set the condition
            if (null != stringBuilderCondition)
            {
                this.condition = stringBuilderCondition.ToString();
            }
        }

        /// <summary>
        /// Validates the specified predicate of the search condition
        /// </summary>
        /// <param name="schemaObjectName">The schema object name for the predicate</param>
        /// <param name="databaseObjectName">The database object name for the predicate</param>
        /// <param name="selector">The selector for the predicate</param>
        private void Validate(string schemaObjectName, string databaseObjectName, string selector)
        {
            // check if the search condition is just a type name only
            if ((null != this.schemaObjectName) && (0 == this.listPredicates.Count))
            {
                throw new InvalidOperationException("SearchCondition is restricted to a single predicate.");
            }

            if (null == this.schemaObjectName)
            {
                this.schemaObjectName = schemaObjectName;
                this.databaseObjectName = databaseObjectName;
                this.selector = selector;
            }
            else if (this.schemaObjectName != schemaObjectName)
            {
                throw new ArgumentException("Type Name mismatch on SearchCondition");
            }
            else if (this.selector != selector)
            {
                throw new ArgumentException("XPath mismatch on SearchCondition");
            }
        }

        /// <summary>
        /// Class to represent a predicate within the search condition
        /// </summary>
        internal abstract class Predicate
        {
            /// <summary>
            /// logicalOperation is the logical operation of this group
            /// </summary>
            private LogicalOperation logicalOperation;

            /// <summary>
            /// Initializes a new instance of the Predicate class
            /// </summary>
            internal Predicate()
            {
            }

            /// <summary>
            /// Initializes a new instance of the Predicate class
            /// </summary>
            /// <param name="logicalOperation">The specified logical operation for this predicate</param>
            public Predicate(LogicalOperation logicalOperation)
            {
                switch (logicalOperation)
                {
                    case LogicalOperation.And:
                        break;

                    case LogicalOperation.AndNot:
                        break;

                    case LogicalOperation.Or:
                        break;

                    case LogicalOperation.OrNot:
                        break;

                    default:
                        throw new ArgumentException(String.Format("'{0}' is an unknown LogicalOperation", logicalOperation));
                }

                this.logicalOperation = logicalOperation;
            }

            /// <summary>
            /// Gets the logical operation of this predicate
            /// </summary>
            public LogicalOperation LogicalOperation
            {
                get { return this.logicalOperation; }
            }

            /// <summary>
            /// Copies this predicate to the specified predicate
            /// </summary>
            /// <param name="predicate"></param>
            internal void CopyTo(Predicate predicate)
            {
                predicate.logicalOperation = this.logicalOperation;
            }
        }

        /// <summary>
        /// Class to represent a single predicate within the search condition
        /// </summary>
        internal sealed class PredicateSingle : Predicate, ICloneable
        {
            /// <summary>
            /// condition is the condition string of this predicate
            /// </summary>
            private string condition;

            /// <summary>
            /// field is the field of the condition
            /// </summary>
            private string field;

            /// <summary>
            /// operation is the specified operation for this predicate
            /// </summary>
            private Operation operation;

            /// <summary>
            /// sqlParameter is the sql parameter for this predicate
            /// </summary>
            private SqlParameter sqlParameter;

            /// <summary>
            /// value is the specified value for this predicate
            /// </summary>
            private string value;

            /// <summary>
            /// Initializes a new instance of the PredicateSingle class
            /// </summary>
            internal PredicateSingle()
            {
            }

            /// <summary>
            /// Initializes a new instance of the PredicateSingle class
            /// </summary>
            /// <param name="logicalOperation">The specified logical operation for this predicate</param>
            /// <param name="field">The specified field for this predicate</param>
            /// <param name="operation">The specified operation for this predicate</param>
            /// <param name="value">The specified value for this predicate</param>
            public PredicateSingle(LogicalOperation logicalOperation, string field, Operation operation, string value)
                : base(logicalOperation)
            {
                bool nullValue = false;

                switch (operation)
                {
                    case Operation.IsNull:
                        nullValue = true;
                        break;

                    case Operation.IsNotNull:
                        nullValue = true;
                        break;

                    case Operation.Equals:
                        break;

                    case Operation.NotEquals:
                        break;

                    case Operation.LessThan:
                        break;

                    case Operation.LessThanOrEquals:
                        break;

                    case Operation.GreaterThan:
                        break;

                    case Operation.GreaterThanOrEquals:
                        break;

                    case Operation.Like:
                        break;

                    case Operation.NotLike:
                        break;

                    default:
                        throw new ArgumentException(String.Format("'{0}' is an unknown Operation", operation));
                }

                if ((true == nullValue) && (null != value))
                {
                    throw new ArgumentException("value must be null for this Operation");
                }
                else if ((false == nullValue) && (null == value))
                {
                    throw new ArgumentNullException("value");
                }

                this.field = field;
                this.operation = operation;
                this.value = value;
            }

            /// <summary>
            /// Gets the condition of this predicate
            /// </summary>
            public string Condition
            {
                get { return this.condition; }
            }

            /// <summary>
            /// Gets the operation of this predicate
            /// </summary>
            public Operation Operation
            {
                get { return this.operation; }
            }

            /// <summary>
            /// Gets the sql parameter of this predicate
            /// </summary>
            public SqlParameter SqlParameter
            {
                get { return this.sqlParameter; }
            }

            /// <summary>
            /// Gets the value of this predicate
            /// </summary>
            public string Value
            {
                get { return this.value; }
            }

            /// <summary>
            /// Resolves the condition and sql parameter of this predicate
            /// </summary>
            /// <param name="databaseTable">The database table referenced by this predicate</param>
            public void Resolve(DatabaseTable databaseTable)
            {
                this.condition = null;
                this.sqlParameter = null;

                // get the sql db type of the field
                SqlDbType sqlDbType = databaseTable.GetElementType(this.field);

                switch (this.operation)
                {
                    case Operation.IsNull:
                        this.condition = "[" + this.field + "] IS NULL";
                        return;

                    case Operation.IsNotNull:
                        this.condition = "[" + this.field + "] IS NOT NULL";
                        return;
                }

                // SqlParameter
                SqlParameter sqlParameter = new SqlParameter();
                sqlParameter.ParameterName = "@" + Guid.NewGuid().ToString("N");

                switch (this.operation)
                {
                    case Operation.Equals:
                        this.condition = "[" + this.field + "] = " + sqlParameter.ParameterName;
                        break;

                    case Operation.NotEquals:
                        this.condition = "[" + this.field + "] <> " + sqlParameter.ParameterName;
                        break;

                    case Operation.LessThan:
                        this.condition = "[" + this.field + "] < " + sqlParameter.ParameterName;
                        break;

                    case Operation.LessThanOrEquals:
                        this.condition = "[" + this.field + "] <= " + sqlParameter.ParameterName;
                        break;

                    case Operation.GreaterThan:
                        this.condition = "[" + this.field + "] > " + sqlParameter.ParameterName;
                        break;

                    case Operation.GreaterThanOrEquals:
                        this.condition = "[" + this.field + "] >= " + sqlParameter.ParameterName;
                        break;

                    case Operation.Like:
                        this.condition = "[" + this.field + "] LIKE " + sqlParameter.ParameterName;
                        break;

                    case Operation.NotLike:
                        this.condition = "[" + this.field + "] NOT LIKE " + sqlParameter.ParameterName;
                        break;
                }

                // parameter value
                if ((Operation.Like == this.operation) || (Operation.NotLike == this.operation))
                {
                    sqlParameter.Value = this.value;
                }
                else
                {
                    if (SqlDbType.UniqueIdentifier == sqlDbType)
                    {
                        sqlParameter.Value = new Guid(this.value);
                    }
                    else if ((SqlDbType.Binary == sqlDbType) || (SqlDbType.Image == sqlDbType) || (SqlDbType.Timestamp == sqlDbType) || (SqlDbType.VarBinary == sqlDbType))
                    {
                        sqlParameter.Value = Convert.FromBase64String(this.value);
                    }
                    else
                    {
                        sqlParameter.Value = this.value;
                    }
                }

                this.sqlParameter = sqlParameter;
            }

            /// <summary>
            /// Creates a new object that is a copy of the current instance
            /// </summary>
            /// <returns>A new object that is a copy of the current instance</returns>
            object System.ICloneable.Clone()
            {
                // create a new predicate single
                PredicateSingle predicateSingleClone = new PredicateSingle();

                predicateSingleClone.condition = this.condition;
                predicateSingleClone.field = this.field;
                predicateSingleClone.operation = this.operation;

                if (null != this.sqlParameter)
                {
                    predicateSingleClone.sqlParameter = (this.sqlParameter as ICloneable).Clone() as SqlParameter;
                }

                predicateSingleClone.value = this.value;

                base.CopyTo(predicateSingleClone);

                return predicateSingleClone;
            }
        }

        /// <summary>
        /// Class to represent a group predicate within the search condition
        /// </summary>
        internal sealed class PredicateGroup : Predicate, ICloneable
        {
            /// <summary>
            /// searchCondition is the nested search condition within the group
            /// </summary>
            private SearchCondition searchCondition;

            /// <summary>
            /// Initializes a new instance of the PredicateGroup class
            /// </summary>
            internal PredicateGroup()
            {
            }

            /// <summary>
            /// Initializes a new instance of the PredicateGroup class
            /// </summary>
            /// <param name="logicalOperation">The specified logical operation for this group</param>
            /// <param name="searchCondition">The specified search condition for this group</param>
            public PredicateGroup(LogicalOperation logicalOperation, SearchCondition searchCondition)
                : base(logicalOperation)
            {
                this.searchCondition = searchCondition;
            }

            /// <summary>
            /// Gets the search condition of this group
            /// </summary>
            public SearchCondition SearchCondition
            {
                get { return this.searchCondition; }
            }

            /// <summary>
            /// Creates a new object that is a copy of the current instance
            /// </summary>
            /// <returns>A new object that is a copy of the current instance</returns>
            object System.ICloneable.Clone()
            {
                // create a new predicate group
                PredicateGroup predicateGroupClone = new PredicateGroup();

                predicateGroupClone.searchCondition = (this.searchCondition as ICloneable).Clone() as SearchCondition;

                base.CopyTo(predicateGroupClone);

                return predicateGroupClone;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\SqlHelper.cs ===
//-----------------------------------------------------------------------
// <copyright file="SqlHelper.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   load sql files
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.IO;
    using System.Reflection;
    using System.Text;

    /// <summary>
    /// Helper class to manage sql resources
    /// </summary>
    internal static class SqlHelper
    {
        /// <summary>
        /// assembly is the current assembly from which to load the manifest resources
        /// </summary>
        private static Assembly assembly = Assembly.GetExecutingAssembly();

        /// <summary>
        /// Loads the sql script
        /// </summary>
        /// <param name="name">The sql script name</param>
        /// <returns>The sql script as a string</returns>
        public static string LoadScript(string name)
        {
            // load the manifest resource
            using (Stream stream = assembly.GetManifestResourceStream("DBSchema.Resources." + name))
            {
                using (StreamReader streamReader = new StreamReader(stream, Encoding.UTF8, true))
                {
                    return streamReader.ReadToEnd();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\TransactionResult.cs ===
//-----------------------------------------------------------------------
// <copyright file="TransactionResult.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   represent the result of a sql transaction
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Data;
    using System.Data.SqlClient;

    /// <summary>
    /// Defines the callback method that will handle transaction events and the TransactionResult
    /// </summary>
    /// <param name="transactionResult">The current transaction result</param>
    /// <param name="context">An object that contains data to be used by the callback method</param>
    public delegate void TransactionEventHandler(TransactionResult transactionResult, object context);

    /// <summary>
    /// Class to represent the result of a sql transaction
    /// </summary>
    public class TransactionResult
    {
        /// <summary>
        /// collectionResults is the read only collection of results
        /// </summary>
        private ReadOnlyCollection<TransactionResult> collectionResults;

        /// <summary>
        /// dataSet is the data set returned from the stored procedure
        /// </summary>
        private DataSet dataSet;

        /// <summary>
        /// dbSchemaType represents the db schema type of the schema object
        /// </summary>
        private DBSchemaType dbSchemaType;

        /// <summary>
        /// listTransactionResults is the collection of transaction results generated by this logical object
        /// </summary>
        private List<TransactionResult> listTransactionResults = new List<TransactionResult>();

        /// <summary>
        /// name is the name of the schema object
        /// </summary>
        private string name;

        /// <summary>
        /// result is the row count for insert, update or delete or the return value from the stored procedure
        /// </summary>
        private int result;

        /// <summary>
        /// sqlAction is the sql action (insert, update, delete, or execute)
        /// </summary>
        private SqlAction sqlAction;

        /// <summary>
        /// sqlException is the sql exception that occurred during the transaction, if any
        /// </summary>
        private SqlException sqlException;

        /// <summary>
        /// Initializes a new instance of the TransactionResult class
        /// </summary>
        /// <param name="name">The name of the schema object responsible for this transaction result</param>
        internal TransactionResult(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Initializes a new instance of the TransactionResult class
        /// </summary>
        /// <param name="name">The name of the schema object responsible for this transaction result</param>
        /// <param name="dbSchemaType">The type of the schema object responsible for this transaction result</param>
        internal TransactionResult(string name, DBSchemaType dbSchemaType)
            : this(name)
        {
            this.dbSchemaType = dbSchemaType;
        }

        /// <summary>
        /// Gets the sql action of the transaction
        /// </summary>
        public SqlAction Action
        {
            get { return this.sqlAction; }
            internal set { this.sqlAction = value; }
        }

        /// <summary>
        /// Gets the data set returned from the stored procedure
        /// </summary>
        public DataSet DataSet
        {
            get { return this.dataSet; }
            internal set { this.dataSet = value; }
        }

        /// <summary>
        /// Gets the sql exception that occurred during the transaction, if any
        /// </summary>
        public SqlException Exception
        {
            get { return this.sqlException; }
            internal set { this.sqlException = value; }
        }

        /// <summary>
        /// Gets the name of the database table or stored procedure or logical object responsible for this transaction result
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the row count for insert, update, or delete or the return value from the stored procedure
        /// </summary>
        public int Result
        {
            get { return this.result; }
            internal set { this.result = value; }
        }

        /// <summary>
        /// Gets the collection of transaction results generated by this logical object
        /// </summary>
        public ReadOnlyCollection<TransactionResult> Results
        {
            get
            {
                if (null == this.collectionResults)
                {
                    this.collectionResults = new ReadOnlyCollection<TransactionResult>(this.listTransactionResults);
                }

                return this.collectionResults;
            }
        }

        /// <summary>
        /// Gets the type responsible for this transaction result
        /// </summary>
        public DBSchemaType SchemaType
        {
            get { return this.dbSchemaType; }
            internal set { this.dbSchemaType = value; }
        }

        /// <summary>
        /// Adds a new transaction result to the collection of transaction results
        /// </summary>
        /// <param name="name">The name of the database table or stored procedure or logical object responsible for the new transaction result</param>
        /// <returns>A new TransactionResult object</returns>
        internal TransactionResult AddResult(string name)
        {
            TransactionResult transactionResult = new TransactionResult(name);

            this.listTransactionResults.Add(transactionResult);

            return transactionResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\activecf.h ===
//------------------------------------------------------------------------------
// File: ActiveCf.h
//
// Desc: Contains the data formats for the transfer of VfW4 filters via the
//       clipboard.
//
// Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#define CFSTR_VFW_FILTERLIST "Video for Windows 4 Filters"

typedef struct tagVFW_FILTERLIST{
    UINT  cFilters;                     // number of CLSIDs in aClsId
    CLSID aClsId[1];                    // ClsId of each filter
    
} VFW_FILTERLIST;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\XmlTextWriterNoNamespace.cs ===
//-----------------------------------------------------------------------
// <copyright file="XmlTextWriterNoNamespace.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   writes an xml element or attribute without the namespace
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System.IO;
    using System.Xml;

    /// <summary>
    /// Class to write an xml element or attribute without the namespace
    /// </summary>
    internal sealed class XmlTextWriterNoNamespace : XmlTextWriter
    {
        /// <summary>
        /// ignoreAttribute specifies to ignore the current attribute
        /// </summary>
        private bool ignoreAttribute;

        /// <summary>
        /// ignoreNamespace specifies to ignore namespaces
        /// </summary>
        private bool ignoreNamespace;

        /// <summary>
        /// Initializes a new instance of the XmlTextWriterNoNamespace class
        /// </summary>
        /// <param name="textWriter">The TextWriter to write to</param>
        public XmlTextWriterNoNamespace(TextWriter textWriter)
            : base(textWriter)
        {
        }

        /// <summary>
        /// Sets a value indicating whether to ignore namespaces
        /// </summary>
        public bool IgnoreNamespace
        {
            set { this.ignoreNamespace = value; }
        }

        /// <summary>
        /// Writes the specified end tag without a namespace
        /// </summary>
        public override void WriteEndAttribute()
        {
            if (false == this.ignoreAttribute)
            {
                base.WriteEndAttribute();
            }

            this.ignoreAttribute = false;
        }

        /// <summary>
        /// Writes the specified start tag without a namespace
        /// </summary>
        /// <param name="prefix">The namespace prefix of the element; ignored</param>
        /// <param name="localName">The local name of the element</param>
        /// <param name="ns">The namespace URI to associate with the element; ignored</param>
        public override void WriteStartAttribute(string prefix, string localName, string ns)
        {
            if (("xmlns" == localName) && (true == this.ignoreNamespace))
            {
                this.ignoreAttribute = true;
            }
            else
            {
                base.WriteStartAttribute(prefix, localName, ns);
            }
        }

        /// <summary>
        /// Writes the specified start tag without a namespace
        /// </summary>
        /// <param name="prefix">The namespace prefix of the element; ignored</param>
        /// <param name="localName">The local name of the element</param>
        /// <param name="ns">The namespace URI to associate with the element; ignored</param>
        public override void WriteStartElement(string prefix, string localName, string ns)
        {
            // check if this is a preserved namespace
            if (("xs" == prefix) || (DBSchemaConstants.NamespaceSchema == ns))
            {
                base.WriteStartElement(prefix, localName, ns);
            }
            else
            {
                base.WriteStartElement(null, localName, null);
            }
        }

        /// <summary>
        /// Writes the specified start tag with the namespace
        /// </summary>
        /// <param name="prefix">The namespace prefix of the element</param>
        /// <param name="localName">The local name of the element</param>
        /// <param name="ns">The namespace URI to associate with the element</param>
        public void WriteStartElementWithNamespace(string prefix, string localName, string ns)
        {
            base.WriteStartElement(prefix, localName, ns);
        }

        /// <summary>
        /// Writes the given text context
        /// </summary>
        /// <param name="text">Text to write</param>
        public override void WriteString(string text)
        {
            // check if this is an attribute value and should be ignored
            if (false == this.ignoreAttribute)
            {
                base.WriteString(text);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchemaTool\Properties\AssemblyInfo.cs ===
//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DBSchemaTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DBSchemaTool")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("96de8899-4a2c-4e0e-9c88-d9b857f4b635")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\Properties\AssemblyInfo.cs ===
//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DBSchema")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DBSchema")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f66d5e8f-bd9d-4201-ab7b-81a9e0d2dd56")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\XmlValidationEventHandler.cs ===
//-----------------------------------------------------------------------
// <copyright file="XmlValidationEventHandler.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to handle XML schema validation
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Runtime.Serialization;
    using System.Xml.Schema;

    /// <summary>
    /// Class to handle XML schema validation
    /// </summary>
    internal sealed class XmlValidationEventHandler
    {
        /// <summary>
        /// childVeh is the external validation event handler (supplied by the caller)
        /// </summary>
        private ValidationEventHandler childVeh;

        /// <summary>
        /// error indicates if an error occurred during the validation
        /// </summary>
        private bool error;

        /// <summary>
        /// ignoreRestrictions specifies if schema restrictions (generally length or pattern restrictions) should be ignored
        /// </summary>
        private bool ignoreRestrictions;

        /// <summary>
        /// parentVeh is the internal validation event handler
        /// </summary>
        private ValidationEventHandler parentVeh;

        /// <summary>
        /// Initializes a new instance of the XmlValidationEventHandler class
        /// </summary>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions should be ignored</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        public XmlValidationEventHandler(bool ignoreRestrictions, ValidationEventHandler veh)
        {
            this.ignoreRestrictions = ignoreRestrictions;
            this.parentVeh = new ValidationEventHandler(this.ValidationEventHandler);
            this.childVeh = veh;
        }

        /// <summary>
        /// Gets a value indicating whether an error occurred during validation
        /// </summary>
        public bool Error
        {
            get { return this.error; }
        }

        /// <summary>
        /// Gets the callback method that will handle XML schema validation events and the ValidationEventArgs
        /// </summary>
        public ValidationEventHandler VEH
        {
            get { return this.parentVeh; }
        }

        /// <summary>
        /// Represents the callback method that will handle XML schema validation events and the ValidationEventArgs
        /// </summary>
        /// <param name="sender">The source of the event</param>
        /// <param name="e">An ValidationEventArgs containing the event data</param>
        private void ValidationEventHandler(object sender, ValidationEventArgs e)
        {
            bool ignore = false;

            if (true == this.ignoreRestrictions)
            {
                // restrictions can be ignored, so check if this is a restriction error
                // this info is burried in the "res" protected property
                // serialize the exception to get "res"
                // if "res" is "Sch_ElementValueDataTypeDetailed" it is a restriction error
                SerializationInfo serializationInfo = new SerializationInfo(e.Exception.GetType(), new FormatterConverter());
                e.Exception.GetObjectData(serializationInfo, new StreamingContext(StreamingContextStates.All));

                try
                {
                    string res = (string)serializationInfo.GetValue("res", typeof(string));

                    if ("Sch_ElementValueDataTypeDetailed" == res)
                    {
                        ignore = true;
                    }
                }
                catch (SerializationException)
                {
                }
                catch (InvalidCastException)
                {
                }
            }

            if (false == ignore)
            {
                this.error = true;

                if (null != this.childVeh)
                {
                    this.childVeh(sender, e);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchemaTool\DBSchemaTool.cs ===
//-----------------------------------------------------------------------
// <copyright file="DBSchemaTool.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for working with the database schema
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace DBSchemaTool
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml.Schema;
    using System.Xml;
    using System.Xml.XPath;

    using ConsoleFileLog;
    using DBSchema;
    using NamedArgParser;

    internal class DBSchemaTool
    {
        /// <summary>
        /// args are the command line arguments
        /// </summary>
        private string[] args;

        /// <summary>
        /// dbSchemaConfig is the config for the database schema
        /// </summary>
        private DBSchemaConfig dbSchemaConfig = null;

        /// <summary>
        /// dbSchemaSet is the schema set for the database schema
        /// </summary>
        private DBSchemaSet dbSchemaSet = null;

        /// <summary>
        /// logWriter is the object to write to the console and log file
        /// </summary>
        private LogWriter logWriter = new LogWriter();

        /// <summary>
        /// namedArgsCollection is the collection of named arguments
        /// </summary>
        private NamedArgsCollection namedArgsCollection = new NamedArgsCollection();

        /// <summary>
        /// timeout is the timeout value for the transaction
        /// </summary>
        private int timeout = 30;

        /// <summary>
        /// Initializes a new instance of the DBSchemaTool class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal DBSchemaTool(string[] args)
        {
            this.args = args;
        }

        /// <summary>
        /// Begins running the db schema tool
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        public int Run()
        {
            int returnValue = 0;

            // attach the console and log file
            returnValue = this.LogWriterAttach();
            if (0 != returnValue)
            {
                return returnValue;
            }

            // log the command line
            this.logWriter.WriteLine(Environment.CommandLine);
            this.logWriter.WriteLine();

            // parse the command line arguments
            string namedArgGroup;
            using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("DBSchemaTool.Resources.Usage.xml"))
            {
                namedArgGroup = this.namedArgsCollection.Parse(stream, this.args, new DisplayUsageCallback(DisplayUsage));
            }

            // run
            if (true == String.IsNullOrEmpty(namedArgGroup))
            {
                returnValue = Marshal.GetHRForException(new ArgumentException("The command line arguments are invalid", "args"));
            }
            else
            {
                returnValue = this.Run(namedArgGroup);
            }

            this.logWriter.WriteLine("Done");
            this.logWriter.WriteLine();

            // detach the console and log file
            this.LogWriterDetach();

            return returnValue;
        }

        /// <summary>
        /// Build the list of named results from the specified list
        /// </summary>
        /// <param name="arg">The argument specifying the list</param>
        /// <returns>A list of named results</returns>
        private static List<NamedResult> BuildListNamedResults(string arg, bool fullPath)
        {
            // listNamedResults is the list of parsed named result objects
            List<NamedResult> listNamedResults = new List<NamedResult>();

            if ('@' == arg[0])
            {
                string fileName = arg.Substring(1);

                DBSchemaTool.BuildListNamedResults(fileName, fullPath, listNamedResults);
            }
            else
            {
                string[] names = arg.Split(';');
                foreach (string name in names)
                {
                    listNamedResults.Add(new NamedResult(name, String.Empty));
                }
            }

            return listNamedResults;
        }

        /// <summary>
        /// Build the list of named results from the specified file
        /// </summary>
        /// <param name="fileName">The specified file name</param>
        /// <param name="fullPath">Specifies if the name should be resolved to a full path</param>
        /// <param name="listNamedResults">The list of named results parsed from the specified file</param>
        private static void BuildListNamedResults(string fileName, bool fullPath, List<NamedResult> listNamedResults)
        {
            // load the specified file
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                using (StreamReader streamReader = new StreamReader(fileStream))
                {
                    // line is the line of text read from the stream
                    string line;
                    while (null != (line = streamReader.ReadLine()))
                    {
                        // build the named result
                        NamedResult namedResult = DBSchemaTool.BuildNamedResult(line, Path.GetDirectoryName(fileName), fullPath);

                        if (null != namedResult)
                        {
                            listNamedResults.Add(namedResult);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Build the named result argument by parsing the specified line and resolving to a full path, if specified
        /// </summary>
        /// <param name="line">The line to parse for the name and contact</param>
        /// <param name="path">The directory to prepend to the name to resolve the full path</param>
        /// <param name="fullPath">Specifies if the name should be resolved to a full path</param>
        /// <returns>The new named result object with the name and contact parsed from the specified line</returns>
        private static NamedResult BuildNamedResult(string line, string directory, bool fullPath)
        {
            // match and split the string
            MatchCollection matchCollection = Regex.Matches(line, @"^([^\s]+?)(?:\s+?(\w+?))?\s*?$");
            if (1 != matchCollection.Count)
            {
                return null;
            }

            // get the name and contact
            string name = matchCollection[0].Groups[1].Value;
            string contact = matchCollection[0].Groups[2].Value;

            // resolve the full path, if necessary
            string[] names = name.Split('\\');
            if ((true == fullPath) && (1 == names.Length) && (false == String.IsNullOrEmpty(directory)))
            {
                name = directory + "\\" + name;
            }

            return new NamedResult(name, contact);
        }

        /// <summary>
        /// The callback method that will handle transaction events and the TransactionResult
        /// </summary>
        /// <param name="transactionResult">The current transaction result</param>
        /// <param name="context">An object that contains data to be used by the callback method</param>
        private void DBSchemaToolTransactionEventHandler(TransactionResult transactionResult, object context)
        {
            TransactionContext transactionContext = context as TransactionContext;

            if (DBSchemaType.LogicalObject == transactionResult.SchemaType)
            {
                if (transactionResult.Action == SqlAction.Begin)
                {
                    string padding = new string(' ', transactionContext.Series * 2);
                    this.logWriter.WriteLine("{0}Element {1} : {2} [{3}]", padding, ++transactionContext.Count, transactionResult.Name, transactionResult.SchemaType);
                    transactionContext.Begin();
                }
                else
                {
                    transactionContext.End();
                    string padding = new string(' ', transactionContext.Series * 2);
                    this.logWriter.WriteLine("{0}Done", padding);
                }
            }
            else
            {
                if (transactionResult.Action == SqlAction.Begin)
                {
                    string padding = new string(' ', transactionContext.Series * 2);
                    this.logWriter.Write("{0}Element {1} : {2} ", padding, ++transactionContext.Count, transactionResult.Name);
                }
                else
                {
                    this.logWriter.WriteLine("[{0}]", transactionResult.Action);
                    if (null != transactionResult.Exception)
                    {
                        transactionContext.Result = Marshal.GetHRForException(transactionResult.Exception);
                        this.logWriter.WriteLine("Exception: {0}", transactionResult.Exception.Message);
                    }
                }
            }
        }

        /// <summary>
        /// The callback method that will handle XML schema validation events and the ValidationEventArgs
        /// </summary>
        /// <param name="sender">The source of the event</param>
        /// <param name="e">An ValidationEventArgs containing the event data</param>
        private void DBSchemaToolValidationEventHandler(object sender, ValidationEventArgs e)
        {
            if ((0 == e.Exception.LineNumber) || (0 == e.Exception.LinePosition))
            {
                this.logWriter.WriteLine("Validation error:");
            }
            else
            {
                this.logWriter.WriteLine("Validation error at line {0}, position {1}:", e.Exception.LineNumber, e.Exception.LinePosition);
            }

            this.logWriter.WriteLine();
            this.logWriter.WriteLine(e.Message);
            this.logWriter.WriteLine();
        }

        /// <summary>
        /// Delete all the data
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int DeleteDataAll()
        {
            this.logWriter.WriteLine("Deleting data ...");
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // delete the data
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction();
                dbSchemaTransaction.Timeout = this.timeout;
                dbSchemaTransaction.Delete(new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            return result;
        }

        /// <summary>
        /// Delete the data specified by the file
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int DeleteDataFile()
        {
            this.logWriter.WriteLine("Deleting data [delete = {0}] ...", this.namedArgsCollection["delete"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // parse the list of files
                List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["delete"], true);

                // iterate the list of files
                foreach (NamedResult namedResult in listNamedResults)
                {
                    // build the transaction context
                    TransactionContext transactionContext = new TransactionContext();

                    // delete the data
                    DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction(namedResult.Name, false, new ValidationEventHandler(this.DBSchemaToolValidationEventHandler));
                    dbSchemaTransaction.Timeout = this.timeout;
                    dbSchemaTransaction.Delete(new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                    if (0 != transactionContext.Result)
                    {
                        result = transactionContext.Result;
                    }
                }
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            return result;
        }

        /// <summary>
        /// Delete the data specified by the search conditions
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int DeleteDataSearch()
        {
            this.logWriter.WriteLine("Deleting data [search = {0}] ...", this.namedArgsCollection["search"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // parse the list of files
                List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["search"], false);

                // iterate the list of files
                SearchConditionCollection searchConditionCollection = new SearchConditionCollection();
                foreach (NamedResult namedResult in listNamedResults)
                {
                    // load the search conditions
                    SearchConditionCollection searchConditionCollectionFile = SearchCondition.LoadSearchConditions(namedResult.Name, new ValidationEventHandler(this.DBSchemaToolValidationEventHandler));

                    foreach (SearchCondition searchCondition in searchConditionCollectionFile)
                    {
                        searchConditionCollection.Add(searchCondition);
                    }
                }

                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // delete the data
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction(searchConditionCollection);
                dbSchemaTransaction.Timeout = this.timeout;
                dbSchemaTransaction.Delete(new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlException ex)
            {
                this.logWriter.WriteLine("XmlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlSchemaException ex)
            {
                this.logWriter.WriteLine("XmlSchemaException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            return result;
        }

        /// <summary>
        /// Delete the data specified by the types
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int DeleteDataType()
        {
            this.logWriter.WriteLine("Deleting data [type = {0}] ...", this.namedArgsCollection["type"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // parse the list of files
                List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["type"], false);

                // iterate the list of files
                SearchConditionCollection searchConditionCollection = new SearchConditionCollection();
                foreach (NamedResult namedResult in listNamedResults)
                {
                    // create the search condition
                    searchConditionCollection.Add(new SearchCondition(namedResult.Name));
                }

                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // delete the data
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction(searchConditionCollection);
                dbSchemaTransaction.Timeout = this.timeout;
                dbSchemaTransaction.Delete(new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            return result;
        }

        /// <summary>
        /// Displays the program usage
        /// </summary>
        /// <param name="usage">The usage string to display</param>
        private void DisplayUsage(string usage)
        {
            this.logWriter.WriteLine(usage);
        }

        /// <summary>
        /// Executes the data
        /// </summary>
        /// <param name="fileName">The data file name</param>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int ExecuteData(string fileName)
        {
            this.logWriter.WriteLine("Executing data [execute = {0}] ...", fileName);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // execute the transaction
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction(fileName, false, new ValidationEventHandler(DBSchemaToolValidationEventHandler));
                dbSchemaTransaction.Timeout = this.timeout;
                dbSchemaTransaction.Execute(new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlException ex)
            {
                this.logWriter.WriteLine("XmlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlSchemaException ex)
            {
                this.logWriter.WriteLine("XmlSchemaException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            this.logWriter.WriteLine();

            return result;
        }

        /// <summary>
        /// Executes the data
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int ExecuteData()
        {
            int returnValue = 0;

            // parse the list of files
            List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["execute"], true);

            // iterate the list of files
            foreach (NamedResult namedResult in listNamedResults)
            {
                // execute the data
                namedResult.Result = this.ExecuteData(namedResult.Name);
                if (0 != namedResult.Result)
                {
                    returnValue = namedResult.Result;
                }
            }

            // check for failures
            if (0 != returnValue)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("Failures:");

                // iterate the list of files
                foreach (NamedResult namedResult in listNamedResults)
                {
                    if (0 == namedResult.Result)
                    {
                        continue;
                    }

                    this.logWriter.WriteLine(String.Format("  File: {0}", namedResult.Name));
                    this.logWriter.WriteLine(String.Format("  Error Code: {0}", namedResult.Result));
                    this.logWriter.WriteLine(String.Format("  Contact: {0}", namedResult.Contact));
                    this.logWriter.WriteLine();
                }
            }

            return returnValue;
        }

        /// <summary>
        /// Load the config
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int LoadConfig()
        {
            if (null == this.namedArgsCollection["config"])
            {
                return 0;
            }

            this.logWriter.WriteLine("Loading config [config = {0}] ...", this.namedArgsCollection["config"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                this.dbSchemaConfig = new DBSchemaConfig();
                this.dbSchemaConfig.LoadConfig(this.namedArgsCollection["config"], new ValidationEventHandler(this.DBSchemaToolValidationEventHandler));
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlException ex)
            {
                this.logWriter.WriteLine("XmlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlSchemaException ex)
            {
                this.logWriter.WriteLine("XmlSchemaException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            if (0 < this.dbSchemaConfig.Warnings.Count)
            {
                this.logWriter.WriteLine("Config Warnings:");

                foreach (string configWarning in this.dbSchemaConfig.Warnings)
                {
                    this.logWriter.WriteLine("  " + configWarning);
                }

                this.logWriter.WriteLine();
            }

            return result;
        }

        /// <summary>
        /// Load the schema
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int LoadSchema()
        {
            this.logWriter.WriteLine("Loading schema [server = {0}, database = {1}, uid = {2}, pwd = {3}] ...", this.namedArgsCollection["server"], this.namedArgsCollection["database"], this.namedArgsCollection["uid"], this.namedArgsCollection["pwd"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                this.dbSchemaSet = new DBSchemaSet();
                this.dbSchemaSet.Timeout = this.timeout;
                this.dbSchemaSet.LoadSchema(this.dbSchemaConfig, this.namedArgsCollection["server"], this.namedArgsCollection["database"], this.namedArgsCollection["uid"], this.namedArgsCollection["pwd"]);
            }
            catch (InvalidOperationException ex)
            {
                this.logWriter.WriteLine("InvalidOperationException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                this.logWriter.WriteLine();
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                this.logWriter.WriteLine();
                result = Marshal.GetHRForException(ex);
            }

            if (0 < this.dbSchemaSet.Warnings.Count)
            {
                this.logWriter.WriteLine("Schema Warnings:");

                foreach (string schemaWarning in this.dbSchemaSet.Warnings)
                {
                    this.logWriter.WriteLine("  " + schemaWarning);
                }

                this.logWriter.WriteLine();
            }

            return result;
        }

        /// <summary>
        /// Attaches the log writer to the console and file name
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int LogWriterAttach()
        {
            // get the name of the currently executing assembly
            string assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetCallingAssembly().ManifestModule.Name);

            // attach the log object
            logWriter.AttachConsole();
            try
            {
                logWriter.AttachFile(assemblyName + ".log");
            }
            catch (IOException ex)
            {
                logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                logWriter.WriteLine("UnauthorizedAccessException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            return 0;
        }

        /// <summary>
        /// Detaches the log writer from the console and file name
        /// </summary>
        private void LogWriterDetach()
        {
            logWriter.DetachFile();
            logWriter.DetachConsole();
        }

        /// <summary>
        /// Begins running the db schema tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int Run(string namedArgGroup)
        {
            int returnValue = 0;

            // parse the timeout
            if (null != this.namedArgsCollection["timeout"])
            {
                this.timeout = Convert.ToInt32(this.namedArgsCollection["timeout"]);
            }

            if ("ValidateDataAgainstXsd" == namedArgGroup)
            {
                return this.ValidateData();
            }

            // load the config
            returnValue = this.LoadConfig();
            if (0 != returnValue)
            {
                return returnValue;
            }

            // load the schema
            returnValue = this.LoadSchema();
            if (0 != returnValue)
            {
                return returnValue;
            }

            // save the schema
            returnValue = this.SaveSchema();
            if (0 != returnValue)
            {
                return returnValue;
            }

            if ("ValidateDataAgainstSchema" == namedArgGroup)
            {
                return this.ValidateData();
            }
            else if ("ExecuteData" == namedArgGroup)
            {
                return this.ExecuteData();
            }
            else if ("SelectDataAll" == namedArgGroup)
            {
                return this.SelectDataAll();
            }
            else if ("SelectDataSearch" == namedArgGroup)
            {
                return this.SelectDataSearch();
            }
            else if ("SelectDataType" == namedArgGroup)
            {
                return this.SelectDataType();
            }
            else if ("DeleteDataFile" == namedArgGroup)
            {
                if (true == String.IsNullOrEmpty(this.namedArgsCollection["delete"]))
                {
                    return this.DeleteDataAll();
                }
                else
                {
                    return this.DeleteDataFile();
                }
            }
            else if ("DeleteDataSearch" == namedArgGroup)
            {
                return this.DeleteDataSearch();
            }
            else if ("DeleteDataType" == namedArgGroup)
            {
                return this.DeleteDataType();
            }

            return 0;
        }

        /// <summary>
        /// Save the schema
        /// </summary>
        /// <param name="schema"></param>
        /// <param name="name"></param>
        private void SaveSchema(string prefix, string name, string schema)
        {
            // Create the file name
            StringBuilder stringBuilder = new StringBuilder();

            // append the prefix
            stringBuilder.Append(prefix);

            // append the name
            if (false == String.IsNullOrEmpty(name))
            {
                stringBuilder.Append("." + name);
            }

            // append the extension
            stringBuilder.Append(".xsd");

            string fileName = stringBuilder.ToString();
            this.logWriter.WriteLine("Saving schema [{0}] ...", fileName);

            using (StreamWriter streamWriter = new StreamWriter(fileName, false, System.Text.Encoding.UTF8))
            {
                streamWriter.Write(schema);
            }
        }

        /// <summary>
        /// Save the schema
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int SaveSchema()
        {
            if (null == this.namedArgsCollection["saveschema"])
            {
                return 0;
            }

            int result = 0;

            try
            {
                if (null == this.namedArgsCollection["debug"])
                {
                    this.SaveSchema(this.namedArgsCollection["saveschema"], String.Empty, this.dbSchemaSet.Schema);
                }
                else
                {
                    this.SaveSchema(this.namedArgsCollection["saveschema"], String.Empty, this.dbSchemaSet.SchemaOrdered);
                }

                foreach (PublishSchema publishSchema in this.dbSchemaSet.PublishSchemas)
                {
                    this.SaveSchema(this.namedArgsCollection["saveschema"], publishSchema.Name, publishSchema.Schema);
                }
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            this.logWriter.WriteLine();

            return result;
        }

        /// <summary>
        /// Select all the data
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int SelectDataAll()
        {
            this.logWriter.WriteLine("Selecting data [select = {0}] ...", this.namedArgsCollection["select"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // select the data
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction();

                dbSchemaTransaction.Timeout = this.timeout;

                if (null != this.namedArgsCollection["includeNullElements"])
                {
                    dbSchemaTransaction.IncludeNullElements = true;
                }

                dbSchemaTransaction.Select(this.namedArgsCollection["select"], new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            this.logWriter.WriteLine();

            return result;
        }

        /// <summary>
        /// Select the data specified by the search conditions
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int SelectDataSearch()
        {
            this.logWriter.WriteLine("Selecting data [select = {0}, search = {1}] ...", this.namedArgsCollection["select"], this.namedArgsCollection["search"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // parse the list of files
                List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["search"], false);

                // iterate the list of files
                SearchConditionCollection searchConditionCollection = new SearchConditionCollection();
                foreach (NamedResult namedResult in listNamedResults)
                {
                    // load the search conditions
                    SearchConditionCollection searchConditionCollectionFile = SearchCondition.LoadSearchConditions(namedResult.Name, new ValidationEventHandler(this.DBSchemaToolValidationEventHandler));

                    foreach (SearchCondition searchCondition in searchConditionCollectionFile)
                    {
                        searchConditionCollection.Add(searchCondition);
                    }
                }

                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // select the data
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction(searchConditionCollection);

                dbSchemaTransaction.Timeout = this.timeout;

                if (null != this.namedArgsCollection["includeNullElements"])
                {
                    dbSchemaTransaction.IncludeNullElements = true;
                }

                dbSchemaTransaction.Select(this.namedArgsCollection["select"], new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("XmlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlSchemaException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("XmlSchemaException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            this.logWriter.WriteLine();

            return result;
        }

        /// <summary>
        /// Select the data specified by the types
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int SelectDataType()
        {
            this.logWriter.WriteLine("Selecting data [select = {0}, type = {1}] ...", this.namedArgsCollection["select"], this.namedArgsCollection["type"]);
            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // parse the list of files
                List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["type"], false);

                // iterate the list of files
                SearchConditionCollection searchConditionCollection = new SearchConditionCollection();
                foreach (NamedResult namedResult in listNamedResults)
                {
                    // create the search condition
                    searchConditionCollection.Add(new SearchCondition(namedResult.Name));
                }

                // build the transaction context
                TransactionContext transactionContext = new TransactionContext();

                // select the data
                DBSchemaTransaction dbSchemaTransaction = this.dbSchemaSet.CreateTransaction(searchConditionCollection);

                dbSchemaTransaction.Timeout = this.timeout;

                if (null != this.namedArgsCollection["includeNullElements"])
                {
                    dbSchemaTransaction.IncludeNullElements = true;
                }

                dbSchemaTransaction.Select(this.namedArgsCollection["select"], new TransactionEventHandler(this.DBSchemaToolTransactionEventHandler), transactionContext);

                result = transactionContext.Result;
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (SqlException ex)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("SqlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            this.logWriter.WriteLine();

            return result;
        }

        /// <summary>
        /// Validate the data against the specified xsd
        /// </summary>
        /// <param name="fileName">The data file name</param>
        /// <param name="xsdFileName">The xsd file name</param>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int ValidateData(string fileName, string xsdFileName)
        {
            if (true == String.IsNullOrEmpty(xsdFileName))
            {
                this.logWriter.WriteLine("Validating data [validate = {0}] ...", fileName);
            }
            else
            {
                this.logWriter.WriteLine("Validating data [xsd = {0}, validate = {1}] ...", xsdFileName, fileName);
            }

            this.logWriter.WriteLine();

            int result = 0;

            try
            {
                // load the document
                XPathNavigator xpathNavigator = null;
                if (true == String.IsNullOrEmpty(xsdFileName))
                {
                    xpathNavigator = DBSchemaDocument.LoadDocument(fileName, this.dbSchemaSet.XmlSchemaSet, false, new ValidationEventHandler(this.DBSchemaToolValidationEventHandler));
                }
                else
                {
                    xpathNavigator = DBSchemaDocument.LoadDocument(fileName, xsdFileName, false, new ValidationEventHandler(this.DBSchemaToolValidationEventHandler));
                }

                // get the number of elements
                XPathNodeIterator xpathNodeIterator = xpathNavigator.SelectSingleNode("*").SelectChildren(XPathNodeType.Element);

                this.logWriter.WriteLine("Validated {0} elements", xpathNodeIterator.Count);
            }
            catch (IOException ex)
            {
                this.logWriter.WriteLine("IOException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlException ex)
            {
                this.logWriter.WriteLine("XmlException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }
            catch (XmlSchemaException ex)
            {
                this.logWriter.WriteLine("XmlSchemaException: " + ex.Message);
                this.logWriter.WriteLine();
                this.logWriter.WriteLine(ex.StackTrace);
                result = Marshal.GetHRForException(ex);
            }

            this.logWriter.WriteLine();

            return result;
        }

        /// <summary>
        /// Validates the data against the specified or loaded schema
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int ValidateData()
        {
            int returnValue = 0;

            // parse the list of files
            List<NamedResult> listNamedResults = DBSchemaTool.BuildListNamedResults(this.namedArgsCollection["validate"], true);

            // get the xsd file name
            string xsdFileName = this.namedArgsCollection["xsd"];

            // iterate the list of files
            foreach (NamedResult namedResult in listNamedResults)
            {
                // validate the data
                namedResult.Result = this.ValidateData(namedResult.Name, xsdFileName);
                if (0 != namedResult.Result)
                {
                    returnValue = namedResult.Result;
                }
            }

            // check for failures
            if (0 != returnValue)
            {
                this.logWriter.WriteLine();
                this.logWriter.WriteLine("Failures:");

                // iterate the list of files
                foreach (NamedResult namedResult in listNamedResults)
                {
                    if (0 == namedResult.Result)
                    {
                        continue;
                    }

                    this.logWriter.WriteLine(String.Format("  File: {0}", namedResult.Name));
                    this.logWriter.WriteLine(String.Format("  Error Code: {0}", namedResult.Result));
                    this.logWriter.WriteLine(String.Format("  Contact: {0}", namedResult.Contact));
                    this.logWriter.WriteLine();
                }
            }

            return returnValue;
        }

        private class NamedResult
        {
            /// <summary>
            /// contact is the appropriate context for this object
            /// </summary>
            private string contact;

            /// <summary>
            /// name is the name of this object
            /// </summary>
            private string name;

            /// <summary>
            /// result is the result of this object
            /// </summary>
            private int result;

            /// <summary>
            /// Initializes a new instance of the NamedResult class
            /// </summary>
            /// <param name="name">The name of the new instance</param>
            /// <param name="contact">The contact for this new instance</param>
            public NamedResult(string name, string contact)
            {
                this.name = name;
                this.contact = contact;
            }

            /// <summary>
            /// Gets the contact for this object
            /// </summary>
            public string Contact
            {
                get { return this.contact; }
            }

            /// <summary>
            /// Gets the name of this object
            /// </summary>
            public string Name
            {
                get { return this.name; }
            }

            /// <summary>
            /// Gets the result of this object
            /// </summary>
            public int Result
            {
                get { return this.result; }
                set { this.result = value; }
            }
        }

        private class TransactionContext
        {
            /// <summary>
            /// count is the number of events within the current begin/end series
            /// </summary>
            private int count;

            /// <summary>
            /// result is the result of this transaction
            /// </summary>
            private int result = 0;

            /// <summary>
            /// stackCount is the stack of counts
            /// </summary>
            private Stack<int> stackCount = new Stack<int>();

            /// <summary>
            /// Initializes a new instance of the TransactionContext class
            /// </summary>
            public TransactionContext()
            {
                this.stackCount.Push(count);
            }

            /// <summary>
            /// Gets or sets the number of events within the current begin/end series
            /// </summary>
            public int Count
            {
                get { return this.count; }
                set { this.count = value; }
            }

            /// <summary>
            /// Gets the result of this object
            /// </summary>
            public int Result
            {
                get { return this.result; }
                set { this.result = value; }
            }

            /// <summary>
            /// Gets the number of series in progress
            /// </summary>
            public int Series
            {
                get { return this.stackCount.Count; }
            }

            /// <summary>
            /// Begins a series
            /// </summary>
            public void Begin()
            {
                this.stackCount.Push(count);
                count = 0;
            }

            /// <summary>
            /// Ends a series
            /// </summary>
            public void End()
            {
                count = this.stackCount.Pop();
            }
        }

        static private int Main(string[] args)
        {
            // create the db schema tool instance
            DBSchemaTool dbSchemaTool = new DBSchemaTool(args);

            // run
            return dbSchemaTool.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DBSchema\code\DBSchema\XmlHelper.cs ===
//-----------------------------------------------------------------------
// <copyright file="XmlHelper.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   load and validate xml files
// </summary>
//-----------------------------------------------------------------------

namespace DBSchema
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;
    using System.Xml.Xsl;

    /// <summary>
    /// Helper class to manage xml resources
    /// </summary>
    internal static class XmlHelper
    {
        /// <summary>
        /// assembly is the current assembly from which to load the manifest resources
        /// </summary>
        private static Assembly assembly = Assembly.GetExecutingAssembly();

        /// <summary>
        /// Change the xml schema namespace to the specified namespace
        /// </summary>
        /// <param name="xpathNavigator">The xml schema document</param>
        /// <param name="ns">The xml schema namespace to use</param>
        /// <returns>The new xml schema</returns>
        public static XmlSchema ChangeSchemaNamespace(XPathNavigator xpathNavigator, string ns)
        {
            // setup the namespace
            XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xpathNavigator.NameTable);
            xmlNamespaceManager.AddNamespace("xs", DBSchemaConstants.NamespaceSchema);

            // validate the root element
            XPathNavigator xpathNavigatorElement = xpathNavigator.SelectSingleNode(".//xs:schema", xmlNamespaceManager);
            if (null == xpathNavigatorElement)
            {
                throw new XmlSchemaException("The XML Schema root element is invalid.");
            }

            // check for unexpected namespaces
            IDictionary<string, string> collectionNamespaces = xpathNavigatorElement.GetNamespacesInScope(XmlNamespaceScope.ExcludeXml);
            foreach (string prefix in collectionNamespaces.Keys)
            {
                if (true == String.IsNullOrEmpty(prefix))
                {
                    continue;
                }

                if (("xs" == prefix) && (DBSchemaConstants.NamespaceSchema == collectionNamespaces[prefix]))
                {
                    continue;
                }

                throw new XmlSchemaException(String.Format("Unexpected Namespace '{0}'.", collectionNamespaces[prefix]));
            }

            // wrap the schema in our namespace
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                using (XmlTextWriterNoNamespace xmlTextWriter = new XmlTextWriterNoNamespace(stringWriterUTF8))
                {
                    // write the start element
                    xmlTextWriter.WriteStartElement("xs", "schema", DBSchemaConstants.NamespaceSchema);

                    // write the attributes
                    xmlTextWriter.WriteAttributeString("xmlns", ns);
                    xmlTextWriter.WriteAttributeString("targetNamespace", ns);
                    xmlTextWriter.WriteAttributeString("elementFormDefault", "qualified");

                    // ignore namespaces in the old xml
                    xmlTextWriter.IgnoreNamespace = true;

                    // write the old xml
                    XPathNodeIterator xpathNodeIterator = xpathNavigatorElement.SelectChildren(XPathNodeType.Element);
                    while (true == xpathNodeIterator.MoveNext())
                    {
                        xmlTextWriter.WriteNode(xpathNodeIterator.Current, false);
                    }

                    // write the end element
                    xmlTextWriter.WriteEndElement();
                }
            }

            // build a new schema that conforms to the dbschema namespace
            using (StringReader stringReader = new StringReader(stringBuilder.ToString()))
            {
                return XmlSchema.Read(stringReader, null);
            }
        }

        /// <summary>
        /// Create an empty xpath navigator with the specified name and namespace
        /// </summary>
        /// <param name="name">The specified name</param>
        /// <param name="ns">The specified namespace</param>
        /// <returns>An empty XPathNavigator object with the specified name and namespace</returns>
        public static XPathNavigator CreateEmptyNavigator(string name, string ns)
        {
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                xmlWriterSettings.Indent = true;

                using (XmlWriter xmlWriter = XmlWriter.Create(stringWriterUTF8))
                {
                    // write the start element
                    xmlWriter.WriteStartElement(name, ns);

                    // write the end element
                    xmlWriter.WriteEndElement();
                }
            }

            return XmlHelper.GetNavigator(stringBuilder.ToString());
        }

        /// <summary>
        /// Create an empty xml schema with the specified namespace
        /// </summary>
        /// <param name="ns">The xml schema namespace</param>
        /// <returns>An XmlSchema object that represents the empty xml schema with the specified namespace</returns>
        public static XmlSchema CreateSchema(string ns)
        {
            XmlSchema xmlSchema = new XmlSchema();

            xmlSchema.Namespaces.Add(String.Empty, ns);
            xmlSchema.Namespaces.Add("xs", "http://www.w3.org/2001/XMLSchema");

            xmlSchema.TargetNamespace = ns;
            xmlSchema.ElementFormDefault = XmlSchemaForm.Qualified;

            return xmlSchema;
        }

        /// <summary>
        /// Create an empty xml schema with the specified namespace and the sql types import
        /// </summary>
        /// <param name="ns">The xml schema namespace</param>
        /// <returns>An XmlSchema object that represents the empty xml schema with the specified namespace</returns>
        public static XmlSchema CreateSchemaWithSqlTypes(string ns)
        {
            XmlSchema xmlSchema = XmlHelper.CreateSchema(ns);

            // Add the sql types namespace
            xmlSchema.Namespaces.Add("sqlTypes", "http://schemas.microsoft.com/sqlserver/2004/sqltypes");

            // Add sql types import
            XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
            xmlSchemaImport.Namespace = "http://schemas.microsoft.com/sqlserver/2004/sqltypes";
            xmlSchemaImport.SchemaLocation = "http://schemas.microsoft.com/sqlserver/2004/sqltypes/sqltypes.xsd";

            xmlSchema.Includes.Add(xmlSchemaImport);

            return xmlSchema;
        }

        /// <summary>
        /// Gets an xpath navigator object to read the xml document
        /// </summary>
        /// <param name="xml">The xml string</param>
        /// <returns>An XPathNavigator object that represents the xml schema definition (xsd)</returns>
        public static XPathNavigator GetNavigator(string xml)
        {
            // load the xml document with the xml string
            using (StringReader stringReader = new StringReader(xml))
            {
                using (XmlTextReader xmlTextReader = new XmlTextReader(stringReader))
                {
                    return new XPathDocument(xmlTextReader).CreateNavigator();
                }
            }
        }

        /// <summary>
        /// Gets an xpath navigator object to read the schema definition
        /// </summary>
        /// <param name="xmlSchema">The xml schema</param>
        /// <returns>An XPathNavigator object that represents the xml schema definition (xsd)</returns>
        public static XPathNavigator GetSchemaNavigator(XmlSchema xmlSchema)
        {
            // write the xml schema to a string
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                xmlSchema.Write(stringWriterUTF8);
            }

            return XmlHelper.GetNavigator(stringBuilder.ToString());
        }

        /// <summary>
        /// Imports the xpath navigator object into a new xpath navigator object with specified name and namespace
        /// </summary>
        /// <param name="xpathNavigator">The xpath navigator object to embed</param>
        /// <param name="name">The specified name</param>
        /// <param name="ns">The specified namespace</param>
        /// <returns>A new xpath navigator object with the specified name and namespace</returns>
        public static XPathNavigator ImportNavigator(XPathNavigator xpathNavigator, string name, string ns)
        {
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                xmlWriterSettings.Indent = true;

                using (XmlWriter xmlWriter = XmlWriter.Create(stringWriterUTF8))
                {
                    // write the start element
                    xmlWriter.WriteStartElement(name, ns);

                    // write the old xml
                    xmlWriter.WriteNode(xpathNavigator, false);

                    // write the end element
                    xmlWriter.WriteEndElement();
                }
            }

            return XmlHelper.GetNavigator(stringBuilder.ToString());
        }

        /// <summary>
        /// Loads the xml file and validates it against the specified schema set
        /// </summary>
        /// <param name="fileName">The xml file name</param>
        /// <param name="xmlSchemaSet">The specified schema set for validation</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">The callback method that will handle XML schema validation events and ValidationEventArgs</param>
        /// <returns>An xpath navigator to read the xml file</returns>
        public static XPathNavigator LoadDocument(string fileName, XmlSchemaSet xmlSchemaSet, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // create the validation event handler
            XmlValidationEventHandler xmlValidationEventHandler = new XmlValidationEventHandler(ignoreRestrictions, veh);

            // set the validation
            XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
            xmlReaderSettings.Schemas.Add(xmlSchemaSet);
            xmlReaderSettings.ValidationEventHandler += xmlValidationEventHandler.VEH;
            xmlReaderSettings.ValidationType = ValidationType.Schema;

            // load the file
            XPathNavigator xpathNavigator = null;
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                using (XmlReader xmlReader = XmlReader.Create(fileStream, xmlReaderSettings))
                {
                    xpathNavigator = new XPathDocument(xmlReader).CreateNavigator();
                }
            }

            // get the document element
            XPathNavigator xpathNavigatorElement = xpathNavigator.SelectSingleNode("*");

            // check if the document element namespace exists in the schema set
            if (0 == xmlSchemaSet.Schemas(xpathNavigatorElement.NamespaceURI).Count)
            {
                throw new XmlSchemaValidationException(String.Format("Namespace '{0}' is not defined for '{1}'.", xpathNavigatorElement.NamespaceURI, fileName));
            }

            // check for errors
            if (true == xmlValidationEventHandler.Error)
            {
                throw new XmlSchemaValidationException(String.Format("XML Schema Validation failed for '{0}'.",  fileName));
            }

            return xpathNavigator;
        }

        /// <summary>
        /// Loads the xml schema definition (xsd) from a manifest resource
        /// </summary>
        /// <param name="name">The resource name to load</param>
        /// <returns>An XmlSchema object of the xml schema</returns>
        public static XmlSchema LoadSchemaFromResource(string name)
        {
            // load the schema
            using (Stream stream = assembly.GetManifestResourceStream("DBSchema.Resources." + name))
            {
                using (StreamReader streamReader = new StreamReader(stream))
                {
                    return XmlSchema.Read(streamReader, null);
                }
            }
        }

        /// <summary>
        /// Loads the xml schema definition (xsd) set from a file
        /// </summary>
        /// <param name="fileName">The file name to load</param>
        /// <param name="veh">Refers to the callback method that will handle XML schema validation events and the ValidationEventArgs</param>
        /// <returns>An XmlSchemaSet object of the xml schema set</returns>
        public static XmlSchemaSet LoadSchemaSet(string fileName, ValidationEventHandler veh)
        {
            // create the validation event handler
            XmlValidationEventHandler xmlValidationEventHandler = new XmlValidationEventHandler(false, veh);

            // set the validation
            XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
            xmlReaderSettings.ValidationEventHandler += xmlValidationEventHandler.VEH;
            xmlReaderSettings.ValidationType = ValidationType.Schema;

            // create the schema set
            XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
            xmlSchemaSet.XmlResolver = new XmlUrlResolver();

            // load the schema
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                using (XmlReader xmlReader = XmlReader.Create(fileStream, xmlReaderSettings))
                {
                    xmlSchemaSet.Add(null, xmlReader);
                }
            }

            // compile the schema
            xmlSchemaSet.Compile();

            // check for errors
            if (true == xmlValidationEventHandler.Error)
            {
                throw new XmlSchemaException(String.Format("XML Schema Validation failed for '{0}'.", fileName));
            }

            return xmlSchemaSet;
        }

        /// <summary>
        /// Loads the xml schema definition (xsd) set from a manifest resource
        /// </summary>
        /// <param name="name">The resource name to load</param>
        /// <param name="ns">The xml schema namespace to use</param>
        /// <returns>An XmlSchemaSet object of the xml schema set</returns>
        public static XmlSchemaSet LoadSchemaSetFromResource(string name, string ns)
        {
            // create the schema set
            XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
            xmlSchemaSet.XmlResolver = new XmlUrlResolver();

            // load the schema and any included schemas into the schema set
            XmlHelper.LoadSchemaFromResource(xmlSchemaSet, name, ns);

            // compile the schema to force validation
            xmlSchemaSet.Compile();

            return xmlSchemaSet;
        }

        /// <summary>
        /// Loads the xml transform (xslt) from a manifest resource
        /// </summary>
        /// <param name="name">The resource name to load</param>
        /// <returns>An XslCompiledTransform object of the xml transform</returns>
        public static XslCompiledTransform LoadTransformFromResource(string name)
        {
            // load the transform
            using (Stream stream = assembly.GetManifestResourceStream("DBSchema.Resources." + name))
            {
                using (XmlTextReader xmlTextReader = new XmlTextReader(stream))
                {
                    XslCompiledTransform xslCompiledTransform = new XslCompiledTransform();
                    xslCompiledTransform.Load(xmlTextReader);

                    return xslCompiledTransform;
                }
            }
        }

        /// <summary>
        ///  Validates an xml document
        /// </summary>
        /// <param name="textReader">The TextReader containing the xml data to load</param>
        /// <param name="xmlSchemaSet">The specified schema set</param>
        /// <param name="ignoreRestrictions">Specifies if schema restrictions (generally length or pattern restrictions) should be ignored</param>
        /// <param name="veh">The callback method that will handle XML schema validation events and ValidationEventArgs</param>
        /// <returns>An xpath navigator to read the xml element</returns>
        public static XPathNavigator Validate(TextReader textReader, XmlSchemaSet xmlSchemaSet, bool ignoreRestrictions, ValidationEventHandler veh)
        {
            // create the validation event handler
            XmlValidationEventHandler xmlValidationEventHandler = new XmlValidationEventHandler(ignoreRestrictions, veh);

            // set the validation
            XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
            xmlReaderSettings.Schemas.Add(xmlSchemaSet);
            xmlReaderSettings.ValidationEventHandler += xmlValidationEventHandler.VEH;
            xmlReaderSettings.ValidationType = ValidationType.Schema;

            // load and validate the xml document
            XPathDocument xpathDocument = null;
            using (XmlReader xmlReader = XmlReader.Create(textReader))
            {
                xpathDocument = new XPathDocument(xmlReader);
            }

            // check for errors
            if (true == xmlValidationEventHandler.Error)
            {
                throw new XmlSchemaException("XML Schema Validation failed.");
            }

            // return the xpath navigator
            return xpathDocument.CreateNavigator();
        }

        /// <summary>
        /// Write the elements iterated by the xpath node iterator to a new xpath navigator document
        /// </summary>
        /// <param name="xpathNodeIterator">The xpath node iterator</param>
        /// <param name="name">The specified name</param>
        /// <param name="ns">The specified namespace</param>
        /// <returns>A new xpath navigator object with the specified name and namespace</returns>
        public static XPathNavigator WriteXPathNodeIterator(XPathNodeIterator xpathNodeIterator, string name, string ns)
        {
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                xmlWriterSettings.Indent = true;

                using (XmlWriter xmlWriter = XmlWriter.Create(stringWriterUTF8))
                {
                    // write the start element
                    xmlWriter.WriteStartElement(name, ns);

                    // write the old xml
                    while (true == xpathNodeIterator.MoveNext())
                    {
                        xmlWriter.WriteNode(xpathNodeIterator.Current, false);
                    }

                    // write the end element
                    xmlWriter.WriteEndElement();
                }
            }

            return XmlHelper.GetNavigator(stringBuilder.ToString());
        }

        /// <summary>
        /// Loads the xml file from a manifest resource
        /// </summary>
        /// <param name="name">The resource name to load</param>
        /// <returns>An xpath navigator to read the xml file</returns>
        private static XPathNavigator LoadDocumentFromResource(string name)
        {
            // load the file
            using (Stream stream = assembly.GetManifestResourceStream("DBSchema.Resources." + name))
            {
                return new XPathDocument(stream).CreateNavigator();
            }
        }

        /// <summary>
        /// Loads the xml schema definition (xsd) from a manifest resource and add it to the schema set
        /// </summary>
        /// <param name="xmlSchemaSet">The XmlSchemaSet object to which to add the specified schema</param>
        /// <param name="name">The resource name to load</param>
        /// <param name="ns">The xml schema namespace to use</param>
        private static void LoadSchemaFromResource(XmlSchemaSet xmlSchemaSet, string name, string ns)
        {
            // load the manifest resource
            XPathNavigator xpathNavigator = XmlHelper.LoadDocumentFromResource(name);

            // change the namespace
            XmlSchema xmlSchema = XmlHelper.ChangeSchemaNamespace(xpathNavigator, ns);

            // load any included schemas
            foreach (XmlSchemaExternal xmlSchemaExternal in xmlSchema.Includes)
            {
                XmlHelper.LoadSchemaFromResource(xmlSchemaSet, xmlSchemaExternal.SchemaLocation, ns);
            }

            // clear the includes so the schemas will not be included again
            xmlSchema.Includes.Clear();

            // add the schema to the schema set
            xmlSchemaSet.Add(xmlSchema);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\amparse.h ===
//------------------------------------------------------------------------------
// File: AMParse.h
//
// Desc: Interface to the parser to get current time.  This is useful for
//       multifile playback.
//
// Copyright (c) 1996-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMPARSE__
#define __AMPARSE__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


DEFINE_GUID(IID_IAMParse,
0xc47a3420, 0x005c, 0x11d2, 0x90, 0x38, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x98);

//
//  Parser interface - supported by MPEG-2 splitter filter
//
DECLARE_INTERFACE_(IAMParse, IUnknown) {
    STDMETHOD(GetParseTime) (THIS_
                             REFERENCE_TIME *prtCurrent
                            ) PURE;
    STDMETHOD(SetParseTime) (THIS_
                             REFERENCE_TIME rtCurrent
                            ) PURE;
    STDMETHOD(Flush) (THIS) PURE;
};

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMPARSE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\amaudio.h ===
//------------------------------------------------------------------------------
// File: AMAudio.h
//
// Desc: Audio related definitions and interfaces for ActiveMovie.
//
// Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMAUDIO__
#define __AMAUDIO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <mmsystem.h>
#include <dsound.h>

// This is the interface the audio renderer supports to give the application
// access to the direct sound object and the buffers it is using, to allow the
// application to use things like the 3D features of Direct Sound for the
// soundtrack of a movie being played with Active Movie.

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IAMDirectSound

DECLARE_INTERFACE_(IAMDirectSound,IUnknown)
{
    /* IUnknown methods */

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /* IAMDirectSound methods */

    STDMETHOD(GetDirectSoundInterface)(THIS_ LPDIRECTSOUND *lplpds) PURE;
    STDMETHOD(GetPrimaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER *lplpdsb) PURE;
    STDMETHOD(GetSecondaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER *lplpdsb) PURE;
    STDMETHOD(ReleaseDirectSoundInterface)(THIS_ LPDIRECTSOUND lpds) PURE;
    STDMETHOD(ReleasePrimaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER lpdsb) PURE;
    STDMETHOD(ReleaseSecondaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER lpdsb) PURE;
    STDMETHOD(SetFocusWindow)(THIS_ HWND, BOOL) PURE ;
    STDMETHOD(GetFocusWindow)(THIS_ HWND *, BOOL*) PURE ;
};


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMAUDIO__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\amva.h ===
//------------------------------------------------------------------------------
// File: AMVA.h
//
// Desc: DirectShowMotionComp include file.
//
// Copyright (c) 1997-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMVA_INCLUDED__
#define __AMVA_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif


#define AMVA_TYPEINDEX_OUTPUTFRAME 0xFFFFFFFF

//  Flags for QueryRenderStatus
#define AMVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0
                                                     // if query for update

typedef struct _tag_AMVAUncompBufferInfo
{
     DWORD                   dwMinNumSurfaces;       // IN   min number of surfaces to be allocated
     DWORD                   dwMaxNumSurfaces;       // IN   max number of surfaces to be allocated
     DDPIXELFORMAT           ddUncompPixelFormat;    // IN   pixel format of surfaces to be allocated
} AMVAUncompBufferInfo, *LPAMVAUncompBufferInfo;

typedef struct _tag_AMVAUncompDataInfo
{
    DWORD                   dwUncompWidth;           // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;          // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;     // [in]     pixel-format of uncompressed data
} AMVAUncompDataInfo, *LPAMVAUncompDataInfo;

typedef struct _tag_AMVAInternalMemInfo
{
    DWORD                   dwScratchMemAlloc;       // [out]    amount of scratch memory will the hal allocate for its private use
} AMVAInternalMemInfo, *LPAMVAInternalMemInfo;


typedef struct _tag_AMVACompBufferInfo
{
    DWORD                   dwNumCompBuffers;        // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;         // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;        // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;       // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;              // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;           // [out]    fourcc to create surfaces to store compressed data
} AMVACompBufferInfo, *LPAMVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_AMVABeginFrameInfo
{
    DWORD                dwDestSurfaceIndex;         // IN  destination buffer in which to decoding this frame
    LPVOID               pInputData;                 // IN  pointer to misc data
    DWORD                dwSizeInputData;            // IN  size of other misc data to begin frame
    LPVOID               pOutputData;                // OUT pointer to data which the VGA is going to fill
    DWORD                dwSizeOutputData;           // IN  size of data which the VGA is going to fill
} AMVABeginFrameInfo, *LPAMVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_AMVAEndFrameInfo
{
    DWORD                   dwSizeMiscData;          // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;               // [in]     pointer to misc data
} AMVAEndFrameInfo, *LPAMVAEndFrameInfo;

typedef struct _tag_AMVABUFFERINFO
{
    DWORD                   dwTypeIndex;             // [in]    Type of buffer
    DWORD                   dwBufferIndex;           // [in]    Buffer index
    DWORD                   dwDataOffset;            // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;              // [in]    size of relevant data
} AMVABUFFERINFO, *LPAMVABUFFERINFO;

#ifdef __cplusplus
};
#endif

#endif // _AMVA_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\amstream.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for amstream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __amstream_h__
#define __amstream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirectShowStream_FWD_DEFINED__
#define __IDirectShowStream_FWD_DEFINED__
typedef interface IDirectShowStream IDirectShowStream;
#endif 	/* __IDirectShowStream_FWD_DEFINED__ */


#ifndef __IAMMultiMediaStream_FWD_DEFINED__
#define __IAMMultiMediaStream_FWD_DEFINED__
typedef interface IAMMultiMediaStream IAMMultiMediaStream;
#endif 	/* __IAMMultiMediaStream_FWD_DEFINED__ */


#ifndef __IAMMediaStream_FWD_DEFINED__
#define __IAMMediaStream_FWD_DEFINED__
typedef interface IAMMediaStream IAMMediaStream;
#endif 	/* __IAMMediaStream_FWD_DEFINED__ */


#ifndef __IMediaStreamFilter_FWD_DEFINED__
#define __IMediaStreamFilter_FWD_DEFINED__
typedef interface IMediaStreamFilter IMediaStreamFilter;
#endif 	/* __IMediaStreamFilter_FWD_DEFINED__ */


#ifndef __IDirectDrawMediaSampleAllocator_FWD_DEFINED__
#define __IDirectDrawMediaSampleAllocator_FWD_DEFINED__
typedef interface IDirectDrawMediaSampleAllocator IDirectDrawMediaSampleAllocator;
#endif 	/* __IDirectDrawMediaSampleAllocator_FWD_DEFINED__ */


#ifndef __IDirectDrawMediaSample_FWD_DEFINED__
#define __IDirectDrawMediaSample_FWD_DEFINED__
typedef interface IDirectDrawMediaSample IDirectDrawMediaSample;
#endif 	/* __IDirectDrawMediaSample_FWD_DEFINED__ */


#ifndef __IAMMediaTypeStream_FWD_DEFINED__
#define __IAMMediaTypeStream_FWD_DEFINED__
typedef interface IAMMediaTypeStream IAMMediaTypeStream;
#endif 	/* __IAMMediaTypeStream_FWD_DEFINED__ */


#ifndef __IAMMediaTypeSample_FWD_DEFINED__
#define __IAMMediaTypeSample_FWD_DEFINED__
typedef interface IAMMediaTypeSample IAMMediaTypeSample;
#endif 	/* __IAMMediaTypeSample_FWD_DEFINED__ */


#ifndef __AMMultiMediaStream_FWD_DEFINED__
#define __AMMultiMediaStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMMultiMediaStream AMMultiMediaStream;
#else
typedef struct AMMultiMediaStream AMMultiMediaStream;
#endif /* __cplusplus */

#endif 	/* __AMMultiMediaStream_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_amstream_0000 */
/* [local] */ 

#include <ddraw.h>
#include <mmsystem.h>
#include <mmstream.h>
#include <ddstream.h>
#include <austream.h>








enum __MIDL___MIDL_itf_amstream_0000_0001
    {	AMMSF_NOGRAPHTHREAD	= 0x1
    } ;

enum __MIDL___MIDL_itf_amstream_0000_0002
    {	AMMSF_ADDDEFAULTRENDERER	= 0x1,
	AMMSF_CREATEPEER	= 0x2,
	AMMSF_STOPIFNOSAMPLES	= 0x4,
	AMMSF_NOSTALL	= 0x8
    } ;

enum __MIDL___MIDL_itf_amstream_0000_0003
    {	AMMSF_RENDERTYPEMASK	= 0x3,
	AMMSF_RENDERTOEXISTING	= 0,
	AMMSF_RENDERALLSTREAMS	= 0x1,
	AMMSF_NORENDER	= 0x2,
	AMMSF_NOCLOCK	= 0x4,
	AMMSF_RUN	= 0x8
    } ;
typedef /* [public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_amstream_0000_0004
    {	Disabled	= 0,
	ReadData	= 1,
	RenderData	= 2
    } 	OUTPUT_STATE;



extern RPC_IF_HANDLE __MIDL_itf_amstream_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_amstream_0000_v0_0_s_ifspec;

#ifndef __IDirectShowStream_INTERFACE_DEFINED__
#define __IDirectShowStream_INTERFACE_DEFINED__

/* interface IDirectShowStream */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDirectShowStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7DB01C96-C0C3-11d0-8FF1-00C04FD9189D")
    IDirectShowStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Video( 
            /* [retval][out] */ OUTPUT_STATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Video( 
            /* [in] */ OUTPUT_STATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Audio( 
            /* [retval][out] */ OUTPUT_STATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Audio( 
            /* [in] */ OUTPUT_STATE newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectShowStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectShowStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectShowStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectShowStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirectShowStream * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirectShowStream * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirectShowStream * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirectShowStream * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IDirectShowStream * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IDirectShowStream * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Video )( 
            IDirectShowStream * This,
            /* [retval][out] */ OUTPUT_STATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Video )( 
            IDirectShowStream * This,
            /* [in] */ OUTPUT_STATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Audio )( 
            IDirectShowStream * This,
            /* [retval][out] */ OUTPUT_STATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Audio )( 
            IDirectShowStream * This,
            /* [in] */ OUTPUT_STATE newVal);
        
        END_INTERFACE
    } IDirectShowStreamVtbl;

    interface IDirectShowStream
    {
        CONST_VTBL struct IDirectShowStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectShowStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectShowStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectShowStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectShowStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDirectShowStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDirectShowStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDirectShowStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDirectShowStream_get_FileName(This,pVal)	\
    (This)->lpVtbl -> get_FileName(This,pVal)

#define IDirectShowStream_put_FileName(This,newVal)	\
    (This)->lpVtbl -> put_FileName(This,newVal)

#define IDirectShowStream_get_Video(This,pVal)	\
    (This)->lpVtbl -> get_Video(This,pVal)

#define IDirectShowStream_put_Video(This,newVal)	\
    (This)->lpVtbl -> put_Video(This,newVal)

#define IDirectShowStream_get_Audio(This,pVal)	\
    (This)->lpVtbl -> get_Audio(This,pVal)

#define IDirectShowStream_put_Audio(This,newVal)	\
    (This)->lpVtbl -> put_Audio(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDirectShowStream_get_FileName_Proxy( 
    IDirectShowStream * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDirectShowStream_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDirectShowStream_put_FileName_Proxy( 
    IDirectShowStream * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDirectShowStream_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDirectShowStream_get_Video_Proxy( 
    IDirectShowStream * This,
    /* [retval][out] */ OUTPUT_STATE *pVal);


void __RPC_STUB IDirectShowStream_get_Video_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDirectShowStream_put_Video_Proxy( 
    IDirectShowStream * This,
    /* [in] */ OUTPUT_STATE newVal);


void __RPC_STUB IDirectShowStream_put_Video_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDirectShowStream_get_Audio_Proxy( 
    IDirectShowStream * This,
    /* [retval][out] */ OUTPUT_STATE *pVal);


void __RPC_STUB IDirectShowStream_get_Audio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDirectShowStream_put_Audio_Proxy( 
    IDirectShowStream * This,
    /* [in] */ OUTPUT_STATE newVal);


void __RPC_STUB IDirectShowStream_put_Audio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectShowStream_INTERFACE_DEFINED__ */


#ifndef __IAMMultiMediaStream_INTERFACE_DEFINED__
#define __IAMMultiMediaStream_INTERFACE_DEFINED__

/* interface IAMMultiMediaStream */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMMultiMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEBE595C-9A6F-11d0-8FDE-00C04FD9189D")
    IAMMultiMediaStream : public IMultiMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ STREAM_TYPE StreamType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IGraphBuilder *pFilterGraph) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterGraph( 
            /* [out] */ IGraphBuilder **ppGraphBuilder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilter( 
            /* [out] */ IMediaStreamFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMediaStream( 
            /* [in] */ IUnknown *pStreamObject,
            /* [in] */ const MSPID *PurposeId,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMediaStream **ppNewStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ LPCWSTR pszFileName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenMoniker( 
            /* [in] */ IBindCtx *pCtx,
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMultiMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMultiMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMultiMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMultiMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAMMultiMediaStream * This,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ STREAM_TYPE *pStreamType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IAMMultiMediaStream * This,
            /* [in] */ REFMSPID idPurpose,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaStreams )( 
            IAMMultiMediaStream * This,
            /* [in] */ long Index,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IAMMultiMediaStream * This,
            /* [out] */ STREAM_STATE *pCurrentState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IAMMultiMediaStream * This,
            /* [in] */ STREAM_STATE NewState);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IAMMultiMediaStream * This,
            /* [out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IAMMultiMediaStream * This,
            /* [out] */ STREAM_TIME *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IAMMultiMediaStream * This,
            /* [in] */ STREAM_TIME SeekTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOfStreamEventHandle )( 
            IAMMultiMediaStream * This,
            /* [out] */ HANDLE *phEOS);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAMMultiMediaStream * This,
            /* [in] */ STREAM_TYPE StreamType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IGraphBuilder *pFilterGraph);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterGraph )( 
            IAMMultiMediaStream * This,
            /* [out] */ IGraphBuilder **ppGraphBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilter )( 
            IAMMultiMediaStream * This,
            /* [out] */ IMediaStreamFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *AddMediaStream )( 
            IAMMultiMediaStream * This,
            /* [in] */ IUnknown *pStreamObject,
            /* [in] */ const MSPID *PurposeId,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMediaStream **ppNewStream);
        
        HRESULT ( STDMETHODCALLTYPE *OpenFile )( 
            IAMMultiMediaStream * This,
            /* [in] */ LPCWSTR pszFileName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMoniker )( 
            IAMMultiMediaStream * This,
            /* [in] */ IBindCtx *pCtx,
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IAMMultiMediaStream * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAMMultiMediaStreamVtbl;

    interface IAMMultiMediaStream
    {
        CONST_VTBL struct IAMMultiMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMultiMediaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMMultiMediaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMMultiMediaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMMultiMediaStream_GetInformation(This,pdwFlags,pStreamType)	\
    (This)->lpVtbl -> GetInformation(This,pdwFlags,pStreamType)

#define IAMMultiMediaStream_GetMediaStream(This,idPurpose,ppMediaStream)	\
    (This)->lpVtbl -> GetMediaStream(This,idPurpose,ppMediaStream)

#define IAMMultiMediaStream_EnumMediaStreams(This,Index,ppMediaStream)	\
    (This)->lpVtbl -> EnumMediaStreams(This,Index,ppMediaStream)

#define IAMMultiMediaStream_GetState(This,pCurrentState)	\
    (This)->lpVtbl -> GetState(This,pCurrentState)

#define IAMMultiMediaStream_SetState(This,NewState)	\
    (This)->lpVtbl -> SetState(This,NewState)

#define IAMMultiMediaStream_GetTime(This,pCurrentTime)	\
    (This)->lpVtbl -> GetTime(This,pCurrentTime)

#define IAMMultiMediaStream_GetDuration(This,pDuration)	\
    (This)->lpVtbl -> GetDuration(This,pDuration)

#define IAMMultiMediaStream_Seek(This,SeekTime)	\
    (This)->lpVtbl -> Seek(This,SeekTime)

#define IAMMultiMediaStream_GetEndOfStreamEventHandle(This,phEOS)	\
    (This)->lpVtbl -> GetEndOfStreamEventHandle(This,phEOS)


#define IAMMultiMediaStream_Initialize(This,StreamType,dwFlags,pFilterGraph)	\
    (This)->lpVtbl -> Initialize(This,StreamType,dwFlags,pFilterGraph)

#define IAMMultiMediaStream_GetFilterGraph(This,ppGraphBuilder)	\
    (This)->lpVtbl -> GetFilterGraph(This,ppGraphBuilder)

#define IAMMultiMediaStream_GetFilter(This,ppFilter)	\
    (This)->lpVtbl -> GetFilter(This,ppFilter)

#define IAMMultiMediaStream_AddMediaStream(This,pStreamObject,PurposeId,dwFlags,ppNewStream)	\
    (This)->lpVtbl -> AddMediaStream(This,pStreamObject,PurposeId,dwFlags,ppNewStream)

#define IAMMultiMediaStream_OpenFile(This,pszFileName,dwFlags)	\
    (This)->lpVtbl -> OpenFile(This,pszFileName,dwFlags)

#define IAMMultiMediaStream_OpenMoniker(This,pCtx,pMoniker,dwFlags)	\
    (This)->lpVtbl -> OpenMoniker(This,pCtx,pMoniker,dwFlags)

#define IAMMultiMediaStream_Render(This,dwFlags)	\
    (This)->lpVtbl -> Render(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_Initialize_Proxy( 
    IAMMultiMediaStream * This,
    /* [in] */ STREAM_TYPE StreamType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IGraphBuilder *pFilterGraph);


void __RPC_STUB IAMMultiMediaStream_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_GetFilterGraph_Proxy( 
    IAMMultiMediaStream * This,
    /* [out] */ IGraphBuilder **ppGraphBuilder);


void __RPC_STUB IAMMultiMediaStream_GetFilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_GetFilter_Proxy( 
    IAMMultiMediaStream * This,
    /* [out] */ IMediaStreamFilter **ppFilter);


void __RPC_STUB IAMMultiMediaStream_GetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_AddMediaStream_Proxy( 
    IAMMultiMediaStream * This,
    /* [in] */ IUnknown *pStreamObject,
    /* [in] */ const MSPID *PurposeId,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMediaStream **ppNewStream);


void __RPC_STUB IAMMultiMediaStream_AddMediaStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_OpenFile_Proxy( 
    IAMMultiMediaStream * This,
    /* [in] */ LPCWSTR pszFileName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMMultiMediaStream_OpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_OpenMoniker_Proxy( 
    IAMMultiMediaStream * This,
    /* [in] */ IBindCtx *pCtx,
    /* [in] */ IMoniker *pMoniker,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMMultiMediaStream_OpenMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMultiMediaStream_Render_Proxy( 
    IAMMultiMediaStream * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMMultiMediaStream_Render_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMMultiMediaStream_INTERFACE_DEFINED__ */


#ifndef __IAMMediaStream_INTERFACE_DEFINED__
#define __IAMMediaStream_INTERFACE_DEFINED__

/* interface IAMMediaStream */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEBE595D-9A6F-11d0-8FDE-00C04FD9189D")
    IAMMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pSourceObject,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFMSPID PurposeId,
            /* [in] */ const STREAM_TYPE StreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ FILTER_STATE State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinAMMultiMediaStream( 
            /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilter( 
            /* [in] */ IMediaStreamFilter *pMediaStreamFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilterGraph( 
            /* [in] */ IFilterGraph *pFilterGraph) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IAMMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAMMediaStream * This,
            /* [out] */ MSPID *pPurposeId,
            /* [out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IAMMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IAMMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IAMMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IAMMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAMMediaStream * This,
            /* [in] */ IUnknown *pSourceObject,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFMSPID PurposeId,
            /* [in] */ const STREAM_TYPE StreamType);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IAMMediaStream * This,
            /* [in] */ FILTER_STATE State);
        
        HRESULT ( STDMETHODCALLTYPE *JoinAMMultiMediaStream )( 
            IAMMediaStream * This,
            /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilter )( 
            IAMMediaStream * This,
            /* [in] */ IMediaStreamFilter *pMediaStreamFilter);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IAMMediaStream * This,
            /* [in] */ IFilterGraph *pFilterGraph);
        
        END_INTERFACE
    } IAMMediaStreamVtbl;

    interface IAMMediaStream
    {
        CONST_VTBL struct IAMMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMMediaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMMediaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream)

#define IAMMediaStream_GetInformation(This,pPurposeId,pType)	\
    (This)->lpVtbl -> GetInformation(This,pPurposeId,pType)

#define IAMMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)

#define IAMMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample)

#define IAMMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)

#define IAMMediaStream_SendEndOfStream(This,dwFlags)	\
    (This)->lpVtbl -> SendEndOfStream(This,dwFlags)


#define IAMMediaStream_Initialize(This,pSourceObject,dwFlags,PurposeId,StreamType)	\
    (This)->lpVtbl -> Initialize(This,pSourceObject,dwFlags,PurposeId,StreamType)

#define IAMMediaStream_SetState(This,State)	\
    (This)->lpVtbl -> SetState(This,State)

#define IAMMediaStream_JoinAMMultiMediaStream(This,pAMMultiMediaStream)	\
    (This)->lpVtbl -> JoinAMMultiMediaStream(This,pAMMultiMediaStream)

#define IAMMediaStream_JoinFilter(This,pMediaStreamFilter)	\
    (This)->lpVtbl -> JoinFilter(This,pMediaStreamFilter)

#define IAMMediaStream_JoinFilterGraph(This,pFilterGraph)	\
    (This)->lpVtbl -> JoinFilterGraph(This,pFilterGraph)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMMediaStream_Initialize_Proxy( 
    IAMMediaStream * This,
    /* [in] */ IUnknown *pSourceObject,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFMSPID PurposeId,
    /* [in] */ const STREAM_TYPE StreamType);


void __RPC_STUB IAMMediaStream_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaStream_SetState_Proxy( 
    IAMMediaStream * This,
    /* [in] */ FILTER_STATE State);


void __RPC_STUB IAMMediaStream_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaStream_JoinAMMultiMediaStream_Proxy( 
    IAMMediaStream * This,
    /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream);


void __RPC_STUB IAMMediaStream_JoinAMMultiMediaStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaStream_JoinFilter_Proxy( 
    IAMMediaStream * This,
    /* [in] */ IMediaStreamFilter *pMediaStreamFilter);


void __RPC_STUB IAMMediaStream_JoinFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaStream_JoinFilterGraph_Proxy( 
    IAMMediaStream * This,
    /* [in] */ IFilterGraph *pFilterGraph);


void __RPC_STUB IAMMediaStream_JoinFilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMMediaStream_INTERFACE_DEFINED__ */


#ifndef __IMediaStreamFilter_INTERFACE_DEFINED__
#define __IMediaStreamFilter_INTERFACE_DEFINED__

/* interface IMediaStreamFilter */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMediaStreamFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEBE595E-9A6F-11d0-8FDE-00C04FD9189D")
    IMediaStreamFilter : public IBaseFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddMediaStream( 
            /* [in] */ IAMMediaStream *pAMMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaStream( 
            /* [in] */ REFMSPID idPurpose,
            /* [out] */ IMediaStream **ppMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMediaStreams( 
            /* [in] */ long Index,
            /* [out] */ IMediaStream **ppMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportSeeking( 
            /* [in] */ BOOL bRenderer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceTimeToStreamTime( 
            /* [out][in] */ REFERENCE_TIME *pTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentStreamTime( 
            /* [out] */ REFERENCE_TIME *pCurrentStreamTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitUntil( 
            /* [in] */ REFERENCE_TIME WaitStreamTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( 
            /* [in] */ BOOL bCancelEOS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOfStream( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaStreamFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaStreamFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaStreamFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaStreamFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMediaStreamFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaStreamFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaStreamFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaStreamFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaStreamFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IMediaStreamFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IMediaStreamFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPins )( 
            IMediaStreamFilter * This,
            /* [out] */ IEnumPins **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IMediaStreamFilter * This,
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFilterInfo )( 
            IMediaStreamFilter * This,
            /* [out] */ FILTER_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IMediaStreamFilter * This,
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVendorInfo )( 
            IMediaStreamFilter * This,
            /* [string][out] */ LPWSTR *pVendorInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddMediaStream )( 
            IMediaStreamFilter * This,
            /* [in] */ IAMMediaStream *pAMMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IMediaStreamFilter * This,
            /* [in] */ REFMSPID idPurpose,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaStreams )( 
            IMediaStreamFilter * This,
            /* [in] */ long Index,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *SupportSeeking )( 
            IMediaStreamFilter * This,
            /* [in] */ BOOL bRenderer);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceTimeToStreamTime )( 
            IMediaStreamFilter * This,
            /* [out][in] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentStreamTime )( 
            IMediaStreamFilter * This,
            /* [out] */ REFERENCE_TIME *pCurrentStreamTime);
        
        HRESULT ( STDMETHODCALLTYPE *WaitUntil )( 
            IMediaStreamFilter * This,
            /* [in] */ REFERENCE_TIME WaitStreamTime);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMediaStreamFilter * This,
            /* [in] */ BOOL bCancelEOS);
        
        HRESULT ( STDMETHODCALLTYPE *EndOfStream )( 
            IMediaStreamFilter * This);
        
        END_INTERFACE
    } IMediaStreamFilterVtbl;

    interface IMediaStreamFilter
    {
        CONST_VTBL struct IMediaStreamFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaStreamFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaStreamFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaStreamFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaStreamFilter_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMediaStreamFilter_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMediaStreamFilter_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMediaStreamFilter_Run(This,tStart)	\
    (This)->lpVtbl -> Run(This,tStart)

#define IMediaStreamFilter_GetState(This,dwMilliSecsTimeout,State)	\
    (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State)

#define IMediaStreamFilter_SetSyncSource(This,pClock)	\
    (This)->lpVtbl -> SetSyncSource(This,pClock)

#define IMediaStreamFilter_GetSyncSource(This,pClock)	\
    (This)->lpVtbl -> GetSyncSource(This,pClock)


#define IMediaStreamFilter_EnumPins(This,ppEnum)	\
    (This)->lpVtbl -> EnumPins(This,ppEnum)

#define IMediaStreamFilter_FindPin(This,Id,ppPin)	\
    (This)->lpVtbl -> FindPin(This,Id,ppPin)

#define IMediaStreamFilter_QueryFilterInfo(This,pInfo)	\
    (This)->lpVtbl -> QueryFilterInfo(This,pInfo)

#define IMediaStreamFilter_JoinFilterGraph(This,pGraph,pName)	\
    (This)->lpVtbl -> JoinFilterGraph(This,pGraph,pName)

#define IMediaStreamFilter_QueryVendorInfo(This,pVendorInfo)	\
    (This)->lpVtbl -> QueryVendorInfo(This,pVendorInfo)


#define IMediaStreamFilter_AddMediaStream(This,pAMMediaStream)	\
    (This)->lpVtbl -> AddMediaStream(This,pAMMediaStream)

#define IMediaStreamFilter_GetMediaStream(This,idPurpose,ppMediaStream)	\
    (This)->lpVtbl -> GetMediaStream(This,idPurpose,ppMediaStream)

#define IMediaStreamFilter_EnumMediaStreams(This,Index,ppMediaStream)	\
    (This)->lpVtbl -> EnumMediaStreams(This,Index,ppMediaStream)

#define IMediaStreamFilter_SupportSeeking(This,bRenderer)	\
    (This)->lpVtbl -> SupportSeeking(This,bRenderer)

#define IMediaStreamFilter_ReferenceTimeToStreamTime(This,pTime)	\
    (This)->lpVtbl -> ReferenceTimeToStreamTime(This,pTime)

#define IMediaStreamFilter_GetCurrentStreamTime(This,pCurrentStreamTime)	\
    (This)->lpVtbl -> GetCurrentStreamTime(This,pCurrentStreamTime)

#define IMediaStreamFilter_WaitUntil(This,WaitStreamTime)	\
    (This)->lpVtbl -> WaitUntil(This,WaitStreamTime)

#define IMediaStreamFilter_Flush(This,bCancelEOS)	\
    (This)->lpVtbl -> Flush(This,bCancelEOS)

#define IMediaStreamFilter_EndOfStream(This)	\
    (This)->lpVtbl -> EndOfStream(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaStreamFilter_AddMediaStream_Proxy( 
    IMediaStreamFilter * This,
    /* [in] */ IAMMediaStream *pAMMediaStream);


void __RPC_STUB IMediaStreamFilter_AddMediaStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_GetMediaStream_Proxy( 
    IMediaStreamFilter * This,
    /* [in] */ REFMSPID idPurpose,
    /* [out] */ IMediaStream **ppMediaStream);


void __RPC_STUB IMediaStreamFilter_GetMediaStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_EnumMediaStreams_Proxy( 
    IMediaStreamFilter * This,
    /* [in] */ long Index,
    /* [out] */ IMediaStream **ppMediaStream);


void __RPC_STUB IMediaStreamFilter_EnumMediaStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_SupportSeeking_Proxy( 
    IMediaStreamFilter * This,
    /* [in] */ BOOL bRenderer);


void __RPC_STUB IMediaStreamFilter_SupportSeeking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_ReferenceTimeToStreamTime_Proxy( 
    IMediaStreamFilter * This,
    /* [out][in] */ REFERENCE_TIME *pTime);


void __RPC_STUB IMediaStreamFilter_ReferenceTimeToStreamTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_GetCurrentStreamTime_Proxy( 
    IMediaStreamFilter * This,
    /* [out] */ REFERENCE_TIME *pCurrentStreamTime);


void __RPC_STUB IMediaStreamFilter_GetCurrentStreamTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_WaitUntil_Proxy( 
    IMediaStreamFilter * This,
    /* [in] */ REFERENCE_TIME WaitStreamTime);


void __RPC_STUB IMediaStreamFilter_WaitUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_Flush_Proxy( 
    IMediaStreamFilter * This,
    /* [in] */ BOOL bCancelEOS);


void __RPC_STUB IMediaStreamFilter_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaStreamFilter_EndOfStream_Proxy( 
    IMediaStreamFilter * This);


void __RPC_STUB IMediaStreamFilter_EndOfStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaStreamFilter_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawMediaSampleAllocator_INTERFACE_DEFINED__
#define __IDirectDrawMediaSampleAllocator_INTERFACE_DEFINED__

/* interface IDirectDrawMediaSampleAllocator */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaSampleAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFC-F6E4-11d0-900D-00C04FD9189D")
    IDirectDrawMediaSampleAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            IDirectDraw **ppDirectDraw) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaSampleAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaSampleAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaSampleAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaSampleAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IDirectDrawMediaSampleAllocator * This,
            IDirectDraw **ppDirectDraw);
        
        END_INTERFACE
    } IDirectDrawMediaSampleAllocatorVtbl;

    interface IDirectDrawMediaSampleAllocator
    {
        CONST_VTBL struct IDirectDrawMediaSampleAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaSampleAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectDrawMediaSampleAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectDrawMediaSampleAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectDrawMediaSampleAllocator_GetDirectDraw(This,ppDirectDraw)	\
    (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectDrawMediaSampleAllocator_GetDirectDraw_Proxy( 
    IDirectDrawMediaSampleAllocator * This,
    IDirectDraw **ppDirectDraw);


void __RPC_STUB IDirectDrawMediaSampleAllocator_GetDirectDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectDrawMediaSampleAllocator_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawMediaSample_INTERFACE_DEFINED__
#define __IDirectDrawMediaSample_INTERFACE_DEFINED__

/* interface IDirectDrawMediaSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFE-F6E4-11d0-900D-00C04FD9189D")
    IDirectDrawMediaSample : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceAndReleaseLock( 
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockMediaSamplePointer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurfaceAndReleaseLock )( 
            IDirectDrawMediaSample * This,
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *LockMediaSamplePointer )( 
            IDirectDrawMediaSample * This);
        
        END_INTERFACE
    } IDirectDrawMediaSampleVtbl;

    interface IDirectDrawMediaSample
    {
        CONST_VTBL struct IDirectDrawMediaSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaSample_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectDrawMediaSample_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectDrawMediaSample_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectDrawMediaSample_GetSurfaceAndReleaseLock(This,ppDirectDrawSurface,pRect)	\
    (This)->lpVtbl -> GetSurfaceAndReleaseLock(This,ppDirectDrawSurface,pRect)

#define IDirectDrawMediaSample_LockMediaSamplePointer(This)	\
    (This)->lpVtbl -> LockMediaSamplePointer(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectDrawMediaSample_GetSurfaceAndReleaseLock_Proxy( 
    IDirectDrawMediaSample * This,
    /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
    /* [out] */ RECT *pRect);


void __RPC_STUB IDirectDrawMediaSample_GetSurfaceAndReleaseLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawMediaSample_LockMediaSamplePointer_Proxy( 
    IDirectDrawMediaSample * This);


void __RPC_STUB IDirectDrawMediaSample_LockMediaSamplePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectDrawMediaSample_INTERFACE_DEFINED__ */


#ifndef __IAMMediaTypeStream_INTERFACE_DEFINED__
#define __IAMMediaTypeStream_INTERFACE_DEFINED__

/* interface IAMMediaTypeStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMMediaTypeStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFA-F6E4-11d0-900D-00C04FD9189D")
    IAMMediaTypeStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ long lSampleSize,
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IAMMediaTypeSample **ppAMMediaTypeSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamAllocatorRequirements( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamAllocatorRequirements( 
            /* [in] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaTypeStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaTypeStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaTypeStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaTypeStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IAMMediaTypeStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAMMediaTypeStream * This,
            /* [out] */ MSPID *pPurposeId,
            /* [out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IAMMediaTypeStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IAMMediaTypeStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IAMMediaTypeStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IAMMediaTypeStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAMMediaTypeStream * This,
            /* [out] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAMMediaTypeStream * This,
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IAMMediaTypeStream * This,
            /* [in] */ long lSampleSize,
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IAMMediaTypeSample **ppAMMediaTypeSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamAllocatorRequirements )( 
            IAMMediaTypeStream * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamAllocatorRequirements )( 
            IAMMediaTypeStream * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pProps);
        
        END_INTERFACE
    } IAMMediaTypeStreamVtbl;

    interface IAMMediaTypeStream
    {
        CONST_VTBL struct IAMMediaTypeStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaTypeStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMMediaTypeStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMMediaTypeStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMMediaTypeStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream)

#define IAMMediaTypeStream_GetInformation(This,pPurposeId,pType)	\
    (This)->lpVtbl -> GetInformation(This,pPurposeId,pType)

#define IAMMediaTypeStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)

#define IAMMediaTypeStream_AllocateSample(This,dwFlags,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample)

#define IAMMediaTypeStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)

#define IAMMediaTypeStream_SendEndOfStream(This,dwFlags)	\
    (This)->lpVtbl -> SendEndOfStream(This,dwFlags)


#define IAMMediaTypeStream_GetFormat(This,pMediaType,dwFlags)	\
    (This)->lpVtbl -> GetFormat(This,pMediaType,dwFlags)

#define IAMMediaTypeStream_SetFormat(This,pMediaType,dwFlags)	\
    (This)->lpVtbl -> SetFormat(This,pMediaType,dwFlags)

#define IAMMediaTypeStream_CreateSample(This,lSampleSize,pbBuffer,dwFlags,pUnkOuter,ppAMMediaTypeSample)	\
    (This)->lpVtbl -> CreateSample(This,lSampleSize,pbBuffer,dwFlags,pUnkOuter,ppAMMediaTypeSample)

#define IAMMediaTypeStream_GetStreamAllocatorRequirements(This,pProps)	\
    (This)->lpVtbl -> GetStreamAllocatorRequirements(This,pProps)

#define IAMMediaTypeStream_SetStreamAllocatorRequirements(This,pProps)	\
    (This)->lpVtbl -> SetStreamAllocatorRequirements(This,pProps)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMMediaTypeStream_GetFormat_Proxy( 
    IAMMediaTypeStream * This,
    /* [out] */ AM_MEDIA_TYPE *pMediaType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMMediaTypeStream_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeStream_SetFormat_Proxy( 
    IAMMediaTypeStream * This,
    /* [in] */ AM_MEDIA_TYPE *pMediaType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMMediaTypeStream_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeStream_CreateSample_Proxy( 
    IAMMediaTypeStream * This,
    /* [in] */ long lSampleSize,
    /* [in] */ BYTE *pbBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown *pUnkOuter,
    /* [out] */ IAMMediaTypeSample **ppAMMediaTypeSample);


void __RPC_STUB IAMMediaTypeStream_CreateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeStream_GetStreamAllocatorRequirements_Proxy( 
    IAMMediaTypeStream * This,
    /* [out] */ ALLOCATOR_PROPERTIES *pProps);


void __RPC_STUB IAMMediaTypeStream_GetStreamAllocatorRequirements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeStream_SetStreamAllocatorRequirements_Proxy( 
    IAMMediaTypeStream * This,
    /* [in] */ ALLOCATOR_PROPERTIES *pProps);


void __RPC_STUB IAMMediaTypeStream_SetStreamAllocatorRequirements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMMediaTypeStream_INTERFACE_DEFINED__ */


#ifndef __IAMMediaTypeSample_INTERFACE_DEFINED__
#define __IAMMediaTypeSample_INTERFACE_DEFINED__

/* interface IAMMediaTypeSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMMediaTypeSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFB-F6E4-11d0-900D-00C04FD9189D")
    IAMMediaTypeSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPointer( 
            /* [in] */ BYTE *pBuffer,
            /* [in] */ long lSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointer( 
            /* [out] */ BYTE **ppBuffer) = 0;
        
        virtual long STDMETHODCALLTYPE GetSize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTime( 
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSyncPoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncPoint( 
            BOOL bIsSyncPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreroll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreroll( 
            BOOL bIsPreroll) = 0;
        
        virtual long STDMETHODCALLTYPE GetActualDataLength( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActualDataLength( 
            long __MIDL_0020) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            AM_MEDIA_TYPE **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDiscontinuity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDiscontinuity( 
            BOOL bDiscontinuity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTime( 
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaTime( 
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaTypeSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaTypeSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaTypeSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IAMMediaTypeSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IAMMediaTypeSample * This,
            /* [out] */ STREAM_TIME *pStartTime,
            /* [out] */ STREAM_TIME *pEndTime,
            /* [out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IAMMediaTypeSample * This,
            /* [in] */ const STREAM_TIME *pStartTime,
            /* [in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IAMMediaTypeSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hEvent,
            /* [in] */ PAPCFUNC pfnAPC,
            /* [in] */ DWORD_PTR dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IAMMediaTypeSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *SetPointer )( 
            IAMMediaTypeSample * This,
            /* [in] */ BYTE *pBuffer,
            /* [in] */ long lSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IAMMediaTypeSample * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IAMMediaTypeSample * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IAMMediaTypeSample * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IAMMediaTypeSample * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IAMMediaTypeSample * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IAMMediaTypeSample * This,
            long __MIDL_0020);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IAMMediaTypeSample * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IAMMediaTypeSample * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IAMMediaTypeSample * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IAMMediaTypeSample * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IAMMediaTypeSample * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        END_INTERFACE
    } IAMMediaTypeSampleVtbl;

    interface IAMMediaTypeSample
    {
        CONST_VTBL struct IAMMediaTypeSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaTypeSample_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMMediaTypeSample_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMMediaTypeSample_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMMediaTypeSample_GetMediaStream(This,ppMediaStream)	\
    (This)->lpVtbl -> GetMediaStream(This,ppMediaStream)

#define IAMMediaTypeSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)

#define IAMMediaTypeSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime)

#define IAMMediaTypeSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)

#define IAMMediaTypeSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds)


#define IAMMediaTypeSample_SetPointer(This,pBuffer,lSize)	\
    (This)->lpVtbl -> SetPointer(This,pBuffer,lSize)

#define IAMMediaTypeSample_GetPointer(This,ppBuffer)	\
    (This)->lpVtbl -> GetPointer(This,ppBuffer)

#define IAMMediaTypeSample_GetSize(This)	\
    (This)->lpVtbl -> GetSize(This)

#define IAMMediaTypeSample_GetTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd)

#define IAMMediaTypeSample_SetTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd)

#define IAMMediaTypeSample_IsSyncPoint(This)	\
    (This)->lpVtbl -> IsSyncPoint(This)

#define IAMMediaTypeSample_SetSyncPoint(This,bIsSyncPoint)	\
    (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint)

#define IAMMediaTypeSample_IsPreroll(This)	\
    (This)->lpVtbl -> IsPreroll(This)

#define IAMMediaTypeSample_SetPreroll(This,bIsPreroll)	\
    (This)->lpVtbl -> SetPreroll(This,bIsPreroll)

#define IAMMediaTypeSample_GetActualDataLength(This)	\
    (This)->lpVtbl -> GetActualDataLength(This)

#define IAMMediaTypeSample_SetActualDataLength(This,__MIDL_0020)	\
    (This)->lpVtbl -> SetActualDataLength(This,__MIDL_0020)

#define IAMMediaTypeSample_GetMediaType(This,ppMediaType)	\
    (This)->lpVtbl -> GetMediaType(This,ppMediaType)

#define IAMMediaTypeSample_SetMediaType(This,pMediaType)	\
    (This)->lpVtbl -> SetMediaType(This,pMediaType)

#define IAMMediaTypeSample_IsDiscontinuity(This)	\
    (This)->lpVtbl -> IsDiscontinuity(This)

#define IAMMediaTypeSample_SetDiscontinuity(This,bDiscontinuity)	\
    (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity)

#define IAMMediaTypeSample_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd)

#define IAMMediaTypeSample_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetPointer_Proxy( 
    IAMMediaTypeSample * This,
    /* [in] */ BYTE *pBuffer,
    /* [in] */ long lSize);


void __RPC_STUB IAMMediaTypeSample_SetPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_GetPointer_Proxy( 
    IAMMediaTypeSample * This,
    /* [out] */ BYTE **ppBuffer);


void __RPC_STUB IAMMediaTypeSample_GetPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


long STDMETHODCALLTYPE IAMMediaTypeSample_GetSize_Proxy( 
    IAMMediaTypeSample * This);


void __RPC_STUB IAMMediaTypeSample_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_GetTime_Proxy( 
    IAMMediaTypeSample * This,
    /* [out] */ REFERENCE_TIME *pTimeStart,
    /* [out] */ REFERENCE_TIME *pTimeEnd);


void __RPC_STUB IAMMediaTypeSample_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetTime_Proxy( 
    IAMMediaTypeSample * This,
    /* [in] */ REFERENCE_TIME *pTimeStart,
    /* [in] */ REFERENCE_TIME *pTimeEnd);


void __RPC_STUB IAMMediaTypeSample_SetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_IsSyncPoint_Proxy( 
    IAMMediaTypeSample * This);


void __RPC_STUB IAMMediaTypeSample_IsSyncPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetSyncPoint_Proxy( 
    IAMMediaTypeSample * This,
    BOOL bIsSyncPoint);


void __RPC_STUB IAMMediaTypeSample_SetSyncPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_IsPreroll_Proxy( 
    IAMMediaTypeSample * This);


void __RPC_STUB IAMMediaTypeSample_IsPreroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetPreroll_Proxy( 
    IAMMediaTypeSample * This,
    BOOL bIsPreroll);


void __RPC_STUB IAMMediaTypeSample_SetPreroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


long STDMETHODCALLTYPE IAMMediaTypeSample_GetActualDataLength_Proxy( 
    IAMMediaTypeSample * This);


void __RPC_STUB IAMMediaTypeSample_GetActualDataLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetActualDataLength_Proxy( 
    IAMMediaTypeSample * This,
    long __MIDL_0020);


void __RPC_STUB IAMMediaTypeSample_SetActualDataLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_GetMediaType_Proxy( 
    IAMMediaTypeSample * This,
    AM_MEDIA_TYPE **ppMediaType);


void __RPC_STUB IAMMediaTypeSample_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetMediaType_Proxy( 
    IAMMediaTypeSample * This,
    AM_MEDIA_TYPE *pMediaType);


void __RPC_STUB IAMMediaTypeSample_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_IsDiscontinuity_Proxy( 
    IAMMediaTypeSample * This);


void __RPC_STUB IAMMediaTypeSample_IsDiscontinuity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetDiscontinuity_Proxy( 
    IAMMediaTypeSample * This,
    BOOL bDiscontinuity);


void __RPC_STUB IAMMediaTypeSample_SetDiscontinuity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_GetMediaTime_Proxy( 
    IAMMediaTypeSample * This,
    /* [out] */ LONGLONG *pTimeStart,
    /* [out] */ LONGLONG *pTimeEnd);


void __RPC_STUB IAMMediaTypeSample_GetMediaTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMMediaTypeSample_SetMediaTime_Proxy( 
    IAMMediaTypeSample * This,
    /* [in] */ LONGLONG *pTimeStart,
    /* [in] */ LONGLONG *pTimeEnd);


void __RPC_STUB IAMMediaTypeSample_SetMediaTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMMediaTypeSample_INTERFACE_DEFINED__ */



#ifndef __DirectShowStreamLib_LIBRARY_DEFINED__
#define __DirectShowStreamLib_LIBRARY_DEFINED__

/* library DirectShowStreamLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DirectShowStreamLib;

EXTERN_C const CLSID CLSID_AMMultiMediaStream;

#ifdef __cplusplus

class DECLSPEC_UUID("49c47ce5-9ba4-11d0-8212-00c04fc32c45")
AMMultiMediaStream;
#endif
#endif /* __DirectShowStreamLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_amstream_0418 */
/* [local] */ 

#ifndef __cplusplus
EXTERN_C const CLSID CLSID_AMMultiMediaStream;
#endif
DEFINE_GUID(CLSID_AMDirectDrawStream, /* 49c47ce4-9ba4-11d0-8212-00c04fc32c45 */
0x49c47ce4, 0x9ba4, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMAudioStream, /* 8496e040-af4c-11d0-8212-00c04fc32c45 */
0x8496e040, 0xaf4c, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMAudioData, /* f2468580-af8a-11d0-8212-00c04fc32c45 */
0xf2468580, 0xaf8a, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMMediaTypeStream, /* CF0F2F7C-F7BF-11d0-900D-00C04FD9189D */
0xcf0f2f7c, 0xf7bf, 0x11d0, 0x90, 0xd, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);


extern RPC_IF_HANDLE __MIDL_itf_amstream_0418_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_amstream_0418_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\audevcod.h ===
//------------------------------------------------------------------------------
// File: AudEvCod.h
//
// Desc: List of Audio device error event codes and the expected params.
//
// Copyright (c) 1999-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------



#ifndef __AUDEVCOD__
#define __AUDEVCOD__


#define EC_SND_DEVICE_ERROR_BASE   0x0200

typedef enum _tagSND_DEVICE_ERROR {

    SNDDEV_ERROR_Open=1,
    SNDDEV_ERROR_Close=2,
    SNDDEV_ERROR_GetCaps=3,
    SNDDEV_ERROR_PrepareHeader=4,
    SNDDEV_ERROR_UnprepareHeader=5,
    SNDDEV_ERROR_Reset=6,
    SNDDEV_ERROR_Restart=7,
    SNDDEV_ERROR_GetPosition=8,
    SNDDEV_ERROR_Write=9,
    SNDDEV_ERROR_Pause=10,
    SNDDEV_ERROR_Stop=11,
    SNDDEV_ERROR_Start=12,
    SNDDEV_ERROR_AddBuffer=13,
    SNDDEV_ERROR_Query=14,

} SNDDEV_ERR;


// Sound device error event codes
// ==============================
//
// All audio device error events are always passed on to the application, and are
// never processed by the filter graph


#define EC_SNDDEV_IN_ERROR                    (EC_SND_DEVICE_ERROR_BASE + 0x00)
#define EC_SNDDEV_OUT_ERROR                   (EC_SND_DEVICE_ERROR_BASE + 0x01)
// Parameters: ( DWORD, DWORD)
// lParam1 is an enum SND_DEVICE_ERROR which notifies the app how the device was
// being accessed when the failure occurred.
//
// lParam2 is the error returned from the sound device call.
//

#endif // __AUDEVCOD__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\austream.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for austream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __austream_h__
#define __austream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAudioMediaStream_FWD_DEFINED__
#define __IAudioMediaStream_FWD_DEFINED__
typedef interface IAudioMediaStream IAudioMediaStream;
#endif 	/* __IAudioMediaStream_FWD_DEFINED__ */


#ifndef __IAudioStreamSample_FWD_DEFINED__
#define __IAudioStreamSample_FWD_DEFINED__
typedef interface IAudioStreamSample IAudioStreamSample;
#endif 	/* __IAudioStreamSample_FWD_DEFINED__ */


#ifndef __IMemoryData_FWD_DEFINED__
#define __IMemoryData_FWD_DEFINED__
typedef interface IMemoryData IMemoryData;
#endif 	/* __IMemoryData_FWD_DEFINED__ */


#ifndef __IAudioData_FWD_DEFINED__
#define __IAudioData_FWD_DEFINED__
typedef interface IAudioData IAudioData;
#endif 	/* __IAudioData_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_austream_0000 */
/* [local] */ 

//
//   The following declarations within the 'if 0' block are dummy typedefs used to make
//   the ddstream.idl file build.  The actual definitions are contained in DDRAW.H
//
#if 0
typedef struct tWAVEFORMATEX WAVEFORMATEX;

#endif






extern RPC_IF_HANDLE __MIDL_itf_austream_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_austream_0000_v0_0_s_ifspec;

#ifndef __IAudioMediaStream_INTERFACE_DEFINED__
#define __IAudioMediaStream_INTERFACE_DEFINED__

/* interface IAudioMediaStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7537560-a3be-11d0-8212-00c04fc32c45")
    IAudioMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ WAVEFORMATEX *pWaveFormatCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const WAVEFORMATEX *lpWaveFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ IAudioData *pAudioData,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IAudioStreamSample **ppSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IAudioMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAudioMediaStream * This,
            /* [out] */ MSPID *pPurposeId,
            /* [out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IAudioMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IAudioMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IAudioMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IAudioMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAudioMediaStream * This,
            /* [out] */ WAVEFORMATEX *pWaveFormatCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAudioMediaStream * This,
            /* [in] */ const WAVEFORMATEX *lpWaveFormat);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IAudioMediaStream * This,
            /* [in] */ IAudioData *pAudioData,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IAudioStreamSample **ppSample);
        
        END_INTERFACE
    } IAudioMediaStreamVtbl;

    interface IAudioMediaStream
    {
        CONST_VTBL struct IAudioMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMediaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAudioMediaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAudioMediaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAudioMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream)

#define IAudioMediaStream_GetInformation(This,pPurposeId,pType)	\
    (This)->lpVtbl -> GetInformation(This,pPurposeId,pType)

#define IAudioMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)

#define IAudioMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample)

#define IAudioMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)

#define IAudioMediaStream_SendEndOfStream(This,dwFlags)	\
    (This)->lpVtbl -> SendEndOfStream(This,dwFlags)


#define IAudioMediaStream_GetFormat(This,pWaveFormatCurrent)	\
    (This)->lpVtbl -> GetFormat(This,pWaveFormatCurrent)

#define IAudioMediaStream_SetFormat(This,lpWaveFormat)	\
    (This)->lpVtbl -> SetFormat(This,lpWaveFormat)

#define IAudioMediaStream_CreateSample(This,pAudioData,dwFlags,ppSample)	\
    (This)->lpVtbl -> CreateSample(This,pAudioData,dwFlags,ppSample)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAudioMediaStream_GetFormat_Proxy( 
    IAudioMediaStream * This,
    /* [out] */ WAVEFORMATEX *pWaveFormatCurrent);


void __RPC_STUB IAudioMediaStream_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAudioMediaStream_SetFormat_Proxy( 
    IAudioMediaStream * This,
    /* [in] */ const WAVEFORMATEX *lpWaveFormat);


void __RPC_STUB IAudioMediaStream_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAudioMediaStream_CreateSample_Proxy( 
    IAudioMediaStream * This,
    /* [in] */ IAudioData *pAudioData,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IAudioStreamSample **ppSample);


void __RPC_STUB IAudioMediaStream_CreateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAudioMediaStream_INTERFACE_DEFINED__ */


#ifndef __IAudioStreamSample_INTERFACE_DEFINED__
#define __IAudioStreamSample_INTERFACE_DEFINED__

/* interface IAudioStreamSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioStreamSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("345fee00-aba5-11d0-8212-00c04fc32c45")
    IAudioStreamSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAudioData( 
            /* [out] */ IAudioData **ppAudio) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioStreamSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioStreamSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioStreamSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioStreamSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IAudioStreamSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IAudioStreamSample * This,
            /* [out] */ STREAM_TIME *pStartTime,
            /* [out] */ STREAM_TIME *pEndTime,
            /* [out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IAudioStreamSample * This,
            /* [in] */ const STREAM_TIME *pStartTime,
            /* [in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IAudioStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hEvent,
            /* [in] */ PAPCFUNC pfnAPC,
            /* [in] */ DWORD_PTR dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IAudioStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioData )( 
            IAudioStreamSample * This,
            /* [out] */ IAudioData **ppAudio);
        
        END_INTERFACE
    } IAudioStreamSampleVtbl;

    interface IAudioStreamSample
    {
        CONST_VTBL struct IAudioStreamSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioStreamSample_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAudioStreamSample_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAudioStreamSample_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAudioStreamSample_GetMediaStream(This,ppMediaStream)	\
    (This)->lpVtbl -> GetMediaStream(This,ppMediaStream)

#define IAudioStreamSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)

#define IAudioStreamSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime)

#define IAudioStreamSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)

#define IAudioStreamSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds)


#define IAudioStreamSample_GetAudioData(This,ppAudio)	\
    (This)->lpVtbl -> GetAudioData(This,ppAudio)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAudioStreamSample_GetAudioData_Proxy( 
    IAudioStreamSample * This,
    /* [out] */ IAudioData **ppAudio);


void __RPC_STUB IAudioStreamSample_GetAudioData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAudioStreamSample_INTERFACE_DEFINED__ */


#ifndef __IMemoryData_INTERFACE_DEFINED__
#define __IMemoryData_INTERFACE_DEFINED__

/* interface IMemoryData */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMemoryData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("327fc560-af60-11d0-8212-00c04fc32c45")
    IMemoryData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBuffer( 
            /* [in] */ DWORD cbSize,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActual( 
            /* [in] */ DWORD cbDataValid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemoryDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemoryData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemoryData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemoryData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBuffer )( 
            IMemoryData * This,
            /* [in] */ DWORD cbSize,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IMemoryData * This,
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData);
        
        HRESULT ( STDMETHODCALLTYPE *SetActual )( 
            IMemoryData * This,
            /* [in] */ DWORD cbDataValid);
        
        END_INTERFACE
    } IMemoryDataVtbl;

    interface IMemoryData
    {
        CONST_VTBL struct IMemoryDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemoryData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMemoryData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMemoryData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMemoryData_SetBuffer(This,cbSize,pbData,dwFlags)	\
    (This)->lpVtbl -> SetBuffer(This,cbSize,pbData,dwFlags)

#define IMemoryData_GetInfo(This,pdwLength,ppbData,pcbActualData)	\
    (This)->lpVtbl -> GetInfo(This,pdwLength,ppbData,pcbActualData)

#define IMemoryData_SetActual(This,cbDataValid)	\
    (This)->lpVtbl -> SetActual(This,cbDataValid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMemoryData_SetBuffer_Proxy( 
    IMemoryData * This,
    /* [in] */ DWORD cbSize,
    /* [in] */ BYTE *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMemoryData_SetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemoryData_GetInfo_Proxy( 
    IMemoryData * This,
    /* [out] */ DWORD *pdwLength,
    /* [out] */ BYTE **ppbData,
    /* [out] */ DWORD *pcbActualData);


void __RPC_STUB IMemoryData_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemoryData_SetActual_Proxy( 
    IMemoryData * This,
    /* [in] */ DWORD cbDataValid);


void __RPC_STUB IMemoryData_SetActual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMemoryData_INTERFACE_DEFINED__ */


#ifndef __IAudioData_INTERFACE_DEFINED__
#define __IAudioData_INTERFACE_DEFINED__

/* interface IAudioData */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54c719c0-af60-11d0-8212-00c04fc32c45")
    IAudioData : public IMemoryData
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ WAVEFORMATEX *pWaveFormatCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const WAVEFORMATEX *lpWaveFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBuffer )( 
            IAudioData * This,
            /* [in] */ DWORD cbSize,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAudioData * This,
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData);
        
        HRESULT ( STDMETHODCALLTYPE *SetActual )( 
            IAudioData * This,
            /* [in] */ DWORD cbDataValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAudioData * This,
            /* [out] */ WAVEFORMATEX *pWaveFormatCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAudioData * This,
            /* [in] */ const WAVEFORMATEX *lpWaveFormat);
        
        END_INTERFACE
    } IAudioDataVtbl;

    interface IAudioData
    {
        CONST_VTBL struct IAudioDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAudioData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAudioData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAudioData_SetBuffer(This,cbSize,pbData,dwFlags)	\
    (This)->lpVtbl -> SetBuffer(This,cbSize,pbData,dwFlags)

#define IAudioData_GetInfo(This,pdwLength,ppbData,pcbActualData)	\
    (This)->lpVtbl -> GetInfo(This,pdwLength,ppbData,pcbActualData)

#define IAudioData_SetActual(This,cbDataValid)	\
    (This)->lpVtbl -> SetActual(This,cbDataValid)


#define IAudioData_GetFormat(This,pWaveFormatCurrent)	\
    (This)->lpVtbl -> GetFormat(This,pWaveFormatCurrent)

#define IAudioData_SetFormat(This,lpWaveFormat)	\
    (This)->lpVtbl -> SetFormat(This,lpWaveFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAudioData_GetFormat_Proxy( 
    IAudioData * This,
    /* [out] */ WAVEFORMATEX *pWaveFormatCurrent);


void __RPC_STUB IAudioData_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAudioData_SetFormat_Proxy( 
    IAudioData * This,
    /* [in] */ const WAVEFORMATEX *lpWaveFormat);


void __RPC_STUB IAudioData_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAudioData_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\atsmedia.h ===
//------------------------------------------------------------------------------
// File: ATSMedia.h
//
// Desc: Broadcast Driver Architecture Media Definitions for ATSC
//
// Copyright (c) 1996-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before BDAMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_BDAMEDIA_)
#error BDAMEDIA.H must be included before ATSCMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_ATSCMEDIA_)
#define _ATSCMEDIA_


//===========================================================================
//
//  ATSC Network Type
//
//===========================================================================

#define STATIC_BDANETWORKTYPE_ATSC\
    0x71985f51, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F51-1CA1-11d3-9CC8-00C04F7971E0", BDANETWORKTYPE_ATSC);
#define BDANETWORKTYPE_ATSC DEFINE_GUIDNAMED(BDANETWORKTYPE_ATSC)


#endif // _ATSCMEDIA_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\aviriff.h ===
//------------------------------------------------------------------------------
// File: AVIRIFF.h
//
// Desc: Structures and defines for the RIFF AVI file format extended to
//       handle very large/long files.
//
// Copyright (c) 1996-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

// Disable some compiler warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)


#if !defined AVIRIFF_H
#define AVIRIFF_H

#if !defined NUMELMS
  #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

// all structures in this file are packed on word boundaries
//
#include <pshpack2.h>

/*
 * heres the general layout of an AVI riff file (new format)
 *
 * RIFF (3F??????) AVI       <- not more than 1 GB in size
 *     LIST (size) hdrl
 *         avih (0038)
 *         LIST (size) strl
 *             strh (0038)
 *             strf (????)
 *             indx (3ff8)   <- size may vary, should be sector sized
 *         LIST (size) strl
 *             strh (0038)
 *             strf (????)
 *             indx (3ff8)   <- size may vary, should be sector sized
 *         LIST (size) odml
 *             dmlh (????)
 *         JUNK (size)       <- fill to align to sector - 12
 *     LIST (7f??????) movi  <- aligned on sector - 12
 *         00dc (size)       <- sector aligned
 *         01wb (size)       <- sector aligned
 *         ix00 (size)       <- sector aligned
 *     idx1 (00??????)       <- sector aligned
 * RIFF (7F??????) AVIX
 *     JUNK (size)           <- fill to align to sector -12
 *     LIST (size) movi
 *         00dc (size)       <- sector aligned
 * RIFF (7F??????) AVIX      <- not more than 2GB in size
 *     JUNK (size)           <- fill to align to sector - 12
 *     LIST (size) movi
 *         00dc (size)       <- sector aligned
 *
 *-===================================================================*/

//
// structures for manipulating RIFF headers
//
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

typedef struct _riffchunk {
   FOURCC fcc;
   DWORD  cb;
   } RIFFCHUNK, * LPRIFFCHUNK;
typedef struct _rifflist {
   FOURCC fcc;
   DWORD  cb;
   FOURCC fccListType;
   } RIFFLIST, * LPRIFFLIST;

#define RIFFROUND(cb) ((cb) + ((cb)&1))
#define RIFFNEXT(pChunk) (LPRIFFCHUNK)((LPBYTE)(pChunk) \
                          + sizeof(RIFFCHUNK) \
                          + RIFFROUND(((LPRIFFCHUNK)pChunk)->cb))


//
// ==================== avi header structures ===========================
//

// main header for the avi file (compatibility header)
//
#define ckidMAINAVIHEADER FCC('avih')
typedef struct _avimainheader {
    FOURCC fcc;                    // 'avih'
    DWORD  cb;                     // size of this structure -8
    DWORD  dwMicroSecPerFrame;     // frame display rate (or 0L)
    DWORD  dwMaxBytesPerSec;       // max. transfer rate
    DWORD  dwPaddingGranularity;   // pad to multiples of this size; normally 2K.
    DWORD  dwFlags;                // the ever-present flags
    #define AVIF_HASINDEX        0x00000010 // Index at end of file?
    #define AVIF_MUSTUSEINDEX    0x00000020
    #define AVIF_ISINTERLEAVED   0x00000100
    #define AVIF_TRUSTCKTYPE     0x00000800 // Use CKType to find key frames
    #define AVIF_WASCAPTUREFILE  0x00010000
    #define AVIF_COPYRIGHTED     0x00020000
    DWORD  dwTotalFrames;          // # frames in first movi list
    DWORD  dwInitialFrames;
    DWORD  dwStreams;
    DWORD  dwSuggestedBufferSize;
    DWORD  dwWidth;
    DWORD  dwHeight;
    DWORD  dwReserved[4];
    } AVIMAINHEADER;

#define ckidODML          FCC('odml')
#define ckidAVIEXTHEADER  FCC('dmlh')
typedef struct _aviextheader {
   FOURCC  fcc;                    // 'dmlh'
   DWORD   cb;                     // size of this structure -8
   DWORD   dwGrandFrames;          // total number of frames in the file
   DWORD   dwFuture[61];           // to be defined later
   } AVIEXTHEADER;

//
// structure of an AVI stream header riff chunk
//
#define ckidSTREAMLIST   FCC('strl')

#ifndef ckidSTREAMHEADER
#define ckidSTREAMHEADER FCC('strh')
#endif
typedef struct _avistreamheader {
   FOURCC fcc;          // 'strh'
   DWORD  cb;           // size of this structure - 8

   FOURCC fccType;      // stream type codes

   #ifndef streamtypeVIDEO
   #define streamtypeVIDEO FCC('vids')
   #define streamtypeAUDIO FCC('auds')
   #define streamtypeMIDI  FCC('mids')
   #define streamtypeTEXT  FCC('txts')
   #endif

   FOURCC fccHandler;
   DWORD  dwFlags;
   #define AVISF_DISABLED          0x00000001
   #define AVISF_VIDEO_PALCHANGES  0x00010000

   WORD   wPriority;
   WORD   wLanguage;
   DWORD  dwInitialFrames;
   DWORD  dwScale;
   DWORD  dwRate;       // dwRate/dwScale is stream tick rate in ticks/sec
   DWORD  dwStart;
   DWORD  dwLength;
   DWORD  dwSuggestedBufferSize;
   DWORD  dwQuality;
   DWORD  dwSampleSize;
   struct {
      short int left;
      short int top;
      short int right;
      short int bottom;
      }   rcFrame;
   } AVISTREAMHEADER;


//
// structure of an AVI stream format chunk
//
#ifndef ckidSTREAMFORMAT
#define ckidSTREAMFORMAT FCC('strf')
#endif
//
// avi stream formats are different for each stream type
//
// BITMAPINFOHEADER for video streams
// WAVEFORMATEX or PCMWAVEFORMAT for audio streams
// nothing for text streams
// nothing for midi streams


#pragma warning(disable:4200)
//
// structure of old style AVI index
//
#define ckidAVIOLDINDEX FCC('idx1')
typedef struct _avioldindex {
   FOURCC  fcc;        // 'idx1'
   DWORD   cb;         // size of this structure -8
   struct _avioldindex_entry {
      DWORD   dwChunkId;
      DWORD   dwFlags;

      #ifndef AVIIF_LIST
      #define AVIIF_LIST       0x00000001
      #define AVIIF_KEYFRAME   0x00000010
      #endif
     
      #define AVIIF_NO_TIME    0x00000100
      #define AVIIF_COMPRESSOR 0x0FFF0000  // unused?
      DWORD   dwOffset;    // offset of riff chunk header for the data
      DWORD   dwSize;      // size of the data (excluding riff header size)
      } aIndex[];          // size of this array
   } AVIOLDINDEX;


//
// ============ structures for timecode in an AVI file =================
//

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED

// defined
// timecode time structure
//
typedef union _timecode {
   struct {
      WORD   wFrameRate;
      WORD   wFrameFract;
      LONG   cFrames;
      };
   DWORDLONG  qw;
   } TIMECODE;

#endif // TIMECODE_DEFINED

#define TIMECODE_RATE_30DROP 0   // this MUST be zero

// struct for all the SMPTE timecode info
//
typedef struct _timecodedata {
   TIMECODE time;
   DWORD    dwSMPTEflags;
   DWORD    dwUser;
   } TIMECODEDATA;

// dwSMPTEflags masks/values
//
#define TIMECODE_SMPTE_BINARY_GROUP 0x07
#define TIMECODE_SMPTE_COLOR_FRAME  0x08

//
// ============ structures for new style AVI indexes =================
//

// index type codes
//
#define AVI_INDEX_OF_INDEXES       0x00
#define AVI_INDEX_OF_CHUNKS        0x01
#define AVI_INDEX_OF_TIMED_CHUNKS  0x02
#define AVI_INDEX_OF_SUB_2FIELD    0x03
#define AVI_INDEX_IS_DATA          0x80

// index subtype codes
//
#define AVI_INDEX_SUB_DEFAULT      0x00

// INDEX_OF_CHUNKS subtype codes
//
#define AVI_INDEX_SUB_2FIELD       0x01

// meta structure of all avi indexes
//
typedef struct _avimetaindex {
   FOURCC fcc;
   UINT   cb;
   WORD   wLongsPerEntry;
   BYTE   bIndexSubType;
   BYTE   bIndexType;
   DWORD  nEntriesInUse;
   DWORD  dwChunkId;
   DWORD  dwReserved[3];
   DWORD  adwIndex[];
   } AVIMETAINDEX;

#define STDINDEXSIZE 0x4000
#define NUMINDEX(wLongsPerEntry) ((STDINDEXSIZE-32)/4/(wLongsPerEntry))
#define NUMINDEXFILL(wLongsPerEntry) ((STDINDEXSIZE/4) - NUMINDEX(wLongsPerEntry))

// structure of a super index (INDEX_OF_INDEXES)
//
#define ckidAVISUPERINDEX FCC('indx')
typedef struct _avisuperindex {
   FOURCC   fcc;               // 'indx'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==4
   BYTE     bIndexSubType;     // ==0 (frame index) or AVI_INDEX_SUB_2FIELD 
   BYTE     bIndexType;        // ==AVI_INDEX_OF_INDEXES
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORD    dwReserved[3];     // must be 0
   struct _avisuperindex_entry {
      DWORDLONG qwOffset;    // 64 bit offset to sub index chunk
      DWORD    dwSize;       // 32 bit size of sub index chunk
      DWORD    dwDuration;   // time span of subindex chunk (in stream ticks)
      } aIndex[NUMINDEX(4)];
   } AVISUPERINDEX;
#define Valid_SUPERINDEX(pi) (*(DWORD *)(&((pi)->wLongsPerEntry)) == (4 | (AVI_INDEX_OF_INDEXES << 24)))

// struct of a standard index (AVI_INDEX_OF_CHUNKS)
//
typedef struct _avistdindex_entry {
   DWORD dwOffset;       // 32 bit offset to data (points to data, not riff header)
   DWORD dwSize;         // 31 bit size of data (does not include size of riff header), bit 31 is deltaframe bit
   } AVISTDINDEX_ENTRY;
#define AVISTDINDEX_DELTAFRAME ( 0x80000000) // Delta frames have the high bit set
#define AVISTDINDEX_SIZEMASK   (~0x80000000)

typedef struct _avistdindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==2
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_OF_CHUNKS
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORDLONG qwBaseOffset;     // base offset that all index intries are relative to
   DWORD    dwReserved_3;      // must be 0
   AVISTDINDEX_ENTRY aIndex[NUMINDEX(2)];
   } AVISTDINDEX;

// struct of a time variant standard index (AVI_INDEX_OF_TIMED_CHUNKS)
//
typedef struct _avitimedindex_entry {
   DWORD dwOffset;       // 32 bit offset to data (points to data, not riff header)
   DWORD dwSize;         // 31 bit size of data (does not include size of riff header) (high bit is deltaframe bit)
   DWORD dwDuration;     // how much time the chunk should be played (in stream ticks)
   } AVITIMEDINDEX_ENTRY;

typedef struct _avitimedindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==3
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_OF_TIMED_CHUNKS
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORDLONG qwBaseOffset;     // base offset that all index intries are relative to
   DWORD    dwReserved_3;      // must be 0
   AVITIMEDINDEX_ENTRY aIndex[NUMINDEX(3)];
   DWORD adwTrailingFill[NUMINDEXFILL(3)]; // to align struct to correct size
   } AVITIMEDINDEX;

// structure of a timecode stream
//
typedef struct _avitimecodeindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==4
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_IS_DATA
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // 'time'
   DWORD    dwReserved[3];     // must be 0
   TIMECODEDATA aIndex[NUMINDEX(sizeof(TIMECODEDATA)/sizeof(LONG))];
   } AVITIMECODEINDEX;

// structure of a timecode discontinuity list (when wLongsPerEntry == 7)
//
typedef struct _avitcdlindex_entry {
    DWORD    dwTick;           // stream tick time that maps to this timecode value
    TIMECODE time;
    DWORD    dwSMPTEflags;
    DWORD    dwUser;
    TCHAR    szReelId[12];
    } AVITCDLINDEX_ENTRY;

typedef struct _avitcdlindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==7 (must be 4 or more all 'tcdl' indexes
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_IS_DATA
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // 'tcdl'
   DWORD    dwReserved[3];     // must be 0
   AVITCDLINDEX_ENTRY aIndex[NUMINDEX(7)];
   DWORD adwTrailingFill[NUMINDEXFILL(7)]; // to align struct to correct size
   } AVITCDLINDEX;

typedef struct _avifieldindex_chunk {
   FOURCC   fcc;               // 'ix##'
   DWORD    cb;                // size of this structure
   WORD     wLongsPerEntry;    // must be 3 (size of each entry in
                               // aIndex array)
   BYTE     bIndexSubType;     // AVI_INDEX_2FIELD
   BYTE     bIndexType;        // AVI_INDEX_OF_CHUNKS
   DWORD    nEntriesInUse;     //
   DWORD    dwChunkId;         // '##dc' or '##db'
   DWORDLONG qwBaseOffset;     // offsets in aIndex array are relative to this
   DWORD    dwReserved3;       // must be 0
   struct _avifieldindex_entry {
      DWORD    dwOffset;
      DWORD    dwSize;         // size of all fields
                               // (bit 31 set for NON-keyframes)
      DWORD    dwOffsetField2; // offset to second field
   } aIndex[  ];
} AVIFIELDINDEX, * PAVIFIELDINDEX;


#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\Amvideo.h ===
//------------------------------------------------------------------------------
// File: AMVideo.h
//
// Desc: Video related definitions and interfaces for ActiveMovie.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMVIDEO__
#define __AMVIDEO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <ddraw.h>


// This is an interface on the video renderer that provides information about
// DirectDraw with respect to its use by the renderer. For example it allows
// an application to get details of the surface and any hardware capabilities
// that are available. It also allows someone to adjust the surfaces that the
// renderer should use and furthermore even set the DirectDraw instance. We
// allow someone to set the DirectDraw instance because DirectDraw can only
// be opened once per process so it helps resolve conflicts. There is some
// duplication in this interface as the hardware/emulated/FOURCCs available
// can all be found through the IDirectDraw interface, this interface allows
// simple access to that information without calling the DirectDraw provider
// itself. The AMDDS prefix is ActiveMovie DirectDraw Switches abbreviated.

#define AMDDS_NONE 0x00             // No use for DCI/DirectDraw
#define AMDDS_DCIPS 0x01            // Use DCI primary surface
#define AMDDS_PS 0x02               // Use DirectDraw primary
#define AMDDS_RGBOVR 0x04           // RGB overlay surfaces
#define AMDDS_YUVOVR 0x08           // YUV overlay surfaces
#define AMDDS_RGBOFF 0x10           // RGB offscreen surfaces
#define AMDDS_YUVOFF 0x20           // YUV offscreen surfaces
#define AMDDS_RGBFLP 0x40           // RGB flipping surfaces
#define AMDDS_YUVFLP 0x80           // YUV flipping surfaces
#define AMDDS_ALL 0xFF              // ALL the previous flags
#define AMDDS_DEFAULT AMDDS_ALL     // Use all available surfaces

#define AMDDS_YUV (AMDDS_YUVOFF | AMDDS_YUVOVR | AMDDS_YUVFLP)
#define AMDDS_RGB (AMDDS_RGBOFF | AMDDS_RGBOVR | AMDDS_RGBFLP)
#define AMDDS_PRIMARY (AMDDS_DCIPS | AMDDS_PS)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IDirectDrawVideo

DECLARE_INTERFACE_(IDirectDrawVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDirectDrawVideo methods

    STDMETHOD(GetSwitches)(THIS_ DWORD *pSwitches) PURE;
    STDMETHOD(SetSwitches)(THIS_ DWORD Switches) PURE;
    STDMETHOD(GetCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetEmulatedCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ DDSURFACEDESC *pSurfaceDesc) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_ DWORD *pCount,DWORD *pCodes) PURE;
    STDMETHOD(SetDirectDraw)(THIS_ LPDIRECTDRAW pDirectDraw) PURE;
    STDMETHOD(GetDirectDraw)(THIS_ LPDIRECTDRAW *ppDirectDraw) PURE;
    STDMETHOD(GetSurfaceType)(THIS_ DWORD *pSurfaceType) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
    STDMETHOD(UseScanLine)(THIS_ long UseScanLine) PURE;
    STDMETHOD(CanUseScanLine)(THIS_ long *UseScanLine) PURE;
    STDMETHOD(UseOverlayStretch)(THIS_ long UseOverlayStretch) PURE;
    STDMETHOD(CanUseOverlayStretch)(THIS_ long *UseOverlayStretch) PURE;
    STDMETHOD(UseWhenFullScreen)(THIS_ long UseWhenFullScreen) PURE;
    STDMETHOD(WillUseFullScreen)(THIS_ long *UseWhenFullScreen) PURE;
};


// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IQualProp

DECLARE_INTERFACE_(IQualProp, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Compare these with the functions in class CGargle in gargle.h

    STDMETHOD(get_FramesDroppedInRenderer)(THIS_ int *pcFrames) PURE;  // Out
    STDMETHOD(get_FramesDrawn)(THIS_ int *pcFramesDrawn) PURE;         // Out
    STDMETHOD(get_AvgFrameRate)(THIS_ int *piAvgFrameRate) PURE;       // Out
    STDMETHOD(get_Jitter)(THIS_ int *iJitter) PURE;                    // Out
    STDMETHOD(get_AvgSyncOffset)(THIS_ int *piAvg) PURE;               // Out
    STDMETHOD(get_DevSyncOffset)(THIS_ int *piDev) PURE;               // Out
};


// This interface allows an application or plug in distributor to control a
// full screen renderer. The Modex renderer supports this interface. When
// connected a renderer should load the display modes it has available
// The number of modes available can be obtained through CountModes. Then
// information on each individual mode is available by calling GetModeInfo
// and IsModeAvailable. An application may enable and disable any modes
// by calling the SetEnabled flag with OATRUE or OAFALSE (not C/C++ TRUE
// and FALSE values) - the current value may be queried by IsModeEnabled

// A more generic way of setting the modes enabled that is easier to use
// when writing applications is the clip loss factor. This defines the
// amount of video that can be lost when deciding which display mode to
// use. Assuming the decoder cannot compress the video then playing an
// MPEG file (say 352x288) into a 320x200 display will lose about 25% of
// the image. The clip loss factor specifies the upper range permissible.
// To allow typical MPEG video to be played in 320x200 it defaults to 25%

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideo

DECLARE_INTERFACE_(IFullScreenVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
};


// This adds the accelerator table capabilities in fullscreen. This is being
// added between the original runtime release and the full SDK release. We
// cannot just add the method to IFullScreenVideo as we don't want to force
// applications to have to ship the ActiveMovie support DLLs - this is very
// important to applications that plan on being downloaded over the Internet

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideoEx

DECLARE_INTERFACE_(IFullScreenVideoEx, IFullScreenVideo)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;

    // IFullScreenVideoEx

    STDMETHOD(SetAcceleratorTable)(THIS_ HWND hwnd,HACCEL hAccel) PURE;
    STDMETHOD(GetAcceleratorTable)(THIS_ HWND *phwnd,HACCEL *phAccel) PURE;
    STDMETHOD(KeepPixelAspectRatio)(THIS_ long KeepAspect) PURE;
    STDMETHOD(IsKeepPixelAspectRatio)(THIS_ long *pKeepAspect) PURE;
};


// The SDK base classes contain a base video mixer class. Video mixing in a
// software environment is tricky because we typically have multiple streams
// each sending data at unpredictable times. To work with this we defined a
// pin that is the lead pin, when data arrives on this pin we do a mix. As
// an alternative we may not want to have a lead pin but output samples at
// predefined spaces, like one every 1/15 of a second, this interfaces also
// supports that mode of operations (there is a working video mixer sample)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IBaseVideoMixer

DECLARE_INTERFACE_(IBaseVideoMixer, IUnknown)
{
    STDMETHOD(SetLeadPin)(THIS_ int iPin) PURE;
    STDMETHOD(GetLeadPin)(THIS_ int *piPin) PURE;
    STDMETHOD(GetInputPinCount)(THIS_ int *piPinCount) PURE;
    STDMETHOD(IsUsingClock)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetUsingClock)(THIS_ int bValue) PURE;
    STDMETHOD(GetClockPeriod)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetClockPeriod)(THIS_ int bValue) PURE;
};

#define iPALETTE_COLORS 256     // Maximum colours in palette
#define iEGA_COLORS 16          // Number colours in EGA palette
#define iMASK_COLORS 3          // Maximum three components
#define iTRUECOLOR 16           // Minimum true colour device
#define iRED 0                  // Index position for RED mask
#define iGREEN 1                // Index position for GREEN mask
#define iBLUE 2                 // Index position for BLUE mask
#define iPALETTE 8              // Maximum colour depth using a palette
#define iMAXBITS 8              // Maximum bits per colour component


// Used for true colour images that also have a palette

typedef struct tag_TRUECOLORINFO {
    DWORD   dwBitMasks[iMASK_COLORS];
    RGBQUAD bmiColors[iPALETTE_COLORS];
} TRUECOLORINFO;


// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagVIDEOINFOHEADER {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

} VIDEOINFOHEADER;

// make sure the pbmi is initialized before using these macros
#define TRUECOLOR(pbmi)  ((TRUECOLORINFO *)(((LPBYTE)&((pbmi)->bmiHeader)) \
					+ (pbmi)->bmiHeader.biSize))
#define COLORS(pbmi)	((RGBQUAD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))
#define BITMASKS(pbmi)	((DWORD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))

// All the image based filters use this to communicate their media types. It's
// centred principally around the BITMAPINFO. This structure always contains a
// BITMAPINFOHEADER followed by a number of other fields depending on what the
// BITMAPINFOHEADER contains. If it contains details of a palettised format it
// will be followed by one or more RGBQUADs defining the palette. If it holds
// details of a true colour format then it may be followed by a set of three
// DWORD bit masks that specify where the RGB data can be found in the image
// (For more information regarding BITMAPINFOs see the Win32 documentation)

// The rcSource and rcTarget fields are not for use by filters supplying the
// data. The destination (target) rectangle should be set to all zeroes. The
// source may also be zero filled or set with the dimensions of the video. So
// if the video is 352x288 pixels then set it to (0,0,352,288). These fields
// are mainly used by downstream filters that want to ask the source filter
// to place the image in a different position in an output buffer. So when
// using for example the primary surface the video renderer may ask a filter
// to place the video images in a destination position of (100,100,452,388)
// on the display since that's where the window is positioned on the display

// !!! WARNING !!!
// DO NOT use this structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagVIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
        DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
        TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    };

} VIDEOINFO;

// These macros define some standard bitmap format sizes

#define SIZE_EGA_PALETTE (iEGA_COLORS * sizeof(RGBQUAD))
#define SIZE_PALETTE (iPALETTE_COLORS * sizeof(RGBQUAD))
#define SIZE_MASKS (iMASK_COLORS * sizeof(DWORD))
#define SIZE_PREHEADER (FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader))
#define SIZE_VIDEOHEADER (sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER)
// !!! for abnormal biSizes
// #define SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + SIZE_PREHEADER)

// DIBSIZE calculates the number of bytes required by an image

#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))

// This compares the bit masks between two VIDEOINFOHEADERs

#define BIT_MASKS_MATCH(pbmi1,pbmi2)                                \
    (((pbmi1)->dwBitMasks[iRED] == (pbmi2)->dwBitMasks[iRED]) &&        \
     ((pbmi1)->dwBitMasks[iGREEN] == (pbmi2)->dwBitMasks[iGREEN]) &&    \
     ((pbmi1)->dwBitMasks[iBLUE] == (pbmi2)->dwBitMasks[iBLUE]))

// These zero fill different parts of the VIDEOINFOHEADER structure

// Only use these macros for pbmi's with a normal BITMAPINFOHEADER biSize
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(pbmi)->dwBitFields,SIZE_MASKS))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi),SIZE_VIDEOHEADER))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(pbmi)->bmiColors,SIZE_PALETTE));

#if 0
// !!! This is the right way to do it, but may break existing code
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_MASKS)))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi), SIZE_PREHEADER +	    \
			sizeof(BITMAPINFOHEADER)))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_PALETTE))
#endif

// Other (hopefully) useful bits and bobs

#define PALETTISED(pbmi) ((pbmi)->bmiHeader.biBitCount <= iPALETTE)
#define PALETTE_ENTRIES(pbmi) ((DWORD) 1 << (pbmi)->bmiHeader.biBitCount)

// Returns the address of the BITMAPINFOHEADER from the VIDEOINFOHEADER
#define HEADER(pVideoInfo) (&(((VIDEOINFOHEADER *) (pVideoInfo))->bmiHeader))


// MPEG variant - includes a DWORD length followed by the
// video sequence header after the video header.
//
// The sequence header includes the sequence header start code and the
// quantization matrices associated with the first sequence header in the
// stream so is a maximum of 140 bytes long.

typedef struct tagMPEG1VIDEOINFO {

    VIDEOINFOHEADER hdr;                    // Compatible with VIDEOINFO
    DWORD           dwStartTimeCode;        // 25-bit Group of pictures time code
                                            // at start of data
    DWORD           cbSequenceHeader;       // Length in bytes of bSequenceHeader
    BYTE            bSequenceHeader[1];     // Sequence header including
                                            // quantization matrices if any
} MPEG1VIDEOINFO;

#define MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)


// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagAnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} ANALOGVIDEOINFO;

//
// AM_KSPROPSETID_FrameStep property set definitions
//
typedef enum {
        //  Step
	AM_PROPERTY_FRAMESTEP_STEP   = 0x01,
	AM_PROPERTY_FRAMESTEP_CANCEL = 0x02,

        //  S_OK for these 2 means we can - S_FALSE if we can't
        AM_PROPERTY_FRAMESTEP_CANSTEP = 0x03,
        AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = 0x04
} AM_PROPERTY_FRAMESTEP;

typedef struct _AM_FRAMESTEP_STEP
{
    //  1 means step 1 frame forward
    //  0 is invalid
    //  n (n > 1) means skip n - 1 frames and show the nth
    DWORD dwFramesToStep;
} AM_FRAMESTEP_STEP;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMVIDEO__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\bdaiface.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for bdaiface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __bdaiface_h__
#define __bdaiface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBDA_NetworkProvider_FWD_DEFINED__
#define __IBDA_NetworkProvider_FWD_DEFINED__
typedef interface IBDA_NetworkProvider IBDA_NetworkProvider;
#endif 	/* __IBDA_NetworkProvider_FWD_DEFINED__ */


#ifndef __IBDA_EthernetFilter_FWD_DEFINED__
#define __IBDA_EthernetFilter_FWD_DEFINED__
typedef interface IBDA_EthernetFilter IBDA_EthernetFilter;
#endif 	/* __IBDA_EthernetFilter_FWD_DEFINED__ */


#ifndef __IBDA_IPV4Filter_FWD_DEFINED__
#define __IBDA_IPV4Filter_FWD_DEFINED__
typedef interface IBDA_IPV4Filter IBDA_IPV4Filter;
#endif 	/* __IBDA_IPV4Filter_FWD_DEFINED__ */


#ifndef __IBDA_IPV6Filter_FWD_DEFINED__
#define __IBDA_IPV6Filter_FWD_DEFINED__
typedef interface IBDA_IPV6Filter IBDA_IPV6Filter;
#endif 	/* __IBDA_IPV6Filter_FWD_DEFINED__ */


#ifndef __IBDA_DeviceControl_FWD_DEFINED__
#define __IBDA_DeviceControl_FWD_DEFINED__
typedef interface IBDA_DeviceControl IBDA_DeviceControl;
#endif 	/* __IBDA_DeviceControl_FWD_DEFINED__ */


#ifndef __IBDA_PinControl_FWD_DEFINED__
#define __IBDA_PinControl_FWD_DEFINED__
typedef interface IBDA_PinControl IBDA_PinControl;
#endif 	/* __IBDA_PinControl_FWD_DEFINED__ */


#ifndef __IBDA_SignalProperties_FWD_DEFINED__
#define __IBDA_SignalProperties_FWD_DEFINED__
typedef interface IBDA_SignalProperties IBDA_SignalProperties;
#endif 	/* __IBDA_SignalProperties_FWD_DEFINED__ */


#ifndef __IBDA_SignalStatistics_FWD_DEFINED__
#define __IBDA_SignalStatistics_FWD_DEFINED__
typedef interface IBDA_SignalStatistics IBDA_SignalStatistics;
#endif 	/* __IBDA_SignalStatistics_FWD_DEFINED__ */


#ifndef __IBDA_Topology_FWD_DEFINED__
#define __IBDA_Topology_FWD_DEFINED__
typedef interface IBDA_Topology IBDA_Topology;
#endif 	/* __IBDA_Topology_FWD_DEFINED__ */


#ifndef __IBDA_VoidTransform_FWD_DEFINED__
#define __IBDA_VoidTransform_FWD_DEFINED__
typedef interface IBDA_VoidTransform IBDA_VoidTransform;
#endif 	/* __IBDA_VoidTransform_FWD_DEFINED__ */


#ifndef __IBDA_NullTransform_FWD_DEFINED__
#define __IBDA_NullTransform_FWD_DEFINED__
typedef interface IBDA_NullTransform IBDA_NullTransform;
#endif 	/* __IBDA_NullTransform_FWD_DEFINED__ */


#ifndef __IBDA_FrequencyFilter_FWD_DEFINED__
#define __IBDA_FrequencyFilter_FWD_DEFINED__
typedef interface IBDA_FrequencyFilter IBDA_FrequencyFilter;
#endif 	/* __IBDA_FrequencyFilter_FWD_DEFINED__ */


#ifndef __IBDA_LNBInfo_FWD_DEFINED__
#define __IBDA_LNBInfo_FWD_DEFINED__
typedef interface IBDA_LNBInfo IBDA_LNBInfo;
#endif 	/* __IBDA_LNBInfo_FWD_DEFINED__ */


#ifndef __IBDA_AutoDemodulate_FWD_DEFINED__
#define __IBDA_AutoDemodulate_FWD_DEFINED__
typedef interface IBDA_AutoDemodulate IBDA_AutoDemodulate;
#endif 	/* __IBDA_AutoDemodulate_FWD_DEFINED__ */


#ifndef __IBDA_DigitalDemodulator_FWD_DEFINED__
#define __IBDA_DigitalDemodulator_FWD_DEFINED__
typedef interface IBDA_DigitalDemodulator IBDA_DigitalDemodulator;
#endif 	/* __IBDA_DigitalDemodulator_FWD_DEFINED__ */


#ifndef __IBDA_IPSinkControl_FWD_DEFINED__
#define __IBDA_IPSinkControl_FWD_DEFINED__
typedef interface IBDA_IPSinkControl IBDA_IPSinkControl;
#endif 	/* __IBDA_IPSinkControl_FWD_DEFINED__ */


#ifndef __IBDA_IPSinkInfo_FWD_DEFINED__
#define __IBDA_IPSinkInfo_FWD_DEFINED__
typedef interface IBDA_IPSinkInfo IBDA_IPSinkInfo;
#endif 	/* __IBDA_IPSinkInfo_FWD_DEFINED__ */


#ifndef __IEnumPIDMap_FWD_DEFINED__
#define __IEnumPIDMap_FWD_DEFINED__
typedef interface IEnumPIDMap IEnumPIDMap;
#endif 	/* __IEnumPIDMap_FWD_DEFINED__ */


#ifndef __IMPEG2PIDMap_FWD_DEFINED__
#define __IMPEG2PIDMap_FWD_DEFINED__
typedef interface IMPEG2PIDMap IMPEG2PIDMap;
#endif 	/* __IMPEG2PIDMap_FWD_DEFINED__ */


#ifndef __IFrequencyMap_FWD_DEFINED__
#define __IFrequencyMap_FWD_DEFINED__
typedef interface IFrequencyMap IFrequencyMap;
#endif 	/* __IFrequencyMap_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"
#include "BdaTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IBDA_NetworkProvider_INTERFACE_DEFINED__
#define __IBDA_NetworkProvider_INTERFACE_DEFINED__

/* interface IBDA_NetworkProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_NetworkProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd501041-8ebe-11ce-8183-00aa00577da2")
    IBDA_NetworkProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutSignalSource( 
            /* [in] */ ULONG ulSignalSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignalSource( 
            /* [out][in] */ ULONG *pulSignalSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkType( 
            /* [out][in] */ GUID *pguidNetworkType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutTuningSpace( 
            /* [in] */ REFGUID guidTuningSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTuningSpace( 
            /* [out][in] */ GUID *pguidTuingSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterDeviceFilter( 
            /* [in] */ IUnknown *pUnkFilterControl,
            /* [out][in] */ ULONG *ppvRegisitrationContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterDeviceFilter( 
            /* [in] */ ULONG pvRegistrationContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_NetworkProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_NetworkProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_NetworkProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_NetworkProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutSignalSource )( 
            IBDA_NetworkProvider * This,
            /* [in] */ ULONG ulSignalSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignalSource )( 
            IBDA_NetworkProvider * This,
            /* [out][in] */ ULONG *pulSignalSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkType )( 
            IBDA_NetworkProvider * This,
            /* [out][in] */ GUID *pguidNetworkType);
        
        HRESULT ( STDMETHODCALLTYPE *PutTuningSpace )( 
            IBDA_NetworkProvider * This,
            /* [in] */ REFGUID guidTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *GetTuningSpace )( 
            IBDA_NetworkProvider * This,
            /* [out][in] */ GUID *pguidTuingSpace);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDeviceFilter )( 
            IBDA_NetworkProvider * This,
            /* [in] */ IUnknown *pUnkFilterControl,
            /* [out][in] */ ULONG *ppvRegisitrationContext);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterDeviceFilter )( 
            IBDA_NetworkProvider * This,
            /* [in] */ ULONG pvRegistrationContext);
        
        END_INTERFACE
    } IBDA_NetworkProviderVtbl;

    interface IBDA_NetworkProvider
    {
        CONST_VTBL struct IBDA_NetworkProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_NetworkProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_NetworkProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_NetworkProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_NetworkProvider_PutSignalSource(This,ulSignalSource)	\
    (This)->lpVtbl -> PutSignalSource(This,ulSignalSource)

#define IBDA_NetworkProvider_GetSignalSource(This,pulSignalSource)	\
    (This)->lpVtbl -> GetSignalSource(This,pulSignalSource)

#define IBDA_NetworkProvider_GetNetworkType(This,pguidNetworkType)	\
    (This)->lpVtbl -> GetNetworkType(This,pguidNetworkType)

#define IBDA_NetworkProvider_PutTuningSpace(This,guidTuningSpace)	\
    (This)->lpVtbl -> PutTuningSpace(This,guidTuningSpace)

#define IBDA_NetworkProvider_GetTuningSpace(This,pguidTuingSpace)	\
    (This)->lpVtbl -> GetTuningSpace(This,pguidTuingSpace)

#define IBDA_NetworkProvider_RegisterDeviceFilter(This,pUnkFilterControl,ppvRegisitrationContext)	\
    (This)->lpVtbl -> RegisterDeviceFilter(This,pUnkFilterControl,ppvRegisitrationContext)

#define IBDA_NetworkProvider_UnRegisterDeviceFilter(This,pvRegistrationContext)	\
    (This)->lpVtbl -> UnRegisterDeviceFilter(This,pvRegistrationContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_PutSignalSource_Proxy( 
    IBDA_NetworkProvider * This,
    /* [in] */ ULONG ulSignalSource);


void __RPC_STUB IBDA_NetworkProvider_PutSignalSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_GetSignalSource_Proxy( 
    IBDA_NetworkProvider * This,
    /* [out][in] */ ULONG *pulSignalSource);


void __RPC_STUB IBDA_NetworkProvider_GetSignalSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_GetNetworkType_Proxy( 
    IBDA_NetworkProvider * This,
    /* [out][in] */ GUID *pguidNetworkType);


void __RPC_STUB IBDA_NetworkProvider_GetNetworkType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_PutTuningSpace_Proxy( 
    IBDA_NetworkProvider * This,
    /* [in] */ REFGUID guidTuningSpace);


void __RPC_STUB IBDA_NetworkProvider_PutTuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_GetTuningSpace_Proxy( 
    IBDA_NetworkProvider * This,
    /* [out][in] */ GUID *pguidTuingSpace);


void __RPC_STUB IBDA_NetworkProvider_GetTuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_RegisterDeviceFilter_Proxy( 
    IBDA_NetworkProvider * This,
    /* [in] */ IUnknown *pUnkFilterControl,
    /* [out][in] */ ULONG *ppvRegisitrationContext);


void __RPC_STUB IBDA_NetworkProvider_RegisterDeviceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NetworkProvider_UnRegisterDeviceFilter_Proxy( 
    IBDA_NetworkProvider * This,
    /* [in] */ ULONG pvRegistrationContext);


void __RPC_STUB IBDA_NetworkProvider_UnRegisterDeviceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_NetworkProvider_INTERFACE_DEFINED__ */


#ifndef __IBDA_EthernetFilter_INTERFACE_DEFINED__
#define __IBDA_EthernetFilter_INTERFACE_DEFINED__

/* interface IBDA_EthernetFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_EthernetFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71985F43-1CA1-11d3-9CC8-00C04F7971E0")
    IBDA_EthernetFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMulticastListSize( 
            /* [out][in] */ ULONG *pulcbAddresses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMulticastList( 
            /* [in] */ ULONG ulcbAddresses,
            /* [size_is][in] */ BYTE pAddressList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMulticastList( 
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE pAddressList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMulticastMode( 
            /* [in] */ ULONG ulModeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMulticastMode( 
            /* [out] */ ULONG *pulModeMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_EthernetFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_EthernetFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_EthernetFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_EthernetFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastListSize )( 
            IBDA_EthernetFilter * This,
            /* [out][in] */ ULONG *pulcbAddresses);
        
        HRESULT ( STDMETHODCALLTYPE *PutMulticastList )( 
            IBDA_EthernetFilter * This,
            /* [in] */ ULONG ulcbAddresses,
            /* [size_is][in] */ BYTE pAddressList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastList )( 
            IBDA_EthernetFilter * This,
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE pAddressList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *PutMulticastMode )( 
            IBDA_EthernetFilter * This,
            /* [in] */ ULONG ulModeMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastMode )( 
            IBDA_EthernetFilter * This,
            /* [out] */ ULONG *pulModeMask);
        
        END_INTERFACE
    } IBDA_EthernetFilterVtbl;

    interface IBDA_EthernetFilter
    {
        CONST_VTBL struct IBDA_EthernetFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_EthernetFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_EthernetFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_EthernetFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_EthernetFilter_GetMulticastListSize(This,pulcbAddresses)	\
    (This)->lpVtbl -> GetMulticastListSize(This,pulcbAddresses)

#define IBDA_EthernetFilter_PutMulticastList(This,ulcbAddresses,pAddressList)	\
    (This)->lpVtbl -> PutMulticastList(This,ulcbAddresses,pAddressList)

#define IBDA_EthernetFilter_GetMulticastList(This,pulcbAddresses,pAddressList)	\
    (This)->lpVtbl -> GetMulticastList(This,pulcbAddresses,pAddressList)

#define IBDA_EthernetFilter_PutMulticastMode(This,ulModeMask)	\
    (This)->lpVtbl -> PutMulticastMode(This,ulModeMask)

#define IBDA_EthernetFilter_GetMulticastMode(This,pulModeMask)	\
    (This)->lpVtbl -> GetMulticastMode(This,pulModeMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_EthernetFilter_GetMulticastListSize_Proxy( 
    IBDA_EthernetFilter * This,
    /* [out][in] */ ULONG *pulcbAddresses);


void __RPC_STUB IBDA_EthernetFilter_GetMulticastListSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_EthernetFilter_PutMulticastList_Proxy( 
    IBDA_EthernetFilter * This,
    /* [in] */ ULONG ulcbAddresses,
    /* [size_is][in] */ BYTE pAddressList[  ]);


void __RPC_STUB IBDA_EthernetFilter_PutMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_EthernetFilter_GetMulticastList_Proxy( 
    IBDA_EthernetFilter * This,
    /* [out][in] */ ULONG *pulcbAddresses,
    /* [size_is][out] */ BYTE pAddressList[  ]);


void __RPC_STUB IBDA_EthernetFilter_GetMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_EthernetFilter_PutMulticastMode_Proxy( 
    IBDA_EthernetFilter * This,
    /* [in] */ ULONG ulModeMask);


void __RPC_STUB IBDA_EthernetFilter_PutMulticastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_EthernetFilter_GetMulticastMode_Proxy( 
    IBDA_EthernetFilter * This,
    /* [out] */ ULONG *pulModeMask);


void __RPC_STUB IBDA_EthernetFilter_GetMulticastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_EthernetFilter_INTERFACE_DEFINED__ */


#ifndef __IBDA_IPV4Filter_INTERFACE_DEFINED__
#define __IBDA_IPV4Filter_INTERFACE_DEFINED__

/* interface IBDA_IPV4Filter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_IPV4Filter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71985F44-1CA1-11d3-9CC8-00C04F7971E0")
    IBDA_IPV4Filter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMulticastListSize( 
            /* [out][in] */ ULONG *pulcbAddresses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMulticastList( 
            /* [in] */ ULONG ulcbAddresses,
            /* [size_is][in] */ BYTE pAddressList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMulticastList( 
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE pAddressList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMulticastMode( 
            /* [in] */ ULONG ulModeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMulticastMode( 
            /* [out] */ ULONG *pulModeMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_IPV4FilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_IPV4Filter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_IPV4Filter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_IPV4Filter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastListSize )( 
            IBDA_IPV4Filter * This,
            /* [out][in] */ ULONG *pulcbAddresses);
        
        HRESULT ( STDMETHODCALLTYPE *PutMulticastList )( 
            IBDA_IPV4Filter * This,
            /* [in] */ ULONG ulcbAddresses,
            /* [size_is][in] */ BYTE pAddressList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastList )( 
            IBDA_IPV4Filter * This,
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE pAddressList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *PutMulticastMode )( 
            IBDA_IPV4Filter * This,
            /* [in] */ ULONG ulModeMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastMode )( 
            IBDA_IPV4Filter * This,
            /* [out] */ ULONG *pulModeMask);
        
        END_INTERFACE
    } IBDA_IPV4FilterVtbl;

    interface IBDA_IPV4Filter
    {
        CONST_VTBL struct IBDA_IPV4FilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_IPV4Filter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_IPV4Filter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_IPV4Filter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_IPV4Filter_GetMulticastListSize(This,pulcbAddresses)	\
    (This)->lpVtbl -> GetMulticastListSize(This,pulcbAddresses)

#define IBDA_IPV4Filter_PutMulticastList(This,ulcbAddresses,pAddressList)	\
    (This)->lpVtbl -> PutMulticastList(This,ulcbAddresses,pAddressList)

#define IBDA_IPV4Filter_GetMulticastList(This,pulcbAddresses,pAddressList)	\
    (This)->lpVtbl -> GetMulticastList(This,pulcbAddresses,pAddressList)

#define IBDA_IPV4Filter_PutMulticastMode(This,ulModeMask)	\
    (This)->lpVtbl -> PutMulticastMode(This,ulModeMask)

#define IBDA_IPV4Filter_GetMulticastMode(This,pulModeMask)	\
    (This)->lpVtbl -> GetMulticastMode(This,pulModeMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_IPV4Filter_GetMulticastListSize_Proxy( 
    IBDA_IPV4Filter * This,
    /* [out][in] */ ULONG *pulcbAddresses);


void __RPC_STUB IBDA_IPV4Filter_GetMulticastListSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV4Filter_PutMulticastList_Proxy( 
    IBDA_IPV4Filter * This,
    /* [in] */ ULONG ulcbAddresses,
    /* [size_is][in] */ BYTE pAddressList[  ]);


void __RPC_STUB IBDA_IPV4Filter_PutMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV4Filter_GetMulticastList_Proxy( 
    IBDA_IPV4Filter * This,
    /* [out][in] */ ULONG *pulcbAddresses,
    /* [size_is][out] */ BYTE pAddressList[  ]);


void __RPC_STUB IBDA_IPV4Filter_GetMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV4Filter_PutMulticastMode_Proxy( 
    IBDA_IPV4Filter * This,
    /* [in] */ ULONG ulModeMask);


void __RPC_STUB IBDA_IPV4Filter_PutMulticastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV4Filter_GetMulticastMode_Proxy( 
    IBDA_IPV4Filter * This,
    /* [out] */ ULONG *pulModeMask);


void __RPC_STUB IBDA_IPV4Filter_GetMulticastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_IPV4Filter_INTERFACE_DEFINED__ */


#ifndef __IBDA_IPV6Filter_INTERFACE_DEFINED__
#define __IBDA_IPV6Filter_INTERFACE_DEFINED__

/* interface IBDA_IPV6Filter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_IPV6Filter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1785A74-2A23-4fb3-9245-A8F88017EF33")
    IBDA_IPV6Filter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMulticastListSize( 
            /* [out][in] */ ULONG *pulcbAddresses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMulticastList( 
            /* [in] */ ULONG ulcbAddresses,
            /* [size_is][in] */ BYTE pAddressList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMulticastList( 
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE pAddressList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMulticastMode( 
            /* [in] */ ULONG ulModeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMulticastMode( 
            /* [out] */ ULONG *pulModeMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_IPV6FilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_IPV6Filter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_IPV6Filter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_IPV6Filter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastListSize )( 
            IBDA_IPV6Filter * This,
            /* [out][in] */ ULONG *pulcbAddresses);
        
        HRESULT ( STDMETHODCALLTYPE *PutMulticastList )( 
            IBDA_IPV6Filter * This,
            /* [in] */ ULONG ulcbAddresses,
            /* [size_is][in] */ BYTE pAddressList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastList )( 
            IBDA_IPV6Filter * This,
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE pAddressList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *PutMulticastMode )( 
            IBDA_IPV6Filter * This,
            /* [in] */ ULONG ulModeMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastMode )( 
            IBDA_IPV6Filter * This,
            /* [out] */ ULONG *pulModeMask);
        
        END_INTERFACE
    } IBDA_IPV6FilterVtbl;

    interface IBDA_IPV6Filter
    {
        CONST_VTBL struct IBDA_IPV6FilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_IPV6Filter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_IPV6Filter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_IPV6Filter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_IPV6Filter_GetMulticastListSize(This,pulcbAddresses)	\
    (This)->lpVtbl -> GetMulticastListSize(This,pulcbAddresses)

#define IBDA_IPV6Filter_PutMulticastList(This,ulcbAddresses,pAddressList)	\
    (This)->lpVtbl -> PutMulticastList(This,ulcbAddresses,pAddressList)

#define IBDA_IPV6Filter_GetMulticastList(This,pulcbAddresses,pAddressList)	\
    (This)->lpVtbl -> GetMulticastList(This,pulcbAddresses,pAddressList)

#define IBDA_IPV6Filter_PutMulticastMode(This,ulModeMask)	\
    (This)->lpVtbl -> PutMulticastMode(This,ulModeMask)

#define IBDA_IPV6Filter_GetMulticastMode(This,pulModeMask)	\
    (This)->lpVtbl -> GetMulticastMode(This,pulModeMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_IPV6Filter_GetMulticastListSize_Proxy( 
    IBDA_IPV6Filter * This,
    /* [out][in] */ ULONG *pulcbAddresses);


void __RPC_STUB IBDA_IPV6Filter_GetMulticastListSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV6Filter_PutMulticastList_Proxy( 
    IBDA_IPV6Filter * This,
    /* [in] */ ULONG ulcbAddresses,
    /* [size_is][in] */ BYTE pAddressList[  ]);


void __RPC_STUB IBDA_IPV6Filter_PutMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV6Filter_GetMulticastList_Proxy( 
    IBDA_IPV6Filter * This,
    /* [out][in] */ ULONG *pulcbAddresses,
    /* [size_is][out] */ BYTE pAddressList[  ]);


void __RPC_STUB IBDA_IPV6Filter_GetMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV6Filter_PutMulticastMode_Proxy( 
    IBDA_IPV6Filter * This,
    /* [in] */ ULONG ulModeMask);


void __RPC_STUB IBDA_IPV6Filter_PutMulticastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPV6Filter_GetMulticastMode_Proxy( 
    IBDA_IPV6Filter * This,
    /* [out] */ ULONG *pulModeMask);


void __RPC_STUB IBDA_IPV6Filter_GetMulticastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_IPV6Filter_INTERFACE_DEFINED__ */


#ifndef __IBDA_DeviceControl_INTERFACE_DEFINED__
#define __IBDA_DeviceControl_INTERFACE_DEFINED__

/* interface IBDA_DeviceControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_DeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD0A5AF3-B41D-11d2-9C95-00C04F7971E0")
    IBDA_DeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeState( 
            /* [out][in] */ ULONG *pState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_DeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_DeviceControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_DeviceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_DeviceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartChanges )( 
            IBDA_DeviceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *CheckChanges )( 
            IBDA_DeviceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            IBDA_DeviceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeState )( 
            IBDA_DeviceControl * This,
            /* [out][in] */ ULONG *pState);
        
        END_INTERFACE
    } IBDA_DeviceControlVtbl;

    interface IBDA_DeviceControl
    {
        CONST_VTBL struct IBDA_DeviceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_DeviceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_DeviceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_DeviceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_DeviceControl_StartChanges(This)	\
    (This)->lpVtbl -> StartChanges(This)

#define IBDA_DeviceControl_CheckChanges(This)	\
    (This)->lpVtbl -> CheckChanges(This)

#define IBDA_DeviceControl_CommitChanges(This)	\
    (This)->lpVtbl -> CommitChanges(This)

#define IBDA_DeviceControl_GetChangeState(This,pState)	\
    (This)->lpVtbl -> GetChangeState(This,pState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_DeviceControl_StartChanges_Proxy( 
    IBDA_DeviceControl * This);


void __RPC_STUB IBDA_DeviceControl_StartChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DeviceControl_CheckChanges_Proxy( 
    IBDA_DeviceControl * This);


void __RPC_STUB IBDA_DeviceControl_CheckChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DeviceControl_CommitChanges_Proxy( 
    IBDA_DeviceControl * This);


void __RPC_STUB IBDA_DeviceControl_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DeviceControl_GetChangeState_Proxy( 
    IBDA_DeviceControl * This,
    /* [out][in] */ ULONG *pState);


void __RPC_STUB IBDA_DeviceControl_GetChangeState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_DeviceControl_INTERFACE_DEFINED__ */


#ifndef __IBDA_PinControl_INTERFACE_DEFINED__
#define __IBDA_PinControl_INTERFACE_DEFINED__

/* interface IBDA_PinControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_PinControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DED49D5-A8B7-4d5d-97A1-12B0C195874D")
    IBDA_PinControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPinID( 
            /* [out][in] */ ULONG *pulPinID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPinType( 
            /* [out][in] */ ULONG *pulPinType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegistrationContext( 
            /* [out][in] */ ULONG *pulRegistrationCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_PinControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_PinControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_PinControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_PinControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPinID )( 
            IBDA_PinControl * This,
            /* [out][in] */ ULONG *pulPinID);
        
        HRESULT ( STDMETHODCALLTYPE *GetPinType )( 
            IBDA_PinControl * This,
            /* [out][in] */ ULONG *pulPinType);
        
        HRESULT ( STDMETHODCALLTYPE *RegistrationContext )( 
            IBDA_PinControl * This,
            /* [out][in] */ ULONG *pulRegistrationCtx);
        
        END_INTERFACE
    } IBDA_PinControlVtbl;

    interface IBDA_PinControl
    {
        CONST_VTBL struct IBDA_PinControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_PinControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_PinControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_PinControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_PinControl_GetPinID(This,pulPinID)	\
    (This)->lpVtbl -> GetPinID(This,pulPinID)

#define IBDA_PinControl_GetPinType(This,pulPinType)	\
    (This)->lpVtbl -> GetPinType(This,pulPinType)

#define IBDA_PinControl_RegistrationContext(This,pulRegistrationCtx)	\
    (This)->lpVtbl -> RegistrationContext(This,pulRegistrationCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_PinControl_GetPinID_Proxy( 
    IBDA_PinControl * This,
    /* [out][in] */ ULONG *pulPinID);


void __RPC_STUB IBDA_PinControl_GetPinID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_PinControl_GetPinType_Proxy( 
    IBDA_PinControl * This,
    /* [out][in] */ ULONG *pulPinType);


void __RPC_STUB IBDA_PinControl_GetPinType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_PinControl_RegistrationContext_Proxy( 
    IBDA_PinControl * This,
    /* [out][in] */ ULONG *pulRegistrationCtx);


void __RPC_STUB IBDA_PinControl_RegistrationContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_PinControl_INTERFACE_DEFINED__ */


#ifndef __IBDA_SignalProperties_INTERFACE_DEFINED__
#define __IBDA_SignalProperties_INTERFACE_DEFINED__

/* interface IBDA_SignalProperties */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_SignalProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2F1644B-B409-11d2-BC69-00A0C9EE9E16")
    IBDA_SignalProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutNetworkType( 
            /* [in] */ REFGUID guidNetworkType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkType( 
            /* [out][in] */ GUID *pguidNetworkType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutSignalSource( 
            /* [in] */ ULONG ulSignalSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignalSource( 
            /* [out][in] */ ULONG *pulSignalSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutTuningSpace( 
            /* [in] */ REFGUID guidTuningSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTuningSpace( 
            /* [out][in] */ GUID *pguidTuingSpace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_SignalPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_SignalProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_SignalProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_SignalProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutNetworkType )( 
            IBDA_SignalProperties * This,
            /* [in] */ REFGUID guidNetworkType);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkType )( 
            IBDA_SignalProperties * This,
            /* [out][in] */ GUID *pguidNetworkType);
        
        HRESULT ( STDMETHODCALLTYPE *PutSignalSource )( 
            IBDA_SignalProperties * This,
            /* [in] */ ULONG ulSignalSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignalSource )( 
            IBDA_SignalProperties * This,
            /* [out][in] */ ULONG *pulSignalSource);
        
        HRESULT ( STDMETHODCALLTYPE *PutTuningSpace )( 
            IBDA_SignalProperties * This,
            /* [in] */ REFGUID guidTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *GetTuningSpace )( 
            IBDA_SignalProperties * This,
            /* [out][in] */ GUID *pguidTuingSpace);
        
        END_INTERFACE
    } IBDA_SignalPropertiesVtbl;

    interface IBDA_SignalProperties
    {
        CONST_VTBL struct IBDA_SignalPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_SignalProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_SignalProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_SignalProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_SignalProperties_PutNetworkType(This,guidNetworkType)	\
    (This)->lpVtbl -> PutNetworkType(This,guidNetworkType)

#define IBDA_SignalProperties_GetNetworkType(This,pguidNetworkType)	\
    (This)->lpVtbl -> GetNetworkType(This,pguidNetworkType)

#define IBDA_SignalProperties_PutSignalSource(This,ulSignalSource)	\
    (This)->lpVtbl -> PutSignalSource(This,ulSignalSource)

#define IBDA_SignalProperties_GetSignalSource(This,pulSignalSource)	\
    (This)->lpVtbl -> GetSignalSource(This,pulSignalSource)

#define IBDA_SignalProperties_PutTuningSpace(This,guidTuningSpace)	\
    (This)->lpVtbl -> PutTuningSpace(This,guidTuningSpace)

#define IBDA_SignalProperties_GetTuningSpace(This,pguidTuingSpace)	\
    (This)->lpVtbl -> GetTuningSpace(This,pguidTuingSpace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_SignalProperties_PutNetworkType_Proxy( 
    IBDA_SignalProperties * This,
    /* [in] */ REFGUID guidNetworkType);


void __RPC_STUB IBDA_SignalProperties_PutNetworkType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalProperties_GetNetworkType_Proxy( 
    IBDA_SignalProperties * This,
    /* [out][in] */ GUID *pguidNetworkType);


void __RPC_STUB IBDA_SignalProperties_GetNetworkType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalProperties_PutSignalSource_Proxy( 
    IBDA_SignalProperties * This,
    /* [in] */ ULONG ulSignalSource);


void __RPC_STUB IBDA_SignalProperties_PutSignalSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalProperties_GetSignalSource_Proxy( 
    IBDA_SignalProperties * This,
    /* [out][in] */ ULONG *pulSignalSource);


void __RPC_STUB IBDA_SignalProperties_GetSignalSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalProperties_PutTuningSpace_Proxy( 
    IBDA_SignalProperties * This,
    /* [in] */ REFGUID guidTuningSpace);


void __RPC_STUB IBDA_SignalProperties_PutTuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalProperties_GetTuningSpace_Proxy( 
    IBDA_SignalProperties * This,
    /* [out][in] */ GUID *pguidTuingSpace);


void __RPC_STUB IBDA_SignalProperties_GetTuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_SignalProperties_INTERFACE_DEFINED__ */


#ifndef __IBDA_SignalStatistics_INTERFACE_DEFINED__
#define __IBDA_SignalStatistics_INTERFACE_DEFINED__

/* interface IBDA_SignalStatistics */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_SignalStatistics;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1347D106-CF3A-428a-A5CB-AC0D9A2A4338")
    IBDA_SignalStatistics : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_SignalStrength( 
            /* [in] */ LONG lDbStrength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SignalStrength( 
            /* [out][in] */ LONG *plDbStrength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SignalQuality( 
            /* [in] */ LONG lPercentQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SignalQuality( 
            /* [out][in] */ LONG *plPercentQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SignalPresent( 
            /* [in] */ BOOLEAN fPresent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SignalPresent( 
            /* [out][in] */ BOOLEAN *pfPresent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SignalLocked( 
            /* [in] */ BOOLEAN fLocked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SignalLocked( 
            /* [out][in] */ BOOLEAN *pfLocked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SampleTime( 
            /* [in] */ LONG lmsSampleTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SampleTime( 
            /* [out][in] */ LONG *plmsSampleTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_SignalStatisticsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_SignalStatistics * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_SignalStatistics * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_SignalStatistics * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_SignalStrength )( 
            IBDA_SignalStatistics * This,
            /* [in] */ LONG lDbStrength);
        
        HRESULT ( STDMETHODCALLTYPE *get_SignalStrength )( 
            IBDA_SignalStatistics * This,
            /* [out][in] */ LONG *plDbStrength);
        
        HRESULT ( STDMETHODCALLTYPE *put_SignalQuality )( 
            IBDA_SignalStatistics * This,
            /* [in] */ LONG lPercentQuality);
        
        HRESULT ( STDMETHODCALLTYPE *get_SignalQuality )( 
            IBDA_SignalStatistics * This,
            /* [out][in] */ LONG *plPercentQuality);
        
        HRESULT ( STDMETHODCALLTYPE *put_SignalPresent )( 
            IBDA_SignalStatistics * This,
            /* [in] */ BOOLEAN fPresent);
        
        HRESULT ( STDMETHODCALLTYPE *get_SignalPresent )( 
            IBDA_SignalStatistics * This,
            /* [out][in] */ BOOLEAN *pfPresent);
        
        HRESULT ( STDMETHODCALLTYPE *put_SignalLocked )( 
            IBDA_SignalStatistics * This,
            /* [in] */ BOOLEAN fLocked);
        
        HRESULT ( STDMETHODCALLTYPE *get_SignalLocked )( 
            IBDA_SignalStatistics * This,
            /* [out][in] */ BOOLEAN *pfLocked);
        
        HRESULT ( STDMETHODCALLTYPE *put_SampleTime )( 
            IBDA_SignalStatistics * This,
            /* [in] */ LONG lmsSampleTime);
        
        HRESULT ( STDMETHODCALLTYPE *get_SampleTime )( 
            IBDA_SignalStatistics * This,
            /* [out][in] */ LONG *plmsSampleTime);
        
        END_INTERFACE
    } IBDA_SignalStatisticsVtbl;

    interface IBDA_SignalStatistics
    {
        CONST_VTBL struct IBDA_SignalStatisticsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_SignalStatistics_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_SignalStatistics_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_SignalStatistics_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_SignalStatistics_put_SignalStrength(This,lDbStrength)	\
    (This)->lpVtbl -> put_SignalStrength(This,lDbStrength)

#define IBDA_SignalStatistics_get_SignalStrength(This,plDbStrength)	\
    (This)->lpVtbl -> get_SignalStrength(This,plDbStrength)

#define IBDA_SignalStatistics_put_SignalQuality(This,lPercentQuality)	\
    (This)->lpVtbl -> put_SignalQuality(This,lPercentQuality)

#define IBDA_SignalStatistics_get_SignalQuality(This,plPercentQuality)	\
    (This)->lpVtbl -> get_SignalQuality(This,plPercentQuality)

#define IBDA_SignalStatistics_put_SignalPresent(This,fPresent)	\
    (This)->lpVtbl -> put_SignalPresent(This,fPresent)

#define IBDA_SignalStatistics_get_SignalPresent(This,pfPresent)	\
    (This)->lpVtbl -> get_SignalPresent(This,pfPresent)

#define IBDA_SignalStatistics_put_SignalLocked(This,fLocked)	\
    (This)->lpVtbl -> put_SignalLocked(This,fLocked)

#define IBDA_SignalStatistics_get_SignalLocked(This,pfLocked)	\
    (This)->lpVtbl -> get_SignalLocked(This,pfLocked)

#define IBDA_SignalStatistics_put_SampleTime(This,lmsSampleTime)	\
    (This)->lpVtbl -> put_SampleTime(This,lmsSampleTime)

#define IBDA_SignalStatistics_get_SampleTime(This,plmsSampleTime)	\
    (This)->lpVtbl -> get_SampleTime(This,plmsSampleTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_put_SignalStrength_Proxy( 
    IBDA_SignalStatistics * This,
    /* [in] */ LONG lDbStrength);


void __RPC_STUB IBDA_SignalStatistics_put_SignalStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_get_SignalStrength_Proxy( 
    IBDA_SignalStatistics * This,
    /* [out][in] */ LONG *plDbStrength);


void __RPC_STUB IBDA_SignalStatistics_get_SignalStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_put_SignalQuality_Proxy( 
    IBDA_SignalStatistics * This,
    /* [in] */ LONG lPercentQuality);


void __RPC_STUB IBDA_SignalStatistics_put_SignalQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_get_SignalQuality_Proxy( 
    IBDA_SignalStatistics * This,
    /* [out][in] */ LONG *plPercentQuality);


void __RPC_STUB IBDA_SignalStatistics_get_SignalQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_put_SignalPresent_Proxy( 
    IBDA_SignalStatistics * This,
    /* [in] */ BOOLEAN fPresent);


void __RPC_STUB IBDA_SignalStatistics_put_SignalPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_get_SignalPresent_Proxy( 
    IBDA_SignalStatistics * This,
    /* [out][in] */ BOOLEAN *pfPresent);


void __RPC_STUB IBDA_SignalStatistics_get_SignalPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_put_SignalLocked_Proxy( 
    IBDA_SignalStatistics * This,
    /* [in] */ BOOLEAN fLocked);


void __RPC_STUB IBDA_SignalStatistics_put_SignalLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_get_SignalLocked_Proxy( 
    IBDA_SignalStatistics * This,
    /* [out][in] */ BOOLEAN *pfLocked);


void __RPC_STUB IBDA_SignalStatistics_get_SignalLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_put_SampleTime_Proxy( 
    IBDA_SignalStatistics * This,
    /* [in] */ LONG lmsSampleTime);


void __RPC_STUB IBDA_SignalStatistics_put_SampleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_SignalStatistics_get_SampleTime_Proxy( 
    IBDA_SignalStatistics * This,
    /* [out][in] */ LONG *plmsSampleTime);


void __RPC_STUB IBDA_SignalStatistics_get_SampleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_SignalStatistics_INTERFACE_DEFINED__ */


#ifndef __IBDA_Topology_INTERFACE_DEFINED__
#define __IBDA_Topology_INTERFACE_DEFINED__

/* interface IBDA_Topology */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_Topology;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79B56888-7FEA-4690-B45D-38FD3C7849BE")
    IBDA_Topology : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNodeTypes( 
            /* [out][in] */ ULONG *pulcNodeTypes,
            /* [in] */ ULONG ulcNodeTypesMax,
            /* [size_is][out][in] */ ULONG rgulNodeTypes[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeDescriptors( 
            /* [out][in] */ ULONG *ulcNodeDescriptors,
            /* [in] */ ULONG ulcNodeDescriptorsMax,
            /* [size_is][out][in] */ BDANODE_DESCRIPTOR rgNodeDescriptors[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeInterfaces( 
            /* [in] */ ULONG ulNodeType,
            /* [out][in] */ ULONG *pulcInterfaces,
            /* [in] */ ULONG ulcInterfacesMax,
            /* [size_is][out][in] */ GUID rgguidInterfaces[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPinTypes( 
            /* [out][in] */ ULONG *pulcPinTypes,
            /* [in] */ ULONG ulcPinTypesMax,
            /* [size_is][out][in] */ ULONG rgulPinTypes[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTemplateConnections( 
            /* [out][in] */ ULONG *pulcConnections,
            /* [in] */ ULONG ulcConnectionsMax,
            /* [size_is][out][in] */ BDA_TEMPLATE_CONNECTION rgConnections[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePin( 
            /* [in] */ ULONG ulPinType,
            /* [out][in] */ ULONG *pulPinId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePin( 
            /* [in] */ ULONG ulPinId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ ULONG ulPinId,
            /* [in] */ AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMedium( 
            /* [in] */ ULONG ulPinId,
            /* [in] */ REGPINMEDIUM *pMedium) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTopology( 
            /* [in] */ ULONG ulInputPinId,
            /* [in] */ ULONG ulOutputPinId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlNode( 
            /* [in] */ ULONG ulInputPinId,
            /* [in] */ ULONG ulOutputPinId,
            /* [in] */ ULONG ulNodeType,
            /* [out][in] */ IUnknown **ppControlNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_TopologyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_Topology * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_Topology * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_Topology * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeTypes )( 
            IBDA_Topology * This,
            /* [out][in] */ ULONG *pulcNodeTypes,
            /* [in] */ ULONG ulcNodeTypesMax,
            /* [size_is][out][in] */ ULONG rgulNodeTypes[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeDescriptors )( 
            IBDA_Topology * This,
            /* [out][in] */ ULONG *ulcNodeDescriptors,
            /* [in] */ ULONG ulcNodeDescriptorsMax,
            /* [size_is][out][in] */ BDANODE_DESCRIPTOR rgNodeDescriptors[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeInterfaces )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulNodeType,
            /* [out][in] */ ULONG *pulcInterfaces,
            /* [in] */ ULONG ulcInterfacesMax,
            /* [size_is][out][in] */ GUID rgguidInterfaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetPinTypes )( 
            IBDA_Topology * This,
            /* [out][in] */ ULONG *pulcPinTypes,
            /* [in] */ ULONG ulcPinTypesMax,
            /* [size_is][out][in] */ ULONG rgulPinTypes[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetTemplateConnections )( 
            IBDA_Topology * This,
            /* [out][in] */ ULONG *pulcConnections,
            /* [in] */ ULONG ulcConnectionsMax,
            /* [size_is][out][in] */ BDA_TEMPLATE_CONNECTION rgConnections[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePin )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulPinType,
            /* [out][in] */ ULONG *pulPinId);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePin )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulPinId);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulPinId,
            /* [in] */ AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMedium )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulPinId,
            /* [in] */ REGPINMEDIUM *pMedium);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTopology )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulInputPinId,
            /* [in] */ ULONG ulOutputPinId);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlNode )( 
            IBDA_Topology * This,
            /* [in] */ ULONG ulInputPinId,
            /* [in] */ ULONG ulOutputPinId,
            /* [in] */ ULONG ulNodeType,
            /* [out][in] */ IUnknown **ppControlNode);
        
        END_INTERFACE
    } IBDA_TopologyVtbl;

    interface IBDA_Topology
    {
        CONST_VTBL struct IBDA_TopologyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_Topology_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_Topology_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_Topology_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_Topology_GetNodeTypes(This,pulcNodeTypes,ulcNodeTypesMax,rgulNodeTypes)	\
    (This)->lpVtbl -> GetNodeTypes(This,pulcNodeTypes,ulcNodeTypesMax,rgulNodeTypes)

#define IBDA_Topology_GetNodeDescriptors(This,ulcNodeDescriptors,ulcNodeDescriptorsMax,rgNodeDescriptors)	\
    (This)->lpVtbl -> GetNodeDescriptors(This,ulcNodeDescriptors,ulcNodeDescriptorsMax,rgNodeDescriptors)

#define IBDA_Topology_GetNodeInterfaces(This,ulNodeType,pulcInterfaces,ulcInterfacesMax,rgguidInterfaces)	\
    (This)->lpVtbl -> GetNodeInterfaces(This,ulNodeType,pulcInterfaces,ulcInterfacesMax,rgguidInterfaces)

#define IBDA_Topology_GetPinTypes(This,pulcPinTypes,ulcPinTypesMax,rgulPinTypes)	\
    (This)->lpVtbl -> GetPinTypes(This,pulcPinTypes,ulcPinTypesMax,rgulPinTypes)

#define IBDA_Topology_GetTemplateConnections(This,pulcConnections,ulcConnectionsMax,rgConnections)	\
    (This)->lpVtbl -> GetTemplateConnections(This,pulcConnections,ulcConnectionsMax,rgConnections)

#define IBDA_Topology_CreatePin(This,ulPinType,pulPinId)	\
    (This)->lpVtbl -> CreatePin(This,ulPinType,pulPinId)

#define IBDA_Topology_DeletePin(This,ulPinId)	\
    (This)->lpVtbl -> DeletePin(This,ulPinId)

#define IBDA_Topology_SetMediaType(This,ulPinId,pMediaType)	\
    (This)->lpVtbl -> SetMediaType(This,ulPinId,pMediaType)

#define IBDA_Topology_SetMedium(This,ulPinId,pMedium)	\
    (This)->lpVtbl -> SetMedium(This,ulPinId,pMedium)

#define IBDA_Topology_CreateTopology(This,ulInputPinId,ulOutputPinId)	\
    (This)->lpVtbl -> CreateTopology(This,ulInputPinId,ulOutputPinId)

#define IBDA_Topology_GetControlNode(This,ulInputPinId,ulOutputPinId,ulNodeType,ppControlNode)	\
    (This)->lpVtbl -> GetControlNode(This,ulInputPinId,ulOutputPinId,ulNodeType,ppControlNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_Topology_GetNodeTypes_Proxy( 
    IBDA_Topology * This,
    /* [out][in] */ ULONG *pulcNodeTypes,
    /* [in] */ ULONG ulcNodeTypesMax,
    /* [size_is][out][in] */ ULONG rgulNodeTypes[  ]);


void __RPC_STUB IBDA_Topology_GetNodeTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_GetNodeDescriptors_Proxy( 
    IBDA_Topology * This,
    /* [out][in] */ ULONG *ulcNodeDescriptors,
    /* [in] */ ULONG ulcNodeDescriptorsMax,
    /* [size_is][out][in] */ BDANODE_DESCRIPTOR rgNodeDescriptors[  ]);


void __RPC_STUB IBDA_Topology_GetNodeDescriptors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_GetNodeInterfaces_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulNodeType,
    /* [out][in] */ ULONG *pulcInterfaces,
    /* [in] */ ULONG ulcInterfacesMax,
    /* [size_is][out][in] */ GUID rgguidInterfaces[  ]);


void __RPC_STUB IBDA_Topology_GetNodeInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_GetPinTypes_Proxy( 
    IBDA_Topology * This,
    /* [out][in] */ ULONG *pulcPinTypes,
    /* [in] */ ULONG ulcPinTypesMax,
    /* [size_is][out][in] */ ULONG rgulPinTypes[  ]);


void __RPC_STUB IBDA_Topology_GetPinTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_GetTemplateConnections_Proxy( 
    IBDA_Topology * This,
    /* [out][in] */ ULONG *pulcConnections,
    /* [in] */ ULONG ulcConnectionsMax,
    /* [size_is][out][in] */ BDA_TEMPLATE_CONNECTION rgConnections[  ]);


void __RPC_STUB IBDA_Topology_GetTemplateConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_CreatePin_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulPinType,
    /* [out][in] */ ULONG *pulPinId);


void __RPC_STUB IBDA_Topology_CreatePin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_DeletePin_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulPinId);


void __RPC_STUB IBDA_Topology_DeletePin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_SetMediaType_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulPinId,
    /* [in] */ AM_MEDIA_TYPE *pMediaType);


void __RPC_STUB IBDA_Topology_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_SetMedium_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulPinId,
    /* [in] */ REGPINMEDIUM *pMedium);


void __RPC_STUB IBDA_Topology_SetMedium_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_CreateTopology_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulInputPinId,
    /* [in] */ ULONG ulOutputPinId);


void __RPC_STUB IBDA_Topology_CreateTopology_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_Topology_GetControlNode_Proxy( 
    IBDA_Topology * This,
    /* [in] */ ULONG ulInputPinId,
    /* [in] */ ULONG ulOutputPinId,
    /* [in] */ ULONG ulNodeType,
    /* [out][in] */ IUnknown **ppControlNode);


void __RPC_STUB IBDA_Topology_GetControlNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_Topology_INTERFACE_DEFINED__ */


#ifndef __IBDA_VoidTransform_INTERFACE_DEFINED__
#define __IBDA_VoidTransform_INTERFACE_DEFINED__

/* interface IBDA_VoidTransform */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_VoidTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71985F46-1CA1-11d3-9CC8-00C04F7971E0")
    IBDA_VoidTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_VoidTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_VoidTransform * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_VoidTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_VoidTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IBDA_VoidTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IBDA_VoidTransform * This);
        
        END_INTERFACE
    } IBDA_VoidTransformVtbl;

    interface IBDA_VoidTransform
    {
        CONST_VTBL struct IBDA_VoidTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_VoidTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_VoidTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_VoidTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_VoidTransform_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IBDA_VoidTransform_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_VoidTransform_Start_Proxy( 
    IBDA_VoidTransform * This);


void __RPC_STUB IBDA_VoidTransform_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_VoidTransform_Stop_Proxy( 
    IBDA_VoidTransform * This);


void __RPC_STUB IBDA_VoidTransform_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_VoidTransform_INTERFACE_DEFINED__ */


#ifndef __IBDA_NullTransform_INTERFACE_DEFINED__
#define __IBDA_NullTransform_INTERFACE_DEFINED__

/* interface IBDA_NullTransform */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_NullTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDF15B0D-BD25-11d2-9CA0-00C04F7971E0")
    IBDA_NullTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_NullTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_NullTransform * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_NullTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_NullTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IBDA_NullTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IBDA_NullTransform * This);
        
        END_INTERFACE
    } IBDA_NullTransformVtbl;

    interface IBDA_NullTransform
    {
        CONST_VTBL struct IBDA_NullTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_NullTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_NullTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_NullTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_NullTransform_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IBDA_NullTransform_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_NullTransform_Start_Proxy( 
    IBDA_NullTransform * This);


void __RPC_STUB IBDA_NullTransform_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_NullTransform_Stop_Proxy( 
    IBDA_NullTransform * This);


void __RPC_STUB IBDA_NullTransform_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_NullTransform_INTERFACE_DEFINED__ */


#ifndef __IBDA_FrequencyFilter_INTERFACE_DEFINED__
#define __IBDA_FrequencyFilter_INTERFACE_DEFINED__

/* interface IBDA_FrequencyFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_FrequencyFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71985F47-1CA1-11d3-9CC8-00C04F7971E0")
    IBDA_FrequencyFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_Autotune( 
            /* [in] */ ULONG ulTransponder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Autotune( 
            /* [out][in] */ ULONG *pulTransponder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Frequency( 
            /* [in] */ ULONG ulFrequency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Frequency( 
            /* [out][in] */ ULONG *pulFrequency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Polarity( 
            /* [in] */ Polarisation Polarity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Polarity( 
            /* [out][in] */ Polarisation *pPolarity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Range( 
            /* [in] */ ULONG ulRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Range( 
            /* [out][in] */ ULONG *pulRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Bandwidth( 
            /* [in] */ ULONG ulBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [out][in] */ ULONG *pulBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_FrequencyMultiplier( 
            /* [in] */ ULONG ulMultiplier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_FrequencyMultiplier( 
            /* [out][in] */ ULONG *pulMultiplier) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_FrequencyFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_FrequencyFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_FrequencyFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Autotune )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ ULONG ulTransponder);
        
        HRESULT ( STDMETHODCALLTYPE *get_Autotune )( 
            IBDA_FrequencyFilter * This,
            /* [out][in] */ ULONG *pulTransponder);
        
        HRESULT ( STDMETHODCALLTYPE *put_Frequency )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ ULONG ulFrequency);
        
        HRESULT ( STDMETHODCALLTYPE *get_Frequency )( 
            IBDA_FrequencyFilter * This,
            /* [out][in] */ ULONG *pulFrequency);
        
        HRESULT ( STDMETHODCALLTYPE *put_Polarity )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ Polarisation Polarity);
        
        HRESULT ( STDMETHODCALLTYPE *get_Polarity )( 
            IBDA_FrequencyFilter * This,
            /* [out][in] */ Polarisation *pPolarity);
        
        HRESULT ( STDMETHODCALLTYPE *put_Range )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ ULONG ulRange);
        
        HRESULT ( STDMETHODCALLTYPE *get_Range )( 
            IBDA_FrequencyFilter * This,
            /* [out][in] */ ULONG *pulRange);
        
        HRESULT ( STDMETHODCALLTYPE *put_Bandwidth )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ ULONG ulBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            IBDA_FrequencyFilter * This,
            /* [out][in] */ ULONG *pulBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *put_FrequencyMultiplier )( 
            IBDA_FrequencyFilter * This,
            /* [in] */ ULONG ulMultiplier);
        
        HRESULT ( STDMETHODCALLTYPE *get_FrequencyMultiplier )( 
            IBDA_FrequencyFilter * This,
            /* [out][in] */ ULONG *pulMultiplier);
        
        END_INTERFACE
    } IBDA_FrequencyFilterVtbl;

    interface IBDA_FrequencyFilter
    {
        CONST_VTBL struct IBDA_FrequencyFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_FrequencyFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_FrequencyFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_FrequencyFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_FrequencyFilter_put_Autotune(This,ulTransponder)	\
    (This)->lpVtbl -> put_Autotune(This,ulTransponder)

#define IBDA_FrequencyFilter_get_Autotune(This,pulTransponder)	\
    (This)->lpVtbl -> get_Autotune(This,pulTransponder)

#define IBDA_FrequencyFilter_put_Frequency(This,ulFrequency)	\
    (This)->lpVtbl -> put_Frequency(This,ulFrequency)

#define IBDA_FrequencyFilter_get_Frequency(This,pulFrequency)	\
    (This)->lpVtbl -> get_Frequency(This,pulFrequency)

#define IBDA_FrequencyFilter_put_Polarity(This,Polarity)	\
    (This)->lpVtbl -> put_Polarity(This,Polarity)

#define IBDA_FrequencyFilter_get_Polarity(This,pPolarity)	\
    (This)->lpVtbl -> get_Polarity(This,pPolarity)

#define IBDA_FrequencyFilter_put_Range(This,ulRange)	\
    (This)->lpVtbl -> put_Range(This,ulRange)

#define IBDA_FrequencyFilter_get_Range(This,pulRange)	\
    (This)->lpVtbl -> get_Range(This,pulRange)

#define IBDA_FrequencyFilter_put_Bandwidth(This,ulBandwidth)	\
    (This)->lpVtbl -> put_Bandwidth(This,ulBandwidth)

#define IBDA_FrequencyFilter_get_Bandwidth(This,pulBandwidth)	\
    (This)->lpVtbl -> get_Bandwidth(This,pulBandwidth)

#define IBDA_FrequencyFilter_put_FrequencyMultiplier(This,ulMultiplier)	\
    (This)->lpVtbl -> put_FrequencyMultiplier(This,ulMultiplier)

#define IBDA_FrequencyFilter_get_FrequencyMultiplier(This,pulMultiplier)	\
    (This)->lpVtbl -> get_FrequencyMultiplier(This,pulMultiplier)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_put_Autotune_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [in] */ ULONG ulTransponder);


void __RPC_STUB IBDA_FrequencyFilter_put_Autotune_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_get_Autotune_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [out][in] */ ULONG *pulTransponder);


void __RPC_STUB IBDA_FrequencyFilter_get_Autotune_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_put_Frequency_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [in] */ ULONG ulFrequency);


void __RPC_STUB IBDA_FrequencyFilter_put_Frequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_get_Frequency_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [out][in] */ ULONG *pulFrequency);


void __RPC_STUB IBDA_FrequencyFilter_get_Frequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_put_Polarity_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [in] */ Polarisation Polarity);


void __RPC_STUB IBDA_FrequencyFilter_put_Polarity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_get_Polarity_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [out][in] */ Polarisation *pPolarity);


void __RPC_STUB IBDA_FrequencyFilter_get_Polarity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_put_Range_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [in] */ ULONG ulRange);


void __RPC_STUB IBDA_FrequencyFilter_put_Range_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_get_Range_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [out][in] */ ULONG *pulRange);


void __RPC_STUB IBDA_FrequencyFilter_get_Range_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_put_Bandwidth_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [in] */ ULONG ulBandwidth);


void __RPC_STUB IBDA_FrequencyFilter_put_Bandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_get_Bandwidth_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [out][in] */ ULONG *pulBandwidth);


void __RPC_STUB IBDA_FrequencyFilter_get_Bandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_put_FrequencyMultiplier_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [in] */ ULONG ulMultiplier);


void __RPC_STUB IBDA_FrequencyFilter_put_FrequencyMultiplier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_FrequencyFilter_get_FrequencyMultiplier_Proxy( 
    IBDA_FrequencyFilter * This,
    /* [out][in] */ ULONG *pulMultiplier);


void __RPC_STUB IBDA_FrequencyFilter_get_FrequencyMultiplier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_FrequencyFilter_INTERFACE_DEFINED__ */


#ifndef __IBDA_LNBInfo_INTERFACE_DEFINED__
#define __IBDA_LNBInfo_INTERFACE_DEFINED__

/* interface IBDA_LNBInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_LNBInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("992CF102-49F9-4719-A664-C4F23E2408F4")
    IBDA_LNBInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_LocalOscilatorFrequencyLowBand( 
            /* [in] */ ULONG ulLOFLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LocalOscilatorFrequencyLowBand( 
            /* [out][in] */ ULONG *pulLOFLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LocalOscilatorFrequencyHighBand( 
            /* [in] */ ULONG ulLOFHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LocalOscilatorFrequencyHighBand( 
            /* [out][in] */ ULONG *pulLOFHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_HighLowSwitchFrequency( 
            /* [in] */ ULONG ulSwitchFrequency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_HighLowSwitchFrequency( 
            /* [out][in] */ ULONG *pulSwitchFrequency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_LNBInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_LNBInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_LNBInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_LNBInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_LocalOscilatorFrequencyLowBand )( 
            IBDA_LNBInfo * This,
            /* [in] */ ULONG ulLOFLow);
        
        HRESULT ( STDMETHODCALLTYPE *get_LocalOscilatorFrequencyLowBand )( 
            IBDA_LNBInfo * This,
            /* [out][in] */ ULONG *pulLOFLow);
        
        HRESULT ( STDMETHODCALLTYPE *put_LocalOscilatorFrequencyHighBand )( 
            IBDA_LNBInfo * This,
            /* [in] */ ULONG ulLOFHigh);
        
        HRESULT ( STDMETHODCALLTYPE *get_LocalOscilatorFrequencyHighBand )( 
            IBDA_LNBInfo * This,
            /* [out][in] */ ULONG *pulLOFHigh);
        
        HRESULT ( STDMETHODCALLTYPE *put_HighLowSwitchFrequency )( 
            IBDA_LNBInfo * This,
            /* [in] */ ULONG ulSwitchFrequency);
        
        HRESULT ( STDMETHODCALLTYPE *get_HighLowSwitchFrequency )( 
            IBDA_LNBInfo * This,
            /* [out][in] */ ULONG *pulSwitchFrequency);
        
        END_INTERFACE
    } IBDA_LNBInfoVtbl;

    interface IBDA_LNBInfo
    {
        CONST_VTBL struct IBDA_LNBInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_LNBInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_LNBInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_LNBInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_LNBInfo_put_LocalOscilatorFrequencyLowBand(This,ulLOFLow)	\
    (This)->lpVtbl -> put_LocalOscilatorFrequencyLowBand(This,ulLOFLow)

#define IBDA_LNBInfo_get_LocalOscilatorFrequencyLowBand(This,pulLOFLow)	\
    (This)->lpVtbl -> get_LocalOscilatorFrequencyLowBand(This,pulLOFLow)

#define IBDA_LNBInfo_put_LocalOscilatorFrequencyHighBand(This,ulLOFHigh)	\
    (This)->lpVtbl -> put_LocalOscilatorFrequencyHighBand(This,ulLOFHigh)

#define IBDA_LNBInfo_get_LocalOscilatorFrequencyHighBand(This,pulLOFHigh)	\
    (This)->lpVtbl -> get_LocalOscilatorFrequencyHighBand(This,pulLOFHigh)

#define IBDA_LNBInfo_put_HighLowSwitchFrequency(This,ulSwitchFrequency)	\
    (This)->lpVtbl -> put_HighLowSwitchFrequency(This,ulSwitchFrequency)

#define IBDA_LNBInfo_get_HighLowSwitchFrequency(This,pulSwitchFrequency)	\
    (This)->lpVtbl -> get_HighLowSwitchFrequency(This,pulSwitchFrequency)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_LNBInfo_put_LocalOscilatorFrequencyLowBand_Proxy( 
    IBDA_LNBInfo * This,
    /* [in] */ ULONG ulLOFLow);


void __RPC_STUB IBDA_LNBInfo_put_LocalOscilatorFrequencyLowBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_LNBInfo_get_LocalOscilatorFrequencyLowBand_Proxy( 
    IBDA_LNBInfo * This,
    /* [out][in] */ ULONG *pulLOFLow);


void __RPC_STUB IBDA_LNBInfo_get_LocalOscilatorFrequencyLowBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_LNBInfo_put_LocalOscilatorFrequencyHighBand_Proxy( 
    IBDA_LNBInfo * This,
    /* [in] */ ULONG ulLOFHigh);


void __RPC_STUB IBDA_LNBInfo_put_LocalOscilatorFrequencyHighBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_LNBInfo_get_LocalOscilatorFrequencyHighBand_Proxy( 
    IBDA_LNBInfo * This,
    /* [out][in] */ ULONG *pulLOFHigh);


void __RPC_STUB IBDA_LNBInfo_get_LocalOscilatorFrequencyHighBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_LNBInfo_put_HighLowSwitchFrequency_Proxy( 
    IBDA_LNBInfo * This,
    /* [in] */ ULONG ulSwitchFrequency);


void __RPC_STUB IBDA_LNBInfo_put_HighLowSwitchFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_LNBInfo_get_HighLowSwitchFrequency_Proxy( 
    IBDA_LNBInfo * This,
    /* [out][in] */ ULONG *pulSwitchFrequency);


void __RPC_STUB IBDA_LNBInfo_get_HighLowSwitchFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_LNBInfo_INTERFACE_DEFINED__ */


#ifndef __IBDA_AutoDemodulate_INTERFACE_DEFINED__
#define __IBDA_AutoDemodulate_INTERFACE_DEFINED__

/* interface IBDA_AutoDemodulate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_AutoDemodulate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDF15B12-BD25-11d2-9CA0-00C04F7971E0")
    IBDA_AutoDemodulate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_AutoDemodulate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_AutoDemodulateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_AutoDemodulate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_AutoDemodulate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_AutoDemodulate * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_AutoDemodulate )( 
            IBDA_AutoDemodulate * This);
        
        END_INTERFACE
    } IBDA_AutoDemodulateVtbl;

    interface IBDA_AutoDemodulate
    {
        CONST_VTBL struct IBDA_AutoDemodulateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_AutoDemodulate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_AutoDemodulate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_AutoDemodulate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_AutoDemodulate_put_AutoDemodulate(This)	\
    (This)->lpVtbl -> put_AutoDemodulate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_AutoDemodulate_put_AutoDemodulate_Proxy( 
    IBDA_AutoDemodulate * This);


void __RPC_STUB IBDA_AutoDemodulate_put_AutoDemodulate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_AutoDemodulate_INTERFACE_DEFINED__ */


#ifndef __IBDA_DigitalDemodulator_INTERFACE_DEFINED__
#define __IBDA_DigitalDemodulator_INTERFACE_DEFINED__

/* interface IBDA_DigitalDemodulator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_DigitalDemodulator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF30F379-985B-4d10-B640-A79D5E04E1E0")
    IBDA_DigitalDemodulator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_ModulationType( 
            /* [in] */ ModulationType *pModulationType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ModulationType( 
            /* [out][in] */ ModulationType *pModulationType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InnerFECMethod( 
            /* [in] */ FECMethod *pFECMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InnerFECMethod( 
            /* [out][in] */ FECMethod *pFECMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InnerFECRate( 
            /* [in] */ BinaryConvolutionCodeRate *pFECRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InnerFECRate( 
            /* [out][in] */ BinaryConvolutionCodeRate *pFECRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_OuterFECMethod( 
            /* [in] */ FECMethod *pFECMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_OuterFECMethod( 
            /* [out][in] */ FECMethod *pFECMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_OuterFECRate( 
            /* [in] */ BinaryConvolutionCodeRate *pFECRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_OuterFECRate( 
            /* [out][in] */ BinaryConvolutionCodeRate *pFECRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SymbolRate( 
            /* [in] */ ULONG *pSymbolRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SymbolRate( 
            /* [out][in] */ ULONG *pSymbolRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SpectralInversion( 
            /* [in] */ SpectralInversion *pSpectralInversion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SpectralInversion( 
            /* [out][in] */ SpectralInversion *pSpectralInversion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_DigitalDemodulatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_DigitalDemodulator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_DigitalDemodulator * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_ModulationType )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ ModulationType *pModulationType);
        
        HRESULT ( STDMETHODCALLTYPE *get_ModulationType )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ ModulationType *pModulationType);
        
        HRESULT ( STDMETHODCALLTYPE *put_InnerFECMethod )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ FECMethod *pFECMethod);
        
        HRESULT ( STDMETHODCALLTYPE *get_InnerFECMethod )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ FECMethod *pFECMethod);
        
        HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ BinaryConvolutionCodeRate *pFECRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ BinaryConvolutionCodeRate *pFECRate);
        
        HRESULT ( STDMETHODCALLTYPE *put_OuterFECMethod )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ FECMethod *pFECMethod);
        
        HRESULT ( STDMETHODCALLTYPE *get_OuterFECMethod )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ FECMethod *pFECMethod);
        
        HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ BinaryConvolutionCodeRate *pFECRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ BinaryConvolutionCodeRate *pFECRate);
        
        HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ ULONG *pSymbolRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ ULONG *pSymbolRate);
        
        HRESULT ( STDMETHODCALLTYPE *put_SpectralInversion )( 
            IBDA_DigitalDemodulator * This,
            /* [in] */ SpectralInversion *pSpectralInversion);
        
        HRESULT ( STDMETHODCALLTYPE *get_SpectralInversion )( 
            IBDA_DigitalDemodulator * This,
            /* [out][in] */ SpectralInversion *pSpectralInversion);
        
        END_INTERFACE
    } IBDA_DigitalDemodulatorVtbl;

    interface IBDA_DigitalDemodulator
    {
        CONST_VTBL struct IBDA_DigitalDemodulatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_DigitalDemodulator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_DigitalDemodulator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_DigitalDemodulator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_DigitalDemodulator_put_ModulationType(This,pModulationType)	\
    (This)->lpVtbl -> put_ModulationType(This,pModulationType)

#define IBDA_DigitalDemodulator_get_ModulationType(This,pModulationType)	\
    (This)->lpVtbl -> get_ModulationType(This,pModulationType)

#define IBDA_DigitalDemodulator_put_InnerFECMethod(This,pFECMethod)	\
    (This)->lpVtbl -> put_InnerFECMethod(This,pFECMethod)

#define IBDA_DigitalDemodulator_get_InnerFECMethod(This,pFECMethod)	\
    (This)->lpVtbl -> get_InnerFECMethod(This,pFECMethod)

#define IBDA_DigitalDemodulator_put_InnerFECRate(This,pFECRate)	\
    (This)->lpVtbl -> put_InnerFECRate(This,pFECRate)

#define IBDA_DigitalDemodulator_get_InnerFECRate(This,pFECRate)	\
    (This)->lpVtbl -> get_InnerFECRate(This,pFECRate)

#define IBDA_DigitalDemodulator_put_OuterFECMethod(This,pFECMethod)	\
    (This)->lpVtbl -> put_OuterFECMethod(This,pFECMethod)

#define IBDA_DigitalDemodulator_get_OuterFECMethod(This,pFECMethod)	\
    (This)->lpVtbl -> get_OuterFECMethod(This,pFECMethod)

#define IBDA_DigitalDemodulator_put_OuterFECRate(This,pFECRate)	\
    (This)->lpVtbl -> put_OuterFECRate(This,pFECRate)

#define IBDA_DigitalDemodulator_get_OuterFECRate(This,pFECRate)	\
    (This)->lpVtbl -> get_OuterFECRate(This,pFECRate)

#define IBDA_DigitalDemodulator_put_SymbolRate(This,pSymbolRate)	\
    (This)->lpVtbl -> put_SymbolRate(This,pSymbolRate)

#define IBDA_DigitalDemodulator_get_SymbolRate(This,pSymbolRate)	\
    (This)->lpVtbl -> get_SymbolRate(This,pSymbolRate)

#define IBDA_DigitalDemodulator_put_SpectralInversion(This,pSpectralInversion)	\
    (This)->lpVtbl -> put_SpectralInversion(This,pSpectralInversion)

#define IBDA_DigitalDemodulator_get_SpectralInversion(This,pSpectralInversion)	\
    (This)->lpVtbl -> get_SpectralInversion(This,pSpectralInversion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_ModulationType_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ ModulationType *pModulationType);


void __RPC_STUB IBDA_DigitalDemodulator_put_ModulationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_ModulationType_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ ModulationType *pModulationType);


void __RPC_STUB IBDA_DigitalDemodulator_get_ModulationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_InnerFECMethod_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ FECMethod *pFECMethod);


void __RPC_STUB IBDA_DigitalDemodulator_put_InnerFECMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_InnerFECMethod_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ FECMethod *pFECMethod);


void __RPC_STUB IBDA_DigitalDemodulator_get_InnerFECMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_InnerFECRate_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ BinaryConvolutionCodeRate *pFECRate);


void __RPC_STUB IBDA_DigitalDemodulator_put_InnerFECRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_InnerFECRate_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ BinaryConvolutionCodeRate *pFECRate);


void __RPC_STUB IBDA_DigitalDemodulator_get_InnerFECRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_OuterFECMethod_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ FECMethod *pFECMethod);


void __RPC_STUB IBDA_DigitalDemodulator_put_OuterFECMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_OuterFECMethod_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ FECMethod *pFECMethod);


void __RPC_STUB IBDA_DigitalDemodulator_get_OuterFECMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_OuterFECRate_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ BinaryConvolutionCodeRate *pFECRate);


void __RPC_STUB IBDA_DigitalDemodulator_put_OuterFECRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_OuterFECRate_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ BinaryConvolutionCodeRate *pFECRate);


void __RPC_STUB IBDA_DigitalDemodulator_get_OuterFECRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_SymbolRate_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ ULONG *pSymbolRate);


void __RPC_STUB IBDA_DigitalDemodulator_put_SymbolRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_SymbolRate_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ ULONG *pSymbolRate);


void __RPC_STUB IBDA_DigitalDemodulator_get_SymbolRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_put_SpectralInversion_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [in] */ SpectralInversion *pSpectralInversion);


void __RPC_STUB IBDA_DigitalDemodulator_put_SpectralInversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_DigitalDemodulator_get_SpectralInversion_Proxy( 
    IBDA_DigitalDemodulator * This,
    /* [out][in] */ SpectralInversion *pSpectralInversion);


void __RPC_STUB IBDA_DigitalDemodulator_get_SpectralInversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_DigitalDemodulator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bdaiface_0421 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_bdaiface_0421_0001
    {	KSPROPERTY_IPSINK_MULTICASTLIST	= 0,
	KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION	= KSPROPERTY_IPSINK_MULTICASTLIST + 1,
	KSPROPERTY_IPSINK_ADAPTER_ADDRESS	= KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION + 1
    } 	KSPROPERTY_IPSINK;



extern RPC_IF_HANDLE __MIDL_itf_bdaiface_0421_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bdaiface_0421_v0_0_s_ifspec;

#ifndef __IBDA_IPSinkControl_INTERFACE_DEFINED__
#define __IBDA_IPSinkControl_INTERFACE_DEFINED__

/* interface IBDA_IPSinkControl */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_IPSinkControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F4DC8E2-4050-11d3-8F4B-00C04F7971E2")
    IBDA_IPSinkControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMulticastList( 
            /* [out][in] */ unsigned long *pulcbSize,
            /* [out][in] */ BYTE **pbBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdapterIPAddress( 
            /* [out][in] */ unsigned long *pulcbSize,
            /* [out][in] */ BYTE **pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_IPSinkControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_IPSinkControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_IPSinkControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_IPSinkControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastList )( 
            IBDA_IPSinkControl * This,
            /* [out][in] */ unsigned long *pulcbSize,
            /* [out][in] */ BYTE **pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapterIPAddress )( 
            IBDA_IPSinkControl * This,
            /* [out][in] */ unsigned long *pulcbSize,
            /* [out][in] */ BYTE **pbBuffer);
        
        END_INTERFACE
    } IBDA_IPSinkControlVtbl;

    interface IBDA_IPSinkControl
    {
        CONST_VTBL struct IBDA_IPSinkControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_IPSinkControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_IPSinkControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_IPSinkControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_IPSinkControl_GetMulticastList(This,pulcbSize,pbBuffer)	\
    (This)->lpVtbl -> GetMulticastList(This,pulcbSize,pbBuffer)

#define IBDA_IPSinkControl_GetAdapterIPAddress(This,pulcbSize,pbBuffer)	\
    (This)->lpVtbl -> GetAdapterIPAddress(This,pulcbSize,pbBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_IPSinkControl_GetMulticastList_Proxy( 
    IBDA_IPSinkControl * This,
    /* [out][in] */ unsigned long *pulcbSize,
    /* [out][in] */ BYTE **pbBuffer);


void __RPC_STUB IBDA_IPSinkControl_GetMulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPSinkControl_GetAdapterIPAddress_Proxy( 
    IBDA_IPSinkControl * This,
    /* [out][in] */ unsigned long *pulcbSize,
    /* [out][in] */ BYTE **pbBuffer);


void __RPC_STUB IBDA_IPSinkControl_GetAdapterIPAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_IPSinkControl_INTERFACE_DEFINED__ */


#ifndef __IBDA_IPSinkInfo_INTERFACE_DEFINED__
#define __IBDA_IPSinkInfo_INTERFACE_DEFINED__

/* interface IBDA_IPSinkInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBDA_IPSinkInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A750108F-492E-4d51-95F7-649B23FF7AD7")
    IBDA_IPSinkInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_MulticastList( 
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE **ppbAddressList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AdapterIPAddress( 
            /* [out] */ BSTR *pbstrBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AdapterDescription( 
            /* [out] */ BSTR *pbstrBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_IPSinkInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_IPSinkInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_IPSinkInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_IPSinkInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_MulticastList )( 
            IBDA_IPSinkInfo * This,
            /* [out][in] */ ULONG *pulcbAddresses,
            /* [size_is][out] */ BYTE **ppbAddressList);
        
        HRESULT ( STDMETHODCALLTYPE *get_AdapterIPAddress )( 
            IBDA_IPSinkInfo * This,
            /* [out] */ BSTR *pbstrBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *get_AdapterDescription )( 
            IBDA_IPSinkInfo * This,
            /* [out] */ BSTR *pbstrBuffer);
        
        END_INTERFACE
    } IBDA_IPSinkInfoVtbl;

    interface IBDA_IPSinkInfo
    {
        CONST_VTBL struct IBDA_IPSinkInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_IPSinkInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_IPSinkInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_IPSinkInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_IPSinkInfo_get_MulticastList(This,pulcbAddresses,ppbAddressList)	\
    (This)->lpVtbl -> get_MulticastList(This,pulcbAddresses,ppbAddressList)

#define IBDA_IPSinkInfo_get_AdapterIPAddress(This,pbstrBuffer)	\
    (This)->lpVtbl -> get_AdapterIPAddress(This,pbstrBuffer)

#define IBDA_IPSinkInfo_get_AdapterDescription(This,pbstrBuffer)	\
    (This)->lpVtbl -> get_AdapterDescription(This,pbstrBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBDA_IPSinkInfo_get_MulticastList_Proxy( 
    IBDA_IPSinkInfo * This,
    /* [out][in] */ ULONG *pulcbAddresses,
    /* [size_is][out] */ BYTE **ppbAddressList);


void __RPC_STUB IBDA_IPSinkInfo_get_MulticastList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPSinkInfo_get_AdapterIPAddress_Proxy( 
    IBDA_IPSinkInfo * This,
    /* [out] */ BSTR *pbstrBuffer);


void __RPC_STUB IBDA_IPSinkInfo_get_AdapterIPAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBDA_IPSinkInfo_get_AdapterDescription_Proxy( 
    IBDA_IPSinkInfo * This,
    /* [out] */ BSTR *pbstrBuffer);


void __RPC_STUB IBDA_IPSinkInfo_get_AdapterDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_IPSinkInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumPIDMap_INTERFACE_DEFINED__
#define __IEnumPIDMap_INTERFACE_DEFINED__

/* interface IEnumPIDMap */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumPIDMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("afb6c2a2-2c41-11d3-8a60-0000f81e0e4a")
    IEnumPIDMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ PID_MAP *pPIDMap,
            /* [out] */ ULONG *pcReceived) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPIDMap **ppIEnumPIDMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPIDMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPIDMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPIDMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPIDMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPIDMap * This,
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ PID_MAP *pPIDMap,
            /* [out] */ ULONG *pcReceived);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPIDMap * This,
            /* [in] */ ULONG cRecords);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPIDMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPIDMap * This,
            /* [out] */ IEnumPIDMap **ppIEnumPIDMap);
        
        END_INTERFACE
    } IEnumPIDMapVtbl;

    interface IEnumPIDMap
    {
        CONST_VTBL struct IEnumPIDMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPIDMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPIDMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPIDMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPIDMap_Next(This,cRequest,pPIDMap,pcReceived)	\
    (This)->lpVtbl -> Next(This,cRequest,pPIDMap,pcReceived)

#define IEnumPIDMap_Skip(This,cRecords)	\
    (This)->lpVtbl -> Skip(This,cRecords)

#define IEnumPIDMap_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPIDMap_Clone(This,ppIEnumPIDMap)	\
    (This)->lpVtbl -> Clone(This,ppIEnumPIDMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPIDMap_Next_Proxy( 
    IEnumPIDMap * This,
    /* [in] */ ULONG cRequest,
    /* [size_is][out][in] */ PID_MAP *pPIDMap,
    /* [out] */ ULONG *pcReceived);


void __RPC_STUB IEnumPIDMap_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPIDMap_Skip_Proxy( 
    IEnumPIDMap * This,
    /* [in] */ ULONG cRecords);


void __RPC_STUB IEnumPIDMap_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPIDMap_Reset_Proxy( 
    IEnumPIDMap * This);


void __RPC_STUB IEnumPIDMap_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPIDMap_Clone_Proxy( 
    IEnumPIDMap * This,
    /* [out] */ IEnumPIDMap **ppIEnumPIDMap);


void __RPC_STUB IEnumPIDMap_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPIDMap_INTERFACE_DEFINED__ */


#ifndef __IMPEG2PIDMap_INTERFACE_DEFINED__
#define __IMPEG2PIDMap_INTERFACE_DEFINED__

/* interface IMPEG2PIDMap */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMPEG2PIDMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("afb6c2a1-2c41-11d3-8a60-0000f81e0e4a")
    IMPEG2PIDMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapPID( 
            /* [in] */ ULONG culPID,
            /* [in] */ ULONG *pulPID,
            /* [in] */ MEDIA_SAMPLE_CONTENT MediaSampleContent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmapPID( 
            /* [in] */ ULONG culPID,
            /* [in] */ ULONG *pulPID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPIDMap( 
            /* [out] */ IEnumPIDMap **pIEnumPIDMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2PIDMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2PIDMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2PIDMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2PIDMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapPID )( 
            IMPEG2PIDMap * This,
            /* [in] */ ULONG culPID,
            /* [in] */ ULONG *pulPID,
            /* [in] */ MEDIA_SAMPLE_CONTENT MediaSampleContent);
        
        HRESULT ( STDMETHODCALLTYPE *UnmapPID )( 
            IMPEG2PIDMap * This,
            /* [in] */ ULONG culPID,
            /* [in] */ ULONG *pulPID);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPIDMap )( 
            IMPEG2PIDMap * This,
            /* [out] */ IEnumPIDMap **pIEnumPIDMap);
        
        END_INTERFACE
    } IMPEG2PIDMapVtbl;

    interface IMPEG2PIDMap
    {
        CONST_VTBL struct IMPEG2PIDMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2PIDMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMPEG2PIDMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMPEG2PIDMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMPEG2PIDMap_MapPID(This,culPID,pulPID,MediaSampleContent)	\
    (This)->lpVtbl -> MapPID(This,culPID,pulPID,MediaSampleContent)

#define IMPEG2PIDMap_UnmapPID(This,culPID,pulPID)	\
    (This)->lpVtbl -> UnmapPID(This,culPID,pulPID)

#define IMPEG2PIDMap_EnumPIDMap(This,pIEnumPIDMap)	\
    (This)->lpVtbl -> EnumPIDMap(This,pIEnumPIDMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMPEG2PIDMap_MapPID_Proxy( 
    IMPEG2PIDMap * This,
    /* [in] */ ULONG culPID,
    /* [in] */ ULONG *pulPID,
    /* [in] */ MEDIA_SAMPLE_CONTENT MediaSampleContent);


void __RPC_STUB IMPEG2PIDMap_MapPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMPEG2PIDMap_UnmapPID_Proxy( 
    IMPEG2PIDMap * This,
    /* [in] */ ULONG culPID,
    /* [in] */ ULONG *pulPID);


void __RPC_STUB IMPEG2PIDMap_UnmapPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMPEG2PIDMap_EnumPIDMap_Proxy( 
    IMPEG2PIDMap * This,
    /* [out] */ IEnumPIDMap **pIEnumPIDMap);


void __RPC_STUB IMPEG2PIDMap_EnumPIDMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMPEG2PIDMap_INTERFACE_DEFINED__ */


#ifndef __IFrequencyMap_INTERFACE_DEFINED__
#define __IFrequencyMap_INTERFACE_DEFINED__

/* interface IFrequencyMap */
/* [restricted][hidden][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFrequencyMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06FB45C1-693C-4ea7-B79F-7A6A54D8DEF2")
    IFrequencyMap : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE get_FrequencyMapping( 
            /* [out] */ ULONG *ulCount,
            /* [size_is][size_is][out] */ ULONG **ppulList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE put_FrequencyMapping( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ ULONG pList[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [out] */ ULONG *pulCountryCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE put_CountryCode( 
            /* [in] */ ULONG ulCountryCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE get_DefaultFrequencyMapping( 
            /* [in] */ ULONG ulCountryCode,
            /* [out] */ ULONG *pulCount,
            /* [size_is][size_is][out] */ ULONG **ppulList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE get_CountryCodeList( 
            /* [out] */ ULONG *pulCount,
            /* [size_is][size_is][out] */ ULONG **ppulList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFrequencyMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFrequencyMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFrequencyMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFrequencyMap * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *get_FrequencyMapping )( 
            IFrequencyMap * This,
            /* [out] */ ULONG *ulCount,
            /* [size_is][size_is][out] */ ULONG **ppulList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *put_FrequencyMapping )( 
            IFrequencyMap * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ ULONG pList[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IFrequencyMap * This,
            /* [out] */ ULONG *pulCountryCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IFrequencyMap * This,
            /* [in] */ ULONG ulCountryCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultFrequencyMapping )( 
            IFrequencyMap * This,
            /* [in] */ ULONG ulCountryCode,
            /* [out] */ ULONG *pulCount,
            /* [size_is][size_is][out] */ ULONG **ppulList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCodeList )( 
            IFrequencyMap * This,
            /* [out] */ ULONG *pulCount,
            /* [size_is][size_is][out] */ ULONG **ppulList);
        
        END_INTERFACE
    } IFrequencyMapVtbl;

    interface IFrequencyMap
    {
        CONST_VTBL struct IFrequencyMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFrequencyMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFrequencyMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFrequencyMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFrequencyMap_get_FrequencyMapping(This,ulCount,ppulList)	\
    (This)->lpVtbl -> get_FrequencyMapping(This,ulCount,ppulList)

#define IFrequencyMap_put_FrequencyMapping(This,ulCount,pList)	\
    (This)->lpVtbl -> put_FrequencyMapping(This,ulCount,pList)

#define IFrequencyMap_get_CountryCode(This,pulCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,pulCountryCode)

#define IFrequencyMap_put_CountryCode(This,ulCountryCode)	\
    (This)->lpVtbl -> put_CountryCode(This,ulCountryCode)

#define IFrequencyMap_get_DefaultFrequencyMapping(This,ulCountryCode,pulCount,ppulList)	\
    (This)->lpVtbl -> get_DefaultFrequencyMapping(This,ulCountryCode,pulCount,ppulList)

#define IFrequencyMap_get_CountryCodeList(This,pulCount,ppulList)	\
    (This)->lpVtbl -> get_CountryCodeList(This,pulCount,ppulList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFrequencyMap_get_FrequencyMapping_Proxy( 
    IFrequencyMap * This,
    /* [out] */ ULONG *ulCount,
    /* [size_is][size_is][out] */ ULONG **ppulList);


void __RPC_STUB IFrequencyMap_get_FrequencyMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFrequencyMap_put_FrequencyMapping_Proxy( 
    IFrequencyMap * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ ULONG pList[  ]);


void __RPC_STUB IFrequencyMap_put_FrequencyMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFrequencyMap_get_CountryCode_Proxy( 
    IFrequencyMap * This,
    /* [out] */ ULONG *pulCountryCode);


void __RPC_STUB IFrequencyMap_get_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFrequencyMap_put_CountryCode_Proxy( 
    IFrequencyMap * This,
    /* [in] */ ULONG ulCountryCode);


void __RPC_STUB IFrequencyMap_put_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFrequencyMap_get_DefaultFrequencyMapping_Proxy( 
    IFrequencyMap * This,
    /* [in] */ ULONG ulCountryCode,
    /* [out] */ ULONG *pulCount,
    /* [size_is][size_is][out] */ ULONG **ppulList);


void __RPC_STUB IFrequencyMap_get_DefaultFrequencyMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFrequencyMap_get_CountryCodeList_Proxy( 
    IFrequencyMap * This,
    /* [out] */ ULONG *pulCount,
    /* [size_is][size_is][out] */ ULONG **ppulList);


void __RPC_STUB IFrequencyMap_get_CountryCodeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFrequencyMap_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\bdatypes.h ===
//------------------------------------------------------------------------------
// File: BDATypes.h
//
// Desc: Typedefs and enums needed by both the WDM drivers and the user mode
//       COM interfaces.
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _BDATYPES_

#define _BDATYPES_      1

/* Utility Macros */

#define MIN_DIMENSION   1


#ifdef __midl
#define V1_ENUM [v1_enum]
#else
#define V1_ENUM
#endif

//===========================================================================
//
//  BDA Topology Structures
//
//===========================================================================

typedef struct _BDA_TEMPLATE_CONNECTION
{
    ULONG   FromNodeType;
    ULONG   FromNodePinType;
    ULONG   ToNodeType;
    ULONG   ToNodePinType;
}BDA_TEMPLATE_CONNECTION, *PBDA_TEMPLATE_CONNECTION;


typedef struct _BDA_TEMPLATE_PIN_JOINT
{
    ULONG   uliTemplateConnection;
    ULONG   ulcInstancesMax;
}BDA_TEMPLATE_PIN_JOINT, *PBDA_TEMPLATE_PIN_JOINT;



//===========================================================================
//
//  BDA Events
//
//===========================================================================

//  In-band Event IDs
//
typedef enum {
    BDA_EVENT_SIGNAL_LOSS = 0,
    BDA_EVENT_SIGNAL_LOCK,
    BDA_EVENT_DATA_START,
    BDA_EVENT_DATA_STOP,
    BDA_EVENT_CHANNEL_ACQUIRED,
    BDA_EVENT_CHANNEL_LOST,
    BDA_EVENT_CHANNEL_SOURCE_CHANGED,
    BDA_EVENT_CHANNEL_ACTIVATED,
    BDA_EVENT_CHANNEL_DEACTIVATED,
    BDA_EVENT_SUBCHANNEL_ACQUIRED,
    BDA_EVENT_SUBCHANNEL_LOST,
    BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED,
    BDA_EVENT_SUBCHANNEL_ACTIVATED,
    BDA_EVENT_SUBCHANNEL_DEACTIVATED,
    BDA_EVENT_ACCESS_GRANTED,
    BDA_EVENT_ACCESS_DENIED,
    BDA_EVENT_OFFER_EXTENDED,
    BDA_EVENT_PURCHASE_COMPLETED,
    BDA_EVENT_SMART_CARD_INSERTED,
    BDA_EVENT_SMART_CARD_REMOVED
} BDA_EVENT_ID, *PBDA_EVENT_ID;



//===========================================================================
//
//  KSSTREAM_HEADER extensions for BDA
//
//===========================================================================

typedef struct tagKS_BDA_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  //
    ULONG                   ulEvent; //
    ULONG                   ulChannelNumber; //
    ULONG                   ulSubchannelNumber; //
    ULONG                   ulReason; //
} KS_BDA_FRAME_INFO, *PKS_BDA_FRAME_INFO;


//------------------------------------------------------------
//
//  BDA Network Ethernet Filter Property Set
//
// {71985F43-1CA1-11d3-9CC8-00C04F7971E0}
//
typedef struct _BDA_ETHERNET_ADDRESS {
    BYTE    rgbAddress[6];
} BDA_ETHERNET_ADDRESS, *PBDA_ETHERNET_ADDRESS;

typedef struct _BDA_ETHERNET_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_ETHERNET_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_ETHERNET_ADDRESS_LIST, * PBDA_ETHERNET_ADDRESS_LIST;

typedef enum {
    BDA_PROMISCUOUS_MULTICAST = 0,
    BDA_FILTERED_MULTICAST,
    BDA_NO_MULTICAST
} BDA_MULTICAST_MODE, *PBDA_MULTICAST_MODE;


//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {71985F44-1CA1-11d3-9CC8-00C04F7971E0}
//
typedef struct _BDA_IPv4_ADDRESS {
    BYTE    rgbAddress[4];
} BDA_IPv4_ADDRESS, *PBDA_IPv4_ADDRESS;

typedef struct _BDA_IPv4_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_IPv4_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_IPv4_ADDRESS_LIST, * PBDA_IPv4_ADDRESS_LIST;


//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {E1785A74-2A23-4fb3-9245-A8F88017EF33}
//
typedef struct _BDA_IPv6_ADDRESS {
    BYTE    rgbAddress[6];
} BDA_IPv6_ADDRESS, *PBDA_IPv6_ADDRESS;

typedef struct _BDA_IPv6_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_IPv6_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_IPv6_ADDRESS_LIST, * PBDA_IPv6_ADDRESS_LIST;


//------------------------------------------------------------
//
//
//  BDA Signal Property Set
//
//  {D2F1644B-B409-11d2-BC69-00A0C9EE9E16}
//
typedef enum {
    BDA_SIGNAL_UNAVAILABLE = 0,
    BDA_SIGNAL_INACTIVE,
    BDA_SIGNAL_ACTIVE
} BDA_SIGNAL_STATE, * PBDA_SIGNAL_STATE;


//------------------------------------------------------------
//
//
//  BDA Change Sync Method Set
//
// {FD0A5AF3-B41D-11d2-9C95-00C04F7971E0}
//
typedef enum
{
    BDA_CHANGES_COMPLETE = 0,
    BDA_CHANGES_PENDING

} BDA_CHANGE_STATE, * PBDA_CHANGE_STATE;


//------------------------------------------------------------
//
//
//  BDA Device Configuration Method Set
//
// {71985F45-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Topology Property Set
//
// {A14EE835-0A23-11d3-9CC7-00C04F7971E0}
//

typedef struct _BDANODE_DESCRIPTOR
{
    ULONG               ulBdaNodeType;  // The node type as it is used
                                        // in the BDA template topology

    GUID                guidFunction;   // GUID from BdaMedia.h describing
                                        // the node's function (e.g.
                                        // KSNODE_BDA_RF_TUNER)

    GUID                guidName;       // GUID that can be use to look up
                                        // a displayable name for the node.
} BDANODE_DESCRIPTOR, *PBDANODE_DESCRIPTOR;


//------------------------------------------------------------
//
//
//  BDA Void Transform Property Set
//
// {71985F46-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Null Transform Property Set
//
// {DDF15B0D-BD25-11d2-9CA0-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Frequency Filter Property Set
//
// {71985F47-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Autodemodulate Property Set
//
// {DDF15B12-BD25-11d2-9CA0-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Table Section Property Set
//
// {516B99C5-971C-4aaf-B3F3-D9FDA8A15E16}
//

typedef struct _BDA_TABLE_SECTION
{
    ULONG               ulPrimarySectionId;
    ULONG               ulSecondarySectionId;
    ULONG               ulcbSectionLength;
    ULONG               argbSectionData[MIN_DIMENSION];
} BDA_TABLE_SECTION, *PBDA_TABLE_SECTION;


//------------------------------------------------------------
//
//
//  BDA PID Filter Property Set
//
// {D0A67D65-08DF-4fec-8533-E5B550410B85}
//

//---------------------------------------------------------------------
// From IEnumPIDMap interface
//---------------------------------------------------------------------

typedef enum {
    MEDIA_TRANSPORT_PACKET,         //  complete TS packet e.g. pass-through mode
    MEDIA_ELEMENTARY_STREAM,        //  PES payloads; audio/video only
    MEDIA_MPEG2_PSI,                //  PAT, PMT, CAT, Private
    MEDIA_TRANSPORT_PAYLOAD         //  gathered TS packet payloads (PES packets, etc...)
} MEDIA_SAMPLE_CONTENT ;

typedef struct {
    ULONG                   ulPID ;
    MEDIA_SAMPLE_CONTENT    MediaSampleContent ;
} PID_MAP ;

typedef struct _BDA_PID_MAP
{
    MEDIA_SAMPLE_CONTENT    MediaSampleContent;
    ULONG                   ulcPIDs;
    ULONG                   aulPIDs[MIN_DIMENSION];
} BDA_PID_MAP, *PBDA_PID_MAP;

typedef struct _BDA_PID_UNMAP
{
    ULONG               ulcPIDs;
    ULONG               aulPIDs[MIN_DIMENSION];
} BDA_PID_UNMAP, *PBDA_PID_UNMAP;


//------------------------------------------------------------
//
//
//  BDA CA Property Set
//
// {B0693766-5278-4ec6-B9E1-3CE40560EF5A}
//
typedef struct _BDA_CA_MODULE_UI
{
    ULONG   ulFormat;
    ULONG   ulbcDesc;
    ULONG   ulDesc[MIN_DIMENSION];
} BDA_CA_MODULE_UI, *PBDA_CA_MODULE_UI;

typedef struct _BDA_PROGRAM_PID_LIST
{
    ULONG   ulProgramNumber;
    ULONG   ulcPIDs;
    ULONG   ulPID[MIN_DIMENSION];
} BDA_PROGRAM_PID_LIST, *PBDA_PROGRAM_PID_LIST;


//------------------------------------------------------------
//
//
//  BDA CA Event Set
//
// {488C4CCC-B768-4129-8EB1-B00A071F9068}
//



//=============================================================
//
//
//  BDA Tuning Model enumerations
//
//
//=============================================================

// system type for particular DVB Tuning Space instance
typedef enum DVBSystemType {
    DVB_Cable,
    DVB_Terrestrial,
    DVB_Satellite,
} DVBSystemType;

//------------------------------------------------------------
//
//  BDA Channel Tune Request

V1_ENUM enum {
    BDA_UNDEFINED_CHANNEL = -1,
};


//------------------------------------------------------------
//
//  BDA Component(substream)
//

typedef V1_ENUM enum ComponentCategory
{
    CategoryNotSet = -1,
    CategoryOther = 0,
    CategoryVideo,
    CategoryAudio,
    CategoryText,
    CategoryData,
} ComponentCategory;

// Component Status
typedef enum ComponentStatus
{
    StatusActive,
    StatusInactive,
    StatusUnavailable,
} ComponentStatus;


//------------------------------------------------------------
//
//  BDA MPEG2 Component Type
//
// from the MPEG2 specification
typedef V1_ENUM enum MPEG2StreamType {
    BDA_UNITIALIZED_MPEG2STREAMTYPE = -1,
    Reserved1 = 0x0,
    ISO_IEC_11172_2_VIDEO   = Reserved1 + 1,
    ISO_IEC_13818_2_VIDEO   = ISO_IEC_11172_2_VIDEO + 1,
    ISO_IEC_11172_3_AUDIO   = ISO_IEC_13818_2_VIDEO + 1,
    ISO_IEC_13818_3_AUDIO   = ISO_IEC_11172_3_AUDIO + 1,
    ISO_IEC_13818_1_PRIVATE_SECTION = ISO_IEC_13818_3_AUDIO + 1,
    ISO_IEC_13818_1_PES     = ISO_IEC_13818_1_PRIVATE_SECTION + 1,
    ISO_IEC_13522_MHEG      = ISO_IEC_13818_1_PES + 1,
    ANNEX_A_DSM_CC          = ISO_IEC_13522_MHEG + 1,
    ITU_T_REC_H_222_1       = ANNEX_A_DSM_CC + 1,
    ISO_IEC_13818_6_TYPE_A  = ITU_T_REC_H_222_1 + 1,
    ISO_IEC_13818_6_TYPE_B  = ISO_IEC_13818_6_TYPE_A + 1,
    ISO_IEC_13818_6_TYPE_C  = ISO_IEC_13818_6_TYPE_B + 1,
    ISO_IEC_13818_6_TYPE_D  = ISO_IEC_13818_6_TYPE_C + 1,
    ISO_IEC_13818_1_AUXILIARY = ISO_IEC_13818_6_TYPE_D + 1,
    ISO_IEC_13818_1_RESERVED = ISO_IEC_13818_1_AUXILIARY + 1,
    USER_PRIVATE            = ISO_IEC_13818_1_RESERVED + 1
} MPEG2StreamType;

//------------------------------------------------------------
//
//  mpeg-2 transport stride format block; associated with media
//   types MEDIATYPE_Stream/MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE;
//   *all* format blocks associated with above media type *must*
//   start with the MPEG2_TRANSPORT_STRIDE structure
//

typedef struct _MPEG2_TRANSPORT_STRIDE {
    DWORD   dwOffset ;
    DWORD   dwPacketLength ;
    DWORD   dwStride ;
} MPEG2_TRANSPORT_STRIDE, *PMPEG2_TRANSPORT_STRIDE ;

//------------------------------------------------------------
//
//  BDA ATSC Component Type
//
//
// ATSC made AC3 Audio a descriptor instead of
// defining a user private stream type.
typedef enum ATSCComponentTypeFlags {
    // bit flags for various component type properties
    ATSCCT_AC3 = 0x00000001,
} ATSCComponentTypeFlags;


//------------------------------------------------------------
//
//  BDA Locators
//


typedef V1_ENUM enum BinaryConvolutionCodeRate {
    BDA_BCC_RATE_NOT_SET = -1,
    BDA_BCC_RATE_NOT_DEFINED = 0,
    BDA_BCC_RATE_1_2 = 1,   // 1/2
    BDA_BCC_RATE_2_3,   // 2/3
    BDA_BCC_RATE_3_4,   // 3/4
    BDA_BCC_RATE_3_5,
    BDA_BCC_RATE_4_5,
    BDA_BCC_RATE_5_6,   // 5/6
    BDA_BCC_RATE_5_11,
    BDA_BCC_RATE_7_8,   // 7/8
    BDA_BCC_RATE_MAX,
} BinaryConvolutionCodeRate;

typedef V1_ENUM enum FECMethod {
    BDA_FEC_METHOD_NOT_SET = -1,
    BDA_FEC_METHOD_NOT_DEFINED = 0,
    BDA_FEC_VITERBI = 1,          // FEC is a Viterbi Binary Convolution.
    BDA_FEC_RS_204_188,       // The FEC is Reed-Solomon 204/188 (outer FEC)
    BDA_FEC_MAX,
} FECMethod;

typedef V1_ENUM enum ModulationType {
    BDA_MOD_NOT_SET = -1,
    BDA_MOD_NOT_DEFINED = 0,
    BDA_MOD_16QAM = 1,
    BDA_MOD_32QAM,
    BDA_MOD_64QAM,
    BDA_MOD_80QAM,
    BDA_MOD_96QAM,
    BDA_MOD_112QAM,
    BDA_MOD_128QAM,
    BDA_MOD_160QAM,
    BDA_MOD_192QAM,
    BDA_MOD_224QAM,
    BDA_MOD_256QAM,
    BDA_MOD_320QAM,
    BDA_MOD_384QAM,
    BDA_MOD_448QAM,
    BDA_MOD_512QAM,
    BDA_MOD_640QAM,
    BDA_MOD_768QAM,
    BDA_MOD_896QAM,
    BDA_MOD_1024QAM,
    BDA_MOD_QPSK,
    BDA_MOD_BPSK,
    BDA_MOD_OQPSK,
    BDA_MOD_8VSB,
    BDA_MOD_16VSB,
    BDA_MOD_ANALOG_AMPLITUDE,  // std am
    BDA_MOD_ANALOG_FREQUENCY,  // std fm
    BDA_MOD_MAX,
} ModulationType;

typedef V1_ENUM enum SpectralInversion {
    BDA_SPECTRAL_INVERSION_NOT_SET = -1,
    BDA_SPECTRAL_INVERSION_NOT_DEFINED = 0,
    BDA_SPECTRAL_INVERSION_AUTOMATIC = 1,
    BDA_SPECTRAL_INVERSION_NORMAL,
    BDA_SPECTRAL_INVERSION_INVERTED,
    BDA_SPECTRAL_INVERSION_MAX
} SpectralInversion;

typedef V1_ENUM enum Polarisation {
    BDA_POLARISATION_NOT_SET = -1,
    BDA_POLARISATION_NOT_DEFINED = 0,
    BDA_POLARISATION_LINEAR_H = 1, // Linear horizontal polarisation
    BDA_POLARISATION_LINEAR_V, // Linear vertical polarisation
    BDA_POLARISATION_CIRCULAR_L, // Circular left polarisation
    BDA_POLARISATION_CIRCULAR_R, // Circular right polarisation
    BDA_POLARISATION_MAX,
} Polarisation;

typedef V1_ENUM enum GuardInterval {
    BDA_GUARD_NOT_SET = -1,
    BDA_GUARD_NOT_DEFINED = 0,
    BDA_GUARD_1_32 = 1, // Guard interval is 1/32
    BDA_GUARD_1_16, // Guard interval is 1/16
    BDA_GUARD_1_8, // Guard interval is 1/8
    BDA_GUARD_1_4, // Guard interval is 1/4
    BDA_GUARD_MAX,
} GuardInterval;

typedef V1_ENUM enum HierarchyAlpha {
    BDA_HALPHA_NOT_SET = -1,
    BDA_HALPHA_NOT_DEFINED = 0,
    BDA_HALPHA_1 = 1, // Hierarchy alpha is 1.
    BDA_HALPHA_2, // Hierarchy alpha is 2.
    BDA_HALPHA_4, // Hierarchy alpha is 4.
    BDA_HALPHA_MAX,
} HierarchyAlpha;

typedef V1_ENUM enum TransmissionMode {
    BDA_XMIT_MODE_NOT_SET = -1,
    BDA_XMIT_MODE_NOT_DEFINED = 0,
    BDA_XMIT_MODE_2K = 1, // Transmission uses 1705 carriers (use a 2K FFT)
    BDA_XMIT_MODE_8K, // Transmission uses 6817 carriers (use an 8K FFT)
    BDA_XMIT_MODE_MAX,
} TransmissionMode;

//  Settings for Tuner Frequency
//
#define BDA_FREQUENCY_NOT_SET       -1
#define BDA_FREQUENCY_NOT_DEFINED   0

//  Settings for Tuner Range
//
//  Tuner range refers to the setting of LNB High/Low as well as the
//  selection of a satellite on a multiple satellite switch.
//
#define BDA_RANGE_NOT_SET       -1
#define BDA_RANGE_NOT_DEFINED   0

//  Settings for Tuner Channel Bandwidth
//
#define BDA_CHAN_BANDWITH_NOT_SET       -1
#define BDA_CHAN_BANDWITH_NOT_DEFINED   0

//  Settings for Tuner Frequency Multiplier
//
#define BDA_FREQUENCY_MULTIPLIER_NOT_SET        -1
#define BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED    0 

#endif // not defined _BDATYPES_

// end of file -- bdatypes.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\Bdatif.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for bdatif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __bdatif_h__
#define __bdatif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBDA_TIF_REGISTRATION_FWD_DEFINED__
#define __IBDA_TIF_REGISTRATION_FWD_DEFINED__
typedef interface IBDA_TIF_REGISTRATION IBDA_TIF_REGISTRATION;
#endif 	/* __IBDA_TIF_REGISTRATION_FWD_DEFINED__ */


#ifndef __IMPEG2_TIF_CONTROL_FWD_DEFINED__
#define __IMPEG2_TIF_CONTROL_FWD_DEFINED__
typedef interface IMPEG2_TIF_CONTROL IMPEG2_TIF_CONTROL;
#endif 	/* __IMPEG2_TIF_CONTROL_FWD_DEFINED__ */


#ifndef __ITuneRequestInfo_FWD_DEFINED__
#define __ITuneRequestInfo_FWD_DEFINED__
typedef interface ITuneRequestInfo ITuneRequestInfo;
#endif 	/* __ITuneRequestInfo_FWD_DEFINED__ */


#ifndef __IGuideDataEvent_FWD_DEFINED__
#define __IGuideDataEvent_FWD_DEFINED__
typedef interface IGuideDataEvent IGuideDataEvent;
#endif 	/* __IGuideDataEvent_FWD_DEFINED__ */


#ifndef __IGuideDataProperty_FWD_DEFINED__
#define __IGuideDataProperty_FWD_DEFINED__
typedef interface IGuideDataProperty IGuideDataProperty;
#endif 	/* __IGuideDataProperty_FWD_DEFINED__ */


#ifndef __IEnumGuideDataProperties_FWD_DEFINED__
#define __IEnumGuideDataProperties_FWD_DEFINED__
typedef interface IEnumGuideDataProperties IEnumGuideDataProperties;
#endif 	/* __IEnumGuideDataProperties_FWD_DEFINED__ */


#ifndef __IEnumTuneRequests_FWD_DEFINED__
#define __IEnumTuneRequests_FWD_DEFINED__
typedef interface IEnumTuneRequests IEnumTuneRequests;
#endif 	/* __IEnumTuneRequests_FWD_DEFINED__ */


#ifndef __IGuideData_FWD_DEFINED__
#define __IGuideData_FWD_DEFINED__
typedef interface IGuideData IGuideData;
#endif 	/* __IGuideData_FWD_DEFINED__ */


#ifndef __IGuideDataLoader_FWD_DEFINED__
#define __IGuideDataLoader_FWD_DEFINED__
typedef interface IGuideDataLoader IGuideDataLoader;
#endif 	/* __IGuideDataLoader_FWD_DEFINED__ */


#ifndef __TIFLoad_FWD_DEFINED__
#define __TIFLoad_FWD_DEFINED__

#ifdef __cplusplus
typedef class TIFLoad TIFLoad;
#else
typedef struct TIFLoad TIFLoad;
#endif /* __cplusplus */

#endif 	/* __TIFLoad_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"
#include "tuner.h"
#include "bdaiface.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_bdatif_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#if ( _MSC_VER >= 1020 )
#pragma once
#endif





extern RPC_IF_HANDLE __MIDL_itf_bdatif_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bdatif_0000_v0_0_s_ifspec;

#ifndef __IBDA_TIF_REGISTRATION_INTERFACE_DEFINED__
#define __IBDA_TIF_REGISTRATION_INTERFACE_DEFINED__

/* interface IBDA_TIF_REGISTRATION */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBDA_TIF_REGISTRATION;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DFEF4A68-EE61-415f-9CCB-CD95F2F98A3A")
    IBDA_TIF_REGISTRATION : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterTIFEx( 
            /* [in] */ IPin *pTIFInputPin,
            /* [out][in] */ ULONG *ppvRegistrationContext,
            /* [out][in] */ IUnknown **ppMpeg2DataControl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterTIF( 
            /* [in] */ ULONG pvRegistrationContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDA_TIF_REGISTRATIONVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDA_TIF_REGISTRATION * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDA_TIF_REGISTRATION * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDA_TIF_REGISTRATION * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterTIFEx )( 
            IBDA_TIF_REGISTRATION * This,
            /* [in] */ IPin *pTIFInputPin,
            /* [out][in] */ ULONG *ppvRegistrationContext,
            /* [out][in] */ IUnknown **ppMpeg2DataControl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterTIF )( 
            IBDA_TIF_REGISTRATION * This,
            /* [in] */ ULONG pvRegistrationContext);
        
        END_INTERFACE
    } IBDA_TIF_REGISTRATIONVtbl;

    interface IBDA_TIF_REGISTRATION
    {
        CONST_VTBL struct IBDA_TIF_REGISTRATIONVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDA_TIF_REGISTRATION_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBDA_TIF_REGISTRATION_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBDA_TIF_REGISTRATION_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBDA_TIF_REGISTRATION_RegisterTIFEx(This,pTIFInputPin,ppvRegistrationContext,ppMpeg2DataControl)	\
    (This)->lpVtbl -> RegisterTIFEx(This,pTIFInputPin,ppvRegistrationContext,ppMpeg2DataControl)

#define IBDA_TIF_REGISTRATION_UnregisterTIF(This,pvRegistrationContext)	\
    (This)->lpVtbl -> UnregisterTIF(This,pvRegistrationContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBDA_TIF_REGISTRATION_RegisterTIFEx_Proxy( 
    IBDA_TIF_REGISTRATION * This,
    /* [in] */ IPin *pTIFInputPin,
    /* [out][in] */ ULONG *ppvRegistrationContext,
    /* [out][in] */ IUnknown **ppMpeg2DataControl);


void __RPC_STUB IBDA_TIF_REGISTRATION_RegisterTIFEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBDA_TIF_REGISTRATION_UnregisterTIF_Proxy( 
    IBDA_TIF_REGISTRATION * This,
    /* [in] */ ULONG pvRegistrationContext);


void __RPC_STUB IBDA_TIF_REGISTRATION_UnregisterTIF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBDA_TIF_REGISTRATION_INTERFACE_DEFINED__ */


#ifndef __IMPEG2_TIF_CONTROL_INTERFACE_DEFINED__
#define __IMPEG2_TIF_CONTROL_INTERFACE_DEFINED__

/* interface IMPEG2_TIF_CONTROL */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMPEG2_TIF_CONTROL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9BAC2F9-4149-4916-B2EF-FAA202326862")
    IMPEG2_TIF_CONTROL : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterTIF( 
            /* [in] */ IUnknown *pUnkTIF,
            /* [out][in] */ ULONG *ppvRegistrationContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterTIF( 
            /* [in] */ ULONG pvRegistrationContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPIDs( 
            /* [in] */ ULONG ulcPIDs,
            /* [in] */ ULONG *pulPIDs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeletePIDs( 
            /* [in] */ ULONG ulcPIDs,
            /* [in] */ ULONG *pulPIDs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPIDCount( 
            /* [out] */ ULONG *pulcPIDs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPIDs( 
            /* [out] */ ULONG *pulcPIDs,
            /* [out] */ ULONG *pulPIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2_TIF_CONTROLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2_TIF_CONTROL * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2_TIF_CONTROL * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2_TIF_CONTROL * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterTIF )( 
            IMPEG2_TIF_CONTROL * This,
            /* [in] */ IUnknown *pUnkTIF,
            /* [out][in] */ ULONG *ppvRegistrationContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterTIF )( 
            IMPEG2_TIF_CONTROL * This,
            /* [in] */ ULONG pvRegistrationContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPIDs )( 
            IMPEG2_TIF_CONTROL * This,
            /* [in] */ ULONG ulcPIDs,
            /* [in] */ ULONG *pulPIDs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeletePIDs )( 
            IMPEG2_TIF_CONTROL * This,
            /* [in] */ ULONG ulcPIDs,
            /* [in] */ ULONG *pulPIDs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPIDCount )( 
            IMPEG2_TIF_CONTROL * This,
            /* [out] */ ULONG *pulcPIDs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPIDs )( 
            IMPEG2_TIF_CONTROL * This,
            /* [out] */ ULONG *pulcPIDs,
            /* [out] */ ULONG *pulPIDs);
        
        END_INTERFACE
    } IMPEG2_TIF_CONTROLVtbl;

    interface IMPEG2_TIF_CONTROL
    {
        CONST_VTBL struct IMPEG2_TIF_CONTROLVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2_TIF_CONTROL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMPEG2_TIF_CONTROL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMPEG2_TIF_CONTROL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMPEG2_TIF_CONTROL_RegisterTIF(This,pUnkTIF,ppvRegistrationContext)	\
    (This)->lpVtbl -> RegisterTIF(This,pUnkTIF,ppvRegistrationContext)

#define IMPEG2_TIF_CONTROL_UnregisterTIF(This,pvRegistrationContext)	\
    (This)->lpVtbl -> UnregisterTIF(This,pvRegistrationContext)

#define IMPEG2_TIF_CONTROL_AddPIDs(This,ulcPIDs,pulPIDs)	\
    (This)->lpVtbl -> AddPIDs(This,ulcPIDs,pulPIDs)

#define IMPEG2_TIF_CONTROL_DeletePIDs(This,ulcPIDs,pulPIDs)	\
    (This)->lpVtbl -> DeletePIDs(This,ulcPIDs,pulPIDs)

#define IMPEG2_TIF_CONTROL_GetPIDCount(This,pulcPIDs)	\
    (This)->lpVtbl -> GetPIDCount(This,pulcPIDs)

#define IMPEG2_TIF_CONTROL_GetPIDs(This,pulcPIDs,pulPIDs)	\
    (This)->lpVtbl -> GetPIDs(This,pulcPIDs,pulPIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMPEG2_TIF_CONTROL_RegisterTIF_Proxy( 
    IMPEG2_TIF_CONTROL * This,
    /* [in] */ IUnknown *pUnkTIF,
    /* [out][in] */ ULONG *ppvRegistrationContext);


void __RPC_STUB IMPEG2_TIF_CONTROL_RegisterTIF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMPEG2_TIF_CONTROL_UnregisterTIF_Proxy( 
    IMPEG2_TIF_CONTROL * This,
    /* [in] */ ULONG pvRegistrationContext);


void __RPC_STUB IMPEG2_TIF_CONTROL_UnregisterTIF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMPEG2_TIF_CONTROL_AddPIDs_Proxy( 
    IMPEG2_TIF_CONTROL * This,
    /* [in] */ ULONG ulcPIDs,
    /* [in] */ ULONG *pulPIDs);


void __RPC_STUB IMPEG2_TIF_CONTROL_AddPIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMPEG2_TIF_CONTROL_DeletePIDs_Proxy( 
    IMPEG2_TIF_CONTROL * This,
    /* [in] */ ULONG ulcPIDs,
    /* [in] */ ULONG *pulPIDs);


void __RPC_STUB IMPEG2_TIF_CONTROL_DeletePIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMPEG2_TIF_CONTROL_GetPIDCount_Proxy( 
    IMPEG2_TIF_CONTROL * This,
    /* [out] */ ULONG *pulcPIDs);


void __RPC_STUB IMPEG2_TIF_CONTROL_GetPIDCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMPEG2_TIF_CONTROL_GetPIDs_Proxy( 
    IMPEG2_TIF_CONTROL * This,
    /* [out] */ ULONG *pulcPIDs,
    /* [out] */ ULONG *pulPIDs);


void __RPC_STUB IMPEG2_TIF_CONTROL_GetPIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMPEG2_TIF_CONTROL_INTERFACE_DEFINED__ */


#ifndef __ITuneRequestInfo_INTERFACE_DEFINED__
#define __ITuneRequestInfo_INTERFACE_DEFINED__

/* interface ITuneRequestInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITuneRequestInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3B152DF-7A90-4218-AC54-9830BEE8C0B6")
    ITuneRequestInfo : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLocatorData( 
            /* [in] */ ITuneRequest *Request) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetComponentData( 
            /* [in] */ ITuneRequest *CurrentRequest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponentList( 
            /* [in] */ ITuneRequest *CurrentRequest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextProgram( 
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPreviousProgram( 
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextLocator( 
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPreviousLocator( 
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITuneRequestInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITuneRequestInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITuneRequestInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITuneRequestInfo * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLocatorData )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *Request);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetComponentData )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *CurrentRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateComponentList )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *CurrentRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextProgram )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPreviousProgram )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextLocator )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPreviousLocator )( 
            ITuneRequestInfo * This,
            /* [in] */ ITuneRequest *CurrentRequest,
            /* [retval][out] */ ITuneRequest **TuneRequest);
        
        END_INTERFACE
    } ITuneRequestInfoVtbl;

    interface ITuneRequestInfo
    {
        CONST_VTBL struct ITuneRequestInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITuneRequestInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITuneRequestInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITuneRequestInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITuneRequestInfo_GetLocatorData(This,Request)	\
    (This)->lpVtbl -> GetLocatorData(This,Request)

#define ITuneRequestInfo_GetComponentData(This,CurrentRequest)	\
    (This)->lpVtbl -> GetComponentData(This,CurrentRequest)

#define ITuneRequestInfo_CreateComponentList(This,CurrentRequest)	\
    (This)->lpVtbl -> CreateComponentList(This,CurrentRequest)

#define ITuneRequestInfo_GetNextProgram(This,CurrentRequest,TuneRequest)	\
    (This)->lpVtbl -> GetNextProgram(This,CurrentRequest,TuneRequest)

#define ITuneRequestInfo_GetPreviousProgram(This,CurrentRequest,TuneRequest)	\
    (This)->lpVtbl -> GetPreviousProgram(This,CurrentRequest,TuneRequest)

#define ITuneRequestInfo_GetNextLocator(This,CurrentRequest,TuneRequest)	\
    (This)->lpVtbl -> GetNextLocator(This,CurrentRequest,TuneRequest)

#define ITuneRequestInfo_GetPreviousLocator(This,CurrentRequest,TuneRequest)	\
    (This)->lpVtbl -> GetPreviousLocator(This,CurrentRequest,TuneRequest)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_GetLocatorData_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *Request);


void __RPC_STUB ITuneRequestInfo_GetLocatorData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_GetComponentData_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *CurrentRequest);


void __RPC_STUB ITuneRequestInfo_GetComponentData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_CreateComponentList_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *CurrentRequest);


void __RPC_STUB ITuneRequestInfo_CreateComponentList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_GetNextProgram_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *CurrentRequest,
    /* [retval][out] */ ITuneRequest **TuneRequest);


void __RPC_STUB ITuneRequestInfo_GetNextProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_GetPreviousProgram_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *CurrentRequest,
    /* [retval][out] */ ITuneRequest **TuneRequest);


void __RPC_STUB ITuneRequestInfo_GetPreviousProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_GetNextLocator_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *CurrentRequest,
    /* [retval][out] */ ITuneRequest **TuneRequest);


void __RPC_STUB ITuneRequestInfo_GetNextLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuneRequestInfo_GetPreviousLocator_Proxy( 
    ITuneRequestInfo * This,
    /* [in] */ ITuneRequest *CurrentRequest,
    /* [retval][out] */ ITuneRequest **TuneRequest);


void __RPC_STUB ITuneRequestInfo_GetPreviousLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITuneRequestInfo_INTERFACE_DEFINED__ */


#ifndef __IGuideDataEvent_INTERFACE_DEFINED__
#define __IGuideDataEvent_INTERFACE_DEFINED__

/* interface IGuideDataEvent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGuideDataEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EFDA0C80-F395-42c3-9B3C-56B37DEC7BB7")
    IGuideDataEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GuideDataAcquired( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProgramChanged( 
            /* [in] */ VARIANT varProgramDescriptionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServiceChanged( 
            /* [in] */ VARIANT varServiceDescriptionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScheduleEntryChanged( 
            /* [in] */ VARIANT varScheduleEntryDescriptionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProgramDeleted( 
            /* [in] */ VARIANT varProgramDescriptionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServiceDeleted( 
            /* [in] */ VARIANT varServiceDescriptionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScheduleDeleted( 
            /* [in] */ VARIANT varScheduleEntryDescriptionID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGuideDataEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGuideDataEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGuideDataEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGuideDataEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GuideDataAcquired )( 
            IGuideDataEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProgramChanged )( 
            IGuideDataEvent * This,
            /* [in] */ VARIANT varProgramDescriptionID);
        
        HRESULT ( STDMETHODCALLTYPE *ServiceChanged )( 
            IGuideDataEvent * This,
            /* [in] */ VARIANT varServiceDescriptionID);
        
        HRESULT ( STDMETHODCALLTYPE *ScheduleEntryChanged )( 
            IGuideDataEvent * This,
            /* [in] */ VARIANT varScheduleEntryDescriptionID);
        
        HRESULT ( STDMETHODCALLTYPE *ProgramDeleted )( 
            IGuideDataEvent * This,
            /* [in] */ VARIANT varProgramDescriptionID);
        
        HRESULT ( STDMETHODCALLTYPE *ServiceDeleted )( 
            IGuideDataEvent * This,
            /* [in] */ VARIANT varServiceDescriptionID);
        
        HRESULT ( STDMETHODCALLTYPE *ScheduleDeleted )( 
            IGuideDataEvent * This,
            /* [in] */ VARIANT varScheduleEntryDescriptionID);
        
        END_INTERFACE
    } IGuideDataEventVtbl;

    interface IGuideDataEvent
    {
        CONST_VTBL struct IGuideDataEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGuideDataEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGuideDataEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGuideDataEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGuideDataEvent_GuideDataAcquired(This)	\
    (This)->lpVtbl -> GuideDataAcquired(This)

#define IGuideDataEvent_ProgramChanged(This,varProgramDescriptionID)	\
    (This)->lpVtbl -> ProgramChanged(This,varProgramDescriptionID)

#define IGuideDataEvent_ServiceChanged(This,varServiceDescriptionID)	\
    (This)->lpVtbl -> ServiceChanged(This,varServiceDescriptionID)

#define IGuideDataEvent_ScheduleEntryChanged(This,varScheduleEntryDescriptionID)	\
    (This)->lpVtbl -> ScheduleEntryChanged(This,varScheduleEntryDescriptionID)

#define IGuideDataEvent_ProgramDeleted(This,varProgramDescriptionID)	\
    (This)->lpVtbl -> ProgramDeleted(This,varProgramDescriptionID)

#define IGuideDataEvent_ServiceDeleted(This,varServiceDescriptionID)	\
    (This)->lpVtbl -> ServiceDeleted(This,varServiceDescriptionID)

#define IGuideDataEvent_ScheduleDeleted(This,varScheduleEntryDescriptionID)	\
    (This)->lpVtbl -> ScheduleDeleted(This,varScheduleEntryDescriptionID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGuideDataEvent_GuideDataAcquired_Proxy( 
    IGuideDataEvent * This);


void __RPC_STUB IGuideDataEvent_GuideDataAcquired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataEvent_ProgramChanged_Proxy( 
    IGuideDataEvent * This,
    /* [in] */ VARIANT varProgramDescriptionID);


void __RPC_STUB IGuideDataEvent_ProgramChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataEvent_ServiceChanged_Proxy( 
    IGuideDataEvent * This,
    /* [in] */ VARIANT varServiceDescriptionID);


void __RPC_STUB IGuideDataEvent_ServiceChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataEvent_ScheduleEntryChanged_Proxy( 
    IGuideDataEvent * This,
    /* [in] */ VARIANT varScheduleEntryDescriptionID);


void __RPC_STUB IGuideDataEvent_ScheduleEntryChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataEvent_ProgramDeleted_Proxy( 
    IGuideDataEvent * This,
    /* [in] */ VARIANT varProgramDescriptionID);


void __RPC_STUB IGuideDataEvent_ProgramDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataEvent_ServiceDeleted_Proxy( 
    IGuideDataEvent * This,
    /* [in] */ VARIANT varServiceDescriptionID);


void __RPC_STUB IGuideDataEvent_ServiceDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataEvent_ScheduleDeleted_Proxy( 
    IGuideDataEvent * This,
    /* [in] */ VARIANT varScheduleEntryDescriptionID);


void __RPC_STUB IGuideDataEvent_ScheduleDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGuideDataEvent_INTERFACE_DEFINED__ */


#ifndef __IGuideDataProperty_INTERFACE_DEFINED__
#define __IGuideDataProperty_INTERFACE_DEFINED__

/* interface IGuideDataProperty */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGuideDataProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88EC5E58-BB73-41d6-99CE-66C524B8B591")
    IGuideDataProperty : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [out] */ long *idLang) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [out] */ VARIANT *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGuideDataPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGuideDataProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGuideDataProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGuideDataProperty * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IGuideDataProperty * This,
            /* [out] */ BSTR *pbstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Language )( 
            IGuideDataProperty * This,
            /* [out] */ long *idLang);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IGuideDataProperty * This,
            /* [out] */ VARIANT *pvar);
        
        END_INTERFACE
    } IGuideDataPropertyVtbl;

    interface IGuideDataProperty
    {
        CONST_VTBL struct IGuideDataPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGuideDataProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGuideDataProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGuideDataProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGuideDataProperty_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IGuideDataProperty_get_Language(This,idLang)	\
    (This)->lpVtbl -> get_Language(This,idLang)

#define IGuideDataProperty_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IGuideDataProperty_get_Name_Proxy( 
    IGuideDataProperty * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IGuideDataProperty_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IGuideDataProperty_get_Language_Proxy( 
    IGuideDataProperty * This,
    /* [out] */ long *idLang);


void __RPC_STUB IGuideDataProperty_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IGuideDataProperty_get_Value_Proxy( 
    IGuideDataProperty * This,
    /* [out] */ VARIANT *pvar);


void __RPC_STUB IGuideDataProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGuideDataProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumGuideDataProperties_INTERFACE_DEFINED__
#define __IEnumGuideDataProperties_INTERFACE_DEFINED__

/* interface IEnumGuideDataProperties */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumGuideDataProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE44423B-4571-475c-AD2C-F40A771D80EF")
    IEnumGuideDataProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long celt,
            /* [out] */ IGuideDataProperty **ppprop,
            /* [out] */ unsigned long *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGuideDataProperties **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGuideDataPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumGuideDataProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumGuideDataProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumGuideDataProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumGuideDataProperties * This,
            /* [in] */ unsigned long celt,
            /* [out] */ IGuideDataProperty **ppprop,
            /* [out] */ unsigned long *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumGuideDataProperties * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumGuideDataProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumGuideDataProperties * This,
            /* [out] */ IEnumGuideDataProperties **ppenum);
        
        END_INTERFACE
    } IEnumGuideDataPropertiesVtbl;

    interface IEnumGuideDataProperties
    {
        CONST_VTBL struct IEnumGuideDataPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGuideDataProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGuideDataProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGuideDataProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGuideDataProperties_Next(This,celt,ppprop,pcelt)	\
    (This)->lpVtbl -> Next(This,celt,ppprop,pcelt)

#define IEnumGuideDataProperties_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGuideDataProperties_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGuideDataProperties_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGuideDataProperties_Next_Proxy( 
    IEnumGuideDataProperties * This,
    /* [in] */ unsigned long celt,
    /* [out] */ IGuideDataProperty **ppprop,
    /* [out] */ unsigned long *pcelt);


void __RPC_STUB IEnumGuideDataProperties_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGuideDataProperties_Skip_Proxy( 
    IEnumGuideDataProperties * This,
    /* [in] */ unsigned long celt);


void __RPC_STUB IEnumGuideDataProperties_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGuideDataProperties_Reset_Proxy( 
    IEnumGuideDataProperties * This);


void __RPC_STUB IEnumGuideDataProperties_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGuideDataProperties_Clone_Proxy( 
    IEnumGuideDataProperties * This,
    /* [out] */ IEnumGuideDataProperties **ppenum);


void __RPC_STUB IEnumGuideDataProperties_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGuideDataProperties_INTERFACE_DEFINED__ */


#ifndef __IEnumTuneRequests_INTERFACE_DEFINED__
#define __IEnumTuneRequests_INTERFACE_DEFINED__

/* interface IEnumTuneRequests */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumTuneRequests;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1993299C-CED6-4788-87A3-420067DCE0C7")
    IEnumTuneRequests : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long celt,
            /* [out] */ ITuneRequest **ppprop,
            /* [out] */ unsigned long *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTuneRequests **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTuneRequestsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTuneRequests * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTuneRequests * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTuneRequests * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTuneRequests * This,
            /* [in] */ unsigned long celt,
            /* [out] */ ITuneRequest **ppprop,
            /* [out] */ unsigned long *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTuneRequests * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTuneRequests * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTuneRequests * This,
            /* [out] */ IEnumTuneRequests **ppenum);
        
        END_INTERFACE
    } IEnumTuneRequestsVtbl;

    interface IEnumTuneRequests
    {
        CONST_VTBL struct IEnumTuneRequestsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTuneRequests_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTuneRequests_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTuneRequests_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTuneRequests_Next(This,celt,ppprop,pcelt)	\
    (This)->lpVtbl -> Next(This,celt,ppprop,pcelt)

#define IEnumTuneRequests_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumTuneRequests_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTuneRequests_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTuneRequests_Next_Proxy( 
    IEnumTuneRequests * This,
    /* [in] */ unsigned long celt,
    /* [out] */ ITuneRequest **ppprop,
    /* [out] */ unsigned long *pcelt);


void __RPC_STUB IEnumTuneRequests_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTuneRequests_Skip_Proxy( 
    IEnumTuneRequests * This,
    /* [in] */ unsigned long celt);


void __RPC_STUB IEnumTuneRequests_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTuneRequests_Reset_Proxy( 
    IEnumTuneRequests * This);


void __RPC_STUB IEnumTuneRequests_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTuneRequests_Clone_Proxy( 
    IEnumTuneRequests * This,
    /* [out] */ IEnumTuneRequests **ppenum);


void __RPC_STUB IEnumTuneRequests_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTuneRequests_INTERFACE_DEFINED__ */


#ifndef __IGuideData_INTERFACE_DEFINED__
#define __IGuideData_INTERFACE_DEFINED__

/* interface IGuideData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGuideData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61571138-5B01-43cd-AEAF-60B784A0BF93")
    IGuideData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetServices( 
            /* [retval][out] */ IEnumTuneRequests **ppEnumTuneRequests) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetServiceProperties( 
            /* [in] */ ITuneRequest *pTuneRequest,
            /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetGuideProgramIDs( 
            /* [retval][out] */ IEnumVARIANT **pEnumPrograms) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProgramProperties( 
            /* [in] */ VARIANT varProgramDescriptionID,
            /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetScheduleEntryIDs( 
            /* [retval][out] */ IEnumVARIANT **pEnumScheduleEntries) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetScheduleEntryProperties( 
            /* [in] */ VARIANT varScheduleEntryDescriptionID,
            /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGuideDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGuideData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGuideData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGuideData * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetServices )( 
            IGuideData * This,
            /* [retval][out] */ IEnumTuneRequests **ppEnumTuneRequests);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetServiceProperties )( 
            IGuideData * This,
            /* [in] */ ITuneRequest *pTuneRequest,
            /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGuideProgramIDs )( 
            IGuideData * This,
            /* [retval][out] */ IEnumVARIANT **pEnumPrograms);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProgramProperties )( 
            IGuideData * This,
            /* [in] */ VARIANT varProgramDescriptionID,
            /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetScheduleEntryIDs )( 
            IGuideData * This,
            /* [retval][out] */ IEnumVARIANT **pEnumScheduleEntries);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetScheduleEntryProperties )( 
            IGuideData * This,
            /* [in] */ VARIANT varScheduleEntryDescriptionID,
            /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties);
        
        END_INTERFACE
    } IGuideDataVtbl;

    interface IGuideData
    {
        CONST_VTBL struct IGuideDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGuideData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGuideData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGuideData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGuideData_GetServices(This,ppEnumTuneRequests)	\
    (This)->lpVtbl -> GetServices(This,ppEnumTuneRequests)

#define IGuideData_GetServiceProperties(This,pTuneRequest,ppEnumProperties)	\
    (This)->lpVtbl -> GetServiceProperties(This,pTuneRequest,ppEnumProperties)

#define IGuideData_GetGuideProgramIDs(This,pEnumPrograms)	\
    (This)->lpVtbl -> GetGuideProgramIDs(This,pEnumPrograms)

#define IGuideData_GetProgramProperties(This,varProgramDescriptionID,ppEnumProperties)	\
    (This)->lpVtbl -> GetProgramProperties(This,varProgramDescriptionID,ppEnumProperties)

#define IGuideData_GetScheduleEntryIDs(This,pEnumScheduleEntries)	\
    (This)->lpVtbl -> GetScheduleEntryIDs(This,pEnumScheduleEntries)

#define IGuideData_GetScheduleEntryProperties(This,varScheduleEntryDescriptionID,ppEnumProperties)	\
    (This)->lpVtbl -> GetScheduleEntryProperties(This,varScheduleEntryDescriptionID,ppEnumProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGuideData_GetServices_Proxy( 
    IGuideData * This,
    /* [retval][out] */ IEnumTuneRequests **ppEnumTuneRequests);


void __RPC_STUB IGuideData_GetServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGuideData_GetServiceProperties_Proxy( 
    IGuideData * This,
    /* [in] */ ITuneRequest *pTuneRequest,
    /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties);


void __RPC_STUB IGuideData_GetServiceProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGuideData_GetGuideProgramIDs_Proxy( 
    IGuideData * This,
    /* [retval][out] */ IEnumVARIANT **pEnumPrograms);


void __RPC_STUB IGuideData_GetGuideProgramIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGuideData_GetProgramProperties_Proxy( 
    IGuideData * This,
    /* [in] */ VARIANT varProgramDescriptionID,
    /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties);


void __RPC_STUB IGuideData_GetProgramProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGuideData_GetScheduleEntryIDs_Proxy( 
    IGuideData * This,
    /* [retval][out] */ IEnumVARIANT **pEnumScheduleEntries);


void __RPC_STUB IGuideData_GetScheduleEntryIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGuideData_GetScheduleEntryProperties_Proxy( 
    IGuideData * This,
    /* [in] */ VARIANT varScheduleEntryDescriptionID,
    /* [retval][out] */ IEnumGuideDataProperties **ppEnumProperties);


void __RPC_STUB IGuideData_GetScheduleEntryProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGuideData_INTERFACE_DEFINED__ */


#ifndef __IGuideDataLoader_INTERFACE_DEFINED__
#define __IGuideDataLoader_INTERFACE_DEFINED__

/* interface IGuideDataLoader */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGuideDataLoader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4764ff7c-fa95-4525-af4d-d32236db9e38")
    IGuideDataLoader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IGuideData *pGuideStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGuideDataLoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGuideDataLoader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGuideDataLoader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGuideDataLoader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IGuideDataLoader * This,
            /* [in] */ IGuideData *pGuideStore);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IGuideDataLoader * This);
        
        END_INTERFACE
    } IGuideDataLoaderVtbl;

    interface IGuideDataLoader
    {
        CONST_VTBL struct IGuideDataLoaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGuideDataLoader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGuideDataLoader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGuideDataLoader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGuideDataLoader_Init(This,pGuideStore)	\
    (This)->lpVtbl -> Init(This,pGuideStore)

#define IGuideDataLoader_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGuideDataLoader_Init_Proxy( 
    IGuideDataLoader * This,
    /* [in] */ IGuideData *pGuideStore);


void __RPC_STUB IGuideDataLoader_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGuideDataLoader_Terminate_Proxy( 
    IGuideDataLoader * This);


void __RPC_STUB IGuideDataLoader_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGuideDataLoader_INTERFACE_DEFINED__ */



#ifndef __PSISLOADLib_LIBRARY_DEFINED__
#define __PSISLOADLib_LIBRARY_DEFINED__

/* library PSISLOADLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PSISLOADLib;

EXTERN_C const CLSID CLSID_TIFLoad;

#ifdef __cplusplus

class DECLSPEC_UUID("14EB8748-1753-4393-95AE-4F7E7A87AAD6")
TIFLoad;
#endif
#endif /* __PSISLOADLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_bdatif_0489 */
/* [local] */ 

#if ( _MSC_VER >= 800 )
#pragma warning(default:4201)    /* Nameless struct/union */
#endif


extern RPC_IF_HANDLE __MIDL_itf_bdatif_0489_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bdatif_0489_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\comlite.h ===
//------------------------------------------------------------------------------
// File: COMLite.h
//
// Desc: This header file is to provide a migration path for users of 
//       ActiveMovie betas 1 and 2.
//
// Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _INC_COMLITE_
#define _INC_COMLITE_

#define QzInitialize            CoInitialize
#define QzUninitialize          CoUninitialize
#define QzFreeUnusedLibraries   CoFreeUnusedLibraries

#define QzGetMalloc             CoGetMalloc
#define QzTaskMemAlloc          CoTaskMemAlloc
#define QzTaskMemRealloc        CoTaskMemRealloc
#define QzTaskMemFree           CoTaskMemFree
#define QzCreateFilterObject    CoCreateInstance
#define QzCLSIDFromString       CLSIDFromString
#define QzStringFromGUID2       StringFromGUID2

#endif  // _INC_COMLITE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\bdamedia.h ===
//------------------------------------------------------------------------------
// File: BDAMedia.h
//
// Desc: Broadcast Driver Architecture Multimedia Definitions.
//
// Copyright (c) 1996 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before BDAMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_BDATYPES_)
#error BDATYPES.H must be included before BDAMEDIA.H
#endif // !defined(_BDATYPES_)

#if !defined(_BDAMEDIA_)
#define _BDAMEDIA_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)



//===========================================================================
//
//  KSProperty Set Structure Definitions for BDA
//
//===========================================================================

typedef struct _KSP_BDA_NODE_PIN {
    KSPROPERTY      Property;
    ULONG           ulNodeType;
    ULONG           ulInputPinId;
    ULONG           ulOutputPinId;
} KSP_BDA_NODE_PIN, *PKSP_BDA_NODE_PIN;


typedef struct _KSM_BDA_PIN
{
    KSMETHOD    Method;
    union
    {
        ULONG       PinId;
        ULONG       PinType;
    };
    ULONG       Reserved;
} KSM_BDA_PIN, * PKSM_BDA_PIN;


typedef struct _KSM_BDA_PIN_PAIR
{
    KSMETHOD    Method;
    union
    {
        ULONG       InputPinId;
        ULONG       InputPinType;
    };
    union
    {
        ULONG       OutputPinId;
        ULONG       OutputPinType;
    };
} KSM_BDA_PIN_PAIR, * PKSM_BDA_PIN_PAIR;


typedef struct {
    KSP_NODE        Property;
    ULONG           EsPid;
} KSP_NODE_ESPID, *PKSP_NODE_ESPID;



//===========================================================================
//
//  BDA Data Range definitions.  Includes specifier definitions.
//
//===========================================================================

//  Antenna Signal Formats
//

typedef struct tagKS_DATARANGE_BDA_ANTENNA {
   KSDATARANGE                  DataRange;

   //   Antenna specifier can go here if required
   //
} KS_DATARANGE_BDA_ANTENNA, *PKS_DATARANGE_BDA_ANTENNA;



//  Transport Formats
//

typedef struct tagBDA_TRANSPORT_INFO {
    ULONG           ulcbPhyiscalPacket; // Size, in bytes, of a physical packet
                                        // (e.g. Satellite link payload size.
    ULONG           ulcbPhyiscalFrame;  // Size, in bytes, of each physical frame
                                        // 0 indicates no HW requirement
    ULONG           ulcbPhyiscalFrameAlignment; // Capture buffer alignment in bytes
                                                // 0 and 1 indicate no alignment requirements
    REFERENCE_TIME  AvgTimePerFrame; // Normal ActiveMovie units (100 nS)

} BDA_TRANSPORT_INFO, *PBDA_TRANSPORT_INFO;

typedef struct tagKS_DATARANGE_BDA_TRANSPORT {
   KSDATARANGE                  DataRange;
   BDA_TRANSPORT_INFO           BdaTransportInfo;

   //   Transport specifier can go here if required
   //
} KS_DATARANGE_BDA_TRANSPORT, *PKS_DATARANGE_BDA_TRANSPORT;


//===========================================================================
//  BDA Event Guids
//
//      These are sent by the IBroadcastEvent service on the graph.
//      To receive,
//          0) Implement IBroadcastEvent in your receiving object - this has one Method on it: Fire() 
//          1) QI the graphs service provider for SID_SBroadcastEventService
//                 for the IID_IBroadcastEvent object
//          2) OR create the event service (CLSID_BroadcastEventService) if not already there
//                 and register it
//          3) QI that object for it's IConnectionPoint interface (*pCP)
//          4) Advise your object on *pCP  (e.g. pCP->Advise(static_cast<IBroadCastEvent*>(this), &dwCookie)
//          5) Unadvise when done..
//          6) Implement IBroadcastEvent::Fire(GUID gEventID)
//             Check for relevant event below and deal with it appropriatly...
//===========================================================================

// {9D7E6235-4B7D-425d-A6D1-D717C33B9C4C}
#define STATIC_EVENTID_TuningChanged \
    0x9d7e6235, 0x4b7d, 0x425d, 0xa6, 0xd1, 0xd7, 0x17, 0xc3, 0x3b, 0x9c, 0x4c
DEFINE_GUIDSTRUCT("9D7E6235-4B7D-425d-A6D1-D717C33B9C4C", EVENTID_TuningChanged);
#define EVENTID_TuningChanged DEFINE_GUIDNAMED(EVENTID_TuningChanged)

// {2A65C528-2249-4070-AC16-00390CDFB2DD}
#define STATIC_EVENTID_CADenialCountChanged \
    0x2a65c528, 0x2249, 0x4070, 0xac, 0x16, 0x0, 0x39, 0xc, 0xdf, 0xb2, 0xdd
DEFINE_GUIDSTRUCT("2A65C528-2249-4070-AC16-00390CDFB2DD", EVENTID_CADenialCountChanged);
#define EVENTID_CADenialCountChanged DEFINE_GUIDNAMED(EVENTID_CADenialCountChanged)

// {6D9CFAF2-702D-4b01-8DFF-6892AD20D191}
#define STATIC_EVENTID_SignalStatusChanged \
    0x6d9cfaf2, 0x702d, 0x4b01, 0x8d, 0xff, 0x68, 0x92, 0xad, 0x20, 0xd1, 0x91
DEFINE_GUIDSTRUCT("6D9CFAF2-702D-4b01-8DFF-6892AD20D191", EVENTID_SignalStatusChanged);
#define EVENTID_SignalStatusChanged DEFINE_GUIDNAMED(EVENTID_SignalStatusChanged)

//===========================================================================
//
//  BDA Stream Format GUIDs
//
//===========================================================================

#define STATIC_KSDATAFORMAT_TYPE_BDA_ANTENNA\
    0x71985f41, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F41-1CA1-11d3-9CC8-00C04F7971E0", KSDATAFORMAT_TYPE_BDA_ANTENNA);
#define KSDATAFORMAT_TYPE_BDA_ANTENNA DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_ANTENNA)


#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT\
    0xf4aeb342, 0x0329, 0x4fdd, 0xa8, 0xfd, 0x4a, 0xff, 0x49, 0x26, 0xc9, 0x78
DEFINE_GUIDSTRUCT("F4AEB342-0329-4fdd-A8FD-4AFF4926C978", KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT);
#define KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT)


#define STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT\
    0x8deda6fd, 0xac5f, 0x4334, 0x8e, 0xcf, 0xa4, 0xba, 0x8f, 0xa7, 0xd0, 0xf0
DEFINE_GUIDSTRUCT("8DEDA6FD-AC5F-4334-8ECF-A4BA8FA7D0F0", KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT);
#define KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT)


#define STATIC_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL\
    0x61be0b47, 0xa5eb, 0x499b, 0x9a, 0x85, 0x5b, 0x16, 0xc0, 0x7f, 0x12, 0x58
DEFINE_GUIDSTRUCT("61BE0B47-A5EB-499b-9A85-5B16C07F1258", KSDATAFORMAT_TYPE_BDA_IF_SIGNAL);
#define KSDATAFORMAT_TYPE_BDA_IF_SIGNAL DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IF_SIGNAL)


#define STATIC_KSDATAFORMAT_TYPE_MPEG2_SECTIONS\
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5
DEFINE_GUIDSTRUCT("455F176C-4B06-47CE-9AEF-8CAEF73DF7B5", KSDATAFORMAT_TYPE_MPEG2_SECTIONS);
#define KSDATAFORMAT_TYPE_MPEG2_SECTIONS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_SECTIONS)


#define STATIC_KSDATAFORMAT_SUBTYPE_ATSC_SI\
    0xb3c7397c, 0xd303, 0x414d, 0xb3, 0x3c, 0x4e, 0xd2, 0xc9, 0xd2, 0x97, 0x33
DEFINE_GUIDSTRUCT("B3C7397C-D303-414D-B33C-4ED2C9D29733", KSDATAFORMAT_SUBTYPE_ATSC_SI);
#define KSDATAFORMAT_SUBTYPE_ATSC_SI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ATSC_SI)


#define STATIC_KSDATAFORMAT_SUBTYPE_DVB_SI\
    0xe9dd31a3, 0x221d, 0x4adb, 0x85, 0x32, 0x9a, 0xf3, 0x9, 0xc1, 0xa4, 0x8
DEFINE_GUIDSTRUCT("e9dd31a3-221d-4adb-8532-9af309c1a408", KSDATAFORMAT_SUBTYPE_DVB_SI);
#define KSDATAFORMAT_SUBTYPE_DVB_SI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DVB_SI)


#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP\
    0x762e3f66, 0x336f, 0x48d1, 0xbf, 0x83, 0x2b, 0x0, 0x35, 0x2c, 0x11, 0xf0
DEFINE_GUIDSTRUCT("762E3F66-336F-48d1-BF83-2B00352C11F0", KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP);
#define KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP\
    0x951727db, 0xd2ce, 0x4528, 0x96, 0xf6, 0x33, 0x1, 0xfa, 0xbb, 0x2d, 0xe0
DEFINE_GUIDSTRUCT("951727DB-D2CE-4528-96F6-3301FABB2DE0", KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP);
#define KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP)

//===========================================================================
//
//  KSPinName Definitions for BDA
//
//===========================================================================

//  Pin name for a BDA transport pin
//
// {78216A81-CFA8-493e-9711-36A61C08BD9D}
//
#define STATIC_PINNAME_BDA_TRANSPORT \
    0x78216a81, 0xcfa8, 0x493e, 0x97, 0x11, 0x36, 0xa6, 0x1c, 0x8, 0xbd, 0x9d
DEFINE_GUIDSTRUCT("78216A81-CFA8-493e-9711-36A61C08BD9D", PINNAME_BDA_TRANSPORT);
#define PINNAME_BDA_TRANSPORT DEFINE_GUIDNAMED(PINNAME_BDA_TRANSPORT)


//  Pin name for a BDA analog video pin
//
// {5C0C8281-5667-486c-8482-63E31F01A6E9}
//
#define STATIC_PINNAME_BDA_ANALOG_VIDEO \
    0x5c0c8281, 0x5667, 0x486c, 0x84, 0x82, 0x63, 0xe3, 0x1f, 0x1, 0xa6, 0xe9
DEFINE_GUIDSTRUCT("5C0C8281-5667-486c-8482-63E31F01A6E9", PINNAME_BDA_ANALOG_VIDEO);
#define PINNAME_BDA_ANALOG_VIDEO DEFINE_GUIDNAMED(PINNAME_BDA_ANALOG_VIDEO)


//  Pin name for a BDA analog audio pin
//
// {D28A580A-9B1F-4b0c-9C33-9BF0A8EA636B}
//
#define STATIC_PINNAME_BDA_ANALOG_AUDIO \
    0xd28a580a, 0x9b1f, 0x4b0c, 0x9c, 0x33, 0x9b, 0xf0, 0xa8, 0xea, 0x63, 0x6b
DEFINE_GUIDSTRUCT("D28A580A-9B1F-4b0c-9C33-9BF0A8EA636B", PINNAME_BDA_ANALOG_AUDIO);
#define PINNAME_BDA_ANALOG_AUDIO DEFINE_GUIDNAMED(PINNAME_BDA_ANALOG_AUDIO)


//  Pin name for a BDA FM Radio pin
//
// {D2855FED-B2D3-4eeb-9BD0-193436A2F890}
//
#define STATIC_PINNAME_BDA_FM_RADIO \
    0xd2855fed, 0xb2d3, 0x4eeb, 0x9b, 0xd0, 0x19, 0x34, 0x36, 0xa2, 0xf8, 0x90
DEFINE_GUIDSTRUCT("D2855FED-B2D3-4eeb-9BD0-193436A2F890", PINNAME_BDA_FM_RADIO);
#define PINNAME_BDA_FM_RADIO DEFINE_GUIDNAMED(PINNAME_BDA_FM_RADIO)


//  Pin name for a BDA Intermediate Frequency pin
//
// {1A9D4A42-F3CD-48a1-9AEA-71DE133CBE14}
//
#define STATIC_PINNAME_BDA_IF_PIN \
    0x1a9d4a42, 0xf3cd, 0x48a1, 0x9a, 0xea, 0x71, 0xde, 0x13, 0x3c, 0xbe, 0x14
DEFINE_GUIDSTRUCT("1A9D4A42-F3CD-48a1-9AEA-71DE133CBE14", PINNAME_BDA_IF_PIN);
#define PINNAME_BDA_IF_PIN DEFINE_GUIDNAMED(PINNAME_BDA_IF_PIN)


//  Pin name for a BDA Open Cable PSIP pin
//
// {297BB104-E5C9-4ACE-B123-95C3CBB24D4F}
//
#define STATIC_PINNAME_BDA_OPENCABLE_PSIP_PIN \
    0x297bb104, 0xe5c9, 0x4ace, 0xb1, 0x23, 0x95, 0xc3, 0xcb, 0xb2, 0x4d, 0x4f
DEFINE_GUIDSTRUCT("297BB104-E5C9-4ACE-B123-95C3CBB24D4F", PINNAME_BDA_OPENCABLE_PSIP_PIN);
#define PINNAME_BDA_OPENCABLE_PSIP_PIN DEFINE_GUIDNAMED(PINNAME_BDA_OPENCABLE_PSIP_PIN)


//===========================================================================
//
//  KSProperty Set Definitions for BDA
//
//===========================================================================


//------------------------------------------------------------
//
//  BDA Network Ethernet Filter Property Set
//
// {71985F43-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaEthernetFilter \
    0x71985f43, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F43-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaEthernetFilter);
#define KSPROPSETID_BdaEthernetFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaEthernetFilter)

typedef enum {
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_ETHERNET_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_ETHERNET_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {71985F44-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaIPv4Filter \
    0x71985f44, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F44-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaIPv4Filter);
#define KSPROPSETID_BdaIPv4Filter DEFINE_GUIDNAMED(KSPROPSETID_BdaIPv4Filter)

typedef enum {
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_IPv4_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_IPv4_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//  BDA Network IPv6 Filter Property Set
//
// {E1785A74-2A23-4fb3-9245-A8F88017EF33}
//
#define STATIC_KSPROPSETID_BdaIPv6Filter \
    0xe1785a74, 0x2a23, 0x4fb3, 0x92, 0x45, 0xa8, 0xf8, 0x80, 0x17, 0xef, 0x33
DEFINE_GUIDSTRUCT("E1785A74-2A23-4fb3-9245-A8F88017EF33", KSPROPSETID_BdaIPv6Filter);
#define KSPROPSETID_BdaIPv6Filter DEFINE_GUIDNAMED(KSPROPSETID_BdaIPv6Filter)

typedef enum {
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_IPv6_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_IPv6_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)


//------------------------------------------------------------
//
//
//  BDA Signal Statistics Property Set
//
//  Used to get signal statistics from a control node or a pin.
//  Set NodeId == -1 to get properties from the pin.
//
//  {1347D106-CF3A-428a-A5CB-AC0D9A2A4338}
//
#define STATIC_KSPROPSETID_BdaSignalStats \
    0x1347d106, 0xcf3a, 0x428a, 0xa5, 0xcb, 0xac, 0xd, 0x9a, 0x2a, 0x43, 0x38
DEFINE_GUIDSTRUCT("1347D106-CF3A-428a-A5CB-AC0D9A2A4338", KSPROPSETID_BdaSignalStats);
#define KSPROPSETID_BdaSignalStats DEFINE_GUIDNAMED(KSPROPSETID_BdaSignalStats)

typedef enum {
    KSPROPERTY_BDA_SIGNAL_STRENGTH = 0,
    KSPROPERTY_BDA_SIGNAL_QUALITY,
    KSPROPERTY_BDA_SIGNAL_PRESENT,
    KSPROPERTY_BDA_SIGNAL_LOCKED,
    KSPROPERTY_BDA_SAMPLE_TIME
} KSPROPERTY_BDA_SIGNAL_STATS;

//  OPTIONAL
//  Carrier strength in mDb (1/1000 of a DB).
//
//  A strength of 0 is nominal strength as expected for the given
//  type of broadcast network.
//
//  Sub-nominal strengths are reported as positive mDb
//
//  Super-nominal strengths are reported as negative mDb
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_STRENGTH(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_STRENGTH,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(LONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  OPTIONAL
//  Amount of data successfully extracted from the signal as a percent.
//
//  Signal Quality is usually reported by the demodulation node and is
//  a representation of how much of the original data could be extracted
//  from the signal.
//
//  In the case of Analog Signals, this percentage can be
//  computed by examining the timing of HSync and VSync as will as by
//  looking at information contained in HBlanking and VBlanking intervals.
//
//  In the case of Digital Signals, this percentage can be
//  computed by examining packet CRCs and FEC confidence values.
//
//  100 percent is ideal.
//  95 percent shows very little (almost unnoticable) artifacts when rendered.
//  90 percent contains few enough artifacts as to be easily viewable.
//  80 percent is the minimum level to be viewable.
//  60 percent is the minimum level to expect data services
//  (including EPG) to work.
//  20 percent indicates that the demodulator knows that a properly modulated
//  signal exists but can't produce enough data to be useful.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_QUALITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_QUALITY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(LONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  REQUIRED
//  True if a signal carrier is present.
//
//  Should be returned by the RF tuner node.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_PRESENT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_PRESENT,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BOOL),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  REQUIRED
//  True if the signal can be locked.
//
//  Ususally represents PLL lock when returned by the RF Tuner Node.
//
//  Represents Signal Quality of at least 20% when returned by the
//  demodulator node.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_LOCKED(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_LOCKED,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BOOL),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  OPTIONAL
//  Indicates the sample time overwhich signal level and quality are
//  averaged.
//
//  Each time a signal statistics property is requested, the node should
//  report the average value for the last n milliseconds where n is the
//  value set by this property.  If no value is set or if the driver does
//  not support this property, the driver should default to 
//  100 millisecond sample times.
//
//  The driver may report values for the most recently completed sample
//  period.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_TIME(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SAMPLE_TIME,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(LONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Change Sync Method Set
//
// {FD0A5AF3-B41D-11d2-9C95-00C04F7971E0}
//
#define STATIC_KSMETHODSETID_BdaChangeSync \
    0xfd0a5af3, 0xb41d, 0x11d2, 0x9c, 0x95, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("FD0A5AF3-B41D-11d2-9C95-00C04F7971E0", KSMETHODSETID_BdaChangeSync);
#define KSMETHODSETID_BdaChangeSync DEFINE_GUIDNAMED(KSMETHODSETID_BdaChangeSync)

typedef enum {
    KSMETHOD_BDA_START_CHANGES = 0,
    KSMETHOD_BDA_CHECK_CHANGES,
    KSMETHOD_BDA_COMMIT_CHANGES,
    KSMETHOD_BDA_GET_CHANGE_STATE
} KSMETHOD_BDA_CHANGE_SYNC;

#define DEFINE_KSMETHOD_ITEM_BDA_START_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_START_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_CHECK_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CHECK_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_COMMIT_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_COMMIT_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_GET_CHANGE_STATE(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_GET_CHANGE_STATE,\
        KSMETHOD_TYPE_READ,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)



//------------------------------------------------------------
//
//
//  BDA Device Configuration Method Set
//
// {71985F45-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSMETHODSETID_BdaDeviceConfiguration \
    0x71985f45, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F45-1CA1-11d3-9CC8-00C04F7971E0", KSMETHODSETID_BdaDeviceConfiguration);
#define KSMETHODSETID_BdaDeviceConfiguration DEFINE_GUIDNAMED(KSMETHODSETID_BdaDeviceConfiguration)

typedef enum {
    KSMETHOD_BDA_CREATE_PIN_FACTORY = 0,
    KSMETHOD_BDA_DELETE_PIN_FACTORY,
    KSMETHOD_BDA_CREATE_TOPOLOGY
} KSMETHOD_BDA_DEVICE_CONFIGURATION;

#define DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CREATE_PIN_FACTORY,\
        KSMETHOD_TYPE_READ,\
        (MethodHandler),\
        sizeof(KSM_BDA_PIN),\
        sizeof(ULONG),\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_DELETE_PIN_FACTORY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_DELETE_PIN_FACTORY,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSM_BDA_PIN),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CREATE_TOPOLOGY,\
        KSMETHOD_TYPE_WRITE,\
        (MethodHandler),\
        sizeof(KSM_BDA_PIN_PAIR),\
        0,\
        SupportHandler)



//------------------------------------------------------------
//
//
//  BDA Topology Property Set
//
// {A14EE835-0A23-11d3-9CC7-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaTopology \
    0xa14ee835, 0x0a23, 0x11d3, 0x9c, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("A14EE835-0A23-11d3-9CC7-00C04F7971E0", KSPROPSETID_BdaTopology);
#define KSPROPSETID_BdaTopology DEFINE_GUIDNAMED(KSPROPSETID_BdaTopology)

typedef enum {
    KSPROPERTY_BDA_NODE_TYPES,
    KSPROPERTY_BDA_PIN_TYPES,
    KSPROPERTY_BDA_TEMPLATE_CONNECTIONS,
    KSPROPERTY_BDA_NODE_METHODS,
    KSPROPERTY_BDA_NODE_PROPERTIES,
    KSPROPERTY_BDA_NODE_EVENTS,
    KSPROPERTY_BDA_CONTROLLING_PIN_ID,
    KSPROPERTY_BDA_NODE_DESCRIPTORS
 }KSPROPERTY_BDA_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_TYPES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_TYPES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TEMPLATE_CONNECTIONS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof( BDA_TEMPLATE_CONNECTION),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_METHODS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_METHODS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_PROPERTIES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_PROPERTIES,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_EVENTS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_EVENTS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CONTROLLING_PIN_ID,\
        (GetHandler),\
        sizeof(KSP_BDA_NODE_PIN),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_DESCRIPTORS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_DESCRIPTORS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Pin Control Property Set
//
// {0DED49D5-A8B7-4d5d-97A1-12B0C195874D}
//
#define STATIC_KSPROPSETID_BdaPinControl \
    0xded49d5, 0xa8b7, 0x4d5d, 0x97, 0xa1, 0x12, 0xb0, 0xc1, 0x95, 0x87, 0x4d
DEFINE_GUIDSTRUCT("0DED49D5-A8B7-4d5d-97A1-12B0C195874D", KSPROPSETID_BdaPinControl);
#define KSPROPSETID_BdaPinControl DEFINE_GUIDNAMED(KSPROPSETID_BdaPinControl)

typedef enum {
    KSPROPERTY_BDA_PIN_ID = 0,
    KSPROPERTY_BDA_PIN_TYPE
} KSPROPERTY_BDA_PIN_CONTROL;

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_ID,\
        (GetHandler),\
        sizeof( KSPROPERTY),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_TYPE,\
        (GetHandler),\
        sizeof( KSPROPERTY),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Pin Event Set
//
// {104781CD-50BD-40d5-95FB-087E0E86A591}
//
#define STATIC_KSEVENTSETID_BdaPinEvent \
    0x104781cd, 0x50bd, 0x40d5, 0x95, 0xfb, 0x08, 0x7e, 0xe, 0x86, 0xa5, 0x91
DEFINE_GUIDSTRUCT("104781CD-50BD-40d5-95FB-087E0E86A591", KSEVENTSETID_BdaPinEvent);
#define KSEVENTSETID_BdaPinEvent DEFINE_GUIDNAMED(KSEVENTSETID_BdaPinEvent)

typedef enum {
    KSEVENT_BDA_PIN_CONNECTED = 0,
    KSEVENT_BDA_PIN_DISCONNECTED
} KSPROPERTY_BDA_PIN_EVENT;

#define DEFINE_KSEVENT_ITEM_BDA_PIN_CONNECTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PIN_CONNECTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_ITEM_BDA_PIN_DISCONNECTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PIN_DISCONNECTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )



//------------------------------------------------------------
//
//
//  BDA Void Transform Property Set
//
// {71985F46-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaVoidTransform \
    0x71985f46, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F46-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaVoidTransform);
#define KSPROPSETID_BdaVoidTransform DEFINE_GUIDNAMED(KSPROPSETID_BdaVoidTransform)

typedef enum {
    KSPROPERTY_BDA_VOID_TRANSFORM_START = 0,
    KSPROPERTY_BDA_VOID_TRANSFORM_STOP
} KSPROPERTY_BDA_VOID_TRANSFORM;

#define DEFINE_KSPROPERTY_ITEM_BDA_VOID_TRANSFORM_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_VOID_TRANSFORM_START,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_VOID_TRANSFORM_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_VOID_TRANSFORM_STOP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Null Transform Property Set
//
// {DDF15B0D-BD25-11d2-9CA0-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaNullTransform \
    0xddf15b0d, 0xbd25, 0x11d2, 0x9c, 0xa0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("DDF15B0D-BD25-11d2-9CA0-00C04F7971E0", KSPROPSETID_BdaNullTransform);
#define KSPROPSETID_BdaNullTransform DEFINE_GUIDNAMED(KSPROPSETID_BdaNullTransform)

typedef enum {
    KSPROPERTY_BDA_NULL_TRANSFORM_START = 0,
    KSPROPERTY_BDA_NULL_TRANSFORM_STOP
} KSPROPERTY_BDA_NULL_TRANSFORM;

#define DEFINE_KSPROPERTY_ITEM_BDA_NULL_TRANSFORM_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NULL_TRANSFORM_START,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NULL_TRANSFORM_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NULL_TRANSFORM_STOP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Frequency Filter Property Set
//
// {71985F47-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaFrequencyFilter \
    0x71985f47, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F47-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaFrequencyFilter);
#define KSPROPSETID_BdaFrequencyFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaFrequencyFilter)

typedef enum {
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY = 0,
    KSPROPERTY_BDA_RF_TUNER_POLARITY,
    KSPROPERTY_BDA_RF_TUNER_RANGE,
    KSPROPERTY_BDA_RF_TUNER_TRANSPONDER,
    KSPROPERTY_BDA_RF_TUNER_BANDWIDTH,
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER
} KSPROPERTY_BDA_FREQUENCY_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_FREQUENCY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_POLARITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_POLARITY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_RANGE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_RANGE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_TRANSPONDER(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_TRANSPONDER,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_BANDWIDTH(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_BANDWIDTH,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY_MULTIPLIER(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA LNB Info Property Set
//
// {992CF102-49F9-4719-A664-C4F23E2408F4}
//
#define STATIC_KSPROPSETID_BdaLNBInfo \
    0x992cf102, 0x49f9, 0x4719, 0xa6, 0x64, 0xc4, 0xf2, 0x3e, 0x24, 0x8, 0xf4
DEFINE_GUIDSTRUCT("992CF102-49F9-4719-A664-C4F23E2408F4", KSPROPSETID_BdaLNBInfo);
#define KSPROPSETID_BdaLNBInfo DEFINE_GUIDNAMED(KSPROPSETID_BdaLNBInfo)

typedef enum {
    KSPROPERTY_BDA_LNB_LOF_LOW_BAND = 0,
    KSPROPERTY_BDA_LNB_LOF_HIGH_BAND,
    KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY
} KSPROPERTY_BDA_LNB_INFO;

#define DEFINE_KSPROPERTY_ITEM_BDA_LNB_LOF_LOW_BAND(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_LNB_LOF_LOW_BAND,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_LNB_LOF_HIGH_BAND(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_LNB_LOF_HIGH_BAND,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_LNB_SWITCH_FREQUENCY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Digital Demodulator Property Set
//
// {EF30F379-985B-4d10-B640-A79D5E04E1E0}
//
#define STATIC_KSPROPSETID_BdaDigitalDemodulator \
    0xef30f379, 0x985b, 0x4d10, 0xb6, 0x40, 0xa7, 0x9d, 0x5e, 0x4, 0xe1, 0xe0
DEFINE_GUIDSTRUCT("EF30F379-985B-4d10-B640-A79D5E04E1E0", KSPROPSETID_BdaDigitalDemodulator);
#define KSPROPSETID_BdaDigitalDemodulator DEFINE_GUIDNAMED(KSPROPSETID_BdaDigitalDemodulator)

typedef enum {
    KSPROPERTY_BDA_MODULATION_TYPE = 0,
    KSPROPERTY_BDA_INNER_FEC_TYPE,
    KSPROPERTY_BDA_INNER_FEC_RATE,
    KSPROPERTY_BDA_OUTER_FEC_TYPE,
    KSPROPERTY_BDA_OUTER_FEC_RATE,
    KSPROPERTY_BDA_SYMBOL_RATE,
    KSPROPERTY_BDA_SPECTRAL_INVERSION,
    KSPROPERTY_BDA_GUARD_INTERVAL,
    KSPROPERTY_BDA_TRANSMISSION_MODE
} KSPROPERTY_BDA_DIGITAL_DEMODULATOR;

#define DEFINE_KSPROPERTY_ITEM_BDA_MODULATION_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_MODULATION_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ModulationType),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_INNER_FEC_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(FECMethod),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_INNER_FEC_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BinaryConvolutionCodeRate),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_OUTER_FEC_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(FECMethod),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_OUTER_FEC_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BinaryConvolutionCodeRate),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SYMBOL_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SYMBOL_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SPECTRAL_INVERSION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SPECTRAL_INVERSION,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(SpectralInversion),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_GUARD_INTERVAL(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_GUARD_INTERVAL,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(GuardInterval),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_TRANSMISSION_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TRANSMISSION_MODE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(TransmissionMode),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Autodemodulate Property Set
//
// {DDF15B12-BD25-11d2-9CA0-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaAutodemodulate \
    0xddf15b12, 0xbd25, 0x11d2, 0x9c, 0xa0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("DDF15B12-BD25-11d2-9CA0-00C04F7971E0", KSPROPSETID_BdaAutodemodulate);
#define KSPROPSETID_BdaAutodemodulate DEFINE_GUIDNAMED(KSPROPSETID_BdaAutodemodulate)

typedef enum {
    KSPROPERTY_BDA_AUTODEMODULATE_START = 0,
    KSPROPERTY_BDA_AUTODEMODULATE_STOP
} KSPROPERTY_BDA_AUTODEMODULATE;

#define DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_AUTODEMODULATE_START,\
        FALSE,\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_AUTODEMODULATE_STOP,\
        FALSE,\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//------------------------------------------------------------
//
//
//  BDA Table Section Property Set
//
// {516B99C5-971C-4aaf-B3F3-D9FDA8A15E16}
//

#define STATIC_KSPROPSETID_BdaTableSection \
    0x516b99c5, 0x971c, 0x4aaf, 0xb3, 0xf3, 0xd9, 0xfd, 0xa8, 0xa1, 0x5e, 0x16
DEFINE_GUIDSTRUCT("516B99C5-971C-4aaf-B3F3-D9FDA8A15E16", KSPROPSETID_BdaTableSection);
#define KSPROPSETID_BdaTableSection DEFINE_GUIDNAMED(KSPROPSETID_BdaTableSection)

typedef enum {
    KSPROPERTY_BDA_TABLE_SECTION = 0,
} KSPROPERTY_IDS_BDA_TABLE;

#define DEFINE_KSPROPERTY_ITEM_BDA_TABLE_SECTION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TABLE_SECTION,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_TABLE_SECTION),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA PID Filter Property Set
//
// {D0A67D65-08DF-4fec-8533-E5B550410B85}
//
#define STATIC_KSPROPSETID_BdaPIDFilter \
    0xd0a67d65, 0x8df, 0x4fec, 0x85, 0x33, 0xe5, 0xb5, 0x50, 0x41, 0xb, 0x85
DEFINE_GUIDSTRUCT("D0A67D65-08DF-4fec-8533-E5B550410B85", KSPROPSETID_BdaPIDFilter);
#define KSPROPSETID_BdaPIDFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaPIDFilter)

typedef enum {
    KSPROPERTY_BDA_PIDFILTER_MAP_PIDS = 0,
    KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS,
    KSPROPERTY_BDA_PIDFILTER_LIST_PIDS
} KSPROPERTY_BDA_PIDFILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_MAP_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_MAP_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PID_MAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_UNMAP_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PID_UNMAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_LIST_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_LIST_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA CA Property Set
//
// {B0693766-5278-4ec6-B9E1-3CE40560EF5A}
//
#define STATIC_KSPROPSETID_BdaCA \
    0xb0693766, 0x5278, 0x4ec6, 0xb9, 0xe1, 0x3c, 0xe4, 0x5, 0x60, 0xef, 0x5a
DEFINE_GUIDSTRUCT("B0693766-5278-4ec6-B9E1-3CE40560EF5A", KSPROPSETID_BdaCA);
#define KSPROPSETID_BdaCA DEFINE_GUIDNAMED(KSPROPSETID_BdaCA)

typedef enum {
    KSPROPERTY_BDA_ECM_MAP_STATUS = 0,
    KSPROPERTY_BDA_CA_MODULE_STATUS,
    KSPROPERTY_BDA_CA_SMART_CARD_STATUS,
    KSPROPERTY_BDA_CA_MODULE_UI,
    KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS,
    KSPROPERTY_BDA_CA_REMOVE_PROGRAM
} KSPROPERTY_BDA_CA;

#define DEFINE_KSPROPERTY_ITEM_BDA_ECM_MAP_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECM_MAP_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_MODULE_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_SMART_CARD_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_SMART_CARD_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_UI(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_MODULE_UI,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_CA_MODULE_UI),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_SET_PROGRAM_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PROGRAM_PID_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_REMOVE_PROGRAM(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_REMOVE_PROGRAM,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA CA Event Set
//
// {488C4CCC-B768-4129-8EB1-B00A071F9068}
//
#define STATIC_KSEVENTSETID_BdaCAEvent \
    0x488c4ccc, 0xb768, 0x4129, 0x8e, 0xb1, 0xb0, 0xa, 0x7, 0x1f, 0x90, 0x68
DEFINE_GUIDSTRUCT("488C4CCC-B768-4129-8EB1-B00A071F9068", KSEVENTSETID_BdaCAEvent);
#define KSEVENTSETID_BdaCAEvent DEFINE_GUIDNAMED(KSEVENTSETID_BdaCAEvent)

typedef enum {
    KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED = 0,
    KSEVENT_BDA_CA_MODULE_STATUS_CHANGED,
    KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED,
    KSEVENT_BDA_CA_MODULE_UI_REQUESTED
} KSPROPERTY_BDA_CA_EVENT;

#define DEFINE_KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_MODULE_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_MODULE_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_MODULE_UI_REQUESTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_MODULE_UI_REQUESTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )


//===========================================================================
//
// BDA Filter Categories
//
//===========================================================================

#define STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT \
    0xFD0A5AF4, 0xB41D, 0x11d2, 0x9c, 0x95, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("FD0A5AF4-B41D-11d2-9C95-00C04F7971E0", KSCATEGORY_BDA_RECEIVER_COMPONENT);
#define KSCATEGORY_BDA_RECEIVER_COMPONENT DEFINE_GUIDNAMED(KSCATEGORY_BDA_RECEIVER_COMPONENT)


#define STATIC_KSCATEGORY_BDA_NETWORK_TUNER \
    0x71985f48, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F48-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_TUNER);
#define KSCATEGORY_BDA_NETWORK_TUNER DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_TUNER)


#define STATIC_KSCATEGORY_BDA_NETWORK_EPG \
    0x71985f49, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F49-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_EPG);
#define KSCATEGORY_BDA_NETWORK_EPG DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_EPG)


#define STATIC_KSCATEGORY_BDA_IP_SINK \
    0x71985f4aL, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4A-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_IP_SINK);
#define KSCATEGORY_IP_SINK DEFINE_GUIDNAMED(KSCATEGORY_BDA_IP_SINK)


#define STATIC_KSCATEGORY_BDA_NETWORK_PROVIDER \
    0x71985f4b, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4B-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_PROVIDER);
#define KSCATEGORY_BDA_NETWORK_PROVIDER DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_PROVIDER)

// {A2E3074F-6C3D-11d3-B653-00C04F79498E}
#define STATIC_KSCATEGORY_BDA_TRANSPORT_INFORMATION \
        0xa2e3074f, 0x6c3d, 0x11d3, 0xb6, 0x53, 0x0, 0xc0, 0x4f, 0x79, 0x49, 0x8e
DEFINE_GUIDSTRUCT("A2E3074F-6C3D-11d3-B653-00C04F79498E", KSCATEGORY_BDA_TRANSPORT_INFORMATION);
#define KSCATEGORY_BDA_TRANSPORT_INFORMATION DEFINE_GUIDNAMED(KSCATEGORY_BDA_TRANSPORT_INFORMATION)

//===========================================================================
//
// BDA Node Categories
//
//===========================================================================


#define STATIC_KSNODE_BDA_RF_TUNER \
    0x71985f4c, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4C-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_RF_TUNER);
#define KSNODE_BDA_RF_TUNER DEFINE_GUIDNAMED(KSNODE_BDA_RF_TUNER)


#define STATIC_KSNODE_BDA_QAM_DEMODULATOR \
    0x71985f4d, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4D-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_QAM_DEMODULATOR);
#define KSNODE_BDA_QAM_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_QAM_DEMODULATOR)


#define STATIC_KSNODE_BDA_QPSK_DEMODULATOR \
    0x6390c905, 0x27c1, 0x4d67, 0xbd, 0xb7, 0x77, 0xc5, 0xd, 0x7, 0x93, 0x0
DEFINE_GUIDSTRUCT("6390C905-27C1-4d67-BDB7-77C50D079300", KSNODE_BDA_QPSK_DEMODULATOR);
#define KSNODE_BDA_QPSK_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_QPSK_DEMODULATOR)


#define STATIC_KSNODE_BDA_8VSB_DEMODULATOR \
    0x71985f4f, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4F-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_8VSB_DEMODULATOR);
#define KSNODE_BDA_8VSB_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_8VSB_DEMODULATOR)


#define STATIC_KSNODE_BDA_COFDM_DEMODULATOR \
    0x2dac6e05, 0xedbe, 0x4b9c, 0xb3, 0x87, 0x1b, 0x6f, 0xad, 0x7d, 0x64, 0x95
DEFINE_GUIDSTRUCT("2DAC6E05-EDBE-4b9c-B387-1B6FAD7D6495", KSNODE_BDA_COFDM_DEMODULATOR);
#define KSNODE_BDA_COFDM_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_COFDM_DEMODULATOR)


#define STATIC_KSNODE_BDA_OPENCABLE_POD \
    0xd83ef8fc, 0xf3b8, 0x45ab, 0x8b, 0x71, 0xec, 0xf7, 0xc3, 0x39, 0xde, 0xb4
DEFINE_GUIDSTRUCT("D83EF8FC-F3B8-45ab-8B71-ECF7C339DEB4", KSNODE_BDA_OPENCABLE_POD);
#define KSNODE_BDA_OPENCABLE_POD DEFINE_GUIDNAMED(KSNODE_BDA_OPENCABLE_POD)


#define STATIC_KSNODE_BDA_COMMON_CA_POD \
    0xd83ef8fc, 0xf3b8, 0x45ab, 0x8b, 0x71, 0xec, 0xf7, 0xc3, 0x39, 0xde, 0xb4
DEFINE_GUIDSTRUCT("D83EF8FC-F3B8-45ab-8B71-ECF7C339DEB4", KSNODE_BDA_COMMON_CA_POD);
#define KSNODE_BDA_COMMON_CA_POD DEFINE_GUIDNAMED(KSNODE_BDA_COMMON_CA_POD)


#define STATIC_KSNODE_BDA_PID_FILTER \
    0xf5412789, 0xb0a0, 0x44e1, 0xae, 0x4f, 0xee, 0x99, 0x9b, 0x1b, 0x7f, 0xbe
DEFINE_GUIDSTRUCT("F5412789-B0A0-44e1-AE4F-EE999B1B7FBE", KSNODE_BDA_PID_FILTER);
#define KSNODE_BDA_PID_FILTER DEFINE_GUIDNAMED(KSNODE_BDA_PID_FILTER)


#define STATIC_KSNODE_BDA_IP_SINK \
    0x71985f4e, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4E-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_IP_SINK);
#define KSNODE_IP_SINK DEFINE_GUIDNAMED(KSNODE_BDA_IP_SINK)


//===========================================================================
//
// IPSink PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


//===========================================================================
//
// BDA IPSink Categories/Types
//
//===========================================================================


#define STATIC_KSDATAFORMAT_TYPE_BDA_IP\
    0xe25f7b8e, 0xcccc, 0x11d2, 0x8f, 0x25, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("e25f7b8e-cccc-11d2-8f25-00c04f7971e2", KSDATAFORMAT_TYPE_BDA_IP);
#define KSDATAFORMAT_TYPE_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IP)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP\
    0x5a9a213c, 0xdb08, 0x11d2, 0x8f, 0x32, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("5a9a213c-db08-11d2-8f32-00c04f7971e2", KSDATAFORMAT_SUBTYPE_BDA_IP);
#define KSDATAFORMAT_SUBTYPE_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_IP)

#define STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP\
    0x6b891420, 0xdb09, 0x11d2, 0x8f, 0x32, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("6B891420-DB09-11d2-8F32-00C04F7971E2", KSDATAFORMAT_SPECIFIER_BDA_IP);
#define KSDATAFORMAT_SPECIFIER_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_BDA_IP)



#define STATIC_KSDATAFORMAT_TYPE_BDA_IP_CONTROL\
    0xdadd5799, 0x7d5b, 0x4b63, 0x80, 0xfb, 0xd1, 0x44, 0x2f, 0x26, 0xb6, 0x21
DEFINE_GUIDSTRUCT("DADD5799-7D5B-4b63-80FB-D1442F26B621", KSDATAFORMAT_TYPE_BDA_IP_CONTROL);
#define KSDATAFORMAT_TYPE_BDA_IP_CONTROL  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IP_CONTROL)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL\
    0x499856e8, 0xe85b, 0x48ed, 0x9b, 0xea, 0x41, 0xd, 0xd, 0xd4, 0xef, 0x81
DEFINE_GUIDSTRUCT("499856E8-E85B-48ed-9BEA-410D0DD4EF81", KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL);
#define KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL  DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL)


//===========================================================================
//
// MPE PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_MPE \
    0xc1b06d73L, 0x1dbb, 0x11d3, 0x8f, 0x46, 0x00, 0xC0, 0x4f, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("C1B06D73-1DBB-11d3-8F46-00C04F7971E2", PINNAME_MPE);
#define PINNAME_MPE   DEFINE_GUIDNAMED(PINNAME_MPE)


/////////////////////////////////////////////////////////////
//
// BDA MPE Categories/Types
//
#define STATIC_KSDATAFORMAT_TYPE_MPE \
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5
DEFINE_GUIDSTRUCT("455F176C-4B06-47ce-9AEF-8CAEF73DF7B5", KSDATAFORMAT_TYPE_MPE);
#define KSDATAFORMAT_TYPE_MPE  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPE)


#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !defined(_BDAMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\control.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for control.odl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __control_h__
#define __control_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMCollection_FWD_DEFINED__
#define __IAMCollection_FWD_DEFINED__
typedef interface IAMCollection IAMCollection;
#endif 	/* __IAMCollection_FWD_DEFINED__ */


#ifndef __IMediaControl_FWD_DEFINED__
#define __IMediaControl_FWD_DEFINED__
typedef interface IMediaControl IMediaControl;
#endif 	/* __IMediaControl_FWD_DEFINED__ */


#ifndef __IMediaEvent_FWD_DEFINED__
#define __IMediaEvent_FWD_DEFINED__
typedef interface IMediaEvent IMediaEvent;
#endif 	/* __IMediaEvent_FWD_DEFINED__ */


#ifndef __IMediaEventEx_FWD_DEFINED__
#define __IMediaEventEx_FWD_DEFINED__
typedef interface IMediaEventEx IMediaEventEx;
#endif 	/* __IMediaEventEx_FWD_DEFINED__ */


#ifndef __IMediaPosition_FWD_DEFINED__
#define __IMediaPosition_FWD_DEFINED__
typedef interface IMediaPosition IMediaPosition;
#endif 	/* __IMediaPosition_FWD_DEFINED__ */


#ifndef __IBasicAudio_FWD_DEFINED__
#define __IBasicAudio_FWD_DEFINED__
typedef interface IBasicAudio IBasicAudio;
#endif 	/* __IBasicAudio_FWD_DEFINED__ */


#ifndef __IVideoWindow_FWD_DEFINED__
#define __IVideoWindow_FWD_DEFINED__
typedef interface IVideoWindow IVideoWindow;
#endif 	/* __IVideoWindow_FWD_DEFINED__ */


#ifndef __IBasicVideo_FWD_DEFINED__
#define __IBasicVideo_FWD_DEFINED__
typedef interface IBasicVideo IBasicVideo;
#endif 	/* __IBasicVideo_FWD_DEFINED__ */


#ifndef __IBasicVideo2_FWD_DEFINED__
#define __IBasicVideo2_FWD_DEFINED__
typedef interface IBasicVideo2 IBasicVideo2;
#endif 	/* __IBasicVideo2_FWD_DEFINED__ */


#ifndef __IDeferredCommand_FWD_DEFINED__
#define __IDeferredCommand_FWD_DEFINED__
typedef interface IDeferredCommand IDeferredCommand;
#endif 	/* __IDeferredCommand_FWD_DEFINED__ */


#ifndef __IQueueCommand_FWD_DEFINED__
#define __IQueueCommand_FWD_DEFINED__
typedef interface IQueueCommand IQueueCommand;
#endif 	/* __IQueueCommand_FWD_DEFINED__ */


#ifndef __FilgraphManager_FWD_DEFINED__
#define __FilgraphManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class FilgraphManager FilgraphManager;
#else
typedef struct FilgraphManager FilgraphManager;
#endif /* __cplusplus */

#endif 	/* __FilgraphManager_FWD_DEFINED__ */


#ifndef __IFilterInfo_FWD_DEFINED__
#define __IFilterInfo_FWD_DEFINED__
typedef interface IFilterInfo IFilterInfo;
#endif 	/* __IFilterInfo_FWD_DEFINED__ */


#ifndef __IRegFilterInfo_FWD_DEFINED__
#define __IRegFilterInfo_FWD_DEFINED__
typedef interface IRegFilterInfo IRegFilterInfo;
#endif 	/* __IRegFilterInfo_FWD_DEFINED__ */


#ifndef __IMediaTypeInfo_FWD_DEFINED__
#define __IMediaTypeInfo_FWD_DEFINED__
typedef interface IMediaTypeInfo IMediaTypeInfo;
#endif 	/* __IMediaTypeInfo_FWD_DEFINED__ */


#ifndef __IPinInfo_FWD_DEFINED__
#define __IPinInfo_FWD_DEFINED__
typedef interface IPinInfo IPinInfo;
#endif 	/* __IPinInfo_FWD_DEFINED__ */


#ifndef __IAMStats_FWD_DEFINED__
#define __IAMStats_FWD_DEFINED__
typedef interface IAMStats IAMStats;
#endif 	/* __IAMStats_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __QuartzTypeLib_LIBRARY_DEFINED__
#define __QuartzTypeLib_LIBRARY_DEFINED__

/* library QuartzTypeLib */
/* [version][lcid][helpstring][uuid] */ 

typedef double REFTIME;

typedef LONG_PTR OAEVENT;

typedef LONG_PTR OAHWND;

typedef long OAFilterState;


DEFINE_GUID(LIBID_QuartzTypeLib,0x56a868b0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifndef __IAMCollection_INTERFACE_DEFINED__
#define __IAMCollection_INTERFACE_DEFINED__

/* interface IAMCollection */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMCollection,0x56a868b9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b9-0ad4-11ce-b03a-0020af0ba770")
    IAMCollection : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lItem,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMCollection * This,
            /* [retval][out] */ LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IAMCollection * This,
            /* [in] */ long lItem,
            /* [out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IAMCollection * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IAMCollectionVtbl;

    interface IAMCollection
    {
        CONST_VTBL struct IAMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAMCollection_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IAMCollection_Item(This,lItem,ppUnk)	\
    (This)->lpVtbl -> Item(This,lItem,ppUnk)

#define IAMCollection_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IAMCollection_get_Count_Proxy( 
    IAMCollection * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IAMCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCollection_Item_Proxy( 
    IAMCollection * This,
    /* [in] */ long lItem,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IAMCollection_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IAMCollection_get__NewEnum_Proxy( 
    IAMCollection * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IAMCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMCollection_INTERFACE_DEFINED__ */


#ifndef __IMediaControl_INTERFACE_DEFINED__
#define __IMediaControl_INTERFACE_DEFINED__

/* interface IMediaControl */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b1-0ad4-11ce-b03a-0020af0ba770")
    IMediaControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ LONG msTimeout,
            /* [out] */ OAFilterState *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ BSTR strFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ BSTR strFilename,
            /* [out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterCollection( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegFilterCollection( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopWhenReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaControl * This,
            /* [in] */ LONG msTimeout,
            /* [out] */ OAFilterState *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IMediaControl * This,
            /* [in] */ BSTR strFilename);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IMediaControl * This,
            /* [in] */ BSTR strFilename,
            /* [out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegFilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *StopWhenReady )( 
            IMediaControl * This);
        
        END_INTERFACE
    } IMediaControlVtbl;

    interface IMediaControl
    {
        CONST_VTBL struct IMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaControl_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IMediaControl_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMediaControl_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMediaControl_GetState(This,msTimeout,pfs)	\
    (This)->lpVtbl -> GetState(This,msTimeout,pfs)

#define IMediaControl_RenderFile(This,strFilename)	\
    (This)->lpVtbl -> RenderFile(This,strFilename)

#define IMediaControl_AddSourceFilter(This,strFilename,ppUnk)	\
    (This)->lpVtbl -> AddSourceFilter(This,strFilename,ppUnk)

#define IMediaControl_get_FilterCollection(This,ppUnk)	\
    (This)->lpVtbl -> get_FilterCollection(This,ppUnk)

#define IMediaControl_get_RegFilterCollection(This,ppUnk)	\
    (This)->lpVtbl -> get_RegFilterCollection(This,ppUnk)

#define IMediaControl_StopWhenReady(This)	\
    (This)->lpVtbl -> StopWhenReady(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaControl_Run_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_Pause_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_Stop_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_GetState_Proxy( 
    IMediaControl * This,
    /* [in] */ LONG msTimeout,
    /* [out] */ OAFilterState *pfs);


void __RPC_STUB IMediaControl_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_RenderFile_Proxy( 
    IMediaControl * This,
    /* [in] */ BSTR strFilename);


void __RPC_STUB IMediaControl_RenderFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_AddSourceFilter_Proxy( 
    IMediaControl * This,
    /* [in] */ BSTR strFilename,
    /* [out] */ IDispatch **ppUnk);


void __RPC_STUB IMediaControl_AddSourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaControl_get_FilterCollection_Proxy( 
    IMediaControl * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IMediaControl_get_FilterCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaControl_get_RegFilterCollection_Proxy( 
    IMediaControl * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IMediaControl_get_RegFilterCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_StopWhenReady_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_StopWhenReady_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaControl_INTERFACE_DEFINED__ */


#ifndef __IMediaEvent_INTERFACE_DEFINED__
#define __IMediaEvent_INTERFACE_DEFINED__

/* interface IMediaEvent */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEvent,0x56a868b6,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b6-0ad4-11ce-b03a-0020af0ba770")
    IMediaEvent : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventHandle( 
            /* [out] */ OAEVENT *hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out] */ long *lEventCode,
            /* [out] */ LONG_PTR *lParam1,
            /* [out] */ LONG_PTR *lParam2,
            /* [in] */ long msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeEventParams( 
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEvent * This,
            /* [out] */ OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEvent * This,
            /* [out] */ long *lEventCode,
            /* [out] */ LONG_PTR *lParam1,
            /* [out] */ LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEvent * This,
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        END_INTERFACE
    } IMediaEventVtbl;

    interface IMediaEvent
    {
        CONST_VTBL struct IMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaEvent_GetEventHandle(This,hEvent)	\
    (This)->lpVtbl -> GetEventHandle(This,hEvent)

#define IMediaEvent_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)

#define IMediaEvent_WaitForCompletion(This,msTimeout,pEvCode)	\
    (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode)

#define IMediaEvent_CancelDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode)

#define IMediaEvent_RestoreDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode)

#define IMediaEvent_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaEvent_GetEventHandle_Proxy( 
    IMediaEvent * This,
    /* [out] */ OAEVENT *hEvent);


void __RPC_STUB IMediaEvent_GetEventHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_GetEvent_Proxy( 
    IMediaEvent * This,
    /* [out] */ long *lEventCode,
    /* [out] */ LONG_PTR *lParam1,
    /* [out] */ LONG_PTR *lParam2,
    /* [in] */ long msTimeout);


void __RPC_STUB IMediaEvent_GetEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_WaitForCompletion_Proxy( 
    IMediaEvent * This,
    /* [in] */ long msTimeout,
    /* [out] */ long *pEvCode);


void __RPC_STUB IMediaEvent_WaitForCompletion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_CancelDefaultHandling_Proxy( 
    IMediaEvent * This,
    /* [in] */ long lEvCode);


void __RPC_STUB IMediaEvent_CancelDefaultHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_RestoreDefaultHandling_Proxy( 
    IMediaEvent * This,
    /* [in] */ long lEvCode);


void __RPC_STUB IMediaEvent_RestoreDefaultHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_FreeEventParams_Proxy( 
    IMediaEvent * This,
    /* [in] */ long lEvCode,
    /* [in] */ LONG_PTR lParam1,
    /* [in] */ LONG_PTR lParam2);


void __RPC_STUB IMediaEvent_FreeEventParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaEvent_INTERFACE_DEFINED__ */


#ifndef __IMediaEventEx_INTERFACE_DEFINED__
#define __IMediaEventEx_INTERFACE_DEFINED__

/* interface IMediaEventEx */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEventEx,0x56a868c0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868c0-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventEx : public IMediaEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifyWindow( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyFlags( 
            /* [in] */ long lNoNotifyFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyFlags( 
            /* [out] */ long *lplNoNotifyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEventEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEventEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEventEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEventEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEventEx * This,
            /* [out] */ OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEventEx * This,
            /* [out] */ long *lEventCode,
            /* [out] */ LONG_PTR *lParam1,
            /* [out] */ LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEventEx * This,
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyWindow )( 
            IMediaEventEx * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyFlags )( 
            IMediaEventEx * This,
            /* [in] */ long lNoNotifyFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyFlags )( 
            IMediaEventEx * This,
            /* [out] */ long *lplNoNotifyFlags);
        
        END_INTERFACE
    } IMediaEventExVtbl;

    interface IMediaEventEx
    {
        CONST_VTBL struct IMediaEventExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaEventEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaEventEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaEventEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaEventEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaEventEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaEventEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaEventEx_GetEventHandle(This,hEvent)	\
    (This)->lpVtbl -> GetEventHandle(This,hEvent)

#define IMediaEventEx_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)

#define IMediaEventEx_WaitForCompletion(This,msTimeout,pEvCode)	\
    (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode)

#define IMediaEventEx_CancelDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode)

#define IMediaEventEx_RestoreDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode)

#define IMediaEventEx_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2)


#define IMediaEventEx_SetNotifyWindow(This,hwnd,lMsg,lInstanceData)	\
    (This)->lpVtbl -> SetNotifyWindow(This,hwnd,lMsg,lInstanceData)

#define IMediaEventEx_SetNotifyFlags(This,lNoNotifyFlags)	\
    (This)->lpVtbl -> SetNotifyFlags(This,lNoNotifyFlags)

#define IMediaEventEx_GetNotifyFlags(This,lplNoNotifyFlags)	\
    (This)->lpVtbl -> GetNotifyFlags(This,lplNoNotifyFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaEventEx_SetNotifyWindow_Proxy( 
    IMediaEventEx * This,
    /* [in] */ OAHWND hwnd,
    /* [in] */ long lMsg,
    /* [in] */ LONG_PTR lInstanceData);


void __RPC_STUB IMediaEventEx_SetNotifyWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEventEx_SetNotifyFlags_Proxy( 
    IMediaEventEx * This,
    /* [in] */ long lNoNotifyFlags);


void __RPC_STUB IMediaEventEx_SetNotifyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEventEx_GetNotifyFlags_Proxy( 
    IMediaEventEx * This,
    /* [out] */ long *lplNoNotifyFlags);


void __RPC_STUB IMediaEventEx_GetNotifyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaEventEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPosition_INTERFACE_DEFINED__
#define __IMediaPosition_INTERFACE_DEFINED__

/* interface IMediaPosition */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaPosition,0x56a868b2,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b2-0ad4-11ce-b03a-0020af0ba770")
    IMediaPosition : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ REFTIME *plength) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrerollTime( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrerollTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekForward( 
            /* [retval][out] */ LONG *pCanSeekForward) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekBackward( 
            /* [retval][out] */ LONG *pCanSeekBackward) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPosition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPosition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPosition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPosition * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPosition * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPosition * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPosition * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *plength);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrerollTime )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrerollTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPosition * This,
            /* [in] */ double dRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPosition * This,
            /* [retval][out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekForward )( 
            IMediaPosition * This,
            /* [retval][out] */ LONG *pCanSeekForward);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekBackward )( 
            IMediaPosition * This,
            /* [retval][out] */ LONG *pCanSeekBackward);
        
        END_INTERFACE
    } IMediaPositionVtbl;

    interface IMediaPosition
    {
        CONST_VTBL struct IMediaPositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaPosition_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaPosition_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaPosition_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaPosition_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaPosition_get_Duration(This,plength)	\
    (This)->lpVtbl -> get_Duration(This,plength)

#define IMediaPosition_put_CurrentPosition(This,llTime)	\
    (This)->lpVtbl -> put_CurrentPosition(This,llTime)

#define IMediaPosition_get_CurrentPosition(This,pllTime)	\
    (This)->lpVtbl -> get_CurrentPosition(This,pllTime)

#define IMediaPosition_get_StopTime(This,pllTime)	\
    (This)->lpVtbl -> get_StopTime(This,pllTime)

#define IMediaPosition_put_StopTime(This,llTime)	\
    (This)->lpVtbl -> put_StopTime(This,llTime)

#define IMediaPosition_get_PrerollTime(This,pllTime)	\
    (This)->lpVtbl -> get_PrerollTime(This,pllTime)

#define IMediaPosition_put_PrerollTime(This,llTime)	\
    (This)->lpVtbl -> put_PrerollTime(This,llTime)

#define IMediaPosition_put_Rate(This,dRate)	\
    (This)->lpVtbl -> put_Rate(This,dRate)

#define IMediaPosition_get_Rate(This,pdRate)	\
    (This)->lpVtbl -> get_Rate(This,pdRate)

#define IMediaPosition_CanSeekForward(This,pCanSeekForward)	\
    (This)->lpVtbl -> CanSeekForward(This,pCanSeekForward)

#define IMediaPosition_CanSeekBackward(This,pCanSeekBackward)	\
    (This)->lpVtbl -> CanSeekBackward(This,pCanSeekBackward)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_Duration_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *plength);


void __RPC_STUB IMediaPosition_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_CurrentPosition_Proxy( 
    IMediaPosition * This,
    /* [in] */ REFTIME llTime);


void __RPC_STUB IMediaPosition_put_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_CurrentPosition_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *pllTime);


void __RPC_STUB IMediaPosition_get_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_StopTime_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *pllTime);


void __RPC_STUB IMediaPosition_get_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_StopTime_Proxy( 
    IMediaPosition * This,
    /* [in] */ REFTIME llTime);


void __RPC_STUB IMediaPosition_put_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_PrerollTime_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *pllTime);


void __RPC_STUB IMediaPosition_get_PrerollTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_PrerollTime_Proxy( 
    IMediaPosition * This,
    /* [in] */ REFTIME llTime);


void __RPC_STUB IMediaPosition_put_PrerollTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_Rate_Proxy( 
    IMediaPosition * This,
    /* [in] */ double dRate);


void __RPC_STUB IMediaPosition_put_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_Rate_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ double *pdRate);


void __RPC_STUB IMediaPosition_get_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaPosition_CanSeekForward_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ LONG *pCanSeekForward);


void __RPC_STUB IMediaPosition_CanSeekForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaPosition_CanSeekBackward_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ LONG *pCanSeekBackward);


void __RPC_STUB IMediaPosition_CanSeekBackward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPosition_INTERFACE_DEFINED__ */


#ifndef __IBasicAudio_INTERFACE_DEFINED__
#define __IBasicAudio_INTERFACE_DEFINED__

/* interface IBasicAudio */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicAudio,0x56a868b3,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b3-0ad4-11ce-b03a-0020af0ba770")
    IBasicAudio : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long *plVolume) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicAudio * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicAudio * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicAudio * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicAudio * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicAudio * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IBasicAudio * This,
            /* [in] */ long lVolume);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IBasicAudio * This,
            /* [retval][out] */ long *plVolume);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IBasicAudio * This,
            /* [in] */ long lBalance);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IBasicAudio * This,
            /* [retval][out] */ long *plBalance);
        
        END_INTERFACE
    } IBasicAudioVtbl;

    interface IBasicAudio
    {
        CONST_VTBL struct IBasicAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicAudio_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicAudio_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasicAudio_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasicAudio_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicAudio_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicAudio_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicAudio_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicAudio_put_Volume(This,lVolume)	\
    (This)->lpVtbl -> put_Volume(This,lVolume)

#define IBasicAudio_get_Volume(This,plVolume)	\
    (This)->lpVtbl -> get_Volume(This,plVolume)

#define IBasicAudio_put_Balance(This,lBalance)	\
    (This)->lpVtbl -> put_Balance(This,lBalance)

#define IBasicAudio_get_Balance(This,plBalance)	\
    (This)->lpVtbl -> get_Balance(This,plBalance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicAudio_put_Volume_Proxy( 
    IBasicAudio * This,
    /* [in] */ long lVolume);


void __RPC_STUB IBasicAudio_put_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicAudio_get_Volume_Proxy( 
    IBasicAudio * This,
    /* [retval][out] */ long *plVolume);


void __RPC_STUB IBasicAudio_get_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicAudio_put_Balance_Proxy( 
    IBasicAudio * This,
    /* [in] */ long lBalance);


void __RPC_STUB IBasicAudio_put_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicAudio_get_Balance_Proxy( 
    IBasicAudio * This,
    /* [retval][out] */ long *plBalance);


void __RPC_STUB IBasicAudio_get_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasicAudio_INTERFACE_DEFINED__ */


#ifndef __IVideoWindow_INTERFACE_DEFINED__
#define __IVideoWindow_INTERFACE_DEFINED__

/* interface IVideoWindow */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IVideoWindow,0x56a868b4,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b4-0ad4-11ce-b03a-0020af0ba770")
    IVideoWindow : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR strCaption) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR *strCaption) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyle( 
            /* [in] */ long WindowStyle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyle( 
            /* [retval][out] */ long *WindowStyle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyleEx( 
            /* [in] */ long WindowStyleEx) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyleEx( 
            /* [retval][out] */ long *WindowStyleEx) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoShow( 
            /* [in] */ long AutoShow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AutoShow( 
            /* [retval][out] */ long *AutoShow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ long WindowState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ long *WindowState) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundPalette( 
            /* [in] */ long BackgroundPalette) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundPalette( 
            /* [retval][out] */ long *pBackgroundPalette) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ long Visible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ long *pVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long *pLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long *pTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ OAHWND Owner) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ OAHWND *Owner) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MessageDrain( 
            /* [in] */ OAHWND Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessageDrain( 
            /* [retval][out] */ OAHWND *Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ long *Color) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long Color) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FullScreenMode( 
            /* [retval][out] */ long *FullScreenMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FullScreenMode( 
            /* [in] */ long FullScreenMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowForeground( 
            /* [in] */ long Focus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOwnerMessage( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowPosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealImageSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealImageSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestorePosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideCursor( 
            /* [in] */ long HideCursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCursorHidden( 
            /* [out] */ long *CursorHidden) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoWindow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoWindow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IVideoWindow * This,
            /* [in] */ BSTR strCaption);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IVideoWindow * This,
            /* [retval][out] */ BSTR *strCaption);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyle )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyle )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowStyle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyleEx )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyleEx);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyleEx )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowStyleEx);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoShow )( 
            IVideoWindow * This,
            /* [in] */ long AutoShow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoShow )( 
            IVideoWindow * This,
            /* [retval][out] */ long *AutoShow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowState )( 
            IVideoWindow * This,
            /* [in] */ long WindowState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowState )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowState);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundPalette )( 
            IVideoWindow * This,
            /* [in] */ long BackgroundPalette);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundPalette )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pBackgroundPalette);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IVideoWindow * This,
            /* [in] */ long Visible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IVideoWindow * This,
            /* [in] */ long Left);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IVideoWindow * This,
            /* [in] */ long Width);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IVideoWindow * This,
            /* [in] */ long Top);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IVideoWindow * This,
            /* [in] */ long Height);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Owner);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IVideoWindow * This,
            /* [retval][out] */ OAHWND *Owner);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageDrain )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDrain )( 
            IVideoWindow * This,
            /* [retval][out] */ OAHWND *Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IVideoWindow * This,
            /* [retval][out] */ long *Color);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IVideoWindow * This,
            /* [in] */ long Color);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IVideoWindow * This,
            /* [retval][out] */ long *FullScreenMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IVideoWindow * This,
            /* [in] */ long FullScreenMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowForeground )( 
            IVideoWindow * This,
            /* [in] */ long Focus);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOwnerMessage )( 
            IVideoWindow * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowPosition )( 
            IVideoWindow * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowPosition )( 
            IVideoWindow * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestorePosition )( 
            IVideoWindow * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *HideCursor )( 
            IVideoWindow * This,
            /* [in] */ long HideCursor);
        
        HRESULT ( STDMETHODCALLTYPE *IsCursorHidden )( 
            IVideoWindow * This,
            /* [out] */ long *CursorHidden);
        
        END_INTERFACE
    } IVideoWindowVtbl;

    interface IVideoWindow
    {
        CONST_VTBL struct IVideoWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVideoWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVideoWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVideoWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVideoWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVideoWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVideoWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVideoWindow_put_Caption(This,strCaption)	\
    (This)->lpVtbl -> put_Caption(This,strCaption)

#define IVideoWindow_get_Caption(This,strCaption)	\
    (This)->lpVtbl -> get_Caption(This,strCaption)

#define IVideoWindow_put_WindowStyle(This,WindowStyle)	\
    (This)->lpVtbl -> put_WindowStyle(This,WindowStyle)

#define IVideoWindow_get_WindowStyle(This,WindowStyle)	\
    (This)->lpVtbl -> get_WindowStyle(This,WindowStyle)

#define IVideoWindow_put_WindowStyleEx(This,WindowStyleEx)	\
    (This)->lpVtbl -> put_WindowStyleEx(This,WindowStyleEx)

#define IVideoWindow_get_WindowStyleEx(This,WindowStyleEx)	\
    (This)->lpVtbl -> get_WindowStyleEx(This,WindowStyleEx)

#define IVideoWindow_put_AutoShow(This,AutoShow)	\
    (This)->lpVtbl -> put_AutoShow(This,AutoShow)

#define IVideoWindow_get_AutoShow(This,AutoShow)	\
    (This)->lpVtbl -> get_AutoShow(This,AutoShow)

#define IVideoWindow_put_WindowState(This,WindowState)	\
    (This)->lpVtbl -> put_WindowState(This,WindowState)

#define IVideoWindow_get_WindowState(This,WindowState)	\
    (This)->lpVtbl -> get_WindowState(This,WindowState)

#define IVideoWindow_put_BackgroundPalette(This,BackgroundPalette)	\
    (This)->lpVtbl -> put_BackgroundPalette(This,BackgroundPalette)

#define IVideoWindow_get_BackgroundPalette(This,pBackgroundPalette)	\
    (This)->lpVtbl -> get_BackgroundPalette(This,pBackgroundPalette)

#define IVideoWindow_put_Visible(This,Visible)	\
    (This)->lpVtbl -> put_Visible(This,Visible)

#define IVideoWindow_get_Visible(This,pVisible)	\
    (This)->lpVtbl -> get_Visible(This,pVisible)

#define IVideoWindow_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IVideoWindow_get_Left(This,pLeft)	\
    (This)->lpVtbl -> get_Left(This,pLeft)

#define IVideoWindow_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IVideoWindow_get_Width(This,pWidth)	\
    (This)->lpVtbl -> get_Width(This,pWidth)

#define IVideoWindow_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IVideoWindow_get_Top(This,pTop)	\
    (This)->lpVtbl -> get_Top(This,pTop)

#define IVideoWindow_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IVideoWindow_get_Height(This,pHeight)	\
    (This)->lpVtbl -> get_Height(This,pHeight)

#define IVideoWindow_put_Owner(This,Owner)	\
    (This)->lpVtbl -> put_Owner(This,Owner)

#define IVideoWindow_get_Owner(This,Owner)	\
    (This)->lpVtbl -> get_Owner(This,Owner)

#define IVideoWindow_put_MessageDrain(This,Drain)	\
    (This)->lpVtbl -> put_MessageDrain(This,Drain)

#define IVideoWindow_get_MessageDrain(This,Drain)	\
    (This)->lpVtbl -> get_MessageDrain(This,Drain)

#define IVideoWindow_get_BorderColor(This,Color)	\
    (This)->lpVtbl -> get_BorderColor(This,Color)

#define IVideoWindow_put_BorderColor(This,Color)	\
    (This)->lpVtbl -> put_BorderColor(This,Color)

#define IVideoWindow_get_FullScreenMode(This,FullScreenMode)	\
    (This)->lpVtbl -> get_FullScreenMode(This,FullScreenMode)

#define IVideoWindow_put_FullScreenMode(This,FullScreenMode)	\
    (This)->lpVtbl -> put_FullScreenMode(This,FullScreenMode)

#define IVideoWindow_SetWindowForeground(This,Focus)	\
    (This)->lpVtbl -> SetWindowForeground(This,Focus)

#define IVideoWindow_NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)

#define IVideoWindow_SetWindowPosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetWindowPosition(This,Left,Top,Width,Height)

#define IVideoWindow_GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)

#define IVideoWindow_GetMinIdealImageSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetMinIdealImageSize(This,pWidth,pHeight)

#define IVideoWindow_GetMaxIdealImageSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetMaxIdealImageSize(This,pWidth,pHeight)

#define IVideoWindow_GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)

#define IVideoWindow_HideCursor(This,HideCursor)	\
    (This)->lpVtbl -> HideCursor(This,HideCursor)

#define IVideoWindow_IsCursorHidden(This,CursorHidden)	\
    (This)->lpVtbl -> IsCursorHidden(This,CursorHidden)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Caption_Proxy( 
    IVideoWindow * This,
    /* [in] */ BSTR strCaption);


void __RPC_STUB IVideoWindow_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Caption_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ BSTR *strCaption);


void __RPC_STUB IVideoWindow_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_WindowStyle_Proxy( 
    IVideoWindow * This,
    /* [in] */ long WindowStyle);


void __RPC_STUB IVideoWindow_put_WindowStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_WindowStyle_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *WindowStyle);


void __RPC_STUB IVideoWindow_get_WindowStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_WindowStyleEx_Proxy( 
    IVideoWindow * This,
    /* [in] */ long WindowStyleEx);


void __RPC_STUB IVideoWindow_put_WindowStyleEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_WindowStyleEx_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *WindowStyleEx);


void __RPC_STUB IVideoWindow_get_WindowStyleEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_AutoShow_Proxy( 
    IVideoWindow * This,
    /* [in] */ long AutoShow);


void __RPC_STUB IVideoWindow_put_AutoShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_AutoShow_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *AutoShow);


void __RPC_STUB IVideoWindow_get_AutoShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_WindowState_Proxy( 
    IVideoWindow * This,
    /* [in] */ long WindowState);


void __RPC_STUB IVideoWindow_put_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_WindowState_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *WindowState);


void __RPC_STUB IVideoWindow_get_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_BackgroundPalette_Proxy( 
    IVideoWindow * This,
    /* [in] */ long BackgroundPalette);


void __RPC_STUB IVideoWindow_put_BackgroundPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_BackgroundPalette_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pBackgroundPalette);


void __RPC_STUB IVideoWindow_get_BackgroundPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Visible_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Visible);


void __RPC_STUB IVideoWindow_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Visible_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pVisible);


void __RPC_STUB IVideoWindow_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Left_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Left);


void __RPC_STUB IVideoWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Left_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pLeft);


void __RPC_STUB IVideoWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Width_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Width);


void __RPC_STUB IVideoWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Width_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pWidth);


void __RPC_STUB IVideoWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Top_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Top);


void __RPC_STUB IVideoWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Top_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pTop);


void __RPC_STUB IVideoWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Height_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Height);


void __RPC_STUB IVideoWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Height_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pHeight);


void __RPC_STUB IVideoWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Owner_Proxy( 
    IVideoWindow * This,
    /* [in] */ OAHWND Owner);


void __RPC_STUB IVideoWindow_put_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Owner_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ OAHWND *Owner);


void __RPC_STUB IVideoWindow_get_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_MessageDrain_Proxy( 
    IVideoWindow * This,
    /* [in] */ OAHWND Drain);


void __RPC_STUB IVideoWindow_put_MessageDrain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_MessageDrain_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ OAHWND *Drain);


void __RPC_STUB IVideoWindow_get_MessageDrain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_BorderColor_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *Color);


void __RPC_STUB IVideoWindow_get_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_BorderColor_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Color);


void __RPC_STUB IVideoWindow_put_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_FullScreenMode_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *FullScreenMode);


void __RPC_STUB IVideoWindow_get_FullScreenMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_FullScreenMode_Proxy( 
    IVideoWindow * This,
    /* [in] */ long FullScreenMode);


void __RPC_STUB IVideoWindow_put_FullScreenMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_SetWindowForeground_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Focus);


void __RPC_STUB IVideoWindow_SetWindowForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_NotifyOwnerMessage_Proxy( 
    IVideoWindow * This,
    /* [in] */ OAHWND hwnd,
    /* [in] */ long uMsg,
    /* [in] */ LONG_PTR wParam,
    /* [in] */ LONG_PTR lParam);


void __RPC_STUB IVideoWindow_NotifyOwnerMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_SetWindowPosition_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Left,
    /* [in] */ long Top,
    /* [in] */ long Width,
    /* [in] */ long Height);


void __RPC_STUB IVideoWindow_SetWindowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetWindowPosition_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetWindowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetMinIdealImageSize_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetMinIdealImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetMaxIdealImageSize_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetMaxIdealImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetRestorePosition_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetRestorePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_HideCursor_Proxy( 
    IVideoWindow * This,
    /* [in] */ long HideCursor);


void __RPC_STUB IVideoWindow_HideCursor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_IsCursorHidden_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *CursorHidden);


void __RPC_STUB IVideoWindow_IsCursorHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVideoWindow_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo_INTERFACE_DEFINED__
#define __IBasicVideo_INTERFACE_DEFINED__

/* interface IBasicVideo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo,0x56a868b5,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b5-0ad4-11ce-b03a-0020af0ba770")
    IBasicVideo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AvgTimePerFrame( 
            /* [retval][out] */ REFTIME *pAvgTimePerFrame) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitRate( 
            /* [retval][out] */ long *pBitRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitErrorRate( 
            /* [retval][out] */ long *pBitErrorRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoWidth( 
            /* [retval][out] */ long *pVideoWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoHeight( 
            /* [retval][out] */ long *pVideoHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceLeft( 
            /* [in] */ long SourceLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceLeft( 
            /* [retval][out] */ long *pSourceLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceWidth( 
            /* [in] */ long SourceWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceWidth( 
            /* [retval][out] */ long *pSourceWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceTop( 
            /* [in] */ long SourceTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceTop( 
            /* [retval][out] */ long *pSourceTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceHeight( 
            /* [in] */ long SourceHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceHeight( 
            /* [retval][out] */ long *pSourceHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationLeft( 
            /* [in] */ long DestinationLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationLeft( 
            /* [retval][out] */ long *pDestinationLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationWidth( 
            /* [in] */ long DestinationWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationWidth( 
            /* [retval][out] */ long *pDestinationWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationTop( 
            /* [in] */ long DestinationTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationTop( 
            /* [retval][out] */ long *pDestinationTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationHeight( 
            /* [in] */ long DestinationHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationHeight( 
            /* [retval][out] */ long *pDestinationHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourcePosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSourcePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationPosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultDestinationPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPaletteEntries( 
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultSource( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultDestination( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo * This,
            /* [retval][out] */ REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo * This);
        
        END_INTERFACE
    } IBasicVideoVtbl;

    interface IBasicVideo
    {
        CONST_VTBL struct IBasicVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicVideo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasicVideo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasicVideo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicVideo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicVideo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicVideo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicVideo_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame)

#define IBasicVideo_get_BitRate(This,pBitRate)	\
    (This)->lpVtbl -> get_BitRate(This,pBitRate)

#define IBasicVideo_get_BitErrorRate(This,pBitErrorRate)	\
    (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate)

#define IBasicVideo_get_VideoWidth(This,pVideoWidth)	\
    (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth)

#define IBasicVideo_get_VideoHeight(This,pVideoHeight)	\
    (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight)

#define IBasicVideo_put_SourceLeft(This,SourceLeft)	\
    (This)->lpVtbl -> put_SourceLeft(This,SourceLeft)

#define IBasicVideo_get_SourceLeft(This,pSourceLeft)	\
    (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft)

#define IBasicVideo_put_SourceWidth(This,SourceWidth)	\
    (This)->lpVtbl -> put_SourceWidth(This,SourceWidth)

#define IBasicVideo_get_SourceWidth(This,pSourceWidth)	\
    (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth)

#define IBasicVideo_put_SourceTop(This,SourceTop)	\
    (This)->lpVtbl -> put_SourceTop(This,SourceTop)

#define IBasicVideo_get_SourceTop(This,pSourceTop)	\
    (This)->lpVtbl -> get_SourceTop(This,pSourceTop)

#define IBasicVideo_put_SourceHeight(This,SourceHeight)	\
    (This)->lpVtbl -> put_SourceHeight(This,SourceHeight)

#define IBasicVideo_get_SourceHeight(This,pSourceHeight)	\
    (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight)

#define IBasicVideo_put_DestinationLeft(This,DestinationLeft)	\
    (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft)

#define IBasicVideo_get_DestinationLeft(This,pDestinationLeft)	\
    (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft)

#define IBasicVideo_put_DestinationWidth(This,DestinationWidth)	\
    (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth)

#define IBasicVideo_get_DestinationWidth(This,pDestinationWidth)	\
    (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth)

#define IBasicVideo_put_DestinationTop(This,DestinationTop)	\
    (This)->lpVtbl -> put_DestinationTop(This,DestinationTop)

#define IBasicVideo_get_DestinationTop(This,pDestinationTop)	\
    (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop)

#define IBasicVideo_put_DestinationHeight(This,DestinationHeight)	\
    (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight)

#define IBasicVideo_get_DestinationHeight(This,pDestinationHeight)	\
    (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight)

#define IBasicVideo_SetSourcePosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height)

#define IBasicVideo_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo_SetDefaultSourcePosition(This)	\
    (This)->lpVtbl -> SetDefaultSourcePosition(This)

#define IBasicVideo_SetDestinationPosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height)

#define IBasicVideo_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo_SetDefaultDestinationPosition(This)	\
    (This)->lpVtbl -> SetDefaultDestinationPosition(This)

#define IBasicVideo_GetVideoSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight)

#define IBasicVideo_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)

#define IBasicVideo_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage)

#define IBasicVideo_IsUsingDefaultSource(This)	\
    (This)->lpVtbl -> IsUsingDefaultSource(This)

#define IBasicVideo_IsUsingDefaultDestination(This)	\
    (This)->lpVtbl -> IsUsingDefaultDestination(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_AvgTimePerFrame_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ REFTIME *pAvgTimePerFrame);


void __RPC_STUB IBasicVideo_get_AvgTimePerFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_BitRate_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pBitRate);


void __RPC_STUB IBasicVideo_get_BitRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_BitErrorRate_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pBitErrorRate);


void __RPC_STUB IBasicVideo_get_BitErrorRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_VideoWidth_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pVideoWidth);


void __RPC_STUB IBasicVideo_get_VideoWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_VideoHeight_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pVideoHeight);


void __RPC_STUB IBasicVideo_get_VideoHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceLeft_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceLeft);


void __RPC_STUB IBasicVideo_put_SourceLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceLeft_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceLeft);


void __RPC_STUB IBasicVideo_get_SourceLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceWidth_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceWidth);


void __RPC_STUB IBasicVideo_put_SourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceWidth_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceWidth);


void __RPC_STUB IBasicVideo_get_SourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceTop_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceTop);


void __RPC_STUB IBasicVideo_put_SourceTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceTop_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceTop);


void __RPC_STUB IBasicVideo_get_SourceTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceHeight_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceHeight);


void __RPC_STUB IBasicVideo_put_SourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceHeight_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceHeight);


void __RPC_STUB IBasicVideo_get_SourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationLeft_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationLeft);


void __RPC_STUB IBasicVideo_put_DestinationLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationLeft_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationLeft);


void __RPC_STUB IBasicVideo_get_DestinationLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationWidth_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationWidth);


void __RPC_STUB IBasicVideo_put_DestinationWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationWidth_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationWidth);


void __RPC_STUB IBasicVideo_get_DestinationWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationTop_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationTop);


void __RPC_STUB IBasicVideo_put_DestinationTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationTop_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationTop);


void __RPC_STUB IBasicVideo_get_DestinationTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationHeight_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationHeight);


void __RPC_STUB IBasicVideo_put_DestinationHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationHeight_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationHeight);


void __RPC_STUB IBasicVideo_get_DestinationHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetSourcePosition_Proxy( 
    IBasicVideo * This,
    /* [in] */ long Left,
    /* [in] */ long Top,
    /* [in] */ long Width,
    /* [in] */ long Height);


void __RPC_STUB IBasicVideo_SetSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetSourcePosition_Proxy( 
    IBasicVideo * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IBasicVideo_GetSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetDefaultSourcePosition_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_SetDefaultSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetDestinationPosition_Proxy( 
    IBasicVideo * This,
    /* [in] */ long Left,
    /* [in] */ long Top,
    /* [in] */ long Width,
    /* [in] */ long Height);


void __RPC_STUB IBasicVideo_SetDestinationPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetDestinationPosition_Proxy( 
    IBasicVideo * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IBasicVideo_GetDestinationPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetDefaultDestinationPosition_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_SetDefaultDestinationPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetVideoSize_Proxy( 
    IBasicVideo * This,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IBasicVideo_GetVideoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetVideoPaletteEntries_Proxy( 
    IBasicVideo * This,
    /* [in] */ long StartIndex,
    /* [in] */ long Entries,
    /* [out] */ long *pRetrieved,
    /* [out] */ long *pPalette);


void __RPC_STUB IBasicVideo_GetVideoPaletteEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetCurrentImage_Proxy( 
    IBasicVideo * This,
    /* [out][in] */ long *pBufferSize,
    /* [out] */ long *pDIBImage);


void __RPC_STUB IBasicVideo_GetCurrentImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_IsUsingDefaultSource_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_IsUsingDefaultSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_IsUsingDefaultDestination_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_IsUsingDefaultDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasicVideo_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo2_INTERFACE_DEFINED__
#define __IBasicVideo2_INTERFACE_DEFINED__

/* interface IBasicVideo2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo2,0x329bb360,0xf6ea,0x11d1,0x90,0x38,0x00,0xa0,0xc9,0x69,0x72,0x98);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("329bb360-f6ea-11d1-9038-00a0c9697298")
    IBasicVideo2 : public IBasicVideo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreferredAspectRatio( 
            /* [out] */ long *plAspectX,
            /* [out] */ long *plAspectY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo2 * This,
            /* [retval][out] */ REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo2 * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo2 * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo2 * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo2 * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferredAspectRatio )( 
            IBasicVideo2 * This,
            /* [out] */ long *plAspectX,
            /* [out] */ long *plAspectY);
        
        END_INTERFACE
    } IBasicVideo2Vtbl;

    interface IBasicVideo2
    {
        CONST_VTBL struct IBasicVideo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicVideo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasicVideo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasicVideo2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicVideo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicVideo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicVideo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicVideo2_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame)

#define IBasicVideo2_get_BitRate(This,pBitRate)	\
    (This)->lpVtbl -> get_BitRate(This,pBitRate)

#define IBasicVideo2_get_BitErrorRate(This,pBitErrorRate)	\
    (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate)

#define IBasicVideo2_get_VideoWidth(This,pVideoWidth)	\
    (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth)

#define IBasicVideo2_get_VideoHeight(This,pVideoHeight)	\
    (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight)

#define IBasicVideo2_put_SourceLeft(This,SourceLeft)	\
    (This)->lpVtbl -> put_SourceLeft(This,SourceLeft)

#define IBasicVideo2_get_SourceLeft(This,pSourceLeft)	\
    (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft)

#define IBasicVideo2_put_SourceWidth(This,SourceWidth)	\
    (This)->lpVtbl -> put_SourceWidth(This,SourceWidth)

#define IBasicVideo2_get_SourceWidth(This,pSourceWidth)	\
    (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth)

#define IBasicVideo2_put_SourceTop(This,SourceTop)	\
    (This)->lpVtbl -> put_SourceTop(This,SourceTop)

#define IBasicVideo2_get_SourceTop(This,pSourceTop)	\
    (This)->lpVtbl -> get_SourceTop(This,pSourceTop)

#define IBasicVideo2_put_SourceHeight(This,SourceHeight)	\
    (This)->lpVtbl -> put_SourceHeight(This,SourceHeight)

#define IBasicVideo2_get_SourceHeight(This,pSourceHeight)	\
    (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight)

#define IBasicVideo2_put_DestinationLeft(This,DestinationLeft)	\
    (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft)

#define IBasicVideo2_get_DestinationLeft(This,pDestinationLeft)	\
    (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft)

#define IBasicVideo2_put_DestinationWidth(This,DestinationWidth)	\
    (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth)

#define IBasicVideo2_get_DestinationWidth(This,pDestinationWidth)	\
    (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth)

#define IBasicVideo2_put_DestinationTop(This,DestinationTop)	\
    (This)->lpVtbl -> put_DestinationTop(This,DestinationTop)

#define IBasicVideo2_get_DestinationTop(This,pDestinationTop)	\
    (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop)

#define IBasicVideo2_put_DestinationHeight(This,DestinationHeight)	\
    (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight)

#define IBasicVideo2_get_DestinationHeight(This,pDestinationHeight)	\
    (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight)

#define IBasicVideo2_SetSourcePosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height)

#define IBasicVideo2_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo2_SetDefaultSourcePosition(This)	\
    (This)->lpVtbl -> SetDefaultSourcePosition(This)

#define IBasicVideo2_SetDestinationPosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height)

#define IBasicVideo2_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo2_SetDefaultDestinationPosition(This)	\
    (This)->lpVtbl -> SetDefaultDestinationPosition(This)

#define IBasicVideo2_GetVideoSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight)

#define IBasicVideo2_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)

#define IBasicVideo2_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage)

#define IBasicVideo2_IsUsingDefaultSource(This)	\
    (This)->lpVtbl -> IsUsingDefaultSource(This)

#define IBasicVideo2_IsUsingDefaultDestination(This)	\
    (This)->lpVtbl -> IsUsingDefaultDestination(This)


#define IBasicVideo2_GetPreferredAspectRatio(This,plAspectX,plAspectY)	\
    (This)->lpVtbl -> GetPreferredAspectRatio(This,plAspectX,plAspectY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBasicVideo2_GetPreferredAspectRatio_Proxy( 
    IBasicVideo2 * This,
    /* [out] */ long *plAspectX,
    /* [out] */ long *plAspectY);


void __RPC_STUB IBasicVideo2_GetPreferredAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasicVideo2_INTERFACE_DEFINED__ */


#ifndef __IDeferredCommand_INTERFACE_DEFINED__
#define __IDeferredCommand_INTERFACE_DEFINED__

/* interface IDeferredCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IDeferredCommand,0x56a868b8,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b8-0ad4-11ce-b03a-0020af0ba770")
    IDeferredCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Confidence( 
            /* [out] */ LONG *pConfidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Postpone( 
            /* [in] */ REFTIME newtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHResult( 
            /* [out] */ HRESULT *phrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeferredCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeferredCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeferredCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Confidence )( 
            IDeferredCommand * This,
            /* [out] */ LONG *pConfidence);
        
        HRESULT ( STDMETHODCALLTYPE *Postpone )( 
            IDeferredCommand * This,
            /* [in] */ REFTIME newtime);
        
        HRESULT ( STDMETHODCALLTYPE *GetHResult )( 
            IDeferredCommand * This,
            /* [out] */ HRESULT *phrResult);
        
        END_INTERFACE
    } IDeferredCommandVtbl;

    interface IDeferredCommand
    {
        CONST_VTBL struct IDeferredCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeferredCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeferredCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDeferredCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDeferredCommand_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IDeferredCommand_Confidence(This,pConfidence)	\
    (This)->lpVtbl -> Confidence(This,pConfidence)

#define IDeferredCommand_Postpone(This,newtime)	\
    (This)->lpVtbl -> Postpone(This,newtime)

#define IDeferredCommand_GetHResult(This,phrResult)	\
    (This)->lpVtbl -> GetHResult(This,phrResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDeferredCommand_Cancel_Proxy( 
    IDeferredCommand * This);


void __RPC_STUB IDeferredCommand_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeferredCommand_Confidence_Proxy( 
    IDeferredCommand * This,
    /* [out] */ LONG *pConfidence);


void __RPC_STUB IDeferredCommand_Confidence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeferredCommand_Postpone_Proxy( 
    IDeferredCommand * This,
    /* [in] */ REFTIME newtime);


void __RPC_STUB IDeferredCommand_Postpone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeferredCommand_GetHResult_Proxy( 
    IDeferredCommand * This,
    /* [out] */ HRESULT *phrResult);


void __RPC_STUB IDeferredCommand_GetHResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDeferredCommand_INTERFACE_DEFINED__ */


#ifndef __IQueueCommand_INTERFACE_DEFINED__
#define __IQueueCommand_INTERFACE_DEFINED__

/* interface IQueueCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IQueueCommand,0x56a868b7,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b7-0ad4-11ce-b03a-0020af0ba770")
    IQueueCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeAtStreamTime( 
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeAtPresentationTime( 
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueueCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueueCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueueCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueueCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtStreamTime )( 
            IQueueCommand * This,
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtPresentationTime )( 
            IQueueCommand * This,
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr);
        
        END_INTERFACE
    } IQueueCommandVtbl;

    interface IQueueCommand
    {
        CONST_VTBL struct IQueueCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueueCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueueCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueueCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueueCommand_InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    (This)->lpVtbl -> InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)

#define IQueueCommand_InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    (This)->lpVtbl -> InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueueCommand_InvokeAtStreamTime_Proxy( 
    IQueueCommand * This,
    /* [out] */ IDeferredCommand **pCmd,
    /* [in] */ REFTIME time,
    /* [in] */ GUID *iid,
    /* [in] */ long dispidMethod,
    /* [in] */ short wFlags,
    /* [in] */ long cArgs,
    /* [in] */ VARIANT *pDispParams,
    /* [out][in] */ VARIANT *pvarResult,
    /* [out] */ short *puArgErr);


void __RPC_STUB IQueueCommand_InvokeAtStreamTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueueCommand_InvokeAtPresentationTime_Proxy( 
    IQueueCommand * This,
    /* [out] */ IDeferredCommand **pCmd,
    /* [in] */ REFTIME time,
    /* [in] */ GUID *iid,
    /* [in] */ long dispidMethod,
    /* [in] */ short wFlags,
    /* [in] */ long cArgs,
    /* [in] */ VARIANT *pDispParams,
    /* [out][in] */ VARIANT *pvarResult,
    /* [out] */ short *puArgErr);


void __RPC_STUB IQueueCommand_InvokeAtPresentationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueueCommand_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_FilgraphManager,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifdef __cplusplus

class DECLSPEC_UUID("e436ebb3-524f-11ce-9f53-0020af0ba770")
FilgraphManager;
#endif

#ifndef __IFilterInfo_INTERFACE_DEFINED__
#define __IFilterInfo_INTERFACE_DEFINED__

/* interface IFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IFilterInfo,0x56a868ba,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ba-0ad4-11ce-b03a-0020af0ba770")
    IFilterInfo : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ BSTR strPinID,
            /* [out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *strName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VendorInfo( 
            /* [retval][out] */ BSTR *strVendorInfo) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pins( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSource( 
            /* [retval][out] */ LONG *pbIsSource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ BSTR *pstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ BSTR strFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFilterInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IFilterInfo * This,
            /* [in] */ BSTR strPinID,
            /* [out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *strName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VendorInfo )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *strVendorInfo);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IFilterInfo * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pins )( 
            IFilterInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSource )( 
            IFilterInfo * This,
            /* [retval][out] */ LONG *pbIsSource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *pstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IFilterInfo * This,
            /* [in] */ BSTR strFilename);
        
        END_INTERFACE
    } IFilterInfoVtbl;

    interface IFilterInfo
    {
        CONST_VTBL struct IFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFilterInfo_FindPin(This,strPinID,ppUnk)	\
    (This)->lpVtbl -> FindPin(This,strPinID,ppUnk)

#define IFilterInfo_get_Name(This,strName)	\
    (This)->lpVtbl -> get_Name(This,strName)

#define IFilterInfo_get_VendorInfo(This,strVendorInfo)	\
    (This)->lpVtbl -> get_VendorInfo(This,strVendorInfo)

#define IFilterInfo_get_Filter(This,ppUnk)	\
    (This)->lpVtbl -> get_Filter(This,ppUnk)

#define IFilterInfo_get_Pins(This,ppUnk)	\
    (This)->lpVtbl -> get_Pins(This,ppUnk)

#define IFilterInfo_get_IsFileSource(This,pbIsSource)	\
    (This)->lpVtbl -> get_IsFileSource(This,pbIsSource)

#define IFilterInfo_get_Filename(This,pstrFilename)	\
    (This)->lpVtbl -> get_Filename(This,pstrFilename)

#define IFilterInfo_put_Filename(This,strFilename)	\
    (This)->lpVtbl -> put_Filename(This,strFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterInfo_FindPin_Proxy( 
    IFilterInfo * This,
    /* [in] */ BSTR strPinID,
    /* [out] */ IDispatch **ppUnk);


void __RPC_STUB IFilterInfo_FindPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Name_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ BSTR *strName);


void __RPC_STUB IFilterInfo_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_VendorInfo_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ BSTR *strVendorInfo);


void __RPC_STUB IFilterInfo_get_VendorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Filter_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFilterInfo_get_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Pins_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IFilterInfo_get_Pins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_IsFileSource_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ LONG *pbIsSource);


void __RPC_STUB IFilterInfo_get_IsFileSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Filename_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ BSTR *pstrFilename);


void __RPC_STUB IFilterInfo_get_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IFilterInfo_put_Filename_Proxy( 
    IFilterInfo * This,
    /* [in] */ BSTR strFilename);


void __RPC_STUB IFilterInfo_put_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IRegFilterInfo_INTERFACE_DEFINED__
#define __IRegFilterInfo_INTERFACE_DEFINED__

/* interface IRegFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IRegFilterInfo,0x56a868bb,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bb-0ad4-11ce-b03a-0020af0ba770")
    IRegFilterInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Filter( 
            /* [out] */ IDispatch **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRegFilterInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRegFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRegFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRegFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IRegFilterInfo * This,
            /* [retval][out] */ BSTR *strName);
        
        HRESULT ( STDMETHODCALLTYPE *Filter )( 
            IRegFilterInfo * This,
            /* [out] */ IDispatch **ppUnk);
        
        END_INTERFACE
    } IRegFilterInfoVtbl;

    interface IRegFilterInfo
    {
        CONST_VTBL struct IRegFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegFilterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegFilterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegFilterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRegFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRegFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRegFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRegFilterInfo_get_Name(This,strName)	\
    (This)->lpVtbl -> get_Name(This,strName)

#define IRegFilterInfo_Filter(This,ppUnk)	\
    (This)->lpVtbl -> Filter(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IRegFilterInfo_get_Name_Proxy( 
    IRegFilterInfo * This,
    /* [retval][out] */ BSTR *strName);


void __RPC_STUB IRegFilterInfo_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegFilterInfo_Filter_Proxy( 
    IRegFilterInfo * This,
    /* [out] */ IDispatch **ppUnk);


void __RPC_STUB IRegFilterInfo_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaTypeInfo_INTERFACE_DEFINED__
#define __IMediaTypeInfo_INTERFACE_DEFINED__

/* interface IMediaTypeInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaTypeInfo,0x56a868bc,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bc-0ad4-11ce-b03a-0020af0ba770")
    IMediaTypeInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Subtype( 
            /* [retval][out] */ BSTR *strType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaTypeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaTypeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaTypeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaTypeInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaTypeInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaTypeInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaTypeInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ BSTR *strType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subtype )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ BSTR *strType);
        
        END_INTERFACE
    } IMediaTypeInfoVtbl;

    interface IMediaTypeInfo
    {
        CONST_VTBL struct IMediaTypeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaTypeInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaTypeInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaTypeInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaTypeInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaTypeInfo_get_Type(This,strType)	\
    (This)->lpVtbl -> get_Type(This,strType)

#define IMediaTypeInfo_get_Subtype(This,strType)	\
    (This)->lpVtbl -> get_Subtype(This,strType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaTypeInfo_get_Type_Proxy( 
    IMediaTypeInfo * This,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IMediaTypeInfo_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaTypeInfo_get_Subtype_Proxy( 
    IMediaTypeInfo * This,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IMediaTypeInfo_get_Subtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaTypeInfo_INTERFACE_DEFINED__ */


#ifndef __IPinInfo_INTERFACE_DEFINED__
#define __IPinInfo_INTERFACE_DEFINED__

/* interface IPinInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IPinInfo,0x56a868bd,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bd-0ad4-11ce-b03a-0020af0ba770")
    IPinInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pin( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedTo( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionMediaType( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterInfo( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ LONG *ppDirection) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PinID( 
            /* [retval][out] */ BSTR *strPinID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectWithType( 
            /* [in] */ IUnknown *pPin,
            /* [in] */ IDispatch *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPinInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPinInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPinInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPinInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pin )( 
            IPinInfo * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedTo )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionMediaType )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterInfo )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IPinInfo * This,
            /* [retval][out] */ BSTR *ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IPinInfo * This,
            /* [retval][out] */ LONG *ppDirection);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinID )( 
            IPinInfo * This,
            /* [retval][out] */ BSTR *strPinID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectWithType )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin,
            /* [in] */ IDispatch *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IPinInfo * This);
        
        END_INTERFACE
    } IPinInfoVtbl;

    interface IPinInfo
    {
        CONST_VTBL struct IPinInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPinInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPinInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPinInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPinInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPinInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPinInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPinInfo_get_Pin(This,ppUnk)	\
    (This)->lpVtbl -> get_Pin(This,ppUnk)

#define IPinInfo_get_ConnectedTo(This,ppUnk)	\
    (This)->lpVtbl -> get_ConnectedTo(This,ppUnk)

#define IPinInfo_get_ConnectionMediaType(This,ppUnk)	\
    (This)->lpVtbl -> get_ConnectionMediaType(This,ppUnk)

#define IPinInfo_get_FilterInfo(This,ppUnk)	\
    (This)->lpVtbl -> get_FilterInfo(This,ppUnk)

#define IPinInfo_get_Name(This,ppUnk)	\
    (This)->lpVtbl -> get_Name(This,ppUnk)

#define IPinInfo_get_Direction(This,ppDirection)	\
    (This)->lpVtbl -> get_Direction(This,ppDirection)

#define IPinInfo_get_PinID(This,strPinID)	\
    (This)->lpVtbl -> get_PinID(This,strPinID)

#define IPinInfo_get_MediaTypes(This,ppUnk)	\
    (This)->lpVtbl -> get_MediaTypes(This,ppUnk)

#define IPinInfo_Connect(This,pPin)	\
    (This)->lpVtbl -> Connect(This,pPin)

#define IPinInfo_ConnectDirect(This,pPin)	\
    (This)->lpVtbl -> ConnectDirect(This,pPin)

#define IPinInfo_ConnectWithType(This,pPin,pMediaType)	\
    (This)->lpVtbl -> ConnectWithType(This,pPin,pMediaType)

#define IPinInfo_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IPinInfo_Render(This)	\
    (This)->lpVtbl -> Render(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_Pin_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IPinInfo_get_Pin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_ConnectedTo_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_ConnectedTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_ConnectionMediaType_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_ConnectionMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_FilterInfo_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_FilterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_Name_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ BSTR *ppUnk);


void __RPC_STUB IPinInfo_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_Direction_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ LONG *ppDirection);


void __RPC_STUB IPinInfo_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_PinID_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ BSTR *strPinID);


void __RPC_STUB IPinInfo_get_PinID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_MediaTypes_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_MediaTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_Connect_Proxy( 
    IPinInfo * This,
    /* [in] */ IUnknown *pPin);


void __RPC_STUB IPinInfo_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_ConnectDirect_Proxy( 
    IPinInfo * This,
    /* [in] */ IUnknown *pPin);


void __RPC_STUB IPinInfo_ConnectDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_ConnectWithType_Proxy( 
    IPinInfo * This,
    /* [in] */ IUnknown *pPin,
    /* [in] */ IDispatch *pMediaType);


void __RPC_STUB IPinInfo_ConnectWithType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_Disconnect_Proxy( 
    IPinInfo * This);


void __RPC_STUB IPinInfo_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_Render_Proxy( 
    IPinInfo * This);


void __RPC_STUB IPinInfo_Render_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPinInfo_INTERFACE_DEFINED__ */


#ifndef __IAMStats_INTERFACE_DEFINED__
#define __IAMStats_INTERFACE_DEFINED__

/* interface IAMStats */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMStats,0xbc9bcf80,0xdcd2,0x11d2,0xab,0xf6,0x00,0xa0,0xc9,0x05,0xf3,0x75);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc9bcf80-dcd2-11d2-abf6-00a0c905f375")
    IAMStats : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByIndex( 
            /* [in] */ long lIndex,
            /* [out] */ BSTR *szName,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByName( 
            /* [in] */ BSTR szName,
            /* [out] */ long *lIndex,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ BSTR szName,
            /* [in] */ long lCreate,
            /* [out] */ long *plIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddValue( 
            /* [in] */ long lIndex,
            /* [in] */ double dValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMStats * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMStats * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMStats * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMStats * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAMStats * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMStats * This,
            /* [retval][out] */ LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByIndex )( 
            IAMStats * This,
            /* [in] */ long lIndex,
            /* [out] */ BSTR *szName,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByName )( 
            IAMStats * This,
            /* [in] */ BSTR szName,
            /* [out] */ long *lIndex,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            IAMStats * This,
            /* [in] */ BSTR szName,
            /* [in] */ long lCreate,
            /* [out] */ long *plIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddValue )( 
            IAMStats * This,
            /* [in] */ long lIndex,
            /* [in] */ double dValue);
        
        END_INTERFACE
    } IAMStatsVtbl;

    interface IAMStats
    {
        CONST_VTBL struct IAMStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMStats_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAMStats_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAMStats_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAMStats_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAMStats_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAMStats_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IAMStats_GetValueByIndex(This,lIndex,szName,lCount,dLast,dAverage,dStdDev,dMin,dMax)	\
    (This)->lpVtbl -> GetValueByIndex(This,lIndex,szName,lCount,dLast,dAverage,dStdDev,dMin,dMax)

#define IAMStats_GetValueByName(This,szName,lIndex,lCount,dLast,dAverage,dStdDev,dMin,dMax)	\
    (This)->lpVtbl -> GetValueByName(This,szName,lIndex,lCount,dLast,dAverage,dStdDev,dMin,dMax)

#define IAMStats_GetIndex(This,szName,lCreate,plIndex)	\
    (This)->lpVtbl -> GetIndex(This,szName,lCreate,plIndex)

#define IAMStats_AddValue(This,lIndex,dValue)	\
    (This)->lpVtbl -> AddValue(This,lIndex,dValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMStats_Reset_Proxy( 
    IAMStats * This);


void __RPC_STUB IAMStats_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IAMStats_get_Count_Proxy( 
    IAMStats * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IAMStats_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_GetValueByIndex_Proxy( 
    IAMStats * This,
    /* [in] */ long lIndex,
    /* [out] */ BSTR *szName,
    /* [out] */ long *lCount,
    /* [out] */ double *dLast,
    /* [out] */ double *dAverage,
    /* [out] */ double *dStdDev,
    /* [out] */ double *dMin,
    /* [out] */ double *dMax);


void __RPC_STUB IAMStats_GetValueByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_GetValueByName_Proxy( 
    IAMStats * This,
    /* [in] */ BSTR szName,
    /* [out] */ long *lIndex,
    /* [out] */ long *lCount,
    /* [out] */ double *dLast,
    /* [out] */ double *dAverage,
    /* [out] */ double *dStdDev,
    /* [out] */ double *dMin,
    /* [out] */ double *dMax);


void __RPC_STUB IAMStats_GetValueByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_GetIndex_Proxy( 
    IAMStats * This,
    /* [in] */ BSTR szName,
    /* [in] */ long lCreate,
    /* [out] */ long *plIndex);


void __RPC_STUB IAMStats_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_AddValue_Proxy( 
    IAMStats * This,
    /* [in] */ long lIndex,
    /* [in] */ double dValue);


void __RPC_STUB IAMStats_AddValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMStats_INTERFACE_DEFINED__ */

#endif /* __QuartzTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3d.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D_H_
#define _D3D_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

// include this file content only if compiling for <=DX7 interfaces
#if(DIRECT3D_VERSION < 0x0800)


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)
DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3D7,            0xf5049e77,0x4861,0x11d2,0xa4,0x7,0x0,0xa0,0xc9,0x6,0x29,0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DTnLHalDevice, 0xf5049e78, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Internal Guid to distinguish requested MMX from MMX being used as an RGB rasterizer
 */

DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DDevice7,  0xf5049e79, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */

DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );

DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
#endif /* DIRECT3D_VERSION >= 0x0600 */

DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DVertexBuffer7, 0xf5049e7d, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */
#endif

#ifdef __cplusplus
struct IDirect3D;
struct IDirect3DDevice;
struct IDirect3DLight;
struct IDirect3DMaterial;
struct IDirect3DExecuteBuffer;
struct IDirect3DTexture;
struct IDirect3DViewport;
typedef struct IDirect3D            *LPDIRECT3D;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
struct IDirect3D2;
struct IDirect3DDevice2;
struct IDirect3DMaterial2;
struct IDirect3DTexture2;
struct IDirect3DViewport2;
typedef struct IDirect3D2           *LPDIRECT3D2;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
struct IDirect3D3;
struct IDirect3DDevice3;
struct IDirect3DMaterial3;
struct IDirect3DViewport3;
struct IDirect3DVertexBuffer;
typedef struct IDirect3D3            *LPDIRECT3D3;
typedef struct IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef struct IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
struct IDirect3D7;
struct IDirect3DDevice7;
struct IDirect3DVertexBuffer7;
typedef struct IDirect3D7             *LPDIRECT3D7;
typedef struct IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#else

typedef struct IDirect3D        *LPDIRECT3D;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
typedef struct IDirect3D2           *LPDIRECT3D2;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
typedef struct IDirect3D3            *LPDIRECT3D3;
typedef struct IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef struct IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct IDirect3D7             *LPDIRECT3D7;
typedef struct IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif

#include "d3dtypes.h"
#include "d3dcaps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Direct3D interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3D

DECLARE_INTERFACE_(IDirect3D, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D methods ***/
    STDMETHOD(Initialize)(THIS_ REFCLSID) PURE;
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
};

typedef struct IDirect3D *LPDIRECT3D;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3D_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#else
#define IDirect3D_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D_AddRef(p) (p)->AddRef()
#define IDirect3D_Release(p) (p)->Release()
#define IDirect3D_Initialize(p,a) (p)->Initialize(a)
#define IDirect3D_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->FindDevice(a,b)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3D2

DECLARE_INTERFACE_(IDirect3D2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D2 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL2*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT2*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE,LPDIRECT3DDEVICE2*) PURE;
};

typedef struct IDirect3D2 *LPDIRECT3D2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D2_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#else
#define IDirect3D2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D2_AddRef(p) (p)->AddRef()
#define IDirect3D2_Release(p) (p)->Release()
#define IDirect3D2_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3D3

DECLARE_INTERFACE_(IDirect3D3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D3 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,LPUNKNOWN) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT3*,LPUNKNOWN) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE4,LPDIRECT3DDEVICE3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER*,DWORD,LPUNKNOWN) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D3 *LPDIRECT3D3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D3_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D3_AddRef(p) (p)->AddRef()
#define IDirect3D3_Release(p) (p)->Release()
#define IDirect3D3_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->CreateDevice(a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->CreateVertexBuffer(a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3D7

DECLARE_INTERFACE_(IDirect3D7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D7 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK7,LPVOID) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE7,LPDIRECT3DDEVICE7*) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER7*,DWORD) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D7 *LPDIRECT3D7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D7_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirect3D7_CreateVertexBuffer(p,a,b,c) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c)
#define IDirect3D7_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D7_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D7_AddRef(p) (p)->AddRef()
#define IDirect3D7_Release(p) (p)->Release()
#define IDirect3D7_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirect3D7_CreateVertexBuffer(p,a,b,c) (p)->CreateVertexBuffer(a,b,c)
#define IDirect3D7_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D7_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */
/*
 * Direct3D Device interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DDevice

DECLARE_INTERFACE_(IDirect3DDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D,LPGUID,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE,LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(CreateExecuteBuffer)(THIS_ LPD3DEXECUTEBUFFERDESC,LPDIRECT3DEXECUTEBUFFER*,IUnknown*) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(Execute)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT,LPDIRECT3DVIEWPORT*,DWORD) PURE;
    STDMETHOD(Pick)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD,LPD3DRECT) PURE;
    STDMETHOD(GetPickRecords)(THIS_ LPDWORD,LPD3DPICKRECORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateMatrix)(THIS_ LPD3DMATRIXHANDLE) PURE;
    STDMETHOD(SetMatrix)(THIS_ D3DMATRIXHANDLE,const LPD3DMATRIX) PURE;
    STDMETHOD(GetMatrix)(THIS_ D3DMATRIXHANDLE,LPD3DMATRIX) PURE;
    STDMETHOD(DeleteMatrix)(THIS_ D3DMATRIXHANDLE) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D*) PURE;
};

typedef struct IDirect3DDevice *LPDIRECT3DDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->lpVtbl->CreateExecuteBuffer(p,a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->lpVtbl->Execute(p,a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->lpVtbl->Pick(p,a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->lpVtbl->GetPickRecords(p,a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->lpVtbl->CreateMatrix(p,a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->lpVtbl->SetMatrix(p,a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->lpVtbl->GetMatrix(p,a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->lpVtbl->DeleteMatrix(p,a)
#define IDirect3DDevice_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#else
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice_AddRef(p) (p)->AddRef()
#define IDirect3DDevice_Release(p) (p)->Release()
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->CreateExecuteBuffer(a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->Execute(a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->Pick(a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->GetPickRecords(a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->CreateMatrix(a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->SetMatrix(a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->GetMatrix(a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->DeleteMatrix(a)
#define IDirect3DDevice_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice_EndScene(p) (p)->EndScene()
#define IDirect3DDevice_GetDirect3D(p,a) (p)->GetDirect3D(a)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DDevice2

DECLARE_INTERFACE_(IDirect3DDevice2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice2 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE2,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT2,LPDIRECT3DVIEWPORT2*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D2*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
};

typedef struct IDirect3DDevice2 *LPDIRECT3DDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice2_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice2_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice2_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#else
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice2_AddRef(p) (p)->AddRef()
#define IDirect3DDevice2_Release(p) (p)->Release()
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice2_EndScene(p) (p)->EndScene()
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice2_Index(p,a) (p)->Index(a)
#define IDirect3DDevice2_End(p,a) (p)->End(a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->GetClipStatus(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DDevice3

DECLARE_INTERFACE_(IDirect3DDevice3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice3 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT3,LPDIRECT3DVIEWPORT3*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D3*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,DWORD,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
};

typedef struct IDirect3DDevice3 *LPDIRECT3DDEVICE3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice3_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice3_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice3_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#else
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice3_AddRef(p) (p)->AddRef()
#define IDirect3DDevice3_Release(p) (p)->Release()
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice3_EndScene(p) (p)->EndScene()
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice3_Index(p,a) (p)->Index(a)
#define IDirect3DDevice3_End(p,a) (p)->End(a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->ValidateDevice(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3DDevice7

DECLARE_INTERFACE_(IDirect3DDevice7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice7 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC7) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D7*) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE7,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT7) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT7) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL7) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL7) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD,LPD3DLIGHT7) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD,LPD3DLIGHT7) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ LPDWORD) PURE;
    STDMETHOD(PreLoad)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER7,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER7,DWORD,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
    STDMETHOD(ApplyStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(CaptureStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(DeleteStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE,LPDWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECTDRAWSURFACE7,LPPOINT,LPDIRECTDRAWSURFACE7,LPRECT,DWORD) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD,BOOL) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD,BOOL*) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD,D3DVALUE*) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD,D3DVALUE*) PURE;
    STDMETHOD(GetInfo)(THIS_ DWORD,LPVOID,DWORD) PURE;
};

typedef struct IDirect3DDevice7 *LPDIRECT3DDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice7_GetCaps(p,a) (p)->lpVtbl->GetCaps(p,a)
#define IDirect3DDevice7_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice7_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice7_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice7_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice7_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice7_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice7_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice7_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice7_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice7_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice7_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice7_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice7_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice7_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice7_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice7_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice7_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice7_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice7_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice7_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice7_PreLoad(p,a) (p)->lpVtbl->PreLoad(p,a)
#define IDirect3DDevice7_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice7_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice7_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice7_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice7_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice7_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice7_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice7_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice7_ApplyStateBlock(p,a) (p)->lpVtbl->ApplyStateBlock(p,a)
#define IDirect3DDevice7_CaptureStateBlock(p,a) (p)->lpVtbl->CaptureStateBlock(p,a)
#define IDirect3DDevice7_DeleteStateBlock(p,a) (p)->lpVtbl->DeleteStateBlock(p,a)
#define IDirect3DDevice7_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice7_Load(p,a,b,c,d,e) (p)->lpVtbl->Load(p,a,b,c,d,e)
#define IDirect3DDevice7_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice7_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice7_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice7_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice7_GetInfo(p,a,b,c) (p)->lpVtbl->GetInfo(p,a,b,c)
#else
#define IDirect3DDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice7_AddRef(p) (p)->AddRef()
#define IDirect3DDevice7_Release(p) (p)->Release()
#define IDirect3DDevice7_GetCaps(p,a) (p)->GetCaps(a)
#define IDirect3DDevice7_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice7_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice7_EndScene(p) (p)->EndScene()
#define IDirect3DDevice7_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice7_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice7_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice7_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice7_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice7_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice7_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice7_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice7_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice7_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice7_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice7_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice7_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice7_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice7_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice7_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice7_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice7_PreLoad(p,a) (p)->PreLoad(a)
#define IDirect3DDevice7_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice7_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice7_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice7_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice7_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e,f,g)
#define IDirect3DDevice7_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice7_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice7_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice7_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice7_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice7_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice7_ApplyStateBlock(p,a) (p)->ApplyStateBlock(a)
#define IDirect3DDevice7_CaptureStateBlock(p,a) (p)->CaptureStateBlock(a)
#define IDirect3DDevice7_DeleteStateBlock(p,a) (p)->DeleteStateBlock(a)
#define IDirect3DDevice7_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice7_Load(p,a,b,c,d,e) (p)->Load(a,b,c,d,e)
#define IDirect3DDevice7_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice7_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice7_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice7_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice7_GetInfo(p,a,b,c) (p)->GetInfo(a,b,c)
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Execute Buffer interface
 */
#undef INTERFACE
#define INTERFACE IDirect3DExecuteBuffer

DECLARE_INTERFACE_(IDirect3DExecuteBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DExecuteBuffer methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Lock)(THIS_ LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(SetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(GetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(Validate)(THIS_ LPDWORD,LPD3DVALIDATECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD) PURE;
};

typedef struct IDirect3DExecuteBuffer *LPDIRECT3DEXECUTEBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DExecuteBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->lpVtbl->Lock(p,a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->lpVtbl->SetExecuteData(p,a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->lpVtbl->GetExecuteData(p,a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->lpVtbl->Validate(p,a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->lpVtbl->Optimize(p,a)
#else
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DExecuteBuffer_Release(p) (p)->Release()
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->Lock(a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->SetExecuteData(a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->GetExecuteData(a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->Validate(a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->Optimize(a)
#endif

/*
 * Light interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DLight

DECLARE_INTERFACE_(IDirect3DLight, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DLight methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetLight)(THIS_ LPD3DLIGHT) PURE;
    STDMETHOD(GetLight)(THIS_ LPD3DLIGHT) PURE;
};

typedef struct IDirect3DLight *LPDIRECT3DLIGHT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DLight_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DLight_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DLight_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DLight_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DLight_SetLight(p,a) (p)->lpVtbl->SetLight(p,a)
#define IDirect3DLight_GetLight(p,a) (p)->lpVtbl->GetLight(p,a)
#else
#define IDirect3DLight_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DLight_AddRef(p) (p)->AddRef()
#define IDirect3DLight_Release(p) (p)->Release()
#define IDirect3DLight_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DLight_SetLight(p,a) (p)->SetLight(a)
#define IDirect3DLight_GetLight(p,a) (p)->GetLight(a)
#endif

/*
 * Material interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DMaterial

DECLARE_INTERFACE_(IDirect3DMaterial, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DMATERIALHANDLE) PURE;
    STDMETHOD(Reserve)(THIS) PURE;
    STDMETHOD(Unreserve)(THIS) PURE;
};

typedef struct IDirect3DMaterial *LPDIRECT3DMATERIAL;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DMaterial_Reserve(p) (p)->lpVtbl->Reserve(p)
#define IDirect3DMaterial_Unreserve(p) (p)->lpVtbl->Unreserve(p)
#else
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial_Release(p) (p)->Release()
#define IDirect3DMaterial_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DMaterial_Reserve(p) (p)->Reserve()
#define IDirect3DMaterial_Unreserve(p) (p)->Unreserve()
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DMaterial2

DECLARE_INTERFACE_(IDirect3DMaterial2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial2 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial2 *LPDIRECT3DMATERIAL2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial2_Release(p) (p)->Release()
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DMaterial3

DECLARE_INTERFACE_(IDirect3DMaterial3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial3 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE3,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial3 *LPDIRECT3DMATERIAL3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial3_Release(p) (p)->Release()
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Texture interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DTexture

DECLARE_INTERFACE_(IDirect3DTexture, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(Unload)(THIS) PURE;
};

typedef struct IDirect3DTexture *LPDIRECT3DTEXTURE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture_Load(p,a) (p)->lpVtbl->Load(p,a)
#define IDirect3DTexture_Unload(p) (p)->lpVtbl->Unload(p)
#else
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture_AddRef(p) (p)->AddRef()
#define IDirect3DTexture_Release(p) (p)->Release()
#define IDirect3DTexture_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture_Load(p,a) (p)->Load(a)
#define IDirect3DTexture_Unload(p) (p)->Unload()
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DTexture2

DECLARE_INTERFACE_(IDirect3DTexture2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture2 methods ***/
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE2) PURE;
};

typedef struct IDirect3DTexture2 *LPDIRECT3DTEXTURE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture2_Load(p,a) (p)->lpVtbl->Load(p,a)
#else
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture2_AddRef(p) (p)->AddRef()
#define IDirect3DTexture2_Release(p) (p)->Release()
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture2_Load(p,a) (p)->Load(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

/*
 * Viewport interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DViewport

DECLARE_INTERFACE_(IDirect3DViewport, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
};

typedef struct IDirect3DViewport *LPDIRECT3DVIEWPORT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#else
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport_AddRef(p) (p)->AddRef()
#define IDirect3DViewport_Release(p) (p)->Release()
#define IDirect3DViewport_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DViewport2

DECLARE_INTERFACE_(IDirect3DViewport2, IDirect3DViewport)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
};

typedef struct IDirect3DViewport2 *LPDIRECT3DVIEWPORT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport2_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#else
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport2_AddRef(p) (p)->AddRef()
#define IDirect3DViewport2_Release(p) (p)->Release()
#define IDirect3DViewport2_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->SetViewport2(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

#undef INTERFACE
#define INTERFACE IDirect3DViewport3

DECLARE_INTERFACE_(IDirect3DViewport3, IDirect3DViewport2)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport2 methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetBackgroundDepth2)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(GetBackgroundDepth2)(THIS_ LPDIRECTDRAWSURFACE4*,LPBOOL) PURE;
    STDMETHOD(Clear2)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
};

typedef struct IDirect3DViewport3 *LPDIRECT3DVIEWPORT3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport3_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#define IDirect3DViewport3_SetBackgroundDepth2(p,a) (p)->lpVtbl->SetBackgroundDepth2(p,a)
#define IDirect3DViewport3_GetBackgroundDepth2(p,a,b) (p)->lpVtbl->GetBackgroundDepth2(p,a,b)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->lpVtbl->Clear2(p,a,b,c,d,e,f)
#else
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport3_AddRef(p) (p)->AddRef()
#define IDirect3DViewport3_Release(p) (p)->Release()
#define IDirect3DViewport3_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->SetViewport2(a)
#define IDirect3DViewport3_SetBackgroundDepth2(p,a) (p)->SetBackgroundDepth2(a)
#define IDirect3DViewport3_GetBackgroundDepth2(p,a,b) (p)->GetBackgroundDepth2(a,b)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->Clear2(a,b,c,d,e,f)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer

DECLARE_INTERFACE_(IDirect3DVertexBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER,DWORD,LPDIRECT3DDEVICE3,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE3,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#else
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer_Release(p) (p)->Release()
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->Optimize(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer7

DECLARE_INTERFACE_(IDirect3DVertexBuffer7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer7 methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER7,DWORD,LPDIRECT3DDEVICE7,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE7,DWORD) PURE;
    STDMETHOD(ProcessVerticesStrided)(THIS_ DWORD,DWORD,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPDIRECT3DDEVICE7,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer7_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer7_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer7_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer7_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer7_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#define IDirect3DVertexBuffer7_ProcessVerticesStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVerticesStrided(p,a,b,c,d,e,f,g)
#else
#define IDirect3DVertexBuffer7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer7_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer7_Release(p) (p)->Release()
#define IDirect3DVertexBuffer7_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer7_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer7_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer7_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer7_Optimize(p,a,b) (p)->Optimize(a,b)
#define IDirect3DVertexBuffer7_ProcessVerticesStrided(p,a,b,c,d,e,f,g) (p)->ProcessVerticesStrided(a,b,c,d,e,f,g)
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
/****************************************************************************
 *
 * Flags for IDirect3DDevice::NextViewport
 *
 ****************************************************************************/

/*
 * Return the next viewport
 */
#define D3DNEXT_NEXT    0x00000001l

/*
 * Return the first viewport
 */
#define D3DNEXT_HEAD    0x00000002l

/*
 * Return the last viewport
 */
#define D3DNEXT_TAIL    0x00000004l


/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/

/*
 * Wait until the device is ready to draw the primitive
 * This will cause DP to not return DDERR_WASSTILLDRAWING
 */
#define D3DDP_WAIT                  0x00000001l
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if (DIRECT3D_VERSION == 0x0500)
/*
 * Hint that it is acceptable to render the primitive out of order.
 */
#define D3DDP_OUTOFORDER            0x00000002l
#endif


#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Hint that the primitives have been clipped by the application.
 */
#define D3DDP_DONOTCLIP             0x00000004l

/*
 * Hint that the extents need not be updated.
 */
#define D3DDP_DONOTUPDATEEXTENTS    0x00000008l
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

/*
 * Hint that the lighting should not be applied on vertices.
 */

#define D3DDP_DONOTLIGHT            0x00000010l

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Direct3D Errors
 * DirectDraw error codes are used when errors not specified here.
 */
#define D3D_OK              DD_OK
#define D3DERR_BADMAJORVERSION      MAKE_DDHRESULT(700)
#define D3DERR_BADMINORVERSION      MAKE_DDHRESULT(701)

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * An invalid device was requested by the application.
 */
#define D3DERR_INVALID_DEVICE   MAKE_DDHRESULT(705)
#define D3DERR_INITFAILED       MAKE_DDHRESULT(706)

/*
 * SetRenderTarget attempted on a device that was
 * QI'd off the render target.
 */
#define D3DERR_DEVICEAGGREGATED MAKE_DDHRESULT(707)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_EXECUTE_CREATE_FAILED    MAKE_DDHRESULT(710)
#define D3DERR_EXECUTE_DESTROY_FAILED   MAKE_DDHRESULT(711)
#define D3DERR_EXECUTE_LOCK_FAILED  MAKE_DDHRESULT(712)
#define D3DERR_EXECUTE_UNLOCK_FAILED    MAKE_DDHRESULT(713)
#define D3DERR_EXECUTE_LOCKED       MAKE_DDHRESULT(714)
#define D3DERR_EXECUTE_NOT_LOCKED   MAKE_DDHRESULT(715)

#define D3DERR_EXECUTE_FAILED       MAKE_DDHRESULT(716)
#define D3DERR_EXECUTE_CLIPPED_FAILED   MAKE_DDHRESULT(717)

#define D3DERR_TEXTURE_NO_SUPPORT   MAKE_DDHRESULT(720)
#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DERR_TEXTURE_DESTROY_FAILED   MAKE_DDHRESULT(722)
#define D3DERR_TEXTURE_LOCK_FAILED  MAKE_DDHRESULT(723)
#define D3DERR_TEXTURE_UNLOCK_FAILED    MAKE_DDHRESULT(724)
#define D3DERR_TEXTURE_LOAD_FAILED  MAKE_DDHRESULT(725)
#define D3DERR_TEXTURE_SWAP_FAILED  MAKE_DDHRESULT(726)
#define D3DERR_TEXTURE_LOCKED       MAKE_DDHRESULT(727)
#define D3DERR_TEXTURE_NOT_LOCKED   MAKE_DDHRESULT(728)
#define D3DERR_TEXTURE_GETSURF_FAILED   MAKE_DDHRESULT(729)

#define D3DERR_MATRIX_CREATE_FAILED MAKE_DDHRESULT(730)
#define D3DERR_MATRIX_DESTROY_FAILED    MAKE_DDHRESULT(731)
#define D3DERR_MATRIX_SETDATA_FAILED    MAKE_DDHRESULT(732)
#define D3DERR_MATRIX_GETDATA_FAILED    MAKE_DDHRESULT(733)
#define D3DERR_SETVIEWPORTDATA_FAILED   MAKE_DDHRESULT(734)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INVALIDCURRENTVIEWPORT   MAKE_DDHRESULT(735)
#define D3DERR_INVALIDPRIMITIVETYPE     MAKE_DDHRESULT(736)
#define D3DERR_INVALIDVERTEXTYPE        MAKE_DDHRESULT(737)
#define D3DERR_TEXTURE_BADSIZE          MAKE_DDHRESULT(738)
#define D3DERR_INVALIDRAMPTEXTURE       MAKE_DDHRESULT(739)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_MATERIAL_CREATE_FAILED   MAKE_DDHRESULT(740)
#define D3DERR_MATERIAL_DESTROY_FAILED  MAKE_DDHRESULT(741)
#define D3DERR_MATERIAL_SETDATA_FAILED  MAKE_DDHRESULT(742)
#define D3DERR_MATERIAL_GETDATA_FAILED  MAKE_DDHRESULT(743)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INVALIDPALETTE           MAKE_DDHRESULT(744)

#define D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY MAKE_DDHRESULT(745)
#define D3DERR_ZBUFF_NEEDS_VIDEOMEMORY  MAKE_DDHRESULT(746)
#define D3DERR_SURFACENOTINVIDMEM       MAKE_DDHRESULT(747)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_LIGHT_SET_FAILED     MAKE_DDHRESULT(750)
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_LIGHTHASVIEWPORT     MAKE_DDHRESULT(751)
#define D3DERR_LIGHTNOTINTHISVIEWPORT           MAKE_DDHRESULT(752)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_SCENE_IN_SCENE       MAKE_DDHRESULT(760)
#define D3DERR_SCENE_NOT_IN_SCENE   MAKE_DDHRESULT(761)
#define D3DERR_SCENE_BEGIN_FAILED   MAKE_DDHRESULT(762)
#define D3DERR_SCENE_END_FAILED     MAKE_DDHRESULT(763)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INBEGIN                  MAKE_DDHRESULT(770)
#define D3DERR_NOTINBEGIN               MAKE_DDHRESULT(771)
#define D3DERR_NOVIEWPORTS              MAKE_DDHRESULT(772)
#define D3DERR_VIEWPORTDATANOTSET       MAKE_DDHRESULT(773)
#define D3DERR_VIEWPORTHASNODEVICE      MAKE_DDHRESULT(774)
#define D3DERR_NOCURRENTVIEWPORT        MAKE_DDHRESULT(775)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#define D3DERR_INVALIDVERTEXFORMAT              MAKE_DDHRESULT(2048)

/*
 * Attempted to CreateTexture on a surface that had a color key
 */
#define D3DERR_COLORKEYATTACHED                 MAKE_DDHRESULT(2050)

#define D3DERR_VERTEXBUFFEROPTIMIZED            MAKE_DDHRESULT(2060)
#define D3DERR_VBUF_CREATE_FAILED               MAKE_DDHRESULT(2061)
#define D3DERR_VERTEXBUFFERLOCKED               MAKE_DDHRESULT(2062)
#define D3DERR_VERTEXBUFFERUNLOCKFAILED         MAKE_DDHRESULT(2063)

#define D3DERR_ZBUFFER_NOTPRESENT               MAKE_DDHRESULT(2070)
#define D3DERR_STENCILBUFFER_NOTPRESENT         MAKE_DDHRESULT(2071)

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_DDHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_DDHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_DDHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_DDHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_DDHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_DDHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_DDHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_DDHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_DDHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_DDHRESULT(2082)
#define D3DERR_TOOMANYPRIMITIVES                MAKE_DDHRESULT(2083)
#define D3DERR_INVALIDMATRIX                    MAKE_DDHRESULT(2084)
#define D3DERR_TOOMANYVERTICES                  MAKE_DDHRESULT(2085)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_DDHRESULT(2086)

#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#define D3DERR_INVALIDSTATEBLOCK        MAKE_DDHRESULT(2100)
#define D3DERR_INBEGINSTATEBLOCK        MAKE_DDHRESULT(2101)
#define D3DERR_NOTINBEGINSTATEBLOCK     MAKE_DDHRESULT(2102)
#endif /* DIRECT3D_VERSION >= 0x0700 */


#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION < 0x0800) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d8.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3d8.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)


/* This identifier is passed to Direct3DCreate8 in order to ensure that an
 * application was built against the correct header files. This number is
 * incremented whenever a header (or other) change would require applications
 * to be rebuilt. If the version doesn't match, Direct3DCreate8 will fail.
 * (The number itself has no meaning.)*/

#define D3D_SDK_VERSION 220


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <windows.h>

#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
    #define HMONITOR_DECLARED
    DECLARE_HANDLE(HMONITOR);
#endif

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

/* IID_IDirect3D8 */
/* {1DD9E8DA-1C77-4d40-B0CF-98FEFDFF9512} */
DEFINE_GUID(IID_IDirect3D8, 0x1dd9e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);

/* IID_IDirect3DDevice8 */
/* {7385E5DF-8FE8-41D5-86B6-D7B48547B6CF} */
DEFINE_GUID(IID_IDirect3DDevice8, 0x7385e5df, 0x8fe8, 0x41d5, 0x86, 0xb6, 0xd7, 0xb4, 0x85, 0x47, 0xb6, 0xcf);

/* IID_IDirect3DResource8 */
/* {1B36BB7B-09B7-410a-B445-7D1430D7B33F} */
DEFINE_GUID(IID_IDirect3DResource8, 0x1b36bb7b, 0x9b7, 0x410a, 0xb4, 0x45, 0x7d, 0x14, 0x30, 0xd7, 0xb3, 0x3f);

/* IID_IDirect3DBaseTexture8 */
/* {B4211CFA-51B9-4a9f-AB78-DB99B2BB678E} */
DEFINE_GUID(IID_IDirect3DBaseTexture8, 0xb4211cfa, 0x51b9, 0x4a9f, 0xab, 0x78, 0xdb, 0x99, 0xb2, 0xbb, 0x67, 0x8e);

/* IID_IDirect3DTexture8 */
/* {E4CDD575-2866-4f01-B12E-7EECE1EC9358} */
DEFINE_GUID(IID_IDirect3DTexture8, 0xe4cdd575, 0x2866, 0x4f01, 0xb1, 0x2e, 0x7e, 0xec, 0xe1, 0xec, 0x93, 0x58);

/* IID_IDirect3DCubeTexture8 */
/* {3EE5B968-2ACA-4c34-8BB5-7E0C3D19B750} */
DEFINE_GUID(IID_IDirect3DCubeTexture8, 0x3ee5b968, 0x2aca, 0x4c34, 0x8b, 0xb5, 0x7e, 0x0c, 0x3d, 0x19, 0xb7, 0x50);

/* IID_IDirect3DVolumeTexture8 */
/* {4B8AAAFA-140F-42ba-9131-597EAFAA2EAD} */
DEFINE_GUID(IID_IDirect3DVolumeTexture8, 0x4b8aaafa, 0x140f, 0x42ba, 0x91, 0x31, 0x59, 0x7e, 0xaf, 0xaa, 0x2e, 0xad);

/* IID_IDirect3DVertexBuffer8 */
/* {8AEEEAC7-05F9-44d4-B591-000B0DF1CB95} */
DEFINE_GUID(IID_IDirect3DVertexBuffer8, 0x8aeeeac7, 0x05f9, 0x44d4, 0xb5, 0x91, 0x00, 0x0b, 0x0d, 0xf1, 0xcb, 0x95);

/* IID_IDirect3DIndexBuffer8 */
/* {0E689C9A-053D-44a0-9D92-DB0E3D750F86} */
DEFINE_GUID(IID_IDirect3DIndexBuffer8, 0x0e689c9a, 0x053d, 0x44a0, 0x9d, 0x92, 0xdb, 0x0e, 0x3d, 0x75, 0x0f, 0x86);

/* IID_IDirect3DSurface8 */
/* {B96EEBCA-B326-4ea5-882F-2FF5BAE021DD} */
DEFINE_GUID(IID_IDirect3DSurface8, 0xb96eebca, 0xb326, 0x4ea5, 0x88, 0x2f, 0x2f, 0xf5, 0xba, 0xe0, 0x21, 0xdd);

/* IID_IDirect3DVolume8 */
/* {BD7349F5-14F1-42e4-9C79-972380DB40C0} */
DEFINE_GUID(IID_IDirect3DVolume8, 0xbd7349f5, 0x14f1, 0x42e4, 0x9c, 0x79, 0x97, 0x23, 0x80, 0xdb, 0x40, 0xc0);

/* IID_IDirect3DSwapChain8 */
/* {928C088B-76B9-4C6B-A536-A590853876CD} */
DEFINE_GUID(IID_IDirect3DSwapChain8, 0x928c088b, 0x76b9, 0x4c6b, 0xa5, 0x36, 0xa5, 0x90, 0x85, 0x38, 0x76, 0xcd);

#endif

#ifdef __cplusplus

interface IDirect3D8;
interface IDirect3DDevice8;

interface IDirect3DResource8;
interface IDirect3DBaseTexture8;
interface IDirect3DTexture8;
interface IDirect3DVolumeTexture8;
interface IDirect3DCubeTexture8;

interface IDirect3DVertexBuffer8;
interface IDirect3DIndexBuffer8;

interface IDirect3DSurface8;
interface IDirect3DVolume8;

interface IDirect3DSwapChain8;

#endif


typedef interface IDirect3D8                IDirect3D8;
typedef interface IDirect3DDevice8          IDirect3DDevice8;
typedef interface IDirect3DResource8        IDirect3DResource8;
typedef interface IDirect3DBaseTexture8     IDirect3DBaseTexture8;
typedef interface IDirect3DTexture8         IDirect3DTexture8;
typedef interface IDirect3DVolumeTexture8   IDirect3DVolumeTexture8;
typedef interface IDirect3DCubeTexture8     IDirect3DCubeTexture8;
typedef interface IDirect3DVertexBuffer8    IDirect3DVertexBuffer8;
typedef interface IDirect3DIndexBuffer8     IDirect3DIndexBuffer8;
typedef interface IDirect3DSurface8         IDirect3DSurface8;
typedef interface IDirect3DVolume8          IDirect3DVolume8;
typedef interface IDirect3DSwapChain8       IDirect3DSwapChain8;

#include "d3d8types.h"
#include "d3d8caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * DLL Function for creating a Direct3D8 object. This object supports
 * enumeration and allows the creation of Direct3DDevice8 objects.
 * Pass the value of the constant D3D_SDK_VERSION to this function, so
 * that the run-time can validate that your application was compiled
 * against the right headers.
 */

IDirect3D8 * WINAPI Direct3DCreate8(UINT SDKVersion);


/*
 * Direct3D interfaces
 */






#undef INTERFACE
#define INTERFACE IDirect3D8

DECLARE_INTERFACE_(IDirect3D8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D8 methods ***/
    STDMETHOD(RegisterSoftwareDevice)(THIS_ void* pInitializeFunction) PURE;
    STDMETHOD_(UINT, GetAdapterCount)(THIS) PURE;
    STDMETHOD(GetAdapterIdentifier)(THIS_ UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER8* pIdentifier) PURE;
    STDMETHOD_(UINT, GetAdapterModeCount)(THIS_ UINT Adapter) PURE;
    STDMETHOD(EnumAdapterModes)(THIS_ UINT Adapter,UINT Mode,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetAdapterDisplayMode)(THIS_ UINT Adapter,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(CheckDeviceType)(THIS_ UINT Adapter,D3DDEVTYPE CheckType,D3DFORMAT DisplayFormat,D3DFORMAT BackBufferFormat,BOOL Windowed) PURE;
    STDMETHOD(CheckDeviceFormat)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,DWORD Usage,D3DRESOURCETYPE RType,D3DFORMAT CheckFormat) PURE;
    STDMETHOD(CheckDeviceMultiSampleType)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SurfaceFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType) PURE;
    STDMETHOD(CheckDepthStencilMatch)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8* pCaps) PURE;
    STDMETHOD_(HMONITOR, GetAdapterMonitor)(THIS_ UINT Adapter) PURE;
    STDMETHOD(CreateDevice)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,HWND hFocusWindow,DWORD BehaviorFlags,D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DDevice8** ppReturnedDeviceInterface) PURE;
};

typedef struct IDirect3D8 *LPDIRECT3D8, *PDIRECT3D8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D8_RegisterSoftwareDevice(p,a) (p)->lpVtbl->RegisterSoftwareDevice(p,a)
#define IDirect3D8_GetAdapterCount(p) (p)->lpVtbl->GetAdapterCount(p)
#define IDirect3D8_GetAdapterIdentifier(p,a,b,c) (p)->lpVtbl->GetAdapterIdentifier(p,a,b,c)
#define IDirect3D8_GetAdapterModeCount(p,a) (p)->lpVtbl->GetAdapterModeCount(p,a)
#define IDirect3D8_EnumAdapterModes(p,a,b,c) (p)->lpVtbl->EnumAdapterModes(p,a,b,c)
#define IDirect3D8_GetAdapterDisplayMode(p,a,b) (p)->lpVtbl->GetAdapterDisplayMode(p,a,b)
#define IDirect3D8_CheckDeviceType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceType(p,a,b,c,d,e)
#define IDirect3D8_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->lpVtbl->CheckDeviceFormat(p,a,b,c,d,e,f)
#define IDirect3D8_CheckDeviceMultiSampleType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceMultiSampleType(p,a,b,c,d,e)
#define IDirect3D8_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->lpVtbl->CheckDepthStencilMatch(p,a,b,c,d,e)
#define IDirect3D8_GetDeviceCaps(p,a,b,c) (p)->lpVtbl->GetDeviceCaps(p,a,b,c)
#define IDirect3D8_GetAdapterMonitor(p,a) (p)->lpVtbl->GetAdapterMonitor(p,a)
#define IDirect3D8_CreateDevice(p,a,b,c,d,e,f) (p)->lpVtbl->CreateDevice(p,a,b,c,d,e,f)
#else
#define IDirect3D8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D8_AddRef(p) (p)->AddRef()
#define IDirect3D8_Release(p) (p)->Release()
#define IDirect3D8_RegisterSoftwareDevice(p,a) (p)->RegisterSoftwareDevice(a)
#define IDirect3D8_GetAdapterCount(p) (p)->GetAdapterCount()
#define IDirect3D8_GetAdapterIdentifier(p,a,b,c) (p)->GetAdapterIdentifier(a,b,c)
#define IDirect3D8_GetAdapterModeCount(p,a) (p)->GetAdapterModeCount(a)
#define IDirect3D8_EnumAdapterModes(p,a,b,c) (p)->EnumAdapterModes(a,b,c)
#define IDirect3D8_GetAdapterDisplayMode(p,a,b) (p)->GetAdapterDisplayMode(a,b)
#define IDirect3D8_CheckDeviceType(p,a,b,c,d,e) (p)->CheckDeviceType(a,b,c,d,e)
#define IDirect3D8_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->CheckDeviceFormat(a,b,c,d,e,f)
#define IDirect3D8_CheckDeviceMultiSampleType(p,a,b,c,d,e) (p)->CheckDeviceMultiSampleType(a,b,c,d,e)
#define IDirect3D8_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->CheckDepthStencilMatch(a,b,c,d,e)
#define IDirect3D8_GetDeviceCaps(p,a,b,c) (p)->GetDeviceCaps(a,b,c)
#define IDirect3D8_GetAdapterMonitor(p,a) (p)->GetAdapterMonitor(a)
#define IDirect3D8_CreateDevice(p,a,b,c,d,e,f) (p)->CreateDevice(a,b,c,d,e,f)
#endif



















#undef INTERFACE
#define INTERFACE IDirect3DDevice8

DECLARE_INTERFACE_(IDirect3DDevice8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice8 methods ***/
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD_(UINT, GetAvailableTextureMem)(THIS) PURE;
    STDMETHOD(ResourceManagerDiscardBytes)(THIS_ DWORD Bytes) PURE;
    STDMETHOD(GetDirect3D)(THIS_ IDirect3D8** ppD3D8) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ D3DCAPS8* pCaps) PURE;
    STDMETHOD(GetDisplayMode)(THIS_ D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetCreationParameters)(THIS_ D3DDEVICE_CREATION_PARAMETERS *pParameters) PURE;
    STDMETHOD(SetCursorProperties)(THIS_ UINT XHotSpot,UINT YHotSpot,IDirect3DSurface8* pCursorBitmap) PURE;
    STDMETHOD_(void, SetCursorPosition)(THIS_ int X,int Y,DWORD Flags) PURE;
    STDMETHOD_(BOOL, ShowCursor)(THIS_ BOOL bShow) PURE;
    STDMETHOD(CreateAdditionalSwapChain)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DSwapChain8** pSwapChain) PURE;
    STDMETHOD(Reset)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT BackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface8** ppBackBuffer) PURE;
    STDMETHOD(GetRasterStatus)(THIS_ D3DRASTER_STATUS* pRasterStatus) PURE;
    STDMETHOD_(void, SetGammaRamp)(THIS_ DWORD Flags,CONST D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD_(void, GetGammaRamp)(THIS_ D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD(CreateTexture)(THIS_ UINT Width,UINT Height,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DTexture8** ppTexture) PURE;
    STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width,UINT Height,UINT Depth,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DVolumeTexture8** ppVolumeTexture) PURE;
    STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DCubeTexture8** ppCubeTexture) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ UINT Length,DWORD Usage,DWORD FVF,D3DPOOL Pool,IDirect3DVertexBuffer8** ppVertexBuffer) PURE;
    STDMETHOD(CreateIndexBuffer)(THIS_ UINT Length,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DIndexBuffer8** ppIndexBuffer) PURE;
    STDMETHOD(CreateRenderTarget)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,BOOL Lockable,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CreateDepthStencilSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CreateImageSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CopyRects)(THIS_ IDirect3DSurface8* pSourceSurface,CONST RECT* pSourceRectsArray,UINT cRects,IDirect3DSurface8* pDestinationSurface,CONST POINT* pDestPointsArray) PURE;
    STDMETHOD(UpdateTexture)(THIS_ IDirect3DBaseTexture8* pSourceTexture,IDirect3DBaseTexture8* pDestinationTexture) PURE;
    STDMETHOD(GetFrontBuffer)(THIS_ IDirect3DSurface8* pDestSurface) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ IDirect3DSurface8* pRenderTarget,IDirect3DSurface8* pNewZStencil) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ IDirect3DSurface8** ppRenderTarget) PURE;
    STDMETHOD(GetDepthStencilSurface)(THIS_ IDirect3DSurface8** ppZStencilSurface) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(Clear)(THIS_ DWORD Count,CONST D3DRECT* pRects,DWORD Flags,D3DCOLOR Color,float Z,DWORD Stencil) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,CONST D3DMATRIX* pMatrix) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,D3DMATRIX* pMatrix) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,CONST D3DMATRIX*) PURE;
    STDMETHOD(SetViewport)(THIS_ CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(GetViewport)(THIS_ D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(SetMaterial)(THIS_ CONST D3DMATERIAL8* pMaterial) PURE;
    STDMETHOD(GetMaterial)(THIS_ D3DMATERIAL8* pMaterial) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD Index,CONST D3DLIGHT8*) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD Index,D3DLIGHT8*) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD Index,BOOL Enable) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD Index,BOOL* pEnable) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD Index,CONST float* pPlane) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD Index,float* pPlane) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD Value) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD* pValue) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ DWORD* pToken) PURE;
    STDMETHOD(ApplyStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(CaptureStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(DeleteStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE Type,DWORD* pToken) PURE;
    STDMETHOD(SetClipStatus)(THIS_ CONST D3DCLIPSTATUS8* pClipStatus) PURE;
    STDMETHOD(GetClipStatus)(THIS_ D3DCLIPSTATUS8* pClipStatus) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture8** ppTexture) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture8* pTexture) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD* pValue) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD Value) PURE;
    STDMETHOD(ValidateDevice)(THIS_ DWORD* pNumPasses) PURE;
    STDMETHOD(GetInfo)(THIS_ DWORD DevInfoID,void* pDevInfoStruct,DWORD DevInfoStructSize) PURE;
    STDMETHOD(SetPaletteEntries)(THIS_ UINT PaletteNumber,CONST PALETTEENTRY* pEntries) PURE;
    STDMETHOD(GetPaletteEntries)(THIS_ UINT PaletteNumber,PALETTEENTRY* pEntries) PURE;
    STDMETHOD(SetCurrentTexturePalette)(THIS_ UINT PaletteNumber) PURE;
    STDMETHOD(GetCurrentTexturePalette)(THIS_ UINT *PaletteNumber) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT StartVertex,UINT PrimitiveCount) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,UINT minIndex,UINT NumVertices,UINT startIndex,UINT primCount) PURE;
    STDMETHOD(DrawPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT PrimitiveCount,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(DrawIndexedPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT MinVertexIndex,UINT NumVertexIndices,UINT PrimitiveCount,CONST void* pIndexData,D3DFORMAT IndexDataFormat,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(ProcessVertices)(THIS_ UINT SrcStartIndex,UINT DestIndex,UINT VertexCount,IDirect3DVertexBuffer8* pDestBuffer,DWORD Flags) PURE;
    STDMETHOD(CreateVertexShader)(THIS_ CONST DWORD* pDeclaration,CONST DWORD* pFunction,DWORD* pHandle,DWORD Usage) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD* pHandle) PURE;
    STDMETHOD(DeleteVertexShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(SetVertexShaderConstant)(THIS_ DWORD Register,CONST void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetVertexShaderConstant)(THIS_ DWORD Register,void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetVertexShaderDeclaration)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(GetVertexShaderFunction)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(SetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer8* pStreamData,UINT Stride) PURE;
    STDMETHOD(GetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer8** ppStreamData,UINT* pStride) PURE;
    STDMETHOD(SetIndices)(THIS_ IDirect3DIndexBuffer8* pIndexData,UINT BaseVertexIndex) PURE;
    STDMETHOD(GetIndices)(THIS_ IDirect3DIndexBuffer8** ppIndexData,UINT* pBaseVertexIndex) PURE;
    STDMETHOD(CreatePixelShader)(THIS_ CONST DWORD* pFunction,DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD* pHandle) PURE;
    STDMETHOD(DeletePixelShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(SetPixelShaderConstant)(THIS_ DWORD Register,CONST void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetPixelShaderConstant)(THIS_ DWORD Register,void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetPixelShaderFunction)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(DrawRectPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DRECTPATCH_INFO* pRectPatchInfo) PURE;
    STDMETHOD(DrawTriPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DTRIPATCH_INFO* pTriPatchInfo) PURE;
    STDMETHOD(DeletePatch)(THIS_ UINT Handle) PURE;
};

typedef struct IDirect3DDevice8 *LPDIRECT3DDEVICE8, *PDIRECT3DDEVICE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice8_TestCooperativeLevel(p) (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirect3DDevice8_GetAvailableTextureMem(p) (p)->lpVtbl->GetAvailableTextureMem(p)
#define IDirect3DDevice8_ResourceManagerDiscardBytes(p,a) (p)->lpVtbl->ResourceManagerDiscardBytes(p,a)
#define IDirect3DDevice8_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice8_GetDeviceCaps(p,a) (p)->lpVtbl->GetDeviceCaps(p,a)
#define IDirect3DDevice8_GetDisplayMode(p,a) (p)->lpVtbl->GetDisplayMode(p,a)
#define IDirect3DDevice8_GetCreationParameters(p,a) (p)->lpVtbl->GetCreationParameters(p,a)
#define IDirect3DDevice8_SetCursorProperties(p,a,b,c) (p)->lpVtbl->SetCursorProperties(p,a,b,c)
#define IDirect3DDevice8_SetCursorPosition(p,a,b,c) (p)->lpVtbl->SetCursorPosition(p,a,b,c)
#define IDirect3DDevice8_ShowCursor(p,a) (p)->lpVtbl->ShowCursor(p,a)
#define IDirect3DDevice8_CreateAdditionalSwapChain(p,a,b) (p)->lpVtbl->CreateAdditionalSwapChain(p,a,b)
#define IDirect3DDevice8_Reset(p,a) (p)->lpVtbl->Reset(p,a)
#define IDirect3DDevice8_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DDevice8_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#define IDirect3DDevice8_GetRasterStatus(p,a) (p)->lpVtbl->GetRasterStatus(p,a)
#define IDirect3DDevice8_SetGammaRamp(p,a,b) (p)->lpVtbl->SetGammaRamp(p,a,b)
#define IDirect3DDevice8_GetGammaRamp(p,a) (p)->lpVtbl->GetGammaRamp(p,a)
#define IDirect3DDevice8_CreateTexture(p,a,b,c,d,e,f,g) (p)->lpVtbl->CreateTexture(p,a,b,c,d,e,f,g)
#define IDirect3DDevice8_CreateVolumeTexture(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->CreateVolumeTexture(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_CreateCubeTexture(p,a,b,c,d,e,f) (p)->lpVtbl->CreateCubeTexture(p,a,b,c,d,e,f)
#define IDirect3DDevice8_CreateVertexBuffer(p,a,b,c,d,e) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateIndexBuffer(p,a,b,c,d,e) (p)->lpVtbl->CreateIndexBuffer(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateRenderTarget(p,a,b,c,d,e,f) (p)->lpVtbl->CreateRenderTarget(p,a,b,c,d,e,f)
#define IDirect3DDevice8_CreateDepthStencilSurface(p,a,b,c,d,e) (p)->lpVtbl->CreateDepthStencilSurface(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateImageSurface(p,a,b,c,d) (p)->lpVtbl->CreateImageSurface(p,a,b,c,d)
#define IDirect3DDevice8_CopyRects(p,a,b,c,d,e) (p)->lpVtbl->CopyRects(p,a,b,c,d,e)
#define IDirect3DDevice8_UpdateTexture(p,a,b) (p)->lpVtbl->UpdateTexture(p,a,b)
#define IDirect3DDevice8_GetFrontBuffer(p,a) (p)->lpVtbl->GetFrontBuffer(p,a)
#define IDirect3DDevice8_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice8_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice8_GetDepthStencilSurface(p,a) (p)->lpVtbl->GetDepthStencilSurface(p,a)
#define IDirect3DDevice8_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice8_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice8_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice8_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice8_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice8_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice8_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice8_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice8_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice8_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice8_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice8_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice8_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice8_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice8_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice8_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice8_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice8_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice8_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice8_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice8_ApplyStateBlock(p,a) (p)->lpVtbl->ApplyStateBlock(p,a)
#define IDirect3DDevice8_CaptureStateBlock(p,a) (p)->lpVtbl->CaptureStateBlock(p,a)
#define IDirect3DDevice8_DeleteStateBlock(p,a) (p)->lpVtbl->DeleteStateBlock(p,a)
#define IDirect3DDevice8_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice8_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice8_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice8_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice8_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice8_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice8_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice8_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice8_GetInfo(p,a,b,c) (p)->lpVtbl->GetInfo(p,a,b,c)
#define IDirect3DDevice8_SetPaletteEntries(p,a,b) (p)->lpVtbl->SetPaletteEntries(p,a,b)
#define IDirect3DDevice8_GetPaletteEntries(p,a,b) (p)->lpVtbl->GetPaletteEntries(p,a,b)
#define IDirect3DDevice8_SetCurrentTexturePalette(p,a) (p)->lpVtbl->SetCurrentTexturePalette(p,a)
#define IDirect3DDevice8_GetCurrentTexturePalette(p,a) (p)->lpVtbl->GetCurrentTexturePalette(p,a)
#define IDirect3DDevice8_DrawPrimitive(p,a,b,c) (p)->lpVtbl->DrawPrimitive(p,a,b,c)
#define IDirect3DDevice8_DrawIndexedPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice8_DrawPrimitiveUP(p,a,b,c,d) (p)->lpVtbl->DrawPrimitiveUP(p,a,b,c,d)
#define IDirect3DDevice8_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_ProcessVertices(p,a,b,c,d,e) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateVertexShader(p,a,b,c,d) (p)->lpVtbl->CreateVertexShader(p,a,b,c,d)
#define IDirect3DDevice8_SetVertexShader(p,a) (p)->lpVtbl->SetVertexShader(p,a)
#define IDirect3DDevice8_GetVertexShader(p,a) (p)->lpVtbl->GetVertexShader(p,a)
#define IDirect3DDevice8_DeleteVertexShader(p,a) (p)->lpVtbl->DeleteVertexShader(p,a)
#define IDirect3DDevice8_SetVertexShaderConstant(p,a,b,c) (p)->lpVtbl->SetVertexShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderConstant(p,a,b,c) (p)->lpVtbl->GetVertexShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderDeclaration(p,a,b,c) (p)->lpVtbl->GetVertexShaderDeclaration(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderFunction(p,a,b,c) (p)->lpVtbl->GetVertexShaderFunction(p,a,b,c)
#define IDirect3DDevice8_SetStreamSource(p,a,b,c) (p)->lpVtbl->SetStreamSource(p,a,b,c)
#define IDirect3DDevice8_GetStreamSource(p,a,b,c) (p)->lpVtbl->GetStreamSource(p,a,b,c)
#define IDirect3DDevice8_SetIndices(p,a,b) (p)->lpVtbl->SetIndices(p,a,b)
#define IDirect3DDevice8_GetIndices(p,a,b) (p)->lpVtbl->GetIndices(p,a,b)
#define IDirect3DDevice8_CreatePixelShader(p,a,b) (p)->lpVtbl->CreatePixelShader(p,a,b)
#define IDirect3DDevice8_SetPixelShader(p,a) (p)->lpVtbl->SetPixelShader(p,a)
#define IDirect3DDevice8_GetPixelShader(p,a) (p)->lpVtbl->GetPixelShader(p,a)
#define IDirect3DDevice8_DeletePixelShader(p,a) (p)->lpVtbl->DeletePixelShader(p,a)
#define IDirect3DDevice8_SetPixelShaderConstant(p,a,b,c) (p)->lpVtbl->SetPixelShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetPixelShaderConstant(p,a,b,c) (p)->lpVtbl->GetPixelShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetPixelShaderFunction(p,a,b,c) (p)->lpVtbl->GetPixelShaderFunction(p,a,b,c)
#define IDirect3DDevice8_DrawRectPatch(p,a,b,c) (p)->lpVtbl->DrawRectPatch(p,a,b,c)
#define IDirect3DDevice8_DrawTriPatch(p,a,b,c) (p)->lpVtbl->DrawTriPatch(p,a,b,c)
#define IDirect3DDevice8_DeletePatch(p,a) (p)->lpVtbl->DeletePatch(p,a)
#else
#define IDirect3DDevice8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice8_AddRef(p) (p)->AddRef()
#define IDirect3DDevice8_Release(p) (p)->Release()
#define IDirect3DDevice8_TestCooperativeLevel(p) (p)->TestCooperativeLevel()
#define IDirect3DDevice8_GetAvailableTextureMem(p) (p)->GetAvailableTextureMem()
#define IDirect3DDevice8_ResourceManagerDiscardBytes(p,a) (p)->ResourceManagerDiscardBytes(a)
#define IDirect3DDevice8_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice8_GetDeviceCaps(p,a) (p)->GetDeviceCaps(a)
#define IDirect3DDevice8_GetDisplayMode(p,a) (p)->GetDisplayMode(a)
#define IDirect3DDevice8_GetCreationParameters(p,a) (p)->GetCreationParameters(a)
#define IDirect3DDevice8_SetCursorProperties(p,a,b,c) (p)->SetCursorProperties(a,b,c)
#define IDirect3DDevice8_SetCursorPosition(p,a,b,c) (p)->SetCursorPosition(a,b,c)
#define IDirect3DDevice8_ShowCursor(p,a) (p)->ShowCursor(a)
#define IDirect3DDevice8_CreateAdditionalSwapChain(p,a,b) (p)->CreateAdditionalSwapChain(a,b)
#define IDirect3DDevice8_Reset(p,a) (p)->Reset(a)
#define IDirect3DDevice8_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DDevice8_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#define IDirect3DDevice8_GetRasterStatus(p,a) (p)->GetRasterStatus(a)
#define IDirect3DDevice8_SetGammaRamp(p,a,b) (p)->SetGammaRamp(a,b)
#define IDirect3DDevice8_GetGammaRamp(p,a) (p)->GetGammaRamp(a)
#define IDirect3DDevice8_CreateTexture(p,a,b,c,d,e,f,g) (p)->CreateTexture(a,b,c,d,e,f,g)
#define IDirect3DDevice8_CreateVolumeTexture(p,a,b,c,d,e,f,g,h) (p)->CreateVolumeTexture(a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_CreateCubeTexture(p,a,b,c,d,e,f) (p)->CreateCubeTexture(a,b,c,d,e,f)
#define IDirect3DDevice8_CreateVertexBuffer(p,a,b,c,d,e) (p)->CreateVertexBuffer(a,b,c,d,e)
#define IDirect3DDevice8_CreateIndexBuffer(p,a,b,c,d,e) (p)->CreateIndexBuffer(a,b,c,d,e)
#define IDirect3DDevice8_CreateRenderTarget(p,a,b,c,d,e,f) (p)->CreateRenderTarget(a,b,c,d,e,f)
#define IDirect3DDevice8_CreateDepthStencilSurface(p,a,b,c,d,e) (p)->CreateDepthStencilSurface(a,b,c,d,e)
#define IDirect3DDevice8_CreateImageSurface(p,a,b,c,d) (p)->CreateImageSurface(a,b,c,d)
#define IDirect3DDevice8_CopyRects(p,a,b,c,d,e) (p)->CopyRects(a,b,c,d,e)
#define IDirect3DDevice8_UpdateTexture(p,a,b) (p)->UpdateTexture(a,b)
#define IDirect3DDevice8_GetFrontBuffer(p,a) (p)->GetFrontBuffer(a)
#define IDirect3DDevice8_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice8_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice8_GetDepthStencilSurface(p,a) (p)->GetDepthStencilSurface(a)
#define IDirect3DDevice8_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice8_EndScene(p) (p)->EndScene()
#define IDirect3DDevice8_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice8_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice8_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice8_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice8_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice8_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice8_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice8_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice8_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice8_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice8_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice8_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice8_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice8_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice8_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice8_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice8_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice8_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice8_ApplyStateBlock(p,a) (p)->ApplyStateBlock(a)
#define IDirect3DDevice8_CaptureStateBlock(p,a) (p)->CaptureStateBlock(a)
#define IDirect3DDevice8_DeleteStateBlock(p,a) (p)->DeleteStateBlock(a)
#define IDirect3DDevice8_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice8_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice8_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice8_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice8_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice8_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice8_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice8_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice8_GetInfo(p,a,b,c) (p)->GetInfo(a,b,c)
#define IDirect3DDevice8_SetPaletteEntries(p,a,b) (p)->SetPaletteEntries(a,b)
#define IDirect3DDevice8_GetPaletteEntries(p,a,b) (p)->GetPaletteEntries(a,b)
#define IDirect3DDevice8_SetCurrentTexturePalette(p,a) (p)->SetCurrentTexturePalette(a)
#define IDirect3DDevice8_GetCurrentTexturePalette(p,a) (p)->GetCurrentTexturePalette(a)
#define IDirect3DDevice8_DrawPrimitive(p,a,b,c) (p)->DrawPrimitive(a,b,c)
#define IDirect3DDevice8_DrawIndexedPrimitive(p,a,b,c,d,e) (p)->DrawIndexedPrimitive(a,b,c,d,e)
#define IDirect3DDevice8_DrawPrimitiveUP(p,a,b,c,d) (p)->DrawPrimitiveUP(a,b,c,d)
#define IDirect3DDevice8_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->DrawIndexedPrimitiveUP(a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_ProcessVertices(p,a,b,c,d,e) (p)->ProcessVertices(a,b,c,d,e)
#define IDirect3DDevice8_CreateVertexShader(p,a,b,c,d) (p)->CreateVertexShader(a,b,c,d)
#define IDirect3DDevice8_SetVertexShader(p,a) (p)->SetVertexShader(a)
#define IDirect3DDevice8_GetVertexShader(p,a) (p)->GetVertexShader(a)
#define IDirect3DDevice8_DeleteVertexShader(p,a) (p)->DeleteVertexShader(a)
#define IDirect3DDevice8_SetVertexShaderConstant(p,a,b,c) (p)->SetVertexShaderConstant(a,b,c)
#define IDirect3DDevice8_GetVertexShaderConstant(p,a,b,c) (p)->GetVertexShaderConstant(a,b,c)
#define IDirect3DDevice8_GetVertexShaderDeclaration(p,a,b,c) (p)->GetVertexShaderDeclaration(a,b,c)
#define IDirect3DDevice8_GetVertexShaderFunction(p,a,b,c) (p)->GetVertexShaderFunction(a,b,c)
#define IDirect3DDevice8_SetStreamSource(p,a,b,c) (p)->SetStreamSource(a,b,c)
#define IDirect3DDevice8_GetStreamSource(p,a,b,c) (p)->GetStreamSource(a,b,c)
#define IDirect3DDevice8_SetIndices(p,a,b) (p)->SetIndices(a,b)
#define IDirect3DDevice8_GetIndices(p,a,b) (p)->GetIndices(a,b)
#define IDirect3DDevice8_CreatePixelShader(p,a,b) (p)->CreatePixelShader(a,b)
#define IDirect3DDevice8_SetPixelShader(p,a) (p)->SetPixelShader(a)
#define IDirect3DDevice8_GetPixelShader(p,a) (p)->GetPixelShader(a)
#define IDirect3DDevice8_DeletePixelShader(p,a) (p)->DeletePixelShader(a)
#define IDirect3DDevice8_SetPixelShaderConstant(p,a,b,c) (p)->SetPixelShaderConstant(a,b,c)
#define IDirect3DDevice8_GetPixelShaderConstant(p,a,b,c) (p)->GetPixelShaderConstant(a,b,c)
#define IDirect3DDevice8_GetPixelShaderFunction(p,a,b,c) (p)->GetPixelShaderFunction(a,b,c)
#define IDirect3DDevice8_DrawRectPatch(p,a,b,c) (p)->DrawRectPatch(a,b,c)
#define IDirect3DDevice8_DrawTriPatch(p,a,b,c) (p)->DrawTriPatch(a,b,c)
#define IDirect3DDevice8_DeletePatch(p,a) (p)->DeletePatch(a)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DSwapChain8

DECLARE_INTERFACE_(IDirect3DSwapChain8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSwapChain8 methods ***/
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT BackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface8** ppBackBuffer) PURE;
};

typedef struct IDirect3DSwapChain8 *LPDIRECT3DSWAPCHAIN8, *PDIRECT3DSWAPCHAIN8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSwapChain8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSwapChain8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSwapChain8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSwapChain8_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DSwapChain8_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#else
#define IDirect3DSwapChain8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSwapChain8_AddRef(p) (p)->AddRef()
#define IDirect3DSwapChain8_Release(p) (p)->Release()
#define IDirect3DSwapChain8_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DSwapChain8_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DResource8

DECLARE_INTERFACE_(IDirect3DResource8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
};

typedef struct IDirect3DResource8 *LPDIRECT3DRESOURCE8, *PDIRECT3DRESOURCE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DResource8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DResource8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DResource8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DResource8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DResource8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DResource8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DResource8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DResource8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DResource8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DResource8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DResource8_GetType(p) (p)->lpVtbl->GetType(p)
#else
#define IDirect3DResource8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DResource8_AddRef(p) (p)->AddRef()
#define IDirect3DResource8_Release(p) (p)->Release()
#define IDirect3DResource8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DResource8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DResource8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DResource8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DResource8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DResource8_GetPriority(p) (p)->GetPriority()
#define IDirect3DResource8_PreLoad(p) (p)->PreLoad()
#define IDirect3DResource8_GetType(p) (p)->GetType()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DBaseTexture8

DECLARE_INTERFACE_(IDirect3DBaseTexture8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
};

typedef struct IDirect3DBaseTexture8 *LPDIRECT3DBASETEXTURE8, *PDIRECT3DBASETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DBaseTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DBaseTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DBaseTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DBaseTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DBaseTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DBaseTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DBaseTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DBaseTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DBaseTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DBaseTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DBaseTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DBaseTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DBaseTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DBaseTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#else
#define IDirect3DBaseTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DBaseTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DBaseTexture8_Release(p) (p)->Release()
#define IDirect3DBaseTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DBaseTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DBaseTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DBaseTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DBaseTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DBaseTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DBaseTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DBaseTexture8_GetType(p) (p)->GetType()
#define IDirect3DBaseTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DBaseTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DBaseTexture8_GetLevelCount(p) (p)->GetLevelCount()
#endif





#undef INTERFACE
#define INTERFACE IDirect3DTexture8

DECLARE_INTERFACE_(IDirect3DTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetSurfaceLevel)(THIS_ UINT Level,IDirect3DSurface8** ppSurfaceLevel) PURE;
    STDMETHOD(LockRect)(THIS_ UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ CONST RECT* pDirtyRect) PURE;
};

typedef struct IDirect3DTexture8 *LPDIRECT3DTEXTURE8, *PDIRECT3DTEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DTexture8_GetSurfaceLevel(p,a,b) (p)->lpVtbl->GetSurfaceLevel(p,a,b)
#define IDirect3DTexture8_LockRect(p,a,b,c,d) (p)->lpVtbl->LockRect(p,a,b,c,d)
#define IDirect3DTexture8_UnlockRect(p,a) (p)->lpVtbl->UnlockRect(p,a)
#define IDirect3DTexture8_AddDirtyRect(p,a) (p)->lpVtbl->AddDirtyRect(p,a)
#else
#define IDirect3DTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DTexture8_Release(p) (p)->Release()
#define IDirect3DTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DTexture8_GetType(p) (p)->GetType()
#define IDirect3DTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DTexture8_GetSurfaceLevel(p,a,b) (p)->GetSurfaceLevel(a,b)
#define IDirect3DTexture8_LockRect(p,a,b,c,d) (p)->LockRect(a,b,c,d)
#define IDirect3DTexture8_UnlockRect(p,a) (p)->UnlockRect(a)
#define IDirect3DTexture8_AddDirtyRect(p,a) (p)->AddDirtyRect(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DVolumeTexture8

DECLARE_INTERFACE_(IDirect3DVolumeTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(GetVolumeLevel)(THIS_ UINT Level,IDirect3DVolume8** ppVolumeLevel) PURE;
    STDMETHOD(LockBox)(THIS_ UINT Level,D3DLOCKED_BOX* pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyBox)(THIS_ CONST D3DBOX* pDirtyBox) PURE;
};

typedef struct IDirect3DVolumeTexture8 *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolumeTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolumeTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolumeTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolumeTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolumeTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolumeTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolumeTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolumeTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVolumeTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVolumeTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVolumeTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVolumeTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DVolumeTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DVolumeTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DVolumeTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DVolumeTexture8_GetVolumeLevel(p,a,b) (p)->lpVtbl->GetVolumeLevel(p,a,b)
#define IDirect3DVolumeTexture8_LockBox(p,a,b,c,d) (p)->lpVtbl->LockBox(p,a,b,c,d)
#define IDirect3DVolumeTexture8_UnlockBox(p,a) (p)->lpVtbl->UnlockBox(p,a)
#define IDirect3DVolumeTexture8_AddDirtyBox(p,a) (p)->lpVtbl->AddDirtyBox(p,a)
#else
#define IDirect3DVolumeTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolumeTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DVolumeTexture8_Release(p) (p)->Release()
#define IDirect3DVolumeTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolumeTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolumeTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolumeTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolumeTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVolumeTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DVolumeTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DVolumeTexture8_GetType(p) (p)->GetType()
#define IDirect3DVolumeTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DVolumeTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DVolumeTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DVolumeTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DVolumeTexture8_GetVolumeLevel(p,a,b) (p)->GetVolumeLevel(a,b)
#define IDirect3DVolumeTexture8_LockBox(p,a,b,c,d) (p)->LockBox(a,b,c,d)
#define IDirect3DVolumeTexture8_UnlockBox(p,a) (p)->UnlockBox(a)
#define IDirect3DVolumeTexture8_AddDirtyBox(p,a) (p)->AddDirtyBox(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DCubeTexture8

DECLARE_INTERFACE_(IDirect3DCubeTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetCubeMapSurface)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,IDirect3DSurface8** ppCubeMapSurface) PURE;
    STDMETHOD(LockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ D3DCUBEMAP_FACES FaceType,CONST RECT* pDirtyRect) PURE;
};

typedef struct IDirect3DCubeTexture8 *LPDIRECT3DCUBETEXTURE8, *PDIRECT3DCUBETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DCubeTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DCubeTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DCubeTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DCubeTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DCubeTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DCubeTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DCubeTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DCubeTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DCubeTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DCubeTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DCubeTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DCubeTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DCubeTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DCubeTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DCubeTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DCubeTexture8_GetCubeMapSurface(p,a,b,c) (p)->lpVtbl->GetCubeMapSurface(p,a,b,c)
#define IDirect3DCubeTexture8_LockRect(p,a,b,c,d,e) (p)->lpVtbl->LockRect(p,a,b,c,d,e)
#define IDirect3DCubeTexture8_UnlockRect(p,a,b) (p)->lpVtbl->UnlockRect(p,a,b)
#define IDirect3DCubeTexture8_AddDirtyRect(p,a,b) (p)->lpVtbl->AddDirtyRect(p,a,b)
#else
#define IDirect3DCubeTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DCubeTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DCubeTexture8_Release(p) (p)->Release()
#define IDirect3DCubeTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DCubeTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DCubeTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DCubeTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DCubeTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DCubeTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DCubeTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DCubeTexture8_GetType(p) (p)->GetType()
#define IDirect3DCubeTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DCubeTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DCubeTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DCubeTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DCubeTexture8_GetCubeMapSurface(p,a,b,c) (p)->GetCubeMapSurface(a,b,c)
#define IDirect3DCubeTexture8_LockRect(p,a,b,c,d,e) (p)->LockRect(a,b,c,d,e)
#define IDirect3DCubeTexture8_UnlockRect(p,a,b) (p)->UnlockRect(a,b)
#define IDirect3DCubeTexture8_AddDirtyRect(p,a,b) (p)->AddDirtyRect(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer8

DECLARE_INTERFACE_(IDirect3DVertexBuffer8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,BYTE** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVERTEXBUFFER_DESC *pDesc) PURE;
};

typedef struct IDirect3DVertexBuffer8 *LPDIRECT3DVERTEXBUFFER8, *PDIRECT3DVERTEXBUFFER8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVertexBuffer8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVertexBuffer8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVertexBuffer8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVertexBuffer8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVertexBuffer8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVertexBuffer8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVertexBuffer8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVertexBuffer8_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DVertexBuffer8_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DVertexBuffer8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer8_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer8_Release(p) (p)->Release()
#define IDirect3DVertexBuffer8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVertexBuffer8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVertexBuffer8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVertexBuffer8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVertexBuffer8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVertexBuffer8_GetPriority(p) (p)->GetPriority()
#define IDirect3DVertexBuffer8_PreLoad(p) (p)->PreLoad()
#define IDirect3DVertexBuffer8_GetType(p) (p)->GetType()
#define IDirect3DVertexBuffer8_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DVertexBuffer8_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer8_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DIndexBuffer8

DECLARE_INTERFACE_(IDirect3DIndexBuffer8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,BYTE** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DINDEXBUFFER_DESC *pDesc) PURE;
};

typedef struct IDirect3DIndexBuffer8 *LPDIRECT3DINDEXBUFFER8, *PDIRECT3DINDEXBUFFER8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DIndexBuffer8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DIndexBuffer8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DIndexBuffer8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DIndexBuffer8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DIndexBuffer8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DIndexBuffer8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DIndexBuffer8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DIndexBuffer8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DIndexBuffer8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DIndexBuffer8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DIndexBuffer8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DIndexBuffer8_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DIndexBuffer8_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DIndexBuffer8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DIndexBuffer8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DIndexBuffer8_AddRef(p) (p)->AddRef()
#define IDirect3DIndexBuffer8_Release(p) (p)->Release()
#define IDirect3DIndexBuffer8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DIndexBuffer8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DIndexBuffer8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DIndexBuffer8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DIndexBuffer8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DIndexBuffer8_GetPriority(p) (p)->GetPriority()
#define IDirect3DIndexBuffer8_PreLoad(p) (p)->PreLoad()
#define IDirect3DIndexBuffer8_GetType(p) (p)->GetType()
#define IDirect3DIndexBuffer8_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DIndexBuffer8_Unlock(p) (p)->Unlock()
#define IDirect3DIndexBuffer8_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DSurface8

DECLARE_INTERFACE_(IDirect3DSurface8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSurface8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(LockRect)(THIS_ D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS) PURE;
};

typedef struct IDirect3DSurface8 *LPDIRECT3DSURFACE8, *PDIRECT3DSURFACE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSurface8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSurface8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSurface8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSurface8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DSurface8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DSurface8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DSurface8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DSurface8_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DSurface8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DSurface8_LockRect(p,a,b,c) (p)->lpVtbl->LockRect(p,a,b,c)
#define IDirect3DSurface8_UnlockRect(p) (p)->lpVtbl->UnlockRect(p)
#else
#define IDirect3DSurface8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSurface8_AddRef(p) (p)->AddRef()
#define IDirect3DSurface8_Release(p) (p)->Release()
#define IDirect3DSurface8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DSurface8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DSurface8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DSurface8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DSurface8_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DSurface8_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DSurface8_LockRect(p,a,b,c) (p)->LockRect(a,b,c)
#define IDirect3DSurface8_UnlockRect(p) (p)->UnlockRect()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVolume8

DECLARE_INTERFACE_(IDirect3DVolume8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVolume8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(LockBox)(THIS_ D3DLOCKED_BOX * pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS) PURE;
};

typedef struct IDirect3DVolume8 *LPDIRECT3DVOLUME8, *PDIRECT3DVOLUME8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolume8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolume8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolume8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolume8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolume8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolume8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolume8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolume8_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DVolume8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DVolume8_LockBox(p,a,b,c) (p)->lpVtbl->LockBox(p,a,b,c)
#define IDirect3DVolume8_UnlockBox(p) (p)->lpVtbl->UnlockBox(p)
#else
#define IDirect3DVolume8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolume8_AddRef(p) (p)->AddRef()
#define IDirect3DVolume8_Release(p) (p)->Release()
#define IDirect3DVolume8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolume8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolume8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolume8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolume8_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DVolume8_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DVolume8_LockBox(p,a,b,c) (p)->LockBox(a,b,c)
#define IDirect3DVolume8_UnlockBox(p) (p)->UnlockBox()
#endif

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/
#define D3DSPD_IUNKNOWN                         0x00000001L

/****************************************************************************
 *
 * Parameter for IDirect3D8 Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for IDirect3D8::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_FPU_PRESERVE                  0x00000002L
#define D3DCREATE_MULTITHREADED                 0x00000004L

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L

#define D3DCREATE_DISABLE_DRIVER_MANAGEMENT     0x00000100L


/****************************************************************************
 *
 * Parameter for IDirect3D8::CreateDevice's iAdapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for IDirect3D8::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             3L

/****************************************************************************
 *
 * Flags for IDirect3DDevice8::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L

/****************************************************************************
 *
 * Flags for IDirect3DDevice8::SetCursorPosition
 *
 ****************************************************************************/

#define D3DCURSOR_IMMEDIATE_UPDATE             0x00000001L

/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/


/*
 *  DirectDraw error codes
 */
#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */
#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)
#define D3DERR_DRIVERINVALIDCALL                MAKE_D3DHRESULT(2157)

#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d9.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3d9.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D9_H_
#define _D3D9_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0900
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX9 interfaces
#if(DIRECT3D_VERSION >= 0x0900)


/* This identifier is passed to Direct3DCreate9 in order to ensure that an
 * application was built against the correct header files. This number is
 * incremented whenever a header (or other) change would require applications
 * to be rebuilt. If the version doesn't match, Direct3DCreate9 will fail.
 * (The number itself has no meaning.)*/

#ifdef D3D_DEBUG_INFO
#define D3D_SDK_VERSION   (32 | 0x80000000)
#define D3D9b_SDK_VERSION (31 | 0x80000000)

#else
#define D3D_SDK_VERSION   32
#define D3D9b_SDK_VERSION 31
#endif


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <windows.h>

#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
    #define HMONITOR_DECLARED
    DECLARE_HANDLE(HMONITOR);
#endif

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

/* IID_IDirect3D9 */
/* {81BDCBCA-64D4-426d-AE8D-AD0147F4275C} */
DEFINE_GUID(IID_IDirect3D9, 0x81bdcbca, 0x64d4, 0x426d, 0xae, 0x8d, 0xad, 0x1, 0x47, 0xf4, 0x27, 0x5c);

/* IID_IDirect3DDevice9 */
// {D0223B96-BF7A-43fd-92BD-A43B0D82B9EB} */
DEFINE_GUID(IID_IDirect3DDevice9, 0xd0223b96, 0xbf7a, 0x43fd, 0x92, 0xbd, 0xa4, 0x3b, 0xd, 0x82, 0xb9, 0xeb);

/* IID_IDirect3DResource9 */
// {05EEC05D-8F7D-4362-B999-D1BAF357C704}
DEFINE_GUID(IID_IDirect3DResource9, 0x5eec05d, 0x8f7d, 0x4362, 0xb9, 0x99, 0xd1, 0xba, 0xf3, 0x57, 0xc7, 0x4);

/* IID_IDirect3DBaseTexture9 */
/* {580CA87E-1D3C-4d54-991D-B7D3E3C298CE} */
DEFINE_GUID(IID_IDirect3DBaseTexture9, 0x580ca87e, 0x1d3c, 0x4d54, 0x99, 0x1d, 0xb7, 0xd3, 0xe3, 0xc2, 0x98, 0xce);

/* IID_IDirect3DTexture9 */
/* {85C31227-3DE5-4f00-9B3A-F11AC38C18B5} */
DEFINE_GUID(IID_IDirect3DTexture9, 0x85c31227, 0x3de5, 0x4f00, 0x9b, 0x3a, 0xf1, 0x1a, 0xc3, 0x8c, 0x18, 0xb5);

/* IID_IDirect3DCubeTexture9 */
/* {FFF32F81-D953-473a-9223-93D652ABA93F} */
DEFINE_GUID(IID_IDirect3DCubeTexture9, 0xfff32f81, 0xd953, 0x473a, 0x92, 0x23, 0x93, 0xd6, 0x52, 0xab, 0xa9, 0x3f);

/* IID_IDirect3DVolumeTexture9 */
/* {2518526C-E789-4111-A7B9-47EF328D13E6} */
DEFINE_GUID(IID_IDirect3DVolumeTexture9, 0x2518526c, 0xe789, 0x4111, 0xa7, 0xb9, 0x47, 0xef, 0x32, 0x8d, 0x13, 0xe6);

/* IID_IDirect3DVertexBuffer9 */
/* {B64BB1B5-FD70-4df6-BF91-19D0A12455E3} */
DEFINE_GUID(IID_IDirect3DVertexBuffer9, 0xb64bb1b5, 0xfd70, 0x4df6, 0xbf, 0x91, 0x19, 0xd0, 0xa1, 0x24, 0x55, 0xe3);

/* IID_IDirect3DIndexBuffer9 */
/* {7C9DD65E-D3F7-4529-ACEE-785830ACDE35} */
DEFINE_GUID(IID_IDirect3DIndexBuffer9, 0x7c9dd65e, 0xd3f7, 0x4529, 0xac, 0xee, 0x78, 0x58, 0x30, 0xac, 0xde, 0x35);

/* IID_IDirect3DSurface9 */
/* {0CFBAF3A-9FF6-429a-99B3-A2796AF8B89B} */
DEFINE_GUID(IID_IDirect3DSurface9, 0xcfbaf3a, 0x9ff6, 0x429a, 0x99, 0xb3, 0xa2, 0x79, 0x6a, 0xf8, 0xb8, 0x9b);

/* IID_IDirect3DVolume9 */
/* {24F416E6-1F67-4aa7-B88E-D33F6F3128A1} */
DEFINE_GUID(IID_IDirect3DVolume9, 0x24f416e6, 0x1f67, 0x4aa7, 0xb8, 0x8e, 0xd3, 0x3f, 0x6f, 0x31, 0x28, 0xa1);

/* IID_IDirect3DSwapChain9 */
/* {794950F2-ADFC-458a-905E-10A10B0B503B} */
DEFINE_GUID(IID_IDirect3DSwapChain9, 0x794950f2, 0xadfc, 0x458a, 0x90, 0x5e, 0x10, 0xa1, 0xb, 0xb, 0x50, 0x3b);

/* IID_IDirect3DVertexDeclaration9 */
/* {DD13C59C-36FA-4098-A8FB-C7ED39DC8546} */
DEFINE_GUID(IID_IDirect3DVertexDeclaration9, 0xdd13c59c, 0x36fa, 0x4098, 0xa8, 0xfb, 0xc7, 0xed, 0x39, 0xdc, 0x85, 0x46);

/* IID_IDirect3DVertexShader9 */
/* {EFC5557E-6265-4613-8A94-43857889EB36} */
DEFINE_GUID(IID_IDirect3DVertexShader9, 0xefc5557e, 0x6265, 0x4613, 0x8a, 0x94, 0x43, 0x85, 0x78, 0x89, 0xeb, 0x36);

/* IID_IDirect3DPixelShader9 */
/* {6D3BDBDC-5B02-4415-B852-CE5E8BCCB289} */
DEFINE_GUID(IID_IDirect3DPixelShader9, 0x6d3bdbdc, 0x5b02, 0x4415, 0xb8, 0x52, 0xce, 0x5e, 0x8b, 0xcc, 0xb2, 0x89);

/* IID_IDirect3DStateBlock9 */
/* {B07C4FE5-310D-4ba8-A23C-4F0F206F218B} */
DEFINE_GUID(IID_IDirect3DStateBlock9, 0xb07c4fe5, 0x310d, 0x4ba8, 0xa2, 0x3c, 0x4f, 0xf, 0x20, 0x6f, 0x21, 0x8b);

/* IID_IDirect3DQuery9 */
/* {d9771460-a695-4f26-bbd3-27b840b541cc} */
DEFINE_GUID(IID_IDirect3DQuery9, 0xd9771460, 0xa695, 0x4f26, 0xbb, 0xd3, 0x27, 0xb8, 0x40, 0xb5, 0x41, 0xcc);


/* IID_HelperName */
/* {E4A36723-FDFE-4b22-B146-3C04C07F4CC8} */
DEFINE_GUID(IID_HelperName, 0xe4a36723, 0xfdfe, 0x4b22, 0xb1, 0x46, 0x3c, 0x4, 0xc0, 0x7f, 0x4c, 0xc8);


#endif

#ifdef __cplusplus

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

interface DECLSPEC_UUID("81BDCBCA-64D4-426d-AE8D-AD0147F4275C") IDirect3D9;
interface DECLSPEC_UUID("D0223B96-BF7A-43fd-92BD-A43B0D82B9EB") IDirect3DDevice9;

interface DECLSPEC_UUID("B07C4FE5-310D-4ba8-A23C-4F0F206F218B") IDirect3DStateBlock9;
interface DECLSPEC_UUID("05EEC05D-8F7D-4362-B999-D1BAF357C704") IDirect3DResource9;
interface DECLSPEC_UUID("DD13C59C-36FA-4098-A8FB-C7ED39DC8546") IDirect3DVertexDeclaration9;
interface DECLSPEC_UUID("EFC5557E-6265-4613-8A94-43857889EB36") IDirect3DVertexShader9;
interface DECLSPEC_UUID("6D3BDBDC-5B02-4415-B852-CE5E8BCCB289") IDirect3DPixelShader9;
interface DECLSPEC_UUID("580CA87E-1D3C-4d54-991D-B7D3E3C298CE") IDirect3DBaseTexture9;
interface DECLSPEC_UUID("85C31227-3DE5-4f00-9B3A-F11AC38C18B5") IDirect3DTexture9;
interface DECLSPEC_UUID("2518526C-E789-4111-A7B9-47EF328D13E6") IDirect3DVolumeTexture9;
interface DECLSPEC_UUID("FFF32F81-D953-473a-9223-93D652ABA93F") IDirect3DCubeTexture9;

interface DECLSPEC_UUID("B64BB1B5-FD70-4df6-BF91-19D0A12455E3") IDirect3DVertexBuffer9;
interface DECLSPEC_UUID("7C9DD65E-D3F7-4529-ACEE-785830ACDE35") IDirect3DIndexBuffer9;

interface DECLSPEC_UUID("0CFBAF3A-9FF6-429a-99B3-A2796AF8B89B") IDirect3DSurface9;
interface DECLSPEC_UUID("24F416E6-1F67-4aa7-B88E-D33F6F3128A1") IDirect3DVolume9;

interface DECLSPEC_UUID("794950F2-ADFC-458a-905E-10A10B0B503B") IDirect3DSwapChain9;
interface DECLSPEC_UUID("d9771460-a695-4f26-bbd3-27b840b541cc") IDirect3DQuery9;


#if defined(_COM_SMARTPTR_TYPEDEF)
_COM_SMARTPTR_TYPEDEF(IDirect3D9, __uuidof(IDirect3D9));
_COM_SMARTPTR_TYPEDEF(IDirect3DDevice9, __uuidof(IDirect3DDevice9));

_COM_SMARTPTR_TYPEDEF(IDirect3DStateBlock9, __uuidof(IDirect3DStateBlock9));
_COM_SMARTPTR_TYPEDEF(IDirect3DResource9, __uuidof(IDirect3DResource9));
_COM_SMARTPTR_TYPEDEF(IDirect3DVertexDeclaration9, __uuidof(IDirect3DVertexDeclaration9));
_COM_SMARTPTR_TYPEDEF(IDirect3DVertexShader9, __uuidof(IDirect3DVertexShader9));
_COM_SMARTPTR_TYPEDEF(IDirect3DPixelShader9, __uuidof(IDirect3DPixelShader9));
_COM_SMARTPTR_TYPEDEF(IDirect3DBaseTexture9, __uuidof(IDirect3DBaseTexture9));
_COM_SMARTPTR_TYPEDEF(IDirect3DTexture9, __uuidof(IDirect3DTexture9));
_COM_SMARTPTR_TYPEDEF(IDirect3DVolumeTexture9, __uuidof(IDirect3DVolumeTexture9));
_COM_SMARTPTR_TYPEDEF(IDirect3DCubeTexture9, __uuidof(IDirect3DCubeTexture9));

_COM_SMARTPTR_TYPEDEF(IDirect3DVertexBuffer9, __uuidof(IDirect3DVertexBuffer9));
_COM_SMARTPTR_TYPEDEF(IDirect3DIndexBuffer9, __uuidof(IDirect3DIndexBuffer9));

_COM_SMARTPTR_TYPEDEF(IDirect3DSurface9, __uuidof(IDirect3DSurface9));
_COM_SMARTPTR_TYPEDEF(IDirect3DVolume9, __uuidof(IDirect3DVolume9));

_COM_SMARTPTR_TYPEDEF(IDirect3DSwapChain9, __uuidof(IDirect3DSwapChain9));
_COM_SMARTPTR_TYPEDEF(IDirect3DQuery9, __uuidof(IDirect3DQuery9));

#endif
#endif


typedef interface IDirect3D9                    IDirect3D9;
typedef interface IDirect3DDevice9              IDirect3DDevice9;
typedef interface IDirect3DStateBlock9          IDirect3DStateBlock9;
typedef interface IDirect3DVertexDeclaration9   IDirect3DVertexDeclaration9;
typedef interface IDirect3DVertexShader9        IDirect3DVertexShader9;
typedef interface IDirect3DPixelShader9         IDirect3DPixelShader9;
typedef interface IDirect3DResource9            IDirect3DResource9;
typedef interface IDirect3DBaseTexture9         IDirect3DBaseTexture9;
typedef interface IDirect3DTexture9             IDirect3DTexture9;
typedef interface IDirect3DVolumeTexture9       IDirect3DVolumeTexture9;
typedef interface IDirect3DCubeTexture9         IDirect3DCubeTexture9;
typedef interface IDirect3DVertexBuffer9        IDirect3DVertexBuffer9;
typedef interface IDirect3DIndexBuffer9         IDirect3DIndexBuffer9;
typedef interface IDirect3DSurface9             IDirect3DSurface9;
typedef interface IDirect3DVolume9              IDirect3DVolume9;
typedef interface IDirect3DSwapChain9           IDirect3DSwapChain9;
typedef interface IDirect3DQuery9               IDirect3DQuery9;


#include "d3d9types.h"
#include "d3d9caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * DLL Function for creating a Direct3D9 object. This object supports
 * enumeration and allows the creation of Direct3DDevice9 objects.
 * Pass the value of the constant D3D_SDK_VERSION to this function, so
 * that the run-time can validate that your application was compiled
 * against the right headers.
 */

IDirect3D9 * WINAPI Direct3DCreate9(UINT SDKVersion);

/*
 * Stubs for graphics profiling.
 */
 
int WINAPI D3DPERF_BeginEvent( D3DCOLOR col, LPCWSTR wszName );
int WINAPI D3DPERF_EndEvent( void );
void WINAPI D3DPERF_SetMarker( D3DCOLOR col, LPCWSTR wszName );
void WINAPI D3DPERF_SetRegion( D3DCOLOR col, LPCWSTR wszName );
BOOL WINAPI D3DPERF_QueryRepeatFrame( void );

void WINAPI D3DPERF_SetOptions( DWORD dwOptions );
DWORD WINAPI D3DPERF_GetStatus( void );

/*
 * Direct3D interfaces
 */






#undef INTERFACE
#define INTERFACE IDirect3D9

DECLARE_INTERFACE_(IDirect3D9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D9 methods ***/
    STDMETHOD(RegisterSoftwareDevice)(THIS_ void* pInitializeFunction) PURE;
    STDMETHOD_(UINT, GetAdapterCount)(THIS) PURE;
    STDMETHOD(GetAdapterIdentifier)(THIS_ UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER9* pIdentifier) PURE;
    STDMETHOD_(UINT, GetAdapterModeCount)(THIS_ UINT Adapter,D3DFORMAT Format) PURE;
    STDMETHOD(EnumAdapterModes)(THIS_ UINT Adapter,D3DFORMAT Format,UINT Mode,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetAdapterDisplayMode)(THIS_ UINT Adapter,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(CheckDeviceType)(THIS_ UINT Adapter,D3DDEVTYPE DevType,D3DFORMAT AdapterFormat,D3DFORMAT BackBufferFormat,BOOL bWindowed) PURE;
    STDMETHOD(CheckDeviceFormat)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,DWORD Usage,D3DRESOURCETYPE RType,D3DFORMAT CheckFormat) PURE;
    STDMETHOD(CheckDeviceMultiSampleType)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SurfaceFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType,DWORD* pQualityLevels) PURE;
    STDMETHOD(CheckDepthStencilMatch)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat) PURE;
    STDMETHOD(CheckDeviceFormatConversion)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SourceFormat,D3DFORMAT TargetFormat) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS9* pCaps) PURE;
    STDMETHOD_(HMONITOR, GetAdapterMonitor)(THIS_ UINT Adapter) PURE;
    STDMETHOD(CreateDevice)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,HWND hFocusWindow,DWORD BehaviorFlags,D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DDevice9** ppReturnedDeviceInterface) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Version;
    #endif
};
    
typedef struct IDirect3D9 *LPDIRECT3D9, *PDIRECT3D9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D9_RegisterSoftwareDevice(p,a) (p)->lpVtbl->RegisterSoftwareDevice(p,a)
#define IDirect3D9_GetAdapterCount(p) (p)->lpVtbl->GetAdapterCount(p)
#define IDirect3D9_GetAdapterIdentifier(p,a,b,c) (p)->lpVtbl->GetAdapterIdentifier(p,a,b,c)
#define IDirect3D9_GetAdapterModeCount(p,a,b) (p)->lpVtbl->GetAdapterModeCount(p,a,b)
#define IDirect3D9_EnumAdapterModes(p,a,b,c,d) (p)->lpVtbl->EnumAdapterModes(p,a,b,c,d)
#define IDirect3D9_GetAdapterDisplayMode(p,a,b) (p)->lpVtbl->GetAdapterDisplayMode(p,a,b)
#define IDirect3D9_CheckDeviceType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceType(p,a,b,c,d,e)
#define IDirect3D9_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->lpVtbl->CheckDeviceFormat(p,a,b,c,d,e,f)
#define IDirect3D9_CheckDeviceMultiSampleType(p,a,b,c,d,e,f) (p)->lpVtbl->CheckDeviceMultiSampleType(p,a,b,c,d,e,f)
#define IDirect3D9_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->lpVtbl->CheckDepthStencilMatch(p,a,b,c,d,e)
#define IDirect3D9_CheckDeviceFormatConversion(p,a,b,c,d) (p)->lpVtbl->CheckDeviceFormatConversion(p,a,b,c,d)
#define IDirect3D9_GetDeviceCaps(p,a,b,c) (p)->lpVtbl->GetDeviceCaps(p,a,b,c)
#define IDirect3D9_GetAdapterMonitor(p,a) (p)->lpVtbl->GetAdapterMonitor(p,a)
#define IDirect3D9_CreateDevice(p,a,b,c,d,e,f) (p)->lpVtbl->CreateDevice(p,a,b,c,d,e,f)
#else
#define IDirect3D9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D9_AddRef(p) (p)->AddRef()
#define IDirect3D9_Release(p) (p)->Release()
#define IDirect3D9_RegisterSoftwareDevice(p,a) (p)->RegisterSoftwareDevice(a)
#define IDirect3D9_GetAdapterCount(p) (p)->GetAdapterCount()
#define IDirect3D9_GetAdapterIdentifier(p,a,b,c) (p)->GetAdapterIdentifier(a,b,c)
#define IDirect3D9_GetAdapterModeCount(p,a,b) (p)->GetAdapterModeCount(a,b)
#define IDirect3D9_EnumAdapterModes(p,a,b,c,d) (p)->EnumAdapterModes(a,b,c,d)
#define IDirect3D9_GetAdapterDisplayMode(p,a,b) (p)->GetAdapterDisplayMode(a,b)
#define IDirect3D9_CheckDeviceType(p,a,b,c,d,e) (p)->CheckDeviceType(a,b,c,d,e)
#define IDirect3D9_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->CheckDeviceFormat(a,b,c,d,e,f)
#define IDirect3D9_CheckDeviceMultiSampleType(p,a,b,c,d,e,f) (p)->CheckDeviceMultiSampleType(a,b,c,d,e,f)
#define IDirect3D9_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->CheckDepthStencilMatch(a,b,c,d,e)
#define IDirect3D9_CheckDeviceFormatConversion(p,a,b,c,d) (p)->CheckDeviceFormatConversion(a,b,c,d)
#define IDirect3D9_GetDeviceCaps(p,a,b,c) (p)->GetDeviceCaps(a,b,c)
#define IDirect3D9_GetAdapterMonitor(p,a) (p)->GetAdapterMonitor(a)
#define IDirect3D9_CreateDevice(p,a,b,c,d,e,f) (p)->CreateDevice(a,b,c,d,e,f)
#endif







/* SwapChain */















#undef INTERFACE
#define INTERFACE IDirect3DDevice9

DECLARE_INTERFACE_(IDirect3DDevice9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice9 methods ***/
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD_(UINT, GetAvailableTextureMem)(THIS) PURE;
    STDMETHOD(EvictManagedResources)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ IDirect3D9** ppD3D9) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ D3DCAPS9* pCaps) PURE;
    STDMETHOD(GetDisplayMode)(THIS_ UINT iSwapChain,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetCreationParameters)(THIS_ D3DDEVICE_CREATION_PARAMETERS *pParameters) PURE;
    STDMETHOD(SetCursorProperties)(THIS_ UINT XHotSpot,UINT YHotSpot,IDirect3DSurface9* pCursorBitmap) PURE;
    STDMETHOD_(void, SetCursorPosition)(THIS_ int X,int Y,DWORD Flags) PURE;
    STDMETHOD_(BOOL, ShowCursor)(THIS_ BOOL bShow) PURE;
    STDMETHOD(CreateAdditionalSwapChain)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DSwapChain9** pSwapChain) PURE;
    STDMETHOD(GetSwapChain)(THIS_ UINT iSwapChain,IDirect3DSwapChain9** pSwapChain) PURE;
    STDMETHOD_(UINT, GetNumberOfSwapChains)(THIS) PURE;
    STDMETHOD(Reset)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT iSwapChain,UINT iBackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface9** ppBackBuffer) PURE;
    STDMETHOD(GetRasterStatus)(THIS_ UINT iSwapChain,D3DRASTER_STATUS* pRasterStatus) PURE;
    STDMETHOD(SetDialogBoxMode)(THIS_ BOOL bEnableDialogs) PURE;
    STDMETHOD_(void, SetGammaRamp)(THIS_ UINT iSwapChain,DWORD Flags,CONST D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD_(void, GetGammaRamp)(THIS_ UINT iSwapChain,D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD(CreateTexture)(THIS_ UINT Width,UINT Height,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DTexture9** ppTexture,HANDLE* pSharedHandle) PURE;
    STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width,UINT Height,UINT Depth,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DVolumeTexture9** ppVolumeTexture,HANDLE* pSharedHandle) PURE;
    STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DCubeTexture9** ppCubeTexture,HANDLE* pSharedHandle) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ UINT Length,DWORD Usage,DWORD FVF,D3DPOOL Pool,IDirect3DVertexBuffer9** ppVertexBuffer,HANDLE* pSharedHandle) PURE;
    STDMETHOD(CreateIndexBuffer)(THIS_ UINT Length,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DIndexBuffer9** ppIndexBuffer,HANDLE* pSharedHandle) PURE;
    STDMETHOD(CreateRenderTarget)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,DWORD MultisampleQuality,BOOL Lockable,IDirect3DSurface9** ppSurface,HANDLE* pSharedHandle) PURE;
    STDMETHOD(CreateDepthStencilSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,DWORD MultisampleQuality,BOOL Discard,IDirect3DSurface9** ppSurface,HANDLE* pSharedHandle) PURE;
    STDMETHOD(UpdateSurface)(THIS_ IDirect3DSurface9* pSourceSurface,CONST RECT* pSourceRect,IDirect3DSurface9* pDestinationSurface,CONST POINT* pDestPoint) PURE;
    STDMETHOD(UpdateTexture)(THIS_ IDirect3DBaseTexture9* pSourceTexture,IDirect3DBaseTexture9* pDestinationTexture) PURE;
    STDMETHOD(GetRenderTargetData)(THIS_ IDirect3DSurface9* pRenderTarget,IDirect3DSurface9* pDestSurface) PURE;
    STDMETHOD(GetFrontBufferData)(THIS_ UINT iSwapChain,IDirect3DSurface9* pDestSurface) PURE;
    STDMETHOD(StretchRect)(THIS_ IDirect3DSurface9* pSourceSurface,CONST RECT* pSourceRect,IDirect3DSurface9* pDestSurface,CONST RECT* pDestRect,D3DTEXTUREFILTERTYPE Filter) PURE;
    STDMETHOD(ColorFill)(THIS_ IDirect3DSurface9* pSurface,CONST RECT* pRect,D3DCOLOR color) PURE;
    STDMETHOD(CreateOffscreenPlainSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DPOOL Pool,IDirect3DSurface9** ppSurface,HANDLE* pSharedHandle) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ DWORD RenderTargetIndex,IDirect3DSurface9* pRenderTarget) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ DWORD RenderTargetIndex,IDirect3DSurface9** ppRenderTarget) PURE;
    STDMETHOD(SetDepthStencilSurface)(THIS_ IDirect3DSurface9* pNewZStencil) PURE;
    STDMETHOD(GetDepthStencilSurface)(THIS_ IDirect3DSurface9** ppZStencilSurface) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(Clear)(THIS_ DWORD Count,CONST D3DRECT* pRects,DWORD Flags,D3DCOLOR Color,float Z,DWORD Stencil) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,CONST D3DMATRIX* pMatrix) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,D3DMATRIX* pMatrix) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,CONST D3DMATRIX*) PURE;
    STDMETHOD(SetViewport)(THIS_ CONST D3DVIEWPORT9* pViewport) PURE;
    STDMETHOD(GetViewport)(THIS_ D3DVIEWPORT9* pViewport) PURE;
    STDMETHOD(SetMaterial)(THIS_ CONST D3DMATERIAL9* pMaterial) PURE;
    STDMETHOD(GetMaterial)(THIS_ D3DMATERIAL9* pMaterial) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD Index,CONST D3DLIGHT9*) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD Index,D3DLIGHT9*) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD Index,BOOL Enable) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD Index,BOOL* pEnable) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD Index,CONST float* pPlane) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD Index,float* pPlane) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD Value) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD* pValue) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE Type,IDirect3DStateBlock9** ppSB) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ IDirect3DStateBlock9** ppSB) PURE;
    STDMETHOD(SetClipStatus)(THIS_ CONST D3DCLIPSTATUS9* pClipStatus) PURE;
    STDMETHOD(GetClipStatus)(THIS_ D3DCLIPSTATUS9* pClipStatus) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture9** ppTexture) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture9* pTexture) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD* pValue) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD Value) PURE;
    STDMETHOD(GetSamplerState)(THIS_ DWORD Sampler,D3DSAMPLERSTATETYPE Type,DWORD* pValue) PURE;
    STDMETHOD(SetSamplerState)(THIS_ DWORD Sampler,D3DSAMPLERSTATETYPE Type,DWORD Value) PURE;
    STDMETHOD(ValidateDevice)(THIS_ DWORD* pNumPasses) PURE;
    STDMETHOD(SetPaletteEntries)(THIS_ UINT PaletteNumber,CONST PALETTEENTRY* pEntries) PURE;
    STDMETHOD(GetPaletteEntries)(THIS_ UINT PaletteNumber,PALETTEENTRY* pEntries) PURE;
    STDMETHOD(SetCurrentTexturePalette)(THIS_ UINT PaletteNumber) PURE;
    STDMETHOD(GetCurrentTexturePalette)(THIS_ UINT *PaletteNumber) PURE;
    STDMETHOD(SetScissorRect)(THIS_ CONST RECT* pRect) PURE;
    STDMETHOD(GetScissorRect)(THIS_ RECT* pRect) PURE;
    STDMETHOD(SetSoftwareVertexProcessing)(THIS_ BOOL bSoftware) PURE;
    STDMETHOD_(BOOL, GetSoftwareVertexProcessing)(THIS) PURE;
    STDMETHOD(SetNPatchMode)(THIS_ float nSegments) PURE;
    STDMETHOD_(float, GetNPatchMode)(THIS) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT StartVertex,UINT PrimitiveCount) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,INT BaseVertexIndex,UINT MinVertexIndex,UINT NumVertices,UINT startIndex,UINT primCount) PURE;
    STDMETHOD(DrawPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT PrimitiveCount,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(DrawIndexedPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT MinVertexIndex,UINT NumVertices,UINT PrimitiveCount,CONST void* pIndexData,D3DFORMAT IndexDataFormat,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(ProcessVertices)(THIS_ UINT SrcStartIndex,UINT DestIndex,UINT VertexCount,IDirect3DVertexBuffer9* pDestBuffer,IDirect3DVertexDeclaration9* pVertexDecl,DWORD Flags) PURE;
    STDMETHOD(CreateVertexDeclaration)(THIS_ CONST D3DVERTEXELEMENT9* pVertexElements,IDirect3DVertexDeclaration9** ppDecl) PURE;
    STDMETHOD(SetVertexDeclaration)(THIS_ IDirect3DVertexDeclaration9* pDecl) PURE;
    STDMETHOD(GetVertexDeclaration)(THIS_ IDirect3DVertexDeclaration9** ppDecl) PURE;
    STDMETHOD(SetFVF)(THIS_ DWORD FVF) PURE;
    STDMETHOD(GetFVF)(THIS_ DWORD* pFVF) PURE;
    STDMETHOD(CreateVertexShader)(THIS_ CONST DWORD* pFunction,IDirect3DVertexShader9** ppShader) PURE;
    STDMETHOD(SetVertexShader)(THIS_ IDirect3DVertexShader9* pShader) PURE;
    STDMETHOD(GetVertexShader)(THIS_ IDirect3DVertexShader9** ppShader) PURE;
    STDMETHOD(SetVertexShaderConstantF)(THIS_ UINT StartRegister,CONST float* pConstantData,UINT Vector4fCount) PURE;
    STDMETHOD(GetVertexShaderConstantF)(THIS_ UINT StartRegister,float* pConstantData,UINT Vector4fCount) PURE;
    STDMETHOD(SetVertexShaderConstantI)(THIS_ UINT StartRegister,CONST int* pConstantData,UINT Vector4iCount) PURE;
    STDMETHOD(GetVertexShaderConstantI)(THIS_ UINT StartRegister,int* pConstantData,UINT Vector4iCount) PURE;
    STDMETHOD(SetVertexShaderConstantB)(THIS_ UINT StartRegister,CONST BOOL* pConstantData,UINT  BoolCount) PURE;
    STDMETHOD(GetVertexShaderConstantB)(THIS_ UINT StartRegister,BOOL* pConstantData,UINT BoolCount) PURE;
    STDMETHOD(SetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer9* pStreamData,UINT OffsetInBytes,UINT Stride) PURE;
    STDMETHOD(GetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer9** ppStreamData,UINT* pOffsetInBytes,UINT* pStride) PURE;
    STDMETHOD(SetStreamSourceFreq)(THIS_ UINT StreamNumber,UINT Setting) PURE;
    STDMETHOD(GetStreamSourceFreq)(THIS_ UINT StreamNumber,UINT* pSetting) PURE;
    STDMETHOD(SetIndices)(THIS_ IDirect3DIndexBuffer9* pIndexData) PURE;
    STDMETHOD(GetIndices)(THIS_ IDirect3DIndexBuffer9** ppIndexData) PURE;
    STDMETHOD(CreatePixelShader)(THIS_ CONST DWORD* pFunction,IDirect3DPixelShader9** ppShader) PURE;
    STDMETHOD(SetPixelShader)(THIS_ IDirect3DPixelShader9* pShader) PURE;
    STDMETHOD(GetPixelShader)(THIS_ IDirect3DPixelShader9** ppShader) PURE;
    STDMETHOD(SetPixelShaderConstantF)(THIS_ UINT StartRegister,CONST float* pConstantData,UINT Vector4fCount) PURE;
    STDMETHOD(GetPixelShaderConstantF)(THIS_ UINT StartRegister,float* pConstantData,UINT Vector4fCount) PURE;
    STDMETHOD(SetPixelShaderConstantI)(THIS_ UINT StartRegister,CONST int* pConstantData,UINT Vector4iCount) PURE;
    STDMETHOD(GetPixelShaderConstantI)(THIS_ UINT StartRegister,int* pConstantData,UINT Vector4iCount) PURE;
    STDMETHOD(SetPixelShaderConstantB)(THIS_ UINT StartRegister,CONST BOOL* pConstantData,UINT  BoolCount) PURE;
    STDMETHOD(GetPixelShaderConstantB)(THIS_ UINT StartRegister,BOOL* pConstantData,UINT BoolCount) PURE;
    STDMETHOD(DrawRectPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DRECTPATCH_INFO* pRectPatchInfo) PURE;
    STDMETHOD(DrawTriPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DTRIPATCH_INFO* pTriPatchInfo) PURE;
    STDMETHOD(DeletePatch)(THIS_ UINT Handle) PURE;
    STDMETHOD(CreateQuery)(THIS_ D3DQUERYTYPE Type,IDirect3DQuery9** ppQuery) PURE;
    
    #ifdef D3D_DEBUG_INFO
    D3DDEVICE_CREATION_PARAMETERS CreationParameters;
    D3DPRESENT_PARAMETERS PresentParameters;
    D3DDISPLAYMODE DisplayMode;
    D3DCAPS9 Caps;
    
    UINT AvailableTextureMem;
    UINT SwapChains;
    UINT Textures;
    UINT VertexBuffers;
    UINT IndexBuffers;
    UINT VertexShaders;
    UINT PixelShaders;
    
    D3DVIEWPORT9 Viewport;
    D3DMATRIX ProjectionMatrix;
    D3DMATRIX ViewMatrix;
    D3DMATRIX WorldMatrix;
    D3DMATRIX TextureMatrices[8];
    
    DWORD FVF;
    UINT VertexSize;
    DWORD VertexShaderVersion;
    DWORD PixelShaderVersion;
    BOOL SoftwareVertexProcessing;
    
    D3DMATERIAL9 Material;
    D3DLIGHT9 Lights[16];
    BOOL LightsEnabled[16];
    
    D3DGAMMARAMP GammaRamp;
    RECT ScissorRect;
    BOOL DialogBoxMode;
    #endif
};
    
typedef struct IDirect3DDevice9 *LPDIRECT3DDEVICE9, *PDIRECT3DDEVICE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice9_TestCooperativeLevel(p) (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirect3DDevice9_GetAvailableTextureMem(p) (p)->lpVtbl->GetAvailableTextureMem(p)
#define IDirect3DDevice9_EvictManagedResources(p) (p)->lpVtbl->EvictManagedResources(p)
#define IDirect3DDevice9_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice9_GetDeviceCaps(p,a) (p)->lpVtbl->GetDeviceCaps(p,a)
#define IDirect3DDevice9_GetDisplayMode(p,a,b) (p)->lpVtbl->GetDisplayMode(p,a,b)
#define IDirect3DDevice9_GetCreationParameters(p,a) (p)->lpVtbl->GetCreationParameters(p,a)
#define IDirect3DDevice9_SetCursorProperties(p,a,b,c) (p)->lpVtbl->SetCursorProperties(p,a,b,c)
#define IDirect3DDevice9_SetCursorPosition(p,a,b,c) (p)->lpVtbl->SetCursorPosition(p,a,b,c)
#define IDirect3DDevice9_ShowCursor(p,a) (p)->lpVtbl->ShowCursor(p,a)
#define IDirect3DDevice9_CreateAdditionalSwapChain(p,a,b) (p)->lpVtbl->CreateAdditionalSwapChain(p,a,b)
#define IDirect3DDevice9_GetSwapChain(p,a,b) (p)->lpVtbl->GetSwapChain(p,a,b)
#define IDirect3DDevice9_GetNumberOfSwapChains(p) (p)->lpVtbl->GetNumberOfSwapChains(p)
#define IDirect3DDevice9_Reset(p,a) (p)->lpVtbl->Reset(p,a)
#define IDirect3DDevice9_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DDevice9_GetBackBuffer(p,a,b,c,d) (p)->lpVtbl->GetBackBuffer(p,a,b,c,d)
#define IDirect3DDevice9_GetRasterStatus(p,a,b) (p)->lpVtbl->GetRasterStatus(p,a,b)
#define IDirect3DDevice9_SetDialogBoxMode(p,a) (p)->lpVtbl->SetDialogBoxMode(p,a)
#define IDirect3DDevice9_SetGammaRamp(p,a,b,c) (p)->lpVtbl->SetGammaRamp(p,a,b,c)
#define IDirect3DDevice9_GetGammaRamp(p,a,b) (p)->lpVtbl->GetGammaRamp(p,a,b)
#define IDirect3DDevice9_CreateTexture(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->CreateTexture(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_CreateVolumeTexture(p,a,b,c,d,e,f,g,h,i) (p)->lpVtbl->CreateVolumeTexture(p,a,b,c,d,e,f,g,h,i)
#define IDirect3DDevice9_CreateCubeTexture(p,a,b,c,d,e,f,g) (p)->lpVtbl->CreateCubeTexture(p,a,b,c,d,e,f,g)
#define IDirect3DDevice9_CreateVertexBuffer(p,a,b,c,d,e,f) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d,e,f)
#define IDirect3DDevice9_CreateIndexBuffer(p,a,b,c,d,e,f) (p)->lpVtbl->CreateIndexBuffer(p,a,b,c,d,e,f)
#define IDirect3DDevice9_CreateRenderTarget(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->CreateRenderTarget(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_CreateDepthStencilSurface(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->CreateDepthStencilSurface(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_UpdateSurface(p,a,b,c,d) (p)->lpVtbl->UpdateSurface(p,a,b,c,d)
#define IDirect3DDevice9_UpdateTexture(p,a,b) (p)->lpVtbl->UpdateTexture(p,a,b)
#define IDirect3DDevice9_GetRenderTargetData(p,a,b) (p)->lpVtbl->GetRenderTargetData(p,a,b)
#define IDirect3DDevice9_GetFrontBufferData(p,a,b) (p)->lpVtbl->GetFrontBufferData(p,a,b)
#define IDirect3DDevice9_StretchRect(p,a,b,c,d,e) (p)->lpVtbl->StretchRect(p,a,b,c,d,e)
#define IDirect3DDevice9_ColorFill(p,a,b,c) (p)->lpVtbl->ColorFill(p,a,b,c)
#define IDirect3DDevice9_CreateOffscreenPlainSurface(p,a,b,c,d,e,f) (p)->lpVtbl->CreateOffscreenPlainSurface(p,a,b,c,d,e,f)
#define IDirect3DDevice9_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice9_GetRenderTarget(p,a,b) (p)->lpVtbl->GetRenderTarget(p,a,b)
#define IDirect3DDevice9_SetDepthStencilSurface(p,a) (p)->lpVtbl->SetDepthStencilSurface(p,a)
#define IDirect3DDevice9_GetDepthStencilSurface(p,a) (p)->lpVtbl->GetDepthStencilSurface(p,a)
#define IDirect3DDevice9_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice9_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice9_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice9_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice9_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice9_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice9_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice9_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice9_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice9_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice9_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice9_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice9_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice9_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice9_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice9_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice9_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice9_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice9_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice9_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice9_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice9_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice9_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice9_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice9_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice9_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice9_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice9_GetSamplerState(p,a,b,c) (p)->lpVtbl->GetSamplerState(p,a,b,c)
#define IDirect3DDevice9_SetSamplerState(p,a,b,c) (p)->lpVtbl->SetSamplerState(p,a,b,c)
#define IDirect3DDevice9_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice9_SetPaletteEntries(p,a,b) (p)->lpVtbl->SetPaletteEntries(p,a,b)
#define IDirect3DDevice9_GetPaletteEntries(p,a,b) (p)->lpVtbl->GetPaletteEntries(p,a,b)
#define IDirect3DDevice9_SetCurrentTexturePalette(p,a) (p)->lpVtbl->SetCurrentTexturePalette(p,a)
#define IDirect3DDevice9_GetCurrentTexturePalette(p,a) (p)->lpVtbl->GetCurrentTexturePalette(p,a)
#define IDirect3DDevice9_SetScissorRect(p,a) (p)->lpVtbl->SetScissorRect(p,a)
#define IDirect3DDevice9_GetScissorRect(p,a) (p)->lpVtbl->GetScissorRect(p,a)
#define IDirect3DDevice9_SetSoftwareVertexProcessing(p,a) (p)->lpVtbl->SetSoftwareVertexProcessing(p,a)
#define IDirect3DDevice9_GetSoftwareVertexProcessing(p) (p)->lpVtbl->GetSoftwareVertexProcessing(p)
#define IDirect3DDevice9_SetNPatchMode(p,a) (p)->lpVtbl->SetNPatchMode(p,a)
#define IDirect3DDevice9_GetNPatchMode(p) (p)->lpVtbl->GetNPatchMode(p)
#define IDirect3DDevice9_DrawPrimitive(p,a,b,c) (p)->lpVtbl->DrawPrimitive(p,a,b,c)
#define IDirect3DDevice9_DrawIndexedPrimitive(p,a,b,c,d,e,f) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f)
#define IDirect3DDevice9_DrawPrimitiveUP(p,a,b,c,d) (p)->lpVtbl->DrawPrimitiveUP(p,a,b,c,d)
#define IDirect3DDevice9_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_ProcessVertices(p,a,b,c,d,e,f) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f)
#define IDirect3DDevice9_CreateVertexDeclaration(p,a,b) (p)->lpVtbl->CreateVertexDeclaration(p,a,b)
#define IDirect3DDevice9_SetVertexDeclaration(p,a) (p)->lpVtbl->SetVertexDeclaration(p,a)
#define IDirect3DDevice9_GetVertexDeclaration(p,a) (p)->lpVtbl->GetVertexDeclaration(p,a)
#define IDirect3DDevice9_SetFVF(p,a) (p)->lpVtbl->SetFVF(p,a)
#define IDirect3DDevice9_GetFVF(p,a) (p)->lpVtbl->GetFVF(p,a)
#define IDirect3DDevice9_CreateVertexShader(p,a,b) (p)->lpVtbl->CreateVertexShader(p,a,b)
#define IDirect3DDevice9_SetVertexShader(p,a) (p)->lpVtbl->SetVertexShader(p,a)
#define IDirect3DDevice9_GetVertexShader(p,a) (p)->lpVtbl->GetVertexShader(p,a)
#define IDirect3DDevice9_SetVertexShaderConstantF(p,a,b,c) (p)->lpVtbl->SetVertexShaderConstantF(p,a,b,c)
#define IDirect3DDevice9_GetVertexShaderConstantF(p,a,b,c) (p)->lpVtbl->GetVertexShaderConstantF(p,a,b,c)
#define IDirect3DDevice9_SetVertexShaderConstantI(p,a,b,c) (p)->lpVtbl->SetVertexShaderConstantI(p,a,b,c)
#define IDirect3DDevice9_GetVertexShaderConstantI(p,a,b,c) (p)->lpVtbl->GetVertexShaderConstantI(p,a,b,c)
#define IDirect3DDevice9_SetVertexShaderConstantB(p,a,b,c) (p)->lpVtbl->SetVertexShaderConstantB(p,a,b,c)
#define IDirect3DDevice9_GetVertexShaderConstantB(p,a,b,c) (p)->lpVtbl->GetVertexShaderConstantB(p,a,b,c)
#define IDirect3DDevice9_SetStreamSource(p,a,b,c,d) (p)->lpVtbl->SetStreamSource(p,a,b,c,d)
#define IDirect3DDevice9_GetStreamSource(p,a,b,c,d) (p)->lpVtbl->GetStreamSource(p,a,b,c,d)
#define IDirect3DDevice9_SetStreamSourceFreq(p,a,b) (p)->lpVtbl->SetStreamSourceFreq(p,a,b)
#define IDirect3DDevice9_GetStreamSourceFreq(p,a,b) (p)->lpVtbl->GetStreamSourceFreq(p,a,b)
#define IDirect3DDevice9_SetIndices(p,a) (p)->lpVtbl->SetIndices(p,a)
#define IDirect3DDevice9_GetIndices(p,a) (p)->lpVtbl->GetIndices(p,a)
#define IDirect3DDevice9_CreatePixelShader(p,a,b) (p)->lpVtbl->CreatePixelShader(p,a,b)
#define IDirect3DDevice9_SetPixelShader(p,a) (p)->lpVtbl->SetPixelShader(p,a)
#define IDirect3DDevice9_GetPixelShader(p,a) (p)->lpVtbl->GetPixelShader(p,a)
#define IDirect3DDevice9_SetPixelShaderConstantF(p,a,b,c) (p)->lpVtbl->SetPixelShaderConstantF(p,a,b,c)
#define IDirect3DDevice9_GetPixelShaderConstantF(p,a,b,c) (p)->lpVtbl->GetPixelShaderConstantF(p,a,b,c)
#define IDirect3DDevice9_SetPixelShaderConstantI(p,a,b,c) (p)->lpVtbl->SetPixelShaderConstantI(p,a,b,c)
#define IDirect3DDevice9_GetPixelShaderConstantI(p,a,b,c) (p)->lpVtbl->GetPixelShaderConstantI(p,a,b,c)
#define IDirect3DDevice9_SetPixelShaderConstantB(p,a,b,c) (p)->lpVtbl->SetPixelShaderConstantB(p,a,b,c)
#define IDirect3DDevice9_GetPixelShaderConstantB(p,a,b,c) (p)->lpVtbl->GetPixelShaderConstantB(p,a,b,c)
#define IDirect3DDevice9_DrawRectPatch(p,a,b,c) (p)->lpVtbl->DrawRectPatch(p,a,b,c)
#define IDirect3DDevice9_DrawTriPatch(p,a,b,c) (p)->lpVtbl->DrawTriPatch(p,a,b,c)
#define IDirect3DDevice9_DeletePatch(p,a) (p)->lpVtbl->DeletePatch(p,a)
#define IDirect3DDevice9_CreateQuery(p,a,b) (p)->lpVtbl->CreateQuery(p,a,b)
#else
#define IDirect3DDevice9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice9_AddRef(p) (p)->AddRef()
#define IDirect3DDevice9_Release(p) (p)->Release()
#define IDirect3DDevice9_TestCooperativeLevel(p) (p)->TestCooperativeLevel()
#define IDirect3DDevice9_GetAvailableTextureMem(p) (p)->GetAvailableTextureMem()
#define IDirect3DDevice9_EvictManagedResources(p) (p)->EvictManagedResources()
#define IDirect3DDevice9_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice9_GetDeviceCaps(p,a) (p)->GetDeviceCaps(a)
#define IDirect3DDevice9_GetDisplayMode(p,a,b) (p)->GetDisplayMode(a,b)
#define IDirect3DDevice9_GetCreationParameters(p,a) (p)->GetCreationParameters(a)
#define IDirect3DDevice9_SetCursorProperties(p,a,b,c) (p)->SetCursorProperties(a,b,c)
#define IDirect3DDevice9_SetCursorPosition(p,a,b,c) (p)->SetCursorPosition(a,b,c)
#define IDirect3DDevice9_ShowCursor(p,a) (p)->ShowCursor(a)
#define IDirect3DDevice9_CreateAdditionalSwapChain(p,a,b) (p)->CreateAdditionalSwapChain(a,b)
#define IDirect3DDevice9_GetSwapChain(p,a,b) (p)->GetSwapChain(a,b)
#define IDirect3DDevice9_GetNumberOfSwapChains(p) (p)->GetNumberOfSwapChains()
#define IDirect3DDevice9_Reset(p,a) (p)->Reset(a)
#define IDirect3DDevice9_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DDevice9_GetBackBuffer(p,a,b,c,d) (p)->GetBackBuffer(a,b,c,d)
#define IDirect3DDevice9_GetRasterStatus(p,a,b) (p)->GetRasterStatus(a,b)
#define IDirect3DDevice9_SetDialogBoxMode(p,a) (p)->SetDialogBoxMode(a)
#define IDirect3DDevice9_SetGammaRamp(p,a,b,c) (p)->SetGammaRamp(a,b,c)
#define IDirect3DDevice9_GetGammaRamp(p,a,b) (p)->GetGammaRamp(a,b)
#define IDirect3DDevice9_CreateTexture(p,a,b,c,d,e,f,g,h) (p)->CreateTexture(a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_CreateVolumeTexture(p,a,b,c,d,e,f,g,h,i) (p)->CreateVolumeTexture(a,b,c,d,e,f,g,h,i)
#define IDirect3DDevice9_CreateCubeTexture(p,a,b,c,d,e,f,g) (p)->CreateCubeTexture(a,b,c,d,e,f,g)
#define IDirect3DDevice9_CreateVertexBuffer(p,a,b,c,d,e,f) (p)->CreateVertexBuffer(a,b,c,d,e,f)
#define IDirect3DDevice9_CreateIndexBuffer(p,a,b,c,d,e,f) (p)->CreateIndexBuffer(a,b,c,d,e,f)
#define IDirect3DDevice9_CreateRenderTarget(p,a,b,c,d,e,f,g,h) (p)->CreateRenderTarget(a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_CreateDepthStencilSurface(p,a,b,c,d,e,f,g,h) (p)->CreateDepthStencilSurface(a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_UpdateSurface(p,a,b,c,d) (p)->UpdateSurface(a,b,c,d)
#define IDirect3DDevice9_UpdateTexture(p,a,b) (p)->UpdateTexture(a,b)
#define IDirect3DDevice9_GetRenderTargetData(p,a,b) (p)->GetRenderTargetData(a,b)
#define IDirect3DDevice9_GetFrontBufferData(p,a,b) (p)->GetFrontBufferData(a,b)
#define IDirect3DDevice9_StretchRect(p,a,b,c,d,e) (p)->StretchRect(a,b,c,d,e)
#define IDirect3DDevice9_ColorFill(p,a,b,c) (p)->ColorFill(a,b,c)
#define IDirect3DDevice9_CreateOffscreenPlainSurface(p,a,b,c,d,e,f) (p)->CreateOffscreenPlainSurface(a,b,c,d,e,f)
#define IDirect3DDevice9_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice9_GetRenderTarget(p,a,b) (p)->GetRenderTarget(a,b)
#define IDirect3DDevice9_SetDepthStencilSurface(p,a) (p)->SetDepthStencilSurface(a)
#define IDirect3DDevice9_GetDepthStencilSurface(p,a) (p)->GetDepthStencilSurface(a)
#define IDirect3DDevice9_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice9_EndScene(p) (p)->EndScene()
#define IDirect3DDevice9_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice9_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice9_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice9_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice9_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice9_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice9_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice9_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice9_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice9_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice9_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice9_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice9_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice9_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice9_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice9_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice9_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice9_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice9_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice9_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice9_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice9_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice9_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice9_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice9_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice9_GetSamplerState(p,a,b,c) (p)->GetSamplerState(a,b,c)
#define IDirect3DDevice9_SetSamplerState(p,a,b,c) (p)->SetSamplerState(a,b,c)
#define IDirect3DDevice9_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice9_SetPaletteEntries(p,a,b) (p)->SetPaletteEntries(a,b)
#define IDirect3DDevice9_GetPaletteEntries(p,a,b) (p)->GetPaletteEntries(a,b)
#define IDirect3DDevice9_SetCurrentTexturePalette(p,a) (p)->SetCurrentTexturePalette(a)
#define IDirect3DDevice9_GetCurrentTexturePalette(p,a) (p)->GetCurrentTexturePalette(a)
#define IDirect3DDevice9_SetScissorRect(p,a) (p)->SetScissorRect(a)
#define IDirect3DDevice9_GetScissorRect(p,a) (p)->GetScissorRect(a)
#define IDirect3DDevice9_SetSoftwareVertexProcessing(p,a) (p)->SetSoftwareVertexProcessing(a)
#define IDirect3DDevice9_GetSoftwareVertexProcessing(p) (p)->GetSoftwareVertexProcessing()
#define IDirect3DDevice9_SetNPatchMode(p,a) (p)->SetNPatchMode(a)
#define IDirect3DDevice9_GetNPatchMode(p) (p)->GetNPatchMode()
#define IDirect3DDevice9_DrawPrimitive(p,a,b,c) (p)->DrawPrimitive(a,b,c)
#define IDirect3DDevice9_DrawIndexedPrimitive(p,a,b,c,d,e,f) (p)->DrawIndexedPrimitive(a,b,c,d,e,f)
#define IDirect3DDevice9_DrawPrimitiveUP(p,a,b,c,d) (p)->DrawPrimitiveUP(a,b,c,d)
#define IDirect3DDevice9_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->DrawIndexedPrimitiveUP(a,b,c,d,e,f,g,h)
#define IDirect3DDevice9_ProcessVertices(p,a,b,c,d,e,f) (p)->ProcessVertices(a,b,c,d,e,f)
#define IDirect3DDevice9_CreateVertexDeclaration(p,a,b) (p)->CreateVertexDeclaration(a,b)
#define IDirect3DDevice9_SetVertexDeclaration(p,a) (p)->SetVertexDeclaration(a)
#define IDirect3DDevice9_GetVertexDeclaration(p,a) (p)->GetVertexDeclaration(a)
#define IDirect3DDevice9_SetFVF(p,a) (p)->SetFVF(a)
#define IDirect3DDevice9_GetFVF(p,a) (p)->GetFVF(a)
#define IDirect3DDevice9_CreateVertexShader(p,a,b) (p)->CreateVertexShader(a,b)
#define IDirect3DDevice9_SetVertexShader(p,a) (p)->SetVertexShader(a)
#define IDirect3DDevice9_GetVertexShader(p,a) (p)->GetVertexShader(a)
#define IDirect3DDevice9_SetVertexShaderConstantF(p,a,b,c) (p)->SetVertexShaderConstantF(a,b,c)
#define IDirect3DDevice9_GetVertexShaderConstantF(p,a,b,c) (p)->GetVertexShaderConstantF(a,b,c)
#define IDirect3DDevice9_SetVertexShaderConstantI(p,a,b,c) (p)->SetVertexShaderConstantI(a,b,c)
#define IDirect3DDevice9_GetVertexShaderConstantI(p,a,b,c) (p)->GetVertexShaderConstantI(a,b,c)
#define IDirect3DDevice9_SetVertexShaderConstantB(p,a,b,c) (p)->SetVertexShaderConstantB(a,b,c)
#define IDirect3DDevice9_GetVertexShaderConstantB(p,a,b,c) (p)->GetVertexShaderConstantB(a,b,c)
#define IDirect3DDevice9_SetStreamSource(p,a,b,c,d) (p)->SetStreamSource(a,b,c,d)
#define IDirect3DDevice9_GetStreamSource(p,a,b,c,d) (p)->GetStreamSource(a,b,c,d)
#define IDirect3DDevice9_SetStreamSourceFreq(p,a,b) (p)->SetStreamSourceFreq(a,b)
#define IDirect3DDevice9_GetStreamSourceFreq(p,a,b) (p)->GetStreamSourceFreq(a,b)
#define IDirect3DDevice9_SetIndices(p,a) (p)->SetIndices(a)
#define IDirect3DDevice9_GetIndices(p,a) (p)->GetIndices(a)
#define IDirect3DDevice9_CreatePixelShader(p,a,b) (p)->CreatePixelShader(a,b)
#define IDirect3DDevice9_SetPixelShader(p,a) (p)->SetPixelShader(a)
#define IDirect3DDevice9_GetPixelShader(p,a) (p)->GetPixelShader(a)
#define IDirect3DDevice9_SetPixelShaderConstantF(p,a,b,c) (p)->SetPixelShaderConstantF(a,b,c)
#define IDirect3DDevice9_GetPixelShaderConstantF(p,a,b,c) (p)->GetPixelShaderConstantF(a,b,c)
#define IDirect3DDevice9_SetPixelShaderConstantI(p,a,b,c) (p)->SetPixelShaderConstantI(a,b,c)
#define IDirect3DDevice9_GetPixelShaderConstantI(p,a,b,c) (p)->GetPixelShaderConstantI(a,b,c)
#define IDirect3DDevice9_SetPixelShaderConstantB(p,a,b,c) (p)->SetPixelShaderConstantB(a,b,c)
#define IDirect3DDevice9_GetPixelShaderConstantB(p,a,b,c) (p)->GetPixelShaderConstantB(a,b,c)
#define IDirect3DDevice9_DrawRectPatch(p,a,b,c) (p)->DrawRectPatch(a,b,c)
#define IDirect3DDevice9_DrawTriPatch(p,a,b,c) (p)->DrawTriPatch(a,b,c)
#define IDirect3DDevice9_DeletePatch(p,a) (p)->DeletePatch(a)
#define IDirect3DDevice9_CreateQuery(p,a,b) (p)->CreateQuery(a,b)
#endif


#undef INTERFACE
#define INTERFACE IDirect3DStateBlock9

DECLARE_INTERFACE_(IDirect3DStateBlock9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DStateBlock9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(Capture)(THIS) PURE;
    STDMETHOD(Apply)(THIS) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DStateBlock9 *LPDIRECT3DSTATEBLOCK9, *PDIRECT3DSTATEBLOCK9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DStateBlock9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DStateBlock9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DStateBlock9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DStateBlock9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DStateBlock9_Capture(p) (p)->lpVtbl->Capture(p)
#define IDirect3DStateBlock9_Apply(p) (p)->lpVtbl->Apply(p)
#else
#define IDirect3DStateBlock9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DStateBlock9_AddRef(p) (p)->AddRef()
#define IDirect3DStateBlock9_Release(p) (p)->Release()
#define IDirect3DStateBlock9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DStateBlock9_Capture(p) (p)->Capture()
#define IDirect3DStateBlock9_Apply(p) (p)->Apply()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DSwapChain9

DECLARE_INTERFACE_(IDirect3DSwapChain9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSwapChain9 methods ***/
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion,DWORD dwFlags) PURE;
    STDMETHOD(GetFrontBufferData)(THIS_ IDirect3DSurface9* pDestSurface) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT iBackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface9** ppBackBuffer) PURE;
    STDMETHOD(GetRasterStatus)(THIS_ D3DRASTER_STATUS* pRasterStatus) PURE;
    STDMETHOD(GetDisplayMode)(THIS_ D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(GetPresentParameters)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
    
    #ifdef D3D_DEBUG_INFO
    D3DPRESENT_PARAMETERS PresentParameters;
    D3DDISPLAYMODE DisplayMode;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DSwapChain9 *LPDIRECT3DSWAPCHAIN9, *PDIRECT3DSWAPCHAIN9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSwapChain9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSwapChain9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSwapChain9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSwapChain9_Present(p,a,b,c,d,e) (p)->lpVtbl->Present(p,a,b,c,d,e)
#define IDirect3DSwapChain9_GetFrontBufferData(p,a) (p)->lpVtbl->GetFrontBufferData(p,a)
#define IDirect3DSwapChain9_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#define IDirect3DSwapChain9_GetRasterStatus(p,a) (p)->lpVtbl->GetRasterStatus(p,a)
#define IDirect3DSwapChain9_GetDisplayMode(p,a) (p)->lpVtbl->GetDisplayMode(p,a)
#define IDirect3DSwapChain9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DSwapChain9_GetPresentParameters(p,a) (p)->lpVtbl->GetPresentParameters(p,a)
#else
#define IDirect3DSwapChain9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSwapChain9_AddRef(p) (p)->AddRef()
#define IDirect3DSwapChain9_Release(p) (p)->Release()
#define IDirect3DSwapChain9_Present(p,a,b,c,d,e) (p)->Present(a,b,c,d,e)
#define IDirect3DSwapChain9_GetFrontBufferData(p,a) (p)->GetFrontBufferData(a)
#define IDirect3DSwapChain9_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#define IDirect3DSwapChain9_GetRasterStatus(p,a) (p)->GetRasterStatus(a)
#define IDirect3DSwapChain9_GetDisplayMode(p,a) (p)->GetDisplayMode(a)
#define IDirect3DSwapChain9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DSwapChain9_GetPresentParameters(p,a) (p)->GetPresentParameters(a)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DResource9

DECLARE_INTERFACE_(IDirect3DResource9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
};
    
typedef struct IDirect3DResource9 *LPDIRECT3DRESOURCE9, *PDIRECT3DRESOURCE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DResource9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DResource9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DResource9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DResource9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DResource9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DResource9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DResource9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DResource9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DResource9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DResource9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DResource9_GetType(p) (p)->lpVtbl->GetType(p)
#else
#define IDirect3DResource9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DResource9_AddRef(p) (p)->AddRef()
#define IDirect3DResource9_Release(p) (p)->Release()
#define IDirect3DResource9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DResource9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DResource9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DResource9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DResource9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DResource9_GetPriority(p) (p)->GetPriority()
#define IDirect3DResource9_PreLoad(p) (p)->PreLoad()
#define IDirect3DResource9_GetType(p) (p)->GetType()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVertexDeclaration9

DECLARE_INTERFACE_(IDirect3DVertexDeclaration9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexDeclaration9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9* pElement,UINT* pNumElements) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DVertexDeclaration9 *LPDIRECT3DVERTEXDECLARATION9, *PDIRECT3DVERTEXDECLARATION9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexDeclaration9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexDeclaration9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexDeclaration9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexDeclaration9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVertexDeclaration9_GetDeclaration(p,a,b) (p)->lpVtbl->GetDeclaration(p,a,b)
#else
#define IDirect3DVertexDeclaration9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexDeclaration9_AddRef(p) (p)->AddRef()
#define IDirect3DVertexDeclaration9_Release(p) (p)->Release()
#define IDirect3DVertexDeclaration9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVertexDeclaration9_GetDeclaration(p,a,b) (p)->GetDeclaration(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVertexShader9

DECLARE_INTERFACE_(IDirect3DVertexShader9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexShader9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(GetFunction)(THIS_ void*,UINT* pSizeOfData) PURE;
    
    #ifdef D3D_DEBUG_INFO
    DWORD Version;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DVertexShader9 *LPDIRECT3DVERTEXSHADER9, *PDIRECT3DVERTEXSHADER9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexShader9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexShader9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexShader9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexShader9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVertexShader9_GetFunction(p,a,b) (p)->lpVtbl->GetFunction(p,a,b)
#else
#define IDirect3DVertexShader9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexShader9_AddRef(p) (p)->AddRef()
#define IDirect3DVertexShader9_Release(p) (p)->Release()
#define IDirect3DVertexShader9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVertexShader9_GetFunction(p,a,b) (p)->GetFunction(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DPixelShader9

DECLARE_INTERFACE_(IDirect3DPixelShader9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DPixelShader9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(GetFunction)(THIS_ void*,UINT* pSizeOfData) PURE;
    
    #ifdef D3D_DEBUG_INFO
    DWORD Version;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DPixelShader9 *LPDIRECT3DPIXELSHADER9, *PDIRECT3DPIXELSHADER9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DPixelShader9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DPixelShader9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DPixelShader9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DPixelShader9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DPixelShader9_GetFunction(p,a,b) (p)->lpVtbl->GetFunction(p,a,b)
#else
#define IDirect3DPixelShader9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DPixelShader9_AddRef(p) (p)->AddRef()
#define IDirect3DPixelShader9_Release(p) (p)->Release()
#define IDirect3DPixelShader9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DPixelShader9_GetFunction(p,a,b) (p)->GetFunction(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DBaseTexture9

DECLARE_INTERFACE_(IDirect3DBaseTexture9, IDirect3DResource9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType) PURE;
    STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS) PURE;
    STDMETHOD_(void, GenerateMipSubLevels)(THIS) PURE;
};
    
typedef struct IDirect3DBaseTexture9 *LPDIRECT3DBASETEXTURE9, *PDIRECT3DBASETEXTURE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DBaseTexture9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DBaseTexture9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DBaseTexture9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DBaseTexture9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DBaseTexture9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DBaseTexture9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DBaseTexture9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DBaseTexture9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DBaseTexture9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DBaseTexture9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DBaseTexture9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DBaseTexture9_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DBaseTexture9_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DBaseTexture9_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DBaseTexture9_SetAutoGenFilterType(p,a) (p)->lpVtbl->SetAutoGenFilterType(p,a)
#define IDirect3DBaseTexture9_GetAutoGenFilterType(p) (p)->lpVtbl->GetAutoGenFilterType(p)
#define IDirect3DBaseTexture9_GenerateMipSubLevels(p) (p)->lpVtbl->GenerateMipSubLevels(p)
#else
#define IDirect3DBaseTexture9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DBaseTexture9_AddRef(p) (p)->AddRef()
#define IDirect3DBaseTexture9_Release(p) (p)->Release()
#define IDirect3DBaseTexture9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DBaseTexture9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DBaseTexture9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DBaseTexture9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DBaseTexture9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DBaseTexture9_GetPriority(p) (p)->GetPriority()
#define IDirect3DBaseTexture9_PreLoad(p) (p)->PreLoad()
#define IDirect3DBaseTexture9_GetType(p) (p)->GetType()
#define IDirect3DBaseTexture9_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DBaseTexture9_GetLOD(p) (p)->GetLOD()
#define IDirect3DBaseTexture9_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DBaseTexture9_SetAutoGenFilterType(p,a) (p)->SetAutoGenFilterType(a)
#define IDirect3DBaseTexture9_GetAutoGenFilterType(p) (p)->GetAutoGenFilterType()
#define IDirect3DBaseTexture9_GenerateMipSubLevels(p) (p)->GenerateMipSubLevels()
#endif





#undef INTERFACE
#define INTERFACE IDirect3DTexture9

DECLARE_INTERFACE_(IDirect3DTexture9, IDirect3DBaseTexture9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType) PURE;
    STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS) PURE;
    STDMETHOD_(void, GenerateMipSubLevels)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetSurfaceLevel)(THIS_ UINT Level,IDirect3DSurface9** ppSurfaceLevel) PURE;
    STDMETHOD(LockRect)(THIS_ UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ CONST RECT* pDirtyRect) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Width;
    UINT Height;
    UINT Levels;
    DWORD Usage;
    D3DFORMAT Format;
    D3DPOOL Pool;
    DWORD Priority;
    DWORD LOD;
    D3DTEXTUREFILTERTYPE FilterType;
    UINT LockCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DTexture9 *LPDIRECT3DTEXTURE9, *PDIRECT3DTEXTURE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DTexture9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DTexture9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DTexture9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DTexture9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DTexture9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DTexture9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DTexture9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DTexture9_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DTexture9_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DTexture9_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DTexture9_SetAutoGenFilterType(p,a) (p)->lpVtbl->SetAutoGenFilterType(p,a)
#define IDirect3DTexture9_GetAutoGenFilterType(p) (p)->lpVtbl->GetAutoGenFilterType(p)
#define IDirect3DTexture9_GenerateMipSubLevels(p) (p)->lpVtbl->GenerateMipSubLevels(p)
#define IDirect3DTexture9_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DTexture9_GetSurfaceLevel(p,a,b) (p)->lpVtbl->GetSurfaceLevel(p,a,b)
#define IDirect3DTexture9_LockRect(p,a,b,c,d) (p)->lpVtbl->LockRect(p,a,b,c,d)
#define IDirect3DTexture9_UnlockRect(p,a) (p)->lpVtbl->UnlockRect(p,a)
#define IDirect3DTexture9_AddDirtyRect(p,a) (p)->lpVtbl->AddDirtyRect(p,a)
#else
#define IDirect3DTexture9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture9_AddRef(p) (p)->AddRef()
#define IDirect3DTexture9_Release(p) (p)->Release()
#define IDirect3DTexture9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DTexture9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DTexture9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DTexture9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DTexture9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DTexture9_GetPriority(p) (p)->GetPriority()
#define IDirect3DTexture9_PreLoad(p) (p)->PreLoad()
#define IDirect3DTexture9_GetType(p) (p)->GetType()
#define IDirect3DTexture9_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DTexture9_GetLOD(p) (p)->GetLOD()
#define IDirect3DTexture9_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DTexture9_SetAutoGenFilterType(p,a) (p)->SetAutoGenFilterType(a)
#define IDirect3DTexture9_GetAutoGenFilterType(p) (p)->GetAutoGenFilterType()
#define IDirect3DTexture9_GenerateMipSubLevels(p) (p)->GenerateMipSubLevels()
#define IDirect3DTexture9_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DTexture9_GetSurfaceLevel(p,a,b) (p)->GetSurfaceLevel(a,b)
#define IDirect3DTexture9_LockRect(p,a,b,c,d) (p)->LockRect(a,b,c,d)
#define IDirect3DTexture9_UnlockRect(p,a) (p)->UnlockRect(a)
#define IDirect3DTexture9_AddDirtyRect(p,a) (p)->AddDirtyRect(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DVolumeTexture9

DECLARE_INTERFACE_(IDirect3DVolumeTexture9, IDirect3DBaseTexture9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType) PURE;
    STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS) PURE;
    STDMETHOD_(void, GenerateMipSubLevels)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(GetVolumeLevel)(THIS_ UINT Level,IDirect3DVolume9** ppVolumeLevel) PURE;
    STDMETHOD(LockBox)(THIS_ UINT Level,D3DLOCKED_BOX* pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyBox)(THIS_ CONST D3DBOX* pDirtyBox) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT Levels;
    DWORD Usage;
    D3DFORMAT Format;
    D3DPOOL Pool;
    DWORD Priority;
    DWORD LOD;
    D3DTEXTUREFILTERTYPE FilterType;
    UINT LockCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DVolumeTexture9 *LPDIRECT3DVOLUMETEXTURE9, *PDIRECT3DVOLUMETEXTURE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolumeTexture9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolumeTexture9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolumeTexture9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolumeTexture9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolumeTexture9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolumeTexture9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolumeTexture9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolumeTexture9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVolumeTexture9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVolumeTexture9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVolumeTexture9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVolumeTexture9_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DVolumeTexture9_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DVolumeTexture9_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DVolumeTexture9_SetAutoGenFilterType(p,a) (p)->lpVtbl->SetAutoGenFilterType(p,a)
#define IDirect3DVolumeTexture9_GetAutoGenFilterType(p) (p)->lpVtbl->GetAutoGenFilterType(p)
#define IDirect3DVolumeTexture9_GenerateMipSubLevels(p) (p)->lpVtbl->GenerateMipSubLevels(p)
#define IDirect3DVolumeTexture9_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DVolumeTexture9_GetVolumeLevel(p,a,b) (p)->lpVtbl->GetVolumeLevel(p,a,b)
#define IDirect3DVolumeTexture9_LockBox(p,a,b,c,d) (p)->lpVtbl->LockBox(p,a,b,c,d)
#define IDirect3DVolumeTexture9_UnlockBox(p,a) (p)->lpVtbl->UnlockBox(p,a)
#define IDirect3DVolumeTexture9_AddDirtyBox(p,a) (p)->lpVtbl->AddDirtyBox(p,a)
#else
#define IDirect3DVolumeTexture9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolumeTexture9_AddRef(p) (p)->AddRef()
#define IDirect3DVolumeTexture9_Release(p) (p)->Release()
#define IDirect3DVolumeTexture9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolumeTexture9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolumeTexture9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolumeTexture9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolumeTexture9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVolumeTexture9_GetPriority(p) (p)->GetPriority()
#define IDirect3DVolumeTexture9_PreLoad(p) (p)->PreLoad()
#define IDirect3DVolumeTexture9_GetType(p) (p)->GetType()
#define IDirect3DVolumeTexture9_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DVolumeTexture9_GetLOD(p) (p)->GetLOD()
#define IDirect3DVolumeTexture9_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DVolumeTexture9_SetAutoGenFilterType(p,a) (p)->SetAutoGenFilterType(a)
#define IDirect3DVolumeTexture9_GetAutoGenFilterType(p) (p)->GetAutoGenFilterType()
#define IDirect3DVolumeTexture9_GenerateMipSubLevels(p) (p)->GenerateMipSubLevels()
#define IDirect3DVolumeTexture9_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DVolumeTexture9_GetVolumeLevel(p,a,b) (p)->GetVolumeLevel(a,b)
#define IDirect3DVolumeTexture9_LockBox(p,a,b,c,d) (p)->LockBox(a,b,c,d)
#define IDirect3DVolumeTexture9_UnlockBox(p,a) (p)->UnlockBox(a)
#define IDirect3DVolumeTexture9_AddDirtyBox(p,a) (p)->AddDirtyBox(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DCubeTexture9

DECLARE_INTERFACE_(IDirect3DCubeTexture9, IDirect3DBaseTexture9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType) PURE;
    STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS) PURE;
    STDMETHOD_(void, GenerateMipSubLevels)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetCubeMapSurface)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,IDirect3DSurface9** ppCubeMapSurface) PURE;
    STDMETHOD(LockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ D3DCUBEMAP_FACES FaceType,CONST RECT* pDirtyRect) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Width;
    UINT Height;
    UINT Levels;
    DWORD Usage;
    D3DFORMAT Format;
    D3DPOOL Pool;
    DWORD Priority;
    DWORD LOD;
    D3DTEXTUREFILTERTYPE FilterType;
    UINT LockCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DCubeTexture9 *LPDIRECT3DCUBETEXTURE9, *PDIRECT3DCUBETEXTURE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DCubeTexture9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DCubeTexture9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DCubeTexture9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DCubeTexture9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DCubeTexture9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DCubeTexture9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DCubeTexture9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DCubeTexture9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DCubeTexture9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DCubeTexture9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DCubeTexture9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DCubeTexture9_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DCubeTexture9_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DCubeTexture9_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DCubeTexture9_SetAutoGenFilterType(p,a) (p)->lpVtbl->SetAutoGenFilterType(p,a)
#define IDirect3DCubeTexture9_GetAutoGenFilterType(p) (p)->lpVtbl->GetAutoGenFilterType(p)
#define IDirect3DCubeTexture9_GenerateMipSubLevels(p) (p)->lpVtbl->GenerateMipSubLevels(p)
#define IDirect3DCubeTexture9_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DCubeTexture9_GetCubeMapSurface(p,a,b,c) (p)->lpVtbl->GetCubeMapSurface(p,a,b,c)
#define IDirect3DCubeTexture9_LockRect(p,a,b,c,d,e) (p)->lpVtbl->LockRect(p,a,b,c,d,e)
#define IDirect3DCubeTexture9_UnlockRect(p,a,b) (p)->lpVtbl->UnlockRect(p,a,b)
#define IDirect3DCubeTexture9_AddDirtyRect(p,a,b) (p)->lpVtbl->AddDirtyRect(p,a,b)
#else
#define IDirect3DCubeTexture9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DCubeTexture9_AddRef(p) (p)->AddRef()
#define IDirect3DCubeTexture9_Release(p) (p)->Release()
#define IDirect3DCubeTexture9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DCubeTexture9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DCubeTexture9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DCubeTexture9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DCubeTexture9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DCubeTexture9_GetPriority(p) (p)->GetPriority()
#define IDirect3DCubeTexture9_PreLoad(p) (p)->PreLoad()
#define IDirect3DCubeTexture9_GetType(p) (p)->GetType()
#define IDirect3DCubeTexture9_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DCubeTexture9_GetLOD(p) (p)->GetLOD()
#define IDirect3DCubeTexture9_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DCubeTexture9_SetAutoGenFilterType(p,a) (p)->SetAutoGenFilterType(a)
#define IDirect3DCubeTexture9_GetAutoGenFilterType(p) (p)->GetAutoGenFilterType()
#define IDirect3DCubeTexture9_GenerateMipSubLevels(p) (p)->GenerateMipSubLevels()
#define IDirect3DCubeTexture9_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DCubeTexture9_GetCubeMapSurface(p,a,b,c) (p)->GetCubeMapSurface(a,b,c)
#define IDirect3DCubeTexture9_LockRect(p,a,b,c,d,e) (p)->LockRect(a,b,c,d,e)
#define IDirect3DCubeTexture9_UnlockRect(p,a,b) (p)->UnlockRect(a,b)
#define IDirect3DCubeTexture9_AddDirtyRect(p,a,b) (p)->AddDirtyRect(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer9

DECLARE_INTERFACE_(IDirect3DVertexBuffer9, IDirect3DResource9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,void** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVERTEXBUFFER_DESC *pDesc) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Length;
    DWORD Usage;
    DWORD FVF;
    D3DPOOL Pool;
    DWORD Priority;
    UINT LockCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DVertexBuffer9 *LPDIRECT3DVERTEXBUFFER9, *PDIRECT3DVERTEXBUFFER9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVertexBuffer9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVertexBuffer9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVertexBuffer9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVertexBuffer9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVertexBuffer9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVertexBuffer9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVertexBuffer9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVertexBuffer9_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DVertexBuffer9_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer9_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DVertexBuffer9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer9_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer9_Release(p) (p)->Release()
#define IDirect3DVertexBuffer9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVertexBuffer9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVertexBuffer9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVertexBuffer9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVertexBuffer9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVertexBuffer9_GetPriority(p) (p)->GetPriority()
#define IDirect3DVertexBuffer9_PreLoad(p) (p)->PreLoad()
#define IDirect3DVertexBuffer9_GetType(p) (p)->GetType()
#define IDirect3DVertexBuffer9_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DVertexBuffer9_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer9_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DIndexBuffer9

DECLARE_INTERFACE_(IDirect3DIndexBuffer9, IDirect3DResource9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,void** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DINDEXBUFFER_DESC *pDesc) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Length;
    DWORD Usage;
    D3DFORMAT Format;
    D3DPOOL Pool;
    DWORD Priority;
    UINT LockCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DIndexBuffer9 *LPDIRECT3DINDEXBUFFER9, *PDIRECT3DINDEXBUFFER9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DIndexBuffer9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DIndexBuffer9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DIndexBuffer9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DIndexBuffer9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DIndexBuffer9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DIndexBuffer9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DIndexBuffer9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DIndexBuffer9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DIndexBuffer9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DIndexBuffer9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DIndexBuffer9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DIndexBuffer9_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DIndexBuffer9_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DIndexBuffer9_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DIndexBuffer9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DIndexBuffer9_AddRef(p) (p)->AddRef()
#define IDirect3DIndexBuffer9_Release(p) (p)->Release()
#define IDirect3DIndexBuffer9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DIndexBuffer9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DIndexBuffer9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DIndexBuffer9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DIndexBuffer9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DIndexBuffer9_GetPriority(p) (p)->GetPriority()
#define IDirect3DIndexBuffer9_PreLoad(p) (p)->PreLoad()
#define IDirect3DIndexBuffer9_GetType(p) (p)->GetType()
#define IDirect3DIndexBuffer9_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DIndexBuffer9_Unlock(p) (p)->Unlock()
#define IDirect3DIndexBuffer9_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DSurface9

DECLARE_INTERFACE_(IDirect3DSurface9, IDirect3DResource9)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(LockRect)(THIS_ D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS) PURE;
    STDMETHOD(GetDC)(THIS_ HDC *phdc) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC hdc) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Width;
    UINT Height;
    DWORD Usage;
    D3DFORMAT Format;
    D3DPOOL Pool;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD MultiSampleQuality;
    DWORD Priority;
    UINT LockCount;
    UINT DCCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DSurface9 *LPDIRECT3DSURFACE9, *PDIRECT3DSURFACE9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSurface9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSurface9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSurface9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSurface9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DSurface9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DSurface9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DSurface9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DSurface9_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DSurface9_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DSurface9_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DSurface9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DSurface9_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DSurface9_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DSurface9_LockRect(p,a,b,c) (p)->lpVtbl->LockRect(p,a,b,c)
#define IDirect3DSurface9_UnlockRect(p) (p)->lpVtbl->UnlockRect(p)
#define IDirect3DSurface9_GetDC(p,a) (p)->lpVtbl->GetDC(p,a)
#define IDirect3DSurface9_ReleaseDC(p,a) (p)->lpVtbl->ReleaseDC(p,a)
#else
#define IDirect3DSurface9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSurface9_AddRef(p) (p)->AddRef()
#define IDirect3DSurface9_Release(p) (p)->Release()
#define IDirect3DSurface9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DSurface9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DSurface9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DSurface9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DSurface9_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DSurface9_GetPriority(p) (p)->GetPriority()
#define IDirect3DSurface9_PreLoad(p) (p)->PreLoad()
#define IDirect3DSurface9_GetType(p) (p)->GetType()
#define IDirect3DSurface9_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DSurface9_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DSurface9_LockRect(p,a,b,c) (p)->LockRect(a,b,c)
#define IDirect3DSurface9_UnlockRect(p) (p)->UnlockRect()
#define IDirect3DSurface9_GetDC(p,a) (p)->GetDC(a)
#define IDirect3DSurface9_ReleaseDC(p,a) (p)->ReleaseDC(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DVolume9

DECLARE_INTERFACE_(IDirect3DVolume9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVolume9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(LockBox)(THIS_ D3DLOCKED_BOX * pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS) PURE;
    
    #ifdef D3D_DEBUG_INFO
    LPCWSTR Name;
    UINT Width;
    UINT Height;
    UINT Depth;
    DWORD Usage;
    D3DFORMAT Format;
    D3DPOOL Pool;
    UINT LockCount;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DVolume9 *LPDIRECT3DVOLUME9, *PDIRECT3DVOLUME9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolume9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolume9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolume9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolume9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolume9_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolume9_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolume9_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolume9_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DVolume9_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DVolume9_LockBox(p,a,b,c) (p)->lpVtbl->LockBox(p,a,b,c)
#define IDirect3DVolume9_UnlockBox(p) (p)->lpVtbl->UnlockBox(p)
#else
#define IDirect3DVolume9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolume9_AddRef(p) (p)->AddRef()
#define IDirect3DVolume9_Release(p) (p)->Release()
#define IDirect3DVolume9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolume9_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolume9_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolume9_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolume9_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DVolume9_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DVolume9_LockBox(p,a,b,c) (p)->LockBox(a,b,c)
#define IDirect3DVolume9_UnlockBox(p) (p)->UnlockBox()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DQuery9

DECLARE_INTERFACE_(IDirect3DQuery9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DQuery9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice) PURE;
    STDMETHOD_(D3DQUERYTYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, GetDataSize)(THIS) PURE;
    STDMETHOD(Issue)(THIS_ DWORD dwIssueFlags) PURE;
    STDMETHOD(GetData)(THIS_ void* pData,DWORD dwSize,DWORD dwGetDataFlags) PURE;
    
    #ifdef D3D_DEBUG_INFO
    D3DQUERYTYPE Type;
    DWORD DataSize;
    LPCWSTR CreationCallStack;
    #endif
};
    
typedef struct IDirect3DQuery9 *LPDIRECT3DQUERY9, *PDIRECT3DQUERY9;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DQuery9_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DQuery9_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DQuery9_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DQuery9_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DQuery9_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DQuery9_GetDataSize(p) (p)->lpVtbl->GetDataSize(p)
#define IDirect3DQuery9_Issue(p,a) (p)->lpVtbl->Issue(p,a)
#define IDirect3DQuery9_GetData(p,a,b,c) (p)->lpVtbl->GetData(p,a,b,c)
#else
#define IDirect3DQuery9_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DQuery9_AddRef(p) (p)->AddRef()
#define IDirect3DQuery9_Release(p) (p)->Release()
#define IDirect3DQuery9_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DQuery9_GetType(p) (p)->GetType()
#define IDirect3DQuery9_GetDataSize(p) (p)->GetDataSize()
#define IDirect3DQuery9_Issue(p,a) (p)->Issue(a)
#define IDirect3DQuery9_GetData(p,a,b,c) (p)->GetData(a,b,c)
#endif


/****************************************************************************
 * Flags for SetPrivateData method on all D3D9 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D9 object is freed.
 ****************************************************************************/
#define D3DSPD_IUNKNOWN                         0x00000001L

/****************************************************************************
 *
 * Flags for IDirect3D9::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_FPU_PRESERVE                  0x00000002L
#define D3DCREATE_MULTITHREADED                 0x00000004L

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L

#define D3DCREATE_DISABLE_DRIVER_MANAGEMENT     0x00000100L
#define D3DCREATE_ADAPTERGROUP_DEVICE           0x00000200L
#define D3DCREATE_DISABLE_DRIVER_MANAGEMENT_EX  0x00000400L

// This flag causes the D3D runtime not to alter the focus 
// window in any way. Use with caution- the burden of supporting
// focus management events (alt-tab, etc.) falls on the 
// application, and appropriate responses (switching display
// mode, etc.) should be coded.
#define D3DCREATE_NOWINDOWCHANGES				0x00000800L


/****************************************************************************
 *
 * Parameter for IDirect3D9::CreateDevice's Adapter argument
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for IDirect3D9::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_WHQL_LEVEL                      0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX9
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             3L

/****************************************************************************
 *
 * Flags for IDirect3DDevice9::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L

/****************************************************************************
 *
 * Flags for IDirect3DDevice9::SetCursorPosition
 *
 ****************************************************************************/

#define D3DCURSOR_IMMEDIATE_UPDATE             0x00000001L

/****************************************************************************
 *
 * Flags for IDirect3DSwapChain9::Present
 *
 ****************************************************************************/

#define D3DPRESENT_DONOTWAIT                   0x00000001L
#define D3DPRESENT_LINEAR_CONTENT              0x00000002L

/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/


/*
 *  DirectDraw error codes
 */
#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )
#define MAKE_D3DSTATUS( code )  MAKE_HRESULT( 0, _FACD3D, code )

/*
 * Direct3D Errors
 */
#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)
#define D3DERR_DRIVERINVALIDCALL                MAKE_D3DHRESULT(2157)
#define D3DERR_WASSTILLDRAWING                  MAKE_D3DHRESULT(540)
#define D3DOK_NOAUTOGEN                         MAKE_D3DSTATUS(2159)


#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION >= 0x0900) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d9caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d9caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _d3d9CAPS_H
#define _d3d9CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0900
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX9 interfaces
#if(DIRECT3D_VERSION >= 0x0900)

#if defined(_X86_) || defined(_IA64)
#pragma pack(4)
#endif

typedef struct _D3DVSHADERCAPS2_0
{
        DWORD Caps;
        INT DynamicFlowControlDepth;
        INT NumTemps;
        INT StaticFlowControlDepth;
} D3DVSHADERCAPS2_0;

#define D3DVS20CAPS_PREDICATION             (1<<0)

#define D3DVS20_MAX_DYNAMICFLOWCONTROLDEPTH  24
#define D3DVS20_MIN_DYNAMICFLOWCONTROLDEPTH  0
#define D3DVS20_MAX_NUMTEMPS    32
#define D3DVS20_MIN_NUMTEMPS    12
#define D3DVS20_MAX_STATICFLOWCONTROLDEPTH    4
#define D3DVS20_MIN_STATICFLOWCONTROLDEPTH    1

typedef struct _D3DPSHADERCAPS2_0
{
    DWORD Caps;
    INT DynamicFlowControlDepth;
    INT NumTemps;
    INT StaticFlowControlDepth;
    INT NumInstructionSlots;
} D3DPSHADERCAPS2_0;

#define D3DPS20CAPS_ARBITRARYSWIZZLE        (1<<0)
#define D3DPS20CAPS_GRADIENTINSTRUCTIONS    (1<<1)
#define D3DPS20CAPS_PREDICATION             (1<<2)
#define D3DPS20CAPS_NODEPENDENTREADLIMIT    (1<<3)
#define D3DPS20CAPS_NOTEXINSTRUCTIONLIMIT   (1<<4)

#define D3DPS20_MAX_DYNAMICFLOWCONTROLDEPTH    24
#define D3DPS20_MIN_DYNAMICFLOWCONTROLDEPTH    0
#define D3DPS20_MAX_NUMTEMPS    32
#define D3DPS20_MIN_NUMTEMPS    12
#define D3DPS20_MAX_STATICFLOWCONTROLDEPTH    4
#define D3DPS20_MIN_STATICFLOWCONTROLDEPTH    0
#define D3DPS20_MAX_NUMINSTRUCTIONSLOTS    512
#define D3DPS20_MIN_NUMINSTRUCTIONSLOTS    96

#define D3DMIN30SHADERINSTRUCTIONS 512
#define D3DMAX30SHADERINSTRUCTIONS 32768

typedef struct _D3DCAPS9
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT        AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture9's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture9's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture9's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture9's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture9's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   PixelShader1xMaxValue;      // max value storable in registers of ps.1.x shaders

    // Here are the DX9 specific ones
    DWORD   DevCaps2;

    float   MaxNpatchTessellationLevel;
    DWORD   Reserved5;

    UINT    MasterAdapterOrdinal;       // ordinal of master adaptor for adapter group
    UINT    AdapterOrdinalInGroup;      // ordinal inside the adapter group
    UINT    NumberOfAdaptersInGroup;    // number of adapters in this adapter group (only if master)
    DWORD   DeclTypes;                  // Data types, supported in vertex declarations
    DWORD   NumSimultaneousRTs;         // Will be at least 1
    DWORD   StretchRectFilterCaps;      // Filter caps supported by StretchRect
    D3DVSHADERCAPS2_0 VS20Caps;
    D3DPSHADERCAPS2_0 PS20Caps;
    DWORD   VertexTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DTexture9's for texture, used in vertex shaders
    DWORD   MaxVShaderInstructionsExecuted; // maximum number of vertex shader instructions that can be executed
    DWORD   MaxPShaderInstructionsExecuted; // maximum number of pixel shader instructions that can be executed
    DWORD   MaxVertexShader30InstructionSlots; 
    DWORD   MaxPixelShader30InstructionSlots;
} D3DCAPS9;

//
// BIT DEFINES FOR D3DCAPS9 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L
#define D3DCAPS2_CANMANAGERESOURCE      0x10000000L
#define D3DCAPS2_DYNAMICTEXTURES        0x20000000L
#define D3DCAPS2_CANAUTOGENMIPMAP       0x40000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

// Indicates that the device can respect the ALPHABLENDENABLE render state
// when fullscreen while using the FLIP or DISCARD swap effect.
// COPY and COPYVSYNC swap effects work whether or not this flag is set.
#define D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD   0x00000020L

// Indicates that the device can perform a gamma correction from 
// a windowed back buffer containing linear content to the sRGB desktop.
#define D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION 0x00000080L

#define D3DCAPS3_COPY_TO_VIDMEM         0x00000100L /* Device can acclerate copies from sysmem to local vidmem */
#define D3DCAPS3_COPY_TO_SYSTEMMEM      0x00000200L /* Device can acclerate copies from local vidmem to sysmem */


//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT     0x00000000L
#define D3DPRESENT_INTERVAL_ONE         0x00000001L
#define D3DPRESENT_INTERVAL_TWO         0x00000002L
#define D3DPRESENT_INTERVAL_THREE       0x00000004L
#define D3DPRESENT_INTERVAL_FOUR        0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE   0x80000000L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */
#define D3DPMISCCAPS_NULLREFERENCE      0x00001000L /* Reference Device that doesnt render */
#define D3DPMISCCAPS_INDEPENDENTWRITEMASKS     0x00004000L /* Device supports independent write masks for MET or MRT */
#define D3DPMISCCAPS_PERSTAGECONSTANT   0x00008000L /* Device supports per-stage constants */
#define D3DPMISCCAPS_FOGANDSPECULARALPHA   0x00010000L /* Device supports separate fog and specular alpha (many devices
                                                          use the specular alpha channel to store fog factor) */
#define D3DPMISCCAPS_SEPARATEALPHABLEND         0x00020000L /* Device supports separate blend settings for the alpha channel */
#define D3DPMISCCAPS_MRTINDEPENDENTBITDEPTHS    0x00040000L /* Device supports different bit depths for MRT */
#define D3DPMISCCAPS_MRTPOSTPIXELSHADERBLENDING 0x00080000L /* Device supports post-pixel shader operations for MRT */
#define D3DPMISCCAPS_FOGVERTEXCLAMPED           0x00100000L /* Device clamps fog blend factor per vertex */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L
#define D3DLINECAPS_ANTIALIAS           0x00000020L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER                 0x00000001L
#define D3DPRASTERCAPS_ZTEST                  0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX              0x00000080L
#define D3DPRASTERCAPS_FOGTABLE               0x00000100L
#define D3DPRASTERCAPS_MIPMAPLODBIAS          0x00002000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR         0x00008000L
#define D3DPRASTERCAPS_FOGRANGE               0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY             0x00020000L
#define D3DPRASTERCAPS_WBUFFER                0x00040000L
#define D3DPRASTERCAPS_WFOG                   0x00100000L
#define D3DPRASTERCAPS_ZFOG                   0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE       0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_SCISSORTEST            0x01000000L
#define D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS    0x02000000L
#define D3DPRASTERCAPS_DEPTHBIAS              0x04000000L 
#define D3DPRASTERCAPS_MULTISAMPLE_TOGGLE     0x08000000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L
#define D3DPBLENDCAPS_BLENDFACTOR       0x00002000L /* Supports both D3DBLEND_BLENDFACTOR and D3DBLEND_INVBLENDFACTOR */

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */
#define D3DPTEXTURECAPS_NOPROJECTEDBUMPENV  0x00200000L /* Device does not support projected bump env lookup operation 
                                                           in programmable and fixed function pixel shaders */

//
// TextureFilterCaps, StretchRectFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MINFPYRAMIDALQUAD   0x00000800L
#define D3DPTFILTERCAPS_MINFGAUSSIANQUAD    0x00001000L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD   0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANQUAD    0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L
#define D3DSTENCILCAPS_TWOSIDED         0x00000100L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_TEXGEN_SPHEREMAP    0x00000100L /* device supports D3DTSS_TCI_SPHEREMAP */
#define D3DVTXPCAPS_NO_TEXGEN_NONLOCALVIEWER   0x00000200L /* device does not support TexGen in non-local
                                                            viewer mode */

//
// DevCaps2
//
#define D3DDEVCAPS2_STREAMOFFSET                        0x00000001L /* Device supports offsets in streams. Must be set by DX9 drivers */
#define D3DDEVCAPS2_DMAPNPATCH                          0x00000002L /* Device supports displacement maps for N-Patches*/
#define D3DDEVCAPS2_ADAPTIVETESSRTPATCH                 0x00000004L /* Device supports adaptive tesselation of RT-patches*/
#define D3DDEVCAPS2_ADAPTIVETESSNPATCH                  0x00000008L /* Device supports adaptive tesselation of N-patches*/
#define D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES       0x00000010L /* Device supports StretchRect calls with a texture as the source*/
#define D3DDEVCAPS2_PRESAMPLEDDMAPNPATCH                0x00000020L /* Device supports presampled displacement maps for N-Patches */
#define D3DDEVCAPS2_VERTEXELEMENTSCANSHARESTREAMOFFSET  0x00000040L /* Vertex elements in a vertex declaration can share the same stream offset */

//
// DeclTypes
//
#define D3DDTCAPS_UBYTE4     0x00000001L
#define D3DDTCAPS_UBYTE4N    0x00000002L
#define D3DDTCAPS_SHORT2N    0x00000004L
#define D3DDTCAPS_SHORT4N    0x00000008L
#define D3DDTCAPS_USHORT2N   0x00000010L
#define D3DDTCAPS_USHORT4N   0x00000020L
#define D3DDTCAPS_UDEC3      0x00000040L
#define D3DDTCAPS_DEC3N      0x00000080L
#define D3DDTCAPS_FLOAT16_2  0x00000100L
#define D3DDTCAPS_FLOAT16_4  0x00000200L


#pragma pack()

#endif /* (DIRECT3D_VERSION >= 0x0900) */
#endif /* _d3d9CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d8types.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8types.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8TYPES_H_
#define _D3D8TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#include <float.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201) // anonymous unions warning
#if defined(_X86_) || defined(_IA64_)
#pragma pack(4)
#endif

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))


#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT8 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT8;

/*
 * Values for clip fields.
 */

// Max number of user clipping planes, supported in D3D.
#define D3DMAXUSERCLIPPLANES 32

// These bits could be ORed together to use with D3DRS_CLIPPLANEENABLE
//
#define D3DCLIPPLANE0 (1 << 0)
#define D3DCLIPPLANE1 (1 << 1)
#define D3DCLIPPLANE2 (1 << 2)
#define D3DCLIPPLANE3 (1 << 3)
#define D3DCLIPPLANE4 (1 << 4)
#define D3DCLIPPLANE5 (1 << 5)

// The following bits are used in the ClipUnion and ClipIntersection
// members of the D3DCLIPSTATUS8
//

#define D3DCS_LEFT        0x00000001L
#define D3DCS_RIGHT       0x00000002L
#define D3DCS_TOP         0x00000004L
#define D3DCS_BOTTOM      0x00000008L
#define D3DCS_FRONT       0x00000010L
#define D3DCS_BACK        0x00000020L
#define D3DCS_PLANE0      0x00000040L
#define D3DCS_PLANE1      0x00000080L
#define D3DCS_PLANE2      0x00000100L
#define D3DCS_PLANE3      0x00000200L
#define D3DCS_PLANE4      0x00000400L
#define D3DCS_PLANE5      0x00000800L

#define D3DCS_ALL (D3DCS_LEFT   | \
                   D3DCS_RIGHT  | \
                   D3DCS_TOP    | \
                   D3DCS_BOTTOM | \
                   D3DCS_FRONT  | \
                   D3DCS_BACK   | \
                   D3DCS_PLANE0 | \
                   D3DCS_PLANE1 | \
                   D3DCS_PLANE2 | \
                   D3DCS_PLANE3 | \
                   D3DCS_PLANE4 | \
                   D3DCS_PLANE5)

typedef struct _D3DCLIPSTATUS8 {
    DWORD ClipUnion;
    DWORD ClipIntersection;
} D3DCLIPSTATUS8;

typedef struct _D3DMATERIAL8 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL8;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT8;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 1,
    D3DSHADE_GOURAUD            = 2,
    D3DSHADE_PHONG              = 3,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;

typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 1,
    D3DFILL_WIREFRAME           = 2,
    D3DFILL_SOLID               = 3,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef struct _D3DLINEPATTERN {
    WORD    wRepeatFactor;
    WORD    wLinePattern;
} D3DLINEPATTERN;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 1,
    D3DBLEND_ONE                = 2,
    D3DBLEND_SRCCOLOR           = 3,
    D3DBLEND_INVSRCCOLOR        = 4,
    D3DBLEND_SRCALPHA           = 5,
    D3DBLEND_INVSRCALPHA        = 6,
    D3DBLEND_DESTALPHA          = 7,
    D3DBLEND_INVDESTALPHA       = 8,
    D3DBLEND_DESTCOLOR          = 9,
    D3DBLEND_INVDESTCOLOR       = 10,
    D3DBLEND_SRCALPHASAT        = 11,
    D3DBLEND_BOTHSRCALPHA       = 12,
    D3DBLEND_BOTHINVSRCALPHA    = 13,
    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 1,
    D3DBLENDOP_SUBTRACT         = 2,
    D3DBLENDOP_REVSUBTRACT      = 3,
    D3DBLENDOP_MIN              = 4,
    D3DBLENDOP_MAX              = 5,
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_MIRRORONCE      = 5,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 1,
    D3DCULL_CW                  = 2,
    D3DCULL_CCW                 = 3,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 1,
    D3DCMP_LESS                 = 2,
    D3DCMP_EQUAL                = 3,
    D3DCMP_LESSEQUAL            = 4,
    D3DCMP_GREATER              = 5,
    D3DCMP_NOTEQUAL             = 6,
    D3DCMP_GREATEREQUAL         = 7,
    D3DCMP_ALWAYS               = 8,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 1,
    D3DSTENCILOP_ZERO           = 2,
    D3DSTENCILOP_REPLACE        = 3,
    D3DSTENCILOP_INCRSAT        = 4,
    D3DSTENCILOP_DECRSAT        = 5,
    D3DSTENCILOP_INVERT         = 6,
    D3DSTENCILOP_INCR           = 7,
    D3DSTENCILOP_DECR           = 8,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINESTRIP             = 3,
    D3DPT_TRIANGLELIST          = 4,
    D3DPT_TRIANGLESTRIP         = 5,
    D3DPT_TRIANGLEFAN           = 6,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 2,
    D3DTS_PROJECTION    = 3,
    D3DTS_TEXTURE0      = 16,
    D3DTS_TEXTURE1      = 17,
    D3DTS_TEXTURE2      = 18,
    D3DTS_TEXTURE3      = 19,
    D3DTS_TEXTURE4      = 20,
    D3DTS_TEXTURE5      = 21,
    D3DTS_TEXTURE6      = 22,
    D3DTS_TEXTURE7      = 23,
    D3DTS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + 256)
#define D3DTS_WORLD  D3DTS_WORLDMATRIX(0)
#define D3DTS_WORLD1 D3DTS_WORLDMATRIX(1)
#define D3DTS_WORLD2 D3DTS_WORLDMATRIX(2)
#define D3DTS_WORLD3 D3DTS_WORLDMATRIX(3)

typedef enum _D3DRENDERSTATETYPE {
    D3DRS_ZENABLE                   = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DRS_FILLMODE                  = 8,    /* D3DFILLMODE */
    D3DRS_SHADEMODE                 = 9,    /* D3DSHADEMODE */
    D3DRS_LINEPATTERN               = 10,   /* D3DLINEPATTERN */
    D3DRS_ZWRITEENABLE              = 14,   /* TRUE to enable z writes */
    D3DRS_ALPHATESTENABLE           = 15,   /* TRUE to enable alpha tests */
    D3DRS_LASTPIXEL                 = 16,   /* TRUE for last-pixel on lines */
    D3DRS_SRCBLEND                  = 19,   /* D3DBLEND */
    D3DRS_DESTBLEND                 = 20,   /* D3DBLEND */
    D3DRS_CULLMODE                  = 22,   /* D3DCULL */
    D3DRS_ZFUNC                     = 23,   /* D3DCMPFUNC */
    D3DRS_ALPHAREF                  = 24,   /* D3DFIXED */
    D3DRS_ALPHAFUNC                 = 25,   /* D3DCMPFUNC */
    D3DRS_DITHERENABLE              = 26,   /* TRUE to enable dithering */
    D3DRS_ALPHABLENDENABLE          = 27,   /* TRUE to enable alpha blending */
    D3DRS_FOGENABLE                 = 28,   /* TRUE to enable fog blending */
    D3DRS_SPECULARENABLE            = 29,   /* TRUE to enable specular */
    D3DRS_ZVISIBLE                  = 30,   /* TRUE to enable z checking */
    D3DRS_FOGCOLOR                  = 34,   /* D3DCOLOR */
    D3DRS_FOGTABLEMODE              = 35,   /* D3DFOGMODE */
    D3DRS_FOGSTART                  = 36,   /* Fog start (for both vertex and pixel fog) */
    D3DRS_FOGEND                    = 37,   /* Fog end      */
    D3DRS_FOGDENSITY                = 38,   /* Fog density  */
    D3DRS_EDGEANTIALIAS             = 40,   /* TRUE to enable edge antialiasing */
    D3DRS_ZBIAS                     = 47,   /* LONG Z bias */
    D3DRS_RANGEFOGENABLE            = 48,   /* Enables range-based fog */
    D3DRS_STENCILENABLE             = 52,   /* BOOL enable/disable stenciling */
    D3DRS_STENCILFAIL               = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRS_STENCILZFAIL              = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRS_STENCILPASS               = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRS_STENCILFUNC               = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRS_STENCILREF                = 57,   /* Reference value used in stencil test */
    D3DRS_STENCILMASK               = 58,   /* Mask value used in stencil test */
    D3DRS_STENCILWRITEMASK          = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRS_TEXTUREFACTOR             = 60,   /* D3DCOLOR used for multi-texture blend */
    D3DRS_WRAP0                     = 128,  /* wrap for 1st texture coord. set */
    D3DRS_WRAP1                     = 129,  /* wrap for 2nd texture coord. set */
    D3DRS_WRAP2                     = 130,  /* wrap for 3rd texture coord. set */
    D3DRS_WRAP3                     = 131,  /* wrap for 4th texture coord. set */
    D3DRS_WRAP4                     = 132,  /* wrap for 5th texture coord. set */
    D3DRS_WRAP5                     = 133,  /* wrap for 6th texture coord. set */
    D3DRS_WRAP6                     = 134,  /* wrap for 7th texture coord. set */
    D3DRS_WRAP7                     = 135,  /* wrap for 8th texture coord. set */
    D3DRS_CLIPPING                  = 136,
    D3DRS_LIGHTING                  = 137,
    D3DRS_AMBIENT                   = 139,
    D3DRS_FOGVERTEXMODE             = 140,
    D3DRS_COLORVERTEX               = 141,
    D3DRS_LOCALVIEWER               = 142,
    D3DRS_NORMALIZENORMALS          = 143,
    D3DRS_DIFFUSEMATERIALSOURCE     = 145,
    D3DRS_SPECULARMATERIALSOURCE    = 146,
    D3DRS_AMBIENTMATERIALSOURCE     = 147,
    D3DRS_EMISSIVEMATERIALSOURCE    = 148,
    D3DRS_VERTEXBLEND               = 151,
    D3DRS_CLIPPLANEENABLE           = 152,
    D3DRS_SOFTWAREVERTEXPROCESSING  = 153,
    D3DRS_POINTSIZE                 = 154,   /* float point size */
    D3DRS_POINTSIZE_MIN             = 155,   /* float point size min threshold */
    D3DRS_POINTSPRITEENABLE         = 156,   /* BOOL point texture coord control */
    D3DRS_POINTSCALEENABLE          = 157,   /* BOOL point size scale enable */
    D3DRS_POINTSCALE_A              = 158,   /* float point attenuation A value */
    D3DRS_POINTSCALE_B              = 159,   /* float point attenuation B value */
    D3DRS_POINTSCALE_C              = 160,   /* float point attenuation C value */
    D3DRS_MULTISAMPLEANTIALIAS      = 161,  // BOOL - set to do FSAA with multisample buffer
    D3DRS_MULTISAMPLEMASK           = 162,  // DWORD - per-sample enable/disable
    D3DRS_PATCHEDGESTYLE            = 163,  // Sets whether patch edges will use float style tessellation
    D3DRS_PATCHSEGMENTS             = 164,  // Number of segments per edge when drawing patches
    D3DRS_DEBUGMONITORTOKEN         = 165,  // DEBUG ONLY - token to debug monitor
    D3DRS_POINTSIZE_MAX             = 166,   /* float point size max threshold */
    D3DRS_INDEXEDVERTEXBLENDENABLE  = 167,
    D3DRS_COLORWRITEENABLE          = 168,  // per-channel write enable
    D3DRS_TWEENFACTOR               = 170,   // float tween factor
    D3DRS_BLENDOP                   = 171,   // D3DBLENDOP setting
    D3DRS_POSITIONORDER             = 172,   // NPatch position interpolation order. D3DORDER_LINEAR or D3DORDER_CUBIC (default)
    D3DRS_NORMALORDER               = 173,   // NPatch normal interpolation order. D3DORDER_LINEAR (default) or D3DORDER_QUADRATIC

    D3DRS_FORCE_DWORD               = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 128UL

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000001L
#define D3DWRAP_V   0x00000002L
#define D3DWRAP_W   0x00000004L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000001L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00000002L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00000004L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x00000008L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<0)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<1)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<2)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<3)

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
    D3DTSS_BUMPENVMAT00   =  7, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01   =  8, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10   =  9, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11   = 10, /* float (bump mapping matrix) */
    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_ADDRESSU       = 13, /* D3DTEXTUREADDRESS for U coordinate */
    D3DTSS_ADDRESSV       = 14, /* D3DTEXTUREADDRESS for V coordinate */
    D3DTSS_BORDERCOLOR    = 15, /* D3DCOLOR */
    D3DTSS_MAGFILTER      = 16, /* D3DTEXTUREFILTER filter to use for magnification */
    D3DTSS_MINFILTER      = 17, /* D3DTEXTUREFILTER filter to use for minification */
    D3DTSS_MIPFILTER      = 18, /* D3DTEXTUREFILTER filter to use between mipmaps during minification */
    D3DTSS_MIPMAPLODBIAS  = 19, /* float Mipmap LOD bias */
    D3DTSS_MAXMIPLEVEL    = 20, /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DTSS_MAXANISOTROPY  = 21, /* DWORD maximum anisotropy */
    D3DTSS_BUMPENVLSCALE  = 22, /* float scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* float offset for bump map luminance */
    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
    D3DTSS_ADDRESSW       = 25, /* D3DTEXTUREADDRESS for W coordinate */
    D3DTSS_COLORARG0      = 26, /* D3DTA_* third arg for triadic ops */
    D3DTSS_ALPHAARG0      = 27, /* D3DTA_* third arg for triadic ops */
    D3DTSS_RESULTARG      = 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURESTAGESTATETYPE;

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DTSS.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRS_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 24,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 25, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 26, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select D3DRS_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

//
// Values for D3DTSS_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_FLATCUBIC       = 4,    // cubic
    D3DTEXF_GAUSSIANCUBIC   = 5,    // different cubic kernel
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* Bits for Flags in ProcessVertices call */

#define D3DPV_DONOTCOPYDATA     (1 << 0)

//-------------------------------------------------------------------

// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c
#define D3DFVF_XYZB5            0x00e

#define D3DFVF_NORMAL           0x010
#define D3DFVF_PSIZE            0x020
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400
#define D3DFVF_TEX5             0x500
#define D3DFVF_TEX6             0x600
#define D3DFVF_TEX7             0x700
#define D3DFVF_TEX8             0x800

#define D3DFVF_LASTBETA_UBYTE4  0x1000

#define D3DFVF_RESERVED2        0xE000  // 4 reserved bits

//---------------------------------------------------------------------
// Vertex Shaders
//

/*

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:20] 0x0
      [19:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    Vertex Input Memory from Tessellator Data (single DWORD token)
      [31:29] 0x3
      [28]    indicates whether data is normals or u/v
      [27:24] 0x0
      [23:20] vertex register address (0..15)
      [19:16] type (dimensionality)
      [15:04] 0x0
      [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:07] 0x0
    [06:00] constant memory address (0..95)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set of stream data definition tokens.  This token sequence fully defines that stream, including the set of elements within the stream, the order in which the elements appear, the type of each element, and the vertex register into which to load an element.
Streams are allowed to include data which is not loaded into a vertex register, thus allowing data which is not used for this shader to exist in the vertex stream.  This skipped data is defined only by a count of DWORDs to skip over, since the type information is irrelevant.
The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into registers and the fourth skipped over.  Register 3 is loaded with the first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  The next two DWORDs (7th and 8th) are skipped over and not loaded into any vertex input register.   Register 7 is loaded with the 9th and 10th DWORDS interpreted as FLOAT data.
Placing of tokens other than NOPs between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0x7F << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..15] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [0..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | (_ConstantAddress))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     ((0x02) << D3DVSD_DATATYPESHIFT) | (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     ((0x01) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x00    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x01    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x02    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x03    // 4D float
#define D3DVSDT_D3DCOLOR    0x04    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_UBYTE4      0x05    // 4D unsigned byte
#define D3DVSDT_SHORT2      0x06    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x07    // 4D signed short

// assignments of vertex input registers for fixed function vertex shader
//
#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_BLENDINDICES    2
#define D3DVSDE_NORMAL          3
#define D3DVSDE_PSIZE           4
#define D3DVSDE_DIFFUSE         5
#define D3DVSDE_SPECULAR        6
#define D3DVSDE_TEXCOORD0       7
#define D3DVSDE_TEXCOORD1       8
#define D3DVSDE_TEXCOORD2       9
#define D3DVSDE_TEXCOORD3       10
#define D3DVSDE_TEXCOORD4       11
#define D3DVSDE_TEXCOORD5       12
#define D3DVSDE_TEXCOORD6       13
#define D3DVSDE_TEXCOORD7       14
#define D3DVSDE_POSITION2       15
#define D3DVSDE_NORMAL2         16

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   8


//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,    // PS/VS
    D3DSIO_MOV          ,       // PS/VS
    D3DSIO_ADD          ,       // PS/VS
    D3DSIO_SUB          ,       // PS
    D3DSIO_MAD          ,       // PS/VS
    D3DSIO_MUL          ,       // PS/VS
    D3DSIO_RCP          ,       // VS
    D3DSIO_RSQ          ,       // VS
    D3DSIO_DP3          ,       // PS/VS
    D3DSIO_DP4          ,       // PS/VS
    D3DSIO_MIN          ,       // VS
    D3DSIO_MAX          ,       // VS
    D3DSIO_SLT          ,       // VS
    D3DSIO_SGE          ,       // VS
    D3DSIO_EXP          ,       // VS
    D3DSIO_LOG          ,       // VS
    D3DSIO_LIT          ,       // VS
    D3DSIO_DST          ,       // VS
    D3DSIO_LRP          ,       // PS
    D3DSIO_FRC          ,       // VS
    D3DSIO_M4x4         ,       // VS
    D3DSIO_M4x3         ,       // VS
    D3DSIO_M3x4         ,       // VS
    D3DSIO_M3x3         ,       // VS
    D3DSIO_M3x2         ,       // VS

    D3DSIO_TEXCOORD     = 64,   // PS
    D3DSIO_TEXKILL      ,       // PS
    D3DSIO_TEX          ,       // PS
    D3DSIO_TEXBEM       ,       // PS
    D3DSIO_TEXBEML      ,       // PS
    D3DSIO_TEXREG2AR    ,       // PS
    D3DSIO_TEXREG2GB    ,       // PS
    D3DSIO_TEXM3x2PAD   ,       // PS
    D3DSIO_TEXM3x2TEX   ,       // PS
    D3DSIO_TEXM3x3PAD   ,       // PS
    D3DSIO_TEXM3x3TEX   ,       // PS
    D3DSIO_TEXM3x3DIFF  ,       // PS
    D3DSIO_TEXM3x3SPEC  ,       // PS
    D3DSIO_TEXM3x3VSPEC ,       // PS
    D3DSIO_EXPP         ,       // VS
    D3DSIO_LOGP         ,       // VS
    D3DSIO_CND          ,       // PS
    D3DSIO_DEF          ,       // PS
    D3DSIO_TEXREG2RGB   ,       // PS
    D3DSIO_TEXDP3TEX    ,       // PS
    D3DSIO_TEXM3x2DEPTH ,       // PS
    D3DSIO_TEXDP3       ,       // PS
    D3DSIO_TEXM3x3      ,       // PS
    D3DSIO_TEXDEPTH     ,       // PS
    D3DSIO_CMP          ,       // PS
    D3DSIO_BEM          ,       // PS

    D3DSIO_PHASE        = 0xFFFD,
    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x00001FFF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
{
    D3DSPDM_NONE    = 0<<D3DSP_DSTMOD_SHIFT, // nop
    D3DSPDM_SATURATE= 1<<D3DSP_DSTMOD_SHIFT, // clamp to 0. to 1. range
    D3DSPDM_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSHADER_PARAM_DSTMOD_TYPE;

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_MASK      0x70000000

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP     = 0<<D3DSP_REGTYPE_SHIFT, // Temporary Register File
    D3DSPR_INPUT    = 1<<D3DSP_REGTYPE_SHIFT, // Input Register File
    D3DSPR_CONST    = 2<<D3DSP_REGTYPE_SHIFT, // Constant Register File
    D3DSPR_ADDR     = 3<<D3DSP_REGTYPE_SHIFT, // Address Register (VS)
    D3DSPR_TEXTURE  = 3<<D3DSP_REGTYPE_SHIFT, // Texture Register File (PS)
    D3DSPR_RASTOUT  = 4<<D3DSP_REGTYPE_SHIFT, // Rasterizer Register File
    D3DSPR_ATTROUT  = 5<<D3DSP_REGTYPE_SHIFT, // Attribute Output Register File
    D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, // Texture Coordinate Output Register File
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (1 << D3DVS_ADDRESSMODE_SHIFT)

typedef enum _D3DVS_ADDRESSMODE_TYPE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVS_ADDRESSMODE_TYPE;

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X from:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y from:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z from:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W from:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATERED \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (0 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (0 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (0 << (D3DSP_SWIZZLE_SHIFT + 6)) )

#define D3DSP_REPLICATEGREEN \
    ( (1 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 6)) )

#define D3DSP_REPLICATEBLUE \
    ( (2 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 6)) )

#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_X2      = 7<<D3DSP_SRCMOD_SHIFT, // *2
    D3DSPSM_X2NEG   = 8<<D3DSP_SRCMOD_SHIFT, // *2 and negate
    D3DSPSM_DZ      = 9<<D3DSP_SRCMOD_SHIFT, // divide through by z component 
    D3DSPSM_DW      = 10<<D3DSP_SRCMOD_SHIFT, // divide through by w component
    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF

//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_INTERPOLATE = 2,
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DORDERTYPE
{
   D3DORDER_LINEAR      = 1,
   D3DORDER_QUADRATIC   = 2,
   D3DORDER_CUBIC       = 3,
   D3DORDER_QUINTIC     = 5,
   D3DORDER_FORCE_DWORD = 0x7fffffff,
} D3DORDERTYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE  = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS = 2,     // 3 matrix blending
    D3DVBF_3WEIGHTS = 3,     // 4 matrix blending
    D3DVBF_TWEENING = 255,   // blending using D3DRS_TWEENFACTOR
    D3DVBF_0WEIGHTS = 256,   // one matrix is used with weight 1.0
    D3DVBF_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D8 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* Multi-Sample buffer types */
typedef enum _D3DMULTISAMPLE_TYPE
{
    D3DMULTISAMPLE_NONE            =  0,
    D3DMULTISAMPLE_2_SAMPLES       =  2,
    D3DMULTISAMPLE_3_SAMPLES       =  3,
    D3DMULTISAMPLE_4_SAMPLES       =  4,
    D3DMULTISAMPLE_5_SAMPLES       =  5,
    D3DMULTISAMPLE_6_SAMPLES       =  6,
    D3DMULTISAMPLE_7_SAMPLES       =  7,
    D3DMULTISAMPLE_8_SAMPLES       =  8,
    D3DMULTISAMPLE_9_SAMPLES       =  9,
    D3DMULTISAMPLE_10_SAMPLES      = 10,
    D3DMULTISAMPLE_11_SAMPLES      = 11,
    D3DMULTISAMPLE_12_SAMPLES      = 12,
    D3DMULTISAMPLE_13_SAMPLES      = 13,
    D3DMULTISAMPLE_14_SAMPLES      = 14,
    D3DMULTISAMPLE_15_SAMPLES      = 15,
    D3DMULTISAMPLE_16_SAMPLES      = 16,

    D3DMULTISAMPLE_FORCE_DWORD     = 0x7fffffff
} D3DMULTISAMPLE_TYPE;

/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */


typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              =  0,

    D3DFMT_R8G8B8               = 20,
    D3DFMT_A8R8G8B8             = 21,
    D3DFMT_X8R8G8B8             = 22,
    D3DFMT_R5G6B5               = 23,
    D3DFMT_X1R5G5B5             = 24,
    D3DFMT_A1R5G5B5             = 25,
    D3DFMT_A4R4G4B4             = 26,
    D3DFMT_R3G3B2               = 27,
    D3DFMT_A8                   = 28,
    D3DFMT_A8R3G3B2             = 29,
    D3DFMT_X4R4G4B4             = 30,
    D3DFMT_A2B10G10R10          = 31,
    D3DFMT_G16R16               = 34,

    D3DFMT_A8P8                 = 40,
    D3DFMT_P8                   = 41,

    D3DFMT_L8                   = 50,
    D3DFMT_A8L8                 = 51,
    D3DFMT_A4L4                 = 52,

    D3DFMT_V8U8                 = 60,
    D3DFMT_L6V5U5               = 61,
    D3DFMT_X8L8V8U8             = 62,
    D3DFMT_Q8W8V8U8             = 63,
    D3DFMT_V16U16               = 64,
    D3DFMT_W11V11U10            = 65,
    D3DFMT_A2W10V10U10          = 67,

    D3DFMT_UYVY                 = MAKEFOURCC('U', 'Y', 'V', 'Y'),
    D3DFMT_YUY2                 = MAKEFOURCC('Y', 'U', 'Y', '2'),
    D3DFMT_DXT1                 = MAKEFOURCC('D', 'X', 'T', '1'),
    D3DFMT_DXT2                 = MAKEFOURCC('D', 'X', 'T', '2'),
    D3DFMT_DXT3                 = MAKEFOURCC('D', 'X', 'T', '3'),
    D3DFMT_DXT4                 = MAKEFOURCC('D', 'X', 'T', '4'),
    D3DFMT_DXT5                 = MAKEFOURCC('D', 'X', 'T', '5'),

    D3DFMT_D16_LOCKABLE         = 70,
    D3DFMT_D32                  = 71,
    D3DFMT_D15S1                = 73,
    D3DFMT_D24S8                = 75,
    D3DFMT_D16                  = 80,
    D3DFMT_D24X8                = 77,
    D3DFMT_D24X4S4              = 79,


    D3DFMT_VERTEXDATA           =100,
    D3DFMT_INDEX16              =101,
    D3DFMT_INDEX32              =102,

    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,
    D3DSWAPEFFECT_COPY_VSYNC        = 4,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Pool types */
typedef enum _D3DPOOL {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,
    D3DPOOL_SCRATCH                 = 3,

    D3DPOOL_FORCE_DWORD             = 0x7fffffff
} D3DPOOL;


/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x7fffffff


/* Resize Optional Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;

    D3DMULTISAMPLE_TYPE MultiSampleType;

    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;

    /* Following elements must be zero for Windowed mode */
    UINT                FullScreen_RefreshRateInHz;
    UINT                FullScreen_PresentationInterval;

} D3DPRESENT_PARAMETERS;

// Values for D3DPRESENT_PARAMETERS.Flags

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER  0x00000001


/* Gamma Ramp: Same as DX7 */

typedef struct _D3DGAMMARAMP
{
    WORD                red  [256];
    WORD                green[256];
    WORD                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef enum _D3DBACKBUFFER_TYPE
{
    D3DBACKBUFFER_TYPE_MONO         = 0,
    D3DBACKBUFFER_TYPE_LEFT         = 1,
    D3DBACKBUFFER_TYPE_RIGHT        = 2,

    D3DBACKBUFFER_TYPE_FORCE_DWORD  = 0x7fffffff
} D3DBACKBUFFER_TYPE;


/* Types */
typedef enum _D3DRESOURCETYPE {
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,


    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Usages */
#define D3DUSAGE_RENDERTARGET       (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL       (0x00000002L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY          (0x00000008L)
#define D3DUSAGE_SOFTWAREPROCESSING (0x00000010L)
#define D3DUSAGE_DONOTCLIP          (0x00000020L)
#define D3DUSAGE_POINTS             (0x00000040L)
#define D3DUSAGE_RTPATCHES          (0x00000080L)
#define D3DUSAGE_NPATCHES           (0x00000100L)
#define D3DUSAGE_DYNAMIC            (0x00000200L)









/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_READONLY           0x00000010L
#define D3DLOCK_DISCARD             0x00002000L
#define D3DLOCK_NOOVERWRITE        0x00001000L
#define D3DLOCK_NOSYSLOCK          0x00000800L

#define D3DLOCK_NO_DIRTY_UPDATE     0x00008000L






/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    DWORD               FVF;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for LockRange */
typedef struct _D3DRANGE
{
    UINT                Offset;
    UINT                Size;
} D3DRANGE;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */

#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;            /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER8;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;



/* Debug monitor tokens (DEBUG only)

   Note that if D3DRS_DEBUGMONITORTOKEN is set, the call is treated as
   passing a token to the debug monitor.  For example, if, after passing
   D3DDMT_ENABLE/DISABLE to D3DRS_DEBUGMONITORTOKEN other token values
   are passed in, the enabled/disabled state of the debug
   monitor will still persist.

   The debug monitor defaults to enabled.

   Calling GetRenderState on D3DRS_DEBUGMONITORTOKEN is not of any use.
*/
typedef enum _D3DDEBUGMONITORTOKENS {
    D3DDMT_ENABLE            = 0,    // enable debug monitor
    D3DDMT_DISABLE           = 1,    // disable debug monitor
    D3DDMT_FORCE_DWORD     = 0x7fffffff,
} D3DDEBUGMONITORTOKENS;

// GetInfo IDs

#define D3DDEVINFOID_RESOURCEMANAGER    5           /* Used with D3DDEVINFO_RESOURCEMANAGER */
#define D3DDEVINFOID_VERTEXSTATS        6           /* Used with D3DDEVINFO_D3DVERTEXSTATS */

typedef struct _D3DRESOURCESTATS
{
// Data collected since last Present()
    BOOL    bThrashing;             /* indicates if thrashing */
    DWORD   ApproxBytesDownloaded;  /* Approximate number of bytes downloaded by resource manager */
    DWORD   NumEvicts;              /* number of objects evicted */
    DWORD   NumVidCreates;          /* number of objects created in video memory */
    DWORD   LastPri;                /* priority of last object evicted */
    DWORD   NumUsed;                /* number of objects set to the device */
    DWORD   NumUsedInVidMem;        /* number of objects set to the device, which are already in video memory */
// Persistent data
    DWORD   WorkingSet;             /* number of objects in video memory */
    DWORD   WorkingSetBytes;        /* number of bytes in video memory */
    DWORD   TotalManaged;           /* total number of managed objects */
    DWORD   TotalBytes;             /* total number of bytes of managed objects */
} D3DRESOURCESTATS;

#define D3DRTYPECOUNT (D3DRTYPE_INDEXBUFFER+1)

typedef struct _D3DDEVINFO_RESOURCEMANAGER
{
    D3DRESOURCESTATS    stats[D3DRTYPECOUNT];
} D3DDEVINFO_RESOURCEMANAGER, *LPD3DDEVINFO_RESOURCEMANAGER;

typedef struct _D3DDEVINFO_D3DVERTEXSTATS
{
    DWORD   NumRenderedTriangles;       /* total number of triangles that are not clipped in this frame */
    DWORD   NumExtraClippingTriangles;  /* Number of new triangles generated by clipping */
} D3DDEVINFO_D3DVERTEXSTATS, *LPD3DDEVINFO_D3DVERTEXSTATS;


#pragma pack()
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3dcaps.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved. 
 *
 *  File:       d3dcaps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3DCAPS_H
#define _D3DCAPS_H

/*
 *  Pull in DirectDraw include file automatically:
 */
#include "ddraw.h"

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

#if defined(_X86_) || defined(_IA64_)
#pragma pack(4)
#endif

/* Description of capabilities of transform */

typedef struct _D3DTRANSFORMCAPS {
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

#define D3DTRANSFORMCAPS_CLIP           0x00000001L /* Will clip whilst transforming */

/* Description of capabilities of lighting */

typedef struct _D3DLIGHTINGCAPS {
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

#define D3DLIGHTINGMODEL_RGB            0x00000001L
#define D3DLIGHTINGMODEL_MONO           0x00000002L

#define D3DLIGHTCAPS_POINT              0x00000001L /* Point lights supported */
#define D3DLIGHTCAPS_SPOT               0x00000002L /* Spot lights supported */
#define D3DLIGHTCAPS_DIRECTIONAL        0x00000004L /* Directional lights supported */
#if(DIRECT3D_VERSION < 0x700)
#define D3DLIGHTCAPS_PARALLELPOINT      0x00000008L /* Parallel point lights supported */
#endif
#if(DIRECT3D_VERSION < 0x500)
#define D3DLIGHTCAPS_GLSPOT             0x00000010L /* GL syle spot lights supported */
#endif

/* Description of capabilities for each primitive type */

typedef struct _D3DPrimCaps {
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

/* D3DPRIMCAPS dwMiscCaps */

#define D3DPMISCCAPS_MASKPLANES         0x00000001L
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CONFORMANT         0x00000008L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L

/* D3DPRIMCAPS dwRasterCaps */

#define D3DPRASTERCAPS_DITHER                   0x00000001L
#define D3DPRASTERCAPS_ROP2                     0x00000002L
#define D3DPRASTERCAPS_XOR                      0x00000004L
#define D3DPRASTERCAPS_PAT                      0x00000008L
#define D3DPRASTERCAPS_ZTEST                    0x00000010L
#define D3DPRASTERCAPS_SUBPIXEL                 0x00000020L
#define D3DPRASTERCAPS_SUBPIXELX                0x00000040L
#define D3DPRASTERCAPS_FOGVERTEX                0x00000080L
#define D3DPRASTERCAPS_FOGTABLE                 0x00000100L
#define D3DPRASTERCAPS_STIPPLE                  0x00000200L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   0x00000400L
#define D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT 0x00000800L
#define D3DPRASTERCAPS_ANTIALIASEDGES           0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS            0x00002000L
#define D3DPRASTERCAPS_ZBIAS                    0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR           0x00008000L
#define D3DPRASTERCAPS_FOGRANGE                 0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY               0x00020000L
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DPRASTERCAPS_WBUFFER                      0x00040000L
#define D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT   0x00080000L
#define D3DPRASTERCAPS_WFOG                         0x00100000L
#define D3DPRASTERCAPS_ZFOG                         0x00200000L
#endif /* DIRECT3D_VERSION >= 0x0600 */

/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */

#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

/* D3DPRIMCAPS dwShadeCaps */

#define D3DPSHADECAPS_COLORFLATMONO             0x00000001L
#define D3DPSHADECAPS_COLORFLATRGB              0x00000002L
#define D3DPSHADECAPS_COLORGOURAUDMONO          0x00000004L
#define D3DPSHADECAPS_COLORGOURAUDRGB           0x00000008L
#define D3DPSHADECAPS_COLORPHONGMONO            0x00000010L
#define D3DPSHADECAPS_COLORPHONGRGB             0x00000020L

#define D3DPSHADECAPS_SPECULARFLATMONO          0x00000040L
#define D3DPSHADECAPS_SPECULARFLATRGB           0x00000080L
#define D3DPSHADECAPS_SPECULARGOURAUDMONO       0x00000100L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB        0x00000200L
#define D3DPSHADECAPS_SPECULARPHONGMONO         0x00000400L
#define D3DPSHADECAPS_SPECULARPHONGRGB          0x00000800L

#define D3DPSHADECAPS_ALPHAFLATBLEND            0x00001000L
#define D3DPSHADECAPS_ALPHAFLATSTIPPLED         0x00002000L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND         0x00004000L
#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED      0x00008000L
#define D3DPSHADECAPS_ALPHAPHONGBLEND           0x00010000L
#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED        0x00020000L

#define D3DPSHADECAPS_FOGFLAT                   0x00040000L
#define D3DPSHADECAPS_FOGGOURAUD                0x00080000L
#define D3DPSHADECAPS_FOGPHONG                  0x00100000L

/* D3DPRIMCAPS dwTextureCaps */

/*
 * Perspective-correct texturing is supported
 */
#define D3DPTEXTURECAPS_PERSPECTIVE     0x00000001L

/*
 * Power-of-2 texture dimensions are required
 */
#define D3DPTEXTURECAPS_POW2            0x00000002L

/*
 * Alpha in texture pixels is supported
 */
#define D3DPTEXTURECAPS_ALPHA           0x00000004L

/*
 * Color-keyed textures are supported
 */
#define D3DPTEXTURECAPS_TRANSPARENCY    0x00000008L

/*
 * obsolete, see D3DPTADDRESSCAPS_BORDER
 */
#define D3DPTEXTURECAPS_BORDER          0x00000010L

/*
 * Only square textures are supported
 */
#define D3DPTEXTURECAPS_SQUAREONLY      0x00000020L

#if(DIRECT3D_VERSION >= 0x0600)
/*
 * Texture indices are not scaled by the texture size prior
 * to interpolation.
 */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L

/*
 * Device can draw alpha from texture palettes
 */
#define D3DPTEXTURECAPS_ALPHAPALETTE    0x00000080L

/*
 * Device can use non-POW2 textures if:
 *  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
 *  2) D3DRS_WRAP(N) is zero for this texture's coordinates
 *  3) mip mapping is not enabled (use magnification filter only)
 */
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L

#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)

// 0x00000200L unused

/*
 * Device can divide transformed texture coordinates by the
 * COUNTth texture coordinate (can do D3DTTFF_PROJECTED)
 */
#define D3DPTEXTURECAPS_PROJECTED  0x00000400L

/*
 * Device can do cubemap textures
 */
#define D3DPTEXTURECAPS_CUBEMAP           0x00000800L

#define D3DPTEXTURECAPS_COLORKEYBLEND     0x00001000L
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* D3DPRIMCAPS dwTextureFilterCaps */

#define D3DPTFILTERCAPS_NEAREST         0x00000001L
#define D3DPTFILTERCAPS_LINEAR          0x00000002L
#define D3DPTFILTERCAPS_MIPNEAREST      0x00000004L
#define D3DPTFILTERCAPS_MIPLINEAR       0x00000008L
#define D3DPTFILTERCAPS_LINEARMIPNEAREST 0x00000010L
#define D3DPTFILTERCAPS_LINEARMIPLINEAR 0x00000020L

#if(DIRECT3D_VERSION >= 0x0600)
/* Device3 Min Filter */
#define D3DPTFILTERCAPS_MINFPOINT       0x00000100L
#define D3DPTFILTERCAPS_MINFLINEAR      0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC 0x00000400L

/* Device3 Mip Filter */
#define D3DPTFILTERCAPS_MIPFPOINT       0x00010000L
#define D3DPTFILTERCAPS_MIPFLINEAR      0x00020000L

/* Device3 Mag Filter */
#define D3DPTFILTERCAPS_MAGFPOINT         0x01000000L
#define D3DPTFILTERCAPS_MAGFLINEAR        0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC   0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC    0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC 0x10000000L
#endif /* DIRECT3D_VERSION >= 0x0600 */

/* D3DPRIMCAPS dwTextureBlendCaps */

#define D3DPTBLENDCAPS_DECAL            0x00000001L
#define D3DPTBLENDCAPS_MODULATE         0x00000002L
#define D3DPTBLENDCAPS_DECALALPHA       0x00000004L
#define D3DPTBLENDCAPS_MODULATEALPHA    0x00000008L
#define D3DPTBLENDCAPS_DECALMASK        0x00000010L
#define D3DPTBLENDCAPS_MODULATEMASK     0x00000020L
#define D3DPTBLENDCAPS_COPY             0x00000040L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPTBLENDCAPS_ADD              0x00000080L
#endif /* DIRECT3D_VERSION >= 0x0500 */

/* D3DPRIMCAPS dwTextureAddressCaps */
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

/* D3DDEVICEDESC dwStencilCaps */

#define D3DSTENCILCAPS_KEEP     0x00000001L
#define D3DSTENCILCAPS_ZERO     0x00000002L
#define D3DSTENCILCAPS_REPLACE  0x00000004L
#define D3DSTENCILCAPS_INCRSAT  0x00000008L
#define D3DSTENCILCAPS_DECRSAT  0x00000010L
#define D3DSTENCILCAPS_INVERT   0x00000020L
#define D3DSTENCILCAPS_INCR     0x00000040L
#define D3DSTENCILCAPS_DECR     0x00000080L

/* D3DDEVICEDESC dwTextureOpCaps */

#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L

/* D3DDEVICEDESC dwFVFCaps flags */

#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 */
typedef struct _D3DDeviceDesc {
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
#if(DIRECT3D_VERSION >= 0x0500)
    // *** New fields for DX5 *** //

    // Width and height caps are 0 for legacy HALs.
    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
    // New fields for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    // Guard band that the rasterizer can accommodate
    // Screen-space vertices inside this space but outside the viewport
    // will get clipped properly.
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#endif /* DIRECT3D_VERSION >= 0x0600 */
} D3DDEVICEDESC, *LPD3DDEVICEDESC;

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DDeviceDesc7 {
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */

    DWORD       dwMinTextureWidth, dwMinTextureHeight;
    DWORD       dwMaxTextureWidth, dwMaxTextureHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;
    GUID        deviceGUID;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
} D3DDEVICEDESC7, *LPD3DDEVICEDESC7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DDEVICEDESCSIZE (sizeof(D3DDEVICEDESC))
#define D3DDEVICEDESC7SIZE (sizeof(D3DDEVICEDESC7))

typedef HRESULT (CALLBACK * LPD3DENUMDEVICESCALLBACK)(GUID FAR *lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID);

#if(DIRECT3D_VERSION >= 0x0700)
typedef HRESULT (CALLBACK * LPD3DENUMDEVICESCALLBACK7)(LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC7, LPVOID);
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* D3DDEVICEDESC dwFlags indicating valid fields */

#define D3DDD_COLORMODEL            0x00000001L /* dcmColorModel is valid */
#define D3DDD_DEVCAPS               0x00000002L /* dwDevCaps is valid */
#define D3DDD_TRANSFORMCAPS         0x00000004L /* dtcTransformCaps is valid */
#define D3DDD_LIGHTINGCAPS          0x00000008L /* dlcLightingCaps is valid */
#define D3DDD_BCLIPPING             0x00000010L /* bClipping is valid */
#define D3DDD_LINECAPS              0x00000020L /* dpcLineCaps is valid */
#define D3DDD_TRICAPS               0x00000040L /* dpcTriCaps is valid */
#define D3DDD_DEVICERENDERBITDEPTH  0x00000080L /* dwDeviceRenderBitDepth is valid */
#define D3DDD_DEVICEZBUFFERBITDEPTH 0x00000100L /* dwDeviceZBufferBitDepth is valid */
#define D3DDD_MAXBUFFERSIZE         0x00000200L /* dwMaxBufferSize is valid */
#define D3DDD_MAXVERTEXCOUNT        0x00000400L /* dwMaxVertexCount is valid */

/* D3DDEVICEDESC dwDevCaps flags */

#define D3DDEVCAPS_FLOATTLVERTEX        0x00000001L /* Device accepts floating point */
                                                    /* for post-transform vertex data */
#define D3DDEVCAPS_SORTINCREASINGZ      0x00000002L /* Device needs data sorted for increasing Z */
#define D3DDEVCAPS_SORTDECREASINGZ      0X00000004L /* Device needs data sorted for decreasing Z */
#define D3DDEVCAPS_SORTEXACT            0x00000008L /* Device needs data sorted exactly */

#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DDEVCAPS_DRAWPRIMITIVES2         0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX       0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT     0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL     0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION         0x00080000L /* Device has HW acceleration for rasterization */

/*
 * These are the flags in the D3DDEVICEDESC7.dwVertexProcessingCaps field
 */

/* device can do texgen */
#define D3DVTXPCAPS_TEXGEN              0x00000001L
/* device can do IDirect3DDevice7 colormaterialsource ops */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L
/* device can do vertex fog */
#define D3DVTXPCAPS_VERTEXFOG           0x00000004L
/* device can do directional lights */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L
/* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L
/* device can do local viewer */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L

#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DFDS_COLORMODEL        0x00000001L /* Match color model */
#define D3DFDS_GUID              0x00000002L /* Match guid */
#define D3DFDS_HARDWARE          0x00000004L /* Match hardware/software */
#define D3DFDS_TRIANGLES         0x00000008L /* Match in triCaps */
#define D3DFDS_LINES             0x00000010L /* Match in lineCaps  */
#define D3DFDS_MISCCAPS          0x00000020L /* Match primCaps.dwMiscCaps */
#define D3DFDS_RASTERCAPS        0x00000040L /* Match primCaps.dwRasterCaps */
#define D3DFDS_ZCMPCAPS          0x00000080L /* Match primCaps.dwZCmpCaps */
#define D3DFDS_ALPHACMPCAPS      0x00000100L /* Match primCaps.dwAlphaCmpCaps */
#define D3DFDS_SRCBLENDCAPS      0x00000200L /* Match primCaps.dwSourceBlendCaps */
#define D3DFDS_DSTBLENDCAPS      0x00000400L /* Match primCaps.dwDestBlendCaps */
#define D3DFDS_SHADECAPS         0x00000800L /* Match primCaps.dwShadeCaps */
#define D3DFDS_TEXTURECAPS       0x00001000L /* Match primCaps.dwTextureCaps */
#define D3DFDS_TEXTUREFILTERCAPS 0x00002000L /* Match primCaps.dwTextureFilterCaps */
#define D3DFDS_TEXTUREBLENDCAPS  0x00004000L /* Match primCaps.dwTextureBlendCaps */
#define D3DFDS_TEXTUREADDRESSCAPS  0x00008000L /* Match primCaps.dwTextureBlendCaps */

/*
 * FindDevice arguments
 */
typedef struct _D3DFINDDEVICESEARCH {
    DWORD               dwSize;
    DWORD               dwFlags;
    BOOL                bHardware;
    D3DCOLORMODEL       dcmColorModel;
    GUID                guid;
    DWORD               dwCaps;
    D3DPRIMCAPS         dpcPrimCaps;
} D3DFINDDEVICESEARCH, *LPD3DFINDDEVICESEARCH;

typedef struct _D3DFINDDEVICERESULT {
    DWORD               dwSize;
    GUID                guid;           /* guid which matched */
    D3DDEVICEDESC       ddHwDesc;       /* hardware D3DDEVICEDESC */
    D3DDEVICEDESC       ddSwDesc;       /* software D3DDEVICEDESC */
} D3DFINDDEVICERESULT, *LPD3DFINDDEVICERESULT;

/*
 * Description of execute buffer.
 */
typedef struct _D3DExecuteBufferDesc {
    DWORD               dwSize;         /* size of this structure */
    DWORD               dwFlags;        /* flags indicating which fields are valid */
    DWORD               dwCaps;         /* capabilities of execute buffer */
    DWORD               dwBufferSize;   /* size of execute buffer data */
    LPVOID              lpData;         /* pointer to actual data */
} D3DEXECUTEBUFFERDESC, *LPD3DEXECUTEBUFFERDESC;

/* D3DEXECUTEBUFFER dwFlags indicating valid fields */

#define D3DDEB_BUFSIZE          0x00000001l     /* buffer size valid */
#define D3DDEB_CAPS             0x00000002l     /* caps valid */
#define D3DDEB_LPDATA           0x00000004l     /* lpData valid */

/* D3DEXECUTEBUFFER dwCaps */

#define D3DDEBCAPS_SYSTEMMEMORY 0x00000001l     /* buffer in system memory */
#define D3DDEBCAPS_VIDEOMEMORY  0x00000002l     /* buffer in device memory */
#define D3DDEBCAPS_MEM (D3DDEBCAPS_SYSTEMMEMORY|D3DDEBCAPS_VIDEOMEMORY)

#if(DIRECT3D_VERSION < 0x0800)

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DDEVINFO_TEXTUREMANAGER {
    BOOL    bThrashing;                 /* indicates if thrashing */
    DWORD   dwApproxBytesDownloaded;    /* Approximate number of bytes downloaded by texture manager */
    DWORD   dwNumEvicts;                /* number of textures evicted */
    DWORD   dwNumVidCreates;            /* number of textures created in video memory */
    DWORD   dwNumTexturesUsed;          /* number of textures used */
    DWORD   dwNumUsedTexInVid;          /* number of used textures present in video memory */
    DWORD   dwWorkingSet;               /* number of textures in video memory */
    DWORD   dwWorkingSetBytes;          /* number of bytes in video memory */
    DWORD   dwTotalManaged;             /* total number of managed textures */
    DWORD   dwTotalBytes;               /* total number of bytes of managed textures */
    DWORD   dwLastPri;                  /* priority of last texture evicted */
} D3DDEVINFO_TEXTUREMANAGER, *LPD3DDEVINFO_TEXTUREMANAGER;

typedef struct _D3DDEVINFO_TEXTURING {
    DWORD   dwNumLoads;                 /* counts Load() API calls */
    DWORD   dwApproxBytesLoaded;        /* Approximate number bytes loaded via Load() */
    DWORD   dwNumPreLoads;              /* counts PreLoad() API calls */
    DWORD   dwNumSet;                   /* counts SetTexture() API calls */
    DWORD   dwNumCreates;               /* counts texture creates */
    DWORD   dwNumDestroys;              /* counts texture destroys */
    DWORD   dwNumSetPriorities;         /* counts SetPriority() API calls */
    DWORD   dwNumSetLODs;               /* counts SetLOD() API calls */
    DWORD   dwNumLocks;                 /* counts number of texture locks */
    DWORD   dwNumGetDCs;                /* counts number of GetDCs to textures */
} D3DDEVINFO_TEXTURING, *LPD3DDEVINFO_TEXTURING;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif //(DIRECT3D_VERSION < 0x0800)

#pragma pack()


#endif /* _D3DCAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d8caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8CAPS_H
#define _D3D8CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#if defined(_X86_) || defined(_IA64_)
#pragma pack(4)
#endif

typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component

} D3DCAPS8;

//
// BIT DEFINES FOR D3DCAPS8 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L
#define D3DCAPS2_CANMANAGERESOURCE      0x10000000L
#define D3DCAPS2_DYNAMICTEXTURES        0x20000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

// Indicates that the device can respect the ALPHABLENDENABLE render state
// when fullscreen while using the FLIP or DISCARD swap effect.
// COPY and COPYVSYNC swap effects work whether or not this flag is set.
#define D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD   0x00000020L

//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT     0x00000000L
#define D3DPRESENT_INTERVAL_ONE         0x00000001L
#define D3DPRESENT_INTERVAL_TWO         0x00000002L
#define D3DPRESENT_INTERVAL_THREE       0x00000004L
#define D3DPRESENT_INTERVAL_FOUR        0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE   0x80000000L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */
#define D3DPMISCCAPS_NULLREFERENCE      0x00001000L /* Reference Device that doesnt render */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */

//
// TextureFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */

#pragma pack()

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3d9types.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d9types.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _d3d9TYPES_H_
#define _d3d9TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0900
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX9 interfaces
#if(DIRECT3D_VERSION >= 0x0900)

#include <float.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201) // anonymous unions warning
#if defined(_X86_) || defined(_IA64)
#pragma pack(4)
#endif

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

#define D3DCOLOR_XYUV(y,u,v)   D3DCOLOR_ARGB(0xff,y,u,v)
#define D3DCOLOR_AYUV(a,y,u,v) D3DCOLOR_ARGB(a,y,u,v)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))


#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT9 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT9;

/*
 * Values for clip fields.
 */

// Max number of user clipping planes, supported in D3D.
#define D3DMAXUSERCLIPPLANES 32

// These bits could be ORed together to use with D3DRS_CLIPPLANEENABLE
//
#define D3DCLIPPLANE0 (1 << 0)
#define D3DCLIPPLANE1 (1 << 1)
#define D3DCLIPPLANE2 (1 << 2)
#define D3DCLIPPLANE3 (1 << 3)
#define D3DCLIPPLANE4 (1 << 4)
#define D3DCLIPPLANE5 (1 << 5)

// The following bits are used in the ClipUnion and ClipIntersection
// members of the D3DCLIPSTATUS9
//

#define D3DCS_LEFT        0x00000001L
#define D3DCS_RIGHT       0x00000002L
#define D3DCS_TOP         0x00000004L
#define D3DCS_BOTTOM      0x00000008L
#define D3DCS_FRONT       0x00000010L
#define D3DCS_BACK        0x00000020L
#define D3DCS_PLANE0      0x00000040L
#define D3DCS_PLANE1      0x00000080L
#define D3DCS_PLANE2      0x00000100L
#define D3DCS_PLANE3      0x00000200L
#define D3DCS_PLANE4      0x00000400L
#define D3DCS_PLANE5      0x00000800L

#define D3DCS_ALL (D3DCS_LEFT   | \
                   D3DCS_RIGHT  | \
                   D3DCS_TOP    | \
                   D3DCS_BOTTOM | \
                   D3DCS_FRONT  | \
                   D3DCS_BACK   | \
                   D3DCS_PLANE0 | \
                   D3DCS_PLANE1 | \
                   D3DCS_PLANE2 | \
                   D3DCS_PLANE3 | \
                   D3DCS_PLANE4 | \
                   D3DCS_PLANE5)

typedef struct _D3DCLIPSTATUS9 {
    DWORD ClipUnion;
    DWORD ClipIntersection;
} D3DCLIPSTATUS9;

typedef struct _D3DMATERIAL9 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL9;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT9 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT9;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 1,
    D3DSHADE_GOURAUD            = 2,
    D3DSHADE_PHONG              = 3,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;

typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 1,
    D3DFILL_WIREFRAME           = 2,
    D3DFILL_SOLID               = 3,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 1,
    D3DBLEND_ONE                = 2,
    D3DBLEND_SRCCOLOR           = 3,
    D3DBLEND_INVSRCCOLOR        = 4,
    D3DBLEND_SRCALPHA           = 5,
    D3DBLEND_INVSRCALPHA        = 6,
    D3DBLEND_DESTALPHA          = 7,
    D3DBLEND_INVDESTALPHA       = 8,
    D3DBLEND_DESTCOLOR          = 9,
    D3DBLEND_INVDESTCOLOR       = 10,
    D3DBLEND_SRCALPHASAT        = 11,
    D3DBLEND_BOTHSRCALPHA       = 12,
    D3DBLEND_BOTHINVSRCALPHA    = 13,
    D3DBLEND_BLENDFACTOR        = 14, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
    D3DBLEND_INVBLENDFACTOR     = 15, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 1,
    D3DBLENDOP_SUBTRACT         = 2,
    D3DBLENDOP_REVSUBTRACT      = 3,
    D3DBLENDOP_MIN              = 4,
    D3DBLENDOP_MAX              = 5,
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_MIRRORONCE      = 5,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 1,
    D3DCULL_CW                  = 2,
    D3DCULL_CCW                 = 3,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 1,
    D3DCMP_LESS                 = 2,
    D3DCMP_EQUAL                = 3,
    D3DCMP_LESSEQUAL            = 4,
    D3DCMP_GREATER              = 5,
    D3DCMP_NOTEQUAL             = 6,
    D3DCMP_GREATEREQUAL         = 7,
    D3DCMP_ALWAYS               = 8,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 1,
    D3DSTENCILOP_ZERO           = 2,
    D3DSTENCILOP_REPLACE        = 3,
    D3DSTENCILOP_INCRSAT        = 4,
    D3DSTENCILOP_DECRSAT        = 5,
    D3DSTENCILOP_INVERT         = 6,
    D3DSTENCILOP_INCR           = 7,
    D3DSTENCILOP_DECR           = 8,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINESTRIP             = 3,
    D3DPT_TRIANGLELIST          = 4,
    D3DPT_TRIANGLESTRIP         = 5,
    D3DPT_TRIANGLEFAN           = 6,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 2,
    D3DTS_PROJECTION    = 3,
    D3DTS_TEXTURE0      = 16,
    D3DTS_TEXTURE1      = 17,
    D3DTS_TEXTURE2      = 18,
    D3DTS_TEXTURE3      = 19,
    D3DTS_TEXTURE4      = 20,
    D3DTS_TEXTURE5      = 21,
    D3DTS_TEXTURE6      = 22,
    D3DTS_TEXTURE7      = 23,
    D3DTS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + 256)
#define D3DTS_WORLD  D3DTS_WORLDMATRIX(0)
#define D3DTS_WORLD1 D3DTS_WORLDMATRIX(1)
#define D3DTS_WORLD2 D3DTS_WORLDMATRIX(2)
#define D3DTS_WORLD3 D3DTS_WORLDMATRIX(3)

typedef enum _D3DRENDERSTATETYPE {
    D3DRS_ZENABLE                   = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DRS_FILLMODE                  = 8,    /* D3DFILLMODE */
    D3DRS_SHADEMODE                 = 9,    /* D3DSHADEMODE */
    D3DRS_ZWRITEENABLE              = 14,   /* TRUE to enable z writes */
    D3DRS_ALPHATESTENABLE           = 15,   /* TRUE to enable alpha tests */
    D3DRS_LASTPIXEL                 = 16,   /* TRUE for last-pixel on lines */
    D3DRS_SRCBLEND                  = 19,   /* D3DBLEND */
    D3DRS_DESTBLEND                 = 20,   /* D3DBLEND */
    D3DRS_CULLMODE                  = 22,   /* D3DCULL */
    D3DRS_ZFUNC                     = 23,   /* D3DCMPFUNC */
    D3DRS_ALPHAREF                  = 24,   /* D3DFIXED */
    D3DRS_ALPHAFUNC                 = 25,   /* D3DCMPFUNC */
    D3DRS_DITHERENABLE              = 26,   /* TRUE to enable dithering */
    D3DRS_ALPHABLENDENABLE          = 27,   /* TRUE to enable alpha blending */
    D3DRS_FOGENABLE                 = 28,   /* TRUE to enable fog blending */
    D3DRS_SPECULARENABLE            = 29,   /* TRUE to enable specular */
    D3DRS_FOGCOLOR                  = 34,   /* D3DCOLOR */
    D3DRS_FOGTABLEMODE              = 35,   /* D3DFOGMODE */
    D3DRS_FOGSTART                  = 36,   /* Fog start (for both vertex and pixel fog) */
    D3DRS_FOGEND                    = 37,   /* Fog end      */
    D3DRS_FOGDENSITY                = 38,   /* Fog density  */
    D3DRS_RANGEFOGENABLE            = 48,   /* Enables range-based fog */
    D3DRS_STENCILENABLE             = 52,   /* BOOL enable/disable stenciling */
    D3DRS_STENCILFAIL               = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRS_STENCILZFAIL              = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRS_STENCILPASS               = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRS_STENCILFUNC               = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRS_STENCILREF                = 57,   /* Reference value used in stencil test */
    D3DRS_STENCILMASK               = 58,   /* Mask value used in stencil test */
    D3DRS_STENCILWRITEMASK          = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRS_TEXTUREFACTOR             = 60,   /* D3DCOLOR used for multi-texture blend */
    D3DRS_WRAP0                     = 128,  /* wrap for 1st texture coord. set */
    D3DRS_WRAP1                     = 129,  /* wrap for 2nd texture coord. set */
    D3DRS_WRAP2                     = 130,  /* wrap for 3rd texture coord. set */
    D3DRS_WRAP3                     = 131,  /* wrap for 4th texture coord. set */
    D3DRS_WRAP4                     = 132,  /* wrap for 5th texture coord. set */
    D3DRS_WRAP5                     = 133,  /* wrap for 6th texture coord. set */
    D3DRS_WRAP6                     = 134,  /* wrap for 7th texture coord. set */
    D3DRS_WRAP7                     = 135,  /* wrap for 8th texture coord. set */
    D3DRS_CLIPPING                  = 136,
    D3DRS_LIGHTING                  = 137,
    D3DRS_AMBIENT                   = 139,
    D3DRS_FOGVERTEXMODE             = 140,
    D3DRS_COLORVERTEX               = 141,
    D3DRS_LOCALVIEWER               = 142,
    D3DRS_NORMALIZENORMALS          = 143,
    D3DRS_DIFFUSEMATERIALSOURCE     = 145,
    D3DRS_SPECULARMATERIALSOURCE    = 146,
    D3DRS_AMBIENTMATERIALSOURCE     = 147,
    D3DRS_EMISSIVEMATERIALSOURCE    = 148,
    D3DRS_VERTEXBLEND               = 151,
    D3DRS_CLIPPLANEENABLE           = 152,
    D3DRS_POINTSIZE                 = 154,   /* float point size */
    D3DRS_POINTSIZE_MIN             = 155,   /* float point size min threshold */
    D3DRS_POINTSPRITEENABLE         = 156,   /* BOOL point texture coord control */
    D3DRS_POINTSCALEENABLE          = 157,   /* BOOL point size scale enable */
    D3DRS_POINTSCALE_A              = 158,   /* float point attenuation A value */
    D3DRS_POINTSCALE_B              = 159,   /* float point attenuation B value */
    D3DRS_POINTSCALE_C              = 160,   /* float point attenuation C value */
    D3DRS_MULTISAMPLEANTIALIAS      = 161,  // BOOL - set to do FSAA with multisample buffer
    D3DRS_MULTISAMPLEMASK           = 162,  // DWORD - per-sample enable/disable
    D3DRS_PATCHEDGESTYLE            = 163,  // Sets whether patch edges will use float style tessellation
    D3DRS_DEBUGMONITORTOKEN         = 165,  // DEBUG ONLY - token to debug monitor
    D3DRS_POINTSIZE_MAX             = 166,   /* float point size max threshold */
    D3DRS_INDEXEDVERTEXBLENDENABLE  = 167,
    D3DRS_COLORWRITEENABLE          = 168,  // per-channel write enable
    D3DRS_TWEENFACTOR               = 170,   // float tween factor
    D3DRS_BLENDOP                   = 171,   // D3DBLENDOP setting
    D3DRS_POSITIONDEGREE            = 172,   // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
    D3DRS_NORMALDEGREE              = 173,   // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
    D3DRS_SCISSORTESTENABLE         = 174,
    D3DRS_SLOPESCALEDEPTHBIAS       = 175,
    D3DRS_ANTIALIASEDLINEENABLE     = 176,
    D3DRS_MINTESSELLATIONLEVEL      = 178,
    D3DRS_MAXTESSELLATIONLEVEL      = 179,
    D3DRS_ADAPTIVETESS_X            = 180,
    D3DRS_ADAPTIVETESS_Y            = 181,
    D3DRS_ADAPTIVETESS_Z            = 182,
    D3DRS_ADAPTIVETESS_W            = 183,
    D3DRS_ENABLEADAPTIVETESSELLATION = 184,
    D3DRS_TWOSIDEDSTENCILMODE       = 185,   /* BOOL enable/disable 2 sided stenciling */
    D3DRS_CCW_STENCILFAIL           = 186,   /* D3DSTENCILOP to do if ccw stencil test fails */
    D3DRS_CCW_STENCILZFAIL          = 187,   /* D3DSTENCILOP to do if ccw stencil test passes and Z test fails */
    D3DRS_CCW_STENCILPASS           = 188,   /* D3DSTENCILOP to do if both ccw stencil and Z tests pass */
    D3DRS_CCW_STENCILFUNC           = 189,   /* D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRS_COLORWRITEENABLE1         = 190,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DRS_COLORWRITEENABLE2         = 191,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DRS_COLORWRITEENABLE3         = 192,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DRS_BLENDFACTOR               = 193,   /* D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR */
    D3DRS_SRGBWRITEENABLE           = 194,   /* Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE) */
    D3DRS_DEPTHBIAS                 = 195,
    D3DRS_WRAP8                     = 198,   /* Additional wrap states for vs_3_0+ attributes with D3DDECLUSAGE_TEXCOORD */
    D3DRS_WRAP9                     = 199,
    D3DRS_WRAP10                    = 200,
    D3DRS_WRAP11                    = 201,
    D3DRS_WRAP12                    = 202,
    D3DRS_WRAP13                    = 203,
    D3DRS_WRAP14                    = 204,
    D3DRS_WRAP15                    = 205,
    D3DRS_SEPARATEALPHABLENDENABLE  = 206,  /* TRUE to enable a separate blending function for the alpha channel */
    D3DRS_SRCBLENDALPHA             = 207,  /* SRC blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
    D3DRS_DESTBLENDALPHA            = 208,  /* DST blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
    D3DRS_BLENDOPALPHA              = 209,  /* Blending operation for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */


    D3DRS_FORCE_DWORD               = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Maximum number of simultaneous render targets D3D supports
#define D3D_MAX_SIMULTANEOUS_RENDERTARGETS 4

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 128UL

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000001L
#define D3DWRAP_V   0x00000002L
#define D3DWRAP_W   0x00000004L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000001L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00000002L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00000004L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x00000008L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<0)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<1)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<2)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<3)

/*
 * State enumerants for per-stage processing of fixed function pixel processing
 * Two of these affect fixed function vertex processing as well: TEXTURETRANSFORMFLAGS and TEXCOORDINDEX.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
    D3DTSS_BUMPENVMAT00   =  7, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01   =  8, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10   =  9, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11   = 10, /* float (bump mapping matrix) */
    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_BUMPENVLSCALE  = 22, /* float scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* float offset for bump map luminance */
    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
    D3DTSS_COLORARG0      = 26, /* D3DTA_* third arg for triadic ops */
    D3DTSS_ALPHAARG0      = 27, /* D3DTA_* third arg for triadic ops */
    D3DTSS_RESULTARG      = 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
    D3DTSS_CONSTANT       = 32, /* Per-stage constant D3DTA_CONSTANT */


    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURESTAGESTATETYPE;

/*
 * State enumerants for per-sampler texture processing.
 */
typedef enum _D3DSAMPLERSTATETYPE
{
    D3DSAMP_ADDRESSU       = 1,  /* D3DTEXTUREADDRESS for U coordinate */
    D3DSAMP_ADDRESSV       = 2,  /* D3DTEXTUREADDRESS for V coordinate */
    D3DSAMP_ADDRESSW       = 3,  /* D3DTEXTUREADDRESS for W coordinate */
    D3DSAMP_BORDERCOLOR    = 4,  /* D3DCOLOR */
    D3DSAMP_MAGFILTER      = 5,  /* D3DTEXTUREFILTER filter to use for magnification */
    D3DSAMP_MINFILTER      = 6,  /* D3DTEXTUREFILTER filter to use for minification */
    D3DSAMP_MIPFILTER      = 7,  /* D3DTEXTUREFILTER filter to use between mipmaps during minification */
    D3DSAMP_MIPMAPLODBIAS  = 8,  /* float Mipmap LOD bias */
    D3DSAMP_MAXMIPLEVEL    = 9,  /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DSAMP_MAXANISOTROPY  = 10, /* DWORD maximum anisotropy */
    D3DSAMP_SRGBTEXTURE    = 11, /* Default = 0 (which means Gamma 1.0,
                                   no correction required.) else correct for
                                   Gamma = 2.2 */
    D3DSAMP_ELEMENTINDEX   = 12, /* When multi-element texture is assigned to sampler, this
                                    indicates which element index to use.  Default = 0.  */
    D3DSAMP_DMAPOFFSET     = 13, /* Offset in vertices in the pre-sampled displacement map.
                                    Only valid for D3DDMAPSAMPLER sampler  */
    D3DSAMP_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DSAMPLERSTATETYPE;

/* Special sampler which is used in the tesselator */
#define D3DDMAPSAMPLER 256

// Samplers used in vertex shaders
#define D3DVERTEXTEXTURESAMPLER0 (D3DDMAPSAMPLER+1)
#define D3DVERTEXTEXTURESAMPLER1 (D3DDMAPSAMPLER+2)
#define D3DVERTEXTEXTURESAMPLER2 (D3DDMAPSAMPLER+3)
#define D3DVERTEXTEXTURESAMPLER3 (D3DDMAPSAMPLER+4)

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
#define D3DTSS_TCI_SPHEREMAP                            0x00040000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DTSS.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRS_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 24,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 25, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 26, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select D3DRS_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_CONSTANT          0x00000006  // select texture stage constant
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

//
// Values for D3DSAMP_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_PYRAMIDALQUAD   = 6,    // 4-sample tent
    D3DTEXF_GAUSSIANQUAD    = 7,    // 4-sample gaussian
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* Bits for Flags in ProcessVertices call */

#define D3DPV_DONOTCOPYDATA     (1 << 0)

//-------------------------------------------------------------------

// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x400E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c
#define D3DFVF_XYZB5            0x00e
#define D3DFVF_XYZW             0x4002

#define D3DFVF_NORMAL           0x010
#define D3DFVF_PSIZE            0x020
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400
#define D3DFVF_TEX5             0x500
#define D3DFVF_TEX6             0x600
#define D3DFVF_TEX7             0x700
#define D3DFVF_TEX8             0x800

#define D3DFVF_LASTBETA_UBYTE4   0x1000
#define D3DFVF_LASTBETA_D3DCOLOR 0x8000

#define D3DFVF_RESERVED2         0x6000  // 2 reserved bits

//---------------------------------------------------------------------
// Vertex Shaders
//

// Vertex shader declaration

// Vertex element semantics
//
typedef enum _D3DDECLUSAGE
{
    D3DDECLUSAGE_POSITION = 0,
    D3DDECLUSAGE_BLENDWEIGHT,   // 1
    D3DDECLUSAGE_BLENDINDICES,  // 2
    D3DDECLUSAGE_NORMAL,        // 3
    D3DDECLUSAGE_PSIZE,         // 4
    D3DDECLUSAGE_TEXCOORD,      // 5
    D3DDECLUSAGE_TANGENT,       // 6
    D3DDECLUSAGE_BINORMAL,      // 7
    D3DDECLUSAGE_TESSFACTOR,    // 8
    D3DDECLUSAGE_POSITIONT,     // 9
    D3DDECLUSAGE_COLOR,         // 10
    D3DDECLUSAGE_FOG,           // 11
    D3DDECLUSAGE_DEPTH,         // 12
    D3DDECLUSAGE_SAMPLE,        // 13
} D3DDECLUSAGE;

#define MAXD3DDECLUSAGE         D3DDECLUSAGE_SAMPLE
#define MAXD3DDECLUSAGEINDEX    15
#define MAXD3DDECLLENGTH        64 // does not include "end" marker vertex element

typedef enum _D3DDECLMETHOD
{
    D3DDECLMETHOD_DEFAULT = 0,
    D3DDECLMETHOD_PARTIALU,
    D3DDECLMETHOD_PARTIALV,
    D3DDECLMETHOD_CROSSUV,    // Normal
    D3DDECLMETHOD_UV,
    D3DDECLMETHOD_LOOKUP,               // Lookup a displacement map
    D3DDECLMETHOD_LOOKUPPRESAMPLED,     // Lookup a pre-sampled displacement map
} D3DDECLMETHOD;

#define MAXD3DDECLMETHOD D3DDECLMETHOD_LOOKUPPRESAMPLED

// Declarations for _Type fields
//
typedef enum _D3DDECLTYPE
{
    D3DDECLTYPE_FLOAT1    =  0,  // 1D float expanded to (value, 0., 0., 1.)
    D3DDECLTYPE_FLOAT2    =  1,  // 2D float expanded to (value, value, 0., 1.)
    D3DDECLTYPE_FLOAT3    =  2,  // 3D float expanded to (value, value, value, 1.)
    D3DDECLTYPE_FLOAT4    =  3,  // 4D float
    D3DDECLTYPE_D3DCOLOR  =  4,  // 4D packed unsigned bytes mapped to 0. to 1. range
                                 // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
    D3DDECLTYPE_UBYTE4    =  5,  // 4D unsigned byte
    D3DDECLTYPE_SHORT2    =  6,  // 2D signed short expanded to (value, value, 0., 1.)
    D3DDECLTYPE_SHORT4    =  7,  // 4D signed short

// The following types are valid only with vertex shaders >= 2.0


    D3DDECLTYPE_UBYTE4N   =  8,  // Each of 4 bytes is normalized by dividing to 255.0
    D3DDECLTYPE_SHORT2N   =  9,  // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
    D3DDECLTYPE_SHORT4N   = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
    D3DDECLTYPE_USHORT2N  = 11,  // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
    D3DDECLTYPE_USHORT4N  = 12,  // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
    D3DDECLTYPE_UDEC3     = 13,  // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
    D3DDECLTYPE_DEC3N     = 14,  // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
    D3DDECLTYPE_FLOAT16_2 = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
    D3DDECLTYPE_FLOAT16_4 = 16,  // Four 16-bit floating point values
    D3DDECLTYPE_UNUSED    = 17,  // When the type field in a decl is unused.
} D3DDECLTYPE;

#define MAXD3DDECLTYPE      D3DDECLTYPE_UNUSED

typedef struct _D3DVERTEXELEMENT9
{
    WORD    Stream;     // Stream index
    WORD    Offset;     // Offset in the stream in bytes
    BYTE    Type;       // Data type
    BYTE    Method;     // Processing method
    BYTE    Usage;      // Semantics
    BYTE    UsageIndex; // Semantic index
} D3DVERTEXELEMENT9, *LPD3DVERTEXELEMENT9;

// This is used to initialize the last vertex element in a vertex declaration
// array
//
#define D3DDECL_END() {0xFF,0,D3DDECLTYPE_UNUSED,0,0,0}

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   8

//---------------------------------------------------------------------
// Values for IDirect3DDevice9::SetStreamSourceFreq's Setting parameter
//---------------------------------------------------------------------
#define D3DSTREAMSOURCE_INDEXEDDATA  (1<<30)
#define D3DSTREAMSOURCE_INSTANCEDATA (2<<30)



//---------------------------------------------------------------------
//
// The internal format of Pixel Shader (PS) & Vertex Shader (VS)
// Instruction Tokens is defined in the Direct3D Device Driver Kit
//
//---------------------------------------------------------------------

//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

#define D3DSI_INSTLENGTH_MASK   0x0F000000
#define D3DSI_INSTLENGTH_SHIFT  24

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,
    D3DSIO_MOV          ,
    D3DSIO_ADD          ,
    D3DSIO_SUB          ,
    D3DSIO_MAD          ,
    D3DSIO_MUL          ,
    D3DSIO_RCP          ,
    D3DSIO_RSQ          ,
    D3DSIO_DP3          ,
    D3DSIO_DP4          ,
    D3DSIO_MIN          ,
    D3DSIO_MAX          ,
    D3DSIO_SLT          ,
    D3DSIO_SGE          ,
    D3DSIO_EXP          ,
    D3DSIO_LOG          ,
    D3DSIO_LIT          ,
    D3DSIO_DST          ,
    D3DSIO_LRP          ,
    D3DSIO_FRC          ,
    D3DSIO_M4x4         ,
    D3DSIO_M4x3         ,
    D3DSIO_M3x4         ,
    D3DSIO_M3x3         ,
    D3DSIO_M3x2         ,
    D3DSIO_CALL         ,
    D3DSIO_CALLNZ       ,
    D3DSIO_LOOP         ,
    D3DSIO_RET          ,
    D3DSIO_ENDLOOP      ,
    D3DSIO_LABEL        ,
    D3DSIO_DCL          ,
    D3DSIO_POW          ,
    D3DSIO_CRS          ,
    D3DSIO_SGN          ,
    D3DSIO_ABS          ,
    D3DSIO_NRM          ,
    D3DSIO_SINCOS       ,
    D3DSIO_REP          ,
    D3DSIO_ENDREP       ,
    D3DSIO_IF           ,
    D3DSIO_IFC          ,
    D3DSIO_ELSE         ,
    D3DSIO_ENDIF        ,
    D3DSIO_BREAK        ,
    D3DSIO_BREAKC       ,
    D3DSIO_MOVA         ,
    D3DSIO_DEFB         ,
    D3DSIO_DEFI         ,

    D3DSIO_TEXCOORD     = 64,
    D3DSIO_TEXKILL      ,
    D3DSIO_TEX          ,
    D3DSIO_TEXBEM       ,
    D3DSIO_TEXBEML      ,
    D3DSIO_TEXREG2AR    ,
    D3DSIO_TEXREG2GB    ,
    D3DSIO_TEXM3x2PAD   ,
    D3DSIO_TEXM3x2TEX   ,
    D3DSIO_TEXM3x3PAD   ,
    D3DSIO_TEXM3x3TEX   ,
    D3DSIO_RESERVED0    ,
    D3DSIO_TEXM3x3SPEC  ,
    D3DSIO_TEXM3x3VSPEC ,
    D3DSIO_EXPP         ,
    D3DSIO_LOGP         ,
    D3DSIO_CND          ,
    D3DSIO_DEF          ,
    D3DSIO_TEXREG2RGB   ,
    D3DSIO_TEXDP3TEX    ,
    D3DSIO_TEXM3x2DEPTH ,
    D3DSIO_TEXDP3       ,
    D3DSIO_TEXM3x3      ,
    D3DSIO_TEXDEPTH     ,
    D3DSIO_CMP          ,
    D3DSIO_BEM          ,
    D3DSIO_DP2ADD       ,
    D3DSIO_DSX          ,
    D3DSIO_DSY          ,
    D3DSIO_TEXLDD       ,
    D3DSIO_SETP         ,
    D3DSIO_TEXLDL       ,
    D3DSIO_BREAKP       ,

    D3DSIO_PHASE        = 0xFFFD,
    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//---------------------------------------------------------------------
// Use these constants with D3DSIO_SINCOS macro as SRC2, SRC3
//
#define D3DSINCOSCONST1 -1.5500992e-006f, -2.1701389e-005f,  0.0026041667f, 0.00026041668f
#define D3DSINCOSCONST2 -0.020833334f, -0.12500000f, 1.0f, 0.50000000f

//---------------------------------------------------------------------
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//---------------------------------------------------------------------
// Opcode specific controls

#define D3DSP_OPCODESPECIFICCONTROL_MASK  0x00ff0000
#define D3DSP_OPCODESPECIFICCONTROL_SHIFT 16

// ps_2_0 texld controls
#define D3DSI_TEXLD_PROJECT (0x01 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)
#define D3DSI_TEXLD_BIAS    (0x02 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)

// Comparison for dynamic conditional instruction opcodes (i.e. if, breakc)
typedef enum _D3DSHADER_COMPARISON
{
                         // < = >
    D3DSPC_RESERVED0= 0, // 0 0 0
    D3DSPC_GT       = 1, // 0 0 1
    D3DSPC_EQ       = 2, // 0 1 0
    D3DSPC_GE       = 3, // 0 1 1
    D3DSPC_LT       = 4, // 1 0 0
    D3DSPC_NE       = 5, // 1 0 1
    D3DSPC_LE       = 6, // 1 1 0
    D3DSPC_RESERVED1= 7  // 1 1 1
} D3DSHADER_COMPARISON;

// Comparison is part of instruction opcode token:
#define D3DSHADER_COMPARISON_SHIFT D3DSP_OPCODESPECIFICCONTROL_SHIFT
#define D3DSHADER_COMPARISON_MASK  (0x7<<D3DSHADER_COMPARISON_SHIFT)

//---------------------------------------------------------------------
// Predication flags on instruction token
#define D3DSHADER_INSTRUCTION_PREDICATED    (0x1 << 28)

//---------------------------------------------------------------------
// DCL Info Token Controls

// For dcl info tokens requiring a semantic (usage + index)
#define D3DSP_DCL_USAGE_SHIFT 0
#define D3DSP_DCL_USAGE_MASK  0x0000000f

#define D3DSP_DCL_USAGEINDEX_SHIFT 16
#define D3DSP_DCL_USAGEINDEX_MASK  0x000f0000

// DCL pixel shader sampler info token.
#define D3DSP_TEXTURETYPE_SHIFT 27
#define D3DSP_TEXTURETYPE_MASK  0x78000000

typedef enum _D3DSAMPLER_TEXTURE_TYPE
{
    D3DSTT_UNKNOWN = 0<<D3DSP_TEXTURETYPE_SHIFT, // uninitialized value
    D3DSTT_2D      = 2<<D3DSP_TEXTURETYPE_SHIFT, // dcl_2d s# (for declaring a 2-D texture)
    D3DSTT_CUBE    = 3<<D3DSP_TEXTURETYPE_SHIFT, // dcl_cube s# (for declaring a cube texture)
    D3DSTT_VOLUME  = 4<<D3DSP_TEXTURETYPE_SHIFT, // dcl_volume s# (for declaring a volume texture)
    D3DSTT_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSAMPLER_TEXTURE_TYPE;

//---------------------------------------------------------------------
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x000007FF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

// Bit masks for destination parameter modifiers
#define    D3DSPDM_NONE                 (0<<D3DSP_DSTMOD_SHIFT) // nop
#define    D3DSPDM_SATURATE             (1<<D3DSP_DSTMOD_SHIFT) // clamp to 0. to 1. range
#define    D3DSPDM_PARTIALPRECISION     (2<<D3DSP_DSTMOD_SHIFT) // Partial precision hint
#define    D3DSPDM_MSAMPCENTROID        (4<<D3DSP_DSTMOD_SHIFT) // Relevant to multisampling only:
                                                                //      When the pixel center is not covered, sample
                                                                //      attribute or compute gradients/LOD
                                                                //      using multisample "centroid" location.
                                                                //      "Centroid" is some location within the covered
                                                                //      region of the pixel.

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_SHIFT2    8
#define D3DSP_REGTYPE_MASK      0x70000000
#define D3DSP_REGTYPE_MASK2     0x00001800

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP           =  0, // Temporary Register File
    D3DSPR_INPUT          =  1, // Input Register File
    D3DSPR_CONST          =  2, // Constant Register File
    D3DSPR_ADDR           =  3, // Address Register (VS)
    D3DSPR_TEXTURE        =  3, // Texture Register File (PS)
    D3DSPR_RASTOUT        =  4, // Rasterizer Register File
    D3DSPR_ATTROUT        =  5, // Attribute Output Register File
    D3DSPR_TEXCRDOUT      =  6, // Texture Coordinate Output Register File
    D3DSPR_OUTPUT         =  6, // Output register file for VS3.0+
    D3DSPR_CONSTINT       =  7, // Constant Integer Vector Register File
    D3DSPR_COLOROUT       =  8, // Color Output Register File
    D3DSPR_DEPTHOUT       =  9, // Depth Output Register File
    D3DSPR_SAMPLER        = 10, // Sampler State Register File
    D3DSPR_CONST2         = 11, // Constant Register File  2048 - 4095
    D3DSPR_CONST3         = 12, // Constant Register File  4096 - 6143
    D3DSPR_CONST4         = 13, // Constant Register File  6144 - 8191
    D3DSPR_CONSTBOOL      = 14, // Constant Boolean register file
    D3DSPR_LOOP           = 15, // Loop counter register file
    D3DSPR_TEMPFLOAT16    = 16, // 16-bit float temp register file
    D3DSPR_MISCTYPE       = 17, // Miscellaneous (single) registers.
    D3DSPR_LABEL          = 18, // Label
    D3DSPR_PREDICATE      = 19, // Predicate register
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// The miscellaneous register file (D3DSPR_MISCTYPES)
// contains register types for which there is only ever one
// register (i.e. the register # is not needed).
// Rather than use up additional register types for such
// registers, they are defined
// as particular offsets into the misc. register file:
typedef enum _D3DSHADER_MISCTYPE_OFFSETS
{
    D3DSMO_POSITION   = 0, // Input position x,y,z,rhw (PS)
    D3DSMO_FACE   = 1, // Floating point primitive area (PS)
} D3DSHADER_MISCTYPE_OFFSETS;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (1 << D3DVS_ADDRESSMODE_SHIFT)

typedef enum _D3DVS_ADDRESSMODE_TYPE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVS_ADDRESSMODE_TYPE;

#define D3DSHADER_ADDRESSMODE_SHIFT 13
#define D3DSHADER_ADDRESSMODE_MASK  (1 << D3DSHADER_ADDRESSMODE_SHIFT)

typedef enum _D3DSHADER_ADDRESSMODE_TYPE
{
    D3DSHADER_ADDRMODE_ABSOLUTE  = (0 << D3DSHADER_ADDRESSMODE_SHIFT),
    D3DSHADER_ADDRMODE_RELATIVE  = (1 << D3DSHADER_ADDRESSMODE_SHIFT),
    D3DSHADER_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DSHADER_ADDRESSMODE_TYPE;

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X from:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y from:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z from:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W from:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATERED \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (0 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (0 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (0 << (D3DSP_SWIZZLE_SHIFT + 6)) )

#define D3DSP_REPLICATEGREEN \
    ( (1 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 6)) )

#define D3DSP_REPLICATEBLUE \
    ( (2 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 6)) )

#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_X2      = 7<<D3DSP_SRCMOD_SHIFT, // *2
    D3DSPSM_X2NEG   = 8<<D3DSP_SRCMOD_SHIFT, // *2 and negate
    D3DSPSM_DZ      = 9<<D3DSP_SRCMOD_SHIFT, // divide through by z component
    D3DSPSM_DW      = 10<<D3DSP_SRCMOD_SHIFT, // divide through by w component
    D3DSPSM_ABS     = 11<<D3DSP_SRCMOD_SHIFT, // abs()
    D3DSPSM_ABSNEG  = 12<<D3DSP_SRCMOD_SHIFT, // -abs()
    D3DSPSM_NOT     = 13<<D3DSP_SRCMOD_SHIFT, // for predicate register: "!p0"
    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF


//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_CATMULL_ROM = 2, /* In D3D8 this used to be D3DBASIS_INTERPOLATE */
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DDEGREETYPE
{
   D3DDEGREE_LINEAR      = 1,
   D3DDEGREE_QUADRATIC   = 2,
   D3DDEGREE_CUBIC       = 3,
   D3DDEGREE_QUINTIC     = 5,
   D3DDEGREE_FORCE_DWORD = 0x7fffffff,
} D3DDEGREETYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE  = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS = 2,     // 3 matrix blending
    D3DVBF_3WEIGHTS = 3,     // 4 matrix blending
    D3DVBF_TWEENING = 255,   // blending using D3DRS_TWEENFACTOR
    D3DVBF_0WEIGHTS = 256,   // one matrix is used with weight 1.0
    D3DVBF_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D9 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_NULLREF     = 4,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* Multi-Sample buffer types */
typedef enum _D3DMULTISAMPLE_TYPE
{
    D3DMULTISAMPLE_NONE            =  0,
    D3DMULTISAMPLE_NONMASKABLE     =  1,
    D3DMULTISAMPLE_2_SAMPLES       =  2,
    D3DMULTISAMPLE_3_SAMPLES       =  3,
    D3DMULTISAMPLE_4_SAMPLES       =  4,
    D3DMULTISAMPLE_5_SAMPLES       =  5,
    D3DMULTISAMPLE_6_SAMPLES       =  6,
    D3DMULTISAMPLE_7_SAMPLES       =  7,
    D3DMULTISAMPLE_8_SAMPLES       =  8,
    D3DMULTISAMPLE_9_SAMPLES       =  9,
    D3DMULTISAMPLE_10_SAMPLES      = 10,
    D3DMULTISAMPLE_11_SAMPLES      = 11,
    D3DMULTISAMPLE_12_SAMPLES      = 12,
    D3DMULTISAMPLE_13_SAMPLES      = 13,
    D3DMULTISAMPLE_14_SAMPLES      = 14,
    D3DMULTISAMPLE_15_SAMPLES      = 15,
    D3DMULTISAMPLE_16_SAMPLES      = 16,

    D3DMULTISAMPLE_FORCE_DWORD     = 0x7fffffff
} D3DMULTISAMPLE_TYPE;

/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *      C = Computed from other channels (typically on certain read operations)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D3DFMT_D16_LOCKABLE indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      D3DFMT_D32F_LOCKABLE indicates:
 *           - An IEEE 754 floating-point value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE and D3DFMT_D32F_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */


typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              =  0,

    D3DFMT_R8G8B8               = 20,
    D3DFMT_A8R8G8B8             = 21,
    D3DFMT_X8R8G8B8             = 22,
    D3DFMT_R5G6B5               = 23,
    D3DFMT_X1R5G5B5             = 24,
    D3DFMT_A1R5G5B5             = 25,
    D3DFMT_A4R4G4B4             = 26,
    D3DFMT_R3G3B2               = 27,
    D3DFMT_A8                   = 28,
    D3DFMT_A8R3G3B2             = 29,
    D3DFMT_X4R4G4B4             = 30,
    D3DFMT_A2B10G10R10          = 31,
    D3DFMT_A8B8G8R8             = 32,
    D3DFMT_X8B8G8R8             = 33,
    D3DFMT_G16R16               = 34,
    D3DFMT_A2R10G10B10          = 35,
    D3DFMT_A16B16G16R16         = 36,

    D3DFMT_A8P8                 = 40,
    D3DFMT_P8                   = 41,

    D3DFMT_L8                   = 50,
    D3DFMT_A8L8                 = 51,
    D3DFMT_A4L4                 = 52,

    D3DFMT_V8U8                 = 60,
    D3DFMT_L6V5U5               = 61,
    D3DFMT_X8L8V8U8             = 62,
    D3DFMT_Q8W8V8U8             = 63,
    D3DFMT_V16U16               = 64,
    D3DFMT_A2W10V10U10          = 67,

    D3DFMT_UYVY                 = MAKEFOURCC('U', 'Y', 'V', 'Y'),
    D3DFMT_R8G8_B8G8            = MAKEFOURCC('R', 'G', 'B', 'G'),
    D3DFMT_YUY2                 = MAKEFOURCC('Y', 'U', 'Y', '2'),
    D3DFMT_G8R8_G8B8            = MAKEFOURCC('G', 'R', 'G', 'B'),
    D3DFMT_DXT1                 = MAKEFOURCC('D', 'X', 'T', '1'),
    D3DFMT_DXT2                 = MAKEFOURCC('D', 'X', 'T', '2'),
    D3DFMT_DXT3                 = MAKEFOURCC('D', 'X', 'T', '3'),
    D3DFMT_DXT4                 = MAKEFOURCC('D', 'X', 'T', '4'),
    D3DFMT_DXT5                 = MAKEFOURCC('D', 'X', 'T', '5'),

    D3DFMT_D16_LOCKABLE         = 70,
    D3DFMT_D32                  = 71,
    D3DFMT_D15S1                = 73,
    D3DFMT_D24S8                = 75,
    D3DFMT_D24X8                = 77,
    D3DFMT_D24X4S4              = 79,
    D3DFMT_D16                  = 80,

    D3DFMT_D32F_LOCKABLE        = 82,
    D3DFMT_D24FS8               = 83,


    D3DFMT_L16                  = 81,

    D3DFMT_VERTEXDATA           =100,
    D3DFMT_INDEX16              =101,
    D3DFMT_INDEX32              =102,

    D3DFMT_Q16W16V16U16         =110,

    D3DFMT_MULTI2_ARGB8         = MAKEFOURCC('M','E','T','1'),

    // Floating point surface formats

    // s10e5 formats (16-bits per channel)
    D3DFMT_R16F                 = 111,
    D3DFMT_G16R16F              = 112,
    D3DFMT_A16B16G16R16F        = 113,

    // IEEE s23e8 formats (32-bits per channel)
    D3DFMT_R32F                 = 114,
    D3DFMT_G32R32F              = 115,
    D3DFMT_A32B32G32R32F        = 116,

    D3DFMT_CxV8U8               = 117,


    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Pool types */
typedef enum _D3DPOOL {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,
    D3DPOOL_SCRATCH                 = 3,

    D3DPOOL_FORCE_DWORD             = 0x7fffffff
} D3DPOOL;


/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000


/* Resize Optional Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD               MultiSampleQuality;

    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;

    /* FullScreen_RefreshRateInHz must be zero for Windowed mode */
    UINT                FullScreen_RefreshRateInHz;
    UINT                PresentationInterval;
} D3DPRESENT_PARAMETERS;

// Values for D3DPRESENT_PARAMETERS.Flags

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      0x00000001
#define D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL     0x00000002
#define D3DPRESENTFLAG_DEVICECLIP               0x00000004
#define D3DPRESENTFLAG_VIDEO                    0x00000010

/* Gamma Ramp: Same as DX7 */

typedef struct _D3DGAMMARAMP
{
    WORD                red  [256];
    WORD                green[256];
    WORD                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef enum _D3DBACKBUFFER_TYPE
{
    D3DBACKBUFFER_TYPE_MONO         = 0,
    D3DBACKBUFFER_TYPE_LEFT         = 1,
    D3DBACKBUFFER_TYPE_RIGHT        = 2,

    D3DBACKBUFFER_TYPE_FORCE_DWORD  = 0x7fffffff
} D3DBACKBUFFER_TYPE;


/* Types */
typedef enum _D3DRESOURCETYPE {
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,


    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Usages */
#define D3DUSAGE_RENDERTARGET       (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL       (0x00000002L)
#define D3DUSAGE_DYNAMIC            (0x00000200L)

// When passed to CheckDeviceFormat, D3DUSAGE_AUTOGENMIPMAP may return
// D3DOK_NOAUTOGEN if the device doesn't support autogeneration for that format.
// D3DOK_NOAUTOGEN is a success code, not a failure code... the SUCCEEDED and FAILED macros
// will return true and false respectively for this code.
#define D3DUSAGE_AUTOGENMIPMAP      (0x00000400L)
#define D3DUSAGE_DMAP               (0x00004000L)

// The following usages are valid only for querying CheckDeviceFormat
#define D3DUSAGE_QUERY_LEGACYBUMPMAP            (0x00008000L)
#define D3DUSAGE_QUERY_SRGBREAD                 (0x00010000L)
#define D3DUSAGE_QUERY_FILTER                   (0x00020000L)
#define D3DUSAGE_QUERY_SRGBWRITE                (0x00040000L)
#define D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING (0x00080000L)
#define D3DUSAGE_QUERY_VERTEXTEXTURE            (0x00100000L)
#define D3DUSAGE_QUERY_WRAPANDMIP	            (0x00200000L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY          (0x00000008L)
#define D3DUSAGE_SOFTWAREPROCESSING (0x00000010L)
#define D3DUSAGE_DONOTCLIP          (0x00000020L)
#define D3DUSAGE_POINTS             (0x00000040L)
#define D3DUSAGE_RTPATCHES          (0x00000080L)
#define D3DUSAGE_NPATCHES           (0x00000100L)










/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_READONLY           0x00000010L
#define D3DLOCK_DISCARD            0x00002000L
#define D3DLOCK_NOOVERWRITE        0x00001000L
#define D3DLOCK_NOSYSLOCK          0x00000800L
#define D3DLOCK_DONOTWAIT          0x00004000L                  

#define D3DLOCK_NO_DIRTY_UPDATE     0x00008000L







/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    DWORD               FVF;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD               MultiSampleQuality;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for LockRange */
typedef struct _D3DRANGE
{
    UINT                Offset;
    UINT                Size;
} D3DRANGE;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DDEGREETYPE       Degree;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DDEGREETYPE       Degree;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */

#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER9
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];
    char            DeviceName[32];         /* Device name for GDI (ex. \\.\DISPLAY1) */

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;          /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;   /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER9;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;



/* Debug monitor tokens (DEBUG only)

   Note that if D3DRS_DEBUGMONITORTOKEN is set, the call is treated as
   passing a token to the debug monitor.  For example, if, after passing
   D3DDMT_ENABLE/DISABLE to D3DRS_DEBUGMONITORTOKEN other token values
   are passed in, the enabled/disabled state of the debug
   monitor will still persist.

   The debug monitor defaults to enabled.

   Calling GetRenderState on D3DRS_DEBUGMONITORTOKEN is not of any use.
*/
typedef enum _D3DDEBUGMONITORTOKENS {
    D3DDMT_ENABLE            = 0,    // enable debug monitor
    D3DDMT_DISABLE           = 1,    // disable debug monitor
    D3DDMT_FORCE_DWORD     = 0x7fffffff,
} D3DDEBUGMONITORTOKENS;

// Async feedback

typedef enum _D3DQUERYTYPE {
    D3DQUERYTYPE_VCACHE                 = 4, /* D3DISSUE_END */
    D3DQUERYTYPE_RESOURCEMANAGER        = 5, /* D3DISSUE_END */
    D3DQUERYTYPE_VERTEXSTATS            = 6, /* D3DISSUE_END */
    D3DQUERYTYPE_EVENT                  = 8, /* D3DISSUE_END */
    D3DQUERYTYPE_OCCLUSION              = 9, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_TIMESTAMP              = 10, /* D3DISSUE_END */
    D3DQUERYTYPE_TIMESTAMPDISJOINT      = 11, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_TIMESTAMPFREQ          = 12, /* D3DISSUE_END */
    D3DQUERYTYPE_PIPELINETIMINGS        = 13, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_INTERFACETIMINGS       = 14, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_VERTEXTIMINGS          = 15, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_PIXELTIMINGS           = 16, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_BANDWIDTHTIMINGS       = 17, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_CACHEUTILIZATION       = 18, /* D3DISSUE_BEGIN, D3DISSUE_END */
} D3DQUERYTYPE;

// Flags field for Issue
#define D3DISSUE_END (1 << 0) // Tells the runtime to issue the end of a query, changing it's state to "non-signaled".
#define D3DISSUE_BEGIN (1 << 1) // Tells the runtime to issue the beginng of a query.


// Flags field for GetData
#define D3DGETDATA_FLUSH (1 << 0) // Tells the runtime to flush if the query is outstanding.


typedef struct _D3DRESOURCESTATS
{
// Data collected since last Present()
    BOOL    bThrashing;             /* indicates if thrashing */
    DWORD   ApproxBytesDownloaded;  /* Approximate number of bytes downloaded by resource manager */
    DWORD   NumEvicts;              /* number of objects evicted */
    DWORD   NumVidCreates;          /* number of objects created in video memory */
    DWORD   LastPri;                /* priority of last object evicted */
    DWORD   NumUsed;                /* number of objects set to the device */
    DWORD   NumUsedInVidMem;        /* number of objects set to the device, which are already in video memory */
// Persistent data
    DWORD   WorkingSet;             /* number of objects in video memory */
    DWORD   WorkingSetBytes;        /* number of bytes in video memory */
    DWORD   TotalManaged;           /* total number of managed objects */
    DWORD   TotalBytes;             /* total number of bytes of managed objects */
} D3DRESOURCESTATS;

#define D3DRTYPECOUNT (D3DRTYPE_INDEXBUFFER+1)

typedef struct _D3DDEVINFO_RESOURCEMANAGER
{
    D3DRESOURCESTATS    stats[D3DRTYPECOUNT];
} D3DDEVINFO_RESOURCEMANAGER, *LPD3DDEVINFO_RESOURCEMANAGER;

typedef struct _D3DDEVINFO_D3DVERTEXSTATS
{
    DWORD   NumRenderedTriangles;       /* total number of triangles that are not clipped in this frame */
    DWORD   NumExtraClippingTriangles;  /* Number of new triangles generated by clipping */
} D3DDEVINFO_D3DVERTEXSTATS, *LPD3DDEVINFO_D3DVERTEXSTATS;


typedef struct _D3DDEVINFO_VCACHE {
    DWORD   Pattern;                    /* bit pattern, return value must be FOUR_CC(C, A, C, H) */
    DWORD   OptMethod;                  /* optimization method 0 means longest strips, 1 means vertex cache based */
    DWORD   CacheSize;                  /* cache size to optimize for  (only required if type is 1) */
    DWORD   MagicNumber;                /* used to determine when to restart strips (only required if type is 1)*/
} D3DDEVINFO_VCACHE, *LPD3DDEVINFO_VCACHE;

typedef struct _D3DDEVINFO_D3D9PIPELINETIMINGS
{
    FLOAT VertexProcessingTimePercent;
    FLOAT PixelProcessingTimePercent;
    FLOAT OtherGPUProcessingTimePercent;
    FLOAT GPUIdleTimePercent;
} D3DDEVINFO_D3D9PIPELINETIMINGS;

typedef struct _D3DDEVINFO_D3D9INTERFACETIMINGS
{
    FLOAT WaitingForGPUToUseApplicationResourceTimePercent;
    FLOAT WaitingForGPUToAcceptMoreCommandsTimePercent;
    FLOAT WaitingForGPUToStayWithinLatencyTimePercent;
    FLOAT WaitingForGPUExclusiveResourceTimePercent;
    FLOAT WaitingForGPUOtherTimePercent;
} D3DDEVINFO_D3D9INTERFACETIMINGS;

typedef struct _D3DDEVINFO_D3D9STAGETIMINGS
{
    FLOAT MemoryProcessingPercent;
    FLOAT ComputationProcessingPercent;
} D3DDEVINFO_D3D9STAGETIMINGS;

typedef struct _D3DDEVINFO_D3D9BANDWIDTHTIMINGS
{
    FLOAT MaxBandwidthUtilized;
    FLOAT FrontEndUploadMemoryUtilizedPercent;
    FLOAT VertexRateUtilizedPercent;
    FLOAT TriangleSetupRateUtilizedPercent;
    FLOAT FillRateUtilizedPercent;
} D3DDEVINFO_D3D9BANDWIDTHTIMINGS;

typedef struct _D3DDEVINFO_D3D9CACHEUTILIZATION
{
    FLOAT TextureCacheHitRate; // Percentage of cache hits
    FLOAT PostTransformVertexCacheHitRate;
} D3DDEVINFO_D3D9CACHEUTILIZATION;

#pragma pack()
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif /* (DIRECT3D_VERSION >= 0x0900) */
#endif /* _d3d9TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3drm.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"

#ifdef __cplusplus
struct IDirect3DRM;
#endif

typedef struct IDirect3DRM *LPDIRECT3DRM;

#include "d3drmobj.h"

#ifdef __cplusplus
extern "C" {
#endif


DEFINE_GUID(IID_IDirect3DRM,    0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRM2,   0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x4516ec83, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);
WIN_TYPES(IDirect3DRM2, DIRECT3DRM2);
WIN_TYPES(IDirect3DRM3, DIRECT3DRM3);

/*
 * Direct3DRM Object Class (for CoCreateInstance())
 */
DEFINE_GUID(CLSID_CDirect3DRM,  0x4516ec41, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);


/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
        LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;

    STDMETHOD(CreateShadow)
    (   THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;

    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;

    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;

    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;

    STDMETHOD(Load)
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
        LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM2

DECLARE_INTERFACE_(IDirect3DRM2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME2 *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER2 *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE2 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE2 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
        LPDIRECT3DRMDEVICE2 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE2 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE2 *) PURE;

    STDMETHOD(CreateShadow)
    (   THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE2 *) PURE;

    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;

    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;

    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;

    STDMETHOD(Load)
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
        LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM3

DECLARE_INTERFACE_(IDirect3DRM3, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME3, LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3 *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION2 *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET2 *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE3 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags, LPDIRECT3DRMDEVICE3 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
        LPDIRECT3DRMDEVICE3 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE3 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE3 *) PURE;

    STDMETHOD(CreateShadow)
    (   THIS_ LPUNKNOWN, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMSHADOW2 *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE3, LPDIRECT3DRMFRAME3, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT2 *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME3,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE3 *) PURE;

    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;

    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;

    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;

    STDMETHOD(Load)
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURE3CALLBACK, LPVOID,
        LPDIRECT3DRMFRAME3
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;

    /* Used with IDirect3DRMObject2 */
    STDMETHOD(RegisterClient)   (THIS_ REFGUID rguid, LPDWORD lpdwID) PURE;
    STDMETHOD(UnregisterClient) (THIS_ REFGUID rguid) PURE;

    STDMETHOD(CreateClippedVisual) (THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMCLIPPEDVISUAL *) PURE;
    STDMETHOD(SetOptions) (THIS_ DWORD);
    STDMETHOD(GetOptions) (THIS_ LPDWORD);
};

#define D3DRM_OK                        DD_OK
#define D3DRMERR_BADOBJECT              MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE                MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC               MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED               MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND               MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET             MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND           MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE                MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE              MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE               MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION        MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION        MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE        MAKE_DDHRESULT(793)
#define D3DRMERR_LIBRARYNOTFOUND        MAKE_DDHRESULT(794)
#define D3DRMERR_INVALIDLIBRARY         MAKE_DDHRESULT(795)
#define D3DRMERR_PENDING                MAKE_DDHRESULT(796)
#define D3DRMERR_NOTENOUGHDATA          MAKE_DDHRESULT(797)
#define D3DRMERR_REQUESTTOOLARGE        MAKE_DDHRESULT(798)
#define D3DRMERR_REQUESTTOOSMALL        MAKE_DDHRESULT(799)
#define D3DRMERR_CONNECTIONLOST         MAKE_DDHRESULT(800)
#define D3DRMERR_LOADABORTED            MAKE_DDHRESULT(801)
#define D3DRMERR_NOINTERNET             MAKE_DDHRESULT(802)
#define D3DRMERR_BADCACHEFILE           MAKE_DDHRESULT(803)
#define D3DRMERR_BOXNOTSET              MAKE_DDHRESULT(804)
#define D3DRMERR_BADPMDATA              MAKE_DDHRESULT(805)
#define D3DRMERR_CLIENTNOTREGISTERED    MAKE_DDHRESULT(806)
#define D3DRMERR_NOTCREATEDFROMDDS      MAKE_DDHRESULT(807)
#define D3DRMERR_NOSUCHKEY              MAKE_DDHRESULT(808)
#define D3DRMERR_INCOMPATABLEKEY        MAKE_DDHRESULT(809)
#define D3DRMERR_ELEMENTINUSE           MAKE_DDHRESULT(810)
#define D3DRMERR_TEXTUREFORMATNOTFOUND  MAKE_DDHRESULT(811)
#define D3DRMERR_NOTAGGREGATED          MAKE_DDHRESULT(812)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3drmdef.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMRAY
{   D3DVECTOR dvDir;
    D3DVECTOR dvPos;
} D3DRMRAY, *LPD3DRMRAY;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT     = 0,
    D3DRMSHADE_GOURAUD  = 1,
    D3DRMSHADE_PHONG    = 2,

    D3DRMSHADE_MASK     = 7,
    D3DRMSHADE_MAX      = 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF      = 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON       = 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK     = 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX      = 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS    = 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME = 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID     = 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK      = 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX       = 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT        (D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD     (D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG       (D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

#define D3DRMRENDERMODE_BLENDEDTRANSPARENCY     1
#define D3DRMRENDERMODE_SORTEDTRANSPARENCY      2
#define D3DRMRENDERMODE_LIGHTINMODELSPACE       8
#define D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR   16
#define D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE 32

typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,               /* choose nearest texel */
    D3DRMTEXTURE_LINEAR,                /* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,            /* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,             /* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,      /* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR        /* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

/*
 * Texture flags
 */
#define D3DRMTEXTURE_FORCERESIDENT          0x00000001 /* texture should be kept in video memory */
#define D3DRMTEXTURE_STATIC                 0x00000002 /* texture will not change */
#define D3DRMTEXTURE_DOWNSAMPLEPOINT        0x00000004 /* point filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEBILINEAR     0x00000008 /* bilinear filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEREDUCEDEPTH  0x00000010 /* reduce bit depth when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLENONE         0x00000020 /* texture should never be downsampled */
#define D3DRMTEXTURE_CHANGEDPIXELS          0x00000040 /* pixels have changed */
#define D3DRMTEXTURE_CHANGEDPALETTE         0x00000080 /* palette has changed */
#define D3DRMTEXTURE_INVALIDATEONLY         0x00000100 /* dirty regions are invalid */

/*
 * Shadow flags
 */
#define D3DRMSHADOW_TRUEALPHA               0x00000001 /* shadow should render without artifacts when true alpha is on */

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,                  /* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,              /* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED               /* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;          /* 0 .. 255 */
    unsigned char green;        /* 0 .. 255 */
    unsigned char blue;         /* 0 .. 255 */
    unsigned char flags;        /* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;          /* width and height in pixels */
    int aspectx, aspecty;       /* aspect ratio for non-square pixels */
    int depth;                  /* bits per pixel */
    int rgb;                    /* if false, pixels are indices into a
                                   palette otherwise, pixels encode
                                   RGB values. */
    int bytes_per_line;         /* number of bytes of memory for a
                                   scanline. This must be a multiple
                                   of 4. */
    void* buffer1;              /* memory to render into (first buffer). */
    void* buffer2;              /* second rendering buffer for double
                                   buffering, set to NULL for single
                                   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;   /* if rgb is true, these are masks for
                                   the red, green and blue parts of a
                                   pixel.  Otherwise, these are masks
                                   for the significant bits of the
                                   red, green and blue elements in the
                                   palette.  For instance, most SVGA
                                   displays use 64 intensities of red,
                                   green and blue, so the masks should
                                   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette; /* description of the palette (only if
                                   rgb is false).  Must be (1<<depth)
                                   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME,
    D3DRMWRAP_SHEET,
    D3DRMWRAP_BOX
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL             1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE       2 /* lines are obscured by closer objects */

/*
 * Do not use righthanded perspective in Viewport2::SetProjection().
 * Set up righthanded mode by using IDirect3DRM3::SetOptions().
 */
typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC,
    D3DRMPROJECT_RIGHTHANDPERSPECTIVE, /* Only valid pre-DX6 */
    D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC /* Only valid pre-DX6 */
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

#define D3DRMOPTIONS_LEFTHANDED  0x00000001L /* Default */
#define D3DRMOPTIONS_RIGHTHANDED 0x00000002L

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16
#define D3DRMXOFSAVE_TEXTURETOPOLOGY 32

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,           /* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,           /* use only X and Z rotations */
    D3DRMCONSTRAIN_X            /* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,            /* linear between start and end */
    D3DRMFOG_EXPONENTIAL,       /* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED /* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,    /* default */
    D3DRMZBUFFER_ENABLE,        /* enable zbuffering */
    D3DRMZBUFFER_DISABLE        /* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,       /* default */
    D3DRMSORT_NONE,             /* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,      /* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT       /* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef struct _D3DRMMATERIALOVERRIDE
{
    DWORD         dwSize;       /* Size of this structure */
    DWORD         dwFlags;      /* Indicate which fields are valid */
    D3DCOLORVALUE dcDiffuse;    /* RGBA */
    D3DCOLORVALUE dcAmbient;    /* RGB */
    D3DCOLORVALUE dcEmissive;   /* RGB */
    D3DCOLORVALUE dcSpecular;   /* RGB */
    D3DVALUE      dvPower;
    LPUNKNOWN     lpD3DRMTex;
} D3DRMMATERIALOVERRIDE, *LPD3DRMMATERIALOVERRIDE;

#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY     0x00000001L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY       0x00000002L
#define D3DRMMATERIALOVERRIDE_DIFFUSE               0x00000003L
#define D3DRMMATERIALOVERRIDE_AMBIENT               0x00000004L
#define D3DRMMATERIALOVERRIDE_EMISSIVE              0x00000008L
#define D3DRMMATERIALOVERRIDE_SPECULAR              0x00000010L
#define D3DRMMATERIALOVERRIDE_POWER                 0x00000020L
#define D3DRMMATERIALOVERRIDE_TEXTURE               0x00000040L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY 0x00000080L
#define D3DRMMATERIALOVERRIDE_ALL                   0x000000FFL

#define D3DRMFPTF_ALPHA                           0x00000001L
#define D3DRMFPTF_NOALPHA                         0x00000002L
#define D3DRMFPTF_PALETTIZED                      0x00000004L
#define D3DRMFPTF_NOTPALETTIZED                   0x00000008L

#define D3DRMSTATECHANGE_UPDATEONLY               0x000000001L
#define D3DRMSTATECHANGE_VOLATILE                 0x000000002L
#define D3DRMSTATECHANGE_NONVOLATILE              0x000000004L
#define D3DRMSTATECHANGE_RENDER                   0x000000020L
#define D3DRMSTATECHANGE_LIGHT                    0x000000040L

/*
 * Values for flags in RM3::CreateDeviceFromSurface
 */
#define D3DRMDEVICE_NOZBUFFER           0x00000001L

/*
 * Values for flags in Object2::SetClientData
 */
#define D3DRMCLIENTDATA_NONE            0x00000001L
#define D3DRMCLIENTDATA_LOCALFREE       0x00000002L
#define D3DRMCLIENTDATA_IUNKNOWN        0x00000004L

/*
 * Values for flags in Frame2::AddMoveCallback.
 */
#define D3DRMCALLBACK_PREORDER          0
#define D3DRMCALLBACK_POSTORDER         1

/*
 * Values for flags in MeshBuilder2::RayPick.
 */
#define D3DRMRAYPICK_ONLYBOUNDINGBOXES          1
#define D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES    2
#define D3DRMRAYPICK_INTERPOLATEUV              4
#define D3DRMRAYPICK_INTERPOLATECOLOR           8
#define D3DRMRAYPICK_INTERPOLATENORMAL          0x10

/*
 * Values for flags in MeshBuilder3::AddFacesIndexed.
 */
#define D3DRMADDFACES_VERTICESONLY              1

/*
 * Values for flags in MeshBuilder2::GenerateNormals.
 */
#define D3DRMGENERATENORMALS_PRECOMPACT         1
#define D3DRMGENERATENORMALS_USECREASEANGLE     2

/*
 * Values for MeshBuilder3::GetParentMesh
 */
#define D3DRMMESHBUILDER_DIRECTPARENT           1
#define D3DRMMESHBUILDER_ROOTMESH               2

/*
 * Flags for MeshBuilder3::Enable
 */
#define D3DRMMESHBUILDER_RENDERENABLE   0x00000001L
#define D3DRMMESHBUILDER_PICKENABLE     0x00000002L

/*
 * Flags for MeshBuilder3::AddMeshBuilder
 */
#define D3DRMADDMESHBUILDER_DONTCOPYAPPDATA     1
#define D3DRMADDMESHBUILDER_FLATTENSUBMESHES    2
#define D3DRMADDMESHBUILDER_NOSUBMESHES         4

/*
 * Flags for Object2::GetAge when used with MeshBuilders
 */
#define D3DRMMESHBUILDERAGE_GEOMETRY    0x00000001L
#define D3DRMMESHBUILDERAGE_MATERIALS   0x00000002L
#define D3DRMMESHBUILDERAGE_TEXTURES    0x00000004L

/*
 * Format flags for MeshBuilder3::AddTriangles.
 */
#define D3DRMFVF_TYPE                   0x00000001L
#define D3DRMFVF_NORMAL                 0x00000002L
#define D3DRMFVF_COLOR                  0x00000004L
#define D3DRMFVF_TEXTURECOORDS          0x00000008L

#define D3DRMVERTEX_STRIP               0x00000001L
#define D3DRMVERTEX_FAN                 0x00000002L
#define D3DRMVERTEX_LIST                0x00000004L

/*
 * Values for flags in Viewport2::Clear2
 */
#define D3DRMCLEAR_TARGET               0x00000001L
#define D3DRMCLEAR_ZBUFFER              0x00000002L
#define D3DRMCLEAR_DIRTYRECTS           0x00000004L
#define D3DRMCLEAR_ALL                  (D3DRMCLEAR_TARGET | \
                                         D3DRMCLEAR_ZBUFFER | \
                                         D3DRMCLEAR_DIRTYRECTS)

/*
 * Values for flags in Frame3::SetSceneFogMethod
 */
#define D3DRMFOGMETHOD_VERTEX          0x00000001L
#define D3DRMFOGMETHOD_TABLE           0x00000002L
#define D3DRMFOGMETHOD_ANY             0x00000004L

/*
 * Values for flags in Frame3::SetTraversalOptions
 */
#define D3DRMFRAME_RENDERENABLE        0x00000001L
#define D3DRMFRAME_PICKENABLE          0x00000002L

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMINTERPOLATIONOPTIONS;
#define D3DRMINTERPOLATION_OPEN 0x01L
#define D3DRMINTERPOLATION_CLOSED 0x02L
#define D3DRMINTERPOLATION_NEAREST 0x0100L
#define D3DRMINTERPOLATION_LINEAR 0x04L
#define D3DRMINTERPOLATION_SPLINE 0x08L
#define D3DRMINTERPOLATION_VERTEXCOLOR 0x40L
#define D3DRMINTERPOLATION_SLERPNORMALS 0x80L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L
#define D3DRMLOAD_FROMURL 0x08L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

#define D3DRMLOAD_ASYNCHRONOUS 0x400L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

#define D3DRMPMESHSTATUS_VALID 0x01L
#define D3DRMPMESHSTATUS_INTERRUPTED 0x02L
#define D3DRMPMESHSTATUS_BASEMESHCOMPLETE 0x04L
#define D3DRMPMESHSTATUS_COMPLETE 0x08L
#define D3DRMPMESHSTATUS_RENDERABLE 0x10L

#define D3DRMPMESHEVENT_BASEMESH 0x01L
#define D3DRMPMESHEVENT_COMPLETE 0x02L

typedef struct _D3DRMPMESHLOADSTATUS {
  DWORD dwSize;            // Size of this structure
  DWORD dwPMeshSize;       // Total Size (bytes)
  DWORD dwBaseMeshSize;    // Total Size of the Base Mesh
  DWORD dwBytesLoaded;     // Total bytes loaded
  DWORD dwVerticesLoaded;  // Number of vertices loaded
  DWORD dwFacesLoaded;     // Number of faces loaded
  HRESULT dwLoadResult;    // Result of the load operation
  DWORD dwFlags;
} D3DRMPMESHLOADSTATUS, *LPD3DRMPMESHLOADSTATUS;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;


typedef struct _D3DRMANIMATIONKEY
{
    DWORD dwSize;
    DWORD dwKeyType;
    D3DVALUE dvTime;
    DWORD dwID;
#if (!defined __cplusplus) || (!defined D3D_OVERLOADS)
    union
    {
        D3DRMQUATERNION dqRotateKey;
        D3DVECTOR dvScaleKey;
        D3DVECTOR dvPositionKey;
    };
#else
    /*
     * We do this as D3D_OVERLOADS defines constructors for D3DVECTOR,
     * this can then not be used in a union.  Use the inlines provided
     * to extract and set the required component.
     */
    D3DVALUE dvK[4];
#endif
} D3DRMANIMATIONKEY;
typedef D3DRMANIMATIONKEY *LPD3DRMANIMATIONKEY;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
inline VOID
D3DRMAnimationGetRotateKey(const D3DRMANIMATIONKEY& rmKey,
                           D3DRMQUATERNION& rmQuat)
{
    rmQuat.s = rmKey.dvK[0];
    rmQuat.v = D3DVECTOR(rmKey.dvK[1], rmKey.dvK[2], rmKey.dvK[3]);
}

inline VOID
D3DRMAnimationGetScaleKey(const D3DRMANIMATIONKEY& rmKey,
                          D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}

inline VOID
D3DRMAnimationGetPositionKey(const D3DRMANIMATIONKEY& rmKey,
                             D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}
inline VOID
D3DRMAnimationSetRotateKey(D3DRMANIMATIONKEY& rmKey,
                           const D3DRMQUATERNION& rmQuat)
{
    rmKey.dvK[0] = rmQuat.s;
    rmKey.dvK[1] = rmQuat.v.x;
    rmKey.dvK[2] = rmQuat.v.y;
    rmKey.dvK[3] = rmQuat.v.z;
}

inline VOID
D3DRMAnimationSetScaleKey(D3DRMANIMATIONKEY& rmKey,
                          const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}

inline VOID
D3DRMAnimationSetPositionKey(D3DRMANIMATIONKEY& rmKey,
                             const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}
#endif

#define D3DRMANIMATION_ROTATEKEY 0x01
#define D3DRMANIMATION_SCALEKEY 0x02
#define D3DRMANIMATION_POSITIONKEY 0x03


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR       position;
    D3DVECTOR       normal;
    D3DVALUE        tu, tv;
    D3DCOLOR        color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGB(D3DVALUE red,
                                          D3DVALUE green,
                                          D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGBA(D3DVALUE red,
                                                 D3DVALUE green,
                                                 D3DVALUE blue,
                                                 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
                                          LPD3DVECTOR s1,
                                          LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
                                               LPD3DVECTOR s1,
                                               LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
                                              LPD3DVECTOR ray,
                                              LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
                                                   LPD3DVECTOR s1,
                                                   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
                                                 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
                                                              LPD3DVECTOR v,
                                                              D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
                                                          LPD3DRMQUATERNION a,
                                                          LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
                                                       LPD3DRMQUATERNION a,
                                                       LPD3DRMQUATERNION b,
                                                       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void             D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);

/*
 * Calculate the quaternion that corresponds to a rotation matrix
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromMatrix(LPD3DRMQUATERNION, D3DRMMATRIX4D);


#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3dx8.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8_H__
#define __D3DX8_H__

#include "d3d8.h"
#include <limits.h>

#ifndef D3DXINLINE
#ifdef _MSC_VER
  #if (_MSC_VER >= 1200)
  #define D3DXINLINE __forceinline
  #else
  #define D3DXINLINE __inline
  #endif
#else
  #ifdef __cplusplus
  #define D3DXINLINE inline
  #else
  #define D3DXINLINE
  #endif
#endif
#endif


#define D3DX_DEFAULT ULONG_MAX
#define D3DX_DEFAULT_FLOAT FLT_MAX

#include "d3dx8math.h"
#include "d3dx8core.h"
#include "d3dx8tex.h"
#include "d3dx8mesh.h"
#include "d3dx8shape.h"
#include "d3dx8effect.h"


#endif //__D3DX8_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3drmwin.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

#include "d3drm.h"

#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3dx.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX_H__
#define __D3DX_H__

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#include "d3dxcore.h"
#include "d3dxmath.h"
#include "d3dxshapes.h"
#include "d3dxsprite.h"

#endif //__D3DX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3drmobj.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

#include <objbase.h> /* Use Windows header files */
#define VIRTUAL
#include "d3drmdef.h"

#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)           (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)           (THIS) kind; \
    STDMETHOD_(ULONG, Release)          (THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)                    (THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)       (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)    (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)               (THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)       (THIS) kind; \
    STDMETHOD(SetName)                  (THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)                  (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)             (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMObject2, DIRECT3DRMOBJECT2);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMDevice2, DIRECT3DRMDEVICE2);
WIN_TYPES(IDirect3DRMDevice3, DIRECT3DRMDEVICE3);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMViewport2, DIRECT3DRMVIEWPORT2);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMFrame2, DIRECT3DRMFRAME2);
WIN_TYPES(IDirect3DRMFrame3, DIRECT3DRMFRAME3);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMMeshBuilder2, DIRECT3DRMMESHBUILDER2);
WIN_TYPES(IDirect3DRMMeshBuilder3, DIRECT3DRMMESHBUILDER3);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMFace2, DIRECT3DRMFACE2);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMTexture2, DIRECT3DRMTEXTURE2);
WIN_TYPES(IDirect3DRMTexture3, DIRECT3DRMTEXTURE3);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMMaterial2, DIRECT3DRMMATERIAL2);
WIN_TYPES(IDirect3DRMInterpolator, DIRECT3DRMINTERPOLATOR);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimation2, DIRECT3DRMANIMATION2);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMAnimationSet2, DIRECT3DRMANIMATIONSET2);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMShadow2, DIRECT3DRMSHADOW2);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMARRAY);
WIN_TYPES(IDirect3DRMObjectArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMAnimationArray, DIRECT3DRMANIMATIONARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMPicked2Array, DIRECT3DRMPICKED2ARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);
WIN_TYPES(IDirect3DRMProgressiveMesh, DIRECT3DRMPROGRESSIVEMESH);
WIN_TYPES(IDirect3DRMClippedVisual, DIRECT3DRMCLIPPEDVISUAL);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,        0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,      0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,         0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,          0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,          0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,         0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,       0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,          0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,      0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,     0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,        0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewportInterpolator,
0xde9eaa1, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMFrameInterpolator,
0xde9eaa2, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMeshInterpolator,
0xde9eaa3, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMLightInterpolator,
0xde9eaa6, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMaterialInterpolator,
0xde9eaa7, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMTextureInterpolator,
0xde9eaa8, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMProgressiveMesh, 0x4516ec40, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMClippedVisual,   0x5434e72d, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);


/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,         0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,          0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0x4516ec82, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFace2,           0x4516ec81, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,     0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray,
0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,         0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);

typedef void (__cdecl *D3DRMOBJECTCALLBACK)(LPDIRECT3DRMOBJECT obj, LPVOID arg);
typedef void (__cdecl *D3DRMFRAMEMOVECALLBACK)(LPDIRECT3DRMFRAME obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMFRAME3MOVECALLBACK)(LPDIRECT3DRMFRAME3 obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMUPDATECALLBACK)(LPDIRECT3DRMDEVICE obj, LPVOID arg, int, LPD3DRECT);
typedef void (__cdecl *D3DRMDEVICE3UPDATECALLBACK)(LPDIRECT3DRMDEVICE3 obj, LPVOID arg, int, LPD3DRECT);
typedef int (__cdecl *D3DRMUSERVISUALCALLBACK)
    (   LPDIRECT3DRMUSERVISUAL obj, LPVOID arg, D3DRMUSERVISUALREASON reason,
        LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view
    );
typedef HRESULT (__cdecl *D3DRMLOADTEXTURECALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE *);
typedef HRESULT (__cdecl *D3DRMLOADTEXTURE3CALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE3 *);
typedef void (__cdecl *D3DRMLOADCALLBACK)
    (LPDIRECT3DRMOBJECT object, REFIID objectguid, LPVOID arg);

typedef HRESULT (__cdecl *D3DRMDOWNSAMPLECALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     LPDIRECTDRAWSURFACE pDDSSrc, LPDIRECTDRAWSURFACE pDDSDst);
typedef HRESULT (__cdecl *D3DRMVALIDATIONCALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     DWORD dwFlags, DWORD dwcRects, LPRECT pRects);


typedef struct _D3DRMPICKDESC
{
    ULONG       ulFaceIdx;
    LONG        lGroupIdx;
    D3DVECTOR   vPosition;

} D3DRMPICKDESC, *LPD3DRMPICKDESC;

typedef struct _D3DRMPICKDESC2
{
    ULONG       ulFaceIdx;
    LONG        lGroupIdx;
    D3DVECTOR   dvPosition;
    D3DVALUE    tu;
    D3DVALUE    tv;
    D3DVECTOR   dvNormal;
    D3DCOLOR    dcColor;

} D3DRMPICKDESC2, *LPD3DRMPICKDESC2;

#undef INTERFACE
#define INTERFACE IDirect3DRMObject

/*
 * Base class
 */
DECLARE_INTERFACE_(IDirect3DRMObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObject2

DECLARE_INTERFACE_(IDirect3DRMObject2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMObject2 methods
     */
    STDMETHOD(AddDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE;
    STDMETHOD(Clone)(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) PURE; \
    STDMETHOD(DeleteDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE; \
    STDMETHOD(GetClientData)(THIS_ DWORD dwID, LPVOID* lplpvData) PURE;
    STDMETHOD(GetDirect3DRM)(THIS_ LPDIRECT3DRM* lplpDirect3DRM) PURE;
    STDMETHOD(GetName)(THIS_ LPDWORD lpdwSize, LPSTR lpName) PURE;
    STDMETHOD(SetClientData)(THIS_ DWORD dwID, LPVOID lpvData, DWORD dwFlags) PURE;
    STDMETHOD(SetName)(THIS_ LPCSTR lpName) PURE;
    STDMETHOD(GetAge)(THIS_ DWORD dwFlags, LPDWORD pdwAge) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisual

DECLARE_INTERFACE_(IDirect3DRMVisual, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice

DECLARE_INTERFACE_(IDirect3DRMDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice2

DECLARE_INTERFACE_(IDirect3DRMDevice2, IDirect3DRMDevice)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice3

DECLARE_INTERFACE_(IDirect3DRMDevice3, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;

    /*
     * IDirect3DRMDevice3 methods
     */
    STDMETHOD(FindPreferredTextureFormat)(THIS_ DWORD dwBitDepths, DWORD dwFlags, LPDDPIXELFORMAT lpDDPF) PURE;
    STDMETHOD(RenderStateChange)(THIS_ D3DRENDERSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(LightStateChange)(THIS_ D3DLIGHTSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(GetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, LPDWORD pdwFlags) PURE;
    STDMETHOD(SetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, DWORD dwFlags) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMViewport

DECLARE_INTERFACE_(IDirect3DRMViewport, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMFRAME camera,
        DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewport2
DECLARE_INTERFACE_(IDirect3DRMViewport2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport2 methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMDEVICE3 dev, LPDIRECT3DRMFRAME3 camera,
        DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME3) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE3 *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
    STDMETHOD(TransformVectors)(THIS_ DWORD dwNumVectors,
                                LPD3DRMVECTOR4D lpDstVectors,
                                LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ DWORD dwNumVectors,
                                       LPD3DVECTOR lpDstVectors,
                                       LPD3DRMVECTOR4D lpSrcVectors) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame

DECLARE_INTERFACE_(IDirect3DRMFrame, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame2

DECLARE_INTERFACE_(IDirect3DRMFrame2, IDirect3DRMFrame)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;

    /*
     * IDirect3DRMFrame2 methods
     */
    STDMETHOD(AddMoveCallback2)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
                       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat,
                    D3DRMSAVEOPTIONS d3dSaveFlags);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame3

DECLARE_INTERFACE_(IDirect3DRMFrame3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame3 methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME3 child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(GetTransform)(THIS_ LPDIRECT3DRMFRAME3 reference,
                             D3DRMMATRIX4D rmMatrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME3 target, LPDIRECT3DRMFRAME3 reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME3 reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
                       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat,
                    D3DRMSAVEOPTIONS d3dSaveFlags);
    STDMETHOD(TransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
                                DWORD dwNumVectors,
                                LPD3DVECTOR lpDstVectors,
                                LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
                                       DWORD dwNumVectors,
                                       LPD3DVECTOR lpDstVectors,
                                       LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(SetTraversalOptions)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetTraversalOptions)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetSceneFogMethod)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetSceneFogMethod)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
    STDMETHOD(GetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMesh

DECLARE_INTERFACE_(IDirect3DRMMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMesh methods
     */
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(AddGroup)(THIS_ unsigned vCount, unsigned fCount, unsigned vPerFace, unsigned *fData, D3DRMGROUPINDEX *returnId) PURE;
    STDMETHOD(SetVertices)(THIS_ D3DRMGROUPINDEX id, unsigned index, unsigned count, D3DRMVERTEX *values) PURE;
    STDMETHOD(SetGroupColor)(THIS_ D3DRMGROUPINDEX id, D3DCOLOR value) PURE;
    STDMETHOD(SetGroupColorRGB)(THIS_ D3DRMGROUPINDEX id, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetGroupMapping)(THIS_ D3DRMGROUPINDEX id, D3DRMMAPPING value) PURE;
    STDMETHOD(SetGroupQuality)(THIS_ D3DRMGROUPINDEX id, D3DRMRENDERQUALITY value) PURE;
    STDMETHOD(SetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL value) PURE;
    STDMETHOD(SetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE value) PURE;

    STDMETHOD_(unsigned, GetGroupCount)(THIS) PURE;
    STDMETHOD(GetGroup)(THIS_ D3DRMGROUPINDEX id, unsigned *vCount, unsigned *fCount, unsigned *vPerFace, DWORD *fDataSize, unsigned *fData) PURE;
    STDMETHOD(GetVertices)(THIS_ D3DRMGROUPINDEX id, DWORD index, DWORD count, D3DRMVERTEX *returnPtr) PURE;
    STDMETHOD_(D3DCOLOR, GetGroupColor)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMMAPPING, GetGroupMapping)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetGroupQuality)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD(GetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL *returnPtr) PURE;
    STDMETHOD(GetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE *returnPtr) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMProgressiveMesh

DECLARE_INTERFACE_(IDirect3DRMProgressiveMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMProgressiveMesh methods
     */
    STDMETHOD(Load) (THIS_ LPVOID lpObjLocation, LPVOID lpObjId,
                     D3DRMLOADOPTIONS dloLoadflags, D3DRMLOADTEXTURECALLBACK lpCallback,
                     LPVOID lpArg) PURE;
    STDMETHOD(GetLoadStatus) (THIS_ LPD3DRMPMESHLOADSTATUS lpStatus) PURE;
    STDMETHOD(SetMinRenderDetail) (THIS_ D3DVALUE d3dVal) PURE;
    STDMETHOD(Abort) (THIS_ DWORD dwFlags) PURE;

    STDMETHOD(GetFaceDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(GetVertexDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(SetFaceDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(SetVertexDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(GetFaceDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetVertexDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetDetail) (THIS_ D3DVALUE *lpdvVal) PURE;
    STDMETHOD(SetDetail) (THIS_ D3DVALUE d3dVal) PURE;

    STDMETHOD(RegisterEvents) (THIS_ HANDLE hEvent, DWORD dwFlags, DWORD dwReserved) PURE;
    STDMETHOD(CreateMesh) (THIS_ LPDIRECT3DRMMESH *lplpD3DRMMesh) PURE;
    STDMETHOD(Duplicate) (THIS_ LPDIRECT3DRMPROGRESSIVEMESH *lplpD3DRMPMesh) PURE;
    STDMETHOD(GetBox) (THIS_ LPD3DRMBOX lpBBox) PURE;
    STDMETHOD(SetQuality) (THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(GetQuality) (THIS_ LPD3DRMRENDERQUALITY lpdwquality) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow

DECLARE_INTERFACE_(IDirect3DRMShadow, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMVISUAL visual, LPDIRECT3DRMLIGHT light,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow2

DECLARE_INTERFACE_(IDirect3DRMShadow2, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (   THIS_ LPUNKNOWN pUNK, LPDIRECT3DRMLIGHT light,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;

    /*
     * IDirect3DRMShadow2 methods
     */
    STDMETHOD(GetVisual)(THIS_ LPDIRECT3DRMVISUAL *) PURE;
    STDMETHOD(SetVisual)(THIS_ LPUNKNOWN pUNK, DWORD) PURE;
    STDMETHOD(GetLight)(THIS_ LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(SetLight)(THIS_ LPDIRECT3DRMLIGHT, DWORD) PURE;
    STDMETHOD(GetPlane)(THIS_ LPD3DVALUE px, LPD3DVALUE py, LPD3DVALUE pz,
                        LPD3DVALUE nx, LPD3DVALUE ny, LPD3DVALUE nz) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE px, D3DVALUE py, D3DVALUE pz,
                        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz, DWORD) PURE;
    STDMETHOD(GetOptions)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetOptions)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace

DECLARE_INTERFACE_(IDirect3DRMFace, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace2

DECLARE_INTERFACE_(IDirect3DRMFace2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder2

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder2, IDirect3DRMMeshBuilder)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;

    /*
     * IDirect3DRMMeshBuilder2 methods
     */
    STDMETHOD(GenerateNormals2)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder3

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder3 methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3, DWORD dwFlags) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetGeometry)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;
    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;
    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(GetVertex)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(GetNormal)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(DeleteVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(Empty)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(AddFacesIndexed)(THIS_ DWORD dwFlags, DWORD *lpdwvIndices, DWORD *dwIndexFirst, DWORD *dwCount) PURE;
    STDMETHOD(CreateSubMesh)(THIS_ LPUNKNOWN *) PURE;
    STDMETHOD(GetParentMesh)(THIS_ DWORD, LPUNKNOWN *) PURE;
    STDMETHOD(GetSubMeshes)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(DeleteSubMesh)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(Enable)(THIS_ DWORD) PURE;
    STDMETHOD(GetEnable)(THIS_ DWORD *) PURE;
    STDMETHOD(AddTriangles)(THIS_ DWORD dwFlags, DWORD dwFormat,
                            DWORD dwVertexCount, LPVOID lpvData) PURE;
    STDMETHOD(SetVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetVertices)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD(SetNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetNormals)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD_(int, GetNormalCount)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLight

DECLARE_INTERFACE_(IDirect3DRMLight, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMLight methods
     */
    STDMETHOD(SetType)(THIS_ D3DRMLIGHTTYPE) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetRange)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUmbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetPenumbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetConstantAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetLinearAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetQuadraticAttenuation)(THIS_ D3DVALUE) PURE;

    STDMETHOD_(D3DVALUE, GetRange)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetUmbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetPenumbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetConstantAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetLinearAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetQuadraticAttenuation)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD_(D3DRMLIGHTTYPE, GetType)(THIS) PURE;

    STDMETHOD(SetEnableFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(GetEnableFrame)(THIS_ LPDIRECT3DRMFRAME*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture

DECLARE_INTERFACE_(IDirect3DRMTexture, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture2

DECLARE_INTERFACE_(IDirect3DRMTexture2, IDirect3DRMTexture)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;

    /*
     * IDirect3DRMTexture2 methods
     */
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture3

DECLARE_INTERFACE_(IDirect3DRMTexture3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture3 methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ DWORD dwFlags, DWORD dwcRects, LPRECT pRects) PURE;
    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
    STDMETHOD(GetSurface)(THIS_ DWORD dwFlags, LPDIRECTDRAWSURFACE* lplpDDS) PURE;
    STDMETHOD(SetCacheOptions)(THIS_ LONG lImportance, DWORD dwFlags) PURE;
    STDMETHOD(GetCacheOptions)(THIS_ LPLONG lplImportance, LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetDownsampleCallback)(THIS_ D3DRMDOWNSAMPLECALLBACK pCallback, LPVOID pArg) PURE;
    STDMETHOD(SetValidationCallback)(THIS_ D3DRMVALIDATIONCALLBACK pCallback, LPVOID pArg) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMWrap

DECLARE_INTERFACE_(IDirect3DRMWrap, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWrap methods
     */
    STDMETHOD(Init)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME ref,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv
    ) PURE;
    STDMETHOD(Apply)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(ApplyRelative)(THIS_ LPDIRECT3DRMFRAME frame, LPDIRECT3DRMOBJECT) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial

DECLARE_INTERFACE_(IDirect3DRMMaterial, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;

    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial2

DECLARE_INTERFACE_(IDirect3DRMMaterial2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial2 methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetAmbient)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(SetAmbient)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation

DECLARE_INTERFACE_(IDirect3DRMAnimation, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation2

DECLARE_INTERFACE_(IDirect3DRMAnimation2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation2 methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME3 frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
    STDMETHOD(GetFrame)(THIS_ LPDIRECT3DRMFRAME3 *lpD3DFrame) PURE;
    STDMETHOD(DeleteKeyByID)(THIS_ DWORD dwID) PURE;
    STDMETHOD(AddKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(ModifyKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(GetKeys)(THIS_ D3DVALUE dvTimeMin,
                       D3DVALUE dvTimeMax, LPDWORD lpdwNumKeys,
                       LPD3DRMANIMATIONKEY lpKey);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet

DECLARE_INTERFACE_(IDirect3DRMAnimationSet, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet2

DECLARE_INTERFACE_(IDirect3DRMAnimationSet2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet2 methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME3 parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(GetAnimations)(THIS_ LPDIRECT3DRMANIMATIONARRAY *) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMUserVisual

DECLARE_INTERFACE_(IDirect3DRMUserVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMUserVisual methods
     */
    STDMETHOD(Init)(THIS_ D3DRMUSERVISUALCALLBACK fn, void *arg) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMArray

DECLARE_INTERFACE_(IDirect3DRMArray, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    /* No GetElement method as it would get overloaded
     * in derived classes, and overloading is
     * a no-no in COM
     */
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObjectArray

DECLARE_INTERFACE_(IDirect3DRMObjectArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMOBJECT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDeviceArray

DECLARE_INTERFACE_(IDirect3DRMDeviceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrameArray

DECLARE_INTERFACE_(IDirect3DRMFrameArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFRAME *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewportArray

DECLARE_INTERFACE_(IDirect3DRMViewportArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisualArray

DECLARE_INTERFACE_(IDirect3DRMVisualArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationArray

DECLARE_INTERFACE_(IDirect3DRMAnimationArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMANIMATION2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPickedArray

DECLARE_INTERFACE_(IDirect3DRMPickedArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLightArray

DECLARE_INTERFACE_(IDirect3DRMLightArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMLIGHT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFaceArray

DECLARE_INTERFACE_(IDirect3DRMFaceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFACE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPicked2Array

DECLARE_INTERFACE_(IDirect3DRMPicked2Array, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC2) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMInterpolator

DECLARE_INTERFACE_(IDirect3DRMInterpolator, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMInterpolator methods
     */
    STDMETHOD(AttachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(GetAttachedObjects)(THIS_ LPDIRECT3DRMOBJECTARRAY *) PURE;
    STDMETHOD(DetachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(SetIndex)(THIS_ D3DVALUE) PURE;
    STDMETHOD_(D3DVALUE, GetIndex)(THIS) PURE;
    STDMETHOD(Interpolate)(THIS_ D3DVALUE, LPDIRECT3DRMOBJECT, D3DRMINTERPOLATIONOPTIONS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMClippedVisual

DECLARE_INTERFACE_(IDirect3DRMClippedVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMClippedVisual methods
     */
    STDMETHOD(Init) (THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(AddPlane) (THIS_ LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD, LPDWORD) PURE;
    STDMETHOD(DeletePlane)(THIS_ DWORD, DWORD) PURE;
    STDMETHOD(GetPlaneIDs)(THIS_ LPDWORD, LPDWORD, DWORD) PURE;
    STDMETHOD(GetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
    STDMETHOD(SetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
};

#ifdef __cplusplus
};
#endif
#endif /* _D3DRMOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\d3dtypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dtypes.h
 *  Content:    Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3DTYPES_H_
#define _D3DTYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

#if (DIRECT3D_VERSION >= 0x0800)
#pragma message("should not include d3dtypes.h when compiling for DX8 or newer interfaces")
#endif

#include <windows.h>

#include <float.h>
#include "ddraw.h"

#pragma warning(disable:4201) // anonymous unions warning
#if defined(_X86_) || defined(_IA64_)
#pragma pack(4)
#endif


/* D3DVALUE is the fundamental Direct3D fractional data type */

#define D3DVALP(val, prec) ((float)(val))
#define D3DVAL(val) ((float)(val))

#ifndef DX_SHARED_DEFINES

/*
 * This definition is shared with other DirectX components whose header files
 * might already have defined it. Therefore, we don't define this type if
 * someone else already has (as indicated by the definition of
 * DX_SHARED_DEFINES). We don't set DX_SHARED_DEFINES here as there are
 * other types in this header that are also shared. The last of these
 * shared defines in this file will set DX_SHARED_DEFINES.
 */
typedef float D3DVALUE, *LPD3DVALUE;

#endif /* DX_SHARED_DEFINES */

#define D3DDivide(a, b)    (float)((double) (a) / (double) (b))
#define D3DMultiply(a, b)    ((a) * (b))

typedef LONG D3DFIXED;

#ifndef RGB_MAKE
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index           |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GETALPHA(ci)    ((ci) >> 24)
#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
#define CI_GETFRACTION(ci) ((ci) & 0xff)
#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
 * The float values must be in the range 0..1
 */
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))

#endif

/*
 * Flags for Enumerate functions
 */

/*
 * Stop the enumeration
 */
#define D3DENUMRET_CANCEL                        DDENUMRET_CANCEL

/*
 * Continue the enumeration
 */
#define D3DENUMRET_OK                            DDENUMRET_OK

typedef HRESULT (CALLBACK* LPD3DVALIDATECALLBACK)(LPVOID lpUserArg, DWORD dwOffset);
typedef HRESULT (CALLBACK* LPD3DENUMTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC lpDdsd, LPVOID lpContext);
typedef HRESULT (CALLBACK* LPD3DENUMPIXELFORMATSCALLBACK)(LPDDPIXELFORMAT lpDDPixFmt, LPVOID lpContext);

#ifndef DX_SHARED_DEFINES

/*
 * This definition is shared with other DirectX components whose header files
 * might already have defined it. Therefore, we don't define this type if
 * someone else already has (as indicated by the definition of
 * DX_SHARED_DEFINES). We don't set DX_SHARED_DEFINES here as there are
 * other types in this header that are also shared. The last of these
 * shared defines in this file will set DX_SHARED_DEFINES.
 */
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif
typedef DWORD *LPD3DCOLOR;

#endif /* DX_SHARED_DEFINES */

typedef DWORD D3DMATERIALHANDLE, *LPD3DMATERIALHANDLE;
typedef DWORD D3DTEXTUREHANDLE, *LPD3DTEXTUREHANDLE;
typedef DWORD D3DMATRIXHANDLE, *LPD3DMATRIXHANDLE;

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    union {
    D3DVALUE r;
    D3DVALUE dvR;
    };
    union {
    D3DVALUE g;
    D3DVALUE dvG;
    };
    union {
    D3DVALUE b;
    D3DVALUE dvB;
    };
    union {
    D3DVALUE a;
    D3DVALUE dvA;
    };
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif
typedef struct _D3DCOLORVALUE *LPD3DCOLORVALUE;

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    union {
    LONG x1;
    LONG lX1;
    };
    union {
    LONG y1;
    LONG lY1;
    };
    union {
    LONG x2;
    LONG lX2;
    };
    union {
    LONG y2;
    LONG lY2;
    };
} D3DRECT;
#define D3DRECT_DEFINED
#endif
typedef struct _D3DRECT *LPD3DRECT;

#ifndef DX_SHARED_DEFINES

/*
 * This definition is shared with other DirectX components whose header files
 * might already have defined it. Therefore, we don't define this type if
 * someone else already has (as indicated by the definition of
 * DX_SHARED_DEFINES).
 */

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    union {
    D3DVALUE x;
    D3DVALUE dvX;
    };
    union {
    D3DVALUE y;
    D3DVALUE dvY;
    };
    union {
    D3DVALUE z;
    D3DVALUE dvZ;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)

public:

    // =====================================
    // Constructors
    // =====================================

    _D3DVECTOR() { }
    _D3DVECTOR(D3DVALUE f);
    _D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z);
    _D3DVECTOR(const D3DVALUE f[3]);

    // =====================================
    // Access grants
    // =====================================

    const D3DVALUE&operator[](int i) const;
    D3DVALUE&operator[](int i);

    // =====================================
    // Assignment operators
    // =====================================

    _D3DVECTOR& operator += (const _D3DVECTOR& v);
    _D3DVECTOR& operator -= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (const _D3DVECTOR& v);
    _D3DVECTOR& operator /= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (D3DVALUE s);
    _D3DVECTOR& operator /= (D3DVALUE s);

    // =====================================
    // Unary operators
    // =====================================

    friend _D3DVECTOR operator + (const _D3DVECTOR& v);
    friend _D3DVECTOR operator - (const _D3DVECTOR& v);


    // =====================================
    // Binary operators
    // =====================================

    // Addition and subtraction
        friend _D3DVECTOR operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
    // Scalar multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v, D3DVALUE s);
        friend _D3DVECTOR operator * (D3DVALUE s, const _D3DVECTOR& v);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v, D3DVALUE s);
    // Memberwise multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Vector dominance
        friend int operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend int operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Bitwise equality
        friend int operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Length-related functions
        friend D3DVALUE SquareMagnitude (const _D3DVECTOR& v);
        friend D3DVALUE Magnitude (const _D3DVECTOR& v);

    // Returns vector with same direction and unit length
        friend _D3DVECTOR Normalize (const _D3DVECTOR& v);

    // Return min/max component of the input vector
        friend D3DVALUE Min (const _D3DVECTOR& v);
        friend D3DVALUE Max (const _D3DVECTOR& v);

    // Return memberwise min/max of input vectors
        friend _D3DVECTOR Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Dot and cross product
        friend D3DVALUE DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif
typedef struct _D3DVECTOR *LPD3DVECTOR;

/*
 * As this is the last of the shared defines to be defined we now set
 * D3D_SHARED_DEFINES to flag that fact that this header has defined these
 * types.
 */
#define DX_SHARED_DEFINES

#endif /* DX_SHARED_DEFINES */

/*
 * Vertex data types supported in an ExecuteBuffer.
 */

/*
 * Homogeneous vertices
 */

typedef struct _D3DHVERTEX {
    DWORD           dwFlags;        /* Homogeneous clipping flags */
    union {
    D3DVALUE    hx;
    D3DVALUE    dvHX;
    };
    union {
    D3DVALUE    hy;
    D3DVALUE    dvHY;
    };
    union {
    D3DVALUE    hz;
    D3DVALUE    dvHZ;
    };
} D3DHVERTEX, *LPD3DHVERTEX;

/*
 * Transformed/lit vertices
 */
typedef struct _D3DTLVERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;        /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    union {
    D3DVALUE    tu;             /* Texture coordinates */
    D3DVALUE    dvTU;
    };
    union {
    D3DVALUE    tv;
    D3DVALUE    dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DTLVERTEX() { }
    _D3DTLVERTEX(const D3DVECTOR& v, float _rhw,
                 D3DCOLOR _color, D3DCOLOR _specular,
                 float _tu, float _tv)
        { sx = v.x; sy = v.y; sz = v.z; rhw = _rhw;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTLVERTEX, *LPD3DTLVERTEX;

/*
 * Untransformed/lit vertices
 */
typedef struct _D3DLVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    DWORD            dwReserved;
    union {
    D3DCOLOR     color;         /* Vertex color */
    D3DCOLOR     dcColor;
    };
    union {
    D3DCOLOR     specular;      /* Specular component of vertex */
    D3DCOLOR     dcSpecular;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DLVERTEX() { }
    _D3DLVERTEX(const D3DVECTOR& v,
                D3DCOLOR _color, D3DCOLOR _specular,
                float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z; dwReserved = 0;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DLVERTEX, *LPD3DLVERTEX;

/*
 * Untransformed/unlit vertices
 */

typedef struct _D3DVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    union {
    D3DVALUE     nx;            /* Normal */
    D3DVALUE     dvNX;
    };
    union {
    D3DVALUE     ny;
    D3DVALUE     dvNY;
    };
    union {
    D3DVALUE     nz;
    D3DVALUE     dvNZ;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DVERTEX() { }
    _D3DVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z;
          nx = n.x; ny = n.y; nz = n.z;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DVERTEX, *LPD3DVERTEX;


/*
 * Matrix, viewport, and tranformation structures and definitions.
 */

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    union {
        struct {
#endif

#endif /* DIRECT3D_VERSION >= 0x0500 */
            D3DVALUE        _11, _12, _13, _14;
            D3DVALUE        _21, _22, _23, _24;
            D3DVALUE        _31, _32, _33, _34;
            D3DVALUE        _41, _42, _43, _44;

#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
        };
        D3DVALUE m[4][4];
    };
    _D3DMATRIX() { }
    _D3DMATRIX( D3DVALUE _m00, D3DVALUE _m01, D3DVALUE _m02, D3DVALUE _m03,
                D3DVALUE _m10, D3DVALUE _m11, D3DVALUE _m12, D3DVALUE _m13,
                D3DVALUE _m20, D3DVALUE _m21, D3DVALUE _m22, D3DVALUE _m23,
                D3DVALUE _m30, D3DVALUE _m31, D3DVALUE _m32, D3DVALUE _m33
        )
        {
                m[0][0] = _m00; m[0][1] = _m01; m[0][2] = _m02; m[0][3] = _m03;
                m[1][0] = _m10; m[1][1] = _m11; m[1][2] = _m12; m[1][3] = _m13;
                m[2][0] = _m20; m[2][1] = _m21; m[2][2] = _m22; m[2][3] = _m23;
                m[3][0] = _m30; m[3][1] = _m31; m[3][2] = _m32; m[3][3] = _m33;
        }

    D3DVALUE& operator()(int iRow, int iColumn) { return m[iRow][iColumn]; }
    const D3DVALUE& operator()(int iRow, int iColumn) const { return m[iRow][iColumn]; }
#if(DIRECT3D_VERSION >= 0x0600)
    friend _D3DMATRIX operator* (const _D3DMATRIX&, const _D3DMATRIX&);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif
typedef struct _D3DMATRIX *LPD3DMATRIX;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
#include "d3dvec.inl"
#endif

typedef struct _D3DVIEWPORT {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Dimensions */
    D3DVALUE    dvScaleX;   /* Scale homogeneous to screen */
    D3DVALUE    dvScaleY;   /* Scale homogeneous to screen */
    D3DVALUE    dvMaxX;     /* Min/max homogeneous x coord */
    D3DVALUE    dvMaxY;     /* Min/max homogeneous y coord */
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;     /* Min/max homogeneous z coord */
} D3DVIEWPORT, *LPD3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
typedef struct _D3DVIEWPORT2 {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Viewport Dimensions */
    D3DVALUE    dvClipX;        /* Top left of clip volume */
    D3DVALUE    dvClipY;
    D3DVALUE    dvClipWidth;    /* Clip Volume Dimensions */
    D3DVALUE    dvClipHeight;
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT2, *LPD3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DVIEWPORT7 {
    DWORD       dwX;
    DWORD       dwY;            /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;       /* Viewport Dimensions */
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT7, *LPD3DVIEWPORT7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Values for clip fields.
 */

#if(DIRECT3D_VERSION >= 0x0700)

// Max number of user clipping planes, supported in D3D.
#define D3DMAXUSERCLIPPLANES 32

// These bits could be ORed together to use with D3DRENDERSTATE_CLIPPLANEENABLE
//
#define D3DCLIPPLANE0 (1 << 0)
#define D3DCLIPPLANE1 (1 << 1)
#define D3DCLIPPLANE2 (1 << 2)
#define D3DCLIPPLANE3 (1 << 3)
#define D3DCLIPPLANE4 (1 << 4)
#define D3DCLIPPLANE5 (1 << 5)

#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DCLIP_LEFT                0x00000001L
#define D3DCLIP_RIGHT               0x00000002L
#define D3DCLIP_TOP             0x00000004L
#define D3DCLIP_BOTTOM              0x00000008L
#define D3DCLIP_FRONT               0x00000010L
#define D3DCLIP_BACK                0x00000020L
#define D3DCLIP_GEN0                0x00000040L
#define D3DCLIP_GEN1                0x00000080L
#define D3DCLIP_GEN2                0x00000100L
#define D3DCLIP_GEN3                0x00000200L
#define D3DCLIP_GEN4                0x00000400L
#define D3DCLIP_GEN5                0x00000800L

/*
 * Values for d3d status.
 */
#define D3DSTATUS_CLIPUNIONLEFT         D3DCLIP_LEFT
#define D3DSTATUS_CLIPUNIONRIGHT        D3DCLIP_RIGHT
#define D3DSTATUS_CLIPUNIONTOP          D3DCLIP_TOP
#define D3DSTATUS_CLIPUNIONBOTTOM       D3DCLIP_BOTTOM
#define D3DSTATUS_CLIPUNIONFRONT        D3DCLIP_FRONT
#define D3DSTATUS_CLIPUNIONBACK         D3DCLIP_BACK
#define D3DSTATUS_CLIPUNIONGEN0         D3DCLIP_GEN0
#define D3DSTATUS_CLIPUNIONGEN1         D3DCLIP_GEN1
#define D3DSTATUS_CLIPUNIONGEN2         D3DCLIP_GEN2
#define D3DSTATUS_CLIPUNIONGEN3         D3DCLIP_GEN3
#define D3DSTATUS_CLIPUNIONGEN4         D3DCLIP_GEN4
#define D3DSTATUS_CLIPUNIONGEN5         D3DCLIP_GEN5

#define D3DSTATUS_CLIPINTERSECTIONLEFT      0x00001000L
#define D3DSTATUS_CLIPINTERSECTIONRIGHT     0x00002000L
#define D3DSTATUS_CLIPINTERSECTIONTOP       0x00004000L
#define D3DSTATUS_CLIPINTERSECTIONBOTTOM    0x00008000L
#define D3DSTATUS_CLIPINTERSECTIONFRONT     0x00010000L
#define D3DSTATUS_CLIPINTERSECTIONBACK      0x00020000L
#define D3DSTATUS_CLIPINTERSECTIONGEN0      0x00040000L
#define D3DSTATUS_CLIPINTERSECTIONGEN1      0x00080000L
#define D3DSTATUS_CLIPINTERSECTIONGEN2      0x00100000L
#define D3DSTATUS_CLIPINTERSECTIONGEN3      0x00200000L
#define D3DSTATUS_CLIPINTERSECTIONGEN4      0x00400000L
#define D3DSTATUS_CLIPINTERSECTIONGEN5      0x00800000L
#define D3DSTATUS_ZNOTVISIBLE               0x01000000L
/* Do not use 0x80000000 for any status flags in future as it is reserved */

#define D3DSTATUS_CLIPUNIONALL  (       \
        D3DSTATUS_CLIPUNIONLEFT |   \
        D3DSTATUS_CLIPUNIONRIGHT    |   \
        D3DSTATUS_CLIPUNIONTOP  |   \
        D3DSTATUS_CLIPUNIONBOTTOM   |   \
        D3DSTATUS_CLIPUNIONFRONT    |   \
        D3DSTATUS_CLIPUNIONBACK |   \
        D3DSTATUS_CLIPUNIONGEN0 |   \
        D3DSTATUS_CLIPUNIONGEN1 |   \
        D3DSTATUS_CLIPUNIONGEN2 |   \
        D3DSTATUS_CLIPUNIONGEN3 |   \
        D3DSTATUS_CLIPUNIONGEN4 |   \
        D3DSTATUS_CLIPUNIONGEN5     \
        )

#define D3DSTATUS_CLIPINTERSECTIONALL   (       \
        D3DSTATUS_CLIPINTERSECTIONLEFT  |   \
        D3DSTATUS_CLIPINTERSECTIONRIGHT |   \
        D3DSTATUS_CLIPINTERSECTIONTOP   |   \
        D3DSTATUS_CLIPINTERSECTIONBOTTOM    |   \
        D3DSTATUS_CLIPINTERSECTIONFRONT |   \
        D3DSTATUS_CLIPINTERSECTIONBACK  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN0  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN1  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN2  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN3  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN4  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN5      \
        )

#define D3DSTATUS_DEFAULT   (           \
        D3DSTATUS_CLIPINTERSECTIONALL   |   \
        D3DSTATUS_ZNOTVISIBLE)


/*
 * Options for direct transform calls
 */
#define D3DTRANSFORM_CLIPPED       0x00000001l
#define D3DTRANSFORM_UNCLIPPED     0x00000002l

typedef struct _D3DTRANSFORMDATA {
    DWORD           dwSize;
    LPVOID      lpIn;           /* Input vertices */
    DWORD           dwInSize;       /* Stride of input vertices */
    LPVOID      lpOut;          /* Output vertices */
    DWORD           dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX    lpHOut;         /* Output homogeneous vertices */
    DWORD           dwClip;         /* Clipping hint */
    DWORD           dwClipIntersection;
    DWORD           dwClipUnion;    /* Union of all clip flags */
    D3DRECT         drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATA, *LPD3DTRANSFORMDATA;

/*
 * Structure defining position and direction properties for lighting.
 */
typedef struct _D3DLIGHTINGELEMENT {
    D3DVECTOR dvPosition;           /* Lightable point in model space */
    D3DVECTOR dvNormal;             /* Normalised unit vector */
} D3DLIGHTINGELEMENT, *LPD3DLIGHTINGELEMENT;

/*
 * Structure defining material properties for lighting.
 */
typedef struct _D3DMATERIAL {
    DWORD           dwSize;
    union {
    D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   dcvDiffuse;
    };
    union {
    D3DCOLORVALUE   ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   dcvAmbient;
    };
    union {
    D3DCOLORVALUE   specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   dcvSpecular;
    };
    union {
    D3DCOLORVALUE   emissive;       /* Emissive color RGB */
    D3DCOLORVALUE   dcvEmissive;
    };
    union {
    D3DVALUE        power;          /* Sharpness if specular highlight */
    D3DVALUE        dvPower;
    };
    D3DTEXTUREHANDLE    hTexture;       /* Handle to texture map */
    DWORD           dwRampSize;
} D3DMATERIAL, *LPD3DMATERIAL;

#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DMATERIAL7 {
    union {
    D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   dcvDiffuse;
    };
    union {
    D3DCOLORVALUE   ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   dcvAmbient;
    };
    union {
    D3DCOLORVALUE   specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   dcvSpecular;
    };
    union {
    D3DCOLORVALUE   emissive;       /* Emissive color RGB */
    D3DCOLORVALUE   dcvEmissive;
    };
    union {
    D3DVALUE        power;          /* Sharpness if specular highlight */
    D3DVALUE        dvPower;
    };
} D3DMATERIAL7, *LPD3DMATERIAL7;

#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
// Note: The following light type (D3DLIGHT_PARALLELPOINT)
// is no longer supported from D3D for DX7 onwards.
    D3DLIGHT_PARALLELPOINT  = 4,
#if(DIRECT3D_VERSION < 0x0500) // For backward compatible headers
    D3DLIGHT_GLSPOT         = 5,
#endif
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

#else
typedef enum _D3DLIGHTTYPE D3DLIGHTTYPE;
#define D3DLIGHT_PARALLELPOINT  (D3DLIGHTTYPE)4
#define D3DLIGHT_GLSPOT         (D3DLIGHTTYPE)5

#endif //(DIRECT3D_VERSION < 0x0800)

/*
 * Structure defining a light source and its properties.
 */
typedef struct _D3DLIGHT {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvColor;           /* Color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT, *LPD3DLIGHT;

#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DLIGHT7 {
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvDiffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   dcvSpecular;        /* Specular color of light */
    D3DCOLORVALUE   dcvAmbient;         /* Ambient color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT7, *LPD3DLIGHT7;

#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Structure defining a light source and its properties.
 */

/* flags bits */
#define D3DLIGHT_ACTIVE         0x00000001
#define D3DLIGHT_NO_SPECULAR    0x00000002
#define D3DLIGHT_ALL (D3DLIGHT_ACTIVE | D3DLIGHT_NO_SPECULAR)

/* maximum valid light range */
#define D3DLIGHT_RANGE_MAX      ((float)sqrt(FLT_MAX))

typedef struct _D3DLIGHT2 {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;        /* Type of light source */
    D3DCOLORVALUE   dcvColor;       /* Color of light */
    D3DVECTOR       dvPosition;     /* Position in world space */
    D3DVECTOR       dvDirection;    /* Direction in world space */
    D3DVALUE        dvRange;        /* Cutoff range */
    D3DVALUE        dvFalloff;      /* Falloff */
    D3DVALUE        dvAttenuation0; /* Constant attenuation */
    D3DVALUE        dvAttenuation1; /* Linear attenuation */
    D3DVALUE        dvAttenuation2; /* Quadratic attenuation */
    D3DVALUE        dvTheta;        /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;          /* Outer angle of spotlight cone */
    DWORD           dwFlags;
} D3DLIGHT2, *LPD3DLIGHT2;

#endif /* DIRECT3D_VERSION >= 0x0500 */
typedef struct _D3DLIGHTDATA {
    DWORD                dwSize;
    LPD3DLIGHTINGELEMENT lpIn;      /* Input positions and normals */
    DWORD                dwInSize;  /* Stride of input elements */
    LPD3DTLVERTEX        lpOut;     /* Output colors */
    DWORD                dwOutSize; /* Stride of output colors */
} D3DLIGHTDATA, *LPD3DLIGHTDATA;

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Before DX5, these values were in an enum called
 * D3DCOLORMODEL. This was not correct, since they are
 * bit flags. A driver can surface either or both flags
 * in the dcmColorModel member of D3DDEVICEDESC.
 */
#define D3DCOLOR_MONO   1
#define D3DCOLOR_RGB    2

typedef DWORD D3DCOLORMODEL;
#endif /* DIRECT3D_VERSION >= 0x0500 */

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */
#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Execute buffers are allocated via Direct3D.  These buffers may then
 * be filled by the application with instructions to execute along with
 * vertex data.
 */

/*
 * Supported op codes for execute instructions.
 */
typedef enum _D3DOPCODE {
    D3DOP_POINT                 = 1,
    D3DOP_LINE                  = 2,
    D3DOP_TRIANGLE      = 3,
    D3DOP_MATRIXLOAD        = 4,
    D3DOP_MATRIXMULTIPLY    = 5,
    D3DOP_STATETRANSFORM        = 6,
    D3DOP_STATELIGHT        = 7,
    D3DOP_STATERENDER       = 8,
    D3DOP_PROCESSVERTICES       = 9,
    D3DOP_TEXTURELOAD       = 10,
    D3DOP_EXIT                  = 11,
    D3DOP_BRANCHFORWARD     