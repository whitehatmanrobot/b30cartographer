4+(i)*16) /* -W-4A */
#define NV_097_SET_TEXGEN_T__SIZE_1                                                4 /*       */
#define NV_097_SET_TEXGEN_T_V                                                   31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_T_V_DISABLE                                     0x00000000 /* -W--V */
#define NV_097_SET_TEXGEN_T_V_NORMAL_MAP                                  0x00008511 /* -W--V */
#define NV_097_SET_TEXGEN_T_V_REFLECTION_MAP                              0x00008512 /* -W--V */
#define NV_097_SET_TEXGEN_T_V_EYE_LINEAR                                  0x00002400 /* -W--V */
#define NV_097_SET_TEXGEN_T_V_OBJECT_LINEAR                               0x00002401 /* -W--V */
#define NV_097_SET_TEXGEN_T_V_SPHERE_MAP                                  0x00002402 /* -W--V */
#define NV_097_SET_TEXGEN_R(i)                                   (0x005c03c8+(i)*16) /* -W-4A */
#define NV_097_SET_TEXGEN_R__SIZE_1                                                4 /*       */
#define NV_097_SET_TEXGEN_R_V                                                   31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_R_V_DISABLE                                     0x00000000 /* -W--V */
#define NV_097_SET_TEXGEN_R_V_NORMAL_MAP                                  0x00008511 /* -W--V */
#define NV_097_SET_TEXGEN_R_V_REFLECTION_MAP                              0x00008512 /* -W--V */
#define NV_097_SET_TEXGEN_R_V_EYE_LINEAR                                  0x00002400 /* -W--V */
#define NV_097_SET_TEXGEN_R_V_OBJECT_LINEAR                               0x00002401 /* -W--V */
#define NV_097_SET_TEXGEN_Q(i)                                   (0x005c03cc+(i)*16) /* -W-4A */
#define NV_097_SET_TEXGEN_Q__SIZE_1                                                4 /*       */
#define NV_097_SET_TEXGEN_Q_V                                                   31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_Q_V_DISABLE                                     0x00000000 /* -W--V */
#define NV_097_SET_TEXGEN_Q_V_EYE_LINEAR                                  0x00002400 /* -W--V */
#define NV_097_SET_TEXGEN_Q_V_OBJECT_LINEAR                               0x00002401 /* -W--V */
#define NV_097_SET_TEXGEN_VIEW_MODEL                                      0x005c09cc /* -W-4R */
#define NV_097_SET_TEXGEN_VIEW_MODEL_V                                          31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_VIEW_MODEL_V_LOCAL_VIEWER                       0x00000000 /* -W--V */
#define NV_097_SET_TEXGEN_VIEW_MODEL_V_INFINITE_VIEWER                    0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_MATRIX_ENABLE(i)                       (0x005c0420+(i)*4) /* -W-4A */
#define NV_097_SET_TEXTURE_MATRIX_ENABLE__SIZE_1                                   4 /*       */
#define NV_097_SET_TEXTURE_MATRIX_ENABLE_V                                      31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE                          0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE                           0x00000001 /* -W--V */
#define NV_097_SET_POINT_SIZE                                             0x005c043c /* -W-4R */
#define NV_097_SET_POINT_SIZE_V                                                 31:0 /* -WXUF */
#define NV_097_SET_SWATH_WIDTH                                            0x005c09f8 /* -W-4R */
#define NV_097_SET_SWATH_WIDTH_V                                                31:0 /* -WXUF */
#define NV_097_SET_SWATH_WIDTH_V_8                                        0x00000000 /* -W--V */
#define NV_097_SET_SWATH_WIDTH_V_16                                       0x00000001 /* -W--V */
#define NV_097_SET_SWATH_WIDTH_V_32                                       0x00000002 /* -W--V */
#define NV_097_SET_SWATH_WIDTH_V_64                                       0x00000003 /* -W--V */
#define NV_097_SET_SWATH_WIDTH_V_128                                      0x00000004 /* -W--V */
#define NV_097_SET_SWATH_WIDTH_V_OFF                                      0x0000000F /* -W--V */
#define NV_097_SET_FLAT_SHADE_OP                                          0x005c09fc /* -W-4R */
#define NV_097_SET_FLAT_SHADE_OP_V                                              31:0 /* -WXUF */
#define NV_097_SET_FLAT_SHADE_OP_V_LAST_VTX                               0x00000000 /* -W--V */
#define NV_097_SET_FLAT_SHADE_OP_V_FIRST_VTX                              0x00000001 /* -W--V */
#define NV_097_SET_PROJECTION_MATRIX(i)                           (0x005c0440+(i)*4) /* -W-4A */
#define NV_097_SET_PROJECTION_MATRIX__SIZE_1                                      16 /*       */
#define NV_097_SET_PROJECTION_MATRIX_V                                          31:0 /* -WXUF */
#define NV_097_SET_MODEL_VIEW_MATRIX0(i)                          (0x005c0480+(i)*4) /* -W-4A */
#define NV_097_SET_MODEL_VIEW_MATRIX0__SIZE_1                                     16 /*       */
#define NV_097_SET_MODEL_VIEW_MATRIX0_V                                         31:0 /* -WXUF */
#define NV_097_SET_MODEL_VIEW_MATRIX1(i)                          (0x005c04c0+(i)*4) /* -W-4A */
#define NV_097_SET_MODEL_VIEW_MATRIX1__SIZE_1                                     16 /*       */
#define NV_097_SET_MODEL_VIEW_MATRIX1_V                                         31:0 /* -WXUF */
#define NV_097_SET_MODEL_VIEW_MATRIX2(i)                          (0x005c0500+(i)*4) /* -W-4A */
#define NV_097_SET_MODEL_VIEW_MATRIX2__SIZE_1                                     16 /*       */
#define NV_097_SET_MODEL_VIEW_MATRIX2_V                                         31:0 /* -WXUF */
#define NV_097_SET_MODEL_VIEW_MATRIX3(i)                          (0x005c0540+(i)*4) /* -W-4A */
#define NV_097_SET_MODEL_VIEW_MATRIX3__SIZE_1                                     16 /*       */
#define NV_097_SET_MODEL_VIEW_MATRIX3_V                                         31:0 /* -WXUF */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                  (0x005c0580+(i)*4) /* -W-4A */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX0__SIZE_1                             16 /*       */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                 31:0 /* -WXUF */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                  (0x005c05c0+(i)*4) /* -W-4A */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX1__SIZE_1                             16 /*       */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                 31:0 /* -WXUF */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX2(i)                  (0x005c0600+(i)*4) /* -W-4A */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX2__SIZE_1                             16 /*       */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX2_V                                 31:0 /* -WXUF */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX3(i)                  (0x005c0640+(i)*4) /* -W-4A */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX3__SIZE_1                             16 /*       */
#define NV_097_SET_INVERSE_MODEL_VIEW_MATRIX3_V                                 31:0 /* -WXUF */
#define NV_097_SET_COMPOSITE_MATRIX(i)                            (0x005c0680+(i)*4) /* -W-4A */
#define NV_097_SET_COMPOSITE_MATRIX__SIZE_1                                       16 /*       */
#define NV_097_SET_COMPOSITE_MATRIX_V                                           31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_MATRIX0(i)                             (0x005c06c0+(i)*4) /* -W-4A */
#define NV_097_SET_TEXTURE_MATRIX0__SIZE_1                                        16 /*       */
#define NV_097_SET_TEXTURE_MATRIX0_V                                            31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_MATRIX1(i)                             (0x005c0700+(i)*4) /* -W-4A */
#define NV_097_SET_TEXTURE_MATRIX1__SIZE_1                                        16 /*       */
#define NV_097_SET_TEXTURE_MATRIX1_V                                            31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_MATRIX2(i)                             (0x005c0740+(i)*4) /* -W-4A */
#define NV_097_SET_TEXTURE_MATRIX2__SIZE_1                                        16 /*       */
#define NV_097_SET_TEXTURE_MATRIX2_V                                            31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_MATRIX3(i)                             (0x005c0780+(i)*4) /* -W-4A */
#define NV_097_SET_TEXTURE_MATRIX3__SIZE_1                                        16 /*       */
#define NV_097_SET_TEXTURE_MATRIX3_V                                            31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_PLANE_S(i,j)                     (0x005c0840+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_TEXGEN_PLANE_S__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_S__SIZE_2                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_S_V                                             31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_PLANE_T(i,j)                     (0x005c0850+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_TEXGEN_PLANE_T__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_T__SIZE_2                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_T_V                                             31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_PLANE_R(i,j)                     (0x005c0860+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_TEXGEN_PLANE_R__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_R__SIZE_2                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_R_V                                             31:0 /* -WXUF */
#define NV_097_SET_TEXGEN_PLANE_Q(i,j)                     (0x005c0870+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_TEXGEN_PLANE_Q__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_Q__SIZE_2                                          4 /*       */
#define NV_097_SET_TEXGEN_PLANE_Q_V                                             31:0 /* -WXUF */
#define NV_097_SET_FOG_PARAMS(i)                                  (0x005c09c0+(i)*4) /* -W-4A */
#define NV_097_SET_FOG_PARAMS__SIZE_1                                              3 /*       */
#define NV_097_SET_FOG_PARAMS_V                                                 31:0 /* -WXUF */
#define NV_097_SET_FOG_PLANE(i)                                   (0x005c09d0+(i)*4) /* -W-4A */
#define NV_097_SET_FOG_PLANE__SIZE_1                                               4 /*       */
#define NV_097_SET_FOG_PLANE_V                                                  31:0 /* -WXUF */
#define NV_097_SET_SPECULAR_PARAMS(i)                             (0x005c09e0+(i)*4) /* -W-4A */
#define NV_097_SET_SPECULAR_PARAMS__SIZE_1                                         6 /*       */
#define NV_097_SET_SPECULAR_PARAMS_V                                            31:0 /* -WXUF */
#define NV_097_SET_BACK_SPECULAR_PARAMS(i)                        (0x005c1e28+(i)*4) /* -W-4A */
#define NV_097_SET_BACK_SPECULAR_PARAMS__SIZE_1                                    6 /*       */
#define NV_097_SET_BACK_SPECULAR_PARAMS_V                                       31:0 /* -WXUF */
#define NV_097_SET_SCENE_AMBIENT_COLOR(i)                         (0x005c0a10+(i)*4) /* -W-4A */
#define NV_097_SET_SCENE_AMBIENT_COLOR__SIZE_1                                     3 /*       */
#define NV_097_SET_SCENE_AMBIENT_COLOR_V                                        31:0 /* -WXUF */
#define NV_097_SET_VIEWPORT_SCALE(i)                              (0x005c0af0+(i)*4) /* -W-4A */
#define NV_097_SET_VIEWPORT_SCALE__SIZE_1                                          4 /*       */
#define NV_097_SET_VIEWPORT_SCALE_V                                             31:0 /* -WXUF */
#define NV_097_SET_VIEWPORT_OFFSET(i)                             (0x005c0a20+(i)*4) /* -W-4A */
#define NV_097_SET_VIEWPORT_OFFSET__SIZE_1                                         4 /*       */
#define NV_097_SET_VIEWPORT_OFFSET_V                                            31:0 /* -WXUF */
#define NV_097_SET_POINT_PARAMS(i)                                (0x005c0a30+(i)*4) /* -W-4A */
#define NV_097_SET_POINT_PARAMS__SIZE_1                                            8 /*       */
#define NV_097_SET_POINT_PARAMS_V                                               31:0 /* -WXUF */
#define NV_097_SET_EYE_POSITION(i)                                (0x005c0a50+(i)*4) /* -W-4A */
#define NV_097_SET_EYE_POSITION__SIZE_1                                            4 /*       */
#define NV_097_SET_EYE_POSITION_V                                               31:0 /* -WXUF */
#define NV_097_SET_BACK_LIGHT_AMBIENT_COLOR(i,j)           (0x005c0c00+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_BACK_LIGHT_AMBIENT_COLOR__SIZE_1                                8 /*       */
#define NV_097_SET_BACK_LIGHT_AMBIENT_COLOR__SIZE_2                                3 /*       */
#define NV_097_SET_BACK_LIGHT_AMBIENT_COLOR_V                                   31:0 /* -WXUF */
#define NV_097_SET_BACK_LIGHT_DIFFUSE_COLOR(i,j)           (0x005c0c0c+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_BACK_LIGHT_DIFFUSE_COLOR__SIZE_1                                8 /*       */
#define NV_097_SET_BACK_LIGHT_DIFFUSE_COLOR__SIZE_2                                3 /*       */
#define NV_097_SET_BACK_LIGHT_DIFFUSE_COLOR_V                                   31:0 /* -WXUF */
#define NV_097_SET_BACK_LIGHT_SPECULAR_COLOR(i,j)          (0x005c0c18+(i)*64+(j)*4) /* -W-4A */
#define NV_097_SET_BACK_LIGHT_SPECULAR_COLOR__SIZE_1                               8 /*       */
#define NV_097_SET_BACK_LIGHT_SPECULAR_COLOR__SIZE_2                               3 /*       */
#define NV_097_SET_BACK_LIGHT_SPECULAR_COLOR_V                                  31:0 /* -WXUF */
#define NV_097_SET_LIGHT_AMBIENT_COLOR(i,j)               (0x005c1000+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_AMBIENT_COLOR__SIZE_1                                     8 /*       */
#define NV_097_SET_LIGHT_AMBIENT_COLOR__SIZE_2                                     3 /*       */
#define NV_097_SET_LIGHT_AMBIENT_COLOR_V                                        31:0 /* -WXUF */
#define NV_097_SET_LIGHT_DIFFUSE_COLOR(i,j)               (0x005c100c+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_DIFFUSE_COLOR__SIZE_1                                     8 /*       */
#define NV_097_SET_LIGHT_DIFFUSE_COLOR__SIZE_2                                     3 /*       */
#define NV_097_SET_LIGHT_DIFFUSE_COLOR_V                                        31:0 /* -WXUF */
#define NV_097_SET_LIGHT_SPECULAR_COLOR(i,j)              (0x005c1018+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_SPECULAR_COLOR__SIZE_1                                    8 /*       */
#define NV_097_SET_LIGHT_SPECULAR_COLOR__SIZE_2                                    3 /*       */
#define NV_097_SET_LIGHT_SPECULAR_COLOR_V                                       31:0 /* -WXUF */
#define NV_097_SET_LIGHT_LOCAL_RANGE(i)                         (0x005c1024+(i)*128) /* -W-4A */
#define NV_097_SET_LIGHT_LOCAL_RANGE__SIZE_1                                       8 /*       */
#define NV_097_SET_LIGHT_LOCAL_RANGE_V                                          31:0 /* -WXUF */
#define NV_097_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)        (0x005c1028+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_INFINITE_HALF_VECTOR__SIZE_1                              8 /*       */
#define NV_097_SET_LIGHT_INFINITE_HALF_VECTOR__SIZE_2                              3 /*       */
#define NV_097_SET_LIGHT_INFINITE_HALF_VECTOR_V                                 31:0 /* -WXUF */
#define NV_097_SET_LIGHT_INFINITE_DIRECTION(i,j)          (0x005c1034+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_INFINITE_DIRECTION__SIZE_1                                8 /*       */
#define NV_097_SET_LIGHT_INFINITE_DIRECTION__SIZE_2                                3 /*       */
#define NV_097_SET_LIGHT_INFINITE_DIRECTION_V                                   31:0 /* -WXUF */
#define NV_097_SET_LIGHT_SPOT_FALLOFF(i,j)                (0x005c1040+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_SPOT_FALLOFF__SIZE_1                                      8 /*       */
#define NV_097_SET_LIGHT_SPOT_FALLOFF__SIZE_2                                      3 /*       */
#define NV_097_SET_LIGHT_SPOT_FALLOFF_V                                         31:0 /* -WXUF */
#define NV_097_SET_LIGHT_SPOT_DIRECTION(i,j)              (0x005c104c+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_SPOT_DIRECTION__SIZE_1                                    8 /*       */
#define NV_097_SET_LIGHT_SPOT_DIRECTION__SIZE_2                                    4 /*       */
#define NV_097_SET_LIGHT_SPOT_DIRECTION_V                                       31:0 /* -WXUF */
#define NV_097_SET_LIGHT_LOCAL_POSITION(i,j)              (0x005c105c+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_LOCAL_POSITION__SIZE_1                                    8 /*       */
#define NV_097_SET_LIGHT_LOCAL_POSITION__SIZE_2                                    3 /*       */
#define NV_097_SET_LIGHT_LOCAL_POSITION_V                                       31:0 /* -WXUF */
#define NV_097_SET_LIGHT_LOCAL_ATTENUATION(i,j)           (0x005c1068+(i)*128+(j)*4) /* -W-4A */
#define NV_097_SET_LIGHT_LOCAL_ATTENUATION__SIZE_1                                 8 /*       */
#define NV_097_SET_LIGHT_LOCAL_ATTENUATION__SIZE_2                                 3 /*       */
#define NV_097_SET_LIGHT_LOCAL_ATTENUATION_V                                    31:0 /* -WXUF */
#define NV_097_SET_VERTEX3F(i)                                    (0x005c1500+(i)*4) /* -W-4A */
#define NV_097_SET_VERTEX3F__SIZE_1                                                3 /*       */
#define NV_097_SET_VERTEX3F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_VERTEX4F(i)                                    (0x005c1518+(i)*4) /* -W-4A */
#define NV_097_SET_VERTEX4F__SIZE_1                                                4 /*       */
#define NV_097_SET_VERTEX4F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_VERTEX4S(i)                                    (0x005c1528+(i)*4) /* -W-4A */
#define NV_097_SET_VERTEX4S__SIZE_1                                                2 /*       */
#define NV_097_SET_VERTEX4S_V                                                   31:0 /* -WXUF */
#define NV_097_SET_NORMAL3F(i)                                    (0x005c1530+(i)*4) /* -W-4A */
#define NV_097_SET_NORMAL3F__SIZE_1                                                3 /*       */
#define NV_097_SET_NORMAL3F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_NORMAL3S(i)                                    (0x005c1540+(i)*4) /* -W-4A */
#define NV_097_SET_NORMAL3S__SIZE_1                                                2 /*       */
#define NV_097_SET_NORMAL3S_V                                                   31:0 /* -WXUF */
#define NV_097_SET_DIFFUSE_COLOR4F(i)                             (0x005c1550+(i)*4) /* -W-4A */
#define NV_097_SET_DIFFUSE_COLOR4F__SIZE_1                                         4 /*       */
#define NV_097_SET_DIFFUSE_COLOR4F_V                                            31:0 /* -WXUF */
#define NV_097_SET_DIFFUSE_COLOR3F(i)                             (0x005c1560+(i)*4) /* -W-4A */
#define NV_097_SET_DIFFUSE_COLOR3F__SIZE_1                                         3 /*       */
#define NV_097_SET_DIFFUSE_COLOR3F_V                                            31:0 /* -WXUF */
#define NV_097_SET_DIFFUSE_COLOR4UB                                       0x005c156c /* -W-4R */
#define NV_097_SET_DIFFUSE_COLOR4UB_V                                           31:0 /* -WXUF */
#define NV_097_SET_SPECULAR_COLOR4F(i)                            (0x005c1570+(i)*4) /* -W-4A */
#define NV_097_SET_SPECULAR_COLOR4F__SIZE_1                                        4 /*       */
#define NV_097_SET_SPECULAR_COLOR4F_V                                           31:0 /* -WXUF */
#define NV_097_SET_SPECULAR_COLOR3F(i)                            (0x005c1580+(i)*4) /* -W-4A */
#define NV_097_SET_SPECULAR_COLOR3F__SIZE_1                                        3 /*       */
#define NV_097_SET_SPECULAR_COLOR3F_V                                           31:0 /* -WXUF */
#define NV_097_SET_SPECULAR_COLOR4UB                                      0x005c158c /* -W-4R */
#define NV_097_SET_SPECULAR_COLOR4UB_V                                          31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD0_2F(i)                                (0x005c1590+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD0_2F__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD0_2F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD0_2S                                           0x005c1598 /* -W-4R */
#define NV_097_SET_TEXCOORD0_2S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD0_4F(i)                                (0x005c15a0+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD0_4F__SIZE_1                                            4 /*       */
#define NV_097_SET_TEXCOORD0_4F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD0_4S(i)                                (0x005c15b0+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD0_4S__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD0_4S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD1_2F(i)                                (0x005c15b8+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD1_2F__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD1_2F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD1_2S                                           0x005c15c0 /* -W-4R */
#define NV_097_SET_TEXCOORD1_2S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD1_4F(i)                                (0x005c15c8+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD1_4F__SIZE_1                                            4 /*       */
#define NV_097_SET_TEXCOORD1_4F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD1_4S(i)                                (0x005c15d8+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD1_4S__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD1_4S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD2_2F(i)                                (0x005c15e0+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD2_2F__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD2_2F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD2_2S                                           0x005c15e8 /* -W-4R */
#define NV_097_SET_TEXCOORD2_2S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD2_4F(i)                                (0x005c15f0+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD2_4F__SIZE_1                                            4 /*       */
#define NV_097_SET_TEXCOORD2_4F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD2_4S(i)                                (0x005c1600+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD2_4S__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD2_4S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD3_2F(i)                                (0x005c1608+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD3_2F__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD3_2F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD3_2S                                           0x005c1610 /* -W-4R */
#define NV_097_SET_TEXCOORD3_2S_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD3_4F(i)                                (0x005c1620+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD3_4F__SIZE_1                                            4 /*       */
#define NV_097_SET_TEXCOORD3_4F_V                                               31:0 /* -WXUF */
#define NV_097_SET_TEXCOORD3_4S(i)                                (0x005c1630+(i)*4) /* -W-4A */
#define NV_097_SET_TEXCOORD3_4S__SIZE_1                                            2 /*       */
#define NV_097_SET_TEXCOORD3_4S_V                                               31:0 /* -WXUF */
#define NV_097_SET_FOG1F                                                  0x005c1698 /* -W-4R */
#define NV_097_SET_FOG1F_V                                                      31:0 /* -WXUF */
#define NV_097_SET_WEIGHT1F                                               0x005c169c /* -W-4R */
#define NV_097_SET_WEIGHT1F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_WEIGHT2F(i)                                    (0x005c16a0+(i)*4) /* -W-4A */
#define NV_097_SET_WEIGHT2F__SIZE_1                                                2 /*       */
#define NV_097_SET_WEIGHT2F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_WEIGHT3F(i)                                    (0x005c16b0+(i)*4) /* -W-4A */
#define NV_097_SET_WEIGHT3F__SIZE_1                                                3 /*       */
#define NV_097_SET_WEIGHT3F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_WEIGHT4F(i)                                    (0x005c16c0+(i)*4) /* -W-4A */
#define NV_097_SET_WEIGHT4F__SIZE_1                                                4 /*       */
#define NV_097_SET_WEIGHT4F_V                                                   31:0 /* -WXUF */
#define NV_097_SET_EDGE_FLAG                                              0x005c16bc /* -W-4R */
#define NV_097_SET_EDGE_FLAG_V                                                  31:0 /* -WXUF */
#define NV_097_SET_EDGE_FLAG_V_FALSE                                      0x00000000 /* -W--V */
#define NV_097_SET_EDGE_FLAG_V_TRUE                                       0x00000001 /* -W--V */
#define NV_097_SET_TRANSFORM_FIXED_CONST0(i)                      (0x005c16e0+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_FIXED_CONST0__SIZE_1                                  4 /*       */
#define NV_097_SET_TRANSFORM_FIXED_CONST0_V                                     31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_FIXED_CONST1(i)                      (0x005c16f0+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_FIXED_CONST1__SIZE_1                                  4 /*       */
#define NV_097_SET_TRANSFORM_FIXED_CONST1_V                                     31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_FIXED_CONST2(i)                      (0x005c1700+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_FIXED_CONST2__SIZE_1                                  4 /*       */
#define NV_097_SET_TRANSFORM_FIXED_CONST2_V                                     31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_FIXED_CONST3(i)                      (0x005c16d0+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_FIXED_CONST3__SIZE_1                                  4 /*       */
#define NV_097_SET_TRANSFORM_FIXED_CONST3_V                                     31:0 /* -WXUF */
#define NV_097_SET_TLCONST_ZERO(i)                                (0x005c17d4+(i)*4) /* -W-4A */
#define NV_097_SET_TLCONST_ZERO__SIZE_1                                            3 /*       */
#define NV_097_SET_TLCONST_ZERO_V                                               31:0 /* -WXUF */
#define NV_097_SET_EYE_DIRECTION(i)                               (0x005c17e0+(i)*4) /* -W-4A */
#define NV_097_SET_EYE_DIRECTION__SIZE_1                                           3 /*       */
#define NV_097_SET_EYE_DIRECTION_V                                              31:0 /* -WXUF */
#define NV_097_SET_LINEAR_FOG_CONST(i)                            (0x005c17ec+(i)*4) /* -W-4A */
#define NV_097_SET_LINEAR_FOG_CONST__SIZE_1                                        3 /*       */
#define NV_097_SET_LINEAR_FOG_CONST_V                                           31:0 /* -WXUF */
#define NV_097_INVALIDATE_VERTEX_CACHE_FILE                               0x005c1710 /* -W-4R */
#define NV_097_INVALIDATE_VERTEX_FILE                                     0x005c1714 /* -W-4R */
#define NV_097_TL_NOP                                                     0x005c1718 /* -W-4R */
#define NV_097_TL_SYNC                                                    0x005c171c /* -W-4R */
#define NV_097_SET_VERTEX_DATA_ARRAY_OFFSET(i)                    (0x005c1720+(i)*4) /* -W-4A */
#define NV_097_SET_VERTEX_DATA_ARRAY_OFFSET__SIZE_1                               16 /*       */
#define NV_097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA                        31:31 /* -WXUF */
#define NV_097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_A          0x00000000 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_B          0x00000001 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_OFFSET_OFFSET                              30:0 /* -WXUF */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT(i)                    (0x005c1760+(i)*4) /* -W-4A */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT__SIZE_1                               16 /*       */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_STRIDE                              31:8 /* -WXUF */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE                                 7:4 /* -WXUF */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED                 0x00000000 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_1                        0x00000001 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2                        0x00000002 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3                        0x00000003 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4                        0x00000004 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3W                       0x00000007 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE                                 3:0 /* -WXUF */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D                   0x00000000 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S1                       0x00000001 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F                        0x00000002 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_OGL                   0x00000004 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K                     0x00000005 /* -W--V */
#define NV_097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_CMP                      0x00000006 /* -W--V */
#define NV_097_SET_LOGIC_OP_ENABLE                                        0x005c17bc /* -W-4R */
#define NV_097_SET_LOGIC_OP_ENABLE_V                                            31:0 /* -WXUF */
#define NV_097_SET_LOGIC_OP_ENABLE_V_FALSE                                0x00000000 /* -W--V */
#define NV_097_SET_LOGIC_OP_ENABLE_V_TRUE                                 0x00000001 /* -W--V */
#define NV_097_SET_LOGIC_OP                                               0x005c17c0 /* -W-4R */
#define NV_097_SET_LOGIC_OP_V                                                   31:0 /* -WXUF */
#define NV_097_SET_LOGIC_OP_V_CLEAR                                       0x00001500 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_AND                                         0x00001501 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_AND_REVERSE                                 0x00001502 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_COPY                                        0x00001503 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_AND_INVERTED                                0x00001504 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_NOOP                                        0x00001505 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_XOR                                         0x00001506 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_OR                                          0x00001507 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_NOR                                         0x00001508 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_EQUIV                                       0x00001509 /* -W--V */
#define NV_097_SET_LOGIC_OP_V_INVERT                                      0x0000150A /* -W--V */
#define NV_097_SET_LOGIC_OP_V_OR_REVERSE                                  0x0000150B /* -W--V */
#define NV_097_SET_LOGIC_OP_V_COPY_INVERTED                               0x0000150C /* -W--V */
#define NV_097_SET_LOGIC_OP_V_OR_INVERTED                                 0x0000150D /* -W--V */
#define NV_097_SET_LOGIC_OP_V_NAND                                        0x0000150E /* -W--V */
#define NV_097_SET_LOGIC_OP_V_SET                                         0x0000150F /* -W--V */
#define NV_097_SET_BEGIN_END                                              0x005c17fc /* -W-4R */
#define NV_097_SET_BEGIN_END_OP                                                 31:0 /* -WXUF */
#define NV_097_SET_BEGIN_END_OP_END                                       0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_POINTS                                    0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_LINES                                     0x00000002 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_LINE_LOOP                                 0x00000003 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_LINE_STRIP                                0x00000004 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_TRIANGLES                                 0x00000005 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_TRIANGLE_STRIP                            0x00000006 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_TRIANGLE_FAN                              0x00000007 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_QUADS                                     0x00000008 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_QUAD_STRIP                                0x00000009 /* -W--V */
#define NV_097_SET_BEGIN_END_OP_POLYGON                                   0x0000000A /* -W--V */
#define NV_097_ARRAY_ELEMENT16                                            0x005c1800 /* -W-4R */
#define NV_097_ARRAY_ELEMENT16_VERTEX0                                          15:0 /* -WXUF */
#define NV_097_ARRAY_ELEMENT16_VERTEX1                                         31:16 /* -WXUF */
#define NV_097_ARRAY_ELEMENT32                                            0x005c1808 /* -W-4R */
#define NV_097_ARRAY_ELEMENT32_V                                                31:0 /* -WXUF */
#define NV_097_DRAW_ARRAYS                                                0x005c1810 /* -W-4R */
#define NV_097_DRAW_ARRAYS_COUNT                                               31:24 /* -WXUF */
#define NV_097_DRAW_ARRAYS_START_INDEX                                          23:0 /* -WXUF */
#define NV_097_INLINE_VERTEX_REUSE                                        0x005c1828 /* -W-4R */
#define NV_097_INLINE_VERTEX_REUSE_V                                            31:0 /* -WXUF */
#define NV_097_INLINE_ARRAY                                               0x005c1818 /* -W-4R */
#define NV_097_INLINE_ARRAY_V                                                   31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_OFFSET(i)                             (0x005c1b00+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_OFFSET__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXTURE_OFFSET_V                                             31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT(i)                             (0x005c1b04+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_FORMAT__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXTURE_FORMAT_CONTEXT_DMA                                    1:0 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                           0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                 2:2 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                    0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                     0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BORDER_SOURCE                                  3:3 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_BORDER_SOURCE_TEXTURE                   0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR                     0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_DIMENSIONALITY                                 7:4 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_DIMENSIONALITY_ONE                      0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO                      0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE                    0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR                                         15:8 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8                             0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8                            0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5                       0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5                       0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4                       0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5                         0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8                       0x00000006 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8                       0x00000007 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8                    0x0000000B /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5                   0x0000000C /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8                  0x0000000E /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8                  0x0000000F /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5                 0x00000010 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5                   0x00000011 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8                 0x00000012 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8                       0x00000013 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8                      0x00000014 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9                    0x00000015 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8                     0x00000016 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8                     0x00000017 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8                   0x00000018 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_A8                             0x00000019 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_A8Y8                           0x0000001A /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8                      0x0000001B /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5                 0x0000001C /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4                 0x0000001D /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8                 0x0000001E /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8                       0x0000001F /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8                     0x00000020 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8             0x00000024 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8             0x00000025 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8               0x00000026 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5                         0x00000027 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8                           0x00000028 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_R8B8                           0x00000029 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FIXED             0x0000002A /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FLOAT             0x0000002B /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FIXED                0x0000002C /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FLOAT                0x0000002D /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED       0x0000002E /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT       0x0000002F /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED          0x00000030 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT          0x00000031 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_Y16                            0x00000032 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16                    0x00000033 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6           0x00000034 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16                      0x00000035 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16                 0x00000036 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5                   0x00000037 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G5B5A1                       0x00000038 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_R4G4B4A4                       0x00000039 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8                       0x0000003A /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_B8G8R8A8                       0x0000003B /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_SZ_R8G8B8A8                       0x0000003C /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1                 0x0000003D /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4                 0x0000003E /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8                 0x0000003F /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8                 0x00000040 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8                 0x00000041 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                19:16 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U                                  23:20 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                           0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                           0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                           0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                          0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                          0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                          0x00000006 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                         0x00000007 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                         0x00000008 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                         0x00000009 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                        0x0000000A /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                        0x0000000B /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4096                        0x0000000C /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V                                  27:24 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                           0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                           0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                           0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                          0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                          0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                          0x00000006 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                         0x00000007 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                         0x00000008 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                         0x00000009 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                        0x0000000A /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                        0x0000000B /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4096                        0x0000000C /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P                                  31:28 /* -WXUF */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1                           0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_2                           0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_4                           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_8                           0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_16                          0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_32                          0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_64                          0x00000006 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_128                         0x00000007 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_256                         0x00000008 /* -W--V */
#define NV_097_SET_TEXTURE_FORMAT_BASE_SIZE_P_512                         0x00000009 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS(i)                            (0x005c1b08+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_ADDRESS__SIZE_1                                         4 /*       */
#define NV_097_SET_TEXTURE_ADDRESS_U                                             3:0 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_U_WRAP                                 0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_U_MIRROR                               0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE                        0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_U_BORDER                               0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_U_CLAMP_OGL                            0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_U                                     7:4 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE                        0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_U_TRUE                         0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_V                                            11:8 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_V_WRAP                                 0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_V_MIRROR                               0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE                        0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_V_BORDER                               0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_V_CLAMP_OGL                            0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_V                                   15:12 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE                        0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_V_TRUE                         0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_P                                           19:16 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_P_WRAP                                 0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_P_MIRROR                               0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE                        0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_P_BORDER                               0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_P_CLAMP_OGL                            0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_P                                   23:20 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE                        0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_P_TRUE                         0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_Q                                   31:24 /* -WXUF */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE                        0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_TRUE                         0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0(i)                           (0x005c1b0c+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_CONTROL0__SIZE_1                                        4 /*       */
#define NV_097_SET_TEXTURE_CONTROL0_ENABLE                                     31:30 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_ENABLE_FALSE                          0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_ENABLE_TRUE                           0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                              29:18 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                               17:6 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                5:4 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                       0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                       0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_2                       0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_3                       0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                           3:3 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE              0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE               0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                            2:2 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE               0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                          1:0 /* -WXUF */
#define NV_097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE             0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA             0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA              0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL              0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_CONTROL1(i)                           (0x005c1b10+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_CONTROL1__SIZE_1                                        4 /*       */
#define NV_097_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                31:16 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER(i)                             (0x005c1b14+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_FILTER__SIZE_1                                          4 /*       */
#define NV_097_SET_TEXTURE_FILTER_MIPMAP_LOD_BIAS                               12:0 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL                           15:13 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX             0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN                                          23:16 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_MIN_BOX_LOD0                            0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN_TENT_LOD0                           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN_BOX_NEARESTLOD                      0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN_TENT_NEARESTLOD                     0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN_BOX_TENT_LOD                        0x00000005 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN_TENT_TENT_LOD                       0x00000006 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0                 0x00000007 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MAG                                          27:24 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_MAG_BOX_LOD0                            0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MAG_TENT_LOD0                           0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0                 0x00000004 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_ASIGNED                                      28:28 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED                    0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_ASIGNED_BIT_ENABLED                     0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_RSIGNED                                      29:29 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED                    0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_RSIGNED_BIT_ENABLED                     0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_GSIGNED                                      30:30 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED                    0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_GSIGNED_BIT_ENABLED                     0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_BSIGNED                                      31:31 /* -WXUF */
#define NV_097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED                    0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_FILTER_BSIGNED_BIT_ENABLED                     0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_IMAGE_RECT(i)                         (0x005c1b1c+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_IMAGE_RECT__SIZE_1                                      4 /*       */
#define NV_097_SET_TEXTURE_IMAGE_RECT_WIDTH                                    31:16 /* -WXUF */
#define NV_097_SET_TEXTURE_IMAGE_RECT_HEIGHT                                    15:0 /* -WXUF */
#define NV_097_SET_TEXTURE_PALETTE(i)                            (0x005c1b20+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_PALETTE__SIZE_1                                         4 /*       */
#define NV_097_SET_TEXTURE_PALETTE_CONTEXT_DMA                                   1:0 /* -WXUF */
#define NV_097_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                          0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                          0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_PALETTE_LENGTH                                        5:2 /* -WXUF */
#define NV_097_SET_TEXTURE_PALETTE_LENGTH_256                             0x00000000 /* -W--V */
#define NV_097_SET_TEXTURE_PALETTE_LENGTH_128                             0x00000001 /* -W--V */
#define NV_097_SET_TEXTURE_PALETTE_LENGTH_64                              0x00000002 /* -W--V */
#define NV_097_SET_TEXTURE_PALETTE_LENGTH_32                              0x00000003 /* -W--V */
#define NV_097_SET_TEXTURE_PALETTE_OFFSET                                       31:6 /* -WXUF */
#define NV_097_SET_TEXTURE_BORDER_COLOR(i)                       (0x005c1b24+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_BORDER_COLOR__SIZE_1                                    4 /*       */
#define NV_097_SET_TEXTURE_BORDER_COLOR_V                                       31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT00(i)                 (0x005c1b28+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT00__SIZE_1                              4 /*       */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT00_V                                 31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT01(i)                 (0x005c1b2c+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT01__SIZE_1                              4 /*       */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT01_V                                 31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT11(i)                 (0x005c1b30+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT11__SIZE_1                              4 /*       */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT11_V                                 31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT10(i)                 (0x005c1b34+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT10__SIZE_1                              4 /*       */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_MAT10_V                                 31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_SCALE(i)                 (0x005c1b38+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_SCALE__SIZE_1                              4 /*       */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_SCALE_V                                 31:0 /* -WXUF */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_OFFSET(i)                (0x005c1b3c+(i)*64) /* -W-4A */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_OFFSET__SIZE_1                             4 /*       */
#define NV_097_SET_TEXTURE_SET_BUMP_ENV_OFFSET_V                                31:0 /* -WXUF */
#define NV_097_PARK_ATTRIBUTE                                             0x005c1d64 /* -W-4R */
#define NV_097_UNPARK_ATTRIBUTE                                           0x005c1d68 /* -W-4R */
#define NV_097_SET_SEMAPHORE_OFFSET                                       0x005c1d6c /* -W-4R */
#define NV_097_SET_SEMAPHORE_OFFSET_V                                           31:0 /* -WXUF */
#define NV_097_BACK_END_WRITE_SEMAPHORE_RELEASE                           0x005c1d70 /* -W-4R */
#define NV_097_BACK_END_WRITE_SEMAPHORE_RELEASE_V                               31:0 /* -WXUF */
#define NV_097_TEXTURE_READ_SEMAPHORE_RELEASE                             0x005c1d74 /* -W-4R */
#define NV_097_TEXTURE_READ_SEMAPHORE_RELEASE_V                                 31:0 /* -WXUF */
#define NV_097_SET_ZMIN_MAX_CONTROL                                       0x005c1d78 /* -W-4R */
#define NV_097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN                             3:0 /* -WXUF */
#define NV_097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE                0x00000000 /* -W--V */
#define NV_097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_TRUE                 0x00000001 /* -W--V */
#define NV_097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN                                    7:4 /* -WXUF */
#define NV_097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CULL                        0x00000000 /* -W--V */
#define NV_097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP                       0x00000001 /* -W--V */
#define NV_097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W                               11:8 /* -WXUF */
#define NV_097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_FALSE                   0x00000000 /* -W--V */
#define NV_097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE                    0x00000001 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL                                  0x005c1d7c /* -W-4R */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ENABLE                                  3:0 /* -WXUF */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE                     0x00000000 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ENABLE_TRUE                      0x00000001 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE                       7:4 /* -WXUF */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_DISABLE        0x00000000 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_ENABLE         0x00000001 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE                           11:8 /* -WXUF */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_DISABLE             0x00000000 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_ENABLE              0x00000001 /* -W--V */
#define NV_097_SET_ANTI_ALIASING_CONTROL_SAMPLE_MASK                           31:16 /* -WXUF */
#define NV_097_SET_DXT_DITHER_ENABLE_SW                                   0x005c1d88 /* -W-4R */
#define NV_097_SET_DXT_DITHER_ENABLE_SW_V                                       31:0 /* -WXUF */
#define NV_097_SET_DXT_DITHER_ENABLE_SW_V_DISABLE                         0x00000000 /* -W--V */
#define NV_097_SET_DXT_DITHER_ENABLE_SW_V_ENABLE                          0x00000001 /* -W--V */
#define NV_097_SET_COMPRESS_ZBUFFER_EN                                    0x005c1d80 /* -W-4R */
#define NV_097_SET_COMPRESS_ZBUFFER_EN_V                                        31:0 /* -WXUF */
#define NV_097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE                          0x00000000 /* -W--V */
#define NV_097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE                           0x00000001 /* -W--V */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN                                    0x005c1d84 /* -W-4R */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN                               0:0 /* -WXUF */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE                0x00000000 /* -W--V */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_ENABLE                 0x00000001 /* -W--V */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN                        1:1 /* -WXUF */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_DISABLE         0x00000000 /* -W--V */
#define NV_097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_ENABLE          0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT                                         0x005c0208 /* -W-4R */
#define NV_097_SET_SURFACE_FORMAT_COLOR                                          3:0 /* -WXUF */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5              0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5              0x00000002 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                         0x00000003 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8              0x00000004 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8              0x00000005 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8          0x00000006 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8          0x00000007 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                       0x00000008 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_B8                             0x00000009 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_COLOR_LE_G8B8                           0x0000000A /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_ZETA                                           7:4 /* -WXUF */
#define NV_097_SET_SURFACE_FORMAT_ZETA_Z16                                0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_ZETA_Z24S8                              0x00000002 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_TYPE                                          11:8 /* -WXUF */
#define NV_097_SET_SURFACE_FORMAT_TYPE_PITCH                              0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_TYPE_SWIZZLE                            0x00000002 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_ANTI_ALIASING                                15:12 /* -WXUF */
#define NV_097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1                  0x00000000 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_CORNER_2           0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_ANTI_ALIASING_SQUARE_OFFSET_4           0x00000002 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH                                        23:16 /* -WXUF */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_1                                 0x00000000 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_2                                 0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_4                                 0x00000002 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_8                                 0x00000003 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_16                                0x00000004 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_32                                0x00000005 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_64                                0x00000006 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_128                               0x00000007 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_256                               0x00000008 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_512                               0x00000009 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_1024                              0x0000000A /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_2048                              0x0000000B /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_WIDTH_4096                              0x0000000C /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT                                       31:24 /* -WXUF */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_1                                0x00000000 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_2                                0x00000001 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_4                                0x00000002 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_8                                0x00000003 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_16                               0x00000004 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_32                               0x00000005 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_64                               0x00000006 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_128                              0x00000007 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_256                              0x00000008 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_512                              0x00000009 /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_1024                             0x0000000A /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_2048                             0x0000000B /* -W--V */
#define NV_097_SET_SURFACE_FORMAT_HEIGHT_4096                             0x0000000C /* -W--V */
#define NV_097_SET_ZSTENCIL_CLEAR_VALUE                                   0x005c1d8c /* -W-4R */
#define NV_097_SET_ZSTENCIL_CLEAR_VALUE_V                                       31:0 /* -WXUF */
#define NV_097_SET_COLOR_CLEAR_VALUE                                      0x005c1d90 /* -W-4R */
#define NV_097_SET_COLOR_CLEAR_VALUE_V                                          31:0 /* -WXUF */
#define NV_097_CLEAR_SURFACE                                              0x005c1d94 /* -W-4R */
#define NV_097_CLEAR_SURFACE_Z                                                   0:0 /* -WXUF */
#define NV_097_CLEAR_SURFACE_Z_DISABLE                                    0x00000000 /* -W--V */
#define NV_097_CLEAR_SURFACE_Z_ENABLE                                     0x00000001 /* -W--V */
#define NV_097_CLEAR_SURFACE_STENCIL                                             1:1 /* -WXUF */
#define NV_097_CLEAR_SURFACE_STENCIL_DISABLE                              0x00000000 /* -W--V */
#define NV_097_CLEAR_SURFACE_STENCIL_ENABLE                               0x00000001 /* -W--V */
#define NV_097_CLEAR_SURFACE_R                                                   4:4 /* -WXUF */
#define NV_097_CLEAR_SURFACE_R_DISABLE                                    0x00000000 /* -W--V */
#define NV_097_CLEAR_SURFACE_R_ENABLE                                     0x00000001 /* -W--V */
#define NV_097_CLEAR_SURFACE_G                                                   5:5 /* -WXUF */
#define NV_097_CLEAR_SURFACE_G_DISABLE                                    0x00000000 /* -W--V */
#define NV_097_CLEAR_SURFACE_G_ENABLE                                     0x00000001 /* -W--V */
#define NV_097_CLEAR_SURFACE_B                                                   6:6 /* -WXUF */
#define NV_097_CLEAR_SURFACE_B_DISABLE                                    0x00000000 /* -W--V */
#define NV_097_CLEAR_SURFACE_B_ENABLE                                     0x00000001 /* -W--V */
#define NV_097_CLEAR_SURFACE_A                                                   7:7 /* -WXUF */
#define NV_097_CLEAR_SURFACE_A_DISABLE                                    0x00000000 /* -W--V */
#define NV_097_CLEAR_SURFACE_A_ENABLE                                     0x00000001 /* -W--V */
#define NV_097_SET_CLEAR_RECT_HORIZONTAL                                  0x005c1d98 /* -W-4R */
#define NV_097_SET_CLEAR_RECT_HORIZONTAL_XMIN                                   15:0 /* -WXUF */
#define NV_097_SET_CLEAR_RECT_HORIZONTAL_XMAX                                  31:16 /* -WXUF */
#define NV_097_SET_CLEAR_RECT_VERTICAL                                    0x005c1d9c /* -W-4R */
#define NV_097_SET_CLEAR_RECT_VERTICAL_YMIN                                     15:0 /* -WXUF */
#define NV_097_SET_CLEAR_RECT_VERTICAL_YMAX                                    31:16 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0                                           0x005c1de0 /* -W-4R */
#define NV_097_SET_BEGIN_PATCH0_POSITION_DEGREE                                  3:0 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM1_DEGREE                                    7:4 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM2_DEGREE                                   11:8 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM3_DEGREE                                  15:12 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM4_DEGREE                                  19:16 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM5_DEGREE                                  23:20 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM6_DEGREE                                  27:24 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH0_PARAM7_DEGREE                                  31:28 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1                                           0x005c1de4 /* -W-4R */
#define NV_097_SET_BEGIN_PATCH1_PARAM8_DEGREE                                    3:0 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM9_DEGREE                                    7:4 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM10_DEGREE                                  11:8 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM11_DEGREE                                 15:12 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM12_DEGREE                                 19:16 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM13_DEGREE                                 23:20 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM14_DEGREE                                 27:24 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH1_PARAM15_DEGREE                                 31:28 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2                                           0x005c1de8 /* -W-4R */
#define NV_097_SET_BEGIN_PATCH2_SWATCH_ROWS                                      7:0 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2_SWATCH_COLS                                     15:8 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2_SWATCH_SIZE                                    20:16 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_WIDTH                           25:21 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_HEIGHT                          30:26 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2_PATCH_TYPE                                     31:31 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH2_PATCH_TYPE_SQUARE                         0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3                                           0x005c1dec /* -W-4R */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS                                         2:0 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS_NONE                             0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST                            0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS_LAST                             0x00000002 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST_AND_LAST                   0x00000003 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS_REV_FIRST                        0x00000005 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_ROW_TRNS_REV_LAST                         0x00000006 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS                                         5:3 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS_NONE                             0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS_FIRST                            0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS_LAST                             0x00000002 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS_FIRST_AND_LAST                   0x00000003 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS_REV_FIRST                        0x00000005 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_COL_TRNS_REV_LAST                         0x00000006 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_POSITION_GUARD_CURVE_DEGREE                      9:6 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH3_NORMAL_GUARD_CURVE_DEGREE                      13:10 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH3_PRIMITIVE                                      15:14 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH3_PRIMITIVE_TRI_STRIP                       0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_PRIMITIVE_REVERSED_TRI_STRIP              0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_PRIMITIVE_BW_TRI_STRIP                    0x00000002 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_PRIMITIVE_BW_REVERSED_TRI_STRIP           0x00000003 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_TESSELATION                                    16:16 /* -WXUF */
#define NV_097_SET_BEGIN_PATCH3_TESSELATION_ADAPTIVE_STITCH               0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_TESSELATION_FIXED_STITCH                  0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_PATCH3_NUM_COEFFS                                     31:24 /* -WXUF */
#define NV_097_SET_END_PATCH                                              0x005c1df0 /* -W-4R */
#define NV_097_SET_BEGIN_END_SWATCH                                       0x005c1df4 /* -W-4R */
#define NV_097_SET_BEGIN_END_SWATCH_SWATCH_CMD                                   3:0 /* -WXUF */
#define NV_097_SET_BEGIN_END_SWATCH_SWATCH_CMD_END                        0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SWATCH_CMD_BEGIN                      0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_NEW_SWATH                                    7:4 /* -WXUF */
#define NV_097_SET_BEGIN_END_SWATCH_NEW_SWATH_CONTINUE                    0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_NEW_SWATH_NEW                         0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW                              11:8 /* -WXUF */
#define NV_097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_FALSE                  0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_TRUE                   0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL                             15:12 /* -WXUF */
#define NV_097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_FALSE                  0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_TRUE                   0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SHORT_SWATCH                               19:16 /* -WXUF */
#define NV_097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_FULL_HEIGHT              0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_PARTIAL_HEIGHT           0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_NARROW_SWATCH                              31:20 /* -WXUF */
#define NV_097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_FULL_WIDTH              0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_PARTIAL_WIDTH           0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE                                        0x005c1df8 /* -W-4R */
#define NV_097_SET_BEGIN_END_CURVE_CMD                                           3:0 /* -WXUF */
#define NV_097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA                     0x00000000 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE                        0x00000001 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE                   0x00000002 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE                  0x00000003 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE             0x00000004 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE             0x00000005 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_OUTER_END_PT                       0x00000006 /* -W--V */
#define NV_097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT                       0x00000007 /* -W--V */
#define NV_097_SET_CURVE_COEFFICIENTS(i)                          (0x005c1e00+(i)*4) /* -W-4A */
#define NV_097_SET_CURVE_COEFFICIENTS__SIZE_1                                      4 /*       */
#define NV_097_SET_CURVE_COEFFICIENTS_V                                         31:0 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0                                      0x005c1e10 /* -W-4R */
#define NV_097_SET_BEGIN_TRANSITION0_POSITION_DEGREE                             3:0 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM1_DEGREE                               7:4 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM2_DEGREE                              11:8 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM3_DEGREE                             15:12 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM4_DEGREE                             19:16 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM5_DEGREE                             23:20 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM6_DEGREE                             27:24 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION0_PARAM7_DEGREE                             31:28 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1                                      0x005c1e14 /* -W-4R */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM8_DEGREE                               3:0 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM9_DEGREE                               7:4 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM10_DEGREE                             11:8 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM11_DEGREE                            15:12 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM12_DEGREE                            19:16 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM13_DEGREE                            23:20 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM14_DEGREE                            27:24 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION1_PARAM15_DEGREE                            31:28 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION2                                      0x005c1e18 /* -W-4R */
#define NV_097_SET_BEGIN_TRANSITION2_INSIDE_SEGMENTS                             9:0 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION2_OUTSIDE_SEGMENTS                          19:10 /* -WXUF */
#define NV_097_SET_BEGIN_TRANSITION2_NUM_COEFFS                                31:24 /* -WXUF */
#define NV_097_SET_END_TRANSITION                                         0x005c1e1c /* -W-4R */
#define NV_097_SET_SHADOW_ZSLOPE_THRESHOLD                                0x005c1e68 /* -W-4R */
#define NV_097_SET_SHADOW_ZSLOPE_THRESHOLD_V                                    31:0 /* -WXUF */
#define NV_097_SET_SHADOW_DEPTH_FUNC                                      0x005c1e6c /* -W-4R */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V                                          31:0 /* -WXUF */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_NEVER                              0x00000000 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_LESS                               0x00000001 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_EQUAL                              0x00000002 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_LEQUAL                             0x00000003 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_GREATER                            0x00000004 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_NOTEQUAL                           0x00000005 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_GEQUAL                             0x00000006 /* -W--V */
#define NV_097_SET_SHADOW_DEPTH_FUNC_V_ALWAYS                             0x00000007 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM                                   0x005c1e70 /* -W-4R */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0                                   4:0 /* -WXUF */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE               0x00000000 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE              0x00000001 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE              0x00000002 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP                   0x00000003 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH               0x00000004 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE                 0x00000005 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1                                   9:5 /* -WXUF */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE               0x00000000 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE              0x00000001 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_3D_PROJECTIVE              0x00000002 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_CUBE_MAP                   0x00000003 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH               0x00000004 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE                 0x00000005 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP                 0x00000006 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE       0x00000007 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_AR               0x0000000F /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_GB               0x00000010 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT                0x00000011 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2                                 14:10 /* -WXUF */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE               0x00000000 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_2D_PROJECTIVE              0x00000001 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_3D_PROJECTIVE              0x00000002 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_CUBE_MAP                   0x00000003 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH               0x00000004 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE                 0x00000005 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP                 0x00000006 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE       0x00000007 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_BRDF                       0x00000008 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST                     0x00000009 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW                     0x0000000A /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE        0x0000000B /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR               0x0000000F /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB               0x00000010 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT                0x00000011 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3                                 19:15 /* -WXUF */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE               0x00000000 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE              0x00000001 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE              0x00000002 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP                   0x00000003 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH               0x00000004 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE                 0x00000005 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP                 0x00000006 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE       0x00000007 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF                       0x00000008 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST                     0x00000009 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW                     0x0000000A /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR       0x0000000C /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D                 0x0000000D /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE               0x0000000E /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR               0x0000000F /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB               0x00000010 /* -W--V */
#define NV_097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST 0x00000012 /* -W--V */
#define NV_097_SET_EYE_VECTOR(i)                                  (0x005c181c+(i)*4) /* -W-4A */
#define NV_097_SET_EYE_VECTOR__SIZE_1                                              3 /*       */
#define NV_097_SET_EYE_VECTOR_V                                                 31:0 /* -WXUF */
#define NV_097_SET_DOT_RGBMAPPING                                         0x005c1e74 /* -W-4R */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1                                         3:0 /* -WXUF */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1                        0x00000000 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_MS                  0x00000001 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_GL                  0x00000002 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_NV                  0x00000003 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_HILO_1                           0x00000004 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_MS               0x00000005 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_GL               0x00000006 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_NV               0x00000007 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2                                         7:4 /* -WXUF */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_ZERO_TO_1                        0x00000000 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_MS                  0x00000001 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_GL                  0x00000002 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_NV                  0x00000003 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_HILO_1                           0x00000004 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_MS               0x00000005 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_GL               0x00000006 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_NV               0x00000007 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3                                        11:8 /* -WXUF */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_ZERO_TO_1                        0x00000000 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_MS                  0x00000001 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_GL                  0x00000002 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_NV                  0x00000003 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_HILO_1                           0x00000004 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_MS               0x00000005 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_GL               0x00000006 /* -W--V */
#define NV_097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_NV               0x00000007 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE                                 0x005c17f8 /* -W-4R */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S                               0:0 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T                               1:1 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R                               2:2 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q                               3:3 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S                               4:4 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T                               5:5 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R                               6:6 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q                               7:7 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S                               8:8 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T                               9:9 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R                             10:10 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q                             11:11 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S                             12:12 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T                             13:13 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R                             14:14 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q                             15:15 /* -WXUF */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPLTZ                0x00000000 /* -W--V */
#define NV_097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPGEZ                0x00000001 /* -W--V */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT                               0x005c1e78 /* -W-4R */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1                              15:0 /* -WXUF */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1_INSTAGE_0              0x00000000 /* -W--V */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2                             19:16 /* -WXUF */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0              0x00000000 /* -W--V */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1              0x00000001 /* -W--V */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3                             23:20 /* -WXUF */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0              0x00000000 /* -W--V */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1              0x00000001 /* -W--V */
#define NV_097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2              0x00000002 /* -W--V */
#define NV_097_SET_SPECULAR_FOG_FACTOR(i)                         (0x005c1e20+(i)*4) /* -W-4A */
#define NV_097_SET_SPECULAR_FOG_FACTOR__SIZE_1                                     2 /*       */
#define NV_097_SET_SPECULAR_FOG_FACTOR_BLUE                                      7:0 /* -WXUF */
#define NV_097_SET_SPECULAR_FOG_FACTOR_GREEN                                    15:8 /* -WXUF */
#define NV_097_SET_SPECULAR_FOG_FACTOR_RED                                     23:16 /* -WXUF */
#define NV_097_SET_SPECULAR_FOG_FACTOR_ALPHA                                   31:24 /* -WXUF */
#define NV_097_SET_COMBINER_CONTROL                                       0x005c1e60 /* -W-4R */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT                              7:0 /* -WXUF */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE                   0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_TWO                   0x00000002 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_THREE                 0x00000003 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_FOUR                  0x00000004 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_FIVE                  0x00000005 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_SIX                   0x00000006 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_SEVEN                 0x00000007 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_ITERATION_COUNT_EIGHT                 0x00000008 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_MUX_SELECT                                  11:8 /* -WXUF */
#define NV_097_SET_COMBINER_CONTROL_MUX_SELECT_LSB                        0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_MUX_SELECT_MSB                        0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_FACTOR0                                    15:12 /* -WXUF */
#define NV_097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL               0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_FACTOR0_EACH_STAGE                    0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_FACTOR1                                    31:16 /* -WXUF */
#define NV_097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL               0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_CONTROL_FACTOR1_EACH_STAGE                    0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW(i)                          (0x005c1e40+(i)*4) /* -W-4A */
#define NV_097_SET_COMBINER_COLOR_OCW__SIZE_1                                      8 /*       */
#define NV_097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB                           31:19 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE              0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE        0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD                           18:18 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE              0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE        0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_OP                                       17:15 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT                          0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT_BIAS                     0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1                     0x00000002 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1_BIAS                0x00000003 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY2                     0x00000004 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_OP_SHIFTRIGHTBY1                    0x00000006 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_MUX_ENABLE                               14:14 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE                            13:13 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE                            12:12 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST                                   11:8 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0                       0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4                       0x00000004 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5                       0x00000005 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8                       0x00000008 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9                       0x00000009 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A                       0x0000000A /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B                       0x0000000B /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C                       0x0000000C /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D                       0x0000000D /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST                                     7:4 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0                        0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4                        0x00000004 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5                        0x00000005 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8                        0x00000008 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9                        0x00000009 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A                        0x0000000A /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B                        0x0000000B /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C                        0x0000000C /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D                        0x0000000D /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST                                     3:0 /* -WXUF */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0                        0x00000000 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4                        0x00000004 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5                        0x00000005 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8                        0x00000008 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9                        0x00000009 /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A                        0x0000000A /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B                        0x0000000B /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C                        0x0000000C /* -W--V */
#define NV_097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D                        0x0000000D /* -W--V */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE                               0x005c1e94 /* -W-4R */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE_MODE                                 1:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED                    0x00000000 /* -W--V */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE_MODE_PROGRAM                  0x00000002 /* -W--V */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE                          31:2 /* -WXUF */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_USER               0x00000000 /* -W--V */
#define NV_097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV               0x00000001 /* -W--V */
#define NV_097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN                         0x005c1e98 /* -W-4R */
#define NV_097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V                             31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_ONLY             0x00000000 /* -W--V */
#define NV_097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_WRITE            0x00000001 /* -W--V */
#define NV_097_SET_TRANSFORM_PROGRAM_LOAD                                 0x005c1e9c /* -W-4R */
#define NV_097_SET_TRANSFORM_PROGRAM_LOAD_PROG_LD_PTR                           31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_PROGRAM_START                                0x005c1ea0 /* -W-4R */
#define NV_097_SET_TRANSFORM_PROGRAM_START_V                                    31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_PROGRAM(i)                           (0x005c0b00+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_PROGRAM__SIZE_1                                      32 /*       */
#define NV_097_SET_TRANSFORM_PROGRAM_V                                          31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_CONSTANT_LOAD                                0x005c1ea4 /* -W-4R */
#define NV_097_SET_TRANSFORM_CONSTANT_LOAD_CONST_LD_PTR                         31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_CONSTANT(i)                          (0x005c0b80+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_CONSTANT__SIZE_1                                     32 /*       */
#define NV_097_SET_TRANSFORM_CONSTANT_V                                         31:0 /* -WXUF */
#define NV_097_SET_TRANSFORM_DATA(i)                              (0x005c1e80+(i)*4) /* -W-4A */
#define NV_097_SET_TRANSFORM_DATA__SIZE_1                                          4 /*       */
#define NV_097_SET_TRANSFORM_DATA_V                                             31:0 /* -WXUF */
#define NV_097_LAUNCH_TRANSFORM_PROGRAM                                   0x005c1e90 /* -W-4R */
#define NV_097_LAUNCH_TRANSFORM_PROGRAM_V                                       31:0 /* -WXUF */
#define NV_097_SET_TWO_SIDE_LIGHT_EN                                      0x005c17c4 /* -W-4R */
#define NV_097_SET_TWO_SIDE_LIGHT_EN_V                                          31:0 /* -WXUF */
#define NV_097_SET_TWO_SIDE_LIGHT_EN_V_FALSE                              0x00000000 /* -W--V */
#define NV_097_SET_TWO_SIDE_LIGHT_EN_V_TRUE                               0x00000001 /* -W--V */
#define NV_097_SET_BACK_SCENE_AMBIENT_COLOR(i)                    (0x005c17a0+(i)*4) /* -W-4A */
#define NV_097_SET_BACK_SCENE_AMBIENT_COLOR__SIZE_1                                3 /*       */
#define NV_097_SET_BACK_SCENE_AMBIENT_COLOR_V                                   31:0 /* -WXUF */
#define NV_097_SET_BACK_MATERIAL_EMISSION(i)                      (0x005c17b0+(i)*4) /* -W-4A */
#define NV_097_SET_BACK_MATERIAL_EMISSION__SIZE_1                                  3 /*       */
#define NV_097_SET_BACK_MATERIAL_EMISSION_V                                     31:0 /* -WXUF */
#define NV_097_CLEAR_REPORT_VALUE                                         0x005c17c8 /* -W-4R */
#define NV_097_CLEAR_REPORT_VALUE_TYPE                                          31:0 /* -WXUF */
#define NV_097_CLEAR_REPORT_VALUE_TYPE_ZPASS_PIXEL_CNT                    0x00000001 /* -W--V */
#define NV_097_SET_ZPASS_PIXEL_COUNT_ENABLE                               0x005c17cc /* -W-4R */
#define NV_097_SET_ZPASS_PIXEL_COUNT_ENABLE_V                                   31:0 /* -WXUF */
#define NV_097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE                       0x00000000 /* -W--V */
#define NV_097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_TRUE                        0x00000001 /* -W--V */
#define NV_097_GET_REPORT                                                 0x005c17d0 /* -W-4R */
#define NV_097_GET_REPORT_OFFSET                                                23:0 /* -WXUF */
#define NV_097_GET_REPORT_TYPE                                                 31:24 /* -WXUF */
#define NV_097_GET_REPORT_TYPE_ZPASS_PIXEL_CNT                            0x00000001 /* -W--V */
#define NV_097_DEBUG_INIT(i)                                      (0x005c1fc0+(i)*4) /* -W-4A */
#define NV_097_DEBUG_INIT__SIZE_1                                                 10 /*       */
#define NV_097_DEBUG_INIT_V                                                     31:0 /* -WXUF */
/* usr_2074.ref */
#define NV_2074_NOTIFICATION__SIZE_0          0x0000003f:0x00000000 /* ----M */
#define NV_2074_NOTIFICATION_TIMESTAMP        ( 1*32+31):( 0*32+ 0) /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_HDR          ( 3*32+31):( 2*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_HDR_ZERO_0                     1:0 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_HDR_CONSTRAINED_PARAMS_FLAG    2:2 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_HDR_VBV_BUFFER_SIZE_VALUE     12:3 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_HDR_ZERO_1                   13:13 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_HDR_BIT_RATE_VALUE           31:14 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_HDR_FRAME_RATE_CODE          35:32 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_HDR_ASPECT_RATIO_INFORMATION 39:36 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_HDR_VERTICAL_SIZE_VALUE      51:40 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_HDR_HORIZONTAL_SIZE_VALUE    63:52 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT          ( 5*32+31):( 4*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_EXT_ZERO_0                    15:0 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_EXT_FRAME_RATE_EXTENTION_D   20:16 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT_FRAME_RATE_EXTENSION_N   22:21 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT_VBV_BUFFER_SIZE_EXT      31:24 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT_ZERO_1                   23:23 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_EXT_BIT_RATE_EXT             44:33 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT_VERTICAL_SIZE_EXT        46:45 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT_HORIZONTAL_SIZE_EXT      48:47 /* ---UF */
#define NV_2074_NOTIFICATION_SEQ_EXT_CHROMA_FORMAT            50:49 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_EXT_PROGRESSIVE_SEQUENCE     51:51 /* ---VF */
#define NV_2074_NOTIFICAITON_SEQ_EXT_PROFILE_AND_LEVEL_IND    59:52 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_EXT_RECEIVED                 63:60 /* ---VF */
#define NV_2074_NOTIFICATION_SEQ_EXT_RECEIVED_NONE       0x00000000 /* ----V */
#define NV_2074_NOTIFICATION_SEQ_EXT_RECEIVED_HEADER     0x00000001 /* ----V */
#define NV_2074_NOTIFICATION_SEQ_EXT_RECEIVED_EXTENSION  0x00000002 /* ----V */
#define NV_2074_NOTIFICATION_GOP_HDR          ( 6*32+31):( 6*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_GOP_HDR_ZERO                       4:0 /* ---VF */
#define NV_2074_NOTIFICATION_GOP_HDR_BROKEN_LINK                5:5 /* ---VF */
#define NV_2074_NOTIFICATION_GOP_HDR_CLOSED_GOP                 6:6 /* ---VF */
#define NV_2074_NOTIFICATION_GOP_HDR_TIME_CODE                 31:7 /* ---VF */
#define NV_2074_NOTIFICATION_ZERO_0           ( 7*32+31):( 7*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR          ( 9*32+31):( 8*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_ZERO                      26:0 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_BACKWARD_F_CODE          29:27 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_FULL_PEL_BACKWARD_VECTOR 30:30 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_FORWARD_F_CODE           33:31 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_FULL_PEL_FORWARD_VECTOR  34:34 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_VBV_DELAY                50:35 /* ---UF */
#define NV_2074_NOTIFICATION_PIC_HDR_PICTURE_CODING_TYPE      53:51 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_HDR_TEMPORAL_REFERENCE       63:54 /* ---UF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT       (11*32+31):(10*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_ZERO                    9:0 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_SUB_CARRIER_PHASE     17:10 /* ---UF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_BURST_AMPLITUDE       24:18 /* ---UF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_SUB_CARRIER           25:25 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_FIELD_SEQUENCE        28:26 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_V_AXIS                29:29 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_COMPOSITE_DISP_FLAG   30:30 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_PROGRESSIVE_FRAME     31:31 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_CHROMA_420_TYPE       32:32 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_REPEAT_FIRST_FIELD    33:33 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_ALTERNATE_SCAN        34:34 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_INTRA_VLC_FORMAT      35:35 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_Q_SCALE_TYPE          36:36 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_CONCEALMENT_MTN_VECTS 37:37 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_FRAME_PRED_FRAME_DCT  38:38 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_TOP_FIELD_FIRST       39:39 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_PICTURE_STRUCTURE     41:40 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_INTRA_DC_PRECISION    43:42 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_F_CODE_BACKWARD_VERT  47:44 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_F_CODE_BACKWARD_HORIZ 51:48 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_F_CODE_FORWARD_VERT   55:52 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_F_CODE_FORWARD_HORIZ  59:56 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_RECEIVED              63:60 /* ---VF */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_RECEIVED_NONE    0x00000000 /* ----V */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_RECEIVED_HEADER  0x00000001 /* ----V */
#define NV_2074_NOTIFICATION_PIC_CD_EXT_RECEIVED_EXT     0x00000002 /* ----V */
#define NV_2074_NOTIFICATION_LST_PRSD_BIT_NBR (12*32+31):(12*31+ 0) /* ---UF */
#define NV_2074_NOTIFICATION_PUBLIC_KEY       (13*32+31):(13*31+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_ZERO_1           (15*32+23):(14*32+ 0) /* ---VF */
#define NV_2074_NOTIFICATION_STATUS           (15*32+31):(15*32+24) /* ---VF */
#define NV_2074_NOTIFICATION_STATUS_DONE_SUCCESS         0x00000000 /* ----V */
#define NV_2074_NOTIFICATION_STATUS_DONE_MPEG_ERROR      0x00000001 /* ----V */
#define NV_2074_NOTIFICATION_STATUS_IN_PROGRESS          0x000000ff /* ----V */
#define NV_2074_SYNCHRONIZE                              0x00000100 /* -W-4R */
#define NV_2074_SYNCHRONIZE_ALL_BITS                           31:0 /* -W-VF */
#define NV_2074_SYNCHRONIZE_NO_OPERATION                 0x00000000 /* -W--V */
#define NV_2074_SYNCHRONIZE_WFI                          0x00000001 /* -W--V */
#define NV_2074_SYNCHRONIZE_WFI_WRITE_PE_NOTIFY          0x00000002 /* -W--V */
#define NV_2074_SYNCHRONIZE_WFI_WRITE_PE_NOTIFY_AWAKEN   0x00000003 /* -W--V */
#define NV_2074_SET_CONTEXT_DMA_NOTIFIES                 0x00000180 /* -W-4R */
#define NV_2074_SET_CONTEXT_DMA_NOTIFIES_ALL_BITS              31:0 /* -WCVF */
#define NV_2074_SET_CONTEXT_DMA_FRAMES                   0x00000184 /* -W-4R */
#define NV_2074_SET_CONTEXT_DMA_FRAMES_ALL_BITS                31:0 /* -WCVF */
#define NV_2074_SET_PUBLIC_KEY                           0x000003e0 /* -W-4R */
#define NV_2074_SET_PUBLIC_KEY_ALL_BITS                        31:0 /* -WCVF */
#define NV_2074_SET_FORMAT                               0x000003e4 /* -W-4R */
#define NV_2074_SET_FORMAT_FRAME_PITCH                         15:0 /* -WCUF */
#define NV_2074_SET_FORMAT_RENDERING                          19:16 /* -WCVF */
#define NV_2074_SET_FORMAT_RENDERING_DISABLED            0x00000000 /* -W--V */
#define NV_2074_SET_FORMAT_RENDERING_ENABLED             0x00000001 /* -W--V */
#define NV_2074_SET_FORMAT_FIELD                              31:20 /* -WCVF */
#define NV_2074_SET_FORMAT_FIELD_AUTOMATIC               0x00000000 /* -W--V */
#define NV_2074_SET_FORMAT_FIELD_FIRST                   0x00000001 /* -W--V */
#define NV_2074_SET_FORMAT_FIELD_SECOND                  0x00000002 /* -W--V */
#define NV_2074_SET_OFFSET_PAST_LUMA                     0x000003e8 /* -W-4R */
#define NV_2074_SET_OFFSET_PAST_LUMA_ALL_BITS                  31:0 /* -WCUF */
#define NV_2074_SET_OFFSET_PAST_CHROMA                   0x000003ec /* -W-4R */
#define NV_2074_SET_OFFSET_PAST_CHROMA_ALL_BITS                31:0 /* -WCUF */
#define NV_2074_SET_OFFSET_CURRENT_LUMA                  0x000003f0 /* -W-4R */
#define NV_2074_SET_OFFSET_CURRENT_LUMA_ALL_BITS               31:0 /* -WCUF */
#define NV_2074_SET_OFFSET_CURRENT_CHROMA                0x000003f4 /* -W-4R */
#define NV_2074_SET_OFFSET_CURRENT_CHROMA_ALL_BITS             31:0 /* -WCUF */
#define NV_2074_SET_OFFSET_FUTURE_LUMA                   0x000003f8 /* -W-4R */
#define NV_2074_SET_OFFSET_FUTURE_LUMA_ALL_BITS                31:0 /* -WCUF */
#define NV_2074_SET_OFFSET_FUTURE_CHROMA                 0x000003fc /* -W-4R */
#define NV_2074_SET_OFFSET_FUTURE_CHROMA_ALL_BITS              31:0 /* -WCUF */
#define NV_2074_SET_DATA(i)                      (0x00000400+(i)*4) /* -W-4A */
#define NV_2074_SET_DATA__SIZE_1                                128 /*       */
#define NV_2074_SET_DATA_VALUE                                 31:0 /* -WCVF */
#define NV_2074_SET_ENCRYPTED_DATA_LEFT(i)       (0x00000600+(i)*8) /* -W-4A */
#define NV_2074_SET_ENCRYPTED_DATA_LEFT__SIZE_1                  64 /*       */
#define NV_2074_SET_ENCRYPTES_DATA_LEFT_ALL_BITS               31:0 /* -WCVF */
#define NV_2074_SET_ENCRYPTED_DATA_RIGHT(i)      (0x00000604+(i)*8) /* -W-4A */
#define NV_2074_SET_ENCRYPTED_DATA_RIGHT__SIZE_1                 64 /*       */
#define NV_2074_SET_ENCRYPTED_DATA_RIGHT_ALL_BITS              31:0 /* -W-VF */
/* usr_pattern.ref */
#define NV_IMAGE_PATTERN                                 0x00000018 /* ----C */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_NOTIFY                                  0x00460104 /* -W-4R */
#define NV_UPATT_NOTIFY_STYLE                                  31:0 /* -W-VF */
#define NV_UPATT_NOTIFY_STYLE_WRITE_ONLY                 0x00000000 /* -W--V */
#define NV_UPATT_NOTIFY_STYLE_WRITE_THEN_AWAKEN          0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY__ALIAS_1                NV_UPATT_NOTIFY /*       */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY                  0x00460180 /* -W-4R */
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_PARAMETER              31:0 /* -W-VF */
#define NV_UPATT_SET_IMAGE_OUTPUT                        0x00460200 /* -W-4R */
#define NV_UPATT_SET_IMAGE_OUTPUT_PARAMETER                    31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR_FORMAT                        0x00460300 /* -W-4R */
#define NV_UPATT_SET_COLOR_FORMAT_LE                           31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR_FORMAT_LE_X16A8Y8             0x00000001 /* -W--V */
#define NV_UPATT_SET_COLOR_FORMAT_LE_X16A1R5G5B5         0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR_FORMAT_LE_A8R8G8B8            0x00000003 /* -W--V */
#define NV_UPATT_SET_MONOCHROME_FORMAT                   0x00460304 /* -W-4R */
#define NV_UPATT_SET_MONOCHROME_FORMAT_VALUE                   31:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X_8Y                   0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X_1Y                  0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X_64Y                  0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_nv4_image_pattern.ref */
#define NV4_IMAGE_PATTERN                                0x00000044 /* ----C */
#define NV_044                                0x00681FFF:0x00680000 /* -W--D */
#define NV_044_CTX_SWITCH                                0x00680000 /* -W-4R */
#define NV_044_NOP                                       0x00680100 /* -W-4R */
#define NV_044_NOP_PARAMETER                                   31:0 /* -WXVF */
#define NV_044_NOTIFY                                    0x00680104 /* -W-4R */
#define NV_044_NOTIFY_STYLE                                    31:0 /* -WXVF */
#define NV_044_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_044_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_044_NOTIFY__ALIAS_1                    NV_044_SET_NOTIFY /*       */
#define NV_044_SET_NOTIFY_PARAMETER                            31:0 /* -WXVF */
#define NV_044_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_044_SET_CONTEXT_DMA_NOTIFY                    0x00680180 /* -W-4R */
#define NV_044_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -WXVF */
#define NV_044_SET_IMAGE_OUTPUT                          0x00680200 /* -W-4R */
#define NV_044_SET_IMAGE_OUTPUT_PARAMETER                      31:0 /* -W-VF */
#define NV_044_SET_COLOR_FORMAT                          0x00680300 /* -W-4R */
#define NV_044_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_044_SET_COLOR_FORMAT_LE_A16R5G6B5             0x00000001 /* -W--V */
#define NV_044_SET_COLOR_FORMAT_LE_X16A1R5G5B5           0x00000002 /* -W--V */
#define NV_044_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000003 /* -W--V */
#define NV_044_SET_MONOCHROME_FORMAT                     0x00680304 /* -W-4R */
#define NV_044_SET_MONOCHROME_FORMAT_VALUE                     31:0 /* -W-VF */
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_CGA6_M1       0x00000001 /* -W--V */
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_LE_M1         0x00000002 /* -W--V */
#define NV_044_SET_MONOCHROME_SHAPE                      0x00680308 /* -W-4R */
#define NV_044_SET_MONOCHROME_SHAPE_VALUE                      31:0 /* -W-VF */
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_8X_8Y          0x00000000 /* -W--V */
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_64X_1Y         0x00000001 /* -W--V */
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_1X_64Y         0x00000002 /* -W--V */
#define NV_044_SET_PATTERN_SELECT                        0x0068030C /* -W-4R */
#define NV_044_SET_PATTERN_SELECT_VALUE                        31:0 /* -W-VF */
#define NV_044_SET_PATTERN_SELECT_VALUE_MONOCHROME       0x00000001 /* -W--V */
#define NV_044_SET_PATTERN_SELECT_VALUE_COLOR            0x00000002 /* -W--V */
#define NV_044_SET_MONOCHROME_COLOR0                     0x00680310 /* -W-4R */
#define NV_044_SET_MONOCHROME_COLOR0_VALUE                     31:0 /* -W-VF */
#define NV_044_SET_MONOCHROME_COLOR1                     0x00680314 /* -W-4R */
#define NV_044_SET_MONOCHROME_COLOR1_VALUE                     31:0 /* -W-VF */
#define NV_044_SET_MONOCHROME_PATTERN0                   0x00680318 /* -W-4A */
#define NV_044_SET_MONOCHROME_PATTERN0_BITMAP                  31:0 /* -W-VF */
#define NV_044_SET_MONOCHROME_PATTERN1                   0x0068031C /* -W-4A */
#define NV_044_SET_MONOCHROME_PATTERN1_BITMAP                  31:0 /* -W-VF */
#define NV_044_SET_PATTERN_Y8(i)                 (0x00680400+(i)*4) /* -W-4A */
#define NV_044_SET_PATTERN_Y8__SIZE_1                            16 /*       */
#define NV_044_SET_PATTERN_Y8_Y0                                7:0 /* -W-VF */
#define NV_044_SET_PATTERN_Y8_Y1                               15:8 /* -W-VF */
#define NV_044_SET_PATTERN_Y8_Y2                              23:16 /* -W-VF */
#define NV_044_SET_PATTERN_Y8_Y3                              31:24 /* -W-VF */
#define NV_044_SET_PATTERN_R5G6B5(i)             (0x00680500+(i)*4) /* -W-4A */
#define NV_044_SET_PATTERN_R5G6B5__SIZE_1                        32 /*       */
#define NV_044_SET_PATTERN_R5G6B5_BLUE0                         4:0 /* -W-VF */
#define NV_044_SET_PATTERN_R5G6B5_GREEN0                       10:5 /* -W-VF */
#define NV_044_SET_PATTERN_R5G6B5_RED0                        15:11 /* -W-VF */
#define NV_044_SET_PATTERN_R5G6B5_BLUE1                       20:16 /* -W-VF */
#define NV_044_SET_PATTERN_R5G6B5_GREEN1                      26:21 /* -W-VF */
#define NV_044_SET_PATTERN_R5G6B5_RED1                        31:27 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5(i)           (0x00680600+(i)*4) /* -W-4A */
#define NV_044_SET_PATTERN_X1R5G5B5__SIZE_1                      32 /*       */
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE0                       4:0 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN0                      9:5 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_RED0                      14:10 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE0                   15:15 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE1                     20:16 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN1                    25:21 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_RED1                      30:26 /* -W-VF */
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE1                   31:31 /* -W-VF */
#define NV_044_SET_PATTERN_X8R8G8B8(i)           (0x00680700+(i)*4) /* -W-4A */
#define NV_044_SET_PATTERN_X8R8G8B8__SIZE_1                      64 /*       */
#define NV_044_SET_PATTERN_X8R8G8B8_BLUE                        7:0 /* -W-VF */
#define NV_044_SET_PATTERN_X8R8G8B8_GREEN                      15:8 /* -W-VF */
#define NV_044_SET_PATTERN_X8R8G8B8_RED                       23:16 /* -W-VF */
#define NV_044_SET_PATTERN_X8R8G8B8_IGNORE                    31:24 /* -W-VF */
/* usr_nv4_beta_solid.ref */
#define NV4_BETA_SOLID                                   0x00000072 /* ----C */
#define NV_072                                0x00621FFF:0x00620000 /* -W--D */
#define NV_072_CTX_SWITCH                                0x00620000 /* -W-4R */
#define NV_072_CTX_SWITCH_INSTANCE                             15:0 /* -W-UF */
#define NV_072_CTX_SWITCH_CHID                                22:16 /* -W-UF */
#define NV_072_CTX_SWITCH_VOLATILE                            31:31 /* -W-VF */
#define NV_072_CTX_SWITCH_VOLATILE_IGNORE                0x00000000 /* -W--V */
#define NV_072_CTX_SWITCH_VOLATILE_RESET                 0x00000001 /* -W--V */
#define NV_072_NOP                                       0x00620100 /* -W-4R */
#define NV_072_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_072_NOTIFY                                    0x00620104 /* -W-4R */
#define NV_072_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_072_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_072_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_072_SET_NOTIFY                                0x00620104 /* -W-4R */
#define NV_072_SET_NOTIFY__ALIAS_1                    NV_072_NOTIFY /*       */
#define NV_072_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_072_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_072_SET_CONTEXT_DMA_NOTIFY                    0x00620180 /* -W-4R */
#define NV_072_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_072_SET_BETA_OUTPUT                           0x00620200 /* -W-4R */
#define NV_072_SET_BETA_OUTPUT_PARAMETER                       31:0 /* -W-VF */
#define NV_072_SET_BETA_FACTOR                           0x00620300 /* -W-4R */
#define NV_072_SET_BETA_FACTOR_BLUE                             7:0 /* -W-UF */
#define NV_072_SET_BETA_FACTOR_GREEN                           15:8 /* -W-UF */
#define NV_072_SET_BETA_FACTOR_RED                            23:16 /* -W-UF */
#define NV_072_SET_BETA_FACTOR_ALPHA                          31:24 /* -W-UF */
/* usr_nv1_render_solid_lin.ref */
#define NV1_RENDER_SOLID_LIN                             0x0000001C /* ----C */
#define NV_01C                                0x006A1FFF:0x006A0000 /* -W--D */
#define NV_01C_CTX_SWITCH                                0x006A0000 /* -W-4R */
#define NV_01C_CTX_SWITCH_INSTANCE                             15:0 /* -W-UF */
#define NV_01C_CTX_SWITCH_CHID                                22:16 /* -W-UF */
#define NV_01C_CTX_SWITCH_VOLATILE                            31:31 /* -W-VF */
#define NV_01C_CTX_SWITCH_VOLATILE_IGNORE                0x00000000 /* -W--V */
#define NV_01C_CTX_SWITCH_VOLATILE_RESET                 0x00000001 /* -W--V */
#define NV_01C_NOP                                       0x006A0100 /* -W-4R */
#define NV_01C_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_01C_NOTIFY                                    0x006A0104 /* -W-4R */
#define NV_01C_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_01C_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_01C_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_01C_SET_NOTIFY                                0x006A0104 /* -W-4R */
#define NV_01C_SET_NOTIFY__ALIAS_1                    NV_01C_NOTIFY /*       */
#define NV_01C_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_01C_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_01C_SET_PATCH                                 0x006A010C /* -W-4R */
#define NV_01C_SET_PATCH_PARAMETER                             31:0 /* -W-VF */
#define NV_01C_SET_PATCH_PARAMETER_INVALIDATE            0x00000000 /* -W--V */
#define NV_01C_SET_PATCH_PARAMETER_VALIDATE              0x00000001 /* -W--V */
#define NV_01C_SET_CONTEXT_DMA_NOTIFY                    0x006A0180 /* -W-4R */
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_01C_SET_IMAGE_OUTPUT                          0x006A0200 /* -W-4R */
#define NV_01C_SET_IMAGE_OUTPUT_PARAMETER                      31:0 /* -W-VF */
#define NV_01C_SET_COLOR_FORMAT                          0x006A0300 /* -W-4R */
#define NV_01C_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_01C_SET_COLOR_FORMAT_LE_X24Y8                 0x00000001 /* -W--V */
#define NV_01C_SET_COLOR_FORMAT_LE_X17R5G5B5             0x00000002 /* -W--V */
#define NV_01C_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000003 /* -W--V */
#define NV_01C_SET_COLOR_FORMAT_LE_X16Y16                0x00000004 /* -W--V */
#define NV_01C_COLOR                                     0x006A0304 /* -W-4R */
#define NV_01C_COLOR_VALUE                                     31:0 /* -W-VF */
#define NV_01C_LIN_0(i)                          (0x006A0400+(i)*8) /* -W-4A */
#define NV_01C_LIN_0__SIZE_1                                     16 /*       */
#define NV_01C_LIN_0_X                                         15:0 /* -W-SF */
#define NV_01C_LIN_0_Y                                        31:16 /* -W-SF */
#define NV_01C_LIN_1(i)                          (0x006A0404+(i)*8) /* -W-4A */
#define NV_01C_LIN_1__SIZE_1                                     16 /*       */
#define NV_01C_LIN_1_X                                         15:0 /* -W-SF */
#define NV_01C_LIN_1_Y                                        31:16 /* -W-SF */
#define NV_01C_LIN32_0(i)                       (0x006A0480+(i)*16) /* -W-4A */
#define NV_01C_LIN32_0__SIZE_1                                    8 /*       */
#define NV_01C_LIN32_0_X                                       31:0 /* -W-SF */
#define NV_01C_LIN32_1(i)                       (0x006A0484+(i)*16) /* -W-4A */
#define NV_01C_LIN32_1__SIZE_1                                    8 /*       */
#define NV_01C_LIN32_1_Y                                       31:0 /* -W-SF */
#define NV_01C_LIN32_2(i)                       (0x006A0488+(i)*16) /* -W-4A */
#define NV_01C_LIN32_2__SIZE_1                                    8 /*       */
#define NV_01C_LIN32_2_X                                       31:0 /* -W-SF */
#define NV_01C_LIN32_3(i)                       (0x006A048C+(i)*16) /* -W-4A */
#define NV_01C_LIN32_3__SIZE_1                                    8 /*       */
#define NV_01C_LIN32_3_Y                                       31:0 /* -W-SF */
#define NV_01C_POLYLIN(i)                        (0x006A0500+(i)*4) /* -W-4A */
#define NV_01C_POLYLIN__SIZE_1                                   32 /*       */
#define NV_01C_POLYLIN_X                                       15:0 /* -W-SF */
#define NV_01C_POLYLIN_Y                                      31:16 /* -W-SF */
#define NV_01C_POLYLIN32_0(i)                    (0x006A0580+(i)*8) /* -W-4A */
#define NV_01C_POLYLIN32_0__SIZE_1                               16 /*       */
#define NV_01C_POLYLIN32_0_X                                   31:0 /* -W-SF */
#define NV_01C_POLYLIN32_1(i)                    (0x006A0584+(i)*8) /* -W-4A */
#define NV_01C_POLYLIN32_1__SIZE_1                               16 /*       */
#define NV_01C_POLYLIN32_1_Y                                   31:0 /* -W-SF */
#define NV_01C_CPOLYLIN_0(i)                     (0x006A0600+(i)*8) /* -W-4A */
#define NV_01C_CPOLYLIN_0__SIZE_1                                16 /*       */
#define NV_01C_CPOLYLIN_0_COLOR                                31:0 /* -W-VF */
#define NV_01C_CPOLYLIN_1(i)                     (0x006A0604+(i)*8) /* -W-4A */
#define NV_01C_CPOLYLIN_1__SIZE_1                                16 /*       */
#define NV_01C_CPOLYLIN_1_X                                    15:0 /* -W-SF */
#define NV_01C_CPOLYLIN_1_Y                                   31:16 /* -W-SF */
/* usr_nv4_render_solid_lin.ref */
#define NV4_RENDER_SOLID_LIN                             0x0000005C /* ----C */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_NOP                                      0x004A0100 /* -W-4R */
#define NV_ULIN_NOP_PARAMETER                                  31:0 /* -W-VF */
#define NV_ULIN_NOTIFY                                   0x004A0104 /* -W-4R */
#define NV_ULIN_NOTIFY_STYLE                                   31:0 /* -W-VF */
#define NV_ULIN_NOTIFY_STYLE_WRITE_ONLY                  0x00000000 /* -W--V */
#define NV_ULIN_NOTIFY_STYLE_WRITE_THEN_AWAKEN           0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY__ALIAS_1                  NV_ULIN_NOTIFY /*       */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_SET_PATCH                                0x004A010C /* -W-4R */
#define NV_ULIN_SET_PATCH_PARAMETER                            31:0 /* -W-VF */
#define NV_ULIN_SET_PATCH_PARAMETER_INVALIDATE           0x00000000 /* -W--V */
#define NV_ULIN_SET_PATCH_PARAMETER_VALIDATE             0x00000001 /* -W--V */
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY                   0x004A0180 /* -W-4R */
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_PARAMETER               31:0 /* -W-VF */
#define NV_ULIN_SET_IMAGE_OUTPUT                         0x004A0200 /* -W-4R */
#define NV_ULIN_SET_IMAGE_OUTPUT_PARAMETER                     31:0 /* -W-VF */
#define NV_ULIN_SET_COLOR_FORMAT                         0x004A0300 /* -W-4R */
#define NV_ULIN_SET_COLOR_FORMAT_LE                            31:0 /* -W-VF */
#define NV_ULIN_SET_COLOR_FORMAT_LE_X16R5G6B5            0x00000001 /* -W--V */
#define NV_ULIN_SET_COLOR_FORMAT_LE_X17R5G5B5            0x00000002 /* -W--V */
#define NV_ULIN_SET_COLOR_FORMAT_LE_X8R8G8B8             0x00000003 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_nv4_render_solid_rectangle.ref */
#define NV_RENDER_SOLID_RECTANGLE                        0x0000005E /* ----C */
#define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_NOP                                     0x00470100 /* -W-4R */
#define NV_URECT_NOP_PARAMETER                                 31:0 /* -W-VF */
#define NV_URECT_NOTIFY                                  0x00470104 /* -W-4R */
#define NV_URECT_NOTIFY_STYLE                                  31:0 /* -W-VF */
#define NV_URECT_NOTIFY_STYLE_WRITE_ONLY                 0x00000000 /* -W--V */
#define NV_URECT_NOTIFY_STYLE_WRITE_THEN_AWAKEN          0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
#define NV_URECT_SET_NOTIFY__ALIAS_1                NV_URECT_NOTIFY /*       */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_SET_PATCH                               0x0047010C /* -W-4R */
#define NV_URECT_SET_PATCH_PARAMETER                           31:0 /* -W-VF */
#define NV_URECT_SET_PATCH_PARAMETER_INVALIDATE          0x00000000 /* -W--V */
#define NV_URECT_SET_PATCH_PARAMETER_VALIDATE            0x00000001 /* -W--V */
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY                  0x00470180 /* -W-4R */
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_PARAMETER              31:0 /* -W-VF */
#define NV_URECT_SET_IMAGE_OUTPUT                        0x00470200 /* -W-4R */
#define NV_URECT_SET_IMAGE_OUTPUT_PARAMETER                    31:0 /* -W-VF */
#define NV_URECT_SET_COLOR_FORMAT                        0x00470300 /* -W-4R */
#define NV_URECT_SET_COLOR_FORMAT_LE                           31:0 /* -W-VF */
#define NV_URECT_SET_COLOR_FORMAT_LE_X16R5G6B5           0x00000001 /* -W--V */
#define NV_URECT_SET_COLOR_FORMAT_LE_X17R5G5B5           0x00000002 /* -W--V */
#define NV_URECT_SET_COLOR_FORMAT_LE_X8R8G8B8            0x00000003 /* -W--V */
#define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_nv4_render_solid_triangle.ref */
#define NV_RENDER_SOLID_TRIANGLE                         0x0000005D /* ----C */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_NOP                                      0x004B0100 /* -W-4R */
#define NV_UTRI_NOP_PARAMETER                                  31:0 /* -W-VF */
#define NV_UTRI_NOTIFY                                   0x004B0104 /* -W-4R */
#define NV_UTRI_NOTIFY_STYLE                                   31:0 /* -W-VF */
#define NV_UTRI_NOTIFY_STYLE_WRITE_ONLY                  0x00000000 /* -W--V */
#define NV_UTRI_NOTIFY_STYLE_WRITE_THEN_AWAKEN           0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY__ALIAS_1                  NV_UTRI_NOTIFY /*       */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_SET_PATCH                                0x004B010C /* -W-4R */
#define NV_UTRI_SET_PATCH_PARAMETER                            31:0 /* -W-VF */
#define NV_UTRI_SET_PATCH_PARAMETER_INVALIDATE           0x00000000 /* -W--V */
#define NV_UTRI_SET_PATCH_PARAMETER_VALIDATE             0x00000001 /* -W--V */
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY                   0x004B0180 /* -W-4R */
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_PARAMETER               31:0 /* -W-VF */
#define NV_UTRI_SET_IMAGE_OUTPUT                         0x004B0200 /* -W-4R */
#define NV_UTRI_SET_IMAGE_OUTPUT_PARAMETER                     31:0 /* -W-VF */
#define NV_UTRI_SET_COLOR_FORMAT                         0x004B0300 /* -W-4R */
#define NV_UTRI_SET_COLOR_FORMAT_LE                            31:0 /* -W-VF */
#define NV_UTRI_SET_COLOR_FORMAT_LE_X16R5G6B5            0x00000001 /* -W--V */
#define NV_UTRI_SET_COLOR_FORMAT_LE_X17R5G5B5            0x00000002 /* -W--V */
#define NV_UTRI_SET_COLOR_FORMAT_LE_X8R8G8B8             0x00000003 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_nv4_image_blit.ref */
#define NV_IMAGE_BLIT                                    0x0000005F /* ----C */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_NOP                                     0x00500100 /* -W-4R */
#define NV_UBLIT_NOP_PARAMETER                                 31:0 /* -W-VF */
#define NV_UBLIT_NOTIFY                                  0x00500104 /* -W-4R */
#define NV_UBLIT_NOTIFY_STYLE                                  31:0 /* -W-VF */
#define NV_UBLIT_NOTIFY_STYLE_WRITE_ONLY                 0x00000000 /* -W--V */
#define NV_UBLIT_NOTIFY_STYLE_WRITE_THEN_AWAKEN          0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY__ALIAS_1                NV_UBLIT_NOTIFY /*       */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_SET_PATCH                               0x0050010C /* -W-4R */
#define NV_UBLIT_SET_PATCH_PARAMETER                           31:0 /* -W-VF */
#define NV_UBLIT_SET_PATCH_PARAMETER_INVALIDATE          0x00000000 /* -W--V */
#define NV_UBLIT_SET_PATCH_PARAMETER_VALIDATE            0x00000001 /* -W--V */
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY                  0x00500180 /* -W-4R */
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_PARAMETER              31:0 /* -W-VF */
#define NV_UBLIT_SET_IMAGE_OUTPUT                        0x00500200 /* -W-4R */
#define NV_UBLIT_SET_IMAGE_OUTPUT_PARAMETER                    31:0 /* -W-VF */
#define NV_UBLIT_SET_IMAGE_INPUT                         0x00500204 /* -W-4R */
#define NV_UBLIT_SET_IMAGE_INPUT_PARAMETER                     31:0 /* -W-VF */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-UF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-UF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-UF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-UF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_nv4_indexed_image_from_cpu.ref */
#define NV4_INDEXED_IMAGE_FROM_CPU                       0x00000060 /* ----C */
#define NV_060                                0x00691FFF:0x00690000 /* -W--D */
#define NV_060_CTX_SWITCH                                0x00690000 /* -W-4R */
#define NV_060_CTX_SWITCH_INSTANCE                             15:0 /* -W-UF */
#define NV_060_CTX_SWITCH_CHID                                22:16 /* -W-UF */
#define NV_060_CTX_SWITCH_VOLATILE                            31:31 /* -W-VF */
#define NV_060_CTX_SWITCH_VOLATILE_IGNORE                0x00000000 /* -W--V */
#define NV_060_CTX_SWITCH_VOLATILE_RESET                 0x00000001 /* -W--V */
#define NV_060_NOP                                       0x00690100 /* -W-4R */
#define NV_060_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_060_NOTIFY                                    0x00690104 /* -W-4R */
#define NV_060_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_060_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_060_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_060_SET_NOTIFY                                0x00690104 /* -W-4R */
#define NV_060_SET_NOTIFY__ALIAS_1                    NV_060_NOTIFY /*       */
#define NV_060_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_060_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_060_SET_PATCH                                 0x0069010C /* -W-4R */
#define NV_060_SET_PATCH_PARAMETER                             31:0 /* -W-VF */
#define NV_060_SET_PATCH_PARAMETER_INVALIDATE            0x00000000 /* -W--V */
#define NV_060_SET_PATCH_PARAMETER_VALIDATE              0x00000001 /* -W--V */
#define NV_060_SET_CONTEXT_DMA_NOTIFY                    0x00690180 /* -W-4R */
#define NV_060_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_060_SET_CONTEXT_DMA_LUT                       0x00690184 /* -W-4R */
#define NV_060_SET_CONTEXT_DMA_LUT_PARAMETER                   31:0 /* -W-VF */
#define NV_060_SET_IMAGE_OUTPUT                          0x00690200 /* -W-4R */
#define NV_060_SET_IMAGE_OUTPUT_PARAMETER                      31:0 /* -W-VF */
#define NV_060_SET_COLOR_FORMAT                          0x006903E8 /* -W-4R */
#define NV_060_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_060_SET_COLOR_FORMAT_LE_R5G6B5                0x00000001 /* -W--V */
#define NV_060_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000002 /* -W--V */
#define NV_060_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000003 /* -W--V */
#define NV_060_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000004 /* -W--V */
#define NV_060_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000005 /* -W--V */
#define NV_060_INDEX_FORMAT                              0x006903EC /* -W-4R */
#define NV_060_INDEX_FORMAT_LE                                 31:0 /* -W-VF */
#define NV_060_INDEX_FORMAT_LE_I8                        0x00000000 /* -W--V */
#define NV_060_INDEX_FORMAT_LE_I4                        0x00000001 /* -W--V */
#define NV_060_LUT_OFFSET                                0x006903F0 /* -W-4R */
#define NV_060_LUT_OFFSET_ARGUMENT                             31:0 /* -W-UF */
#define NV_060_POINT                                     0x006903F4 /* -W-4R */
#define NV_060_POINT_X                                         15:0 /* -W-SF */
#define NV_060_POINT_Y                                        31:16 /* -W-SF */
#define NV_060_SIZE_OUT                                  0x006903F8 /* -W-4R */
#define NV_060_SIZE_OUT_WIDTH                                  15:0 /* -W-UF */
#define NV_060_SIZE_OUT_HEIGHT                                31:16 /* -W-UF */
#define NV_060_SIZE_IN                                   0x006903FC /* -W-4R */
#define NV_060_SIZE_IN_WIDTH                                   15:0 /* -W-UF */
#define NV_060_SIZE_IN_HEIGHT                                 31:16 /* -W-UF */
#define NV_060_COLOR(i)                          (0x00690400+(i)*4) /* -W-4A */
#define NV_060_COLOR__SIZE_1                                   1792 /*       */
#define NV_060_COLOR_VALUE                                     31:0 /* -W-VF */
/* usr_nv5_indexed_image_from_cpu.ref */
#define NV5_INDEXED_IMAGE_FROM_CPU                       0x00000064 /* ----C */
#define NV_064                                0x00651FFF:0x00650000 /* -W--D */
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU                0x00650000 /* -W-4R */
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_HANDLE               31:0 /* -WXVF */
#define NV_064_NOP                                       0x00650100 /* -W-4R */
#define NV_064_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_064_NOTIFY                                    0x00650104 /* -W-4R */
#define NV_064_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_064_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_064_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_064_SET_NOTIFY                                0x00650104 /* -W-4R */
#define NV_064_SET_NOTIFY__ALIAS_1                    NV_064_NOTIFY /*       */
#define NV_064_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_064_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_064_SET_CONTEXT_DMA_NOTIFY                    0x00650180 /* -W-4R */
#define NV_064_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_DMA_LUT                       0x00650184 /* -W-4R */
#define NV_064_SET_CONTEXT_DMA_LUT_PARAMETER                   31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_COLOR_KEY                     0x00650188 /* -W-4R */
#define NV_064_SET_CONTEXT_COLOR_KEY_PARAMETER                 31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE                0x0065018C /* -W-4R */
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER            31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_PATTERN                       0x00650190 /* -W-4R */
#define NV_064_SET_CONTEXT_PATTERN_PARAMETER                   31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_ROP                           0x00650194 /* -W-4R */
#define NV_064_SET_CONTEXT_ROP_PARAMETER                       31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_BETA1                         0x00650198 /* -W-4R */
#define NV_064_SET_CONTEXT_BETA1_PARAMETER                     31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_BETA4                         0x0065019C /* -W-4R */
#define NV_064_SET_CONTEXT_BETA4_PARAMETER                     31:0 /* -W-VF */
#define NV_064_SET_CONTEXT_SURFACE                       0x006501A0 /* -W-4R */
#define NV_064_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_064_SET_COLOR_CONVERSION                      0x006503E0 /* -W-4R */
#define NV_064_SET_COLOR_CONVERSION_TYPE                       31:0 /* -W-VF */
#define NV_064_SET_COLOR_CONVERSION_TYPE_DITHER          0x00000000 /* -W--V */
#define NV_064_SET_COLOR_CONVERSION_TYPE_TRUNCATE        0x00000001 /* -W--V */
#define NV_064_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE  0x00000002 /* -W--V */
#define NV_064_SET_OPERATION                             0x006503E4 /* -W-4R */
#define NV_064_SET_OPERATION_MODE                              31:0 /* -W-VF */
#define NV_064_SET_OPERATION_MODE_SRCCOPY_AND            0x00000000 /* -W--V */
#define NV_064_SET_OPERATION_MODE_ROP_AND                0x00000001 /* -W--V */
#define NV_064_SET_OPERATION_MODE_BLEND_AND              0x00000002 /* -W--V */
#define NV_064_SET_OPERATION_MODE_SRCCOPY                0x00000003 /* -W--V */
#define NV_064_SET_OPERATION_MODE_SRCCOPY_PREMULT        0x00000004 /* -W--V */
#define NV_064_SET_OPERATION_MODE_BLEND_PREMULT          0x00000005 /* -W--V */
#define NV_064_SET_COLOR_FORMAT                          0x006503E8 /* -W-4R */
#define NV_064_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_064_SET_COLOR_FORMAT_LE_R5G6B5                0x00000001 /* -W--V */
#define NV_064_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000002 /* -W--V */
#define NV_064_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000003 /* -W--V */
#define NV_064_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000004 /* -W--V */
#define NV_064_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000005 /* -W--V */
#define NV_064_INDEX_FORMAT                              0x006503EC /* -W-4R */
#define NV_064_INDEX_FORMAT_LE                                 31:0 /* -W-VF */
#define NV_064_INDEX_FORMAT_LE_I8                        0x00000000 /* -W--V */
#define NV_064_INDEX_FORMAT_LE_I4                        0x00000001 /* -W--V */
#define NV_064_LUT_OFFSET                                0x006503F0 /* -W-4R */
#define NV_064_LUT_OFFSET_ARGUMENT                             31:0 /* -W-UF */
#define NV_064_POINT                                     0x006503F4 /* -W-4R */
#define NV_064_POINT_X                                         15:0 /* -W-SF */
#define NV_064_POINT_Y                                        31:16 /* -W-SF */
#define NV_064_SIZE_OUT                                  0x006503F8 /* -W-4R */
#define NV_064_SIZE_OUT_WIDTH                                  15:0 /* -W-UF */
#define NV_064_SIZE_OUT_HEIGHT                                31:16 /* -W-UF */
#define NV_064_SIZE_IN                                   0x006503FC /* -W-4R */
#define NV_064_SIZE_IN_WIDTH                                   15:0 /* -W-UF */
#define NV_064_SIZE_IN_HEIGHT                                 31:16 /* -W-UF */
#define NV_064_INDICES(i)                        (0x00650400+(i)*4) /* -W-4A */
#define NV_064_INDICES__SIZE_1                                 1792 /*       */
#define NV_064_INDICES_VALUE                                   31:0 /* -W-VF */
/* usr_nv4_image_from_cpu.ref */
#define NV_IMAGE_FROM_CPU                                0x00000061 /* ----C */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_NOP                                    0x00510100 /* -W-4R */
#define NV_UIMAGE_NOP_PARAMETER                                31:0 /* -W-VF */
#define NV_UIMAGE_NOTIFY                                 0x00510104 /* -W-4R */
#define NV_UIMAGE_NOTIFY_STYLE                                 31:0 /* -W-VF */
#define NV_UIMAGE_NOTIFY_STYLE_WRITE_ONLY                0x00000000 /* -W--V */
#define NV_UIMAGE_NOTIFY_STYLE_WRITE_THEN_AWAKEN         0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY__ALIAS_1              NV_UIMAGE_NOTIFY /*       */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_SET_PATCH                              0x0051010C /* -W-4R */
#define NV_UIMAGE_SET_PATCH_PARAMETER                          31:0 /* -W-VF */
#define NV_UIMAGE_SET_PATCH_PARAMETER_INVALIDATE         0x00000000 /* -W--V */
#define NV_UIMAGE_SET_PATCH_PARAMETER_VALIDATE           0x00000001 /* -W--V */
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY                 0x00510180 /* -W-4R */
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_PARAMETER             31:0 /* -W-VF */
#define NV_UIMAGE_SET_IMAGE_OUTPUT                       0x00510200 /* -W-4R */
#define NV_UIMAGE_SET_IMAGE_OUTPUT_PARAMETER                   31:0 /* -W-VF */
#define NV_UIMAGE_SET_COLOR_FORMAT                       0x00510300 /* -W-4R */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE                          31:0 /* -W-VF */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_R5G6B5             0x00000001 /* -W--V */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_A1R5G5B5           0x00000002 /* -W--V */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_X1R5G5B5           0x00000003 /* -W--V */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_A8R8G8B8           0x00000004 /* -W--V */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_X8R8G8B8           0x00000005 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_nv5_image_from_cpu.ref */
#define NV5_IMAGE_FROM_CPU                               0x00000065 /* ----C */
#define NV_065                                0x00661FFF:0x00660000 /* -W--D */
#define NV_065_NV5_IMAGE_FROM_CPU                        0x00660000 /* -W-4R */
#define NV_065_NV5_IMAGE_FROM_CPU_HANDLE                       31:0 /* -WXVF */
#define NV_065_NOP                                       0x00660100 /* -W-4R */
#define NV_065_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_065_NOTIFY                                    0x00660104 /* -W-4R */
#define NV_065_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_065_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_065_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_065_SET_NOTIFY                                0x00660104 /* -W-4R */
#define NV_065_SET_NOTIFY__ALIAS_1                    NV_065_NOTIFY /*       */
#define NV_065_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_065_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_065_SET_CONTEXT_DMA_NOTIFY                    0x00660180 /* -W-4R */
#define NV_065_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_COLOR_KEY                     0x00660184 /* -W-4R */
#define NV_065_SET_CONTEXT_COLOR_KEY_PARAMETER                 31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE                0x00660188 /* -W-4R */
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER            31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_PATTERN                       0x0066018C /* -W-4R */
#define NV_065_SET_CONTEXT_PATTERN_PARAMETER                   31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_ROP                           0x00660190 /* -W-4R */
#define NV_065_SET_CONTEXT_ROP_PARAMETER                       31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_BETA1                         0x00660194 /* -W-4R */
#define NV_065_SET_CONTEXT_BETA1_PARAMETER                     31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_BETA4                         0x00660198 /* -W-4R */
#define NV_065_SET_CONTEXT_BETA4_PARAMETER                     31:0 /* -W-VF */
#define NV_065_SET_CONTEXT_SURFACE                       0x0066019C /* -W-4R */
#define NV_065_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_065_SET_COLOR_CONVERSION                      0x006602F8 /* -W-4R */
#define NV_065_SET_COLOR_CONVERSION_TYPE                       31:0 /* -W-VF */
#define NV_065_SET_COLOR_CONVERSION_TYPE_DITHER          0x00000000 /* -W--V */
#define NV_065_SET_COLOR_CONVERSION_TYPE_TRUNCATE        0x00000001 /* -W--V */
#define NV_065_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE  0x00000002 /* -W--V */
#define NV_065_SET_OPERATION                             0x006602FC /* -W-4R */
#define NV_065_SET_OPERATION_MODE                              31:0 /* -W-VF */
#define NV_065_SET_OPERATION_MODE_SRCCOPY_AND            0x00000000 /* -W--V */
#define NV_065_SET_OPERATION_MODE_ROP_AND                0x00000001 /* -W--V */
#define NV_065_SET_OPERATION_MODE_BLEND_AND              0x00000002 /* -W--V */
#define NV_065_SET_OPERATION_MODE_SRCCOPY                0x00000003 /* -W--V */
#define NV_065_SET_OPERATION_MODE_SRCCOPY_PREMULT        0x00000004 /* -W--V */
#define NV_065_SET_OPERATION_MODE_BLEND_PREMULT          0x00000005 /* -W--V */
#define NV_065_SET_COLOR_FORMAT                          0x00660300 /* -W-4R */
#define NV_065_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_065_SET_COLOR_FORMAT_LE_R5G6B5                0x00000001 /* -W--V */
#define NV_065_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000002 /* -W--V */
#define NV_065_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000003 /* -W--V */
#define NV_065_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000004 /* -W--V */
#define NV_065_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000005 /* -W--V */
#define NV_065_POINT                                     0x00660304 /* -W-4R */
#define NV_065_POINT_X                                         15:0 /* -W-SF */
#define NV_065_POINT_Y                                        31:16 /* -W-SF */
#define NV_065_SIZE_OUT                                  0x00660308 /* -W-4R */
#define NV_065_SIZE_OUT_WIDTH                                  15:0 /* -W-UF */
#define NV_065_SIZE_OUT_HEIGHT                                31:16 /* -W-UF */
#define NV_065_SIZE_IN                                   0x0066030C /* -W-4R */
#define NV_065_SIZE_IN_WIDTH                                   15:0 /* -W-UF */
#define NV_065_SIZE_IN_HEIGHT                                 31:16 /* -W-UF */
#define NV_065_COLOR(i)                          (0x00660400+(i)*4) /* -W-4A */
#define NV_065_COLOR__SIZE_1                                   1792 /*       */
#define NV_065_COLOR_VALUE                                     31:0 /* -W-VF */
/* usr_nv10_image_from_cpu.ref */
#define NV10_IMAGE_FROM_CPU                              0x0000008A /* ----C */
#define NV_08A                                0x00541FFF:0x00540000 /* -W--D */
#define NV_08A_NV10_IMAGE_FROM_CPU                       0x00540000 /* -W-4R */
#define NV_08A_NV10_IMAGE_FROM_CPU_HANDLE                      31:0 /* -WXVF */
#define NV_08A_NOP                                       0x00540100 /* -W-4R */
#define NV_08A_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_08A_NOTIFY                                    0x00540104 /* -W-4R */
#define NV_08A_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_08A_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_08A_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_08A_SET_NOTIFY                                0x00540104 /* -W-4R */
#define NV_08A_SET_NOTIFY__ALIAS_1                    NV_08A_NOTIFY /*       */
#define NV_08A_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_08A_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_08A_WAIT_FOR_IDLE                             0x00540108 /* -W-4R */
#define NV_08A_WAIT_FOR_IDLE_PARAMETER                         31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_DMA_NOTIFY                    0x00540180 /* -W-4R */
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_COLOR_KEY                     0x00540184 /* -W-4R */
#define NV_08A_SET_CONTEXT_COLOR_KEY_PARAMETER                 31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE                0x00540188 /* -W-4R */
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER            31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_PATTERN                       0x0054018C /* -W-4R */
#define NV_08A_SET_CONTEXT_PATTERN_PARAMETER                   31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_ROP                           0x00540190 /* -W-4R */
#define NV_08A_SET_CONTEXT_ROP_PARAMETER                       31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_BETA1                         0x00540194 /* -W-4R */
#define NV_08A_SET_CONTEXT_BETA1_PARAMETER                     31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_BETA4                         0x00540198 /* -W-4R */
#define NV_08A_SET_CONTEXT_BETA4_PARAMETER                     31:0 /* -W-VF */
#define NV_08A_SET_CONTEXT_SURFACE                       0x0054019C /* -W-4R */
#define NV_08A_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_08A_SET_COLOR_CONVERSION                      0x005402F8 /* -W-4R */
#define NV_08A_SET_COLOR_CONVERSION_TYPE                       31:0 /* -W-VF */
#define NV_08A_SET_COLOR_CONVERSION_TYPE_DITHER          0x00000000 /* -W--V */
#define NV_08A_SET_COLOR_CONVERSION_TYPE_TRUNCATE        0x00000001 /* -W--V */
#define NV_08A_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE  0x00000002 /* -W--V */
#define NV_08A_SET_OPERATION                             0x005402FC /* -W-4R */
#define NV_08A_SET_OPERATION_MODE                              31:0 /* -W-VF */
#define NV_08A_SET_OPERATION_MODE_SRCCOPY_AND            0x00000000 /* -W--V */
#define NV_08A_SET_OPERATION_MODE_ROP_AND                0x00000001 /* -W--V */
#define NV_08A_SET_OPERATION_MODE_BLEND_AND              0x00000002 /* -W--V */
#define NV_08A_SET_OPERATION_MODE_SRCCOPY                0x00000003 /* -W--V */
#define NV_08A_SET_OPERATION_MODE_SRCCOPY_PREMULT        0x00000004 /* -W--V */
#define NV_08A_SET_OPERATION_MODE_BLEND_PREMULT          0x00000005 /* -W--V */
#define NV_08A_SET_COLOR_FORMAT                          0x00540300 /* -W-4R */
#define NV_08A_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_08A_SET_COLOR_FORMAT_LE_R5G6B5                0x00000001 /* -W--V */
#define NV_08A_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000002 /* -W--V */
#define NV_08A_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000003 /* -W--V */
#define NV_08A_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000004 /* -W--V */
#define NV_08A_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000005 /* -W--V */
#define NV_08A_POINT                                     0x00540304 /* -W-4R */
#define NV_08A_POINT_X                                         15:0 /* -W-SF */
#define NV_08A_POINT_Y                                        31:16 /* -W-SF */
#define NV_08A_SIZE_OUT                                  0x00540308 /* -W-4R */
#define NV_08A_SIZE_OUT_WIDTH                                  15:0 /* -W-UF */
#define NV_08A_SIZE_OUT_HEIGHT                                31:16 /* -W-UF */
#define NV_08A_SIZE_IN                                   0x0054030C /* -W-4R */
#define NV_08A_SIZE_IN_WIDTH                                   15:0 /* -W-UF */
#define NV_08A_SIZE_IN_HEIGHT                                 31:16 /* -W-UF */
#define NV_08A_COLORA(i)                         (0x00540400+(i)*8) /* -W-4A */
#define NV_08A_COLORA__SIZE_1                                   896 /*       */
#define NV_08A_COLOR_VALUE                                     31:0 /* -W-VF */
#define NV_08A_COLORB(i)                         (0x00540404+(i)*8) /* -W-4A */
#define NV_08A_COLORB__SIZE_1                                   896 /*       */
#define NV_08A_COLORB_VALUE                                    31:0 /* -W-VF */
/* usr_nv10_texture_from_cpu.ref */
#define NV10_TEXTURE_FROM_CPU                            0x0000007B /* ----C */
#define NV_07B                                0x00531FFF:0x00530000 /* -W--D */
#define NV_07B_NV10_TEXTURE_FROM_CPU                     0x00530000 /* -W-4R */
#define NV_07B_NV10_TEXTURE_FROM_CPU_HANDLE                    31:0 /* -WXVF */
#define NV_07B_NOP                                       0x00530100 /* -W-4R */
#define NV_07B_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_07B_PM_TRIGGER                                0x00530140 /* -W-4R */
#define NV_07B_PM_TRIGGER_PARAMETER                            31:0 /* -W-VF */
#define NV_07B_NOTIFY                                    0x00530104 /* -W-4R */
#define NV_07B_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_07B_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_07B_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_07B_SET_NOTIFY                                0x00530104 /* -W-4R */
#define NV_07B_SET_NOTIFY__ALIAS_1                    NV_07B_NOTIFY /*       */
#define NV_07B_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_07B_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_07B_WAIT_FOR_IDLE                             0x00530108 /* -W-4R */
#define NV_07B_WAIT_FOR_IDLE_PARAMETER                         31:0 /* -W-VF */
#define NV_07B_SET_CONTEXT_DMA_NOTIFY                    0x00530180 /* -W-4R */
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_07B_SET_CONTEXT_SURFACE                       0x00530184 /* -W-4R */
#define NV_07B_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_07B_SET_COLOR_FORMAT                          0x00530300 /* -W-4R */
#define NV_07B_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_07B_SET_COLOR_FORMAT_LE_R5G6B5                0x00000001 /* -W--V */
#define NV_07B_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000002 /* -W--V */
#define NV_07B_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000003 /* -W--V */
#define NV_07B_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000004 /* -W--V */
#define NV_07B_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000005 /* -W--V */
#define NV_07B_POINT                                     0x00530304 /* -W-4R */
#define NV_07B_POINT_X                                         15:0 /* -W-SF */
#define NV_07B_POINT_Y                                        31:16 /* -W-SF */
#define NV_07B_SIZE                                      0x00530308 /* -W-4R */
#define NV_07B_SIZE_WIDTH                                      15:0 /* -W-UF */
#define NV_07B_SIZE_HEIGHT                                    31:16 /* -W-UF */
#define NV_07B_CLIP_HORIZONTAL                           0x0053030C /* -W-4R */
#define NV_07B_CLIP_HORIZONTAL_X                               15:0 /* -W-UF */
#define NV_07B_CLIP_HORIZONTAL_WIDTH                          31:16 /* -W-UF */
#define NV_07B_CLIP_VERTICAL                             0x00530310 /* -W-4R */
#define NV_07B_CLIP_VERTICAL_Y                                 15:0 /* -W-UF */
#define NV_07B_CLIP_VERTICAL_HEIGHT                           31:16 /* -W-UF */
#define NV_07B_COLORA(i)                         (0x00530400+(i)*8) /* -W-4A */
#define NV_07B_COLORA__SIZE_1                                   896 /*       */
#define NV_07B_COLOR_VALUE                                     31:0 /* -W-VF */
#define NV_07B_COLORB(i)                         (0x00530404+(i)*8) /* -W-4A */
#define NV_07B_COLORB__SIZE_1                                   896 /*       */
#define NV_07B_COLORB_VALUE                                    31:0 /* -W-VF */
/* usr_nv4_scaled_image_from_mem.ref */
#define NV_SCALED_IMAGE_FROM_MEMORY                      0x00000077 /* ----C */
#define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
#define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
#define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USCALED_NOP                                   0x004E0100 /* -W-4R */
#define NV_USCALED_NOP_PARAMETER                               31:0 /* -W-VF */
#define NV_USCALED_NOTIFY                                0x004e0104 /* -W-4R */
#define NV_USCALED_NOTIFY_STYLE                                31:0 /* -W-VF */
#define NV_USCALED_NOTIFY_STYLE_WRITE_ONLY               0x00000000 /* -W--V */
#define NV_USCALED_NOTIFY_STYLE_WRITE_THEN_AWAKEN        0x00000001 /* -W--V */
#define NV_USCALED_SET_NOTIFY                            0x004e0104 /* -W-4R */
#define NV_USCALED_SET_NOTIFY__ALIAS_1            NV_USCALED_NOTIFY /*       */
#define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USCALED_SET_PATCH                             0x004e010C /* -W-4R */
#define NV_USCALED_SET_PATCH_PARAMETER                         31:0 /* -W-VF */
#define NV_USCALED_SET_PATCH_PARAMETER_INVALIDATE        0x00000000 /* -W--V */
#define NV_USCALED_SET_PATCH_PARAMETER_VALIDATE          0x00000001 /* -W--V */
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY                0x004e0180 /* -W-4R */
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_PARAMETER            31:0 /* -W-VF */
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE                 0x004e0184 /* -W-4R */
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_PARAMETER             31:0 /* -W-VF */
#define NV_USCALED_SET_IMAGE_OUTPUT                      0x004e0200 /* -W-4R */
#define NV_USCALED_SET_IMAGE_OUTPUT_PARAMETER                  31:0 /* -W-VF */
#define NV_USCALED_SET_COLOR_FORMAT                      0x004E0300 /* -W-4R */
#define NV_USCALED_SET_COLOR_FORMAT_LE                         31:0 /* -W-VF */
#define NV_USCALED_SET_COLOR_FORMAT_LE_A1R5G5B5          0x00000001 /* -W--V */
#define NV_USCALED_SET_COLOR_FORMAT_LE_X1R5G5B5          0x00000002 /* -W--V */
#define NV_USCALED_SET_COLOR_FORMAT_LE_A8R8G8B8          0x00000003 /* -W--V */
#define NV_USCALED_SET_COLOR_FORMAT_LE_X8R8G8B8          0x00000004 /* -W--V */
#define NV_USCALED_SET_COLOR_FORMAT_LE_V8YB8U8YA8        0x00000005 /* -W--V */
#define NV_USCALED_SET_COLOR_FORMAT_LE_YB8V8YA8U8        0x00000006 /* -W--V */
#define NV_USCALED_SET_COLOR_FORMAT_LE_R5G6B5            0x00000007 /* -W--V */
#define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
#define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
#define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
#define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
#define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
#define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_USCALED_FORMAT                                0x004E0404 /* -W-4R */
#define NV_USCALED_FORMAT_PITCH                                15:0 /* -W-SF */
#define NV_USCALED_FORMAT_ORIGIN                              23:16 /* -W-VF */
#define NV_USCALED_FORMAT_ORIGIN_CENTER                  0x00000001 /* -W--V */
#define NV_USCALED_FORMAT_ORIGIN_CORNER                  0x00000002 /* -W--V */
#define NV_USCALED_FORMAT_INTERPOLATOR                        31:24 /* -W-VF */
#define NV_USCALED_FORMAT_INTERPOLATOR_ZOH               0x00000000 /* -W--V */
#define NV_USCALED_FORMAT_INTERPOLATOR_FOH               0x00000001 /* -W--V */
#define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
#define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
#define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
#define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
#define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
#define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
#define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
#define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
/* usr_nv5_scaled_image_from_mem.ref */
#define NV5_SCALED_IMAGE_FROM_MEMORY                     0x00000063 /* ----C */
#define NV_063                                0x00641FFF:0x00640000 /* -W--D */
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY              0x00640000 /* -W-4R */
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_HANDLE             31:0 /* -WXVF */
#define NV_063_NOP                                       0x00640100 /* -W-4R */
#define NV_063_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_063_NOTIFY                                    0x00640104 /* -W-4R */
#define NV_063_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_063_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_063_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_063_SET_NOTIFY                                0x00640104 /* -W-4R */
#define NV_063_SET_NOTIFY__ALIAS_1                    NV_063_NOTIFY /*       */
#define NV_063_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_063_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_063_SET_CONTEXT_DMA_NOTIFY                    0x00640180 /* -W-4R */
#define NV_063_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_063_SET_CONTEXT_DMA_IMAGE                     0x00640184 /* -W-4R */
#define NV_063_SET_CONTEXT_DMA_IMAGE_PARAMETER                 31:0 /* -W-VF */
#define NV_063_SET_CONTEXT_PATTERN                       0x00640188 /* -W-4R */
#define NV_063_SET_CONTEXT_PATTERN_PARAMETER                   31:0 /* -W-VF */
#define NV_063_SET_CONTEXT_ROP                           0x0064018C /* -W-4R */
#define NV_063_SET_CONTEXT_ROP_PARAMETER                       31:0 /* -W-VF */
#define NV_063_SET_CONTEXT_BETA1                         0x00640190 /* -W-4R */
#define NV_063_SET_CONTEXT_BETA1_PARAMETER                     31:0 /* -W-VF */
#define NV_063_SET_CONTEXT_BETA4                         0x00640194 /* -W-4R */
#define NV_063_SET_CONTEXT_BETA4_PARAMETER                     31:0 /* -W-VF */
#define NV_063_SET_CONTEXT_SURFACE                       0x00640198 /* -W-4R */
#define NV_063_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_063_SET_COLOR_CONVERSION                      0x006402FC /* -W-4R */
#define NV_063_SET_COLOR_CONVERSION_TYPE                       31:0 /* -W-VF */
#define NV_063_SET_COLOR_CONVERSION_TYPE_DITHER          0x00000000 /* -W--V */
#define NV_063_SET_COLOR_CONVERSION_TYPE_TRUNCATE        0x00000001 /* -W--V */
#define NV_063_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE  0x00000002 /* -W--V */
#define NV_063_SET_COLOR_FORMAT                          0x00640300 /* -W-4R */
#define NV_063_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_063_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000001 /* -W--V */
#define NV_063_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000002 /* -W--V */
#define NV_063_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000003 /* -W--V */
#define NV_063_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000004 /* -W--V */
#define NV_063_SET_COLOR_FORMAT_LE_V8YB8U8YA8            0x00000005 /* -W--V */
#define NV_063_SET_COLOR_FORMAT_LE_YB8V8YA8U8            0x00000006 /* -W--V */
#define NV_063_SET_COLOR_FORMAT_LE_R5G6B5                0x00000007 /* -W--V */
#define NV_063_SET_OPERATION                             0x00640304 /* -W-4R */
#define NV_063_SET_OPERATION_MODE                              31:0 /* -W-VF */
#define NV_063_SET_OPERATION_MODE_SRCCOPY_AND            0x00000000 /* -W--V */
#define NV_063_SET_OPERATION_MODE_ROP_AND                0x00000001 /* -W--V */
#define NV_063_SET_OPERATION_MODE_BLEND_AND              0x00000002 /* -W--V */
#define NV_063_SET_OPERATION_MODE_SRCCOPY                0x00000003 /* -W--V */
#define NV_063_SET_OPERATION_MODE_SRCCOPY_PREMULT        0x00000004 /* -W--V */
#define NV_063_SET_OPERATION_MODE_BLEND_PREMULT          0x00000005 /* -W--V */
#define NV_063_CLIP_0                                    0x00640308 /* -W-4R */
#define NV_063_CLIP_0_X                                        15:0 /* -W-SF */
#define NV_063_CLIP_0_Y                                       31:16 /* -W-SF */
#define NV_063_CLIP_1                                    0x0064030C /* -W-4R */
#define NV_063_CLIP_1_WIDTH                                    15:0 /* -W-UF */
#define NV_063_CLIP_1_HEIGHT                                  31:16 /* -W-UF */
#define NV_063_RECTANGLE_OUT_0                           0x00640310 /* -W-4R */
#define NV_063_RECTANGLE_OUT_0_X                               15:0 /* -W-SF */
#define NV_063_RECTANGLE_OUT_0_Y                              31:16 /* -W-SF */
#define NV_063_RECTANGLE_OUT_1                           0x00640314 /* -W-4R */
#define NV_063_RECTANGLE_OUT_1_WIDTH                           15:0 /* -W-UF */
#define NV_063_RECTANGLE_OUT_1_HEIGHT                         31:16 /* -W-UF */
#define NV_063_DELTA_DU_DX                               0x00640318 /* -W-4R */
#define NV_063_DELTA_DU_DX_R_FRACTION                          19:0 /* -W-UF */
#define NV_063_DELTA_DU_DX_R_INT                              31:20 /* -W-SF */
#define NV_063_DELTA_DU_DX_R                                   31:0 /* -W-SF */
#define NV_063_DELTA_DV_DY                               0x0064031C /* -W-4R */
#define NV_063_DELTA_DV_DY_R_FRACTION                          19:0 /* -W-UF */
#define NV_063_DELTA_DV_DY_R_INT                              31:20 /* -W-SF */
#define NV_063_DELTA_DV_DY_R                                   31:0 /* -W-SF */
#define NV_063_SIZE                                      0x00640400 /* -W-4R */
#define NV_063_SIZE_WIDTH                                      15:0 /* -W-UF */
#define NV_063_SIZE_HEIGHT                                    31:16 /* -W-UF */
#define NV_063_FORMAT                                    0x00640404 /* -W-4R */
#define NV_063_FORMAT_PITCH                                    15:0 /* -W-SF */
#define NV_063_FORMAT_ORIGIN                                  23:16 /* -W-VF */
#define NV_063_FORMAT_ORIGIN_CENTER                      0x00000001 /* -W--V */
#define NV_063_FORMAT_ORIGIN_CORNER                      0x00000002 /* -W--V */
#define NV_063_FORMAT_INTERPOLATOR                            31:24 /* -W-VF */
#define NV_063_FORMAT_INTERPOLATOR_ZOH                   0x00000000 /* -W--V */
#define NV_063_FORMAT_INTERPOLATOR_FOH                   0x00000001 /* -W--V */
#define NV_063_OFFSET                                    0x00640408 /* -W-4R */
#define NV_063_OFFSET_VALUE                                   31:0  /* -W-UF */
#define NV_063_POINT                                     0x0064040C /* -W-4R */
#define NV_063_POINT_V_FRACTION                                11:0 /* -W-UF */
#define NV_063_POINT_V_INT                                    15:12 /* -W-UF */
#define NV_063_POINT_V_VALUE                                   15:0 /* -W-UF */
#define NV_063_POINT_U_FRACTION                               19:16 /* -W-UF */
#define NV_063_POINT_U_INT                                    31:20 /* -W-UF */
#define NV_063_POINT_U_VALUE                                   31:0 /* -W-UF */
/* usr_nv10_scaled_image_from_mem.ref */
#define NV10_SCALED_IMAGE_FROM_MEMORY                    0x00000089 /* ----C */
#define NV_089                                0x006E1FFF:0x006E0000 /* -W--D */
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY             0x006E0000 /* -W-4R */
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_HANDLE            31:0 /* -WXVF */
#define NV_089_NOP                                       0x006E0100 /* -W-4R */
#define NV_089_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_089_PM_TRIGGER                                0x006E0140 /* -W-4R */
#define NV_089_PM_TRIGGER_PARAMETER                            31:0 /* -W-VF */
#define NV_089_NOTIFY                                    0x006E0104 /* -W-4R */
#define NV_089_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_089_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_089_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_089_SET_NOTIFY                                0x006E0104 /* -W-4R */
#define NV_089_SET_NOTIFY__ALIAS_1                    NV_089_NOTIFY /*       */
#define NV_089_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_089_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_089_WAIT_FOR_IDLE                             0x006E0108 /* -W-4R */
#define NV_089_WAIT_FOR_IDLE_PARAMETER                         31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_DMA_NOTIFY                    0x006E0180 /* -W-4R */
#define NV_089_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_DMA_IMAGE                     0x006E0184 /* -W-4R */
#define NV_089_SET_CONTEXT_DMA_IMAGE_PARAMETER                 31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_PATTERN                       0x006E0188 /* -W-4R */
#define NV_089_SET_CONTEXT_PATTERN_PARAMETER                   31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_ROP                           0x006E018C /* -W-4R */
#define NV_089_SET_CONTEXT_ROP_PARAMETER                       31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_BETA1                         0x006E0190 /* -W-4R */
#define NV_089_SET_CONTEXT_BETA1_PARAMETER                     31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_BETA4                         0x006E0194 /* -W-4R */
#define NV_089_SET_CONTEXT_BETA4_PARAMETER                     31:0 /* -W-VF */
#define NV_089_SET_CONTEXT_SURFACE                       0x006E0198 /* -W-4R */
#define NV_089_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_089_SET_COLOR_CONVERSION                      0x006E02FC /* -W-4R */
#define NV_089_SET_COLOR_CONVERSION_TYPE                       31:0 /* -W-VF */
#define NV_089_SET_COLOR_CONVERSION_TYPE_DITHER          0x00000000 /* -W--V */
#define NV_089_SET_COLOR_CONVERSION_TYPE_TRUNCATE        0x00000001 /* -W--V */
#define NV_089_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE  0x00000002 /* -W--V */
#define NV_089_SET_COLOR_FORMAT                          0x006E0300 /* -W-4R */
#define NV_089_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_089_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000001 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000002 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000003 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000004 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_V8YB8U8YA8            0x00000005 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_YB8V8YA8U8            0x00000006 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_R5G6B5                0x00000007 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_Y8                    0x00000008 /* -W--V */
#define NV_089_SET_COLOR_FORMAT_LE_AY8                   0x00000009 /* -W--V */
#define NV_089_SET_OPERATION                             0x006E0304 /* -W-4R */
#define NV_089_SET_OPERATION_MODE                              31:0 /* -W-VF */
#define NV_089_SET_OPERATION_MODE_SRCCOPY_AND            0x00000000 /* -W--V */
#define NV_089_SET_OPERATION_MODE_ROP_AND                0x00000001 /* -W--V */
#define NV_089_SET_OPERATION_MODE_BLEND_AND              0x00000002 /* -W--V */
#define NV_089_SET_OPERATION_MODE_SRCCOPY                0x00000003 /* -W--V */
#define NV_089_SET_OPERATION_MODE_SRCCOPY_PREMULT        0x00000004 /* -W--V */
#define NV_089_SET_OPERATION_MODE_BLEND_PREMULT          0x00000005 /* -W--V */
#define NV_089_CLIP_0                                    0x006E0308 /* -W-4R */
#define NV_089_CLIP_0_X                                        15:0 /* -W-SF */
#define NV_089_CLIP_0_Y                                       31:16 /* -W-SF */
#define NV_089_CLIP_1                                    0x006E030C /* -W-4R */
#define NV_089_CLIP_1_WIDTH                                    15:0 /* -W-UF */
#define NV_089_CLIP_1_HEIGHT                                  31:16 /* -W-UF */
#define NV_089_RECTANGLE_OUT_0                           0x006E0310 /* -W-4R */
#define NV_089_RECTANGLE_OUT_0_X                               15:0 /* -W-SF */
#define NV_089_RECTANGLE_OUT_0_Y                              31:16 /* -W-SF */
#define NV_089_RECTANGLE_OUT_1                           0x006E0314 /* -W-4R */
#define NV_089_RECTANGLE_OUT_1_WIDTH                           15:0 /* -W-UF */
#define NV_089_RECTANGLE_OUT_1_HEIGHT                         31:16 /* -W-UF */
#define NV_089_DELTA_DU_DX                               0x006E0318 /* -W-4R */
#define NV_089_DELTA_DU_DX_R_FRACTION                          19:0 /* -W-UF */
#define NV_089_DELTA_DU_DX_R_INT                              31:20 /* -W-SF */
#define NV_089_DELTA_DU_DX_R                                   31:0 /* -W-SF */
#define NV_089_DELTA_DV_DY                               0x006E031C /* -W-4R */
#define NV_089_DELTA_DV_DY_R_FRACTION                          19:0 /* -W-UF */
#define NV_089_DELTA_DV_DY_R_INT                              31:20 /* -W-SF */
#define NV_089_DELTA_DV_DY_R                                   31:0 /* -W-SF */
#define NV_089_SIZE                                      0x006E0400 /* -W-4R */
#define NV_089_SIZE_WIDTH                                      15:0 /* -W-UF */
#define NV_089_SIZE_HEIGHT                                    31:16 /* -W-UF */
#define NV_089_FORMAT                                    0x006E0404 /* -W-4R */
#define NV_089_FORMAT_PITCH                                    15:0 /* -W-SF */
#define NV_089_FORMAT_ORIGIN                                  23:16 /* -W-VF */
#define NV_089_FORMAT_ORIGIN_CENTER                      0x00000001 /* -W--V */
#define NV_089_FORMAT_ORIGIN_CORNER                      0x00000002 /* -W--V */
#define NV_089_FORMAT_INTERPOLATOR                            31:24 /* -W-VF */
#define NV_089_FORMAT_INTERPOLATOR_ZOH                   0x00000000 /* -W--V */
#define NV_089_FORMAT_INTERPOLATOR_FOH                   0x00000001 /* -W--V */
#define NV_089_OFFSET                                    0x006E0408 /* -W-4R */
#define NV_089_OFFSET_VALUE                                   31:0  /* -W-UF */
#define NV_089_POINT                                     0x006E040C /* -W-4R */
#define NV_089_POINT_V_FRACTION                                11:0 /* -W-UF */
#define NV_089_POINT_V_INT                                    15:12 /* -W-UF */
#define NV_089_POINT_V_VALUE                                   15:0 /* -W-UF */
#define NV_089_POINT_U_FRACTION                               19:16 /* -W-UF */
#define NV_089_POINT_U_INT                                    31:20 /* -W-UF */
#define NV_089_POINT_U_VALUE                                   31:0 /* -W-UF */
/* usr_nv11_scaled_image_from_mem.ref */
#define NV11_SCALED_IMAGE_FROM_MEMORY                    0x00000089 /* ----C */
#define NV_1189                               0x006E1FFF:0x006E0000 /* -W--D */
#define NV_1189_NV11_SCALED_IMAGE_FROM_MEMORY            0x006E0000 /* -W-4R */
#define NV_1189_NV11_SCALED_IMAGE_FROM_MEMORY_HANDLE           31:0 /* -WXVF */
#define NV_1189_NOP                                      0x006E0100 /* -W-4R */
#define NV_1189_NOP_PARAMETER                                  31:0 /* -W-VF */
#define NV_1189_PM_TRIGGER                               0x006E0140 /* -W-4R */
#define NV_1189_PM_TRIGGER_PARAMETER                           31:0 /* -W-VF */
#define NV_1189_NOTIFY                                   0x006E0104 /* -W-4R */
#define NV_1189_NOTIFY_STYLE                                   31:0 /* -W-VF */
#define NV_1189_NOTIFY_STYLE_WRITE_ONLY                  0x00000000 /* -W--V */
#define NV_1189_NOTIFY_STYLE_WRITE_THEN_AWAKEN           0x00000001 /* -W--V */
#define NV_1189_SET_NOTIFY                               0x006E0104 /* -W-4R */
#define NV_1189_SET_NOTIFY__ALIAS_1                  NV_1189_NOTIFY /*       */
#define NV_1189_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_1189_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_1189_WAIT_FOR_IDLE                            0x006E0108 /* -W-4R */
#define NV_1189_WAIT_FOR_IDLE_PARAMETER                        31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_DMA_NOTIFY                   0x006E0180 /* -W-4R */
#define NV_1189_SET_CONTEXT_DMA_NOTIFY_PARAMETER               31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_DMA_IMAGE                    0x006E0184 /* -W-4R */
#define NV_1189_SET_CONTEXT_DMA_IMAGE_PARAMETER                31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_PATTERN                      0x006E0188 /* -W-4R */
#define NV_1189_SET_CONTEXT_PATTERN_PARAMETER                  31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_ROP                          0x006E018C /* -W-4R */
#define NV_1189_SET_CONTEXT_ROP_PARAMETER                      31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_BETA1                        0x006E0190 /* -W-4R */
#define NV_1189_SET_CONTEXT_BETA1_PARAMETER                    31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_BETA4                        0x006E0194 /* -W-4R */
#define NV_1189_SET_CONTEXT_BETA4_PARAMETER                    31:0 /* -W-VF */
#define NV_1189_SET_CONTEXT_SURFACE                      0x006E0198 /* -W-4R */
#define NV_1189_SET_CONTEXT_SURFACE_PARAMETER                  31:0 /* -W-VF */
#define NV_1189_SET_COLOR_CONVERSION                     0x006E02FC /* -W-4R */
#define NV_1189_SET_COLOR_CONVERSION_TYPE                      31:0 /* -W-VF */
#define NV_1189_SET_COLOR_CONVERSION_TYPE_DITHER         0x00000000 /* -W--V */
#define NV_1189_SET_COLOR_CONVERSION_TYPE_TRUNCATE       0x00000001 /* -W--V */
#define NV_1189_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE 0x00000002 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT                         0x006E0300 /* -W-4R */
#define NV_1189_SET_COLOR_FORMAT_LE                            31:0 /* -W-VF */
#define NV_1189_SET_COLOR_FORMAT_LE_A1R5G5B5             0x00000001 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_X1R5G5B5             0x00000002 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_A8R8G8B8             0x00000003 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_X8R8G8B8             0x00000004 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_V8YB8U8YA8           0x00000005 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_YB8V8YA8U8           0x00000006 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_R5G6B5               0x00000007 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_Y8                   0x00000008 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_AY8                  0x00000009 /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_EYB8ECR8EYA8ECB8     0x0000000A /* -W--V */
#define NV_1189_SET_COLOR_FORMAT_LE_ECR8EYB8ECB8EYA8     0x0000000B /* -W--V */
#define NV_1189_SET_OPERATION                            0x006E0304 /* -W-4R */
#define NV_1189_SET_OPERATION_MODE                             31:0 /* -W-VF */
#define NV_1189_SET_OPERATION_MODE_SRCCOPY_AND           0x00000000 /* -W--V */
#define NV_1189_SET_OPERATION_MODE_ROP_AND               0x00000001 /* -W--V */
#define NV_1189_SET_OPERATION_MODE_BLEND_AND             0x00000002 /* -W--V */
#define NV_1189_SET_OPERATION_MODE_SRCCOPY               0x00000003 /* -W--V */
#define NV_1189_SET_OPERATION_MODE_SRCCOPY_PREMULT       0x00000004 /* -W--V */
#define NV_1189_SET_OPERATION_MODE_BLEND_PREMULT         0x00000005 /* -W--V */
#define NV_1189_CLIP_0                                   0x006E0308 /* -W-4R */
#define NV_1189_CLIP_0_X                                       15:0 /* -W-SF */
#define NV_1189_CLIP_0_Y                                      31:16 /* -W-SF */
#define NV_1189_CLIP_1                                   0x006E030C /* -W-4R */
#define NV_1189_CLIP_1_WIDTH                                   15:0 /* -W-UF */
#define NV_1189_CLIP_1_HEIGHT                                 31:16 /* -W-UF */
#define NV_1189_RECTANGLE_OUT_0                          0x006E0310 /* -W-4R */
#define NV_1189_RECTANGLE_OUT_0_X                              15:0 /* -W-SF */
#define NV_1189_RECTANGLE_OUT_0_Y                             31:16 /* -W-SF */
#define NV_1189_RECTANGLE_OUT_1                          0x006E0314 /* -W-4R */
#define NV_1189_RECTANGLE_OUT_1_WIDTH                          15:0 /* -W-UF */
#define NV_1189_RECTANGLE_OUT_1_HEIGHT                        31:16 /* -W-UF */
#define NV_1189_DELTA_DU_DX                              0x006E0318 /* -W-4R */
#define NV_1189_DELTA_DU_DX_R_FRACTION                         19:0 /* -W-UF */
#define NV_1189_DELTA_DU_DX_R_INT                             31:20 /* -W-SF */
#define NV_1189_DELTA_DU_DX_R                                  31:0 /* -W-SF */
#define NV_1189_DELTA_DV_DY                              0x006E031C /* -W-4R */
#define NV_1189_DELTA_DV_DY_R_FRACTION                         19:0 /* -W-UF */
#define NV_1189_DELTA_DV_DY_R_INT                             31:20 /* -W-SF */
#define NV_1189_DELTA_DV_DY_R                                  31:0 /* -W-SF */
#define NV_1189_SIZE                                     0x006E0400 /* -W-4R */
#define NV_1189_SIZE_WIDTH                                     15:0 /* -W-UF */
#define NV_1189_SIZE_HEIGHT                                   31:16 /* -W-UF */
#define NV_1189_FORMAT                                   0x006E0404 /* -W-4R */
#define NV_1189_FORMAT_PITCH                                   15:0 /* -W-SF */
#define NV_1189_FORMAT_ORIGIN                                 23:16 /* -W-VF */
#define NV_1189_FORMAT_ORIGIN_CENTER                     0x00000001 /* -W--V */
#define NV_1189_FORMAT_ORIGIN_CORNER                     0x00000002 /* -W--V */
#define NV_1189_FORMAT_INTERPOLATOR                           31:24 /* -W-VF */
#define NV_1189_FORMAT_INTERPOLATOR_ZOH                  0x00000000 /* -W--V */
#define NV_1189_FORMAT_INTERPOLATOR_FOH                  0x00000001 /* -W--V */
#define NV_1189_OFFSET                                   0x006E0408 /* -W-4R */
#define NV_1189_OFFSET_VALUE                                  31:0  /* -W-UF */
#define NV_1189_POINT                                    0x006E040C /* -W-4R */
#define NV_1189_POINT_V_FRACTION                               11:0 /* -W-UF */
#define NV_1189_POINT_V_INT                                   15:12 /* -W-UF */
#define NV_1189_POINT_V_VALUE                                  15:0 /* -W-UF */
#define NV_1189_POINT_U_FRACTION                              19:16 /* -W-UF */
#define NV_1189_POINT_U_INT                                   31:20 /* -W-UF */
#define NV_1189_POINT_U_VALUE                                  31:0 /* -W-UF */
/* usr_dvd_subpicture.ref */
#define NV4_DVD_SUBPICTURE                               0x00000038 /* ----C */
#define NV_038                                0x004F1FFF:0x004F0000 /* -W--D */
#define NV_038_NV4_DVD_SUBPICTURE                        0x004F0000 /* -W-4R */
#define NV_038_NOP                                       0x004F0100 /* -W-4R */
#define NV_038_NOP_PARAMETER                                   31:0 /* -WXVF */
#define NV_038_NOTIFY                                    0x004f0104 /* -W-4R */
#define NV_038_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_038_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_038_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_038_NOTIFY__ALIAS_1                    NV_038_SET_NOTIFY /*       */
#define NV_038_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_038_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_038_SET_CONTEXT_DMA_NOTIFY                    0x004f0180 /* -W-4R */
#define NV_038_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_038_SET_CONTEXT_DMA_OVERLAY                   0x004f0184 /* -W-4R */
#define NV_038_SET_CONTEXT_DMA_OVERLAY_PARAMETER               31:0 /* -W-VF */
#define NV_038_SET_CONTEXT_DMA_IMAGEIN                   0x004f0188 /* -W-4R */
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_PARAMETER               31:0 /* -W-VF */
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT                  0x004f018C /* -W-4R */
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER              31:0 /* -W-VF */
#define NV_038_IMAGEOUT_POINT                            0x004F0300 /* -W-4R */
#define NV_038_IMAGEOUT_POINT_X                                15:0 /* -W-SF */
#define NV_038_IMAGEOUT_POINT_Y                               31:16 /* -W-SF */
#define NV_038_IMAGEOUT_SIZE                             0x004F0304 /* -W-4R */
#define NV_038_IMAGEOUT_SIZE_WIDTH                             15:0 /* -W-UF */
#define NV_038_IMAGEOUT_SIZE_HEIGHT                           31:16 /* -W-UF */
#define NV_038_IMAGEOUT_FMT                              0x004F0308 /* -W-4R */
#define NV_038_IMAGEOUT_FMT_PITCH                              15:0 /* -W-UF */
#define NV_038_IMAGEOUT_FMT_COLOR                             31:16 /* -W-UF */
#define NV_038_IMAGEOUT_FMT_COLOR_INVALID                0x00000000 /* -W--V */
#define NV_038_IMAGEOUT_FMT_COLOR_LE_V8YB8U8YA8          0x00000001 /* -W--V */
#define NV_038_IMAGEOUT_FMT_COLOR_LE_YB8V8YA8U8          0x00000002 /* -W--V */
#define NV_038_IMAGEOUT_OFFSET                           0x004F030C /* -W-4R */
#define NV_038_IMAGEOUT_OFFSET_VALUE                           31:0 /* -W-UF */
#define NV_038_IMAGEIN_DELTA_DU_DX                       0x004F0310 /* -W-4R */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_FRACTION                  19:0 /* -W-SF */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_INT                      31:20 /* -W-UF */
#define NV_038_IMAGEIN_DELTA_DU_DX_R                           31:0 /* -W-UF */
#define NV_038_IMAGEIN_DELTA_DV_DY                       0x004F0314 /* -W-4R */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_FRACTION                  19:0 /* -W-SF */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_INT                      31:20 /* -W-UF */
#define NV_038_IMAGEIN_DELTA_DV_DY_R                           31:0 /* -W-UF */
#define NV_038_IMAGEIN_SIZE                              0x004F0318 /* -W-4R */
#define NV_038_IMAGEIN_SIZE_WIDTH                              15:0 /* -W-UF */
#define NV_038_IMAGEIN_SIZE_HEIGHT                            31:16 /* -W-UF */
#define NV_038_IMAGEIN_FMT                               0x004F031C /* -W-4R */
#define NV_038_IMAGEIN_FMT_PITCH                               15:0 /* -W-UF */
#define NV_038_IMAGEIN_FMT_COLOR                              31:16 /* -W-VF */
#define NV_038_IMAGEIN_FMT_COLOR_INVALID                 0x00000000 /* -W--V */
#define NV_038_IMAGEIN_FMT_COLOR_LE_V8YB8U8YA8           0x00000001 /* -W--V */
#define NV_038_IMAGEIN_FMT_COLOR_LE_YB8V8YA8U8           0x00000002 /* -W--V */
#define NV_038_IMAGEIN_OFFSET                            0x004F0320 /* -W-4R */
#define NV_038_IMAGEIN_OFFSET_VALUE                            31:0 /* -W-UF */
#define NV_038_IMAGEIN_POINT                             0x004F0324 /* -W-4R */
#define NV_038_IMAGEIN_POINT_U_FRACTION                         3:0 /* -W-UF */
#define NV_038_IMAGEIN_POINT_U_INT                             15:4 /* -W-UF */
#define NV_038_IMAGEIN_POINT_U_VALUE                           15:0 /* -W-UF */
#define NV_038_IMAGEIN_POINT_V_FRACTION                       19:16 /* -W-UF */
#define NV_038_IMAGEIN_POINT_V_INT                            31:20 /* -W-UF */
#define NV_038_IMAGEIN_POINT_V_VALUE                           31:0 /* -W-UF */
#define NV_038_OVERLAY_DELTA_DU_DX                       0x004F0328 /* -W-4R */
#define NV_038_OVERLAY_DELTA_DU_DX_R_FRACTION                  19:0 /* -W-SF */
#define NV_038_OVERLAY_DELTA_DU_DX_R_INT                      31:20 /* -W-UF */
#define NV_038_OVERLAY_DELTA_DU_DX_R                           31:0 /* -W-UF */
#define NV_038_OVERLAY_DELTA_DV_DY                       0x004F032C /* -W-4R */
#define NV_038_OVERLAY_DELTA_DV_DY_R_FRACTION                  19:0 /* -W-SF */
#define NV_038_OVERLAY_DELTA_DV_DY_R_INT                      31:20 /* -W-UF */
#define NV_038_OVERLAY_DELTA_DV_DY_R                           31:0 /* -W-UF */
#define NV_038_OVERLAY_SIZE                              0x004F0330 /* -W-4R */
#define NV_038_OVERLAY_SIZE_WIDTH                              15:0 /* -W-UF */
#define NV_038_OVERLAY_SIZE_HEIGHT                            31:16 /* -W-UF */
#define NV_038_OVERLAY_FMT                               0x004F0334 /* -W-4R */
#define NV_038_OVERLAY_FMT_PITCH                               15:0 /* -W-UF */
#define NV_038_OVERLAY_FMT_COLOR                              31:16 /* -W-VF */
#define NV_038_OVERLAY_FMT_COLOR_INVALID                 0x00000000 /* -W--V */
#define NV_038_OVERLAY_FMT_COLOR_LE_A8V8U8Y8             0x00000001 /* -W--V */
#define NV_038_OVERLAY_FMT_COLOR_LE_A4V6YB6A4U6YA6       0x00000002 /* -W--V */
#define NV_038_OVERLAY_FMT_COLOR_LE_TRANSPARENT          0x00000003 /* -W--V */
#define NV_038_OVERLAY_OFFSET                            0x004F0338 /* -W-4R */
#define NV_038_OVERLAY_OFFSET_VALUE                           31:0  /* -W-UF */
#define NV_038_OVERLAY_POINT                             0x004F033C /* -W-4R */
#define NV_038_OVERLAY_POINT_U_FRACTION                         3:0 /* -W-UF */
#define NV_038_OVERLAY_POINT_U_INT                             15:4 /* -W-UF */
#define NV_038_OVERLAY_POINT_U_VALUE                           15:0 /* -W-UF */
#define NV_038_OVERLAY_POINT_V_FRACTION                       19:16 /* -W-UF */
#define NV_038_OVERLAY_POINT_V_INT                            31:20 /* -W-UF */
#define NV_038_OVERLAY_POINT_V_VALUE                           31:0 /* -W-UF */
/* usr_nv10_dvd_subpicture.ref */
#define NV10_DVD_SUBPICTURE                              0x00000088 /* ----C */
#define NV_088                                0x006F1FFF:0x006F0000 /* -W--D */
#define NV_088_NV4_DVD_SUBPICTURE                        0x006F0000 /* -W-4R */
#define NV_088_NOP                                       0x006F0100 /* -W-4R */
#define NV_088_NOP_PARAMETER                                   31:0 /* -WXVF */
#define NV_088_NOTIFY                                    0x006F0104 /* -W-4R */
#define NV_088_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_088_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_088_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_088_NOTIFY__ALIAS_1                    NV_088_SET_NOTIFY /*       */
#define NV_088_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_088_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_088_WAIT_FOR_IDLE                             0x006F0108 /* -W-4R */
#define NV_088_WAIT_FOR_IDLE_PARAMETER                         31:0 /* -W-VF */
#define NV_088_SET_CONTEXT_DMA_NOTIFY                    0x006F0180 /* -W-4R */
#define NV_088_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_088_SET_CONTEXT_DMA_OVERLAY                   0x006F0184 /* -W-4R */
#define NV_088_SET_CONTEXT_DMA_OVERLAY_PARAMETER               31:0 /* -W-VF */
#define NV_088_SET_CONTEXT_DMA_IMAGEIN                   0x006F0188 /* -W-4R */
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_PARAMETER               31:0 /* -W-VF */
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT                  0x006F018C /* -W-4R */
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER              31:0 /* -W-VF */
#define NV_088_IMAGEOUT_POINT                            0x006F0300 /* -W-4R */
#define NV_088_IMAGEOUT_POINT_X                                15:0 /* -W-SF */
#define NV_088_IMAGEOUT_POINT_Y                               31:16 /* -W-SF */
#define NV_088_IMAGEOUT_SIZE                             0x006F0304 /* -W-4R */
#define NV_088_IMAGEOUT_SIZE_WIDTH                             15:0 /* -W-UF */
#define NV_088_IMAGEOUT_SIZE_HEIGHT                           31:16 /* -W-UF */
#define NV_088_IMAGEOUT_FMT                              0x006F0308 /* -W-4R */
#define NV_088_IMAGEOUT_FMT_PITCH                              15:0 /* -W-UF */
#define NV_088_IMAGEOUT_FMT_COLOR                             31:16 /* -W-UF */
#define NV_088_IMAGEOUT_FMT_COLOR_INVALID                0x00000000 /* -W--V */
#define NV_088_IMAGEOUT_FMT_COLOR_LE_V8YB8U8YA8          0x00000001 /* -W--V */
#define NV_088_IMAGEOUT_FMT_COLOR_LE_YB8V8YA8U8          0x00000002 /* -W--V */
#define NV_088_IMAGEOUT_OFFSET                           0x006F030C /* -W-4R */
#define NV_088_IMAGEOUT_OFFSET_VALUE                           31:0 /* -W-UF */
#define NV_088_IMAGEIN_DELTA_DU_DX                       0x006F0310 /* -W-4R */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_FRACTION                  19:0 /* -W-SF */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_INT                      31:20 /* -W-UF */
#define NV_088_IMAGEIN_DELTA_DU_DX_R                           31:0 /* -W-UF */
#define NV_088_IMAGEIN_DELTA_DV_DY                       0x006F0314 /* -W-4R */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_FRACTION                  19:0 /* -W-SF */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_INT                      31:20 /* -W-UF */
#define NV_088_IMAGEIN_DELTA_DV_DY_R                           31:0 /* -W-UF */
#define NV_088_IMAGEIN_SIZE                              0x006F0318 /* -W-4R */
#define NV_088_IMAGEIN_SIZE_WIDTH                              15:0 /* -W-UF */
#define NV_088_IMAGEIN_SIZE_HEIGHT                            31:16 /* -W-UF */
#define NV_088_IMAGEIN_FMT                               0x006F031C /* -W-4R */
#define NV_088_IMAGEIN_FMT_PITCH                               15:0 /* -W-UF */
#define NV_088_IMAGEIN_FMT_COLOR                              31:16 /* -W-VF */
#define NV_088_IMAGEIN_FMT_COLOR_INVALID                 0x00000000 /* -W--V */
#define NV_088_IMAGEIN_FMT_COLOR_LE_V8YB8U8YA8           0x00000001 /* -W--V */
#define NV_088_IMAGEIN_FMT_COLOR_LE_YB8V8YA8U8           0x00000002 /* -W--V */
#define NV_088_IMAGEIN_OFFSET                            0x006F0320 /* -W-4R */
#define NV_088_IMAGEIN_OFFSET_VALUE                            31:0 /* -W-UF */
#define NV_088_IMAGEIN_POINT                             0x006F0324 /* -W-4R */
#define NV_088_IMAGEIN_POINT_U_FRACTION                         3:0 /* -W-UF */
#define NV_088_IMAGEIN_POINT_U_INT                             15:4 /* -W-UF */
#define NV_088_IMAGEIN_POINT_U_VALUE                           15:0 /* -W-UF */
#define NV_088_IMAGEIN_POINT_V_FRACTION                       19:16 /* -W-UF */
#define NV_088_IMAGEIN_POINT_V_INT                            31:20 /* -W-UF */
#define NV_088_IMAGEIN_POINT_V_VALUE                           31:0 /* -W-UF */
#define NV_088_OVERLAY_DELTA_DU_DX                       0x006F0328 /* -W-4R */
#define NV_088_OVERLAY_DELTA_DU_DX_R_FRACTION                  19:0 /* -W-SF */
#define NV_088_OVERLAY_DELTA_DU_DX_R_INT                      31:20 /* -W-UF */
#define NV_088_OVERLAY_DELTA_DU_DX_R                           31:0 /* -W-UF */
#define NV_088_OVERLAY_DELTA_DV_DY                       0x006F032C /* -W-4R */
#define NV_088_OVERLAY_DELTA_DV_DY_R_FRACTION                  19:0 /* -W-SF */
#define NV_088_OVERLAY_DELTA_DV_DY_R_INT                      31:20 /* -W-UF */
#define NV_088_OVERLAY_DELTA_DV_DY_R                           31:0 /* -W-UF */
#define NV_088_OVERLAY_SIZE                              0x006F0330 /* -W-4R */
#define NV_088_OVERLAY_SIZE_WIDTH                              15:0 /* -W-UF */
#define NV_088_OVERLAY_SIZE_HEIGHT                            31:16 /* -W-UF */
#define NV_088_OVERLAY_FMT                               0x006F0334 /* -W-4R */
#define NV_088_OVERLAY_FMT_PITCH                               15:0 /* -W-UF */
#define NV_088_OVERLAY_FMT_COLOR                              31:16 /* -W-VF */
#define NV_088_OVERLAY_FMT_COLOR_INVALID                 0x00000000 /* -W--V */
#define NV_088_OVERLAY_FMT_COLOR_LE_A8V8U8Y8             0x00000001 /* -W--V */
#define NV_088_OVERLAY_FMT_COLOR_LE_A4V6YB6A4U6YA6       0x00000002 /* -W--V */
#define NV_088_OVERLAY_FMT_COLOR_LE_TRANSPARENT          0x00000003 /* -W--V */
#define NV_088_OVERLAY_OFFSET                            0x006F0338 /* -W-4R */
#define NV_088_OVERLAY_OFFSET_VALUE                           31:0  /* -W-UF */
#define NV_088_OVERLAY_POINT                             0x006F033C /* -W-4R */
#define NV_088_OVERLAY_POINT_U_FRACTION                         3:0 /* -W-UF */
#define NV_088_OVERLAY_POINT_U_INT                             15:4 /* -W-UF */
#define NV_088_OVERLAY_POINT_U_VALUE                           15:0 /* -W-UF */
#define NV_088_OVERLAY_POINT_V_FRACTION                       19:16 /* -W-UF */
#define NV_088_OVERLAY_POINT_V_INT                            31:20 /* -W-UF */
#define NV_088_OVERLAY_POINT_V_VALUE                           31:0 /* -W-UF */
/* usr_nv4_surface.ref */
#define NV4_SURFACE                                      0x00000042 /* ----C */
#define NV_042                                0x00611FFF:0x00610000 /* -W--D */
#define NV_042_NV4_SURFACE                               0x00610000 /* -W-4R */
#define NV_042_NOP                                       0x00610100 /* -W-4R */
#define NV_042_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_042_PM_TRIGGER                                0x00610140 /* -W-4R */
#define NV_042_PM_TRIGGER_PARAMETER                            31:0 /* -W-VF */
#define NV_042_NOTIFY                                    0x00610104 /* -W-4R */
#define NV_042_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_042_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_042_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_042_SET_NOTIFY                                0x00610104 /* -W-4R */
#define NV_042_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_042_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_042_SET_CONTEXT_DMA_NOTIFY                    0x00610180 /* -W-4R */
#define NV_042_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE              0x00610184 /* -W-4R */
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER          31:0 /* -W-VF */
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN              0x00610188 /* -W-4R */
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER          31:0 /* -W-VF */
#define NV_042_SET_IMAGE_OUTPUT_SOURCE                   0x00610200 /* -W-4R */
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_PARAMETER               31:0 /* -W-VF */
#define NV_042_SET_IMAGE_OUTPUT_DESTIN                   0x00610204 /* -W-4R */
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_PARAMETER               31:0 /* -W-VF */
#define NV_042_SET_IMAGE_INPUT_DESTIN(i)         (0x00610208+(i)*4) /* -W-4A */
#define NV_042_SET_IMAGE_INPUT_DESTIN__SIZE_1                    62 /*       */
#define NV_042_SET_IMAGE_INPUT_DESTIN_PARAMETER                31:0 /* -W-VF */
#define NV_042_FMT                                       0x00610300 /* -W-4R */
#define NV_042_FMT_VALUE                                       31:0 /* -WXUF */
#define NV_042_FMT_VALUE_LE_Y8                           0x00000001 /* -W--V */
#define NV_042_FMT_VALUE_LE_X1R5G5B5_Z1R5G5B5            0x00000002 /* -W--V */
#define NV_042_FMT_VALUE_LE_X1R5G5B5_O1R5G5B5            0x00000003 /* -W--V */
#define NV_042_FMT_VALUE_LE_R5G6B5                       0x00000004 /* -W--V */
#define NV_042_FMT_VALUE_LE_Y16                          0x00000005 /* -W--V */
#define NV_042_FMT_VALUE_LE_X8R8G8B8_Z8R8G8B8            0x00000006 /* -W--V */
#define NV_042_FMT_VALUE_LE_X8R8G8B8_O8R8G8B8            0x00000007 /* -W--V */
#define NV_042_FMT_VALUE_LE_X1A7R8G8B8_Z1A7R8G8B8        0x00000008 /* -W--V */
#define NV_042_FMT_VALUE_LE_X1A7R8G8B8_O1A7R8G8B8        0x00000009 /* -W--V */
#define NV_042_FMT_VALUE_LE_A8R8G8B8                     0x0000000a /* -W--V */
#define NV_042_FMT_VALUE_LE_Y32                          0x0000000b /* -W--V */
#define NV_042_PITCH                                     0x00610304 /* -W-4R */
#define NV_042_PITCH_SOURCE                                    15:0 /* -WXUF */
#define NV_042_PITCH_DESTIN                                   31:16 /* -WXUF */
#define NV_042_OFFSET_SOURCE                             0x00610308 /* -W-4R */
#define NV_042_OFFSET_SOURCE_LINADRS                           31:0 /* -WIUF */
#define NV_042_OFFSET_SOURCE_LINADRS_0                   0x00000000 /* -WI-V */
#define NV_042_OFFSET_DESTIN                             0x0061030C /* -W-4R */
#define NV_042_OFFSET_DESTIN_LINADRS                           31:0 /* -WIUF */
#define NV_042_OFFSET_DESTIN_LINADRS_0                   0x00000000 /* -WI-V */
/* usr_nv10_surface.ref */
#define NV10_CONTEXT_SURFACES_2D                         0x00000062 /* ----C */
#define NV_062                                0x006D1FFF:0x006D0000 /* -W--D */
#define NV_062_NV10_CONTEXT_SURFACES_2D                  0x006D0000 /* -W-4R */
#define NV_062_NV10_CONTEXT_SURFACES_2D_HANDLE                 31:0 /* -WXVF */
#define NV_062_NOP                                       0x006D0100 /* -W-4R */
#define NV_062_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_062_PM_TRIGGER                                0x006D0140 /* -W-4R */
#define NV_062_PM_TRIGGER_PARAMETER                            31:0 /* -W-VF */
#define NV_062_NOTIFY                                    0x006D0104 /* -W-4R */
#define NV_062_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_062_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_062_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_062_SET_NOTIFY                                0x006D0104 /* -W-4R */
#define NV_062_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_062_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_062_WAIT_FOR_IDLE                             0x006D0108 /* -W-4R */
#define NV_062_WAIT_FOR_IDLE_PARAMETER                         31:0 /* -W-VF */
#define NV_062_SET_CONTEXT_DMA_NOTIFY                    0x006D0180 /* -W-4R */
#define NV_062_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE              0x006D0184 /* -W-4R */
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER          31:0 /* -W-VF */
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN              0x006D0188 /* -W-4R */
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER          31:0 /* -W-VF */
#define NV_062_FMT                                       0x006D0300 /* -W-4R */
#define NV_062_FMT_VALUE                                       31:0 /* -WXUF */
#define NV_062_FMT_VALUE_LE_Y8                           0x00000001 /* -W--V */
#define NV_062_FMT_VALUE_LE_X1R5G5B5_Z1R5G5B5            0x00000002 /* -W--V */
#define NV_062_FMT_VALUE_LE_X1R5G5B5_O1R5G5B5            0x00000003 /* -W--V */
#define NV_062_FMT_VALUE_LE_R5G6B5                       0x00000004 /* -W--V */
#define NV_062_FMT_VALUE_LE_Y16                          0x00000005 /* -W--V */
#define NV_062_FMT_VALUE_LE_X8R8G8B8_Z8R8G8B8            0x00000006 /* -W--V */
#define NV_062_FMT_VALUE_LE_X8R8G8B8_O8R8G8B8            0x00000007 /* -W--V */
#define NV_062_FMT_VALUE_LE_X1A7R8G8B8_Z1A7R8G8B8        0x00000008 /* -W--V */
#define NV_062_FMT_VALUE_LE_X1A7R8G8B8_O1A7R8G8B8        0x00000009 /* -W--V */
#define NV_062_FMT_VALUE_LE_A8R8G8B8                     0x0000000a /* -W--V */
#define NV_062_FMT_VALUE_LE_Y32                          0x0000000b /* -W--V */
#define NV_062_PITCH                                     0x006D0304 /* -W-4R */
#define NV_062_PITCH_SOURCE                                    15:0 /* -WXUF */
#define NV_062_PITCH_DESTIN                                   31:16 /* -WXUF */
#define NV_062_OFFSET_SOURCE                             0x006D0308 /* -W-4R */
#define NV_062_OFFSET_SOURCE_LINADRS                           31:0 /* -WIUF */
#define NV_062_OFFSET_SOURCE_LINADRS_0                   0x00000000 /* -WI-V */
#define NV_062_OFFSET_DESTIN                             0x006D030C /* -W-4R */
#define NV_062_OFFSET_DESTIN_LINADRS                           31:0 /* -WIUF */
#define NV_062_OFFSET_DESTIN_LINADRS_0                   0x00000000 /* -WI-V */
/* usr_nv4_swizzled_surface.ref */
#define NV4_SWIZZLED_SURFACE                             0x00000052 /* ----C */
#define NV_052                                0x00631FFF:0x00630000 /* -W--D */
#define NV_052_NV4_SWIZZLED_SURFACE                      0x00630000 /* -W-4R */
#define NV_052_NOP                                       0x00630100 /* -W-4R */
#define NV_052_NOP_PARAMETER                                   31:0 /* -WXVF */
#define NV_052_NOTIFY                                    0x00630104 /* -W-4R */
#define NV_052_NOTIFY_STYLE                                    31:0 /* -WXVF */
#define NV_052_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_052_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_052_NOTIFY__ALIAS_1                    NV_052_SET_NOTIFY /*       */
#define NV_052_SET_NOTIFY_PARAMETER                            31:0 /* -WXVF */
#define NV_052_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_052_SET_CONTEXT_DMA_NOTIFY                    0x00630180 /* -W-4R */
#define NV_052_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -WXVF */
#define NV_052_SET_CONTEXT_DMA_IMAGE                     0x00630184 /* -W-4R */
#define NV_052_SET_CONTEXT_DMA_IMAGE_PARAMETER                 31:0 /* -W-VF */
#define NV_052_SET_IMAGE_OUTPUT                          0x00630200 /* -W-4R */
#define NV_052_SET_IMAGE_OUTPUT_PARAMETER                      31:0 /* -W-VF */
#define NV_052_SET_IMAGE_INPUT(i)                (0x00630204+(i)*4) /* -W-4A */
#define NV_052_SET_IMAGE_INPUT__SIZE_1                           63 /*       */
#define NV_052_SET_IMAGE_INPUT_PARAMETER                       31:0 /* -W-VF */
#define NV_052_SET_FORMAT                                0x00630300 /* -W-4R */
#define NV_052_SET_FORMAT_COLOR                                15:0 /* -WXVF */
#define NV_052_SET_FORMAT_COLOR_LE_Y8                    0x00000001 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5     0x00000002 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5     0x00000003 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_R5G6B5                0x00000004 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_Y16                   0x00000005 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8     0x00000006 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8     0x00000007 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8 0x00000008 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8 0x00000009 /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_A8R8G8B8              0x0000000a /* -W--V */
#define NV_052_SET_FORMAT_COLOR_LE_Y32                   0x0000000b /* -W--V */
#define NV_052_SET_FORMAT_WIDTH                               23:16 /* -WXVF */
#define NV_052_SET_FORMAT_WIDTH_1                        0x00000000 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_2                        0x00000001 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_4                        0x00000002 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_8                        0x00000003 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_16                       0x00000004 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_32                       0x00000005 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_64                       0x00000006 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_128                      0x00000007 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_256                      0x00000008 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_512                      0x00000009 /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_1024                     0x0000000a /* -W--V */
#define NV_052_SET_FORMAT_WIDTH_2048                     0x0000000b /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT                              31:24 /* -WXVF */
#define NV_052_SET_FORMAT_HEIGHT_1                       0x00000000 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_2                       0x00000001 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_4                       0x00000002 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_8                       0x00000003 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_16                      0x00000004 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_32                      0x00000005 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_64                      0x00000006 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_128                     0x00000007 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_256                     0x00000008 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_512                     0x00000009 /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_1024                    0x0000000a /* -W--V */
#define NV_052_SET_FORMAT_HEIGHT_2048                    0x0000000b /* -W--V */
#define NV_052_SET_OFFSET                                0x00630304 /* -W-4R */
#define NV_052_SET_OFFSET_LINADRS                              31:0 /* -WIUF */
#define NV_052_SET_OFFSET_LINADRS_0                      0x00000000 /* -WI-V */
/* usr_nv3_surface.ref */
#define NV3_SURFACE_0                                    0x00000058 /* ----C */
#define NV3_SURFACE_1                                    0x00000059 /* ----C */
#define NV3_SURFACE_2                                    0x0000005A /* ----C */
#define NV3_SURFACE_3                                    0x0000005B /* ----C */
#define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
#define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
#define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UINMEM_NOP                                    0x005C0100 /* -W-4R */
#define NV_UINMEM_NOP_PARAMETER                                31:0 /* -W-VF */
#define NV_UINMEM_NOTIFY                                 0x005C0104 /* -W-4R */
#define NV_UINMEM_NOTIFY_STYLE                                 31:0 /* -W-VF */
#define NV_UINMEM_NOTIFY_STYLE_WRITE_ONLY                0x00000000 /* -W--V */
#define NV_UINMEM_NOTIFY_STYLE_WRITE_THEN_AWAKEN         0x00000001 /* -W--V */
#define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
#define NV_UINMEM_SET_NOTIFY__ALIAS_1              NV_UINMEM_NOTIFY /*       */
#define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY                 0x005C0180 /* -W-4R */
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_PARAMETER             31:0 /* -W-VF */
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE                  0x005C0184 /* -W-4R */
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_PARAMETER              31:0 /* -W-VF */
#define NV_UINMEM_SET_IMAGE_OUTPUT                       0x005C0200 /* -W-4R */
#define NV_UINMEM_SET_IMAGE_OUTPUT_PARAMETER                   31:0 /* -W-VF */
#define NV_UINMEM_SET_IMAGE_INPUT(i)             (0x005C0204+(i)*4) /* -W-4A */
#define NV_UINMEM_SET_IMAGE_INPUT__SIZE_1                        63 /*       */
#define NV_UINMEM_SET_IMAGE_INPUT_PARAMETER                    31:0 /* -W-VF */
#define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
#define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
#define NV_UINMEM_FORMAT_VALUE_LE_Y8                     0x01010000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_Y16                    0x01010001 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_Z1R5G5B5      0x01000000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8_Z8R8G8B8      0x00000001 /* -W--V */
#define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
#define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
#define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
#define NV_UINMEM_OFFSET_LINADRS                               22:0 /* -WIUF */
#define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
/* usr_nv4_gdi_rectangle_text.ref */
#define NV4_GDI_RECTANGLE_TEXT                           0x0000004A /* ----C */
#define NV_04A                                0x004C1FFF:0x004C0000 /* -W--D */
#define NV_04A_NV4_GDI_RECTANGLE_TEXT                    0x004C0000 /* -W-4R */
#define NV_04A_NOP                                       0x004C0100 /* -W-4R */
#define NV_04A_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_04A_PM_TRIGGER                                0x004C0140 /* -W-4R */
#define NV_04A_PM_TRIGGER_PARAMETER                            31:0 /* -W-VF */
#define NV_04A_NOTIFY                                    0x004C0104 /* -W-4R */
#define NV_04A_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_04A_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_04A_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_04A_SET_PATCH                                 0x004C010C /* -W-4R */
#define NV_04A_SET_PATCH_PARAMETER                             31:0 /* -W-VF */
#define NV_04A_SET_PATCH_PARAMETER_INVALIDATE            0x00000000 /* -W--V */
#define NV_04A_SET_PATCH_PARAMETER_VALIDATE              0x00000001 /* -W--V */
#define NV_04A_SET_CONTEXT_DMA_NOTIFY                    0x004C0180 /* -W-4R */
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_04A_SET_CONTEXT_DMA_FONTS                     0x004C0184 /* -W-4R */
#define NV_04A_SET_CONTEXT_DMA_FONTS_PARAMETER                 31:0 /* -W-VF */
#define NV_04A_SET_IMAGE_OUTPUT                          0x004C0200 /* -W-4R */
#define NV_04A_SET_IMAGE_OUTPUT_PARAMETER                      31:0 /* -W-VF */
#define NV_04A_SET_COLOR_FORMAT                          0x004C0300 /* -W-4R */
#define NV_04A_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_04A_SET_COLOR_FORMAT_LE_X16R5G6B5             0x00000001 /* -W--V */
#define NV_04A_SET_COLOR_FORMAT_LE_X17R5G5B5             0x00000002 /* -W--V */
#define NV_04A_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000003 /* -W--V */
#define NV_04A_SET_MONOCHROME_FORMAT                     0x004C0304 /* -W-4R */
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE                     31:0 /* -W-VF */
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_CGA6_M1       0x00000001 /* -W--V */
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_LE_M1         0x00000002 /* -W--V */
#define NV_04A_COLOR1_A                                  0x004C03FC /* -W-4R */
#define NV_04A_COLOR1_A_VALUE                                  31:0 /* -W-VF */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT(i)      (0x004C0400+(i)*8) /* -W-4A */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT__SIZE_1                 32 /*       */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_Y                     15:0 /* -W-SF */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_X                    31:16 /* -W-SF */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE(i)       (0x004C0404+(i)*8) /* -W-4A */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE__SIZE_1                  32 /*       */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                 15:0 /* -W-UF */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH                 31:16 /* -W-UF */
#define NV_04A_CLIP_B_POINT0                             0x004C05F4 /* -W-4R */
#define NV_04A_CLIP_B_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04A_CLIP_B_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04A_CLIP_B_POINT1                             0x004C05F8 /* -W-4R */
#define NV_04A_CLIP_B_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04A_CLIP_B_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04A_COLOR1_B                                  0x004C05FC /* -W-4R */
#define NV_04A_COLOR1_B_VALUE                                  31:0 /* -W-VF */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0(i)      (0x004C0600+(i)*8) /* -W-4A */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0__SIZE_1                 32 /*       */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_LEFT                  15:0 /* -W-SF */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_TOP                  31:16 /* -W-SF */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1(i)      (0x004C0604+(i)*8) /* -W-4A */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1__SIZE_1                 32 /*       */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_RIGHT                 15:0 /* -W-SF */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM               31:16 /* -W-SF */
#define NV_04A_CLIP_C_POINT0                             0x004C07EC /* -W-4R */
#define NV_04A_CLIP_C_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04A_CLIP_C_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04A_CLIP_C_POINT1                             0x004C07F0 /* -W-4R */
#define NV_04A_CLIP_C_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04A_CLIP_C_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04A_COLOR1_C                                  0x004C07F4 /* -W-4R */
#define NV_04A_COLOR1_C_VALUE                                  31:0 /* -W-VF */
#define NV_04A_SIZE_C                                    0x004C07F8 /* -W-4R */
#define NV_04A_SIZE_C_WIDTH                                    15:0 /* -W-UF */
#define NV_04A_SIZE_C_HEIGHT                                  31:16 /* -W-UF */
#define NV_04A_POINT_C                                   0x004C07FC /* -W-4R */
#define NV_04A_POINT_C_X                                       15:0 /* -W-SF */
#define NV_04A_POINT_C_Y                                      31:16 /* -W-SF */
#define NV_04A_MONOCHROME_COLOR1_C(i)            (0x004C0800+(i)*4) /* -W-4A */
#define NV_04A_MONOCHROME_COLOR1_C__SIZE_1                      128 /*       */
#define NV_04A_MONOCHROME_COLOR1_C_BITMAP                      31:0 /* -W-VF */
#define NV_04A_CLIP_E_POINT0                             0x004C0BE4 /* -W-4R */
#define NV_04A_CLIP_E_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04A_CLIP_E_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04A_CLIP_E_POINT1                             0x004C0BE8 /* -W-4R */
#define NV_04A_CLIP_E_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04A_CLIP_E_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04A_COLOR0_E                                  0x004C0BEC /* -W-4R */
#define NV_04A_COLOR0_E_VALUE                                  31:0 /* -W-VF */
#define NV_04A_COLOR1_E                                  0x004C0BF0 /* -W-4R */
#define NV_04A_COLOR1_E_VALUE                                  31:0 /* -W-VF */
#define NV_04A_SIZE_IN_E                                 0x004C0BF4 /* -W-4R */
#define NV_04A_SIZE_IN_E_WIDTH                                 15:0 /* -W-UF */
#define NV_04A_SIZE_IN_E_HEIGHT                               31:16 /* -W-UF */
#define NV_04A_SIZE_OUT_E                                0x004C0BF8 /* -W-4R */
#define NV_04A_SIZE_OUT_E_WIDTH                                15:0 /* -W-UF */
#define NV_04A_SIZE_OUT_E_HEIGHT                              31:16 /* -W-UF */
#define NV_04A_POINT_E                                   0x004C0BFC /* -W-4R */
#define NV_04A_POINT_E_X                                       15:0 /* -W-SF */
#define NV_04A_POINT_E_Y                                      31:16 /* -W-SF */
#define NV_04A_MONOCHROME_COLOR01_E(i)           (0x004C0C00+(i)*4) /* -W-4A */
#define NV_04A_MONOCHROME_COLOR01_E__SIZE_1                     128 /*       */
#define NV_04A_MONOCHROME_COLOR01_E_BITMAP                     31:0 /* -W-VF */
#define NV_04A_FONT_F                                    0x004C0FF0 /* -W-4R */
#define NV_04A_FONT_F_OFFSET                                   27:0 /* -W-UF */
#define NV_04A_FONT_F_PITCH                                   31:28 /* -W-VF */
#define NV_04A_FONT_F_PITCH_8                            0x00000003 /* -W--V */
#define NV_04A_FONT_F_PITCH_16                           0x00000004 /* -W--V */
#define NV_04A_FONT_F_PITCH_32                           0x00000005 /* -W--V */
#define NV_04A_FONT_F_PITCH_64                           0x00000006 /* -W--V */
#define NV_04A_FONT_F_PITCH_128                          0x00000007 /* -W--V */
#define NV_04A_FONT_F_PITCH_256                          0x00000008 /* -W--V */
#define NV_04A_FONT_F_PITCH_512                          0x00000009 /* -W--V */
#define NV_04A_CLIP_F_POINT0                             0x004C0FF4 /* -W-4R */
#define NV_04A_CLIP_F_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04A_CLIP_F_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04A_CLIP_F_POINT1                             0x004C0FF8 /* -W-4R */
#define NV_04A_CLIP_F_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04A_CLIP_F_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04A_COLOR1_F                                  0x004C0FFC /* -W-4A */
#define NV_04A_COLOR1_F_VALUE                                  31:0 /* -W-VF */
#define NV_04A_CHARACTER_COLOR1_F(i)             (0x004C1000+(i)*4) /* -W-4A */
#define NV_04A_CHARACTER_COLOR1_F__SIZE_1                       256 /*       */
#define NV_04A_CHARACTER_COLOR1_F_INDEX                         7:0 /* -W-UF */
#define NV_04A_CHARACTER_COLOR1_F_X                            19:8 /* -W-SF */
#define NV_04A_CHARACTER_COLOR1_F_Y                           31:20 /* -W-SF */
#define NV_04A_FONT_G                                    0x004C17F0 /* -W-4R */
#define NV_04A_FONT_G_OFFSET                                   27:0 /* -W-UF */
#define NV_04A_FONT_G_PITCH                                   31:28 /* -W-VF */
#define NV_04A_FONT_G_PITCH_8                            0x00000003 /* -W--V */
#define NV_04A_FONT_G_PITCH_16                           0x00000004 /* -W--V */
#define NV_04A_FONT_G_PITCH_32                           0x00000005 /* -W--V */
#define NV_04A_FONT_G_PITCH_64                           0x00000006 /* -W--V */
#define NV_04A_FONT_G_PITCH_128                          0x00000007 /* -W--V */
#define NV_04A_FONT_G_PITCH_256                          0x00000008 /* -W--V */
#define NV_04A_FONT_G_PITCH_512                          0x00000009 /* -W--V */
#define NV_04A_CLIP_G_POINT0                             0x004C17F4 /* -W-4R */
#define NV_04A_CLIP_G_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04A_CLIP_G_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04A_CLIP_G_POINT1                             0x004C17F8 /* -W-4R */
#define NV_04A_CLIP_G_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04A_CLIP_G_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04A_COLOR1_G                                  0x004C17FC /* -W-4A */
#define NV_04A_COLOR1_G_VALUE                                  31:0 /* -W-VF */
#define NV_04A_CHARACTER_COLOR1_G_POINT(i)       (0x004C1800+(i)*8) /* -W-4A */
#define NV_04A_CHARACTER_COLOR1_G_POINT__SIZE_1                 256 /*       */
#define NV_04A_CHARACTER_COLOR1_G_POINT_X                      15:0 /* -W-SF */
#define NV_04A_CHARACTER_COLOR1_G_POINT_Y                     31:16 /* -W-SF */
#define NV_04A_CHARACTER_COLOR1_G_INDEX(i)       (0x004C1804+(i)*8) /* -W-4A */
#define NV_04A_CHARACTER_COLOR1_G_INDEX__SIZE_1                 256 /*       */
#define NV_04A_CHARACTER_COLOR1_G_INDEX_VALUE                  31:0 /* -W-UF */
/* usr_mem_to_mem.ref */
#define NV_MEMORY_TO_MEMORY_FORMAT                       0x00000039 /* ----C */
#define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
#define NV_UMEMFMT_NOP                                   0x004D0100 /* -W-4R */
#define NV_UMEMFMT_NOP_PARAMETER                               31:0 /* -W-VF */
#define NV_UMEMFMT_NOTIFY                                0x004D0104 /* -W-4R */
#define NV_UMEMFMT_NOTIFY_STYLE                                31:0 /* -W-VF */
#define NV_UMEMFMT_NOTIFY_STYLE_WRITE_ONLY               0x00000000 /* -W--V */
#define NV_UMEMFMT_NOTIFY_STYLE_WRITE_THEN_AWAKEN        0x00000001 /* -W--V */
#define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
#define NV_UMEMFMT_SET_NOTIFY__ALIAS_1            NV_UMEMFMT_NOTIFY /*       */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY                0x004D0180 /* -W-4R */
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_INSTANCE             15:0 /* -W-VF */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN             0x004D0184 /* -W-4R */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_INSTANCE          15:0 /* -W-VF */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT            0x004D0188 /* -W-4R */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_INSTANCE         15:0 /* -W-VF */
#define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
#define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
#define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
#define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
#define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
#define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
#define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
#define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
#define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
#define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
#define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
#define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
#define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
/* usr_nv4_stretched_image_from_cpu.ref */
#define NV_STRETCHED_IMAGE_FROM_CPU                      0x00000076 /* ----C */
#define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
#define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
#define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USTRTCH_NOP                                   0x00550100 /* -W-4R */
#define NV_USTRTCH_NOP_PARAMETER                               31:0 /* -W-VF */
#define NV_USTRTCH_NOTIFY                                0x00550104 /* -W-4R */
#define NV_USTRTCH_NOTIFY_STYLE                                31:0 /* -W-VF */
#define NV_USTRTCH_NOTIFY_STYLE_WRITE_ONLY               0x00000000 /* -W--V */
#define NV_USTRTCH_NOTIFY_STYLE_WRITE_THEN_AWAKEN        0x00000001 /* -W--V */
#define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
#define NV_USTRTCH_SET_NOTIFY__ALIAS_1            NV_USTRTCH_NOTIFY /*       */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USTRTCH_SET_PATCH                             0x0055010C /* -W-4R */
#define NV_USTRTCH_SET_PATCH_PARAMETER                         31:0 /* -W-VF */
#define NV_USTRTCH_SET_PATCH_PARAMETER_INVALIDATE        0x00000000 /* -W--V */
#define NV_USTRTCH_SET_PATCH_PARAMETER_VALIDATE          0x00000001 /* -W--V */
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY                0x00550180 /* -W-4R */
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_PARAMETER            31:0 /* -W-VF */
#define NV_USTRTCH_SET_IMAGE_OUTPUT                      0x00550200 /* -W-4R */
#define NV_USTRTCH_SET_IMAGE_OUTPUT_PARAMETER                  31:0 /* -W-VF */
#define NV_USTRTCH_SET_COLOR_FORMAT                      0x00550300 /* -W-4R */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE                         31:0 /* -W-VF */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_R5G6B5            0x00000001 /* -W--V */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_A1R5G5B5          0x00000002 /* -W--V */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_X1R5G5B5          0x00000003 /* -W--V */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_A8R8G8B8          0x00000004 /* -W--V */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_X8R8G8B8          0x00000005 /* -W--V */
#define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
#define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
#define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
#define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
#define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
#define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
#define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
#define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
#define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
/* usr_nv5_stretched_image_from_cpu.ref */
#define NV5_STRETCHED_IMAGE_FROM_CPU                     0x00000066 /* ----C */
#define NV_066                                0x00671FFF:0x00670000 /* -W--D */
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU              0x00670000 /* -W-4R */
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_HANDLE             31:0 /* -WXVF */
#define NV_066_NOP                                       0x00670100 /* -W-4R */
#define NV_066_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_066_NOTIFY                                    0x00670104 /* -W-4R */
#define NV_066_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_066_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_066_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_066_SET_NOTIFY                                0x00670104 /* -W-4R */
#define NV_066_SET_NOTIFY__ALIAS_1                    NV_066_NOTIFY /*       */
#define NV_066_SET_NOTIFY_PARAMETER                            31:0 /* -W-VF */
#define NV_066_SET_NOTIFY_PARAMETER_WRITE                0x00000000 /* -W--V */
#define NV_066_SET_CONTEXT_DMA_NOTIFY                    0x00670180 /* -W-4R */
#define NV_066_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_066_SET_CONTEXT_COLOR_KEY                     0x00670184 /* -W-4R */
#define NV_066_SET_CONTEXT_COLOR_KEY_PARAMETER                 31:0 /* -W-VF */
#define NV_066_SET_CONTEXT_PATTERN                       0x00670188 /* -W-4R */
#define NV_066_SET_CONTEXT_PATTERN_PARAMETER                   31:0 /* -W-VF */
#define NV_066_SET_CONTEXT_ROP                           0x0067018C /* -W-4R */
#define NV_066_SET_CONTEXT_ROP_PARAMETER                       31:0 /* -W-VF */
#define NV_066_SET_CONTEXT_BETA1                         0x00670190 /* -W-4R */
#define NV_066_SET_CONTEXT_BETA1_PARAMETER                     31:0 /* -W-VF */
#define NV_066_SET_CONTEXT_BETA4                         0x00670194 /* -W-4R */
#define NV_066_SET_CONTEXT_BETA4_PARAMETER                     31:0 /* -W-VF */
#define NV_066_SET_CONTEXT_SURFACE                       0x00670198 /* -W-4R */
#define NV_066_SET_CONTEXT_SURFACE_PARAMETER                   31:0 /* -W-VF */
#define NV_066_SET_COLOR_CONVERSION                      0x006702F8 /* -W-4R */
#define NV_066_SET_COLOR_CONVERSION_TYPE                       31:0 /* -W-VF */
#define NV_066_SET_COLOR_CONVERSION_TYPE_DITHER          0x00000000 /* -W--V */
#define NV_066_SET_COLOR_CONVERSION_TYPE_TRUNCATE        0x00000001 /* -W--V */
#define NV_066_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE  0x00000002 /* -W--V */
#define NV_066_SET_OPERATION                             0x006702FC /* -W-4R */
#define NV_066_SET_OPERATION_MODE                              31:0 /* -W-VF */
#define NV_066_SET_OPERATION_MODE_SRCCOPY_AND            0x00000000 /* -W--V */
#define NV_066_SET_OPERATION_MODE_ROP_AND                0x00000001 /* -W--V */
#define NV_066_SET_OPERATION_MODE_BLEND_AND              0x00000002 /* -W--V */
#define NV_066_SET_OPERATION_MODE_SRCCOPY                0x00000003 /* -W--V */
#define NV_066_SET_OPERATION_MODE_SRCCOPY_PREMULT        0x00000004 /* -W--V */
#define NV_066_SET_OPERATION_MODE_BLEND_PREMULT          0x00000005 /* -W--V */
#define NV_066_SET_COLOR_FORMAT                          0x00670300 /* -W-4R */
#define NV_066_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_066_SET_COLOR_FORMAT_LE_R5G6B5                0x00000001 /* -W--V */
#define NV_066_SET_COLOR_FORMAT_LE_A1R5G5B5              0x00000002 /* -W--V */
#define NV_066_SET_COLOR_FORMAT_LE_X1R5G5B5              0x00000003 /* -W--V */
#define NV_066_SET_COLOR_FORMAT_LE_A8R8G8B8              0x00000004 /* -W--V */
#define NV_066_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000005 /* -W--V */
#define NV_066_SIZE_IN                                   0x00670304 /* -W-4R */
#define NV_066_SIZE_IN_WIDTH                                   15:0 /* -W-UF */
#define NV_066_SIZE_IN_HEIGHT                                 31:16 /* -W-UF */
#define NV_066_DELTA_DX_DU                               0x00670308 /* -W-4R */
#define NV_066_DELTA_DX_DU_R_FRACTION                          19:0 /* -W-UF */
#define NV_066_DELTA_DX_DU_R_INT                              31:20 /* -W-UF */
#define NV_066_DELTA_DX_DU_R                                   31:0 /* -W-UF */
#define NV_066_DELTA_DY_DV                               0x0067030C /* -W-4R */
#define NV_066_DELTA_DY_DV_R_FRACTION                          19:0 /* -W-UF */
#define NV_066_DELTA_DY_DV_R_INT                              31:20 /* -W-UF */
#define NV_066_DELTA_DY_DV_R                                   31:0 /* -W-UF */
#define NV_066_CLIP_0                                    0x00670310 /* -W-4R */
#define NV_066_CLIP_0_X                                        15:0 /* -W-SF */
#define NV_066_CLIP_0_Y                                       31:16 /* -W-SF */
#define NV_066_CLIP_1                                    0x00670314 /* -W-4R */
#define NV_066_CLIP_1_WIDTH                                    15:0 /* -W-UF */
#define NV_066_CLIP_1_HEIGHT                                  31:16 /* -W-UF */
#define NV_066_POINT12D4                                 0x00670318 /* -W-4R */
#define NV_066_POINT12D4_X_FRACTION                             3:0 /* -W-SF */
#define NV_066_POINT12D4_X_INT                                 15:4 /* -W-SF */
#define NV_066_POINT12D4_X                                     15:0 /* -W-SF */
#define NV_066_POINT12D4_Y_FRACTION                           19:16 /* -W-SF */
#define NV_066_POINT12D4_Y_INT                                31:20 /* -W-SF */
#define NV_066_POINT12D4_Y                                    31:16 /* -W-SF */
#define NV_066_COLOR(i)                          (0x00670400+(i)*4) /* -W-4A */
#define NV_066_COLOR__SIZE_1                                   1792 /*       */
#define NV_066_COLOR_VALUE                                     31:0 /* -W-VF */
/* usr_nv3_gdi_rectangle_text.ref */
#define NV3_GDI_RECTANGLE_TEXT                           0x0000004B /* ----C */
#define NV_04B                                0x006B1FFF:0x006B0000 /* -W--D */
#define NV_04B_NV3_GDI_RECTANGLE_TEXT                    0x006B0000 /* -W-4R */
#define NV_04B_NOP                                       0x006B0100 /* -W-4R */
#define NV_04B_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_04B_NOTIFY                                    0x006B0104 /* -W-4R */
#define NV_04B_NOTIFY_STYLE                                    31:0 /* -W-VF */
#define NV_04B_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_04B_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_04B_SET_PATCH                                 0x006B010C /* -W-4R */
#define NV_04B_SET_PATCH_PARAMETER                             31:0 /* -W-VF */
#define NV_04B_SET_PATCH_PARAMETER_INVALIDATE            0x00000000 /* -W--V */
#define NV_04B_SET_PATCH_PARAMETER_VALIDATE              0x00000001 /* -W--V */
#define NV_04B_SET_CONTEXT_DMA_NOTIFY                    0x006B0180 /* -W-4R */
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -W-VF */
#define NV_04B_SET_IMAGE_OUTPUT                          0x006B0200 /* -W-4R */
#define NV_04B_SET_IMAGE_OUTPUT_PARAMETER                      31:0 /* -W-VF */
#define NV_04B_SET_COLOR_FORMAT                          0x006B0300 /* -W-4R */
#define NV_04B_SET_COLOR_FORMAT_LE                             31:0 /* -W-VF */
#define NV_04B_SET_COLOR_FORMAT_LE_X24Y8                 0x00000001 /* -W--V */
#define NV_04B_SET_COLOR_FORMAT_LE_X17R5G5B5             0x00000002 /* -W--V */
#define NV_04B_SET_COLOR_FORMAT_LE_X8R8G8B8              0x00000003 /* -W--V */
#define NV_04B_SET_MONOCHROME_FORMAT                     0x006B0304 /* -W-4R */
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE                     31:0 /* -W-VF */
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_CGA6_M1       0x00000001 /* -W--V */
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_LE_M1         0x00000002 /* -W--V */
#define NV_04B_COLOR1_A                                  0x006B03FC /* -W-4R */
#define NV_04B_COLOR1_A_VALUE                                  31:0 /* -W-VF */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT(i)      (0x006B0400+(i)*8) /* -W-4A */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT__SIZE_1                 64 /*       */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_Y                     15:0 /* -W-SF */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_X                    31:16 /* -W-SF */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE(i)       (0x006B0404+(i)*8) /* -W-4A */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE__SIZE_1                  64 /*       */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                 15:0 /* -W-UF */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                 31:16 /* -W-UF */
#define NV_04B_CLIP_B_POINT0                             0x006B07F4 /* -W-4R */
#define NV_04B_CLIP_B_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04B_CLIP_B_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04B_CLIP_B_POINT1                             0x006B07F8 /* -W-4R */
#define NV_04B_CLIP_B_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04B_CLIP_B_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04B_COLOR1_B                                  0x006B07FC /* -W-4R */
#define NV_04B_COLOR1_B_VALUE                                  31:0 /* -W-VF */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0(i)      (0x006B0800+(i)*8) /* -W-4A */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0__SIZE_1                 64 /*       */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_LEFT                  15:0 /* -W-SF */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_TOP                  31:16 /* -W-SF */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1(i)      (0x006B0804+(i)*8) /* -W-4A */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1__SIZE_1                 64 /*       */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_RIGHT                 15:0 /* -W-SF */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_BOTTOM               31:16 /* -W-SF */
#define NV_04B_CLIP_C_POINT0                             0x006B0BEC /* -W-4R */
#define NV_04B_CLIP_C_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04B_CLIP_C_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04B_CLIP_C_POINT1                             0x006B0BF0 /* -W-4R */
#define NV_04B_CLIP_C_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04B_CLIP_C_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04B_COLOR1_C                                  0x006B0BF4 /* -W-4R */
#define NV_04B_COLOR1_C_VALUE                                  31:0 /* -W-VF */
#define NV_04B_SIZE_C                                    0x006B0BF8 /* -W-4R */
#define NV_04B_SIZE_C_WIDTH                                    15:0 /* -W-UF */
#define NV_04B_SIZE_C_HEIGHT                                  31:16 /* -W-UF */
#define NV_04B_POINT_C                                   0x006B0BFC /* -W-4R */
#define NV_04B_POINT_C_X                                       15:0 /* -W-SF */
#define NV_04B_POINT_C_Y                                      31:16 /* -W-SF */
#define NV_04B_MONOCHROME_COLOR1_C(i)            (0x006B0C00+(i)*4) /* -W-4A */
#define NV_04B_MONOCHROME_COLOR1_C__SIZE_1                      128 /*       */
#define NV_04B_MONOCHROME_COLOR1_C_BITMAP                      31:0 /* -W-VF */
#define NV_04B_CLIP_D_POINT0                             0x006B0FE8 /* -W-4R */
#define NV_04B_CLIP_D_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04B_CLIP_D_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04B_CLIP_D_POINT1                             0x006B0FEC /* -W-4R */
#define NV_04B_CLIP_D_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04B_CLIP_D_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04B_COLOR1_D                                  0x006B0FF0 /* -W-4R */
#define NV_04B_COLOR1_D_VALUE                                  31:0 /* -W-VF */
#define NV_04B_SIZE_IN_D                                 0x006B0FF4 /* -W-4R */
#define NV_04B_SIZE_IN_D_WIDTH                                 15:0 /* -W-UF */
#define NV_04B_SIZE_IN_D_HEIGHT                               31:16 /* -W-UF */
#define NV_04B_SIZE_OUT_D                                0x006B0FF8 /* -W-4R */
#define NV_04B_SIZE_OUT_D_WIDTH                                15:0 /* -W-UF */
#define NV_04B_SIZE_OUT_D_HEIGHT                              31:16 /* -W-UF */
#define NV_04B_POINT_D                                   0x006B0FFC /* -W-4R */
#define NV_04B_POINT_D_X                                       15:0 /* -W-SF */
#define NV_04B_POINT_D_Y                                      31:16 /* -W-SF */
#define NV_04B_MONOCHROME_COLOR1_D(i)            (0x006B1000+(i)*4) /* -W-4A */
#define NV_04B_MONOCHROME_COLOR1_D__SIZE_1                      128 /*       */
#define NV_04B_MONOCHROME_COLOR1_D_BITMAP                      31:0 /* -W-VF */
#define NV_04B_CLIP_E_POINT0                             0x006B13E4 /* -W-4R */
#define NV_04B_CLIP_E_POINT0_LEFT                              15:0 /* -W-SF */
#define NV_04B_CLIP_E_POINT0_TOP                              31:16 /* -W-SF */
#define NV_04B_CLIP_E_POINT1                             0x006B13E8 /* -W-4R */
#define NV_04B_CLIP_E_POINT1_RIGHT                             15:0 /* -W-SF */
#define NV_04B_CLIP_E_POINT1_BOTTOM                           31:16 /* -W-SF */
#define NV_04B_COLOR0_E                                  0x006B13EC /* -W-4R */
#define NV_04B_COLOR0_E_VALUE                                  31:0 /* -W-VF */
#define NV_04B_COLOR1_E                                  0x006B13F0 /* -W-4R */
#define NV_04B_COLOR1_E_VALUE                                  31:0 /* -W-VF */
#define NV_04B_SIZE_IN_E                                 0x006B13F4 /* -W-4R */
#define NV_04B_SIZE_IN_E_WIDTH                                 15:0 /* -W-UF */
#define NV_04B_SIZE_IN_E_HEIGHT                               31:16 /* -W-UF */
#define NV_04B_SIZE_OUT_E                                0x006B13F8 /* -W-4R */
#define NV_04B_SIZE_OUT_E_WIDTH                                15:0 /* -W-UF */
#define NV_04B_SIZE_OUT_E_HEIGHT                              31:16 /* -W-UF */
#define NV_04B_POINT_E                                   0x006B13FC /* -W-4R */
#define NV_04B_POINT_E_X                                       15:0 /* -W-SF */
#define NV_04B_POINT_E_Y                                      31:16 /* -W-SF */
#define NV_04B_MONOCHROME_COLOR01_E(i)           (0x006B1400+(i)*4) /* -W-4A */
#define NV_04B_MONOCHROME_COLOR01_E__SIZE_1                     128 /*       */
#define NV_04B_MONOCHROME_COLOR01_E_BITMAP                     31:0 /* -W-VF */
/* usr_context_surfaces_argb_zs.ref */
#define NV4_CONTEXT_SURFACES_ARGB_ZS                     0x00000053 /* ----C */
#define NV_053                                0x00601FFF:0x00600000 /* -W--D */
#define NV_053_NV4_CONTEXT_SURFACES_ARGB_ZS              0x00600000 /* -W-4R */
#define NV_053_NOP                                       0x00600100 /* -W-4R */
#define NV_053_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_053_NOTIFY                                    0x00600104 /* -W-4R */
#define NV_053_NOTIFY_STYLE                                    31:0 /* -WXVF */
#define NV_053_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_053_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_053_SET_CONTEXT_DMA_NOTIFY                    0x00600180 /* -W-4R */
#define NV_053_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -WXVF */
#define NV_053_SET_CONTEXT_DMA_COLOR                     0x00600184 /* -W-4R */
#define NV_053_SET_CONTEXT_DMA_COLOR_PARAMETER                 31:0 /* -WXVF */
#define NV_053_SET_CONTEXT_DMA_ZETA                      0x00600188 /* -W-4R */
#define NV_053_SET_CONTEXT_DMA_ZETA_PARAMETER                  31:0 /* -WXVF */
#define NV_053_SET_CLIP_HORIZONTAL                       0x006002f8 /* -W-4R */
#define NV_053_SET_CLIP_HORIZONTAL_X                           15:0 /* -W-UF */
#define NV_053_SET_CLIP_HORIZONTAL_WIDTH                      31:16 /* -W-UF */
#define NV_053_SET_CLIP_VERTICAL                         0x006002fc /* -W-4R */
#define NV_053_SET_CLIP_VERTICAL_Y                             15:0 /* -W-UF */
#define NV_053_SET_CLIP_VERTICAL_HEIGHT                       31:16 /* -W-UF */
#define NV_053_SET_FORMAT                                0x00600300 /* -W-4R */
#define NV_053_SET_FORMAT_COLOR                                 7:0 /* -W-VF */
#define NV_053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5     0x00000001 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5     0x00000002 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_R5G6B5                0x00000003 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8     0x00000004 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8     0x00000005 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8 0x00000006 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8 0x00000007 /* -W--V */
#define NV_053_SET_FORMAT_COLOR_LE_A8R8G8B8              0x00000008 /* -W--V */
#define NV_053_SET_FORMAT_TYPE                                 15:8 /* -W-VF */
#define NV_053_SET_FORMAT_TYPE_PITCH                     0x00000001 /* -W--V */
#define NV_053_SET_FORMAT_TYPE_SWIZZLE                   0x00000002 /* -W--V */
#define NV_053_SET_FORMAT_WIDTH                               23:16 /* -W-VF */
#define NV_053_SET_FORMAT_HEIGHT                              31:24 /* -W-VF */
#define NV_053_SET_CLIP_SIZE                             0x00600304 /* -W-4R */
#define NV_053_SET_CLIP_SIZE_WIDTH                             15:0 /* -W-UF */
#define NV_053_SET_CLIP_SIZE_HEIGHT                           31:16 /* -W-UF */
#define NV_053_SET_PITCH                                 0x00600308 /* -W-4R */
#define NV_053_SET_PITCH_COLOR                                 15:0 /* -W-UF */
#define NV_053_SET_PITCH_ZETA                                 31:16 /* -W-UF */
#define NV_053_SET_OFFSET_COLOR                          0x0060030C /* -W-4R */
#define NV_053_SET_OFFSET_COLOR_VALUE                         31:0  /* -W-UF */
#define NV_053_SET_OFFSET_ZETA                           0x00600310 /* -W-4R */
#define NV_053_SET_OFFSET_ZETA_VALUE                          31:0  /* -W-UF */
/* usr_nv10_context_surfaces_argb_zs.ref */
#define NV10_CONTEXT_SURFACES_ARGB_ZS                    0x00000093 /* ----C */
#define NV_093                                0x00581FFF:0x00580000 /* -W--D */
#define NV_093_NV10_CONTEXT_SURFACES_ARGB_ZS             0x00580000 /* -W-4R */
#define NV_093_NOP                                       0x00580100 /* -W-4R */
#define NV_093_NOP_PARAMETER                                   31:0 /* -W-VF */
#define NV_093_NOTIFY                                    0x00580104 /* -W-4R */
#define NV_093_NOTIFY_STYLE                                    31:0 /* -WXVF */
#define NV_093_NOTIFY_STYLE_WRITE_ONLY                   0x00000000 /* -W--V */
#define NV_093_NOTIFY_STYLE_WRITE_THEN_AWAKEN            0x00000001 /* -W--V */
#define NV_093_SET_CONTEXT_DMA_NOTIFY                    0x00580180 /* -W-4R */
#define NV_093_SET_CONTEXT_DMA_NOTIFY_PARAMETER                31:0 /* -WXVF */
#define NV_093_SET_CONTEXT_DMA_COLOR                     0x00580184 /* -W-4R */
#define NV_093_SET_CONTEXT_DMA_COLOR_PARAMETER                 31:0 /* -WXVF */
#define NV_093_SET_CONTEXT_DMA_ZETA                      0x00580188 /* -W-4R */
#define NV_093_SET_CONTEXT_DMA_ZETA_PARAMETER                  31:0 /* -WXVF */
#define NV_093_SET_CLIP_HORIZONTAL                       0x005802f8 /* -W-4R */
#define NV_093_SET_CLIP_HORIZONTAL_X                           15:0 /* -W-UF */
#define NV_093_SET_CLIP_HORIZONTAL_WIDTH                      31:16 /* -W-UF */
#define NV_093_SET_CLIP_VERTICAL                         0x005802fc /* -W-4R */
#define NV_093_SET_CLIP_VERTICAL_Y                             15:0 /* -W-UF */
#define NV_093_SET_CLIP_VERTICAL_HEIGHT                       31:16 /* -W-UF */
#define NV_093_SET_FORMAT                                0x00580300 /* -W-4R */
#define NV_093_SET_FORMAT_COLOR                                 7:0 /* -W-VF */
#define NV_093_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5     0x00000001 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5     0x00000002 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_R5G6B5                0x00000003 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8     0x00000004 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8     0x00000005 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8 0x00000006 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8 0x00000007 /* -W--V */
#define NV_093_SET_FORMAT_COLOR_LE_A8R8G8B8              0x00000008 /* -W--V */
#define NV_093_SET_FORMAT_TYPE                                 15:8 /* -W-VF */
#define NV_093_SET_FORMAT_TYPE_PITCH                     0x00000001 /* -W--V */
#define NV_093_SET_FORMAT_TYPE_SWIZZLE                   0x00000002 /* -W--V */
#define NV_093_SET_FORMAT_WIDTH                               23:16 /* -W-VF */
#define NV_093_SET_FORMAT_HEIGHT                              31:24 /* -W-VF */
#define NV_093_SET_CLIP_SIZE                             0x00580304 /* -W-4R */
#define NV_093_SET_CLIP_SIZE_WIDTH                             15:0 /* -W-UF */
#define NV_093_SET_CLIP_SIZE_HEIGHT                           31:16 /* -W-UF */
#define NV_093_SET_PITCH                                 0x00580308 /* -W-4R */
#define NV_093_SET_PITCH_COLOR                                 15:0 /* -W-UF */
#define NV_093_SET_PITCH_ZETA                                 31:16 /* -W-UF */
#define NV_093_SET_OFFSET_COLOR                          0x0058030C /* -W-4R */
#define NV_093_SET_OFFSET_COLOR_VALUE                         31:0  /* -W-UF */
#define NV_093_SET_OFFSET_ZETA                           0x00580310 /* -W-4R */
#define NV_093_SET_OFFSET_ZETA_VALUE                          31:0  /* -W-UF */
/* usr_context_dma.ref */
#define NV_CONTEXT_DMA_IN_MEMORY                         0x0000003D /* ----C */
#define NV_CONTEXT_DMA_FROM_MEMORY                       0x00000002 /* ----C */
#define NV_CONTEXT_DMA_TO_MEMORY                         0x00000003 /* ----C */
#define NV4_CONTEXT_SURFACES_ARGB_ZS                     0x00000053 /* ----C */
/* usr_null_class.ref */
#define NV_NULL_CLASS                                    0x00000030 /* ----C */
/* usr_notifications.ref */
#define NV_STATUS_IN_PROGRESS                   (0x8000)  /* not done    */
#define NV_STATUS_ERROR_PROTECTION_FAULT        (0x4000)  /* fatal error */
#define NV_STATUS_ERROR_BAD_ARGUMENT            (0x2000)  /* fatal error */
#define NV_STATUS_ERROR_INVALID_STATE           (0x1000)  /* fatal error */
#define NV_STATUS_ERROR_STATE_IN_USE            (0x0800)  /* fatal error */
#define NV_STATUS_ERROR_BAD_PATCH               (0x0400)  /* fatal error */
#define NV_STATUS_ERROR_FLOW_CONTROL            (0x0200)  /* fatal error */
#define NV_STATUS_WARNING_INVALID_DATA          (0x0001)  /* warning     */
#define NV_STATUS_NO_ERRORS_OR_WARNINGS         (0x0000)  /* done all ok */
/* dev_pm.ref */
#define NV_PPM                                0x0000AFFF:0x0000A000 /* RW--D */
#define NV_PPM_NV_TRIG0_SEL                              0x0000A400 /* RW-4R */
#define NV_PPM_NV_TRIG0_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP                               0x0000A404 /* RW-4R */
#define NV_PPM_NV_TRIG0_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL                              0x0000A408 /* RW-4R */
#define NV_PPM_NV_TRIG1_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP                               0x0000A40C /* RW-4R */
#define NV_PPM_NV_TRIG1_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL                              0x0000A410 /* RW-4R */
#define NV_PPM_NV_EVENT_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_EVENT_OP                               0x0000A414 /* RW-4R */
#define NV_PPM_NV_EVENT_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_EVENT_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_EVENT_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL                             0x0000A418 /* RW-4R */
#define NV_PPM_NV_SAMPLE_SEL_SEL0                               7:0 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL1                              15:8 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL2                             23:16 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL3                             31:24 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP                              0x0000A41C /* RW-4R */
#define NV_PPM_NV_SAMPLE_OP_FUNC                               15:0 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP_DSEL0                             16:16 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP_DSEL1                             17:17 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL                            0x0000A420 /* RW-4R */
#define NV_PPM_NV_SETFLAG_SEL_SEL0                              7:0 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL1                             15:8 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL2                            23:16 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL3                            31:24 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP                             0x0000A424 /* RW-4R */
#define NV_PPM_NV_SETFLAG_OP_FUNC                              15:0 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP_DSEL0                            16:16 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP_DSEL1                            17:17 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL                            0x0000A428 /* RW-4R */
#define NV_PPM_NV_CLRFLAG_SEL_SEL0                              7:0 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL1                             15:8 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL2                            23:16 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL3                            31:24 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP                             0x0000A42C /* RW-4R */
#define NV_PPM_NV_CLRFLAG_OP_FUNC                              15:0 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP_DSEL0                            16:16 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP_DSEL1                            17:17 /* RWXUF */
#define NV_PPM_NV_ELAPSED_0                              0x0000A600 /* RR-4R */
#define NV_PPM_NV_ELAPSED_0_VAL                                31:0 /* RR-UF */
#define NV_PPM_NV_ELAPSED_1                              0x0000A604 /* RR-4R */
#define NV_PPM_NV_ELAPSED_1_VAL                                 7:0 /* RR-UF */
#define NV_PPM_NV_CYCLECNT_0                             0x0000A608 /* RR-4R */
#define NV_PPM_NV_CYCLECNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_NV_CYCLECNT_1                             0x0000A60C /* RR-4R */
#define NV_PPM_NV_CYCLECNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_NV_EVENTCNT_0                             0x0000A610 /* RR-4R */
#define NV_PPM_NV_EVENTCNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_NV_EVENTCNT_1                             0x0000A614 /* RR-4R */
#define NV_PPM_NV_EVENTCNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_NV_THRESHCNT_0                            0x0000A618 /* RR-4R */
#define NV_PPM_NV_THRESHCNT_0_VAL                              31:0 /* RR-UF */
#define NV_PPM_NV_THRESHCNT_1                            0x0000A61C /* RR-4R */
#define NV_PPM_NV_THRESHCNT_1_VAL                               7:0 /* RR-UF */
#define NV_PPM_NV_TRIGGERCNT                             0x0000A620 /* RW-4R */
#define NV_PPM_NV_TRIGGERCNT_VAL                               31:0 /* RWXUF */
#define NV_PPM_NV_SAMPLECNT                              0x0000A624 /* RW-4R */
#define NV_PPM_NV_SAMPLECNT_VAL                                31:0 /* RWXUF */
#define NV_PPM_NV_THRESHOLD_0                            0x0000A628 /* RW-4R */
#define NV_PPM_NV_THRESHOLD_0_VAL                              31:0 /* RWXUF */
#define NV_PPM_NV_THRESHOLD_1                            0x0000A62C /* RW-4R */
#define NV_PPM_NV_THRESHOLD_1_VAL                               7:0 /* RWXUF */
#define NV_PPM_M_TRIG0_SEL                               0x0000A500 /* RW-4R */
#define NV_PPM_M_TRIG0_SEL_SEL0                                 5:0 /* RWXUF */
#define NV_PPM_M_TRIG0_SEL_SEL1                                13:8 /* RWXUF */
#define NV_PPM_M_TRIG0_SEL_SEL2                               21:16 /* RWXUF */
#define NV_PPM_M_TRIG0_SEL_SEL3                               29:24 /* RWXUF */
#define NV_PPM_M_TRIG0_OP                                0x0000A504 /* RW-4R */
#define NV_PPM_M_TRIG0_OP_FUNC                                 15:0 /* RWXUF */
#define NV_PPM_M_TRIG0_OP_DSEL0                               16:16 /* RWXUF */
#define NV_PPM_M_TRIG0_OP_DSEL1                               17:17 /* RWXUF */
#define NV_PPM_M_TRIG1_SEL                               0x0000A508 /* RW-4R */
#define NV_PPM_M_TRIG1_SEL_SEL0                                 5:0 /* RWXUF */
#define NV_PPM_M_TRIG1_SEL_SEL1                                13:8 /* RWXUF */
#define NV_PPM_M_TRIG1_SEL_SEL2                               21:16 /* RWXUF */
#define NV_PPM_M_TRIG1_SEL_SEL3                               29:24 /* RWXUF */
#define NV_PPM_M_TRIG1_OP                                0x0000A50C /* RW-4R */
#define NV_PPM_M_TRIG1_OP_FUNC                                 15:0 /* RWXUF */
#define NV_PPM_M_TRIG1_OP_DSEL0                               16:16 /* RWXUF */
#define NV_PPM_M_TRIG1_OP_DSEL1                               17:17 /* RWXUF */
#define NV_PPM_M_EVENT_SEL                               0x0000A510 /* RW-4R */
#define NV_PPM_M_EVENT_SEL_SEL0                                 5:0 /* RWXUF */
#define NV_PPM_M_EVENT_SEL_SEL1                                13:8 /* RWXUF */
#define NV_PPM_M_EVENT_SEL_SEL2                               21:16 /* RWXUF */
#define NV_PPM_M_EVENT_SEL_SEL3                               29:24 /* RWXUF */
#define NV_PPM_M_EVENT_OP                                0x0000A514 /* RW-4R */
#define NV_PPM_M_EVENT_OP_FUNC                                 15:0 /* RWXUF */
#define NV_PPM_M_EVENT_OP_DSEL0                               16:16 /* RWXUF */
#define NV_PPM_M_EVENT_OP_DSEL1                               17:17 /* RWXUF */
#define NV_PPM_M_SAMPLE_SEL                              0x0000A518 /* RW-4R */
#define NV_PPM_M_SAMPLE_SEL_SEL0                                5:0 /* RWXUF */
#define NV_PPM_M_SAMPLE_SEL_SEL1                               13:8 /* RWXUF */
#define NV_PPM_M_SAMPLE_SEL_SEL2                              21:16 /* RWXUF */
#define NV_PPM_M_SAMPLE_SEL_SEL3                              29:24 /* RWXUF */
#define NV_PPM_M_SAMPLE_OP                               0x0000A51C /* RW-4R */
#define NV_PPM_M_SAMPLE_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_M_SAMPLE_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_M_SAMPLE_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_M_SETFLAG_SEL                             0x0000A520 /* RW-4R */
#define NV_PPM_M_SETFLAG_SEL_SEL0                               5:0 /* RWXUF */
#define NV_PPM_M_SETFLAG_SEL_SEL1                              13:8 /* RWXUF */
#define NV_PPM_M_SETFLAG_SEL_SEL2                             21:16 /* RWXUF */
#define NV_PPM_M_SETFLAG_SEL_SEL3                             29:24 /* RWXUF */
#define NV_PPM_M_SETFLAG_OP                              0x0000A524 /* RW-4R */
#define NV_PPM_M_SETFLAG_OP_FUNC                               15:0 /* RWXUF */
#define NV_PPM_M_SETFLAG_OP_DSEL0                             16:16 /* RWXUF */
#define NV_PPM_M_SETFLAG_OP_DSEL1                             17:17 /* RWXUF */
#define NV_PPM_M_CLRFLAG_SEL                             0x0000A528 /* RW-4R */
#define NV_PPM_M_CLRFLAG_SEL_SEL0                               5:0 /* RWXUF */
#define NV_PPM_M_CLRFLAG_SEL_SEL1                              13:8 /* RWXUF */
#define NV_PPM_M_CLRFLAG_SEL_SEL2                             21:16 /* RWXUF */
#define NV_PPM_M_CLRFLAG_SEL_SEL3                             29:24 /* RWXUF */
#define NV_PPM_M_CLRFLAG_OP                              0x0000A52C /* RW-4R */
#define NV_PPM_M_CLRFLAG_OP_FUNC                               15:0 /* RWXUF */
#define NV_PPM_M_CLRFLAG_OP_DSEL0                             16:16 /* RWXUF */
#define NV_PPM_M_CLRFLAG_OP_DSEL1                             17:17 /* RWXUF */
#define NV_PPM_M_ELAPSED_0                               0x0000A700 /* RR-4R */
#define NV_PPM_M_ELAPSED_0_VAL                                 31:0 /* RR-UF */
#define NV_PPM_M_ELAPSED_1                               0x0000A704 /* RR-4R */
#define NV_PPM_M_ELAPSED_1_VAL                                  7:0 /* RR-UF */
#define NV_PPM_M_CYCLECNT_0                              0x0000A708 /* RR-4R */
#define NV_PPM_M_CYCLECNT_0_VAL                                31:0 /* RR-UF */
#define NV_PPM_M_CYCLECNT_1                              0x0000A70C /* RR-4R */
#define NV_PPM_M_CYCLECNT_1_VAL                                 7:0 /* RR-UF */
#define NV_PPM_M_EVENTCNT_0                              0x0000A710 /* RR-4R */
#define NV_PPM_M_EVENTCNT_0_VAL                                31:0 /* RR-UF */
#define NV_PPM_M_EVENTCNT_1                              0x0000A714 /* RR-4R */
#define NV_PPM_M_EVENTCNT_1_VAL                                 7:0 /* RR-UF */
#define NV_PPM_M_THRESHCNT_0                             0x0000A718 /* RR-4R */
#define NV_PPM_M_THRESHCNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_M_THRESHCNT_1                             0x0000A71C /* RR-4R */
#define NV_PPM_M_THRESHCNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_M_TRIGGERCNT                              0x0000A720 /* RW-4R */
#define NV_PPM_M_TRIGGERCNT_VAL                                31:0 /* RWXUF */
#define NV_PPM_M_SAMPLECNT                               0x0000A724 /* RW-4R */
#define NV_PPM_M_SAMPLECNT_VAL                                 31:0 /* RWXUF */
#define NV_PPM_M_THRESHOLD_0                             0x0000A728 /* RW-4R */
#define NV_PPM_M_THRESHOLD_0_VAL                               31:0 /* RWXUF */
#define NV_PPM_M_THRESHOLD_1                             0x0000A72C /* RW-4R */
#define NV_PPM_M_THRESHOLD_1_VAL                                7:0 /* RWXUF */
#define NV_PPM_NV_WATCH0                                 0x0000A430 /* RR-4R */
#define NV_PPM_NV_WATCH0_GR_XBAR2FE_PIXCOUNT_REPORT_REQ_NV     0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2CBUF_READY3                   1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2CBUF_READY2                   2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2CBUF_READY1                   3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2CBUF_READY0                   4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2CBUF_STALL                    5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_FEFLUSHACTIVE                      6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_BACKEND_IDLE                       7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2FE_SEMAPHORE_RELEASE_REQ      8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2R2D_BUSY                      9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_PROP2CMB_READY                    10:10 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_CMB2PROP_VALID                    11:11 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_CMB2RSTR_VALID                    12:12 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_RECIRC_CYCLE                      13:13 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_CMB2SHDBE_BUSY                    14:14 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_SHDBE2SHD_VALID                   15:15 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_SHDBE2TEX_BUSY                    16:16 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_SHDBE2CMB_VALID                   17:17 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TFAB_TPB_BUSY                     18:18 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TFAB_TPA_BUSY                     19:19 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TC2FB_P3_STALL                    20:20 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TC2FB_P2_STALL                    21:21 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TC2FB_P1_STALL                    22:22 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TC2FB_P0_STALL                    23:23 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TCDMA2FB_STALL                    24:24 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_DXP_UNALIGN_XFER                  25:25 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_DXP_DXT_XFER                      26:26 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_DXP_PAL_XFER                      27:27 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_DXP_PAL_LOAD                      28:28 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_DXP_XFER1                         29:29 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_DXP_XFER0                         30:30 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TPB_STATUS                        31:31 /* RR-UF */
#define NV_PPM_NV_WATCH1                                 0x0000A434 /* RR-4R */
#define NV_PPM_NV_WATCH1_GR_TPB_RBFR_FULL                      0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPB_INUSE_STALL                    1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPB_XBFR_STALL                     2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_STATUS                         3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_RBFR_FULL                      4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_INUSE_STALL                    5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_XBFR_STALL                     6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_M_TPB_SYNC_BUSY                    7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPB_M_SYNC_VALID                   8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_M_TPA_SYNC_BUSY                    9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_M_SYNC_VALID                  10:10 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_M_TPB_BUSY                        11:11 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPB_M_VALID                       12:12 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_M_TPA_BUSY                        13:13 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_M_VALID                       14:14 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPB_TMAB_BUSY                     15:15 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TMAB_TPB_VALID                    16:16 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TPA_TMAB_BUSY                     17:17 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TMAB_TPA_VALID                    18:18 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TEX2SHD_BUSY                      19:19 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_TEX2SHDBE_VALID                   20:20 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_CACHE_IDLE                        21:21 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_FBI_RDFA_FULL                     22:22 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_FBI_RDFB_FULL                     23:23 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SPF_FULL                          24:24 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_PMI_RDF_FULL                      25:25 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SHD2SHDBE_BUSY                    26:26 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SHD2SHDBE_VALID                   27:27 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SHD_IDLE                          28:28 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SP3_BUSY                          29:29 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SP2_BUSY                          30:30 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_SP1_BUSY                          31:31 /* RR-UF */
#define NV_PPM_NV_WATCH2                                 0x0000A438 /* RR-4R */
#define NV_PPM_NV_WATCH2_GR_SP0_BUSY                           0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_SHD2TEX_VALID                      1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_SHD2RSTR_BUSY                      2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_SHD2CAS_BUSY                       3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CAS2SHD_LAST                       4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CAS2SHD_VALID                      5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CASIDLE                            6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CAS2STP_BUSY                       7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CAS2VTX_BUSY                       8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PROP_OUTPUT_REQ                9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PROP_OUTPUT_NOP               10:10 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_RSTR2D_IDLE                       11:11 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2TEX_IM_RIGHT_DV               12:12 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2TEX_IM_LEFT_DV                13:13 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2TEX_IM_NEWLINE                14:14 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2FE_RSTR2D_BUSY                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ                     16:16 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_RSTR2PROP_ZCULL_COMPRESSED        17:17 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_RSTR2PROP_ZCULL_VALID             18:18 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_RSTR2SHD_EOPRIM                   19:19 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_RSTR2SHD_VALID                    20:20 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_FRSTR2CULL_READY                  21:21 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIXCNT_0                          22:22 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIXCNT_1                          23:23 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIXCNT_2                          24:24 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_FINE_EDGE_EVAL                    25:25 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_FINE_ALIASED                      26:26 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_ZOCL2FB_REQ                       27:27 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CULL2PM_ZCULL3                    28:28 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CULL2PM_ZCULL2                    29:29 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CULL2PM_ZCULL1                    30:30 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_CULL2FRSTR_ZST_COMPRESS           31:31 /* RR-UF */
#define NV_PPM_NV_WATCH3                                 0x0000A43C /* RR-4R */
#define NV_PPM_NV_WATCH3_GR_CULL2FRSTR_DV                      0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_CULL2FRSTR_NULLZ                   1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_CULL2CRSTR_READY                   2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_CRSTR2CULL_VALID                   3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_RSTR2PM_SEARCH_MODE                4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_RSTR2STP_READY                     5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_STP_IDLE                    6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2VTX_NOT_BUSY                   7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2RSTR_VALID                     8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2RSTR_DO_SWATHS                 9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2CAS_VALID                     10:10 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_START_PRIM                 11:11 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_POLYMODE                   12:12 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_DO_POINT                   13:13 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_DO_LINE                    14:14 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_CULL_REASON_0              15:15 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_CULL_REASON_1              16:16 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_STP2PM_CULL_REASON_2              17:17 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_VTX2STP_STATEVALID                18:18 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_VTX2STP_PRIMVALID                 19:19 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_VTX2CAS_VALID                     20:20 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_VTXIDLE                           21:21 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_VTX2XF_LAUNCHBUSY                 22:22 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_VTX2FD_BYPBUSY                    23:23 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF_FETCH_BUSY                     24:24 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF_ISSUE_VALID                    25:25 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF_IDLE                           26:26 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF2VTX_LAUNCH_VALID               27:27 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF2VTX_LAST                       28:28 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF2VTX_VALID                      29:29 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_XF2FD_BUSY                        30:30 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FD_PROCESS1                       31:31 /* RR-UF */
#define NV_PPM_NV_WATCH4                                 0x0000A630 /* RR-4R */
#define NV_PPM_NV_WATCH4_GR_FD_PROCESS0                        0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2XF_LAUNCH                       1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2XF_INIT                         2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2XF_ACTIVE                       3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2XF_VALID                        4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2VTX_BYPVALID                    5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2IDX_BYPBUSY                     6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FD2IDX_BUSY                        7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2FD_LAUNCH                      8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2FD_BYPVALID                    9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2FD_VALID                      10:10 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_INTALIGN                          11:11 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COMPOVFL                          12:12 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_PTEBUSY                           13:13 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_BYPASSFULL                        14:14 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDXIDLE                           15:15 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_SLOTHIT                           16:16 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_SLOTMISS                          17:17 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_CACHEHIT                          18:18 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_CACHEMISS                         19:19 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_CACHEUSAGEWAIT                    20:20 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_CACHEUSAGEFULL                    21:21 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_PTEUSAGEWAIT                      22:22 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2PMI_VALID                     23:23 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2DEC_BUSY                      24:24 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2FBI_INST                      25:25 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_IDX2FBI_VALID                     26:26 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FBI2IDX_BUSY                      27:27 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FE2PM_FBI_REQ_BURST               28:28 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FE2PM_FBI_REQ                     29:29 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FE2PM_FBI_RD                      30:30 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_FE2PM_FBI_INST                    31:31 /* RR-UF */
#define NV_PPM_NV_WATCH5                                 0x0000A634 /* RR-4R */
#define NV_PPM_NV_WATCH5_GR_FE2XBAR_PIXELCOUNT_REPORT_BUSY     0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_FE2PROP_SEMAPHORE_RELEASE_BUSY     1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_FE2PM_CACHE_INVALIDATE             2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_NVINTR_GR                          3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_WAIT_GR_IDLE                       4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_GR_IDLE                            5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_DEC2IDX_VALID_0                    6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_DEC2IDX_VALID_1                    7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_FF_GR_RDY                          8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH5_GR_FF_GR_B2B                          9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_VSYNC1                           10:10 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_FB2ZOCL_BUSY                     11:11 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_COALESCE_0                  12:12 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_COALESCE_1                  13:13 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_COALESCE_2                  14:14 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_BUSY3                       15:15 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_BUSY2                       16:16 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_BUSY1                       17:17 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_CBUF_BUSY0                       18:18 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_PMI2IDX_BUSY                     19:19 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_FF_GR_MDV                        20:20 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_FF_DHV                           21:21 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_FF_CHSW                          22:22 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_BR2PM_DEVSEL_                    23:23 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_BR2PM_STOP_                      24:24 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_BR2PM_TRDY_                      25:25 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_BR2PM_IRDY_                      26:26 /* RR-UF */
#define NV_PPM_NV_WATCH5_TOP_BR2PM_FRAME_                     27:27 /* RR-UF */
#define NV_PPM_M_WATCH0                                  0x0000A530 /* RR-4R */
#define NV_PPM_M_WATCH0_GR_XBARSTATE0_0                        0: 0 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE0_1                        1: 1 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE0_2                        2: 2 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE1_0                        3: 3 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE1_1                        4: 4 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE1_2                        5: 5 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE2_0                        6: 6 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE2_1                        7: 7 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE2_2                        8: 8 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE3_0                        9: 9 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE3_1                       10:10 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBARSTATE3_2                       11:11 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBAR2ZROP_BUSY0                    12:12 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBAR2ZROP_BUSY1                    13:13 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBAR2ZROP_BUSY2                    14:14 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBAR2ZROP_BUSY3                    15:15 /* RR-UF */
#define NV_PPM_M_WATCH0_GR_XBAR2ZROP_IDLE                     16:16 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2ZRD_P0_BUSY                    17:17 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2ZWR_P0_BUSY                    18:18 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2CRD_P0_BUSY                    19:19 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2CWR_P0_BUSY                    20:20 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2ZRD_P0_QEMPTY                  21:21 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2ZWR_P0_QEMPTY                  22:22 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2CRD_P0_QEMPTY                  23:23 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_FB2CWR_P0_QEMPTY                  24:24 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_MC_BUSY_D                 25:25 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_A1_ANY_GNT_VALID          26:26 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_A1_NX_CONT_GNT            27:27 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_A1_GNT_BANK_0             28:28 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_A1_GNT_BANK_1             29:29 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_A1_ZW_GNT_COMPRESS        30:30 /* RR-UF */
#define NV_PPM_M_WATCH0_TOP_P0_FARB_A1_GNT_CLOSE_PAGE         31:31 /* RR-UF */
#define NV_PPM_M_WATCH1                                  0x0000A534 /* RR-4R */
#define NV_PPM_M_WATCH1_TOP_P0_FARB_A1_GNT_RD                  0: 0 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CWR2FB_REQ                         1: 1 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CROP2PM_BURST_STALL_RD             2: 2 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CROP2PM_SB_STALL                   3: 3 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CROP2PM_HASH_STALL                 4: 4 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CROP2XBAR_BUSY                     5: 5 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZWR2FB_REQ                         6: 6 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZROP2XBAR_REQ                      7: 7 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZWR_WAIT4CSUBPKT                   8: 8 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZWR2ZRD_ZSUBPKT_BUSY               9: 9 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZWR2ZRD_PKT_BUSY                  10:10 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZROP2CBUF_CSUBPKT_BUSY            11:11 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZRD2FB_REQ                        12:12 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ILOCK_STALL                       13:13 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_TAG_STALL                         14:14 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_TOSS_CULL                         15:15 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZRD2ZWR_ZSUBPKT_RDY               16:16 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZRD2ZWR_PKT_RDY                   17:17 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZROP2CBUF_ZSUBPKT_BUSY            18:18 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_ZROP2CBUF_PKT_BUSY                19:19 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CBUF2ZROP_ZSUBPKT_RDY             20:20 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CBUF2ZROP_CSUBPKT_RDY             21:21 /* RR-UF */
#define NV_PPM_M_WATCH1_TOP_CBUF2ZROP_PKT_RDY                 22:22 /* RR-UF */
#define NV_PPM_NV_WATCH5_ZEROBIT                              28:28 /* RR-UF */
#define NV_PPM_NV_WATCH5_FE2PM_TRIGGER                        29:29 /* RR-UF */
#define NV_PPM_NV_WATCH5_MFLAG_SYNC                           30:30 /* RR-UF */
#define NV_PPM_NV_WATCH5_NVFLAG                               31:31 /* RR-UF */
#define NV_PPM_M_WATCH1_ZEROBIT                               28:28 /* RR-UF */
#define NV_PPM_M_WATCH1_FE2PM_TRIGGER                         29:29 /* RR-UF */
#define NV_PPM_M_WATCH1_MFLAG                                 30:30 /* RR-UF */
#define NV_PPM_M_WATCH1_NVFLAG_SYNC                           31:31 /* RR-UF */
#define NV_PPM_CONTROL                                   0x0000A73C /* RW-4R */
#define NV_PPM_CONTROL_M_ADDTOEVENT                             0:0 /* RWXUF */
#define NV_PPM_CONTROL_M_ADDTOEVENT_INCR                 0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_M_ADDTOEVENT_ADDTRIG1             0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_DRIVE_OUT                                1:1 /* RWXUF */
#define NV_PPM_CONTROL_DRIVE_OUT_NORMAL                  0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_DRIVE_OUT_OBSERVE                 0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_NV_ADDTOEVENT                            2:2 /* RWXUF */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_INCR                0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_ADDTRIG1            0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_NV_STATE                                 4:3 /* RRIUF */
#define NV_PPM_CONTROL_M_STATE                                  6:5 /* RRIUF */
#define NV_PPM_CONTROL_STATE_IDLE                        0x00000000 /* RRI-V */
#define NV_PPM_CONTROL_STATE_WAIT_TRIG0                  0x00000001 /* RRI-V */
#define NV_PPM_CONTROL_STATE_WAIT_TRIG1                  0x00000002 /* RRI-V */
#define NV_PPM_CONTROL_STATE_CAPTURE                     0x00000003 /* RRI-V */
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE                      8:8 /* RWXUF */
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_DISABLE       0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_ENABLE        0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_M_CLEAR_EVENT_ONCE                       9:9 /* RWXUF */
#define NV_PPM_CONTROL_M_CLEAR_EVENT_ONCE_DISABLE        0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_M_CLEAR_EVENT_ONCE_ENABLE         0x00000001 /* RWI-V */
/* dev_ram.ref */
#define NV_PNVM                               0x3FFFFFFF:0x20000000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x20000000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                            33554432 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXUF */
#define NV_PNVM_DATA016(i)           (0x20000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                           67108864  /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXUF */
#define NV_PNVM_DATA008(i)                         (0x20000000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                           134217728 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXUF */
/* dev_ram.ref */
#define NV_PDFB                               0x3FFFFFFF:0x20000000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMIN                             0x007FFFFF:0x00700000 /* RW--M */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x00710FFF:0x00710000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x007113FF:0x00711000 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x007115FF:0x00711400 /* RW--M */
#define NV_PRAMIN_CTX_0(i)                    (0x00700000 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_0__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_0_NVCLASS                                11:0 /* RWXUF */
#define NV_PRAMIN_CTX_0_NVCLASS_NV_ROOT                  0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_NVCLASS_012                      0x00000012 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_017                      0x00000017 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_018                      0x00000018 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_019                      0x00000019 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01C                      0x0000001C /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01D                      0x0000001D /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01E                      0x0000001E /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01F                      0x0000001F /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_021                      0x00000021 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_030                      0x00000030 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_036                      0x00000036 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_037                      0x00000037 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_038                      0x00000038 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_039                      0x00000039 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_042                      0x00000042 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_043                      0x00000043 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_044                      0x00000044 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_048                      0x00000048 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_04A                      0x0000004A /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_04B                      0x0000004B /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_052                      0x00000052 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_053                      0x00000053 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_054                      0x00000054 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_055                      0x00000055 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_057                      0x00000057 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_058                      0x00000058 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_059                      0x00000059 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05A                      0x0000005A /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05B                      0x0000005B /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05C                      0x0000005C /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05E                      0x0000005E /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05F                      0x0000005F /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_060                      0x00000060 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_061                      0x00000061 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_064                      0x00000064 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_065                      0x00000065 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_066                      0x00000066 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_067                      0x00000067 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_072                      0x00000072 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_076                      0x00000076 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_077                      0x00000077 /* RWC-V */
#define NV_PRAMIN_CTX_0_CHROMA_KEY                            12:12 /* RWXUF */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_DISABLE               0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_ENABLE                0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_USER_CLIP                             13:13 /* RWXUF */
#define NV_PRAMIN_CTX_0_USER_CLIP_DISABLE                0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_USER_CLIP_ENABLE                 0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_SWIZZLE                               14:14 /* RWXUF */
#define NV_PRAMIN_CTX_0_SWIZZLE_DISABLE                  0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_SWIZZLE_ENABLE                   0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG                          17:15 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_AND         0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_ROP_AND             0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_AND           0x00000002 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY             0x00000003 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_PRE         0x00000004 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_PRE           0x00000005 /* RW--V */
#define NV_PRAMIN_CTX_0_SYNCHRONIZE                           18:18 /* RWXUF */
#define NV_PRAMIN_CTX_0_SYNCHRONIZE_DISABLE              0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_SYNCHRONIZE_ENABLE               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_ENDIAN_MODE                           19:19 /* RWXUF */
#define NV_PRAMIN_CTX_0_ENDIAN_MODE_LITTLE               0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_ENDIAN_MODE_BIG                  0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_DITHER_MODE                           21:20 /* RWXUF */
#define NV_PRAMIN_CTX_0_DITHER_MODE_COMPATIBILITY        0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_DITHER_MODE_DITHER               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_DITHER_MODE_TRUNCATE             0x00000002 /* RW--V */
#define NV_PRAMIN_CTX_0_DITHER_MODE_SUBTRACT_TRUNCATE    0x00000003 /* RW--V */
#define NV_PRAMIN_CTX_0_SINGLE_STEP                           23:23 /* RWXUF */
#define NV_PRAMIN_CTX_0_SINGLE_STEP_DISABLE              0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_SINGLE_STEP_ENABLE               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS                          24:24 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_INVALID             0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0                      25:25 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_INVALID         0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_VALID           0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1                      26:26 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_INVALID         0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_VALID           0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN                       27:27 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_INVALID          0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_VALID            0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP                           28:28 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_INVALID              0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_VALID                0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1                         29:29 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_INVALID            0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_VALID              0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4                         30:30 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_INVALID            0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_VALID              0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_1(i)                    (0x00700004 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_1__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_1_MONO_FORMAT                             7:0 /* RWXUF */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_INVALID                    0x00 /* RWD-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_CGA6_M1                    0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_LE_M1                      0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_018                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_044                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_04A                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_04B                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT                           15:8 /* RWXUF */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_INVALID                   0x00 /* RWD-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y8                     0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A8Y8                0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X24Y8                  0x03 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A1R5G5B5               0x06 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X1R5G5B5               0x07 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A1R5G5B5            0x08 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X17R5G5B5              0x09 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_R5G6B5                 0x0A /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16R5G6B5              0x0B /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16R5G6B5              0x0C /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A8R8G8B8               0x0D /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X8R8G8B8               0x0E /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y16                    0x0F /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16Y16                 0x10 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16Y16                 0x11 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_V8YB8U8YA8             0x12 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_YB8V8YA8U8             0x13 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y32                    0x14 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_017                 0x00000002 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_018                 0x00000002 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01C                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01D                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01E                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_021                 0x00000001 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_036                 0x00000001 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_037                 0x00000006 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_044                 0x0000000B /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_04A                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_04B                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_057                 0x0000000B /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05C                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05D                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05E                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_060                 0x0000000A /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_061                 0x0000000A /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_076                 0x0000000A /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_077                 0x00000006 /* RWC-V */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE                       31:16 /* RWXUF */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_INVALID              0x0000 /* RWD-V */
#define NV_PRAMIN_CTX_2(i)                    (0x00700008 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_2__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE                         15:0 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_INVALID               0x0000 /* RWD-V */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE                        31:16 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_INVALID               0x0000 /* RWD-V */
#define NV_PRAMIN_CTX_3(i)                    (0x0070000C + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_3__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_3_METHOD_TRAPS                           31:0 /* RWXUF */
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_DISABLED            0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_4(i)                    (0x00700010 + (i)*16) /* RW--M */
#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXUF */
#define NV_PRAMIN_DATA016(i)         (0x00700000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                           1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                15:0 /* RWXUF */
#define NV_PRAMIN_DATA008(i)                       (0x00700000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                           2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                 7:0 /* RWXUF */
/* dev_ram.ref */
#define NV_FIFO_DMA_OPCODE                    ( 0*32+31):( 0*32+29) /* RWXUF */
#define NV_FIFO_DMA_OPCODE_METHOD                        0x00000000 /* ----V */
#define NV_FIFO_DMA_OPCODE_JUMP                          0x00000001 /* ----V */
#define NV_FIFO_DMA_OPCODE_NONINC_METHOD                 0x00000002 /* ----V */
#define NV_FIFO_DMA_OPCODE2                   ( 0*32+ 1):( 0*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2_NONE                         0x00000000 /* ----V */
#define NV_FIFO_DMA_OPCODE2_JUMP_LONG                    0x00000001 /* ----V */
#define NV_FIFO_DMA_OPCODE2_CALL                         0x00000002 /* ----V */
#define NV_FIFO_DMA_OPCODE                    ( 0*32+31):( 0*32+29) /* RWXUF */
#define NV_FIFO_DMA_OPCODE_METHOD                        0x00000000 /* ----V */
#define NV_FIFO_DMA_OPCODE_NONINC_METHOD                 0x00000002 /* ----V */
#define NV_FIFO_DMA_METHOD_COUNT              ( 0*32+28):( 0*32+18) /* RWXUF */
#define NV_FIFO_DMA_OPCODE3                   ( 0*32+17):( 0*32+16) /* RWXUF */
#define NV_FIFO_DMA_OPCODE3_NONE                         0x00000000 /* ----V */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL         ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_FIFO_DMA_METHOD_ADDRESS            ( 0*32+12):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2                   ( 0*32+ 1):( 0*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2_NONE                         0x00000000 /* ----V */
#define NV_FIFO_DMA_DATA                      ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_NOP                                  0x00000000 /* RWXUF */
#define NV_FIFO_DMA_OPCODE                    ( 0*32+31):( 0*32+29) /* RWXUF */
#define NV_FIFO_DMA_OPCODE_JUMP                          0x00000001 /* ----V */
#define NV_FIFO_DMA_OPCODE2                   ( 0*32+ 1):( 0*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2_NONE                         0x00000000 /* ----V */
#define NV_FIFO_DMA_JUMP_OFFSET               ( 0*32+28):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2                   ( 0*32+ 1):( 0*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2_JUMP_LONG                    0x00000001 /* ----V */
#define NV_FIFO_DMA_JUMP_LONG_OFFSET          ( 0*32+31):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2                   ( 0*32+ 1):( 0*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_OPCODE2_CALL                         0x00000002 /* ----V */
#define NV_FIFO_DMA_CALL_OFFSET               ( 0*32+31):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_RETURN                               0x00020000 /* RWXUF */
#define NV_FIFO_DMA_OPCODE3                   ( 0*32+17):( 0*32+16) /* RWXUF */
#define NV_FIFO_DMA_OPCODE3_RETURN                       0x00000002 /* ----V */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_fb.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_FINE_SEL                                 2:0 /* RWIVF */
#define NV_PFB_DEBUG_0_FINE_SEL_0                        0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_MRS                                      4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_MRS_256                           0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_MRS_2                             0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SPARE0                                   8:8 /* RWIVF */
#define NV_PFB_DEBUG_0_SPARE0_DISABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SPARE0_ENABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2NV                    16:16 /* RWIVF */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2NV_DISABLED      0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2NV_ENABLED       0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2CPU                   17:17 /* RWIVF */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2CPU_DISABLED     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2CPU_ENABLED      0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2AGP                   18:18 /* RWIVF */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2AGP_DISABLED     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2AGP_ENABLED      0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2LDT                   19:19 /* RWIVF */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2LDT_DISABLED     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_RR_M2LDT_ENABLED      0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_FA                         24:24 /* RWIVF */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_FA_DISABLED           0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_XTRA_SETTLE_FA_ENABLED            0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_BURST_INTERRUPT                        27:27 /* RWIVF */
#define NV_PFB_DEBUG_0_BURST_INTERRUPT_ENABLED           0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_BURST_INTERRUPT_DISABLED          0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SPARE1                                 28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_SPARE1_DISABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SPARE1_ENABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SPARE2                                 29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_SPARE2_DISABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SPARE2_ENABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SPARE3                                 30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SPARE3_DISABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SPARE3_ENABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SPARE4                                 31:31 /* RWIVF */
#define NV_PFB_DEBUG_0_SPARE4_DISABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SPARE4_ENABLED                    0x00000001 /* RW--V */
#define NV_PFB_RDI_INDEX                                 0x001000F0 /* RW-4R */
#define NV_PFB_RDI_INDEX_ADDRESS                               12:6 /* RWIVF */
#define NV_PFB_RDI_INDEX_ADDRESS_0                       0x00000000 /* RWI-V */
#define NV_PFB_RDI_INDEX_SELECT                               24:16 /* RWIVF */
#define NV_PFB_RDI_INDEX_SELECT_0                        0x00000000 /* RWI-V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQ_P0                0x00000100 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQ_P1                0x00000101 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQ_P2                0x00000102 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQ_P3                0x00000103 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZOQ_P0                0x00000104 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZOQ_P1                0x00000105 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZOQ_P2                0x00000106 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZOQ_P3                0x00000107 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T0Q_P0                0x00000108 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T0Q_P1                0x00000109 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T0Q_P2                0x0000010A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T0Q_P3                0x0000010B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T1Q_P0                0x0000010C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T1Q_P1                0x0000010D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T1Q_P2                0x0000010E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_T1Q_P3                0x0000010F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZRQ_P0                0x00000110 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZRQ_P1                0x00000111 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZRQ_P2                0x00000112 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZRQ_P3                0x00000113 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQ_P0                0x00000114 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQ_P1                0x00000115 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQ_P2                0x00000116 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQ_P3                0x00000117 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CRQ_P0                0x00000118 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CRQ_P1                0x00000119 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CRQ_P2                0x0000011A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CRQ_P3                0x0000011B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQ_P0                0x0000011C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQ_P1                0x0000011D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQ_P2                0x0000011E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQ_P3                0x0000011F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_EXTQ_P0               0x00000120 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_EXTQ_P1               0x00000121 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_EXTQ_P2               0x00000122 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_EXTQ_P3               0x00000123 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_HP_HPQ_P0                0x00000124 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_HP_HPQ_P1                0x00000125 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_HP_HPQ_P2                0x00000126 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_HP_HPQ_P3                0x00000127 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_AGP_D             0x00000128 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_AGP_BE            0x00000129 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_ISO_D             0x0000012A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_ISO_BE            0x0000012B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_NONISO_D          0x0000012C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_NONISO_BE         0x0000012D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_CPU_D             0x0000012E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_SNQ_CPU_BE            0x0000012F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P0               0x00000130 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P1               0x00000131 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P2               0x00000132 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P3               0x00000133 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_GART_INTFC_CPU_D         0x00000134 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_GART_INTFC_CPU_BE        0x00000135 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_WBC_DATA                 0x00000136 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_CPUQ_P0         0x00000138 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_CPUQ_P1         0x00000139 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_CPUQ_P2         0x0000013A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_CPUQ_P3         0x0000013B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_LDTQ_P0         0x0000013C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_LDTQ_P1         0x0000013D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_LDTQ_P2         0x0000013E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_PA_RTARB_LDTQ_P3         0x0000013F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_RWAQ_P0        0x00000140 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_RWAQ_P1        0x00000141 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_RWAQ_P2        0x00000142 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_RWAQ_P3        0x00000143 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_PRQ_P0         0x00000148 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_PRQ_P1         0x00000149 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_PRQ_P2         0x0000014A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_PRQ_P3         0x0000014B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_ACQ_P0         0x0000014C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_ACQ_P1         0x0000014D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_ACQ_P2         0x0000014E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQHP_ACQ_P3         0x0000014F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQW_P0               0x00000150 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQW_P1               0x00000151 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQW_P2               0x00000152 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_LPQW_P3               0x00000153 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQW_P0               0x00000154 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQW_P1               0x00000155 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQW_P2               0x00000156 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_ZWQW_P3               0x00000157 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQW_P0               0x00000158 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQW_P1               0x00000159 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQW_P2               0x0000015A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_FA_CWQW_P3               0x0000015B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_AGP_P0                0x0000015C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_AGP_P1                0x0000015D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_AGP_P2                0x0000015E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_AGP_P3                0x0000015F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_ISO_P0                0x00000160 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_ISO_P1                0x00000161 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_ISO_P2                0x00000162 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_ISO_P3                0x00000163 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_NONISO_P0             0x00000164 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_NONISO_P1             0x00000165 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_NONISO_P2             0x00000166 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_NONISO_P3             0x00000167 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_CPU_P0                0x00000168 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_CPU_P1                0x00000169 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_CPU_P2                0x0000016A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_CPU_P3                0x0000016B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0HP_P0               0x0000016C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0HP_P1               0x0000016D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0HP_P2               0x0000016E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0HP_P3               0x0000016F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0LP_P0               0x00000170 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0LP_P1               0x00000171 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0LP_P2               0x00000172 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W0LP_P3               0x00000173 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W1LP_P0               0x00000174 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W1LP_P1               0x00000175 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W1LP_P2               0x00000176 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W1LP_P3               0x00000177 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W2LP_P0               0x00000178 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W2LP_P1               0x00000179 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W2LP_P2               0x0000017A /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W2LP_P3               0x0000017B /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W3HP_P0               0x0000017C /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W3HP_P1               0x0000017D /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W3HP_P2               0x0000017E /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_RR_W3HP_P3               0x0000017F /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWAQ_P0        0x000001A0 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWAQ_P1        0x000001A1 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWAQ_P2        0x000001A2 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWAQ_P3        0x000001A3 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWDQ_P0        0x000001A4 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWDQ_P1        0x000001A5 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWDQ_P2        0x000001A6 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_RWDQ_P3        0x000001A7 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_PRQ_P0         0x000001A8 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_PRQ_P1         0x000001A9 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_PRQ_P2         0x000001AA /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_PRQ_P3         0x000001AB /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_ACQ_P0         0x000001AC /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_ACQ_P1         0x000001AD /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_ACQ_P2         0x000001AE /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQFA_ACQ_P3         0x000001AF /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWAQ_P0        0x000001B0 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWAQ_P1        0x000001B1 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWAQ_P2        0x000001B2 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWAQ_P3        0x000001B3 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWDQ_P0        0x000001B4 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWDQ_P1        0x000001B5 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWDQ_P2        0x000001B6 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_RWDQ_P3        0x000001B7 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_PRQ_P0         0x000001B8 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_PRQ_P1         0x000001B9 /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_PRQ_P2         0x000001BA /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_PRQ_P3         0x000001BB /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_ACQ_P0         0x000001BC /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_ACQ_P1         0x000001BD /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_ACQ_P2         0x000001BE /* RW--V */
#define NV_PFB_RDI_INDEX_SELECT_MC_CMDQRT_ACQ_P3         0x000001BF /* RW--V */
#define NV_PFB_RDI_DATA(i)                       (0x00100100+(i)*4) /* RW-4A */
#define NV_PFB_RDI_DATA__SIZE_1                                  16 /*       */
#define NV_PFB_RDI_DATA_FIELD                                  31:0 /* RW-VF */
#define NV_PFB_CFG0                                      0x00100200 /* RW-4R */
#define NV_PFB_CFG0_PART                                        1:0 /* RWIVF */
#define NV_PFB_CFG0_PART_4                               0x00000003 /* RWI-V */
#define NV_PFB_CFG0_PART_1                               0x00000000 /* RW--V */
#define NV_PFB_CFG0_PART_2                               0x00000001 /* RW--V */
#define NV_PFB_CFG0_EXTBANK                                     8:8 /* RWIVF */
#define NV_PFB_CFG0_EXTBANK_0                            0x00000000 /* RW--V */
#define NV_PFB_CFG0_EXTBANK_1                            0x00000001 /* RWI-V */
#define NV_PFB_CFG0_BURST_INT_RD2RD                           16:16 /* RWIVF */
#define NV_PFB_CFG0_BURST_INT_RD2RD_DISABLED             0x00000000 /* RW--V */
#define NV_PFB_CFG0_BURST_INT_RD2RD_ENABLED              0x00000001 /* RWI-V */
#define NV_PFB_CFG0_BURST_INT_WR2WR                           17:17 /* RWIVF */
#define NV_PFB_CFG0_BURST_INT_WR2WR_DISABLED             0x00000000 /* RW--V */
#define NV_PFB_CFG0_BURST_INT_WR2WR_ENABLED              0x00000001 /* RWI-V */
#define NV_PFB_CFG0_BURST_INT_RD2PRE                          18:18 /* RWIVF */
#define NV_PFB_CFG0_BURST_INT_RD2PRE_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CFG0_BURST_INT_RD2PRE_ENABLED             0x00000001 /* RWI-V */
#define NV_PFB_CFG0_SPARE0                                    19:19 /* RWIVF */
#define NV_PFB_CFG0_SPARE0_DISABLED                      0x00000000 /* RWI-V */
#define NV_PFB_CFG0_SPARE0_ENABLED                       0x00000001 /* RW--V */
#define NV_PFB_CFG0_AUTO_PRE_RD                               24:24 /* RWIVF */
#define NV_PFB_CFG0_AUTO_PRE_RD_DISABLED                 0x00000000 /* RW--V */
#define NV_PFB_CFG0_AUTO_PRE_RD_ENABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CFG0_AUTO_PRE_WR                               25:25 /* RWIVF */
#define NV_PFB_CFG0_AUTO_PRE_WR_DISABLED                 0x00000000 /* RW--V */
#define NV_PFB_CFG0_AUTO_PRE_WR_ENABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CFG0_SYNC_MODE                                 26:26 /* RWIVF */
#define NV_PFB_CFG0_SYNC_MODE_DISABLED                   0x00000000 /* RWI-V */
#define NV_PFB_CFG0_SYNC_MODE_ENABLED                    0x00000001 /* RW--V */
#define NV_PFB_CFG0_TWO_CLK_ADDR                              27:27 /* RWIVF */
#define NV_PFB_CFG0_TWO_CLK_ADDR_DISABLE                 0x00000000 /* RWI-V */
#define NV_PFB_CFG0_TWO_CLK_ADDR_ENABLE                  0x00000001 /* RW--V */
#define NV_PFB_CFG1                                      0x00100204 /* RW-4R */
#define NV_PFB_CFG1_APA                                         6:4 /* RWIVF */
#define NV_PFB_CFG1_APA_A8                               0x00000000 /* RWI-V */
#define NV_PFB_CFG1_APA_A9                               0x00000001 /* RW--V */
#define NV_PFB_CFG1_APA_A10                              0x00000002 /* RW--V */
#define NV_PFB_CFG1_APA_A11                              0x00000003 /* RW--V */
#define NV_PFB_CFG1_APA_A12                              0x00000004 /* RW--V */
#define NV_PFB_CFG1_APB                                        10:8 /* RWIVF */
#define NV_PFB_CFG1_APB_A8                               0x00000000 /* RWI-V */
#define NV_PFB_CFG1_APB_A9                               0x00000001 /* RW--V */
#define NV_PFB_CFG1_APB_A10                              0x00000002 /* RW--V */
#define NV_PFB_CFG1_APB_A11                              0x00000003 /* RW--V */
#define NV_PFB_CFG1_APB_A12                              0x00000004 /* RW--V */
#define NV_PFB_CFG1_COL                                       15:12 /* RWIVF */
#define NV_PFB_CFG1_COL_8                                0x00000008 /* RWI-V */
#define NV_PFB_CFG1_COL_9                                0x00000009 /* RW--V */
#define NV_PFB_CFG1_COL_7                                0x00000007 /* RW--V */
#define NV_PFB_CFG1_COL_10                               0x0000000A /* RW--V */
#define NV_PFB_CFG1_ROWA                                      19:16 /* RWIVF */
#define NV_PFB_CFG1_ROWA_11                              0x00000003 /* RWI-V */
#define NV_PFB_CFG1_ROWA_12                              0x00000004 /* RW--V */
#define NV_PFB_CFG1_ROWA_9                               0x00000001 /* RW--V */
#define NV_PFB_CFG1_ROWA_10                              0x00000002 /* RW--V */
#define NV_PFB_CFG1_ROWA_13                              0x00000005 /* RW--V */
#define NV_PFB_CFG1_ROWB                                      23:20 /* RWIVF */
#define NV_PFB_CFG1_ROWB_11                              0x00000003 /* RWI-V */
#define NV_PFB_CFG1_ROWB_12                              0x00000004 /* RW--V */
#define NV_PFB_CFG1_ROWB_9                               0x00000001 /* RW--V */
#define NV_PFB_CFG1_ROWB_10                              0x00000002 /* RW--V */
#define NV_PFB_CFG1_ROWB_13                              0x00000005 /* RW--V */
#define NV_PFB_CFG1_BANKA                                     24:24 /* RWIVF */
#define NV_PFB_CFG1_BANKA_2                              0x00000001 /* RWI-V */
#define NV_PFB_CFG1_BANKA_1                              0x00000000 /* RW--V */
#define NV_PFB_CFG1_BANKB                                     28:28 /* RWIVF */
#define NV_PFB_CFG1_BANKB_2                              0x00000001 /* RWI-V */
#define NV_PFB_CFG1_BANKB_1                              0x00000000 /* RW--V */
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_CSTATUS_RAMAMOUNT_MS                             0:0 /* R--VF */
#define NV_PFB_CSTATUS_RAMAMOUNT_LS                           31:20 /* R--VF */
#define NV_PFB_REFCTRL                                   0x00100210 /* RW-4R */
#define NV_PFB_REFCTRL_PUT                                      6:0 /* RWIVF */
#define NV_PFB_REFCTRL_PUT_0                             0x00000000 /* RWI-V */
#define NV_PFB_REFCTRL_GET                                     14:8 /* RWIVF */
#define NV_PFB_REFCTRL_GET_0                             0x00000000 /* RWI-V */
#define NV_PFB_REFCTRL_VALID                                  31:31 /* RWIVF */
#define NV_PFB_REFCTRL_VALID_0                           0x00000000 /* RWI-V */
#define NV_PFB_REFCTRL_VALID_1                           0x00000001 /* RW--V */
#define NV_PFB_NVM                                       0x00100214 /* RW-4R */
#define NV_PFB_NVM_MODE                                         0:0 /* RWIVF */
#define NV_PFB_NVM_MODE_DISABLE                          0x00000000 /* RWI-V */
#define NV_PFB_NVM_MODE_ENABLE                           0x00000001 /* RW--V */
#define NV_PFB_NVM_LIMIT                                        7:4 /* RW-VF */
#define NV_PFB_NVM_LIMIT_64K                             0x00000000 /* RW--V */
#define NV_PFB_NVM_LIMIT_128K                            0x00000001 /* RW--V */
#define NV_PFB_NVM_LIMIT_192K                            0x00000002 /* RW--V */
#define NV_PFB_NVM_LIMIT_256K                            0x00000003 /* RW--V */
#define NV_PFB_NVM_LIMIT_320K                            0x00000004 /* RW--V */
#define NV_PFB_NVM_LIMIT_384K                            0x00000005 /* RW--V */
#define NV_PFB_NVM_LIMIT_448K                            0x00000006 /* RW--V */
#define NV_PFB_NVM_LIMIT_512K                            0x00000007 /* RW--V */
#define NV_PFB_NVM_LIMIT_576K                            0x00000008 /* RW--V */
#define NV_PFB_NVM_LIMIT_640K                            0x00000009 /* RW--V */
#define NV_PFB_NVM_LIMIT_704K                            0x0000000A /* RW--V */
#define NV_PFB_NVM_LIMIT_768K                            0x0000000B /* RW--V */
#define NV_PFB_NVM_LIMIT_832K                            0x0000000C /* RW--V */
#define NV_PFB_NVM_LIMIT_896K                            0x0000000D /* RW--V */
#define NV_PFB_NVM_LIMIT_960K                            0x0000000E /* RW--V */
#define NV_PFB_NVM_LIMIT_1024K                           0x0000000F /* RW--V */
#define NV_PFB_PIN                                       0x00100218 /* RW-4R */
#define NV_PFB_PIN_CKE                                          0:0 /* RWIVF */
#define NV_PFB_PIN_CKE_POWERDOWN                         0x00000000 /* RWI-V */
#define NV_PFB_PIN_CKE_NORMAL                            0x00000001 /* RW--V */
#define NV_PFB_PIN_DQM                                          4:4 /* RWIVF */
#define NV_PFB_PIN_DQM_NORMAL                            0x00000000 /* RWI-V */
#define NV_PFB_PIN_DQM_INACTIVE                          0x00000001 /* RW--V */
#define NV_PFB_PAD                                       0x0010021C /* RW-4R */
#define NV_PFB_PAD_CKE                                          0:0 /* RWIVF */
#define NV_PFB_PAD_CKE_TRISTATE                          0x00000000 /* RWI-V */
#define NV_PFB_PAD_CKE_NORMAL                            0x00000001 /* RW--V */
#define NV_PFB_TIMING0                                   0x00100220 /* RW-4R */
#define NV_PFB_TIMING0_RC                                       4:0 /* RWIVF */
#define NV_PFB_TIMING0_RC_12                             0x0000000C /* RWI-V */
#define NV_PFB_TIMING0_RC_31                             0x0000001F /* RW--V */
#define NV_PFB_TIMING0_RFC                                     12:8 /* RWIVF */
#define NV_PFB_TIMING0_RFC_14                            0x0000000E /* RWI-V */
#define NV_PFB_TIMING0_RFC_31                            0x0000001F /* RW--V */
#define NV_PFB_TIMING0_RAS                                    19:15 /* RWIVF */
#define NV_PFB_TIMING0_RAS_8                             0x00000008 /* RWI-V */
#define NV_PFB_TIMING0_RAS_31                            0x0000001F /* RW--V */
#define NV_PFB_TIMING0_RD_RCD                                 23:20 /* RWIVF */
#define NV_PFB_TIMING0_RD_RCD_4                          0x00000004 /* RWI-V */
#define NV_PFB_TIMING0_RD_RCD_15                         0x0000000F /* RW--V */
#define NV_PFB_TIMING0_WR_RCD                                 27:24 /* RWIVF */
#define NV_PFB_TIMING0_WR_RCD_4                          0x00000004 /* RWI-V */
#define NV_PFB_TIMING0_WR_RCD_15                         0x0000000F /* RW--V */
#define NV_PFB_TIMING0_RP                                     31:28 /* RWIVF */
#define NV_PFB_TIMING0_RP_4                              0x00000004 /* RWI-V */
#define NV_PFB_TIMING0_RP_15                             0x0000000F /* RW--V */
#define NV_PFB_TIMING1                                   0x00100224 /* RW-4R */
#define NV_PFB_TIMING1_R2W                                      7:4 /* RWIVF */
#define NV_PFB_TIMING1_R2W_5                             0x00000005 /* RWI-V */
#define NV_PFB_TIMING1_R2W_7                             0x00000007 /* RW--V */
#define NV_PFB_TIMING1_R2P                                     11:8 /* RWIVF */
#define NV_PFB_TIMING1_R2P_1                             0x00000001 /* RW--V */
#define NV_PFB_TIMING1_R2P_2                             0x00000002 /* RWI-V */
#define NV_PFB_TIMING1_R2P_3                             0x00000003 /* RW--V */
#define NV_PFB_TIMING1_R2P_7                             0x00000007 /* RW--V */
#define NV_PFB_TIMING1_REXT                                   14:12 /* RWIVF */
#define NV_PFB_TIMING1_REXT_1                            0x00000001 /* RW--V */
#define NV_PFB_TIMING1_REXT_2                            0x00000002 /* RWI-V */
#define NV_PFB_TIMING1_W2R                                    19:16 /* RWIVF */
#define NV_PFB_TIMING1_W2R_3                             0x00000003 /* RW--V */
#define NV_PFB_TIMING1_W2R_4                             0x00000004 /* RWI-V */
#define NV_PFB_TIMING1_W2R_7                             0x00000007 /* RW--V */
#define NV_PFB_TIMING1_W2P                                    23:20 /* RWIVF */
#define NV_PFB_TIMING1_W2P_4                             0x00000004 /* RW--V */
#define NV_PFB_TIMING1_W2P_5                             0x00000005 /* RWI-V */
#define NV_PFB_TIMING1_W2P_7                             0x00000007 /* RW--V */
#define NV_PFB_TIMING1_RRD                                    26:24 /* RWIVF */
#define NV_PFB_TIMING1_RRD_1                             0x00000001 /* RW--V */
#define NV_PFB_TIMING1_RRD_2                             0x00000002 /* RWI-V */
#define NV_PFB_TIMING1_RRD_7                             0x00000007 /* RW--V */
#define NV_PFB_TIMING1_DOE_TYPE                               27:27 /* RWIVF */
#define NV_PFB_TIMING1_DOE_TYPE_0                        0x00000000 /* RWI-V */
#define NV_PFB_TIMING1_DOE_DLY                                30:28 /* RWIVF */
#define NV_PFB_TIMING1_DOE_DLY_7                         0x00000007 /* RWI-V */
#define NV_PFB_TIMING2                                   0x00100228 /* RW-4R */
#define NV_PFB_TIMING2_REFRESH_LO                               4:0 /* C-IVF */
#define NV_PFB_TIMING2_REFRESH_LO_1F                     0x0000001F /* C-I-V */
#define NV_PFB_TIMING2_REFRESH                                 15:5 /* RWIVF */
#define NV_PFB_TIMING2_REFRESH_0                         0x00000000 /* RW--V */
#define NV_PFB_TIMING2_REFRESH_47                        0x0000002F /* RWI-V */
#define NV_PFB_TIMING2_QUSE                                   18:16 /* RWIVF */
#define NV_PFB_TIMING2_QUSE_2                            0x00000002 /* RWI-V */
#define NV_PFB_TIMING2_QUSE_MIN                          0x00000000 /* RW--V */
#define NV_PFB_TIMING2_QUSE_MAX                          0x00000007 /* RW--V */
#define NV_PFB_TIMING2_QINC                                   23:20 /* RWIVF */
#define NV_PFB_TIMING2_QINC_1                            0x00000001 /* RWI-V */
#define NV_PFB_TIMING2_QINC_MIN                          0x00000000 /* RW--V */
#define NV_PFB_TIMING2_QINC_MAX                          0x0000000F /* RW--V */
#define NV_PFB_TIMING2_RDV                                    27:24 /* RWIVF */
#define NV_PFB_TIMING2_RDV_7                             0x00000007 /* RW--V */
#define NV_PFB_TIMING2_RDV_8                             0x00000008 /* RWI-V */
#define NV_PFB_TIMING2_RDV_MIN                           0x00000002 /* RW--V */
#define NV_PFB_TIMING2_RDV_MAX                           0x0000000E /* RW--V */
#define NV_PFB_TILE(i)                          (0x00100240+(i)*16) /* RW-4A */
#define NV_PFB_TILE__SIZE_1                                       8 /*       */
#define NV_PFB_TILE_REGION                                      0:0 /* RWIVF */
#define NV_PFB_TILE_REGION_INVALID                       0x00000000 /* RWI-V */
#define NV_PFB_TILE_REGION_VALID                         0x00000001 /* RW--V */
#define NV_PFB_TILE_BANK0_SENSE                                 1:1 /* RWIVF */
#define NV_PFB_TILE_BANK0_SENSE_0                        0x00000000 /* RWI-V */
#define NV_PFB_TILE_BANK0_SENSE_1                        0x00000001 /* RW--V */
#define NV_PFB_TILE_ADR                                       31:14 /* RW-UF */
#define NV_PFB_TLIMIT(i)                        (0x00100244+(i)*16) /* RW-4A */
#define NV_PFB_TLIMIT__SIZE_1                                     8 /*       */
#define NV_PFB_TLIMIT_ADR                                     31:14 /* RW-UF */
#define NV_PFB_TLIMIT_ADR_LO                                   13:0 /* C-IVF */
#define NV_PFB_TLIMIT_ADR_LO_3FFF                       0x000003FFF /* C-I-V */
#define NV_PFB_TSIZE(i)                         (0x00100248+(i)*16) /* RW-4A */
#define NV_PFB_TSIZE__SIZE_1                                      8 /*       */
#define NV_PFB_TSIZE_PITCH                                     15:8 /* RW-UF */
#define NV_PFB_TSIZE_PITCH_0200                          0x00000002 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0300                          0x00000003 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0400                          0x00000004 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0500                          0x00000005 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0600                          0x00000006 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0700                          0x00000007 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0800                          0x00000008 /* RW--V */
#define NV_PFB_TSIZE_PITCH_0A00                          0x0000000A /* RW--V */
#define NV_PFB_TSIZE_PITCH_0C00                          0x0000000C /* RW--V */
#define NV_PFB_TSIZE_PITCH_0E00                          0x0000000E /* RW--V */
#define NV_PFB_TSIZE_PITCH_1000                          0x00000010 /* RW--V */
#define NV_PFB_TSIZE_PITCH_1400                          0x00000014 /* RW--V */
#define NV_PFB_TSIZE_PITCH_1800                          0x00000018 /* RW--V */
#define NV_PFB_TSIZE_PITCH_1C00                          0x0000001C /* RW--V */
#define NV_PFB_TSIZE_PITCH_2000                          0x00000020 /* RW--V */
#define NV_PFB_TSIZE_PITCH_2800                          0x00000028 /* RW--V */
#define NV_PFB_TSIZE_PITCH_3000                          0x00000030 /* RW--V */
#define NV_PFB_TSIZE_PITCH_3800                          0x00000038 /* RW--V */
#define NV_PFB_TSIZE_PITCH_4000                          0x00000040 /* RW--V */
#define NV_PFB_TSIZE_PITCH_5000                          0x00000050 /* RW--V */
#define NV_PFB_TSIZE_PITCH_6000                          0x00000060 /* RW--V */
#define NV_PFB_TSIZE_PITCH_7000                          0x00000070 /* RW--V */
#define NV_PFB_TSIZE_PITCH_8000                          0x00000080 /* RW--V */
#define NV_PFB_TSIZE_PITCH_A000                          0x000000A0 /* RW--V */
#define NV_PFB_TSIZE_PITCH_C000                          0x000000C0 /* RW--V */
#define NV_PFB_TSIZE_PITCH_E000                          0x000000E0 /* RW--V */
#define NV_PFB_TSTATUS(i)                       (0x0010024C+(i)*16) /* R--4A */
#define NV_PFB_TSTATUS__SIZE_1                                    8 /*       */
#define NV_PFB_TSTATUS_PRIME                                    1:0 /* R--VF */
#define NV_PFB_TSTATUS_PRIME_1                           0x00000000 /* R---V */
#define NV_PFB_TSTATUS_PRIME_3                           0x00000001 /* R---V */
#define NV_PFB_TSTATUS_PRIME_5                           0x00000002 /* R---V */
#define NV_PFB_TSTATUS_PRIME_7                           0x00000003 /* R---V */
#define NV_PFB_TSTATUS_FACTOR                                   6:4 /* R--VF */
#define NV_PFB_TSTATUS_FACTOR_1                          0x00000000 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_2                          0x00000001 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_4                          0x00000002 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_8                          0x00000003 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_16                         0x00000004 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_32                         0x00000005 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_64                         0x00000006 /* R---V */
#define NV_PFB_TSTATUS_FACTOR_128                        0x00000007 /* R---V */
#define NV_PFB_TSTATUS_REGION                                 31:31 /* R-IVF */
#define NV_PFB_TSTATUS_REGION_INVALID                    0x00000000 /* R-I-V */
#define NV_PFB_TSTATUS_REGION_VALID                      0x00000001 /* R---V */
#define NV_PFB_MRS                                       0x001002C0 /* RW-4R */
#define NV_PFB_MRS_A0                                           0:0 /* RWIVF */
#define NV_PFB_MRS_A0_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A0_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A1                                           1:1 /* RWIVF */
#define NV_PFB_MRS_A1_0                                  0x00000000 /* RW--V */
#define NV_PFB_MRS_A1_1                                  0x00000001 /* RWI-V */
#define NV_PFB_MRS_A2                                           2:2 /* RWIVF */
#define NV_PFB_MRS_A2_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A2_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A3                                           3:3 /* RWIVF */
#define NV_PFB_MRS_A3_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A3_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A4                                           4:4 /* RWIVF */
#define NV_PFB_MRS_A4_0                                  0x00000000 /* RW--V */
#define NV_PFB_MRS_A4_1                                  0x00000001 /* RWI-V */
#define NV_PFB_MRS_A5                                           5:5 /* RWIVF */
#define NV_PFB_MRS_A5_0                                  0x00000000 /* RW--V */
#define NV_PFB_MRS_A5_1                                  0x00000001 /* RWI-V */
#define NV_PFB_MRS_A6                                           6:6 /* RWIVF */
#define NV_PFB_MRS_A6_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A6_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A7                                           7:7 /* RWIVF */
#define NV_PFB_MRS_A7_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A7_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A8                                           8:8 /* RWIVF */
#define NV_PFB_MRS_A8_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A8_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A9                                           9:9 /* RWIVF */
#define NV_PFB_MRS_A9_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A9_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A10                                        10:10 /* RWIVF */
#define NV_PFB_MRS_A10_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_A10_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_A11                                        11:11 /* RWIVF */
#define NV_PFB_MRS_A11_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_A11_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_A12                                        12:12 /* RWIVF */
#define NV_PFB_MRS_A12_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_A12_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_BA0                                        20:20 /* RWIVF */
#define NV_PFB_MRS_BA0_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_BA0_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_BA1                                        21:21 /* RWIVF */
#define NV_PFB_MRS_BA1_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_BA1_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS                                      0x001002C4 /* RW-4R */
#define NV_PFB_EMRS_A0                                          0:0 /* RWIVF */
#define NV_PFB_EMRS_A0_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A0_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A1                                          1:1 /* RWIVF */
#define NV_PFB_EMRS_A1_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A1_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A2                                          2:2 /* RWIVF */
#define NV_PFB_EMRS_A2_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A2_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A3                                          3:3 /* RWIVF */
#define NV_PFB_EMRS_A3_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A3_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A4                                          4:4 /* RWIVF */
#define NV_PFB_EMRS_A4_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A4_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A5                                          5:5 /* RWIVF */
#define NV_PFB_EMRS_A5_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A5_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A6                                          6:6 /* RWIVF */
#define NV_PFB_EMRS_A6_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A6_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A7                                          7:7 /* RWIVF */
#define NV_PFB_EMRS_A7_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A7_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A8                                          8:8 /* RWIVF */
#define NV_PFB_EMRS_A8_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A8_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A9                                          9:9 /* RWIVF */
#define NV_PFB_EMRS_A9_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A9_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A10                                       10:10 /* RWIVF */
#define NV_PFB_EMRS_A10_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A10_1                                0x00000001 /* RW--V */
#define NV_PFB_EMRS_A11                                       11:11 /* RWIVF */
#define NV_PFB_EMRS_A11_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A11_1                                0x00000001 /* RW--V */
#define NV_PFB_EMRS_A12                                       12:12 /* RWIVF */
#define NV_PFB_EMRS_A12_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A12_1                                0x00000001 /* RW--V */
#define NV_PFB_EMRS_BA0                                       20:20 /* RWIVF */
#define NV_PFB_EMRS_BA0_0                                0x00000000 /* RW--V */
#define NV_PFB_EMRS_BA0_1                                0x00000001 /* RWI-V */
#define NV_PFB_EMRS_BA1                                       21:21 /* RWIVF */
#define NV_PFB_EMRS_BA1_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_BA1_1                                0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT                                   0x001002C8 /* RW-4R */
#define NV_PFB_MRS_EXT_A0                                       0:0 /* RWIVF */
#define NV_PFB_MRS_EXT_A0_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A0_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A1                                       1:1 /* RWIVF */
#define NV_PFB_MRS_EXT_A1_0                              0x00000000 /* RW--V */
#define NV_PFB_MRS_EXT_A1_1                              0x00000001 /* RWI-V */
#define NV_PFB_MRS_EXT_A2                                       2:2 /* RWIVF */
#define NV_PFB_MRS_EXT_A2_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A2_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A3                                       3:3 /* RWIVF */
#define NV_PFB_MRS_EXT_A3_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A3_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A4                                       4:4 /* RWIVF */
#define NV_PFB_MRS_EXT_A4_0                              0x00000000 /* RW--V */
#define NV_PFB_MRS_EXT_A4_1                              0x00000001 /* RWI-V */
#define NV_PFB_MRS_EXT_A5                                       5:5 /* RWIVF */
#define NV_PFB_MRS_EXT_A5_0                              0x00000000 /* RW--V */
#define NV_PFB_MRS_EXT_A5_1                              0x00000001 /* RWI-V */
#define NV_PFB_MRS_EXT_A6                                       6:6 /* RWIVF */
#define NV_PFB_MRS_EXT_A6_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A6_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A7                                       7:7 /* RWIVF */
#define NV_PFB_MRS_EXT_A7_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A7_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A8                                       8:8 /* RWIVF */
#define NV_PFB_MRS_EXT_A8_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A8_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A9                                       9:9 /* RWIVF */
#define NV_PFB_MRS_EXT_A9_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A9_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A10                                    10:10 /* RWIVF */
#define NV_PFB_MRS_EXT_A10_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A10_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A11                                    11:11 /* RWIVF */
#define NV_PFB_MRS_EXT_A11_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A11_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A12                                    12:12 /* RWIVF */
#define NV_PFB_MRS_EXT_A12_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A12_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_BA0                                    20:20 /* RWIVF */
#define NV_PFB_MRS_EXT_BA0_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_BA0_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_BA1                                    21:21 /* RWIVF */
#define NV_PFB_MRS_EXT_BA1_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_BA1_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT                                  0x001002CC /* RW-4R */
#define NV_PFB_EMRS_EXT_A0                                      0:0 /* RWIVF */
#define NV_PFB_EMRS_EXT_A0_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A0_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A1                                      1:1 /* RWIVF */
#define NV_PFB_EMRS_EXT_A1_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A1_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A2                                      2:2 /* RWIVF */
#define NV_PFB_EMRS_EXT_A2_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A2_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A3                                      3:3 /* RWIVF */
#define NV_PFB_EMRS_EXT_A3_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A3_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A4                                      4:4 /* RWIVF */
#define NV_PFB_EMRS_EXT_A4_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A4_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A5                                      5:5 /* RWIVF */
#define NV_PFB_EMRS_EXT_A5_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A5_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A6                                      6:6 /* RWIVF */
#define NV_PFB_EMRS_EXT_A6_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A6_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A7                                      7:7 /* RWIVF */
#define NV_PFB_EMRS_EXT_A7_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A7_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A8                                      8:8 /* RWIVF */
#define NV_PFB_EMRS_EXT_A8_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A8_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A9                                      9:9 /* RWIVF */
#define NV_PFB_EMRS_EXT_A9_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A9_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A10                                   10:10 /* RWIVF */
#define NV_PFB_EMRS_EXT_A10_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A10_1                            0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A11                                   11:11 /* RWIVF */
#define NV_PFB_EMRS_EXT_A11_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A11_1                            0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A12                                   12:12 /* RWIVF */
#define NV_PFB_EMRS_EXT_A12_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A12_1                            0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_BA0                                   20:20 /* RWIVF */
#define NV_PFB_EMRS_EXT_BA0_0                            0x00000000 /* RW--V */
#define NV_PFB_EMRS_EXT_BA0_1                            0x00000001 /* RWI-V */
#define NV_PFB_EMRS_EXT_BA1                                   21:21 /* RWIVF */
#define NV_PFB_EMRS_EXT_BA1_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_BA1_1                            0x00000001 /* RW--V */
#define NV_PFB_REF                                       0x001002D0 /* -W-4R */
#define NV_PFB_REF_CMD                                          0:0 /* -WIVF */
#define NV_PFB_REF_CMD_REFRESH                           0x00000000 /* -WI-V */
#define NV_PFB_REF_CMD_REFRESH_1                         0x00000001 /* -W--T */
#define NV_PFB_PRE                                       0x001002D4 /* -W-4R */
#define NV_PFB_PRE_CMD                                          0:0 /* -WIVF */
#define NV_PFB_PRE_CMD_PRECHARGE                         0x00000000 /* -WI-V */
#define NV_PFB_PRE_CMD_PRECHARGE_1                       0x00000001 /* -W--T */
#define NV_PFB_ZCOMP(i)                          (0x00100300+(i)*4) /* RW-4A */
#define NV_PFB_ZCOMP__SIZE_1                                      8 /*       */
#define NV_PFB_ZCOMP_BASE_TAG_ADR                              17:6 /* RW-UF */
#define NV_PFB_ZCOMP_MODE                                     26:26 /* RWIVF */
#define NV_PFB_ZCOMP_MODE_16                             0x00000000 /* RW--V */
#define NV_PFB_ZCOMP_MODE_32                             0x00000001 /* RWI-V */
#define NV_PFB_ZCOMP_ENDIAN                                   27:27 /* RWIVF */
#define NV_PFB_ZCOMP_ENDIAN_LITTLE                       0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_ENDIAN_BIG                          0x00000001 /* RW--V */
#define NV_PFB_ZCOMP_AA                                       29:28 /* RWIVF */
#define NV_PFB_ZCOMP_AA_DISABLED                         0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_AA_CENTER_1                         0x00000001 /* RW--V */
#define NV_PFB_ZCOMP_AA_CENTER_CORNER_2                  0x00000002 /* RW--V */
#define NV_PFB_ZCOMP_AA_SQUARE_OFFSET_4                  0x00000003 /* RW--V */
#define NV_PFB_ZCOMP_EN                                       31:31 /* RWIVF */
#define NV_PFB_ZCOMP_EN_FALSE                            0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_EN_TRUE                             0x00000001 /* RW--V */
#define NV_PFB_ZCOMP_MAX_TAG                             0x00100320 /* R-X4R */
#define NV_PFB_ZCOMP_MAX_TAG_ADR_LO                             5:0 /* C-IVF */
#define NV_PFB_ZCOMP_MAX_TAG_ADR_LO_3F                   0x0000003F /* C-I-V */
#define NV_PFB_ZCOMP_MAX_TAG_ADR                               17:6 /* C-IVF */
#define NV_PFB_ZCOMP_MAX_TAG_ADR_VALUE                   0x0000012B /* C-I-V */
#define NV_PFB_ZCOMP_OFFSET                              0x00100324 /* RW-4R */
#define NV_PFB_ZCOMP_OFFSET_ADR_SPACE                           3:0 /* RW-UF */
#define NV_PFB_ZCOMP_OFFSET_ZCULL_COMP_ONLY_EN                  4:4 /* RWIVF */
#define NV_PFB_ZCOMP_OFFSET_ZCULL_COMP_ONLY_EN_FALSE     0x00000000 /* RW--V */
#define NV_PFB_ZCOMP_OFFSET_ZCULL_COMP_ONLY_EN_TRUE      0x00000001 /* RWI-V */
#define NV_PFB_ZCOMP_OFFSET_ADR                               25:14 /* RW-UF */
#define NV_PFB_ZCOMP_OFFSET_EN                                31:31 /* RWIVF */
#define NV_PFB_ZCOMP_OFFSET_EN_FALSE                     0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_OFFSET_EN_TRUE                      0x00000001 /* RW--V */
#define NV_PFB_ARB_PREDIVIDER                            0x00100328 /* RW-4R */
#define NV_PFB_ARB_PREDIVIDER_DIV                               7:0 /* RWIUF */
#define NV_PFB_ARB_PREDIVIDER_DIV_0                      0x00000000 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_1                      0x00000001 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_2                      0x00000002 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_3                      0x00000003 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_4                      0x00000004 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_5                      0x00000005 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_6                      0x00000006 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_7                      0x00000007 /* RWIUV */
#define NV_PFB_ARB_PREDIVIDER_DIV_8                      0x00000008 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_9                      0x00000009 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_10                     0x0000000A /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_11                     0x0000000B /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_12                     0x0000000C /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_13                     0x0000000D /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_14                     0x0000000E /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_15                     0x0000000F /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_16                     0x00000010 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_DIV_20                     0x00000014 /* RW-UV */
#define NV_PFB_ARB_PREDIVIDER_TIMEOUT_CONT_GNT                12:12 /* RWIUF */
#define NV_PFB_ARB_PREDIVIDER_TIMEOUT_CONT_GNT_DISABLE   0x00000000 /* RWIUV */
#define NV_PFB_ARB_PREDIVIDER_TIMEOUT_CONT_GNT_ENABLE    0x00000001 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT                               0x0010032C /* RW-4R */
#define NV_PFB_ARB_TIMEOUT_EXT                                  3:0 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_EXT_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_EXT_14                        0x0000000E /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_EXT_DISABLE                   0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_LP                                   7:4 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_LP_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_LP_DISABLE                    0x0000000F /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_ZO                                  11:8 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_ZO_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZO_DISABLE                    0x0000000F /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_TX                                 15:12 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_TX_3                          0x00000003 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_TX_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_TX_12                         0x0000000C /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_TX_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZR                                 19:16 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_ZR_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZR_DISABLE                    0x0000000F /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_ZW                                 23:20 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_ZW_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZW_DISABLE                    0x0000000F /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_CR                                 27:24 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_CR_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_CR_DISABLE                    0x0000000F /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_CW                                 31:28 /* RWIUF */
#define NV_PFB_ARB_TIMEOUT_CW_8                          0x00000008 /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_CW_DISABLE                    0x0000000F /* RWIUV */
#define NV_PFB_ARB_XFER_SZ                               0x00100330 /* RW-4R */
#define NV_PFB_ARB_XFER_SZ_EXT                                  3:0 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_EXT_4                         0x00000002 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_EXT_8                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_EXT_MIN                       0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_EXT_INF                       0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_LP                                   7:4 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_LP_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_LP_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_LP_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZO                                  11:8 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_ZO_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_ZO_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZO_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_TX                                 15:12 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_TX_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_TX_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_TX_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZR                                 19:16 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_ZR_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_ZR_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZR_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZW                                 23:20 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_ZW_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_ZW_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZW_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CR                                 27:24 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_CR_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_CR_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CR_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CW                                 31:28 /* RWIUF */
#define NV_PFB_ARB_XFER_SZ_CW_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_CW_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CW_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_REM                              0x00100334 /* RW-4R */
#define NV_PFB_ARB_XFER_REM_EXT                                 3:0 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_EXT_0                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_EXT_4                        0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_EXT_8                        0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_LP                                  7:4 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_LP_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_LP_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_LP_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZO                                 11:8 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_ZO_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZO_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_ZO_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_TX                                15:12 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_TX_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_TX_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_TX_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZR                                19:16 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_ZR_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZR_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_ZR_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZW                                23:20 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_ZW_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZW_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_ZW_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CR                                27:24 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_CR_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CR_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_CR_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CW                                31:28 /* RWIUF */
#define NV_PFB_ARB_XFER_REM_CW_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CW_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_CW_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK                             0x00100338 /* RW-4R */
#define NV_PFB_ARB_DIFF_BANK_EXT                                0:0 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_EXT_DISABLED                0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_EXT_ENABLED                 0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_LP                                 1:1 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_LP_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_LP_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_ZO                                 2:2 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_ZO_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_ZO_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_TX                                 3:3 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_TX_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_TX_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_ZR                                 4:4 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_ZR_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_ZR_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_ZW                                 5:5 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_ZW_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_ZW_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_CR                                 6:6 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_CR_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_CR_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_CW                                 7:7 /* RWIUF */
#define NV_PFB_ARB_DIFF_BANK_CW_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_CW_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0                               0x00100340 /* RW-4R */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_EXT                         0:0 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_EXT_DISABLED         0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_EXT_ENABLED          0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LP                          1:1 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LP_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LP_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZO                          2:2 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZO_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZO_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_TX                          3:3 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_TX_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_TX_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZR                          4:4 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZR_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZR_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZW                          5:5 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZW_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZW_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CR                          6:6 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CR_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CR_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CW                          7:7 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CW_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CW_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_HP                          8:8 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_HP_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_HP_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CPU                         9:9 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CPU_DISABLED         0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CPU_ENABLED          0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LDT                       10:10 /* RWIUF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LDT_DISABLED         0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LDT_ENABLED          0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1                               0x00100344 /* RW-4R */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_EXT                        0:0 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_EXT_DISABLED        0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_EXT_ENABLED         0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LP                         1:1 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LP_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LP_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZO                         2:2 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZO_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZO_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_TX                         3:3 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_TX_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_TX_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZR                         4:4 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZR_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZR_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZW                         5:5 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZW_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZW_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CR                         6:6 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CR_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CR_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CW                         7:7 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CW_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CW_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_HP                         8:8 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_HP_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_HP_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CPU                        9:9 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CPU_DISABLED        0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CPU_ENABLED         0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LDT                      10:10 /* RWIUF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LDT_DISABLED        0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LDT_ENABLED         0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2                               0x00100348 /* RW-4R */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_EXT                          0:0 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_EXT_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_EXT_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LP                           1:1 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LP_DISABLED           0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LP_ENABLED            0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZO                           2:2 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZO_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZO_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_TX                           3:3 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_TX_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_TX_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZR                           4:4 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZR_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZR_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZW                           5:5 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZW_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZW_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CR                           6:6 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CR_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CR_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CW                           7:7 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CW_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CW_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_HP                           8:8 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_HP_DISABLED           0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_HP_ENABLED            0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CPU                          9:9 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CPU_DISABLED          0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CPU_ENABLED           0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LDT                        10:10 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LDT_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LDT_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_GART                        11:11 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_GART_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_GART_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_WBC_LP                      12:12 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_WBC_LP_DISABLED        0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_WBC_LP_ENABLED         0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_WBC_HP                      13:13 /* RWIUF */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_WBC_HP_DISABLED        0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_ALWAYS_WBC_HP_ENABLED         0x00000001 /* RW-UV */
#define NV_PFB_BPARB                                     0x0010034C /* RW-4R */
#define NV_PFB_BPARB_HP_ARB_MODE                                2:0 /* RWIUF */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_10           0x00000000 /* RWIUV */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_8            0x00000001 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_6            0x00000002 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_4            0x00000003 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_NEVER              0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0                                     0x00100350 /* RW-4R */
#define NV_PFB_CMDQ0_FA_RW                                      4:0 /* RWIUF */
#define NV_PFB_CMDQ0_FA_RW_4                             0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0_FA_RW_5                             0x00000005 /* RW-UV */
#define NV_PFB_CMDQ0_FA_RW_6                             0x00000006 /* RW-UV */
#define NV_PFB_CMDQ0_FA_RW_7                             0x00000007 /* RW-UV */
#define NV_PFB_CMDQ0_FA_RW_8                             0x00000008 /* RW-UV */
#define NV_PFB_CMDQ0_FA_RW_16                            0x00000010 /* RWIUV */
#define NV_PFB_CMDQ0_FA_ACT                                    11:8 /* RWIUF */
#define NV_PFB_CMDQ0_FA_ACT_1                            0x00000001 /* RW-UV */
#define NV_PFB_CMDQ0_FA_ACT_2                            0x00000002 /* RW-UV */
#define NV_PFB_CMDQ0_FA_ACT_3                            0x00000003 /* RW-UV */
#define NV_PFB_CMDQ0_FA_ACT_4                            0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0_FA_ACT_8                            0x00000008 /* RWIUV */
#define NV_PFB_CMDQ0_FA_PRE                                   15:12 /* RWIUF */
#define NV_PFB_CMDQ0_FA_PRE_1                            0x00000001 /* RW-UV */
#define NV_PFB_CMDQ0_FA_PRE_2                            0x00000002 /* RW-UV */
#define NV_PFB_CMDQ0_FA_PRE_3                            0x00000003 /* RW-UV */
#define NV_PFB_CMDQ0_FA_PRE_4                            0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0_FA_PRE_8                            0x00000008 /* RWIUV */
#define NV_PFB_CMDQ0_HP_RW                                    20:16 /* RWIUF */
#define NV_PFB_CMDQ0_HP_RW_4                             0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0_HP_RW_5                             0x00000005 /* RW-UV */
#define NV_PFB_CMDQ0_HP_RW_6                             0x00000006 /* RW-UV */
#define NV_PFB_CMDQ0_HP_RW_7                             0x00000007 /* RW-UV */
#define NV_PFB_CMDQ0_HP_RW_8                             0x00000008 /* RW-UV */
#define NV_PFB_CMDQ0_HP_RW_16                            0x00000010 /* RWIUV */
#define NV_PFB_CMDQ0_HP_ACT                                   27:24 /* RWIUF */
#define NV_PFB_CMDQ0_HP_ACT_1                            0x00000001 /* RW-UV */
#define NV_PFB_CMDQ0_HP_ACT_2                            0x00000002 /* RW-UV */
#define NV_PFB_CMDQ0_HP_ACT_3                            0x00000003 /* RW-UV */
#define NV_PFB_CMDQ0_HP_ACT_4                            0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0_HP_ACT_8                            0x00000008 /* RWIUV */
#define NV_PFB_CMDQ0_HP_PRE                                   31:28 /* RWIUF */
#define NV_PFB_CMDQ0_HP_PRE_1                            0x00000001 /* RW-UV */
#define NV_PFB_CMDQ0_HP_PRE_2                            0x00000002 /* RW-UV */
#define NV_PFB_CMDQ0_HP_PRE_3                            0x00000003 /* RW-UV */
#define NV_PFB_CMDQ0_HP_PRE_4                            0x00000004 /* RW-UV */
#define NV_PFB_CMDQ0_HP_PRE_8                            0x00000008 /* RWIUV */
#define NV_PFB_CMDQ1                                     0x00100354 /* RW-4R */
#define NV_PFB_CMDQ1_RT_RW                                      4:0 /* RWIUF */
#define NV_PFB_CMDQ1_RT_RW_3                             0x00000003 /* RW-UV */
#define NV_PFB_CMDQ1_RT_RW_4                             0x00000004 /* RW-UV */
#define NV_PFB_CMDQ1_RT_RW_5                             0x00000005 /* RW-UV */
#define NV_PFB_CMDQ1_RT_RW_6                             0x00000006 /* RW-UV */
#define NV_PFB_CMDQ1_RT_RW_7                             0x00000007 /* RW-UV */
#define NV_PFB_CMDQ1_RT_RW_8                             0x00000008 /* RW-UV */
#define NV_PFB_CMDQ1_RT_RW_10                            0x0000000A /* RWIUV */
#define NV_PFB_CMDQ1_RT_RW_16                            0x00000010 /* RW-UV */
#define NV_PFB_CMDQ1_RT_ACT                                    11:8 /* RWIUF */
#define NV_PFB_CMDQ1_RT_ACT_1                            0x00000001 /* RW-UV */
#define NV_PFB_CMDQ1_RT_ACT_2                            0x00000002 /* RW-UV */
#define NV_PFB_CMDQ1_RT_ACT_3                            0x00000003 /* RW-UV */
#define NV_PFB_CMDQ1_RT_ACT_4                            0x00000004 /* RW-UV */
#define NV_PFB_CMDQ1_RT_ACT_6                            0x00000006 /* RW-UV */
#define NV_PFB_CMDQ1_RT_ACT_8                            0x00000008 /* RWIUV */
#define NV_PFB_CMDQ1_RT_PRE                                   15:12 /* RWIUF */
#define NV_PFB_CMDQ1_RT_PRE_1                            0x00000001 /* RW-UV */
#define NV_PFB_CMDQ1_RT_PRE_2                            0x00000002 /* RW-UV */
#define NV_PFB_CMDQ1_RT_PRE_3                            0x00000003 /* RW-UV */
#define NV_PFB_CMDQ1_RT_PRE_4                            0x00000004 /* RW-UV */
#define NV_PFB_CMDQ1_RT_PRE_6                            0x00000006 /* RW-UV */
#define NV_PFB_CMDQ1_RT_PRE_8                            0x00000008 /* RWIUV */
#define NV_PFB_ILL_INSTR(i)                      (0x00100360+(i)*4) /* R--4A */
#define NV_PFB_ILL_INSTR__SIZE_1                                  4 /*       */
#define NV_PFB_ILL_INSTR_REQID                                  4:0 /* R--VF */
#define NV_PFB_ILL_INSTR_CMD                                   26:5 /* R--VF */
#define NV_PFB_ILL_INSTR_CODE                                 30:27 /* R--VF */
#define NV_PFB_ILL_INSTR_TRAPPED                              31:31 /* R--VF */
#define NV_PFB_RT                                        0x00100400 /* RW-4R */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP                             2:0 /* RWIUF */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_0                    0x00000000 /* RW-UV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_1                    0x00000001 /* RW-UV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_2                    0x00000002 /* RW-UV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_3                    0x00000003 /* RWIUV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_4                    0x00000004 /* RW-UV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_5                    0x00000005 /* RW-UV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_6                    0x00000006 /* RW-UV */
#define NV_PFB_RT_CPU_GNT_BLOCKS_LP_7                    0x00000007 /* RW-UV */
#define NV_PFB_AUTOCLOSE                                 0x00100404 /* RW-4R */
#define NV_PFB_AUTOCLOSE_ACTIVE                                 0:0 /* RWIVF */
#define NV_PFB_AUTOCLOSE_ACTIVE_FALSE                    0x00000000 /* RW--V */
#define NV_PFB_AUTOCLOSE_ACTIVE_TRUE                     0x00000001 /* RWI-V */
#define NV_PFB_AUTOCLOSE_RT                                     4:4 /* RWIVF */
#define NV_PFB_AUTOCLOSE_RT_DISABLED                     0x00000000 /* RW--V */
#define NV_PFB_AUTOCLOSE_RT_ENABLED                      0x00000001 /* RWI-V */
#define NV_PFB_AUTOCLOSE_HP                                     5:5 /* RWIVF */
#define NV_PFB_AUTOCLOSE_HP_DISABLED                     0x00000000 /* RWI-V */
#define NV_PFB_AUTOCLOSE_HP_ENABLED                      0x00000001 /* RW--V */
#define NV_PFB_AUTOCLOSE_FA                                     6:6 /* RWIVF */
#define NV_PFB_AUTOCLOSE_FA_DISABLED                     0x00000000 /* RWI-V */
#define NV_PFB_AUTOCLOSE_FA_ENABLED                      0x00000001 /* RW--V */
#define NV_PFB_AUTOCLOSE_TIMEOUT                               12:8 /* RWIUF */
#define NV_PFB_AUTOCLOSE_TIMEOUT_MIN                     0x00000000 /* RW-UV */
#define NV_PFB_AUTOCLOSE_TIMEOUT_15                      0x0000000F /* RWIUV */
#define NV_PFB_AUTOCLOSE_TIMEOUT_MAX                     0x0000001F /* RW-UV */
#define NV_PFB_AUTOCLOSE_DRAMC_DEBUG                          31:16 /* RWIVF */
#define NV_PFB_AUTOCLOSE_DRAMC_DEBUG_INIT                0x00000000 /* RWI-V */
#define NV_PFB_WBC                                       0x00100410 /* RW-4R */
#define NV_PFB_WBC_HWM                                          4:0 /* RWIUF */
#define NV_PFB_WBC_HWM_0                                 0x00000000 /* RW-UV */
#define NV_PFB_WBC_HWM_1                                 0x00000001 /* RW-UV */
#define NV_PFB_WBC_HWM_2                                 0x00000002 /* RW-UV */
#define NV_PFB_WBC_HWM_3                                 0x00000003 /* RW-UV */
#define NV_PFB_WBC_HWM_4                                 0x00000004 /* RW-UV */
#define NV_PFB_WBC_HWM_5                                 0x00000005 /* RW-UV */
#define NV_PFB_WBC_HWM_6                                 0x00000006 /* RW-UV */
#define NV_PFB_WBC_HWM_7                                 0x00000007 /* RW-UV */
#define NV_PFB_WBC_HWM_8                                 0x00000008 /* RW-UV */
#define NV_PFB_WBC_HWM_9                                 0x00000009 /* RW-UV */
#define NV_PFB_WBC_HWM_10                                0x0000000A /* RW-UV */
#define NV_PFB_WBC_HWM_11                                0x0000000B /* RW-UV */
#define NV_PFB_WBC_HWM_12                                0x0000000C /* RW-UV */
#define NV_PFB_WBC_HWM_13                                0x0000000D /* RW-UV */
#define NV_PFB_WBC_HWM_14                                0x0000000E /* RW-UV */
#define NV_PFB_WBC_HWM_15                                0x0000000F /* RW-UV */
#define NV_PFB_WBC_HWM_16                                0x00000010 /* RW-UV */
#define NV_PFB_WBC_HWM_17                                0x00000011 /* RW-UV */
#define NV_PFB_WBC_HWM_18                                0x00000012 /* RW-UV */
#define NV_PFB_WBC_HWM_19                                0x00000013 /* RW-UV */
#define NV_PFB_WBC_HWM_20                                0x00000014 /* RW-UV */
#define NV_PFB_WBC_HWM_21                                0x00000015 /* RW-UV */
#define NV_PFB_WBC_HWM_22                                0x00000016 /* RW-UV */
#define NV_PFB_WBC_HWM_23                                0x00000017 /* RW-UV */
#define NV_PFB_WBC_HWM_24                                0x00000018 /* RWIUV */
#define NV_PFB_WBC_HWM_25                                0x00000019 /* RW-UV */
#define NV_PFB_WBC_HWM_26                                0x0000001A /* RW-UV */
#define NV_PFB_WBC_HWM_27                                0x0000001B /* RW-UV */
#define NV_PFB_WBC_HWM_28                                0x0000001C /* RW-UV */
#define NV_PFB_WBC_HWM_29                                0x0000001D /* RW-UV */
#define NV_PFB_WBC_HWM_30                                0x0000001E /* RW-UV */
#define NV_PFB_WBC_HWM_31                                0x0000001F /* RW-UV */
#define NV_PFB_WBC_LWM                                         12:8 /* RWIUF */
#define NV_PFB_WBC_LWM_0                                 0x00000000 /* RW-UV */
#define NV_PFB_WBC_LWM_1                                 0x00000001 /* RW-UV */
#define NV_PFB_WBC_LWM_2                                 0x00000002 /* RW-UV */
#define NV_PFB_WBC_LWM_3                                 0x00000003 /* RW-UV */
#define NV_PFB_WBC_LWM_4                                 0x00000004 /* RW-UV */
#define NV_PFB_WBC_LWM_5                                 0x00000005 /* RW-UV */
#define NV_PFB_WBC_LWM_6                                 0x00000006 /* RW-UV */
#define NV_PFB_WBC_LWM_7                                 0x00000007 /* RW-UV */
#define NV_PFB_WBC_LWM_8                                 0x00000008 /* RW-UV */
#define NV_PFB_WBC_LWM_9                                 0x00000009 /* RW-UV */
#define NV_PFB_WBC_LWM_10                                0x0000000A /* RW-UV */
#define NV_PFB_WBC_LWM_11                                0x0000000B /* RW-UV */
#define NV_PFB_WBC_LWM_12                                0x0000000C /* RW-UV */
#define NV_PFB_WBC_LWM_13                                0x0000000D /* RW-UV */
#define NV_PFB_WBC_LWM_14                                0x0000000E /* RW-UV */
#define NV_PFB_WBC_LWM_15                                0x0000000F /* RW-UV */
#define NV_PFB_WBC_LWM_16                                0x00000010 /* RWIUV */
#define NV_PFB_WBC_LWM_17                                0x00000011 /* RW-UV */
#define NV_PFB_WBC_LWM_18                                0x00000012 /* RW-UV */
#define NV_PFB_WBC_LWM_19                                0x00000013 /* RW-UV */
#define NV_PFB_WBC_LWM_20                                0x00000014 /* RW-UV */
#define NV_PFB_WBC_LWM_21                                0x00000015 /* RW-UV */
#define NV_PFB_WBC_LWM_22                                0x00000016 /* RW-UV */
#define NV_PFB_WBC_LWM_23                                0x00000017 /* RW-UV */
#define NV_PFB_WBC_LWM_24                                0x00000018 /* RW-UV */
#define NV_PFB_WBC_LWM_25                                0x00000019 /* RW-UV */
#define NV_PFB_WBC_LWM_26                                0x0000001A /* RW-UV */
#define NV_PFB_WBC_LWM_27                                0x0000001B /* RW-UV */
#define NV_PFB_WBC_LWM_28                                0x0000001C /* RW-UV */
#define NV_PFB_WBC_LWM_29                                0x0000001D /* RW-UV */
#define NV_PFB_WBC_LWM_30                                0x0000001E /* RW-UV */
#define NV_PFB_WBC_LWM_31                                0x0000001F /* RW-UV */
#define NV_PFB_WBC_FLUSH                                      16:16 /* RWIVF */
#define NV_PFB_WBC_FLUSH_NOT_PENDING                     0x00000000 /* RWI-V */
#define NV_PFB_WBC_FLUSH_PENDING                         0x00000001 /* -W--T */
#define NV_PFB_WBC_FULL_BLOCKS_ISOLDT_READ                    20:20 /* RWIVF */
#define NV_PFB_WBC_FULL_BLOCKS_ISOLDT_READ_FALSE         0x00000000 /* RWI-V */
#define NV_PFB_WBC_FULL_BLOCKS_ISOLDT_READ_TRUE          0x00000001 /* RW--V */
#define NV_PFB_WBC_FULL_BLOCKS_NONISOLDT_READ                 21:21 /* RWIVF */
#define NV_PFB_WBC_FULL_BLOCKS_NONISOLDT_READ_FALSE      0x00000000 /* RWI-V */
#define NV_PFB_WBC_FULL_BLOCKS_NONISOLDT_READ_TRUE       0x00000001 /* RW--V */
#define NV_PFB_WBC_ATOMIC_CPU_READS                           24:24 /* RWIVF */
#define NV_PFB_WBC_ATOMIC_CPU_READS_DISABLED             0x00000000 /* RW--V */
#define NV_PFB_WBC_ATOMIC_CPU_READS_ENABLED              0x00000001 /* RWI-V */
#define NV_PFB_WBC_ATOMIC_AGP_READS                           25:25 /* RWIVF */
#define NV_PFB_WBC_ATOMIC_AGP_READS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFB_WBC_ATOMIC_AGP_READS_ENABLED              0x00000001 /* RW--V */
#define NV_PFB_WBC_ATOMIC_LDT_READS                           26:26 /* RWIVF */
#define NV_PFB_WBC_ATOMIC_LDT_READS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFB_WBC_ATOMIC_LDT_READS_ENABLED              0x00000001 /* RW--V */
#define NV_PFB_WBC_32B_WRITE_BLOCKS_READS                     28:28 /* RWIVF */
#define NV_PFB_WBC_32B_WRITE_BLOCKS_READS_DISABLED       0x00000000 /* RW--V */
#define NV_PFB_WBC_32B_WRITE_BLOCKS_READS_ENABLED        0x00000001 /* RWI-V */
#define NV_PFB_CMDQ_PRT                                  0x00100418 /* RW-4R */
#define NV_PFB_CMDQ_PRT_DISABLE                                 0:0 /* RWIVF */
#define NV_PFB_CMDQ_PRT_DISABLE_OFF                      0x00000000 /* RWI-V */
#define NV_PFB_CMDQ_PRT_DISABLE_ON                       0x00000001 /* RW--V */
#define NV_PFB_CMDQ_PRT_HP_MIN                                  5:2 /* RWIUF */
#define NV_PFB_CMDQ_PRT_HP_MIN_0                         0x00000000 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_1                         0x00000001 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_2                         0x00000002 /* RWIUV */
#define NV_PFB_CMDQ_PRT_HP_MIN_3                         0x00000003 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_4                         0x00000004 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_5                         0x00000005 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_6                         0x00000006 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_7                         0x00000007 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_8                         0x00000008 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_9                         0x00000009 /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_10                        0x0000000a /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_11                        0x0000000b /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_12                        0x0000000c /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_13                        0x0000000d /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_14                        0x0000000e /* RW-UV */
#define NV_PFB_CMDQ_PRT_HP_MIN_15                        0x0000000f /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN                                14:11 /* RWIUF */
#define NV_PFB_CMDQ_PRT_RT_MIN_0                         0x00000000 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_1                         0x00000001 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_2                         0x00000002 /* RWIUV */
#define NV_PFB_CMDQ_PRT_RT_MIN_3                         0x00000003 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_4                         0x00000004 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_5                         0x00000005 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_6                         0x00000006 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_7                         0x00000007 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_8                         0x00000008 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_9                         0x00000009 /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_10                        0x0000000a /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_11                        0x0000000b /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_12                        0x0000000c /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_13                        0x0000000d /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_14                        0x0000000e /* RW-UV */
#define NV_PFB_CMDQ_PRT_RT_MIN_15                        0x0000000f /* RW-UV */
#define NV_PFB_CPU_RRQ                                   0x00100420 /* RW-4R */
#define NV_PFB_CPU_RRQ_BYPASS                                   0:0 /* RWIVF */
#define NV_PFB_CPU_RRQ_BYPASS_DISABLED                   0x00000000 /* R-I-V */
#define NV_PFB_CPU_RRQ_BYPASS_ENABLED                    0x00000001 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY                                  7:4 /* RWIUF */
#define NV_PFB_CPU_RRQ_LATENCY_MIN                       0x00000000 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_0                         0x00000000 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_1                         0x00000001 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_2                         0x00000002 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_3                         0x00000003 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_4                         0x00000004 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_5                         0x00000005 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_6                         0x00000006 /* R---V */
#define NV_PFB_CPU_RRQ_LATENCY_MAX                       0x00000006 /* R-I-V */
#define NV_PFB_CPU_RRQ_FWP                                     11:8 /* RWIUF */
#define NV_PFB_CPU_RRQ_FWP_MIN                           0x00000003 /* R---V */
#define NV_PFB_CPU_RRQ_FWP_3                             0x00000003 /* R---V */
#define NV_PFB_CPU_RRQ_FWP_4                             0x00000004 /* R---V */
#define NV_PFB_CPU_RRQ_FWP_MAX                           0x00000004 /* R-I-V */
#define NV_PFB_BYPASS                                    0x00100424 /* RW-4R */
#define NV_PFB_BYPASS_FAST_READ                                 0:0 /* RWIVF */
#define NV_PFB_BYPASS_FAST_READ_DISABLED                 0x00000000 /* RWI-V */
#define NV_PFB_BYPASS_FAST_READ_ENABLED                  0x00000001 /* RW--V */
#define NV_PFB_BYPASS_SINGLE_CYCLE                              4:4 /* RWIVF */
#define NV_PFB_BYPASS_SINGLE_CYCLE_DISABLED              0x00000000 /* RWI-V */
#define NV_PFB_BYPASS_SINGLE_CYCLE_ENABLED               0x00000001 /* RW--V */
#define NV_PFB_BYPASS_BLOCK_WBC_AUTOPRE                         5:5 /* RWIVF */
#define NV_PFB_BYPASS_BLOCK_WBC_AUTOPRE_DISABLED         0x00000000 /* RW--V */
#define NV_PFB_BYPASS_BLOCK_WBC_AUTOPRE_ENABLED          0x00000001 /* RWI-V */
#define NV_PFB_BYPASS_ALLOW_CPUREAD_DURING_BYPASS               8:8 /* RWIVF */
#define NV_PFB_BYPASS_ALLOW_CPUREAD_DURING_BYPASS_FALSE  0x00000000 /* RWI-V */
#define NV_PFB_BYPASS_ALLOW_CPUREAD_DURING_BYPASS_TRUE   0x00000001 /* RW--V */
#define NV_PFB_BYPASS_DEBUG                                    15:9 /* RWIVF */
#define NV_PFB_BYPASS_DEBUG_INIT                         0x00000000 /* RWI-V */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY                         19:16 /* RWIUF */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_0                  0x00000000 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_1                  0x00000001 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_2                  0x00000002 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_3                  0x00000003 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_4                  0x00000004 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_5                  0x00000005 /* RWIUV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_6                  0x00000006 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_7                  0x00000007 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_8                  0x00000008 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_9                  0x00000009 /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_10                 0x0000000a /* RW-UV */
#define NV_PFB_BYPASS_MAX_CPU_LATENCY_11                 0x0000000b /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY                         22:20 /* RWIUF */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_0                  0x00000000 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_1                  0x00000001 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_2                  0x00000002 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_3                  0x00000003 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_4                  0x00000004 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_5                  0x00000005 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_6                  0x00000006 /* RW-UV */
#define NV_PFB_BYPASS_MAX_MEM_LATENCY_7                  0x00000007 /* RWIUV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED                         26:24 /* RWIUF */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_0                  0x00000000 /* RW-UV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_1                  0x00000001 /* RW-UV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_2                  0x00000002 /* RWIUV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_3                  0x00000003 /* RW-UV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_4                  0x00000004 /* RW-UV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_5                  0x00000005 /* RW-UV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_6                  0x00000006 /* RW-UV */
#define NV_PFB_BYPASS_RR_SLOTS_NEEDED_7                  0x00000007 /* RW-UV */
#define NV_PFB_BYPASS_ROW_EARLY_NONSPEC                       28:28 /* RWIVF */
#define NV_PFB_BYPASS_ROW_EARLY_NONSPEC_DISABLED         0x00000000 /* RWI-V */
#define NV_PFB_BYPASS_ROW_EARLY_NONSPEC_ENABLED          0x00000001 /* RW--V */
#define NV_PFB_BYPASS_ROW_EARLY_SPEC                          29:29 /* RWIVF */
#define NV_PFB_BYPASS_ROW_EARLY_SPEC_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_BYPASS_ROW_EARLY_SPEC_ENABLED             0x00000001 /* RW--V */
#define NV_PFB_BYPASS_RETIRE_DELAY                            31:30 /* RWIUF */
#define NV_PFB_BYPASS_RETIRE_DELAY_MIN                   0x00000000 /* RWIUV */
#define NV_PFB_BYPASS_RETIRE_DELAY_0                     0x00000000 /* RW-UV */
#define NV_PFB_BYPASS_RETIRE_DELAY_1                     0x00000001 /* RW-UV */
#define NV_PFB_BYPASS_RETIRE_DELAY_2                     0x00000002 /* RW-UV */
#define NV_PFB_BYPASS_RETIRE_DELAY_3                     0x00000003 /* RW-UV */
#define NV_PFB_BYPASS_RETIRE_DELAY_MAX                   0x00000003 /* RW-UV */
/* dev_fb.ref */
#define NV_PFBM                               0x3FFFFFFF:0x08000000 /* RW--M */
/* dev_fb.ref */
#define NV_PFBIN                              0x007FFFFF:0x00700000 /* RW--M */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD                          0:0 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_NORMAL            0x00000001 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_REVERSED          0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG                          5:2 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG_0                 0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X                          9:9 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_ENABLED           0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_DISABLED          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA                       10:10 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_DISABLED         0x00000001 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_ENABLED          0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR                    11:11 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_ENABLED       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_DISABLED      0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID                     13:12 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_0              0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_1              0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_2              0x00000002 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_3              0x00000003 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                      14:14 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE                      15:15 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT           0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_12BIT           0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB                            17:16 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_64M                   0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_128M                  0x00000001 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_256M                  0x00000002 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_512M                  0x00000003 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_EMRS                          19:18 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_EMRS_MICRON              0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_EMRS_REDUCED_DRIVE       0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_EMRS_RESERVED            0x00000002 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_EMRS_MATCHED             0x00000003 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_CPU                           23:20 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_LDT_BIAS_EN                   24:24 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_USER                          28:25 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE                     31:31 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_DISABLED       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_ENABLED        0x00000001 /* RW--V */
#define NV_PEXTDEV_NEW_BOOT_0                            0x00101000 /* RW-4R */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE                      30:0 /* RWIVF */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE                 31:31 /* RWIVF */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_DISABLED   0x00000000 /* RWI-V */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_ENABLED    0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB                            17:16 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_64M                   0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_128M                  0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_256M                  0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_FB_512M                  0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR                            18:18 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_DISABLED              0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_ENABLED               0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_REG_128M                   19:19 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_REG_128M_ENABLED      0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_REG_128M_DISABLED     0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_AGP_DEV                    20:20 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_AGP_DEV_DISABLED      0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_AGP_DEV_ENABLED       0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_IO_DEV                     21:21 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_IO_DEV_DISABLED       0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BR_IO_DEV_ENABLED        0x00000001 /* R---V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00680000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0030FFFF:0x00300000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00300000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_fifo.ref */
#define NV_USER                               0x00BFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                   32 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                  32 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                  32 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                  32 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                  32 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_DMA_PUT(i,j)    (0x00800040+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_DMA_PUT__SIZE_1                                  32 /*       */
#define NV_USER_DMA_PUT__SIZE_2                                   8 /*       */
#define NV_USER_DMA_PUT_OFFSET                                 31:2 /* -WXUF */
#define NV_USER_DMA_GET(i,j)    (0x00800044+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_DMA_GET__SIZE_1                                  32 /*       */
#define NV_USER_DMA_GET__SIZE_2                                   8 /*       */
#define NV_USER_DMA_GET_OFFSET                                 31:2 /* R-XUF */
#define NV_USER_REF(i,j)        (0x00800048+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_REF__SIZE_1                                      32 /*       */
#define NV_USER_REF__SIZE_2                                       8 /*       */
#define NV_USER_REF_CNT                                        31:0 /* R-XUF */
/* dev_fifo.ref */
#define NV_UDMA_OBJECT(j)                   (0x00000000+(j)*0x2000) /* -W-4A */
#define NV_UDMA_OBJECT__SIZE_1                                   32 /*       */
#define NV_UDMA_OBJECT__SIZE_2                                    8 /*       */
#define NV_UDMA_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_UDMA_SET_REF(j)                  (0x00000050+(j)*0x2000) /* R--4A */
#define NV_UDMA_SET_REF__SIZE_1                                  32 /*       */
#define NV_UDMA_SET_REF__SIZE_2                                   8 /*       */
#define NV_UDMA_SET_REF_CNT                                    31:0 /* R-XUF */
#define NV_UDMA_SEM_CTXDMA(j)               (0x00000060+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_CTXDMA__SIZE_1                               32 /*       */
#define NV_UDMA_SEM_CTXDMA__SIZE_2                                8 /*       */
#define NV_UDMA_SEM_CTXDMA_HANDLE                              31:0 /* -W-VF */
#define NV_UDMA_SEM_OFFSET(j)               (0x00000064+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_OFFSET__SIZE_1                               32 /*       */
#define NV_UDMA_SEM_OFFSET__SIZE_2                                8 /*       */
#define NV_UDMA_SEM_OFFSET_ADDRESS                             11:2 /* -W-VF */
#define NV_UDMA_SEM_ACQUIRE(j)              (0x00000068+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_ACQUIRE__SIZE_1                              32 /*       */
#define NV_UDMA_SEM_ACQUIRE__SIZE_2                               8 /*       */
#define NV_UDMA_SEM_ACQUIRE_VALUE                              31:0 /* -W-VF */
#define NV_UDMA_SEM_RELEASE(j)              (0x0000006C+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_RELEASE__SIZE_1                              32 /*       */
#define NV_UDMA_SEM_RELEASE__SIZE_2                               8 /*       */
#define NV_UDMA_SEM_RELEASE_VALUE                              31:0 /* -W-VF */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+17):( 1*32+16) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+28):( 1*32+24) /* RWXUF */
#define NV_RAMHT_STATUS                       ( 1*32+31):( 1*32+31) /* RWXUF */
#define NV_RAMHT_STATUS_INVALID                          0x00000000 /* RW--V */
#define NV_RAMHT_STATUS_VALID                            0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+12):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_SUBCHANNEL                   ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXUF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000003FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x000007FF:0x00000000 /* RW--M */
#define NV_RAMFC_DMA_PUT                      ( 0*32+31):( 0*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_GET                      ( 1*32+31):( 1*32+ 2) /* RWXUF */
#define NV_RAMFC_REF_CNT                      ( 2*32+31):( 2*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_INST                     ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_COUNT                    ( 3*32+28):( 3*32+18) /* RWXUF */
#define NV_RAMFC_DMA_METHOD                   ( 4*32+12):( 4*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_SUBCHANNEL               ( 4*32+15):( 4*32+13) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_COUNT             ( 4*32+28):( 4*32+18) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_TYPE              ( 4*32+ 0):( 4*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_TRIG               ( 5*32+ 7):( 5*32+ 3) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_SIZE               ( 5*32+15):( 5*32+13) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_MAX_REQS           ( 5*32+20):( 5*32+16) /* RWXUF */
#define NV_RAMFC_BIG_ENDIAN                   ( 5*32+31):( 5*32+31) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_0                 ( 6*32+ 1):( 6*32+ 0) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_1                 ( 6*32+ 5):( 6*32+ 4) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_2                 ( 6*32+ 9):( 6*32+ 8) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_3                 ( 6*32+13):( 6*32+12) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_4                 ( 6*32+17):( 6*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_5                 ( 6*32+21):( 6*32+20) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_6                 ( 6*32+25):( 6*32+24) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_7                 ( 6*32+29):( 6*32+28) /* RWXUF */
#define NV_RAMFC_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMFC_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE                 ( 7*32+ 1):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_PULL1_ENGINE_SW                         0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_GRAPHICS                   0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_DVD                        0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ACQ_STATE              ( 7*32+ 4):( 7*32+ 4) /* RWXVF */
#define NV_RAMFC_PULL1_ACQ_STATE_INACTIVE                0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ACQ_STATE_ACTIVE                  0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE        ( 7*32+17):( 7*32+16) /* RWXUF */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_NVM               0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_PCI               0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_AGP               0x00000003 /* RW--V */
#define NV_RAMFC_ACQUIRE_VALUE                ( 8*32+31):( 8*32+ 0) /* RWXUF */
#define NV_RAMFC_ACQUIRE_TIMESTAMP            ( 9*32+31):( 9*32+ 0) /* RWXUF */
#define NV_RAMFC_ACQUIRE_TIMEOUT              (10*32+30):(10*32+ 0) /* RWXUF */
#define NV_RAMFC_SEMAPHORE_CTXDMA             (11*32+ 0):(11*32+ 0) /* RWXVF */
#define NV_RAMFC_SEMAPHORE_CTXDMA_INVALID                0x00000000 /* RW--V */
#define NV_RAMFC_SEMAPHORE_CTXDMA_VALID                  0x00000001 /* RW--V */
#define NV_RAMFC_SEMAPHORE_OFFSET             (11*32+11):(11*32+ 2) /* RWXUF */
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS       (11*32+31):(11*32+12) /* RWXUF */
#define NV_RAMFC_DMA_SUBROUTINE_STATE         (12*32+ 0):(12*32+ 0) /* RWXVF */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_INACTIVE           0x00000000 /* RW--V */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_ACTIVE             0x00000001 /* RW--V */
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET (12*32+31):(12*32+ 2) /* RWXUF */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_RAMDVD_CTX_TABLE                   (63*32+31):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT(c,s) (((c)*4+((s)/2))*32+((s)%2)*16+15):(((c)*4+((s)/2))*32+((s)%2)*16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0        ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1        ( 0*32+31):( 0*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2        ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3        ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4        ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5        ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6        ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7        ( 3*32+31):( 3*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0       (60*32+15):(60*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1       (60*32+31):(60*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2       (61*32+15):(61*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3       (61*32+31):(61*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4       (62*32+15):(62*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5       (62*32+31):(62*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6       (63*32+15):(63*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7       (63*32+31):(63*32+16) /* RWXUF */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_CLASS                          ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_PAGE_ENTRY                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_DMA_PAGE_ENTRY_NOT_LINEAR                     0x00000000 /* RW--V */
#define NV_DMA_PAGE_ENTRY_LINEAR                         0x00000001 /* RW--V */
#define NV_DMA_FLAGS_ACCESS                   ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_DMA_FLAGS_ACCESS_READ_WRITE                   0x00000000 /* RW--V */
#define NV_DMA_FLAGS_ACCESS_OTHER                        0x00000001 /* RW--V */
#define NV_DMA_FLAGS_MAPPING_COHERENCY        ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_DMA_FLAGS_MAPPING_COHERENCY_UNCACHED          0x00000000 /* RW--V */
#define NV_DMA_FLAGS_MAPPING_COHERENCY_CACHED            0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+17):( 0*32+16) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_NVM_TILED                     0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_MEMORY_CLASS                   ( 0*32+19):( 0*32+18) /* RWXVF */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_LOCAL_LINEAR     0x00000000 /* RW--V */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_LOCAL_BANKED     0x00000001 /* RW--V */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_SYSTEM           0x00000002 /* RW--V */
#define NV_DMA_MEMORY_CLASS_OTHER                        0x00000003 /* RW--V */
#define NV_DMA_ADJUST                         ( 0*32+31):( 0*32+20) /* RWXUF */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\av\avp.h ===
/*--
Copyright (c) Microsoft Corporation

Module Name:

    avp.h

Abstract:

    This module contains the private data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AVP_H
#define _AVP_H

#include "ntos.h"
#include <av.h>
#include <smcdef.h>
#include <xtl.h>
#include "xboxp.h"
#include "xconfig.h"

#include "nv_ref_2a.h"
#include "nv_ref_plus.h"

#define DEFINE_REGISTERS

#include <avmode.h>

//
// I2C constants
//

#define I2C_PORT_PRIMARY            0
#define I2C_PORT_SECONDARY          1

#define I2C_SRCK                    0x20    // Serial Clock write
#define I2C_SRD                     0x10    // Serial Data  write
#define I2C_SRCK_IN                 0x04    // Serial Clock read
#define I2C_SRD_IN                  0x08    // Serial Data  read
#define I2C_ENABLE                  0x01    // Enable Serial Port Function

VOID
AvpReadDeviceReg(
    PVOID RegisterBase,
    UCHAR SMBaddr,
    UCHAR Reg,
    UCHAR* ReadData
    );

UCHAR
AvpWriteDeviceReg(
    PVOID RegisterBase,
    UCHAR SMBaddr,
    UCHAR Reg,
    UCHAR WriteValue
    );

VOID
AvpDelay(
    PVOID RegisterBase,
    ULONG nanosec
    );

#if DBG

extern ULONG AvpDump;

#endif 

//
// Macros/functions to access hardware registers
//

FORCEINLINE ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
    return *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr)));
}

FORCEINLINE VOID
REG_WR32(VOID* Ptr, ULONG Addr, ULONG Val)
{
    *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr))) = (ULONG)(Val);

#if DBG
    if (AvpDump)
    {
        DbgPrint("%08X = %08X\n", Addr, Val);
    }
#endif
}

FORCEINLINE VOID
REG_OR32(VOID* Ptr, ULONG Addr, ULONG Val)
{
    ULONG Value;
    
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    Value = REG_RD32(Ptr, Addr);
    REG_WR32(Ptr, Addr, Value | Val);

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("%08X = %08X (read modify write)\n", Addr, Val);
    }
#endif
}

FORCEINLINE UCHAR
REG_RD08(VOID* Ptr, ULONG Addr)
{
    return *((volatile UCHAR*)((UCHAR*)(Ptr) + (Addr)));
}

FORCEINLINE VOID
REG_WR08(VOID* Ptr, ULONG Addr, UCHAR Val)
{
    *((volatile UCHAR*)((UCHAR*)(Ptr) + (Addr))) = (UCHAR)(Val);

#if DBG
    if (AvpDump)
    {
        DbgPrint("%08X = %08X\n", Addr, Val);
    }
#endif
}

#define REG_RD_DRF(Ptr,d,r,f)       (((REG_RD32(Ptr,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define REG_WR_DRF_NUM(Ptr,d,r,f,n) REG_WR32(Ptr, NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(Ptr,d,r,f,c) REG_WR32(Ptr, NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(Ptr,d,r,f,n) REG_WR32(Ptr, NV##d##r,(REG_RD32(Ptr, NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(Ptr,d,r,f,c) REG_WR32(Ptr, NV##d##r,(REG_RD32(Ptr, NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))

FORCEINLINE VOID
CRTC_WR(VOID* Ptr, UCHAR i, UCHAR d)
{
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    REG_WR08(Ptr, NV_PRMCIO_CRX__COLOR, i);
    REG_WR08(Ptr, NV_PRMCIO_CR__COLOR, d);

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("CR%02X = %02X\n", i, d);
    }
#endif
}

FORCEINLINE UCHAR
CRTC_RD(VOID* Ptr, UCHAR i)            
{
    UCHAR Value;

#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    REG_WR08(Ptr, NV_PRMCIO_CRX__COLOR, i);
    Value = REG_RD08(Ptr, NV_PRMCIO_CR__COLOR);

#if DBG
    AvpDump = Store;
#endif

    return Value;
}

FORCEINLINE UCHAR
SMB_RD(VOID * Ptr, UCHAR Reg)
{
    ULONG Value;

#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    HalReadSMBusByte(TV_ENCODER_ID, Reg, &Value);

#if DBG
    AvpDump = Store;
#endif

    return (UCHAR)Value;
}

FORCEINLINE VOID
SMB_WR(VOID *Ptr, UCHAR Reg, UCHAR Val)
{
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    HalWriteSMBusByte(TV_ENCODER_ID, Reg, Val);

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("TV%02X = %02X\n", Reg, Val);
    }
#endif
}

FORCEINLINE USHORT
SMB_RDW(VOID * Ptr, UCHAR Reg)
{
    ULONG Value;

#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    HalReadSMBusWord(TV_ENCODER_ID, Reg, &Value);

#if DBG
    AvpDump = Store;
#endif

    return (USHORT)Value;
}

FORCEINLINE VOID
SMB_WRW(VOID *Ptr, UCHAR Reg, USHORT Val)
{
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    HalWriteSMBusWord(TV_ENCODER_ID, Reg, Val);

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("TV%04X = %04X\n", Reg, Val);
    }
#endif
}


FORCEINLINE VOID
SRX_WR(VOID *Ptr, UCHAR i, UCHAR d)            
{
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    REG_WR08(Ptr, NV_PRMVIO_SRX, i);
    REG_WR08(Ptr, NV_PRMVIO_SR_RESET, (d));

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("SR%02X = %02X\n", i, d);
    }
#endif
}

FORCEINLINE VOID
GRX_WR(VOID *Ptr, UCHAR i, UCHAR d)            
{
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    REG_WR08(Ptr, NV_PRMVIO_GRX, i);
    REG_WR08(Ptr, NV_PRMVIO_GX_SR, (d));

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("GR%02X = %02X\n", i, d);
    }
#endif
}

FORCEINLINE VOID
ARX_WR(VOID *Ptr, UCHAR i, UCHAR d)            
{
#if DBG
    ULONG Store = AvpDump;
    AvpDump = FALSE;
#endif

    REG_WR08(Ptr, NV_PRMCIO_ARX, i);
    REG_WR08(Ptr, NV_PRMCIO_ARX, (d));

#if DBG
    AvpDump = Store;
    if (AvpDump)
    {
        DbgPrint("AR%02X = %02X\n", i, d);
    }
#endif
}

#if DBG
#define AvDbgPrint(x)               DbgPrint x
#else
#define AvDbgPrint(x)
#endif

#endif // _AVP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\bldr32.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bldr32.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the boot loader.

--*/

#ifndef _BOOT32_
#define _BOOT32_

#include <ntos.h>

//
// To enable spew, define BLDRSPEW below
//

#undef BLDRSPEW

//
// To enable a memory test before and after calibration, define BLDRMEMTEST below
// This should only be used for debug purposes
//

#undef BLDRMEMTEST

//
// PCI space access
//

#define PCI_TYPE1_ADDR_PORT         ((PULONG) 0xCF8)
#define PCI_TYPE1_DATA_PORT         0xCFC

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)


typedef unsigned long DWORD;

VOID
BldrEncDec(
    IN  PUCHAR  MsgData,
    IN  ULONG   MsgDataLen,
    IN  const UCHAR * Key,
    IN  ULONG   KeyBytes
    );

VOID
BldrCopyROMToRAM(
    IN const UCHAR * DecryptionKey
    );

VOID
BldrShutdownSystem(
    VOID
    );

VOID
__fastcall
BldrLoadMediaROM(
    ULONG_PTR MediaROMBaseAddress
    );

VOID 
BldrInitTimer(
    PVOID RegisterBase
    );

VOID
BldrSetDrvSlwFromROMData(
    PVOID RegisterBase
    );

VOID
BldrSetupLDTBus(
    VOID
    );

//
// Smbus access routines
//
    
NTSTATUS
BldrReadSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue,
    OUT ULONG *DataValue
    );

#define BldrReadSMBusByte(SlaveAddress, CommandCode, DataValue) \
    BldrReadSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define BldrReadSMBusWord(SlaveAddress, CommandCode, DataValue) \
    BldrReadSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

NTSTATUS
BldrWriteSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    );

#define BldrWriteSMBusByte(SlaveAddress, CommandCode, DataValue) \
    BldrWriteSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define BldrWriteSMBusWord(SlaveAddress, CommandCode, DataValue) \
    BldrWriteSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

#define SMC_SLAVE_ADDRESS                           0x20

VOID
DbgPrintHex(
    PUCHAR Buffer,
    ULONG  BufferSize
    );


#ifdef BLDRSPEW
#define BldrPrint(x)                DbgPrint x
#else
#define BldrPrint(x)
#endif

//
// Following structure exists at BLDR_CODE location.  BLDRBLD reserves spaces
// for it and fills in the Bldr32EntryPoint.  The rest of the fields are filled by
// DOSBOOT when booting from DOS.  When booting from ROM, these fields contain 0
//
typedef struct _BOOTLDRPARAM {
    ULONG Bldr32EntryPoint;
    CHAR  CommandLine[64];
} BOOTLDRPARAM, *PBOOTLDRPARAM;

#endif // BOOT32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\bldrtran.h ===
VOID
BldrEncoderTranslate(
    UCHAR i0, 
    UCHAR i1, 
    UCHAR i2, 
    UCHAR i3,
    UCHAR* o0,
    UCHAR* o1
    )
{
    *o0 = i0 + i1;
    *o1 = i2 + i3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\bldr32.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bldr32.c

Abstract:

    This module implements the initialization sequence required to jump to
    XBOXKRNL.EXE.

--*/

#include "bldr32.h"
#include "bldr.h"
#include "xpcicfg.h"
#include "enckey.h"

#ifdef BLDRMEMTEST
#include <ldi.h>
#include <sha.h>
#include <rc4.h>
#endif


VOID
DbgInitialize(
    VOID
    );

VOID
DbgPrintCharacter(
    IN UCHAR Character
    );

//
// Prototype for the entry point of XBOXKRNL.EXE.
//

typedef
int
(__cdecl *NTOS_ENTRY_POINT)(
    IN PUCHAR LoadOptions,
    IN const UCHAR* CryptKeys
    );


VOID
BldrDisableInteralROM(
    VOID
    );
VOID
BldrEncoderFixup(
    VOID
    );
VOID
BldrSetupUSB(
    VOID
    );

#ifdef BLDRMEMTEST
VOID
BldrTestMemory(
    ULONG StartAddress,
    ULONG EndAddress,
    BOOLEAN CompareDigests
    );

ULONG MemTestErrorCount = 0;
#endif


VOID
BldrStartup2(
    VOID
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    NTOS_ENTRY_POINT NtosEntryPoint;
    PBOOTLDRPARAM BootLdrParam;
    const UCHAR* KeyToDecryptKernel;
    BOOLEAN FirstTime;

#ifdef RETAILXM3

    BldrDisableInteralROM();

    BldrEncoderFixup();

#endif

    BldrPrint(("Bldr: Entered BldrStartup2"));

#ifdef BLDRMEMTEST
    //
    // Memory test before calibration
    //

    //BldrTestMemory(0, BLDR_RELOCATED_ORIGIN - 1, TRUE);
    BldrTestMemory(BLDR_RELOCATED_ORIGIN + BLDR_BLOCK_SIZE, 0x3FFFFFF, TRUE);
#endif


    //
    // The boot loader was relocated from BLDR_BOOT_ORIGIN to
    // BLDR_RELOCATED_ORIGIN.  Code should no longer attempt to access any
    // memory at the boot origin because it will be overwritten when we
    // decompress the kernel into low memory.  Fill the old memory with a
    // garbage value to ensure that we don't accidently use that memory.
    //

    RtlFillMemory((PVOID)(0x80000000 + BLDR_BOOT_ORIGIN), BLDR_BLOCK_SIZE, 0xCC);

    //
    // Calculate a pointer to the boot parameters stored at the begining of
    // of the boot loader image eg command line.  In case of ROM, entire image
    // including the parameter structure is decrypted so its safe to use
    // the command line which will normally be empty.
    //

    BootLdrParam = (PBOOTLDRPARAM)(0x80000000 + BLDR_RELOCATED_ORIGIN);

    FirstTime = TRUE;
#ifndef RETAILXM3
    if (strstr(BootLdrParam->CommandLine, "SHADOW") != NULL) {
        FirstTime = FALSE;
    }
#endif

    if (FirstTime) {
        
        //
        // Set drive/slew from ROM.
        //

        BldrSetDrvSlwFromROMData((PVOID)XPCICFG_GPU_MEMORY_REGISTER_BASE_0);
    
        //
        // Setup LDT bus including DWORD flow control
        //
 
        BldrSetupLDTBus();

        //
        // Configure the USB ASRC
        //

        BldrSetupUSB();
    
    }

#ifdef BLDRMEMTEST
    
    //
    // Memory test after calibration
    //

    //BldrTestMemory(0, BLDR_RELOCATED_ORIGIN - 1, FALSE);
    BldrTestMemory(BLDR_RELOCATED_ORIGIN + BLDR_BLOCK_SIZE, 0x3FFFFFF, FALSE);
#endif


    //
    // Decrypt and decompress the kernel image from ROM to its base address 
    // in RAM.  Kernel encryption key is the 3rd key in the XboxCryptKeys
    //
    
    KeyToDecryptKernel = XboxCryptKeys + (2 * XBOX_KEY_LENGTH);

    BldrCopyROMToRAM(KeyToDecryptKernel);

    //
    // Go find the entry point.
    //

    NtHeader = RtlImageNtHeader(PsNtosImageBase);

    if (NtHeader == NULL) {

        //
        // Image is invalid
        //
        
        BldrPrint(("Bldr: Entry point not found--invalid image"));

        BldrShutdownSystem();
    }

    NtosEntryPoint = (NTOS_ENTRY_POINT)((ULONG_PTR)PsNtosImageBase +
        NtHeader->OptionalHeader.AddressOfEntryPoint);

    //
    // Pass control to XBOXKRNL.EXE.
    //
    
    BldrPrint(("Bldr: Calling into the kernel"));

#ifdef BLDRMEMTEST
    
    //
    // While testing memory, if there are no errors, tell the SMC to reboot
    //

    if (MemTestErrorCount == 0) {
        DbgPrint("Memory test finished with no errors, rebooting\r\n...");
        BldrWriteSMBusByte(SMC_SLAVE_ADDRESS, 0x2, 0x40);
    } else {
        DbgPrint("Memory test FAILED with %d errors", MemTestErrorCount);
    }

#endif

    NtosEntryPoint(BootLdrParam->CommandLine, XboxCryptKeys);
}

VOID
BldrReencryptROM(
    VOID
    )
{
    BldrEncDec((PUCHAR)0 - ROM_DEC_SIZE - BLDR_BLOCK_SIZE,
        BLDR_BLOCK_SIZE, KeyToDecryptBldr, 16);
}


#ifdef RETAILXM3

VOID
BldrDisableInteralROM(
    VOID
    )
{
    _outpd(PCI_TYPE1_ADDR_PORT, 0x80000880);
    _outp(PCI_TYPE1_DATA_PORT, 2);
}


#include <bldrtran.h>


VOID
BldrEncoderFixup(
    VOID
    )
{
    UCHAR i0; 
    UCHAR i1; 
    UCHAR i2; 
    UCHAR i3;
    UCHAR o0;
    UCHAR o1;
    ULONG Val;

    //
    // Read the inputs
    //
    
    Val = 0;
    BldrReadSMBusByte(SMC_SLAVE_ADDRESS, 0x1c, &Val);
    i0 = (UCHAR)Val;
    BldrReadSMBusByte(SMC_SLAVE_ADDRESS, 0x1d, &Val);
    i1 = (UCHAR)Val;
    BldrReadSMBusByte(SMC_SLAVE_ADDRESS, 0x1e, &Val);
    i2 = (UCHAR)Val;
    BldrReadSMBusByte(SMC_SLAVE_ADDRESS, 0x1f, &Val);
    i3 = (UCHAR)Val;

    if (i0 == 0 && i1 == 0 && i2 == 0 && i3 == 0) {
        BldrShutdownSystem();    
    }

    BldrEncoderTranslate(i0, i1, i2, i3, &o0, &o1);

    //
    // Write the outputs
    //
    
    BldrWriteSMBusByte(SMC_SLAVE_ADDRESS, 0x20, o0);
    BldrWriteSMBusByte(SMC_SLAVE_ADDRESS, 0x21, o1);

    BldrPrint(("\n%d %d %d %d => %d %d", i0, i1, i2, i3, o0, o1));


    //
    // Reset the SMC revision pointer
    //
    
    BldrWriteSMBusByte(SMC_SLAVE_ADDRESS, 0x1, 0);

    //
    // Reenable all MCP devices.  Specifically NIC and IDE which
    // were disabled in the init table strap value
    //
    
    _outpd(PCI_TYPE1_ADDR_PORT, 0x8000088C);
    _outpd(PCI_TYPE1_DATA_PORT, 0x40000000);
}

#endif


VOID
BldrSetupUSB(
    VOID
    )
{

    UCHAR MCPRevisionID;

    //
    // Setup the USB ASRC (Automatic Slew Rate Compensation) which affects how the 
    // USB signal is driven.  This change is required only for MCP revision D01 and later.
    // Read the MCP revision to see if the change needs to be applied.
    //
    
    _outpd(PCI_TYPE1_ADDR_PORT, 0x80000808);
    
    MCPRevisionID = (UCHAR)_inp(PCI_TYPE1_DATA_PORT);    
    
    if (MCPRevisionID >= 0xD1) {
        _outpd(PCI_TYPE1_ADDR_PORT, 0x800008C8);
        _outpd(PCI_TYPE1_DATA_PORT, 0x00008F00);
    }
}


#ifdef BLDRMEMTEST
VOID
BldrTestMemory(
    ULONG StartAddress,
    ULONG EndAddress,
    BOOLEAN CompareDigests
    )                                                           
{
    UCHAR Key[16];
    ULONG Index;        
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    A_SHA_CTX SHAHash;

    if (CompareDigests) {
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, (PVOID)BLDR_RELOCATED_ORIGIN, BLDR_BLOCK_SIZE);
        A_SHAFinal(&SHAHash, SHADigest);
        
        DbgPrintHex(SHADigest, 20);
    
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, (PVOID)0xFFFF9E00, BLDR_BLOCK_SIZE);
        A_SHAFinal(&SHAHash, SHADigest);
        
        DbgPrintHex(SHADigest, 20);
    }


    DbgPrint("Testing memory from %x to %x with 00s", StartAddress, EndAddress);

    RtlFillMemory((PVOID)StartAddress, EndAddress - StartAddress + 1, 0);

    for (Index = 0; Index < 16; Index++) {
        Key[Index] = (UCHAR)Index;
    }
    BldrEncDec((PUCHAR)StartAddress, EndAddress - StartAddress + 1, Key, sizeof(Key));

    __asm wbinvd
    
    for (Index = 0; Index < 16; Index++) {
        Key[Index] = (UCHAR)Index;
    }
    BldrEncDec((PUCHAR)StartAddress, EndAddress - StartAddress + 1, Key, sizeof(Key));

    __asm wbinvd

    for (Index = StartAddress; Index <= EndAddress; Index++) {
        if ((*(UCHAR*)Index) != 0) {
            MemTestErrorCount++;
            DbgPrint("***Mem test failed at %x (%d)", Index, (*(UCHAR*)Index)); 
        }
    }
    
    DbgPrint("Testing memory from %x to %x with FFs", StartAddress, EndAddress);

    RtlFillMemory((PVOID)StartAddress, EndAddress - StartAddress + 1, 0xFF);

    for (Index = 0; Index < 16; Index++) {
        Key[Index] = (UCHAR)Index;
    }
    BldrEncDec((PUCHAR)StartAddress, EndAddress - StartAddress + 1, Key, sizeof(Key));

    __asm wbinvd
    
    for (Index = 0; Index < 16; Index++) {
        Key[Index] = (UCHAR)Index;
    }
    BldrEncDec((PUCHAR)StartAddress, EndAddress - StartAddress + 1, Key, sizeof(Key));

    __asm wbinvd

    for (Index = StartAddress; Index <= EndAddress; Index++) {
        if ((*(UCHAR*)Index) != 0xFF) {
            MemTestErrorCount++;
            DbgPrint("***Mem test failed at %x (%d)", Index, (*(UCHAR*)Index)); 
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements routines to assist debugging the boot loader.

--*/

#include "bldr32.h"
#include <stdio.h>
#include <dos.h>

VOID
DbgInitializeSuperIo(
    VOID
    );

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

BOOLEAN DbgInitialized = FALSE;
USHORT DbgBaseAddress = 0x3F8;
ULONG DbgBaudRate = 19200;

VOID
DbgInitialize(
    VOID
    )
{
    ULONG DivisorLatch;

    DbgInitializeSuperIo();

    DivisorLatch = CLOCK_RATE / DbgBaudRate;

    _outp(DbgBaseAddress + COM_LCR, 0x83);
    _outp(DbgBaseAddress + COM_DLM, (UCHAR)(DivisorLatch >> 8));
    _outp(DbgBaseAddress + COM_DLL, (UCHAR)(DivisorLatch));
    _outp(DbgBaseAddress + COM_LCR, 0x03);

    _outp(DbgBaseAddress + COM_MCR, MC_DTRRTS);
    _outp(DbgBaseAddress + COM_IEN, 0);

    DbgInitialized = TRUE;
}

VOID
DbgPrintCharacter(
    IN UCHAR Character
    )
{
    while (!(_inp(DbgBaseAddress + COM_LSR) & COM_OUTRDY));

    _outp(DbgBaseAddress + COM_DAT, Character);
}


ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    int current;

    if (!DbgInitialized) {
        DbgInitialize();
    }

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    for (current = 0; current < cb; current++) {
        DbgPrintCharacter(Buffer[current]);
    }
    DbgPrintCharacter('\r');
    DbgPrintCharacter('\n');

    return STATUS_SUCCESS;
}


VOID
DbgPrintHex(
    PUCHAR Buffer,
    ULONG  BufferSize
    )
{
    UCHAR Nibble;
    ULONG i;
    
    if (!DbgInitialized) {
        DbgInitialize();
    }

    for (i = 0; i < BufferSize; i++) {

        Nibble = (Buffer[i] & 0xF0) >> 4;
    
        if (Nibble <= 9) {
            Nibble += '0';
        } else {
            Nibble -= 10;
            Nibble += 'A';
        }
        DbgPrintCharacter(Nibble);
    
        Nibble = (Buffer[i] & 0x0F);
    
        if (Nibble <= 9) {
            Nibble += '0';
        } else {
            Nibble -= 10;
            Nibble += 'A';
        }
        DbgPrintCharacter(Nibble);
    }
    DbgPrintCharacter('\r');
    DbgPrintCharacter('\n');
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\drvslw.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    drvslw.c

Abstract:

    This module implements code to perform Drive/Slew Pad compensation, so we
    can bring the memory clock up to fullspeed early during boot.

--*/

#include "bldr32.h"
#include <bldr.h>
#include "romdata.h"
#include <nv_ref_2a.h>

//
// To enable cache checking code using PMC, define CHECKCACHE
//
#undef CHECKCACHE

//
// Location of the ROM base (mapped in BldrStartup) and the datatbl offset.
//
#define BLDR_ROM_BASE               0xFFC00000
#define BLDR_ROM_DATA_OFFSET        0x0000007C

//
// Macros used by calibration code
//
#define TOFIXEDPOINT(d)             ((d) << 20)
#define SLW_VALUE(r,f)              SlwValue(r,f)
#define FROMFIXEDPOINT(d)           FromFixedPoint(d);

#define NV_PBUS_FBIO_CALEN_VAL      0x000f0f0f
#define NV_PBUS_FBIO_CALSEL_VCCQ    0x00040004
#define NV_PBUS_FBIO_CALSEL_VCC     0x00040000

#define DRF_MASK(drf)               (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))

//
// PMC event to use for cache checking code
//
#define PMC_EVENT    0x65   // Number of bus burst read transactions

//
// LDT flow control enable bits
//
#define LDT_FLOW_CONTROL_BITS       0x88000000


//
// LDT registers
//
#define CR_CPU_LDT_1                0x80000064
#define CR_CPU_LDT_3_USER_CNFG      0x8000006C
#define MCP_LEG_CFG_21              0x80000854
 

#define CR_CPU_MEMTOP               0x80000084
#define CR_CPU_MEMTOP_LIMIT_64MB    0x03FFFFFF
#define CR_CPU_MEMTOP_LIMIT_128MB   0x07FFFFFF

#define CR_CPU_GRAP                 0x80000080

//
// Memory test results
//
#define MCP_USBA_CFG_15             0x8000103C
#define MCP_USBB_CFG_15             0x8000183C



typedef struct _REGVALUEPAIR {
    ULONG Register;
    ULONG Value;
} REGVALUEPAIR, *PREGVALUEPAIR;



FORCEINLINE
ULONG
REG_RD32(
    VOID* Ptr,
    ULONG Addr
    )
{
    return *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr)));
}


FORCEINLINE
VOID
REG_WR32(
    VOID* Ptr,
    ULONG Addr,
    ULONG Val)
{
    *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr))) = (ULONG)(Val);
}


#ifdef CHECKCACHE
FORCEINLINE
VOID
SetPMCEvent(
    ULONG Event
    )
{
    Event |= ((1 << 22) | (1 << 17) | (1 << 18) | (1 << 20));

    __asm {
        mov     ecx, 0x186
        mov     eax, Event
        xor     edx, edx
        wrmsr  

        ;
        ; mov eax, cr4
        ;
        _emit   0Fh
        _emit   20h
        _emit   0E0h  

        or eax, 100h
        
        ;
        ; mov cr4, eax
        ;
        _emit   0Fh
        _emit   22h
        _emit   0E0h  
    }
}


FORCEINLINE
ULONG
ReadPMCLow(
    VOID
    )
{
    ULONG LowPart;

    __asm {
        xor     edx, edx
        xor     ecx, ecx
        _emit   0fh
        _emit   33h
        mov     LowPart, eax
    }
    
    return LowPart;
};
#endif


VOID 
BldrDelay(
    ULONG nsec
    )
/*++

Routine Description:

    This is a busy wait loop for the drive/slew calibration only.  Its not very 
    accurate, since the 733MHz cycle time (1.364ns) is rounded to 1ns and also 
    doesn't account for the instructions that make-up the loop.  The idle times 
    being passed in are currently 10us, so delaying a little longer in this 
    routine shouldn't be noticeable.


Arguments:


Return Value:

    None.

--*/
{
    ULONG tick_curr_lo, tick_curr_hi;
    ULONG tick_end_lo, tick_end_hi;

    //
    // Read start counters
    //
    __asm {
        rdtsc
        mov tick_curr_lo, eax
        mov tick_curr_hi, edx
    }

    tick_end_hi = tick_curr_hi;
    tick_end_lo = tick_curr_lo + nsec;  

    // 
    // Handle rollover
    //
    if (tick_end_lo < tick_curr_lo) {
        tick_end_hi++;  
    }

    //
    // Do nothing loop for specified time
    //
    do {
        __asm {
            rdtsc
            mov tick_curr_lo, eax
            mov tick_curr_hi, edx
        }
    } while ((tick_curr_hi <= tick_end_hi) &&
             (tick_curr_lo < tick_end_lo)); 
}


static _declspec(noinline)
ULONG 
SlwValue(
    ULONG r, 
    ULONG f
    )
{
   return ((r << 28) | (f << 24) | (r << 20) | (f << 16) | (r << 12) | (f << 8)  | (r <<  4) |  f);
}


static _declspec(noinline)
ULONG 
FromFixedPoint(
    ULONG d
    )
{
    return ((((d) + (0x1 << 19)) >> 20) & 0xf);
}



FORCEINLINE
ULONG
ReadPCIConfig(
    ULONG Reg
    )
{
    _outpd(PCI_TYPE1_ADDR_PORT, Reg);
    return _inpd(PCI_TYPE1_DATA_PORT);
}


VOID
BldrSetDrvSlwFromROMData(
    PVOID RegisterBase
    )
{
    ULONG *offsetp;
    PROM_DATATBL pROMData;
    PDRVSLWCALPARAMS pDrvSlwCalParams;
    PDRVSLWPADPARAMS pPadParams, pDrvSlwPadParam_lo, pDrvSlwPadParam_hi;
    ULONG adr_drv_fall, adr_drv_rise, adr_drv,
          clk_drv_fall, clk_drv_rise, clk_drv,
          dat_drv_fall, dat_drv_rise, dat_drv,
          dqs_drv_fall, dqs_drv_rise, dqs_drv;
    ULONG adr_slw_fall, adr_slw_rise, adr_slw,
          clk_slw_fall, clk_slw_rise, clk_slw,
          dat_slw_fall, dat_slw_rise, dat_slw,
          dqs_slw_fall, dqs_slw_rise, dqs_slw;
    ULONG dqs_ib_del, data_ib_del, clk_ic_del, fbio_dly;
    ULONG vccq_a, vccq_b, vccq_c, vccq_d, avg_vccq;
    ULONG vcc_a, vcc_b, vcc_c, vcc_d, avg_vcc;
    ULONG ratio_a, ratio_b;

    REGVALUEPAIR RegValuePair[9];
    ULONG Pass;
    ULONG i;
#ifdef CHECKCACHE
    ULONG BeginHits;
    ULONG EndHits;
#endif
    ULONG StrapEMRS;

    //
    // Find start of ROM datatbl containing drive/slew data
    //
    offsetp = (ULONG *)(BLDR_ROM_BASE + BLDR_ROM_DATA_OFFSET);
    pROMData = (PROM_DATATBL)(BLDR_ROM_BASE + *offsetp);
    pDrvSlwCalParams = &pROMData->calParams;

    //
    // Check to see if its Samsung or a Micron memory bits 19:18
    //
    StrapEMRS = REG_RD32(RegisterBase, NV_PEXTDEV_BOOT_0) & 0x0000C0000;

    if (StrapEMRS == 0) {
        pPadParams = &(pROMData->MicronParams[0]);
        BldrPrint(("Bldr: Memory type: Micron"));
    }
    else {
        pPadParams = &(pROMData->SamsungParams[0]);
        BldrPrint(("Bldr: Memory type: Samsung"));
    }
    
#ifdef BLDRSPEW
    //
    // Dump out memory sizes etc
    //
    if (ReadPCIConfig(CR_CPU_MEMTOP) == CR_CPU_MEMTOP_LIMIT_64MB) {
        BldrPrint(("Bldr: Memory size: 64MB"));
    } else {
        BldrPrint(("Bldr: Memory size: 128MB")); 
    }
    
    BldrPrint(("Bldr: Memory test results: 4MB/2MB=%x, Pass/Fail=%x", 
        ReadPCIConfig(MCP_USBA_CFG_15) & 0xff, 
        ReadPCIConfig(MCP_USBB_CFG_15) & 0xff));
    
    BldrPrint(("Bldr: NV_PBUS_FBIO_DLY=%x", REG_RD32(RegisterBase, NV_PBUS_FBIO_DLY)));
    BldrPrint(("Bldr: PadParams=%x", pPadParams));

    BldrPrint(("Bldr: DriveSlewCalibration started"));
#endif    

    //
    // Read the calibration for outbound/inbound 
    //
    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALEN, NV_PBUS_FBIO_CALEN_VAL);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ);
    BldrDelay(10*1000);    // 10 usecs
    vccq_a = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ+1);
    BldrDelay(10*1000);    // 10 usecs
    vccq_b = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ+2);
    BldrDelay(10*1000);    // 10 usecs
    vccq_c = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ+3);
    BldrDelay(10*1000);    // 10 usecs
    vccq_d = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    avg_vccq = (vccq_a + vccq_b + vccq_c + vccq_d) / 4;

    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_A=0x%x", vccq_a));
    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_B=0x%x", vccq_b));
    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_C=0x%x", vccq_c));
    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_D=0x%x", vccq_d));

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC);
    BldrDelay(10*1000);    // 10 usecs
    vcc_a = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC+1);
    BldrDelay(10*1000);    // 10 usecs
    vcc_b = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC+2);
    BldrDelay(10*1000);    // 10 usecs
    vcc_c = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC+3);
    BldrDelay(10*1000);    // 10 usecs
    vcc_d = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    avg_vcc = (vcc_a + vcc_b + vcc_c + vcc_d) / 4;

    BldrPrint(("Bldr: DriveSlewCalibration VCC_A=0x%x", vcc_a));
    BldrPrint(("Bldr: DriveSlewCalibration VCC_B=0x%x", vcc_b));
    BldrPrint(("Bldr: DriveSlewCalibration VCC_C=0x%x", vcc_c));
    BldrPrint(("Bldr: DriveSlewCalibration VCC_D=0x%x", vcc_d));

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALEN, 0);

    //
    // Determine outbound process params and interp ratio_a/ratio_b
    //
    if (avg_vccq <= pDrvSlwCalParams->SlowCountAvg) {
        BldrPrint(("Bldr: Outbound interp slow ext -> slow avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwExtSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgSlow];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->SlowCountExt) /
                              (pDrvSlwCalParams->SlowCountAvg - pDrvSlwCalParams->SlowCountExt);
        if (ratio_a & 0x80000000)  
            ratio_a = 0;
    
    } else if (avg_vccq >= pDrvSlwCalParams->FastCountAvg) {
        BldrPrint(("Bldr: Outbound interp fast avg -> fast ext"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgFast];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwExtFast];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->FastCountAvg) /
                              (pDrvSlwCalParams->FastCountExt - pDrvSlwCalParams->FastCountAvg);
        if (ratio_a > TOFIXEDPOINT(1))
            ratio_a = 1;
    
    } else if (avg_vccq < pDrvSlwCalParams->TypiCount) {
        BldrPrint(("Bldr: Outbound interp slow avg -> typical"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwTypical];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->SlowCountAvg) /
                              (pDrvSlwCalParams->TypiCount - pDrvSlwCalParams->SlowCountAvg);
    } else {
        BldrPrint(("Bldr: Outbound interp typical -> fast avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwTypical];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgFast];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->TypiCount) /
                              (pDrvSlwCalParams->FastCountAvg - pDrvSlwCalParams->TypiCount);
    }

    ratio_b = TOFIXEDPOINT(1) - ratio_a;

    adr_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrDrvFall * ratio_a)); 
    adr_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrDrvRise * ratio_a));
    adr_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrSlwFall * ratio_a));
    adr_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrSlwRise * ratio_a));

    clk_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkDrvFall * ratio_a));
    clk_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkDrvRise * ratio_a));
    clk_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkSlwFall * ratio_a));
    clk_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkSlwRise * ratio_a));

    dat_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatDrvFall * ratio_a));
    dat_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatDrvRise * ratio_a));
    dat_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatSlwFall * ratio_a));
    dat_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatSlwRise * ratio_a));

    dqs_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsDrvFall * ratio_a));
    dqs_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsDrvRise * ratio_a));
    dqs_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsSlwFall * ratio_a));
    dqs_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsSlwRise * ratio_a));

    //
    // Determine inbound process params and interp ratio_a/ratio_b
    //
    if (avg_vcc <= pDrvSlwCalParams->SlowCountBAvg) {
        
        BldrPrint(("Bldr: Inbound interp slow ext -> slow avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwExtSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgSlow];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->SlowCountBExt) /
                              (pDrvSlwCalParams->SlowCountBAvg - pDrvSlwCalParams->SlowCountBExt);
        if (ratio_a & 0x80000000) {      
            ratio_a = 0;
        }
    
    } else if (avg_vcc >= pDrvSlwCalParams->FastCountBAvg) {
        
        BldrPrint(("Bldr: Inbound interp fast avg -> fast ext"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgFast];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwExtFast];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->FastCountBAvg) /
                              (pDrvSlwCalParams->FastCountBExt - pDrvSlwCalParams->FastCountBAvg);
        if (ratio_a > TOFIXEDPOINT(1)) {
            ratio_a = 1;
        }
    
    } else if (avg_vcc < pDrvSlwCalParams->TypiCountB) {
        
        BldrPrint(("Bldr: Inbound interp slow avg -> typical"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwTypical];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->SlowCountBAvg) /
                              (pDrvSlwCalParams->TypiCountB - pDrvSlwCalParams->SlowCountBAvg);
    
    } else {

        BldrPrint(("Bldr: Inbound interp typical -> fast avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwTypical];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgFast];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->TypiCountB) /
                              (pDrvSlwCalParams->FastCountBAvg - pDrvSlwCalParams->TypiCountB);
    }
    
    ratio_b = TOFIXEDPOINT(1) - ratio_a;

    dqs_ib_del = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsInbDely * ratio_b) +
                                (pDrvSlwPadParam_hi->DqsInbDely * ratio_a));

    data_ib_del = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DataInbDely * ratio_b) +
                                 (pDrvSlwPadParam_hi->DataInbDely * ratio_a));

    clk_ic_del = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkIcDely * ratio_b) +
                                (pDrvSlwPadParam_hi->ClkIcDely * ratio_a));
    
    //
    // NOTE: We must write all 9 register values without accessing memory
    //       Therefore, all code and data must be present in the cache
    // 

    //
    // Clear the cache
    //
    __asm wbinvd;

    //
    // Save the final register values and registers in an array
    //

    adr_drv = SLW_VALUE(adr_drv_rise, adr_drv_fall);
    RegValuePair[0].Register = NV_PBUS_FBIO_ADRDRV; 
    RegValuePair[0].Value = adr_drv;  

    adr_slw = SLW_VALUE(adr_slw_rise, adr_slw_fall);
    RegValuePair[1].Register = NV_PBUS_FBIO_ADRSLW; 
    RegValuePair[1].Value = adr_slw;  

    clk_drv = SLW_VALUE(clk_drv_rise, clk_drv_fall);
    RegValuePair[2].Register = NV_PBUS_FBIO_CLKDRV; 
    RegValuePair[2].Value = clk_drv;

    clk_slw = SLW_VALUE(clk_slw_rise, clk_slw_fall);
    RegValuePair[3].Register = NV_PBUS_FBIO_CLKSLW; 
    RegValuePair[3].Value = clk_slw;  

    dat_drv = SLW_VALUE(dat_drv_rise, dat_drv_fall);
    RegValuePair[4].Register = NV_PBUS_FBIO_DATDRV; 
    RegValuePair[4].Value = dat_drv;  

    dat_slw = SLW_VALUE(dat_slw_rise, dat_slw_fall);
    RegValuePair[5].Register = NV_PBUS_FBIO_DATSLW; 
    RegValuePair[5].Value = dat_slw;  

    dqs_drv = SLW_VALUE(dqs_drv_rise, dqs_drv_fall);
    RegValuePair[6].Register = NV_PBUS_FBIO_DQSDRV; 
    RegValuePair[6].Value = dqs_drv;  

    dqs_slw = SLW_VALUE(dqs_slw_rise, dqs_slw_fall);
    RegValuePair[7].Register = NV_PBUS_FBIO_DQSSLW; 
    RegValuePair[7].Value = dqs_slw;  

    fbio_dly = (dqs_ib_del << 29) | (clk_ic_del << 27) | (data_ib_del << 24) |
               (dqs_ib_del << 21) | (clk_ic_del << 19) | (data_ib_del << 16) |
               (dqs_ib_del << 13) | (clk_ic_del << 11) | (data_ib_del << 8) |
               (dqs_ib_del << 5)  | (clk_ic_del << 3)  |  data_ib_del;
    
    RegValuePair[8].Register = NV_PBUS_FBIO_DLY; 
    RegValuePair[8].Value = fbio_dly;

    //
    // Read the array byte by byte to ensure it is in cache.  
    //
    for (i = 0; i < 9; i++) {
        if (RegValuePair[i].Register == 0 || RegValuePair[i].Value == 0) {
            RegValuePair[i].Register = 0;
        }
    }

#ifdef CHECKCACHE
    SetPMCEvent(PMC_EVENT);   
#endif
    
    //
    // First pass is a NOP and used to ensure the code is in cache
    // Second pass actually writes the register values out
    //
    for (Pass = 0; Pass < 2; Pass++) {

#ifdef CHECKCACHE
        BeginHits = ReadPMCLow();
#endif

        for (i = 0; i < 9; i++) {
            if (Pass == 1) {
                REG_WR32(RegisterBase, RegValuePair[i].Register, 
                    RegValuePair[i].Value);
            }

        }

#ifdef CHECKCACHE
        EndHits = ReadPMCLow();
#endif
    
    }
    
#ifdef CHECKCACHE
    BldrPrint(("Bldr: Mem reads during register writes=%d (must be zero) (%d,%d)", 
              (EndHits - BeginHits), EndHits, BeginHits));
#endif
    

#ifdef BLDRSPEW
    for (i = 0; i < 9; i++) {
        BldrPrint(("Bldr: DriveSlewCalibration register %x=%x", RegValuePair[i].Register, 
            RegValuePair[i].Value));
    }

    BldrPrint(("Bldr: DriveSlewCalibration setup finished"));
#endif

}




VOID
BldrSetupLDTBus(
    VOID
    )
{
    ULONG ldt_data;
    
    //
    // NOTE: Since we have to reset the LDT bus as part of this initialization, we
    // can't run this code out of the ROM (while resetting the bus, we won't be
    // able to execute the code to reenable it), so it has to be in memory.
    //
 
    BldrPrint(("Bldr: Enabling LDT DWORD flow control"));

    // 
    // Enable DWORD flow control in the MCP
    //
    _outpd(PCI_TYPE1_ADDR_PORT, MCP_LEG_CFG_21);
    ldt_data = _inpd(PCI_TYPE1_DATA_PORT);
    ldt_data |= LDT_FLOW_CONTROL_BITS;
    _outpd(PCI_TYPE1_DATA_PORT, ldt_data);
 
    //
    // Enable DWORD flow control in the NV2A
    //
    _outpd(PCI_TYPE1_ADDR_PORT, CR_CPU_LDT_1);
    ldt_data = _inpd(PCI_TYPE1_DATA_PORT);
    ldt_data |= LDT_FLOW_CONTROL_BITS;
    _outpd(PCI_TYPE1_DATA_PORT, ldt_data);
 
    //
    // Force a reset of the LDT link. This is done by toggling the
    // WARM_RESET bit (bit0), where a 0 initiates the reset and a 1 
    // completes it
    //
    _outpd(PCI_TYPE1_ADDR_PORT, CR_CPU_LDT_3_USER_CNFG);
    ldt_data = _inpd(PCI_TYPE1_DATA_PORT);
    _outpd(PCI_TYPE1_DATA_PORT, (ldt_data & 0xFFFFFFFE));
    _outpd(PCI_TYPE1_DATA_PORT, ldt_data);

    //
    // Allow the LDT->1GB transactions by ensuring that the GART is visible to LDT.
    // Due to the fact there is a shadow copy of this register, we must do this write
    // even though the power on value is already 0x100
    //
    _outpd(PCI_TYPE1_ADDR_PORT, CR_CPU_GRAP);
    _outpd(PCI_TYPE1_DATA_PORT, 0x100);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\enckey.h ===
//
// NOTE: Checked in version of this file should only contain the test keys
// The checked in keys are intended to be used for DevKits (xm2) only.
//


//
// Encryption key used to encrypt the boot loader.  We only use this when
// reloading a media ROM
//
const UCHAR KeyToDecryptBldr[] =
    {
        0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
        0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
    };

//
// This array contains multiple 16-byte decryption keys:
//  1. The first key is used to decrypt the encrypted section of the EEPROM.
//  2. The second key is the CERT key.
//  3. Encryption key used to encrypt/decrypt the kernel
//
const UCHAR XboxCryptKeys[3 * XBOX_KEY_LENGTH] = {
    // EEPROM key
    0x7b, 0x35, 0xa8, 0xb7, 0x27, 0xed, 0x43, 0x7a,
    0xa0, 0xba, 0xfb, 0x8f, 0xa4, 0x38, 0x61, 0x80,

    // CERT key
    0x66, 0x81, 0x0d, 0x37, 0x91, 0xfd, 0x45, 0x7f,
    0xbf, 0xa9, 0x76, 0xf8, 0xa4, 0x46, 0xa4, 0x94,

    // Kernel encryption key
    0xAD, 0x32, 0x64, 0x01, 0x2F, 0xC8, 0xF4, 0xAD,  
    0xA9, 0xF5, 0xAF, 0x45, 0x22, 0xB7, 0x18, 0xD1   

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\startup.asm ===
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     startup.asm
;
;  Abstract:
;
;     This module implements the entry point for the 32-bit boot loader code.
;
;  Environment:
;
;     32-bit protected mode.
;
;--

        .586p

        INCLUDE bldr.inc
        INCLUDE ks386.inc

        EXTERN  _BldrStartup2@0:NEAR
        EXTERN  _BldrTopOfROMAddress:DWORD
        EXTERN  _XboxCryptKeys:DWORD
        EXTERN  _BldrReencryptROM@0:NEAR

_TEXT   SEGMENT PARA USE32 PUBLIC 'CODE'

        ASSUME  DS:_TEXT, ES:_TEXT, SS:_TEXT, FS:NOTHING, GS:NOTHING

;
; BldrStartup
;
; Entry point for the 32-bit boot loader.
;
; The DWORD immediately before the entry point is the address of the routine to
; reload a media ROM.  When the kernel loads a ROM from the hard disk or CD-ROM,
; it will decrypt the boot loader, extract this function pointer relative to the
; boot loader entry point and jump to that code.
;
; The DWORD before the above is used to point to key data.  ROMBLD uses this
; to find where the keys are located in this image
;

        dd      OFFSET _XboxCryptKeys
        dd      OFFSET @BldrLoadMediaROM@4
        PUBLIC  _BldrStartup
_BldrStartup PROC

;
; Flush the processor's caches and disable the MTRRs in order to change the MTRR
; policy.  At this point, the MTRRs are initialized to map memory either as
; uncached or write-back.
;

        mov     eax, cr0                ; disable and flush cache
        or      eax, (CR0_CD OR CR0_NW)
        mov     cr0, eax
        wbinvd

        mov     eax, cr3                ; flush TLB
        mov     cr3, eax

        mov     ecx, 2FFh               ; disable MTRR
        xor     eax, eax
        xor     edx, edx
        wrmsr

;
; Set up the first 64MB (or 128MB for DEVKIT) to writeback using the first
; variable-range MTRR.
;

        mov     ecx, 200h
        mov     eax, 6                  ; physical base 00000h as writeback
        xor     edx, edx
        wrmsr

        inc     ecx
ifdef DEVKIT
        mov     eax, 0F8000800h         ; physical mask FF8000h, 128MB for DEVKIT
else
        mov     eax, 0FC000800h         ; physical mask FFC000h, 64MB
endif
        mov     edx, 00000000Fh
        wrmsr

;
; Set up the top 512KB to write-protected using the second variable-range MTRR.
;

        inc     ecx
        mov     eax, 0FFF80005h         ; physical base 0FFF80h as write-protected
        xor     edx, edx
        wrmsr

        inc     ecx
        mov     eax, 0FFF80800h         ; physical mask FFFF80h
        mov     edx, 00000000Fh
        wrmsr

;
; Reset the contents of the rest of the variable-range MTRRs.
;

        inc     ecx
        xor     eax, eax
        xor     edx, edx
@@:
        wrmsr
        inc     ecx
        cmp     ecx, 20Fh
        jbe     @B

;
; Enable MTRR, disable fix-range MTRRs and set default memory type to UC.
;

        mov     ecx, 2FFh
        mov     eax, 800h
        wrmsr

;
; Enable the processor cache by clearing cache disable and not-write-through
; flags in CR0.
;

        mov     eax, cr0
        and     eax, NOT (CR0_CD OR CR0_NW)
        mov     cr0, eax

;
; Load the various segment registers with the expected values.
;

        mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax
        mov     esp, BLDR_RELOCATED_ORIGIN

        xor     eax, eax
        mov     fs, eax
        mov     gs, eax

;
; Copy the boot loader to the relocated boot origin so that once we jump to
; BldrStartup2, we'll be out of the way of the base address of XBOXKRNL.EXE.
;

        cld
ifdef MCP_B02XM3
        mov     esi, BLDR_BOOT_ORIGIN
else
        mov     esi, ebp
endif
        mov     edi, BLDR_RELOCATED_ORIGIN
        mov     ecx, ROMLDR_SIZE / 4
        rep     movsd

;
; Fill in the page directory with identify mappings for the first 256M of memory
; at both linear address 0x00000000 and 0x80000000.  Large pages (4MB) are used
; for this mapping.  Zero out the rest of the page directory.
;

        mov     edi, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     ecx, 64
        mov     eax, BLDR_VALID_KERNEL_LARGE_PTE_BITS   ; Set valid, write, large Page, PFN=0
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        add     eax, 400000h                            ; Advanced PFN to the next 4MB page.
        loop    @B

        mov     ecx, 448
        xor     eax, eax
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        loop    @B

;
; Double map the page directory page.
;

        mov     edi, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS + BLDR_VALID_KERNEL_PTE_BITS
        mov     DWORD PTR [edi + ((0C0000000h SHR 22) SHL 2)], eax

;
; Identity map 4MB of ROM space to the page directory.
;

        mov     eax, 0FFC00000h + BLDR_VALID_KERNEL_LARGE_PTE_BITS
        mov     DWORD PTR [edi + ((0FFC00000h SHR 22) SHL 2)], eax

;
; Identity map 16MB of GPU register space to the page directory (uncached)
;
        mov     eax, XPCICFG_GPU_MEMORY_REGISTER_BASE_0 + BLDR_VALID_KERNEL_LARGE_PTE_UC_BITS
        mov     ebx, eax
        shr     ebx, (22 - 2)
        add     edi, ebx
        mov     DWORD PTR [edi], eax    ; 4MB
        add     edi, 4
        add     eax, 400000h
        mov     DWORD PTR [edi], eax    ; 8MB
        add     edi, 4
        add     eax, 400000h
        mov     DWORD PTR [edi], eax    ; 12MB
        add     edi, 4
        add     eax, 400000h
        mov     DWORD PTR [edi], eax    ; 16MB

;
; Initialize the page attribute table (PAT_TYPE_WB, PAT_TYPE_USWC,
; PAT_TYPE_WEAK_UC, PAT_TYPE_STRONG_UC in the low and high elements of the
; table).
;

        mov     eax, cr0
        mov     ebx, eax
        and     eax, NOT CR0_NW
        or      eax, CR0_CD
        mov     cr0, eax                ; Disable caching and line fill
        wbinvd
        mov     ecx, 277h               ; PAT register
        mov     eax, 00070106h          ; STRONG_UC, WEAK_UC, UWSC, WB
        mov     edx, eax
        wrmsr
        wbinvd
        mov     cr0, ebx                ; Restore cr0

;
; Enable the processor's large page support, FXSR support, and XMMI exception
; handling.
;

        mov     eax, cr4
        or      eax, CR4_PSE + CR4_FXSR + CR4_XMMEXCPT
        mov     cr4, eax

;
; Load the address of the page directory into the processor.
;

        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     cr3, eax

;
; Enable the paging support, and numeric exception support.
;

        mov     eax, cr0
        or      eax, CR0_PG + CR0_WP + CR0_NE
        mov     cr0, eax

        jmp     @F
@@:

;
; Reload the stack segment register with its mapped address.
;

        mov     esp, 080000000h + BLDR_RELOCATED_ORIGIN

;
; Call the C entry point of the boot loader.  Note that we need to load the
; address of the C entry point into a register in order to obtain the absolute
; address of the entry point.  If we call BldrStartup2 directly, then a EIP
; relative call will be generated and we'll run from the boot origin instead of
; the relocated origin.
;

        lea     eax, _BldrStartup2@0
        call    eax

;
; Spin. We should not get here
;

@@:     jmp     @B

_BldrStartup ENDP

;
; BldrLoadMediaROM
;
; Invoked by XBOXKRNL.EXE to load another instance of the ROM from the CD-ROM or
; hard disk.
;

        PUBLIC  @BldrLoadMediaROM@4

@BldrLoadMediaROM@4 PROC

IFNDEF MCP_XMODE3
        
        cli
        mov     edx, ecx

;
; Fill in the page directory with identify mappings for the first 256M of memory
; at both linear address 0x00000000 and 0x80000000.  Large pages (4MB) are used
; for this mapping.  Zero out the rest of the page directory.
;

        mov     edi, 080000000h + PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     ecx, 64
        mov     eax, BLDR_VALID_KERNEL_LARGE_PTE_BITS   ; Set valid, write, large Page, PFN=0
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        add     eax, 400000h                            ; Advanced PFN to the next 4MB page.
        loop    @B

        mov     ecx, 448
        xor     eax, eax
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        loop    @B

;
; Double map the page directory page.
;

        mov     edi, 080000000h + PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS + BLDR_VALID_KERNEL_PTE_BITS
        mov     DWORD PTR [edi + ((0C0000000h SHR 22) SHL 2)], eax

;
; Map the shadow ROM into the top of memory.  This can't be done with large
; page mapping, so we borrow the page below the page directory for the
; page table.  We'll map the upper 1MB and leave the rest of it undefined
;
        sub     eax, 01000h
        mov     DWORD PTR [edi + ((0FFF00000h SHR 22) SHL 2)], eax
        sub     edi, 0400h
        lea     eax, [edx + BLDR_VALID_KERNEL_PTE_BITS]
        mov     ecx, 0100h
@@:
        stosd
        add     eax, 01000h
        loop    @B

;
; Load the address of the page directory into the processor.  This should end up
; being the same page directory that we're already running on, but this will
; flush out the stale entries in the TLB.
;

        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     cr3, eax

;
; We're going to be overwriting the current kernel image, including the current
; global descriptor table, so move us to a safe table.
;

        lgdt    FWORD PTR [BldrRestartGDTFWORD]

;
; Execute a 16:32 jump to reload the code selector.
;

        db      0EAh
        dd      OFFSET lmr10
        dw      KGDT_R0_CODE
lmr10:

;
; Load the various segment registers with the expected values.
;

        mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax
        mov     esp, 080000000h + BLDR_RELOCATED_ORIGIN

        xor     eax, eax
        mov     fs, eax
        mov     gs, eax

;
; Store the virtual address of the shadow ROM in the global pointer so that we
; don't go back to the real ROM.
;

        add     edx, 080000000h + ROM_SHADOW_SIZE
        mov     DWORD PTR [_BldrTopOfROMAddress], edx

;
; Reencrypt the boot loader to restore the original ROM image
;

        call    _BldrReencryptROM@0

;
; Call the C entry point of the boot loader.
;

        lea     eax, _BldrStartup2@0
        call    eax
ENDIF
;
; Spin. We should not get here.
;

@@:     jmp     @B

@BldrLoadMediaROM@4 ENDP

;
; Values to initialize the processor's descriptor tables.
;

        ALIGN   4
BldrRestartGDT LABEL DWORD
        dd      0                       ; KGDT_NULL
        dd      0
        dd      00000FFFFh              ; KGDT_R0_CODE
        dd      000CF9B00h
        dd      00000FFFFh              ; KGDT_R0_DATA
        dd      000CF9300h
BldrRestartGDTEnd LABEL DWORD

        ALIGN   4
BldrRestartGDTFWORD LABEL FWORD
        dw      OFFSET BldrRestartGDTEnd - OFFSET BldrRestartGDT
        dd      OFFSET BldrRestartGDT

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\romdata.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    romdata.h

Abstract:

    Header file for XBox boot loader (contains datatbl format)


--*/

#ifndef _DATATBL_H
#define _DATATBL_H

//
// Data struct contains all of the drive/slew parameters.
//
typedef struct _drv_slw_cal_params {
    USHORT MaxMClk;

    UCHAR SlowCountExt;
    UCHAR SlowCountBExt;
    UCHAR SlowCountAvg;
    UCHAR SlowCountBAvg;
    UCHAR TypiCount;
    UCHAR TypiCountB;
    UCHAR FastCountAvg;
    UCHAR FastCountBAvg;
    UCHAR FastCountExt;
    UCHAR FastCountBExt;
} DRVSLWCALPARAMS, *PDRVSLWCALPARAMS;

//
// Data structure contains the drive/slew per-speed process parameters.
//
typedef struct _drv_slw_pad_params {
    UCHAR AdrDrvFall;
    UCHAR AdrDrvRise;
    UCHAR AdrSlwFall;
    UCHAR AdrSlwRise;

    UCHAR ClkDrvFall;
    UCHAR ClkDrvRise;
    UCHAR ClkSlwFall;
    UCHAR ClkSlwRise;

    UCHAR DatDrvFall;
    UCHAR DatDrvRise;
    UCHAR DatSlwFall;
    UCHAR DatSlwRise;

    UCHAR DqsDrvFall;
    UCHAR DqsDrvRise;
    UCHAR DqsSlwFall;
    UCHAR DqsSlwRise;

    UCHAR DataInbDely;
    UCHAR ClkIcDely;
    UCHAR DqsInbDely;
} DRVSLWPADPARAMS, *PDRVSLWPADPARAMS;


enum {
    DrvSlwExtFast = 0,
    DrvSlwAvgFast,
    DrvSlwTypical,
    DrvSlwAvgSlow,
    DrvSlwExtSlow,
    DrvSlwTotal,
};


//
// Complete layout of the ROM data table
//
typedef struct _rom_datatbl {
    DRVSLWCALPARAMS calParams;
    DRVSLWPADPARAMS SamsungParams[DrvSlwTotal];
    DRVSLWPADPARAMS MicronParams[DrvSlwTotal];
} ROM_DATATBL, *PROM_DATATBL;

#endif // _DATATBL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\smbus.asm ===
TITLE   "SMBus Routines"
;++
;
;  Copyright (c) Microsoft Corporation
;
;  Module Name:
;
;     smbus.asm
;
;  Abstract:
;
;     This module implements the routines to send and receive data over SMBus.
;
;
;--

        .686p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

;
; Define the SMBus registers starting at XPCICFG_SMBUS_IO_REGISTER_BASE_1.
;

MCPX_SMBUS_HOST_STATUS_REGISTER         EQU     00h
MCPX_SMBUS_HOST_CONTROL_REGISTER        EQU     02h
MCPX_SMBUS_HOST_ADDRESS_REGISTER        EQU     04h
MCPX_SMBUS_HOST_DATA_REGISTER           EQU     06h
MCPX_SMBUS_HOST_COMMAND_REGISTER        EQU     08h
MCPX_SMBUS_HOST_BLOCK_DATA_REGISTER     EQU     09h

;
; Define the status bits for MCPX_SMBUS_HOST_STATUS_REGISTER.
;

MCPX_STATUS_HOST_ABORT                  EQU     0001h
MCPX_STATUS_COLLISION                   EQU     0002h
MCPX_STATUS_PROTOCOL_ERROR              EQU     0004h
MCPX_STATUS_HOST_BUSY                   EQU     0008h
MCPX_STATUS_HOST_CYCLE_COMPLETE         EQU     0010h
MCPX_STATUS_TIMEOUT_ERROR               EQU     0020h

;
; Define the control bits for MCPX_SMBUS_HOST_CONTROL_REGISTER.
;

MCPX_CONTROL_CYCLE_READ_WRITE_BYTE      EQU     0002h
MCPX_CONTROL_CYCLE_READ_WRITE_WORD      EQU     0003h
MCPX_CONTROL_HOST_START                 EQU     0008h

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; NTSTATUS
; BldrReadSMBusValue(
;     IN UCHAR SlaveAddress,
;     IN UCHAR CommandCode,
;     IN BOOLEAN ReadWordValue,
;     OUT UCHAR *DataValue
;     )
;
; Routine Description:
;
;     This routine submits a "read byte" or "read word" transaction over SMBus.
;
; Arguments:
;
;     SlaveAddress - Specifies the slave address of the SMBus device to access.
;
;     CommandCode - Specifies the command field to pass during as part of the
;         host cycle.
;
;     ReadWordValue - Specifies TRUE if 16-bits should be read, else FALSE if
;         8-bits should be read.
;
;     DataValue - Specifies the location of the buffer to receive the data read
;         from the SMBus.
;
; Return Value:
;
;     Status of operation.
;
;--
cPublicProc _BldrReadSMBusValue, 4

RsmbSlaveAddress    EQU     4
RsmbCommandCode     EQU     8
RsmbReadWordValue   EQU     12
RsmbDataValue       EQU     16


;
; Set the host address register.
;

rsmb10: xor     eax, eax                        ; eliminate partial stall
        mov     al, BYTE PTR [esp+RsmbSlaveAddress]
        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER
        or      al, 1                           ; force a read cycle
        out     dx, al

;
; Set the host command register.
;

        mov     al, BYTE PTR [esp+RsmbCommandCode]
        add     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_ADDRESS_REGISTER
        out     dx, al

;
; Write the current contents of the status register out to itself in order to
; clear the register.
;

        sub     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        in      ax, dx
        out     dx, ax

;
; Initiate the read transaction.
;

        add     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        mov     al, MCPX_CONTROL_HOST_START + MCPX_CONTROL_CYCLE_READ_WRITE_BYTE
        cmp     BYTE PTR [esp+RsmbReadWordValue], 0
        je      rsmb15
        inc     al                              ; select the read word cycle
rsmb15: out     dx, al

;
; Spin until the host controller indicates that its not busy.
;

        sub     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
rsmb20: in      al, dx
        test    al, MCPX_STATUS_HOST_BUSY
        jnz     rsmb20

;
; Check if there was a collision on the SMBus.  If so, retry the operation.
;

        test    al, MCPX_STATUS_COLLISION
        jnz     rsmb10

;
; Check if the transaction timed out.
;

        mov     edx, STATUS_IO_TIMEOUT
        test    al, MCPX_STATUS_TIMEOUT_ERROR
        jnz     rsmb30

;
; Check if the transaction caused a protocol error.
;

        mov     edx, STATUS_DEVICE_PROTOCOL_ERROR
        test    al, MCPX_STATUS_PROTOCOL_ERROR
        jnz     rsmb30

;
; Check if the transaction completed successfully.
;

        mov     edx, STATUS_IO_DEVICE_ERROR
        test    al, MCPX_STATUS_HOST_CYCLE_COMPLETE
        jz      rsmb30

;
; Read the host data register and write the contents back to the user's buffer
; and return STATUS_SUCCESS;
;

        xor     eax, eax
        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER
        in      ax, dx
        cmp     BYTE PTR [esp+RsmbReadWordValue], 0
        jne     rsmb25
        xor     ah, ah                          ; only return eight bits of data
rsmb25: mov     edx, DWORD PTR [esp+RsmbDataValue]
        mov     DWORD PTR [edx], eax
        xor     edx, edx                        ; edx = STATUS_SUCCESS

rsmb30:
        mov     eax, edx
        
        stdRET  _BldrReadSMBusValue

stdENDP _BldrReadSMBusValue

;++
;
; NTSTATUS
; BldrWriteSMBusByte(
;     IN UCHAR SlaveAddress,
;     IN UCHAR CommandCode,
;     IN BOOLEAN WriteWordValue,
;     IN ULONG DataValue
;     )
;
; Routine Description:
;
;     This routine submits a "write byte" or "write word" transaction over
;     SMBus.
;
; Arguments:
;
;     SlaveAddress - Specifies the slave address of the SMBus device to access.
;
;     CommandCode - Specifies the command field to pass during as part of the
;         host cycle.
;
;     WriteWordValue - Specifies TRUE if 16-bits should be written, else FALSE
;         if 8-bits should be written.
;
;     DataValue - Specifies the data value to transmit over SMBus.
;
; Return Value:
;
;     Status of operation.
;
;--
cPublicProc _BldrWriteSMBusValue, 4

WsmbSlaveAddress    EQU     4
WsmbCommandCode     EQU     8
WsmbWriteWordValue  EQU     12
WsmbDataValue       EQU     16


;
; Set the host address register.
;

wsmb10: xor     eax, eax                        ; eliminate partial stall
        mov     al, BYTE PTR [esp+WsmbSlaveAddress]
        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER
        and     al, NOT 1                       ; force a write cycle
        out     dx, al

;
; Set the host command register.
;

        mov     al, BYTE PTR [esp+WsmbCommandCode]
        add     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_ADDRESS_REGISTER
        out     dx, al

;
; Set the host data register.
;

        mov     eax, DWORD PTR [esp+WsmbDataValue]
        sub     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_DATA_REGISTER
        out     dx, ax

;
; Write the current contents of the status register out to itself in order to
; clear the register.
;

        sub     edx, MCPX_SMBUS_HOST_DATA_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        in      ax, dx
        out     dx, ax

;
; Initiate the write transaction.
;

        add     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        mov     al, MCPX_CONTROL_HOST_START + MCPX_CONTROL_CYCLE_READ_WRITE_BYTE
        cmp     BYTE PTR [esp+WsmbWriteWordValue], 0
        je      wsmb15
        inc     al                              ; select the read word cycle
wsmb15: out     dx, al

;
; Spin until the host controller indicates that its not busy.
;

        sub     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
wsmb20: in      al, dx
        test    al, MCPX_STATUS_HOST_BUSY
        jnz     wsmb20

;
; Check if there was a collision on the SMBus.  If so, retry the operation.
;

        test    al, MCPX_STATUS_COLLISION
        jnz     wsmb10

;
; Check if the transaction timed out.
;

        mov     edx, STATUS_IO_TIMEOUT
        test    al, MCPX_STATUS_TIMEOUT_ERROR
        jnz     wsmb30

;
; Check if the transaction caused a protocol error.
;

        mov     edx, STATUS_DEVICE_PROTOCOL_ERROR
        test    al, MCPX_STATUS_PROTOCOL_ERROR
        jnz     wsmb30

;
; Check if the transaction completed successfully.
;

        test    al, MCPX_STATUS_HOST_CYCLE_COMPLETE
        mov     edx, STATUS_IO_DEVICE_ERROR
        jz      wsmb30

;
; The write completed successfully, so return STATUS_SUCCESS.
;

        xor     edx, edx                        ; edx = STATUS_SUCCESS

wsmb30:
        mov     eax, edx
        
        stdRET  _BldrWriteSMBusValue

stdENDP _BldrWriteSMBusValue

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\romcpy.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    romcpy.c

Abstract:

    This module implements code to uncompress, copy, and check Xbox ROM

--*/

#include "bldr32.h"
#include <ldi.h>
#include <bldr.h>
#include <sha.h>
#include <rc4.h>

//
// Local support
//

BOOLEAN
BldrDecompress(
    IN  ULONG FromAddress,
    IN  ULONG ToAddress,
    IN  ULONG UncompressedSize
    );

MI_MEMORY
DIAMONDAPI
BldrAlloc(
    ULONG NumberOfBytes
    );

VOID
DIAMONDAPI
BldrFree(
    MI_MEMORY pointer
    );

//
// Location of the topmost byte, not inclusive, of the ROM.
//
ULONG BldrTopOfROMAddress = 0;

//
// Number of bytes that have been allocated for LZX decompression.  Used to mark
// the top of the heap.
//
ULONG BldrNumberOfBytesAllocated;

VOID
BldrCopyROMToRAM(
    IN const UCHAR* DecryptionKey
    )
/*++

Routine Description:

    Decrypts and decompresses kernel image from ROM to the RAM.  

Arguments:

    DecryptionKey - Key used to decrypt the kernel image

Return Value:

    None.

--*/
{
    ULONG BldrAddress;
    PBOOTLDRPARAM BootLdrParam;
    PXBOOT_PARAM BootParam;
    ULONG CompressedKernelAddress;
    ULONG UncompressedKernelDataAddress;
#ifdef MCP_B02XM3
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    ULONG InitTableAddress;
#endif
    PUCHAR KernelBuffer;

    //
    // Start address for the boot loader image
    //
    BldrAddress = 0x80000000 + BLDR_RELOCATED_ORIGIN;

    //
    // Calculate a pointer to the boot parameters stored at the begining of
    // of the boot loader image eg command line.  In case of ROM, entire image
    // including the parameter structure is decrypted so its safe to use
    // the command line which will normally be empty.
    //
    BootLdrParam = (PBOOTLDRPARAM)BldrAddress;

    //
    // Boot param structure is at the end of the boot loader block
    //
    BootParam = (PXBOOT_PARAM)(BldrAddress + BLDR_BLOCK_SIZE - sizeof(XBOOT_PARAM));

    //
    // Compute the address of the uncompressed kernel data block
    //
    UncompressedKernelDataAddress = 0 - ROM_DEC_SIZE -
        BLDR_BLOCK_SIZE - BootParam->UncompressedKernelDataSize;

    //
    // Compute the address of the compressed kernel image
    //
    CompressedKernelAddress = UncompressedKernelDataAddress -
        BootParam->CompressedKernelSize;

#ifdef MCP_B02XM3

    //
    // Calculate SHA1 digest for the compressed kernel image and uncompressed
    // kernel data block.
    //
    // Compute the address of the init table.  The ROM image is aliased
    // through out the top 16MB of address space.  For a 1MB image, it will
    // be aliased 16 times.  We use the top 1MB alias and the address mapped
    // in startup.asm.  This should work fine for 512K or 256K but will not
    // work for parts larger than 1MB.
    //
    InitTableAddress = 0UL - 0x100000;

    BldrPrint(("Bldr: Init Table=%08x, Version=%x", InitTableAddress, 
        *((PUCHAR)(InitTableAddress + 0x78))));

    //
    // Calculate a SHA1 digest with the following ROM components
    //     1. Size and contents of compressed and encrypted kernel in ROM
    //     2. Size and contents of uncompressed data
    //     3. Size and contents of init table
    //
    // Note: We calculate the digests directly from ROM rather than 
    // depending on the contents of RAM at this point
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)DecryptionKey, 16);
    A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->CompressedKernelSize, sizeof(ULONG));
    A_SHAUpdate(&SHAHash, (PVOID)CompressedKernelAddress, BootParam->CompressedKernelSize);
    
    A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->UncompressedKernelDataSize, sizeof(ULONG));
    A_SHAUpdate(&SHAHash, (PVOID)UncompressedKernelDataAddress, BootParam->UncompressedKernelDataSize);
    
#ifdef DEVKIT
    //
    // Hack to allow manual editing of the init table.  For devkit systems, if
    // the InitTableSize is 0, we skip calculating the digest for the init table
    // This can be initiatiated by ROMBLD's /HACKINITTABLE option
    //
    if (BootParam->InitTableSize != 0) {
        A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->InitTableSize, sizeof(ULONG));
        A_SHAUpdate(&SHAHash, (PVOID)InitTableAddress, BootParam->InitTableSize);
    }

#else
    
    A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->InitTableSize, sizeof(ULONG));
    A_SHAUpdate(&SHAHash, (PVOID)InitTableAddress, BootParam->InitTableSize);

#endif

    A_SHAFinal(&SHAHash, SHADigest);
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)DecryptionKey, 16);
    A_SHAUpdate(&SHAHash, SHADigest, sizeof SHADigest);
    A_SHAFinal(&SHAHash, SHADigest);

    //
    // Compare the calculated digest with the digest in the boot param
    //
    if (memcmp(SHADigest, BootParam->MainRomDigest, sizeof(SHADigest)) != 0) {
        BldrPrint(("Bldr: ROM digests do not match"));

        BldrShutdownSystem();
    }

#endif // MCP_B02XM3

    //
    // If we got here, the ROM image is OK to decrypt.  Allocate enough space
    // so we can copy the compessed encrypted kernel image to RAM.  We don't have to
    // worry about freeing this memory.
    //
    KernelBuffer = (PUCHAR)BldrAlloc(BootParam->CompressedKernelSize);

    //
    // Copy the compress encrypted kernel image from ROM to RAM
    //
    BldrPrint(("Bldr: Copying from %08x to %08x", CompressedKernelAddress, KernelBuffer));
    memcpy(KernelBuffer, (PUCHAR)CompressedKernelAddress, BootParam->CompressedKernelSize);

    //
    // Decrypt the RAM kernel buffer in place
    //
    BldrEncDec(KernelBuffer, BootParam->CompressedKernelSize, DecryptionKey, 16);

    //
    // Decompress the decrypted RAM kernel buffer to the location kernel image
    // needs to run from
    //
    BldrDecompress((ULONG_PTR)KernelBuffer, (ULONG_PTR)PsNtosImageBase,
        BootParam->CompressedKernelSize);

    //
    // Fixup the pointer to the uncompressed .data with the actual load address
    // of the ROM.  If the ROM is loaded at the top of memory, then this doesn't
    // affect the pointer.
    //
    ((PXDATA_SECTION_HEADER)(((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2))->PointerToRawData +=
        BldrTopOfROMAddress;
}

MI_MEMORY
DIAMONDAPI
BldrAlloc(
    ULONG NumberOfBytes
    )
/*++

Routine Description:

    Simple memory allocation used for limited known allocation

Arguments:

Return Value:

    A pointer to where the memory was allocated

--*/
{
    PVOID BaseAddress;

    BaseAddress = (PVOID)(0x80000000 + BLDR_RELOCATED_ORIGIN + BLDR_BLOCK_SIZE +
        BldrNumberOfBytesAllocated);

    BldrNumberOfBytesAllocated += NumberOfBytes;

    BldrPrint(("Bldr: Allocate %d bytes at %x", NumberOfBytes, BaseAddress));

    return BaseAddress;
}

VOID
DIAMONDAPI
BldrFree(
    MI_MEMORY pointer
    )
{
    // we don't need to free the memory
}

BOOLEAN
BldrDecompress(
    IN  ULONG FromAddress,
    IN  ULONG ToAddress,
    IN  ULONG UncompressedSize
    )
{
    PLZXBOX_BLOCK Block;
    ULONG Source;
    ULONG Dest;
    UINT SourceSize;
    LZXDECOMPRESS Decomp;
    UINT DestSize;
    ULONG BytesDecompressed;
    LDI_CONTEXT_HANDLE Handle;
    BOOLEAN Success = FALSE;

    BldrPrint(("Bldr: Decompressing from=0x%08X to=0x%08X bytes=%d", 
        FromAddress, ToAddress, UncompressedSize));
    
    //
    // Initialize decompression engine
    //
    Decomp.fCPUtype = LDI_CPU_80386;
    Decomp.WindowSize = LZX_WINDOW_SIZE;

    SourceSize = LZX_CHUNK_SIZE;
    if (LDICreateDecompression(&SourceSize, &Decomp, BldrAlloc, BldrFree, &DestSize,
        &Handle, NULL,NULL,NULL,NULL,NULL) != MDI_ERROR_NO_ERROR) {
        
        BldrPrint(("Bldr: Failed to init decompression engine"));
        
        return Success;
    }

    Source = FromAddress;
    Dest = ToAddress;
    for (;;) {

        //
        // Read the compression block
        //
        Block = (PLZXBOX_BLOCK)Source;
        Source += sizeof(LZXBOX_BLOCK);

        //
        // Perform decompression
        //
        BytesDecompressed = Block->UncompressedSize;
        if (LDIDecompress(Handle, (PVOID)Source, Block->CompressedSize, (PVOID)Dest,
            &BytesDecompressed) != MDI_ERROR_NO_ERROR) {
            goto CleanupAndExit;
        }

        //
        // Advance the pointers
        //
        Source += Block->CompressedSize;
        Dest += Block->UncompressedSize;

        //
        // Check to see if we are done
        //
        if ((Source - FromAddress) >= UncompressedSize) {
            break;
        }
    }

    Success = TRUE;

CleanupAndExit:
    (VOID)LDIDestroyDecompression(Handle);

    BldrPrint(("Bldr: Decompression %s", (Success ? "successful" : "failed")));

    return Success;
}

VOID
BldrShutdownSystem(
    VOID
    )
/*++

Routine Description:

    Shutdown the system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BldrPrint(("Bldr: *** Shutdown occurred"));

#ifdef RETAILXM3
    //
    // Flat line the clocks
    //

    _outpd(PCI_TYPE1_ADDR_PORT, 0x8000036C);
    _outpd(PCI_TYPE1_DATA_PORT, 0x01000000);
    
#endif

    __asm {
        hlt
    }
}


VOID
BldrEncDec(
    IN  PUCHAR  MsgData,
    IN  ULONG   MsgDataLen,
    IN  const UCHAR* Key,
    IN  ULONG   KeyBytes
    )
/*++

Routine Description:

    Encrypt or decrypt the given data buffer in-place using RC4 which is symmetric algorithm.

Arguments:


Return Value:

    None

--*/
{
    struct RC4_KEYSTRUCT rc4KeyCtl;

    BldrPrint(("Bldr: Decrypting %d bytes at %x", MsgDataLen, MsgData));

    rc4_key(&rc4KeyCtl, (UINT)KeyBytes, (PUCHAR)Key);

    rc4(&rc4KeyCtl, (UINT)MsgDataLen, MsgData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\bldr32\i386\superio.asm ===
TITLE   "Memory Management Support Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     superio.asm
;
;  Abstract:
;
;     This module implements the routines to interact with the system super I/O
;     controller.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

;
; Define the ports used to interact with the super I/O controller.
;

SMC_CONFIG_PORT                     EQU     02Eh
SMC_INDEX_PORT                      EQU     02Fh
SMC_DATA_PORT                       EQU     02Fh

;
; Define the values to enter and exit the configuration mode of the super I/O
; controller.
;

SMC_ENTER_CONFIGURATION_MODE        EQU     055h
SMC_EXIT_CONFIGURATION_MODE         EQU     0AAh

;
; Define the logical device numbers.
;

SMC_FLOPPY_DRIVE_CONTROLLER         EQU     000h
SMC_PARALLEL_PORT                   EQU     003h
SMC_SERIAL_PORT_1                   EQU     004h
SMC_SERIAL_PORT_2                   EQU     005h
SMC_KEYBOARD                        EQU     007h
SMC_GAME_PORT                       EQU     009h
SMC_PME                             EQU     00Ah
SMC_MPU_401                         EQU     00Bh
SMC_USB_HUB                         EQU     00Ch

;
; Define the global configuration registers.
;

SMC_LOGICAL_DEVICE_NUMBER           EQU     007h

SMC_DEVICE_ACTIVATE                 EQU     030h
SMC_DEVICE_PRIMARY_ADDRESS_HIGH     EQU     060h
SMC_DEVICE_PRIMARY_ADDRESS_LOW      EQU     061h

;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; DbgInitializeSuperIo(
;     VOID
;     )
;
; Routine Description:
;
;     This function initializes the super I/O controller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _DbgInitializeSuperIo, 0

;
; Place the the super I/O controller in configuration mode.
;

        mov     edx, SMC_CONFIG_PORT
        mov     al, SMC_ENTER_CONFIGURATION_MODE
        out     dx, al
        IODelay

;
; Select the first serial I/O port for configuration.
;

        mov     al, SMC_LOGICAL_DEVICE_NUMBER
        out     dx, al
        IODelay
        inc     edx
        mov     al, SMC_SERIAL_PORT_1
        out     dx, al
        IODelay
        dec     edx

;
; Activate the first serial I/O port at a base address of 0x03F8.
;

        mov     al, SMC_DEVICE_ACTIVATE
        out     dx, al
        IODelay
        inc     edx
        mov     al, 1
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_HIGH
        out     dx, al
        IODelay
        inc     edx
        mov     al, 003h
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_LOW
        out     dx, al
        IODelay
        inc     edx
        mov     al, 0F8h
        out     dx, al
        IODelay
        dec     edx

;
; Take the the super I/O controller out of configuration mode.
;

        mov     al, SMC_EXIT_CONFIGURATION_MODE
        out     dx, al

        stdRET  _DbgInitializeSuperIo

stdENDP _DbgInitializeSuperIo

_TEXT  ends

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\preldr32\i386\superio.asm ===
TITLE   "Memory Management Support Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     superio.asm
;
;  Abstract:
;
;     This module implements the routines to interact with the system super I/O
;     controller.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

;
; Define the ports used to interact with the super I/O controller.
;

SMC_CONFIG_PORT                     EQU     02Eh
SMC_INDEX_PORT                      EQU     02Fh
SMC_DATA_PORT                       EQU     02Fh

;
; Define the values to enter and exit the configuration mode of the super I/O
; controller.
;

SMC_ENTER_CONFIGURATION_MODE        EQU     055h
SMC_EXIT_CONFIGURATION_MODE         EQU     0AAh

;
; Define the logical device numbers.
;

SMC_FLOPPY_DRIVE_CONTROLLER         EQU     000h
SMC_PARALLEL_PORT                   EQU     003h
SMC_SERIAL_PORT_1                   EQU     004h
SMC_SERIAL_PORT_2                   EQU     005h
SMC_KEYBOARD                        EQU     007h
SMC_GAME_PORT                       EQU     009h
SMC_PME                             EQU     00Ah
SMC_MPU_401                         EQU     00Bh
SMC_USB_HUB                         EQU     00Ch

;
; Define the global configuration registers.
;

SMC_LOGICAL_DEVICE_NUMBER           EQU     007h

SMC_DEVICE_ACTIVATE                 EQU     030h
SMC_DEVICE_PRIMARY_ADDRESS_HIGH     EQU     060h
SMC_DEVICE_PRIMARY_ADDRESS_LOW      EQU     061h

;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; DbgInitializeSuperIo(
;     VOID
;     )
;
; Routine Description:
;
;     This function initializes the super I/O controller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _DbgInitializeSuperIo, 0

;
; Place the the super I/O controller in configuration mode.
;

        mov     edx, SMC_CONFIG_PORT
        mov     al, SMC_ENTER_CONFIGURATION_MODE
        out     dx, al
        IODelay

;
; Select the first serial I/O port for configuration.
;

        mov     al, SMC_LOGICAL_DEVICE_NUMBER
        out     dx, al
        IODelay
        inc     edx
        mov     al, SMC_SERIAL_PORT_1
        out     dx, al
        IODelay
        dec     edx

;
; Activate the first serial I/O port at a base address of 0x03F8.
;

        mov     al, SMC_DEVICE_ACTIVATE
        out     dx, al
        IODelay
        inc     edx
        mov     al, 1
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_HIGH
        out     dx, al
        IODelay
        inc     edx
        mov     al, 003h
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_LOW
        out     dx, al
        IODelay
        inc     edx
        mov     al, 0F8h
        out     dx, al
        IODelay
        dec     edx

;
; Take the the super I/O controller out of configuration mode.
;

        mov     al, SMC_EXIT_CONFIGURATION_MODE
        out     dx, al

        stdRET  _DbgInitializeSuperIo

stdENDP _DbgInitializeSuperIo

_TEXT  ends

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\preldr32\makefile.inc ===
$(BASEDIR)\private\ntos\obj\i386\xpreldr.bin: obj\i386\preldr32.exe
    bldrbld -p obj\i386\preldr32.exe $(BASEDIR)\private\ntos\obj\i386\xpreldr.bin
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\preldr32\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements routines to assist debugging the boot loader.

--*/

#include <ntos.h>
#include <stdio.h>
#include <dos.h>

VOID
DbgInitializeSuperIo(
    VOID
    );

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

BOOLEAN DbgInitialized = FALSE;
USHORT DbgBaseAddress = 0x3F8;
ULONG DbgBaudRate = 19200;

VOID
DbgInitialize(
    VOID
    )
{
    ULONG DivisorLatch;

    DbgInitializeSuperIo();

    DivisorLatch = CLOCK_RATE / DbgBaudRate;

    _outp(DbgBaseAddress + COM_LCR, 0x83);
    _outp(DbgBaseAddress + COM_DLM, (UCHAR)(DivisorLatch >> 8));
    _outp(DbgBaseAddress + COM_DLL, (UCHAR)(DivisorLatch));
    _outp(DbgBaseAddress + COM_LCR, 0x03);

    _outp(DbgBaseAddress + COM_MCR, MC_DTRRTS);
    _outp(DbgBaseAddress + COM_IEN, 0);

    DbgInitialized = TRUE;
}

VOID
DbgPrintCharacter(
    IN UCHAR Character
    )
{
    while (!(_inp(DbgBaseAddress + COM_LSR) & COM_OUTRDY));

    _outp(DbgBaseAddress + COM_DAT, Character);
}

ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    int current;

    if (!DbgInitialized) {
        DbgInitialize();
    }

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    for (current = 0; current < cb; current++) {
        DbgPrintCharacter(Buffer[current]);
    }
    DbgPrintCharacter('\r');
    DbgPrintCharacter('\n');

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -Sa -Fl -c -omf -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $<

OBJ=obj\i386\romdec.obj

obj\i386\romdec.com: $(OBJ)

obj\i386\romdec.obj: i386\romdec.asm

obj\i386\romdec.com: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
obj\i386\romdec.com



<<
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\dostest\enckey.inc ===
; 
; the encryption key 
;
EncKey:
        DB 057h,042h,029h,00Ch,030h,01Eh,0D3h,001h
        DB 0B3h,0E5h,05Dh,028h,050h,031h,0E1h,0CEh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\preldr32\preldr32.c ===
/*
 *
 * preldr32.c
 *
 * Boot pre-loader
 *
 */

#include "ntos.h"
typedef ULONG DWORD, *PDWORD, *LPDWORD;
typedef UCHAR BYTE, *PBYTE, *LPBYTE;
typedef ULONG BOOL;
#define far
#include <xcrypt.h>
#include <sha.h>
#include <rsa.h>
#include <rc4.h>
#include <bldr.h>
#include <stdio.h>

BOOLEAN
VerifyDigest(
    PUCHAR PubKey,
    PUCHAR EncryptedDigest, 
    PUCHAR PlaintextDigest
);

VOID
DbgInitialize(
    VOID
    );

VOID
DbgPrintCharacter(
    UCHAR
    );

#ifndef MCP_XMODE3P
static UCHAR BldrEncKey[] =
{
    0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
    0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
};
#endif

// Public key matches the XBE public key

UCHAR EncryptedPubKey[] =
{
#ifdef RETAILPUBKEY
#else
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
#endif
};

/* We dole out RAM from below the relocated boot loader.  We'll overwrite this
 * when we decrypt the boot loader */
ULONG pbNextAlloc = BLDR_RELOCATED_ORIGIN;

PVOID RSA32Alloc(ULONG u1)
{
    /* Round up to 32 bytes */
    u1 = (u1 + 31) & ~31;
    pbNextAlloc -= u1;
    return (PVOID)pbNextAlloc;
}
    
VOID RSA32Free(PVOID pv) {}

typedef struct _PRELDR_FUNCS {
    void (*pfnSHAInit)(A_SHA_CTX *);
    void (*pfnSHAUpdate)(A_SHA_CTX *, unsigned char *, unsigned int);
    void (*pfnSHAFinal)(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);
    BOOLEAN (*pfnVerifyDigest)(PUCHAR, PUCHAR, PUCHAR);
} PRELDR_FUNCS, *PPRELDR_FUNCS;

PRELDR_FUNCS PreloaderFuncTable = {
    A_SHAInit,
    A_SHAUpdate,
    A_SHAFinal,
    VerifyDigest
};

//
// Reverse ASN.1 Encodings of possible hash identifiers.
//
static PBYTE shaEncodings[] = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" };

BOOLEAN VerifyDigest(PUCHAR PubKey, PUCHAR EncryptedDigest, PUCHAR PlaintextDigest)
{
    UCHAR Encrypt[264];
    UCHAR Decrypt[264];
    BYTE      rgbTmpHash[A_SHA_DIGEST_LEN];
    DWORD     i;
    DWORD     cb;
    BYTE*     pbStart;
    DWORD     cbTmp;
    BSAFE_PUB_KEY *pKey = (LPBSAFE_PUB_KEY)PubKey;

    /* We need a 264-byte work area, so copy the digest into it and fill out
     * with zeroes */
    memcpy(Encrypt, EncryptedDigest, 256);
    memset(Encrypt+256, 0, 8);
    if(!BSafeEncPublic(pKey, Encrypt, Decrypt))
        return FALSE;

    //
    // reverse the hash to match the signature.
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        rgbTmpHash[i] = PlaintextDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    //
    // see if it matches.
    //
    if (memcmp(rgbTmpHash, Decrypt, A_SHA_DIGEST_LEN)) {
        return FALSE;
    }

    cb = A_SHA_DIGEST_LEN;

    //
    // check for any signature type identifiers
    //
    for (i = 0; 0 != *shaEncodings[i]; i += 1) {
        pbStart = (LPBYTE)shaEncodings[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&Decrypt[cb], pbStart, cbTmp)) {
            // adjust the end of the hash data.
            cb += cbTmp;
            break;
        }
    }

    //
    // check to make sure the rest of the PKCS #1 padding is correct
    //

    if ((0x00 != Decrypt[cb]) || (0x00 != Decrypt[pKey->datalen]) ||
         (0x1 != Decrypt[pKey->datalen - 1])) {
        return FALSE;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++) {
        if (0xff != Decrypt[i]) {
            return FALSE;
        }
    }

    return TRUE;
}

ULONG PreloaderStartup2(PUCHAR DecryptAddress)
{
    struct RC4_KEYSTRUCT RC4KeyStruct;
    PUCHAR EncBldr;
    ULONG EntryAddress;
    UCHAR Digest[XC_DIGEST_LEN];
    UCHAR PubKey[sizeof EncryptedPubKey];
    A_SHA_CTX SHAHash;
    PUCHAR SignTop;
    PUCHAR Signature;
    PUCHAR SignBase;
    PUCHAR InitTop;
    PUCHAR KernelBase;
    PULONG ROMRegions;
    const PUCHAR SBKey = (PUCHAR)(0LU - ROMDEC_N);
#ifdef MCP_XMODE3P
    int i;
    UCHAR EncKey[XC_DIGEST_LEN];
#endif

    /* The keyset we have is encrypted.  We decrypt it using the SB key */
    rc4_key(&RC4KeyStruct, 12, SBKey);
    memcpy(PubKey, EncryptedPubKey, sizeof EncryptedPubKey);
    rc4(&RC4KeyStruct, sizeof PubKey, PubKey);

    /* Find the pieces */
    SignTop = (PUCHAR)0 - ROM_DEC_SIZE;
    Signature = SignTop - 0x180;
    ROMRegions = (PULONG)(Signature + 0x100);

    /* We ask this ROM what its size is, but we only allow 256k - 1MB in
     * multiples of 256k */
    SignBase = (PUCHAR)ROMRegions[0];
    SignBase = (PUCHAR)(((ULONG)SignBase & 0xFFFC0000) | 0xFFF00000);
    InitTop = SignBase + ROMRegions[1];
    KernelBase = (PUCHAR)ROMRegions[2];

    /* Do some sanity checking on the ROM sizes so we don't try to hash all
     * 4 GB of address space */
    if(InitTop < SignBase || KernelBase < InitTop)
        return 0;
    
    /* SHA digest the ROM contents (top 128, then init table, then the rest)
     * and verify the signature */
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)ROMRegions, SignTop - (PUCHAR)ROMRegions);
    A_SHAUpdate(&SHAHash, SignBase, InitTop - SignBase);
    A_SHAUpdate(&SHAHash, KernelBase, Signature - KernelBase);
    A_SHAFinal(&SHAHash, Digest);

    if(!VerifyDigest(PubKey, Signature, Digest))
        return 0;

#if 0
    PULONG pdwTimes = (PULONG)0x8F020;

    DbgInitialize();
    DbgPrint("Got to preldr!\n");

    DbgPrint("Before times: %08X %08X\n", pdwTimes[0], pdwTimes[1]);
    DbgPrint("After times: %08X %08X\n", pdwTimes[2], pdwTimes[3]);
#endif

    /* Now we decrypt the boot loader */

#ifdef MCP_XMODE3P
    /* Build the bldr key */
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, SBKey, 16);
    A_SHAUpdate(&SHAHash, (PUCHAR)(0LU - ROM_DEC_SIZE - 16), 16);
    for(i = 0; i < 16; ++i)
        EncKey[i] = SBKey[i] ^ 0x5C;
    A_SHAUpdate(&SHAHash, EncKey, 16);
    A_SHAFinal(&SHAHash, EncKey);
    rc4_key(&RC4KeyStruct, sizeof EncKey, EncKey);
    memset(EncKey, 0, sizeof EncKey);
#else
    rc4_key(&RC4KeyStruct, sizeof BldrEncKey, BldrEncKey);
#endif

    EncBldr = (PUCHAR)0xFFFFFE00 - BLDR_BLOCK_SIZE;
    memcpy(DecryptAddress, EncBldr, BLDR_BLOCK_SIZE);
    rc4(&RC4KeyStruct, BLDR_BLOCK_SIZE, DecryptAddress);
    
    EntryAddress = ((PULONG)(DecryptAddress + BLDR_BLOCK_SIZE -
        PRELDR_BLOCK_SIZE))[-2];
    return (ULONG)DecryptAddress + EntryAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\preldr32\i386\startup.asm ===
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     startup.asm
;
;  Abstract:
;
;     This module implements the entry point for the 32-bit boot preloader code.
;
;  Environment:
;
;     32-bit protected mode.
;
;--

        .586p

        INCLUDE bldr.inc
        INCLUDE ks386.inc

        EXTERN  _PreloaderStartup2@4:NEAR
        EXTERN  _PreloaderFuncTable:DWORD
        EXTERN  _EncryptedPubKey:DWORD

_TEXT   SEGMENT PARA USE32 PUBLIC 'CODE'

        ASSUME  DS:_TEXT, ES:_TEXT, SS:_TEXT, FS:NOTHING, GS:NOTHING

;
; PreloaderStartup
;
; Entry point for the 32-bit boot preloader.  We don't do much work here; we
; inherit the cache policies that the romdec set up, and we set up just enough
; register and segment state for code to actually run.
;
; The entry point has to be preceded by a dword which indicates where the
; SHA function table lives.  This is so bldrbld can mark it somewhere where
; the bldr can find it.  The dword before that is the location of the public
; key.
;
;
        PUBLIC  _PreloaderStartup
        dd      _EncryptedPubKey
        dd      _PreloaderFuncTable
_PreloaderStartup PROC

        mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax
        mov     esp, ROMDEC_STACK

        xor     eax, eax
        mov     fs, eax
        mov     gs, eax

;
; we should really set up the GDT here as well so we can unmap the SB ROM,
; but we'll put that off to the bldr for now
;

;
; Figure out where we're going to decrypt the boot loader to
;

        mov     esi, BLDR_RELOCATED_ORIGIN - ROMLDR_SIZE

;
; Call off to the loader code, which will return with the actual address
; to call off to, and then go to the final destination.  We'll load ebp with
; the decrypt address so it can find itself
;
        push    esi
        call    _PreloaderStartup2@4
        test    eax, eax
        jz      @F
        mov     ebp, esi
        jmp     eax

;
; If the load failed, we stop the clocks
; 
@@:     mov     edx, 0cf8h
        mov     eax, 08000036ch
        out     dx, eax
        add     edx, 4
        mov     eax, 01000000h
        out     dx, eax
        cli
        hlt

_PreloaderStartup ENDP

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\decrypt.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Portions Copyright (C) 1987 RSA Data Security, Inc. Created 1987.
;    This is an unpublished work protected as such under copyright law.
;    This work contains proprietary, confidential, and trade secret information
;    of RSA Data Security, Inc.  Use, disclosure, or reproduction without the
;    express written authorization of RSA Data Security, Inc., is prohibited.
;
; Module Name:
;
;    decrypt.asm
;
; Abstract:
;
;    The module decrypts the ROM loader
;
;    This module implements the RSA Data Security RC4 encryption algorithm.
;
; Author:
;
;    Yasser Asmi (yasmi)  7-Jun-2000
;
; Environment:
;
;    Real Address Mode
;
;--

; ==========================================================================

.586p

BOOT_CODE_ORIGIN  EQU    0FE00h          ; start of the code

ROMLDR_SIZE       EQU    6000h           ; size of the rom loader (must match BLDR_BLOCK_SIZE)

ENC_BUF_SIZE      EQU    ROMLDR_SIZE

ENC_INPUT_OFFSET  EQU    (BOOT_CODE_ORIGIN - ROMLDR_SIZE)

ENC_OUTPUT_OFFSET EQU    0

; ==========================================================================


; temp EQUs will be replaced by include files
BLDR_CODE         EQU    90000h
CR0_CD            EQU    040000000H
CR0_NW            EQU    020000000H


;
; For now, the boot loader will be loaded at 9000:0000.
;
BLDRTEXT SEGMENT USE16 AT (BLDR_CODE SHR 4)

        ORG     0h
Bldr16Startup   LABEL BYTE

BLDRTEXT ENDS



STACKSEG SEGMENT USE16 AT 8000h

        ORG     0FFFEh
StackStartup    LABEL BYTE

STACKSEG ENDS







_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE' 
        ASSUME  CS:_TEXT, DS:NOTHING, SS:NOTHING, ES:NOTHING


        PUBLIC Start

        ORG BOOT_CODE_ORIGIN

Start:
        cld

; 
; enable processor cache
;
        mov     eax, cr0
        and     eax, NOT (CR0_NW OR CR0_CD)
        mov     cr0, eax  


; INTEL 440BX

; initialize DRAM using SDROM Control Register  
;

        ; setup PCI cycle to 76h
        mov     eax, 080000074h
        mov     dx, 0CFEh

        ; NOP Command Enable
        mov     al, 20h 
        out     dx, al

        mov     cx, -1
@@:     loop    @B

         ; All Banks Precharge Enable
        mov     al, 40h  
        out     dx, al

    	mov	    ebx, ds:[0]

        mov     cx, 1000h
@@:     loop    @B
        	

        ; CBR Enable Command
        mov     al, 80h   
        out     dx, al

        mov     cx, 8
CBRLoop:
    	mov	    ebx, ds:[0]
        loop    CBRLoop


        ; Mode Register Set Enable Command 
        mov     al, 60h   
        out     dx, al

    	;mov     di, 01F0h    ;MKF_CL2_ADDRESS_FOR_MAA;CL2 address for Rows 3:0
	    ;mov     di, 0FEA8h   ; MKF_CL2_ADDRESS_FOR_MAB; No, get correct address
    	;mov     di, 01D0h    ; CL3

        mov     di, 0DE28h
	    mov     ebx, ds:[di]


        ; Normal SDRAM Operation
        mov     al, 0h   
        out     dx, al

        mov     ebx, ds:[0] 

; 
; initialize chipset registers
;
        xor     si, si
        xor     bx, bx

RAMInitLoop:
        mov     bl, cs:BYTE PTR RAMInitData[si]
        cmp     bl, 0
        je      RAMInitDone
            
        mov     eax, 080000000h
        mov     al, bl
        mov     dx, 0CF8h
        inc     si
        out     dx, eax
        
        mov     dx, 0CFCh
        mov     ax, bx
        mov     eax, cs:DWORD PTR RAMInitData[si]
        out     dx, eax
        add     si, 4
        jmp     RAMInitLoop
                
RAMInitDone:


;
; 
        mov     ax, SEG STACKSEG          
        mov     ss, ax                           
        mov     sp, 0FFFEh

        mov     ax, SEG STACKSEG
        mov     ds, ax

        mov     ax, SEG BLDRTEXT
        mov     es, ax

        call    RC4Encrypt
        ;call    JustCopy


        jmp     FAR PTR Bldr16Startup
        
      
; ==========================================================================

EncKey           DB      'abcdefgh'       ; the encryption key 


;
; ram initialization data pairs (register offset byte, value dword)
;
RAMInitData:

        DB  050h
        DD  0FF00800Ch
        DB  054h
        DD  009000000h
        DB  058h
        DD  000111003h
        DB  05Ch
        DD  011110000h
        DB  060h
        DD  004040404h
        DB  064h
        DD  004040404h
        DB  068h
        DD  000000000h
        DB  06Ch
        DD  000000000h
        DB  074h
        DD  000000000h
        DB  078h
        DD  0381C0100h

        ; end of RAM init data
        DB  00h
    
; ==========================================================================



JustCopy PROC NEAR 

        xor     bx, bx                          ; clear loop counter
.REPEAT
        mov	    di, WORD PTR ENC_INPUT_OFFSET   ; get input buffer[k]
        mov	    cl, BYTE PTR cs:[bx + di]  

        mov     di, WORD PTR ENC_OUTPUT_OFFSET  ; write the result to the output buffer   
        mov     BYTE PTR es:[bx + di], cl

        inc     bx                              ; advance loop counter

.UNTIL (bx >= ENC_BUF_SIZE)

        ret     0

JustCopy ENDP




;++
;
; RC4Encrypt - This function carries performs decryption using the RC4 algorithm
;
; Arguments - 
;
; Returns
;
;--

RC4_TABLESIZE     EQU     256             ; RC4 state table size



RC4Encrypt PROC NEAR 

        LOCAL   statetable[RC4_TABLESIZE]:BYTE
        LOCAL   i:BYTE 
        LOCAL   j:BYTE
        LOCAL   k:BYTE
;
; RC4 key expansion functionality (rc4_key) 
;



;!  for (ii=0;ii<RC4_TABLESIZE;ii++)
;!    keystruct.S[ii] = (unsigned char)ii;
;!
;! bx => ii

        xor     bx, bx
        lea     di, statetable               
.REPEAT
        mov     [di + bx], bl                ; write out loop counter to statetable[ii]
        inc     bx 
.UNTIL (bx > RC4_TABLESIZE)


;!  j = k = (unsigned char) 0;
;!  for (ii=0;ii<RC4_TABLESIZE;ii++)
;!  {
;!    j = (unsigned char)((j + keystruct.S[ii] + enckey[k]) % RC4_TABLESIZE);
;!
;!    t = keystruct.S[ii];
;!    keystruct.S[ii] = keystruct.S[j];
;!    keystruct.S[j] = t;
;!
;!    k = (unsigned char) ((k+1) % RC4_KEYSIZE);
;!  }
;! 
;! bx => ii


        xor     bx, bx                          ; clear loop counter, j, k
        mov     j, bl
        mov     k, bl

.REPEAT
        xor     ch, ch
        
        lea     di, statetable                  ; calculate expression result in ax 
        xor     ah, ah        
        mov     al, j                           ;   add j
        mov     cl, [di + bx]                   ;   add statetable[ii]
        add     ax, cx

        xor     si, si                          ;   put value of k in cx and add it to si
        mov     cl, k
        add     si, cx 
        
        inc     cx                              ;   calculate new value of k
        and     cx, 7                           ;      (k + 1) % RC4_KEYSIZE(=8)
        mov     k, cl

        mov	    cl, cs:BYTE PTR EncKey[si]        ;   add enckey[k] to expression result
        add     ax, cx

        mov     cx, RC4_TABLESIZE               ; divide ax by tablesize and put remainer byte in j
        cwd 
        idiv    cx
        mov     j, dl

        lea     di, statetable                  ; swap bytes at ii and j in the keytable
        xor     ch, ch       
        mov     cl, j 
        add     di, cx 
        mov     al, [di]                        ;   statetable[j] => al
        
        lea     si, statetable                  ;   swap al with statetable[ii] 
        xchg    al, BYTE PTR [si + bx]
        mov     [di], al                        ;   write al back


        inc     bx                              ; advance loop counter
.UNTIL (bx >= RC4_TABLESIZE)



; RC4 encryption functionality (rc4) 
;


;!  for (k = 0; k < buffersize; k++)
;!  {
;!    i = (unsigned char) ((i + 1) % RC4_TABLESIZE);
;!    j = (unsigned char) ((j + keystruct.S[i]) % RC4_TABLESIZE);
;!
;!    t = keystruct.S[i];
;!    keystruct.S[i] = keystruct.S[j];
;!    keystruct.S[j] = t;
;!
;!    outbuffer[k] = inbuffer[k] ^ keystruct.S[(keystruct.S[i]+keystruct.S[j]) % RC4_TABLESIZE];
;!   }
;!
;! bx => k


        xor     bx, bx                          ; clear loop counter, i, j
        mov     i, bl
        mov     j, bl
.REPEAT

        xor     ah, ah                          ; calculate new value of i
        mov     al, i                           ;   i + 1
        inc     ax
        
        mov     cx, RC4_TABLESIZE               ;   divide by table size and put remained byte in i
        cwd 
        idiv    cx
        mov     i, dl

        xor     ah, ah                          ; calculate new value of j in ax
        mov     al, j

        lea     di, statetable                  ;   add statetable[i]                  
        xor     ch, ch         
        mov     cl, i
        add     di, cx
        add     ax, [di]

        mov     cx, RC4_TABLESIZE               ;   divide by table size and put remained byte in j
        cwd 
        idiv    cx
        mov     j, dl

        lea     di, statetable                  ; swap bytes at i and j in the statetable
        xor     ch, ch                          
        mov     cl, j 
        add     di, cx 
        mov     al, [di]                        ;   statetable[j] => al
        
        lea     si, statetable
        mov     cl, i
        add     si, cx  
        
        xchg    al, BYTE PTR [si]               ;   swap al with statetable[i] 
        mov     [di], al                        ;   write al back


        xor     ax, ax                          ; calculate expression result in ax

        xor     ch, ch                          ;   add previously obtained statetable[i] and statetable[i]
        mov     cl, [di]  
        add     ax, cx
        mov     cl, [si]  
        add     ax, cx

        mov     cx, RC4_TABLESIZE               ;   divide by table size
        cwd
        idiv    cx


        lea     di, statetable                  ; get the statetable[modresult]
        add     di, dx
        mov     al, BYTE PTR [di]      


        mov	    di, WORD PTR ENC_INPUT_OFFSET   ; get input buffer[k]
        mov	    cl, cs:BYTE PTR [bx + di]      
        xor     cl, al                          ; xor the two values

        mov     di, WORD PTR ENC_OUTPUT_OFFSET  ; write the result to the output buffer   
        mov     es:BYTE PTR [bx + di], cl

        inc     bx                              ; advance loop counter

.UNTIL (bx >= ENC_BUF_SIZE)


        ret     0

RC4Encrypt ENDP




; ==========================================================================
;
; Pad until processor startup location.  The code will be loaded at 512 bytes
; below the uppermost memory location.  The processor starts execution at 16
; bytes below the uppermost memory location.  If the above code takes less than
; 512-16 bytes, then we want to put padding of appropriate number of bytes
; so that we can put a jmp to our start of code at the right place

PadLabel:

        PadSize = (200h - 10h - (PadLabel - Start))
        
        ;db      PadSize     DUP(90H)                ; 90h=NOP
        db      11h     DUP(90H)                ; 90h=NOP

ProcessorInit:

        jmp     Start                    ; jump to the start of code
        
        REPT 13                                 ; pad with nop to complete 512 bytes
            nop
        ENDM

; ==========================================================================


_TEXT   ENDS



        END      Start
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\dostest\dostest.asm ===
.586p

ENC_BUF_SIZE      EQU    6000h


ORIGIN            EQU    100h
                

; ==========================================================================

_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE'
        ASSUME  CS:_TEXT, DS:_TEXT, SS:_TEXT, ES:_TEXT
        ORG ORIGIN


        PUBLIC Start

Start:
        mov     sp, OFFSET StackBase

;
; open input file
;
        mov     ax, 3D00h
        lea     dx, InFileName
        int     21h
        mov     [FileHandle], ax

;
; read input file
;
        mov     ah, 3Fh
        mov     bx, [FileHandle]
        mov     cx, ENC_BUF_SIZE
        lea     dx, InBuffer
        int     21h

;
; close input file
;
        mov     ah, 3Eh        
        mov     bx, [FileHandle]
        int     21h


; ==========================================================================
;
; encrypt the buffer
;        
        mov     ax, ds
        mov     es, ax
          
        call    ZTimerOn
 
        call    RC4Encrypt

        call    ZTimerOff
        call	ZTimerReport


 
; ==========================================================================

;
; create output file
;
        mov     ah, 3Ch
        mov     cx, 0
        lea     dx, OutFileName
        int     21h

;
; open output file
;
        mov     ax, 3D01h
        lea     dx, OutFileName
        int     21h
        mov     [FileHandle], ax

;
; write output file
;
        mov     ah, 40h
        mov     bx, [FileHandle]
        mov     cx, ENC_BUF_SIZE
        lea     dx, OutBuffer
        int     21h
;
; close output file
;
        mov     ah, 3Eh        
        mov     bx, [FileHandle]
        int     21h


;
; DOS Exit 
;
Exit:
        mov     ah, 04Ch
        mov     al, 0
        int     21h


;
; encryption key
;
INCLUDE ENCKEY.INC



INCLUDE ..\I386\ENCRYPT.INC

INCLUDE ..\I386\ZENTIME.INC


_rc4KeyCtl  db 258 dup(?)


InFileName      db "in.bin", 0
FileHandle      dw -1

OutFileName     db "out.bin", 0
OutFileHandle   dw -1


        ALIGN   2

StackLimit      db 1024 dup (?)
StackBase       EQU $

ENC_INPUT_OFFSET  EQU    $
InBuffer        db  ENC_BUF_SIZE    DUP(0)
        
ENC_OUTPUT_OFFSET EQU    $
OutBuffer       db  ENC_BUF_SIZE    DUP(0)



_TEXT   ENDS
 
        END      Start
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\i386\enckey.inc ===
; 
; the encryption key 
;
EncKey:
        DB 057h,042h,029h,00Ch,030h,01Eh,0D3h,001h
        DB 0B3h,0E5h,05Dh,028h,050h,031h,0E1h,0CEh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\dostest\enc\enc.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    rombld.cpp

Abstract:


--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <xcrypt.h>
#include <bldr.h>


static BYTE EncKey[] = 

    {
           0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
           0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
    };




void
BuildFiles(
    PBYTE pData,
    DWORD dwDataSize
    )
{

    char szOrgFile[MAX_PATH];
    char szEncFile[MAX_PATH];
    HANDLE hWriteFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    PBYTE pEncBuffer = NULL;
    DWORD dwEncBufSize;
    DWORD dwFileNum = 0;
    PBYTE p = pData;
    DWORD dwLeft = dwDataSize;
    DWORD dwCopySize;

    //
    // allocate buffer for encryption
    //
    dwEncBufSize = BLDR_BLOCK_SIZE;
    pEncBuffer = (PBYTE)malloc(dwEncBufSize);


    printf("File size set to boot loader filesize (%d)\n", BLDR_BLOCK_SIZE);

    for (;;)
    {

        sprintf(szOrgFile, "%d.ORG", dwFileNum);
        sprintf(szEncFile, "%d.ENC", dwFileNum);
        dwFileNum++;

        printf("Creating %s and %s files\n", szOrgFile, szEncFile);


        dwCopySize = BLDR_BLOCK_SIZE;
        if (dwCopySize >= dwLeft)
        {
            dwCopySize = dwLeft;
            dwLeft = 0;
            memset(pEncBuffer, 0, dwEncBufSize);
        }
        else
        {
            dwLeft -= dwCopySize;
        }
        memcpy(pEncBuffer, p, dwCopySize);
        p += dwCopySize;


        hWriteFile = CreateFile(szOrgFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hWriteFile == INVALID_HANDLE_VALUE) {
            printf("Failed to open output file\n");
            goto Cleanup;
        }
        if (!WriteFile(hWriteFile, pEncBuffer, dwEncBufSize, &dwBytes, NULL))
        {
            printf("Failed to write to output file\n");
            goto Cleanup;
        }
        CloseHandle(hWriteFile);

        
        //
        // encrypt the buffer
        //
        XCSymmetricEncDec(pEncBuffer, dwEncBufSize, EncKey, 16);

        hWriteFile = CreateFile(szEncFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hWriteFile == INVALID_HANDLE_VALUE) {
            printf("Failed to open output file\n");
            goto Cleanup;
        }
        if (!WriteFile(hWriteFile, pEncBuffer, dwEncBufSize, &dwBytes, NULL))
        {
            printf("Failed to write to output file\n");
            goto Cleanup;
        }
        CloseHandle(hWriteFile);

        hWriteFile = INVALID_HANDLE_VALUE;

        if (dwLeft == 0)
        {
            break;
        }

    }
        

Cleanup:
    if (hWriteFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hWriteFile);
    }

    if (pEncBuffer != NULL)
    {
        free(pEncBuffer);
    }
 
}





extern "C"
int
_cdecl
main(
	int,
	char** argv
	)
{
	HANDLE hFile;
	DWORD dwBytes;
    DWORD dwSize;
    PBYTE p;

    hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize > 0)
        {
            p = (PBYTE)malloc(dwSize);
            if (p != NULL)
            {
                if (ReadFile(hFile, p, dwSize, &dwBytes, NULL))
                {
                    BuildFiles(p, dwSize);
                }
            }

            free(p);
        }
        CloseHandle(hFile);
    }

    return 0;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\i386\initcode.inc ===
; initialize DRAM using SDRAM Control Register  
;

        ; setup PCI cycle to 76h
        mov     eax, 080000074h
        mov     dx, 0CFEh

        ; NOP Command Enable
        mov     al, 20h 
        out     dx, al

        mov     cx, -1
@@:     loop    @B

         ; All Banks Precharge Enable
        mov     al, 40h  
        out     dx, al

    	mov	    ebx, ds:[0]

        mov     cx, 1000h
@@:     loop    @B
        	

        ; CBR Enable Command
        mov     al, 80h   
        out     dx, al

        mov     cx, 8
CBRLoop:
    	mov	    ebx, ds:[0]
        loop    CBRLoop


        ; Mode Register Set Enable Command 
        mov     al, 60h   
        out     dx, al

    	;mov     di, 01F0h    ;MKF_CL2_ADDRESS_FOR_MAA;CL2 address for Rows 3:0
	    ;mov     di, 0FEA8h   ; MKF_CL2_ADDRESS_FOR_MAB; No, get correct address
    	;mov     di, 01D0h    ; CL3

        mov     di, 0DE28h
	    mov     ebx, ds:[di]


        ; Normal SDRAM Operation
        mov     al, 0h   
        out     dx, al

        mov     ebx, ds:[0] 

; 
; initialize chipset registers
;
        xor     si, si
        xor     bx, bx

RAMInitLoop:
        mov     bl, cs:BYTE PTR RAMInitData[si]
        cmp     bl, 0
        je      RAMInitDone
            
        mov     eax, 080000000h
        mov     al, bl
        mov     dx, 0CF8h
        inc     si
        out     dx, eax
        
        mov     dx, 0CFCh
        mov     ax, bx
        mov     eax, cs:DWORD PTR RAMInitData[si]
        out     dx, eax
        add     si, 4
        jmp     RAMInitLoop
                
RAMInitDone:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\i386\encrypt.inc ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Portions Copyright (C) 1987 RSA Data Security, Inc. Created 1987.
;    This is an unpublished work protected as such under copyright law.
;    This work contains proprietary, confidential, and trade secret information
;    of RSA Data Security, Inc.  Use, disclosure, or reproduction without the
;    express written authorization of RSA Data Security, Inc., is prohibited.
;
; Abstract:
;
;    This module implements the RSA Data Security RC4 encryption algorithm.
;
;--


RC4_TABLESIZE     EQU     256             ; RC4 state table size



RC4Encrypt PROC NEAR

        LOCAL   statetable[RC4_TABLESIZE]:BYTE
        LOCAL   i:BYTE
        LOCAL   j:BYTE
        LOCAL   k:BYTE

;
; RC4 key expansion functionality (rc4_key)
;------------------------------------------

        lea     dx, statetable                  ; keep address of statetable in dx
        xor     ch, ch                          ; clear high byte of cx

;
; for (ii=0;ii<RC4_TABLESIZE;ii++)
;    keystruct.S[ii] = (unsigned char)ii;
; (bx => ii)
;
        xor     bx, bx
        mov     di, dx
.REPEAT
        mov     [di + bx], bl                   ; write out loop counter to statetable[ii]
        inc     bx
.UNTIL (bx > RC4_TABLESIZE)

;
; j = k = (unsigned char) 0;
; for (ii=0;ii<RC4_TABLESIZE;ii++) {
;    j = (unsigned char)((j + keystruct.S[ii] + enckey[k]) % RC4_TABLESIZE);
;
;    t = keystruct.S[ii];
;    keystruct.S[ii] = keystruct.S[j];
;    keystruct.S[j] = t;
;
;    k = (unsigned char) ((k+1) % RC4_KEYSIZE);
; }
; (bx => ii)
;
        xor     bx, bx                          ; clear loop counter, j, k
        xor     al, al                          ; keep j in al
        mov     k, bl

.REPEAT
        mov     di, dx                          ; calculate expression result in ax

        add     al, [di + bx]                   ; add statetable[ii]

        mov     cl, k
        mov     si, cx                          ; put value of k in si

        inc     cl                              ; calculate new value of k
        and     cl, 0Fh                         ; (k + 1) % RC4_KEYSIZE(=16)
        mov     k, cl

        add     al, cs:BYTE PTR EncKey[si]      ; add enckey[k] to expression result

        mov     di, dx                          ; swap bytes at ii and j in the keytable
        mov     cl, al                          ; word extend j to cx
        add     di, cx
        mov     cl, [di]                        ; statetable[j] => cl

        mov     si, dx                          ; swap ah with statetable[ii]
        mov     ah, [si + bx]
        mov     [si + bx], cl
        mov     [di], ah

        inc     bx                              ; advance loop counter
.UNTIL (bx >= RC4_TABLESIZE)


;
; RC4 encryption functionality (rc4)
;-----------------------------------

;
; for (k = 0; k < buffersize; k++) {
;    i = (unsigned char) ((i + 1) % RC4_TABLESIZE);
;    j = (unsigned char) ((j + keystruct.S[i]) % RC4_TABLESIZE);
;
;    t = keystruct.S[i];
;    keystruct.S[i] = keystruct.S[j];
;    keystruct.S[j] = t;
;
;    outbuffer[k] = inbuffer[k] ^ keystruct.S[(keystruct.S[i]+keystruct.S[j]) % RC4_TABLESIZE];
; }
; (bx => k)

        xor     bx, bx                          ; clear loop counter, i, j
        mov     i, bl
        mov     j, bl
.REPEAT

        inc     i                               ; calculate new value of i

        mov     di, dx                          ; add statetable[i]
        mov     cl, i
        add     di, cx
        mov     al, [di]
        add     j, al                           ; mod 256

        mov     di, dx                          ; swap bytes at i and j in the statetable
        mov     cl, j
        add     di, cx
        mov     al, [di]

        mov     si, dx
        mov     cl, i
        add     si, cx

        mov     ah, [si]                        ; swap al with statetable[i]
        mov     [si], al
        mov     [di], ah

        mov     cl, [di]                        ; add previously obtained statetable[i] and statetable[j] in ax
        mov     ax, cx
        add     al, [si]                        ; mod 256

        mov     di, dx                          ; get the statetable[modresult]
        add     di, ax

        mov     al, BYTE PTR [di]

IFDEF ENC_USE_FS_GS
        mov	    cl, fs:BYTE PTR [bx]
ELSE
        mov	    di, ENC_INPUT_OFFSET            ; get input buffer[k]
        mov	    cl, cs:BYTE PTR [bx + di]
ENDIF

        xor     cl, al                          ; xor the two values

IFDEF ENC_USE_FS_GS
        mov     gs:BYTE PTR [bx], cl
ELSE
        mov     di, ENC_OUTPUT_OFFSET           ; write the result to the output buffer
        mov     es:BYTE PTR [bx + di], cl
ENDIF

        inc     bx                              ; advance loop counter

.UNTIL (bx >= ENC_BUF_SIZE)

        ret

RC4Encrypt ENDP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\i386\initdata.inc ===
;
; ram initialization data pairs (register offset byte, value dword)
;
RAMInitData:

        DB  050h
        DD  0FF00800Ch
        DB  054h
        DD  009000000h
        DB  058h
        DD  000111003h
        DB  05Ch
        DD  011110000h
        DB  060h
        DD  004040404h
        DB  064h
        DD  004040404h
        DB  068h
        DD  000000000h
        DB  06Ch
        DD  000000000h
        DB  074h
        DD  000000000h
        DB  078h
        DD  0381C0100h

        ; end of RAM init data
        DB  00h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\i386\romdec.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    romdec.asm
;
; Abstract:
;
;    The module decrypts the ROM loader
;
; Environment:
;
;    Real Address Mode
;
;--

; ==========================================================================

        .586p

        INCLUDE bldr.inc


ENC_BUF_SIZE      EQU    ROMLDR_SIZE

ENC_INPUT_OFFSET  EQU    (BOOT_CODE_ORIGIN - ROMLDR_SIZE)

ENC_OUTPUT_OFFSET EQU    0

CR0_CD            EQU    040000000H

CR0_NW            EQU    020000000H

; ==========================================================================
;
; segment where bootloader code will be decrypted
;
BLDRTEXT SEGMENT USE16 AT (BLDR_CODE SHR 4)

        ORG     0h
Bldr16Startup   LABEL BYTE

BLDRTEXT ENDS


; ==========================================================================
;
; stack segment
;
STACKSEG SEGMENT USE16 AT 8000h

        ORG     0FFFEh
StackStartup    LABEL BYTE

STACKSEG ENDS



; ==========================================================================
;
; main segment
;
_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE' 
        ASSUME  CS:_TEXT, DS:NOTHING, SS:NOTHING, ES:NOTHING


        PUBLIC  Start

        ORG     BOOT_CODE_ORIGIN

Start:
;
; reset vector transfers the control here
;

        cld
; 
; enable processor cache
;
        mov     eax, cr0
        and     eax, NOT (CR0_NW OR CR0_CD)
        mov     cr0, eax  

;
; initialize chipset and DRAM
;
        INCLUDE INITCODE.INC


;
; setup segments
; 
        mov     ax, SEG STACKSEG          
        mov     ss, ax                           
        mov     sp, 0FFFEh

        mov     ax, SEG STACKSEG
        mov     ds, ax

        mov     ax, SEG BLDRTEXT
        mov     es, ax

;
; decrypt the boot loader
;
        call    RC4Encrypt


;
; check to see if the encryption was successful.  RC4 algorithm does not provide
; success information.  Therefore, we check for a known signature in the
; decrypted boot loader
;

        mov     eax, es:DWORD PTR [ROMLDR_SIZE - ROMLDR_BOOTPARAMSIZE]   
        cmp     eax, ROMLDR_SIGNATURE
        jz      JumpToBootLoader

Fail:
;
; ROM is not valid.  Shutdown by copying the shutdown sequence to RAM and executing it.  We
; cannot execute in SB ROM because after we turn of SB ROM, the CPU will continue execution
; in the main ROM.  
;
        
        mov     si, OFFSET TurnOffSbRom
        xor     di, di
        mov     cx, 22
ShutdownCopyLoop:
        mov     al, cs:BYTE PTR [si]                           
        mov     es:BYTE PTR [di], al
        inc     si
        inc     di
        loop    ShutdownCopyLoop

JumpToBootLoader:
;
; jump to the boot loader startup or in case of failure the shutdown sequence
;
        mov     si, OFFSET CmdLine
        jmp     FAR PTR Bldr16Startup
        
      
; ==========================================================================

;
; command line options to boot loader 
;
CmdLine     DB      0

;
; sequence of instructions to turn off SB ROM and halt
;
TurnOffSBRom:
          
;        mov     eax, 80000880h
;        mov     dx, 0CF8h
;        out     dx, eax
;        mov     dx, 0CFCh
;        mov     al, 2
;        out     dx, al
        hlt

;
; encryption key
;
        INCLUDE ENCKEY.INC

;
; chipset initialization related data
;
        INCLUDE INITDATA.INC


;
; encryption function
;
        INCLUDE ENCRYPT.INC

; ==========================================================================


;
; pad until processor startup location.  The code will be loaded at 512 bytes
; below the uppermost memory location.  The processor starts execution at 16
; bytes below the uppermost memory location.  If the above code takes less than
; 512-16 bytes, then we want to put padding of appropriate number of bytes
; so that we can put a jmp to our start of code at the right place

PadLabel:

;
; NOTE: following constant sets the number of bytes to be used for padding.  If
; the above code changes then the pad size must be adjusted.  We cannot use 
; this directly because of one-pass assembly.  However, if the number is not
; correct the following .ERRNZ condition will fail with A2045.  If you see the
; error during compilation, look at the .lst file and change PadSize value to
; the value reported for RequiredPadSize
;
        PadSize = 44h
        RequiredPadSize = (200h - 10h - (PadLabel - Start))

.ERRNZ (200h - 10h - (PadLabel - Start)) - PadSize


        db      PadSize     DUP(90H)                ; 90h=NOP

;
; this is where the processor will start executing code
;
ProcessorInit:
        jmp     Start                    ; jump to the start of code


;
; pad with nop to complete 512 bytes
;
        REPT 13
            nop
        ENDM

; ==========================================================================

_TEXT   ENDS

        END      Start
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\chipset.inc ===
;++
;
; Copyright (c) Microsoft Corporation
;
; Module Name:
;
;    chipset.inc
;
; Abstract:
;
;    This file contains defines that control which chipset romdec and
;    init table are built for
;
;--

IFNDEF RETAILXM3
;
; We want MCP_XMODE2 unless retail XM3 is being built
;
MCP_XMODE2 = 1

ENDIF

;
; Define the following, when building for MCP Rev B01 in XMODE3
; Otherwise, this should undefined
;
;MCP_REV_B01 = 1


IFDEF SYS_QT
;
; If we are building for QT which implies C03 (or higher), the following 
; should be defined For C02, it should not be defined
;
MCP_REV_C03 = 1

;
; If we are building for QT, we need to automatically define DVT6
;
SYS_DVT6 = 1

ENDIF

;
; If we are building retail, set the local retail define
;
IFDEF RETAILXM3

SYS_RETAIL = 1

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\bin\makefile.inc ===
$(BASEDIR)\private\ntos\obj\i386\romdec32.bin: ..\r16\obj\i386\rstartup.com ..\r32\obj\i386\romdec32.exe
    rdbld ..\r32\obj\i386\romdec32.exe ..\r16\obj\i386\rstartup.com $(BASEDIR)\private\ntos\obj\i386\romdec32.bin
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF


# Hack to get around a MP build problem where romdec32.exe isn't linked by
# the time the above build dependency rule is evaluated.
..\r32\obj\i386\romdec32.exe:
    sleep 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec\i386\zentime.inc ===
;
; *** Listing 3-1 ***
;
; The precision Zen timer (PZTIMER.ASM)
;
; Uses the 8253 timer to time the performance of code that takes
; less than about 54 milliseconds to execute, with a resolution
; of better than 10 microseconds.
;
; By Michael Abrash 
;
; Externally callable routines:
;
;  ZTimerOn: Starts the Zen timer, with interrupts disabled.
;
;  ZTimerOff: Stops the Zen timer, saves the timer count,
;	times the overhead code, and restores interrupts to the
;	state they were in when ZTimerOn was called.
;
;  ZTimerReport: Prints the net time that passed between starting
;	and stopping the timer.
;
; Note: If longer than about 54 ms passes between ZTimerOn and
;	ZTimerOff calls, the timer turns over and the count is
;	inaccurate. When this happens, an error message is displayed
;	instead of a count. The long-period Zen timer should be used
;	in such cases.
;
; Note: Interrupts *MUST* be left off between calls to ZTimerOn
;	and ZTimerOff for accurate timing and for detection of
;	timer overflow.
;
; Note: These routines can introduce slight inaccuracies into the
;	system clock count for each code section timed even if
;	timer 0 doesn't overflow. If timer 0 does overflow, the
;	system clock can become slow by virtually any amount of
;	time, since the system clock can't advance while the
;	precison timer is timing. Consequently, it's a good idea
;	to reboot at the end of each timing session. (The
;	battery-backed clock, if any, is not affected by the Zen
;	timer.)
;
; All registers, and all flags except the interrupt flag, are
; preserved by all routines. Interrupts are enabled and then disabled
; by ZTimerOn, and are restored by ZTimerOff to the state they were
; in when ZTimerOn was called.
;


;
; Base address of the 8253 timer chip.
;
BASE_8253		equ	40h
;
; The address of the timer 0 count registers in the 8253.
;
TIMER_0_8253		equ	BASE_8253 + 0
;
; The address of the mode register in the 8253.
;
MODE_8253		equ	BASE_8253 + 3
;
; The address of Operation Command Word 3 in the 8259 Programmable
; Interrupt Controller (PIC) (write only, and writable only when
; bit 4 of the byte written to this address is 0 and bit 3 is 1).
;
OCW3			equ	20h
;
; The address of the Interrupt Request register in the 8259 PIC
; (read only, and readable only when bit 1 of OCW3 = 1 and bit 0
; of OCW3 = 0).
;
IRR			equ	20h
;
; Macro to emulate a POPF instruction in order to fix the bug in some
; 80286 chips which allows interrupts to occur during a POPF even when
; interrupts remain disabled.
;
MPOPF macro 
	local	p1, p2
	jmp short p2
p1:	iret			;jump to pushed address & pop flags
p2:	push	cs		;construct far return address to
	call	p1		; the next instruction
	endm

;
; Macro to delay briefly to ensure that enough time has elapsed
; between successive I/O accesses so that the device being accessed
; can respond to both accesses even on a very fast PC.
;
DELAY	macro
	jmp	$+2
	jmp	$+2
	jmp	$+2
	endm

OriginalFlags		db	?	;storage for upper byte of
					; FLAGS register when
					; ZTimerOn called
TimedCount		dw	?	;timer 0 count when the timer
					; is stopped
ReferenceCount		dw	?	;number of counts required to
					; execute timer overhead code
OverflowFlag		db	?	;used to indicate whether the
					; timer overflowed during the
					; timing interval
;
; String printed to report results.
;
OutputStr	label	byte
		db	0dh, 0ah, 'Timed count: ', 5 dup (?)
ASCIICountEnd	label	byte
		db	' microseconds', 0dh, 0ah
		db	'$'
;
; String printed to report timer overflow.
;
OverflowStr	label	byte
	db	0dh, 0ah
	db	'****************************************************'
	db	0dh, 0ah
	db	'* The timer overflowed, so the interval timed was  *'
	db	0dh, 0ah
	db	'* too long for the precision timer to measure.     *'
	db	0dh, 0ah
	db	'* Please perform the timing test again with the    *'
	db	0dh, 0ah
	db	'* long-period timer.                               *'
	db	0dh, 0ah
	db	'****************************************************'
	db	0dh, 0ah
	db	'$'

;********************************************************************
;* Routine called to start timing.				    *
;********************************************************************

ZTimerOn	proc	near

;
; Save the context of the program being timed.
;
	push	ax
	pushf
	pop	ax			;get flags so we can keep
					; interrupts off when leaving
					; this routine
	mov	cs:[OriginalFlags],ah	;remember the state of the
					; Interrupt flag
	and	ah,0fdh 		;set pushed interrupt flag
					; to 0
	push	ax
;
; Turn on interrupts, so the timer interrupt can occur if it's
; pending.
;
	sti
;
; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause
; linear counting rather than count-by-two counting. Also
; leaves the 8253 waiting for the initial timer 0 count to
; be loaded.
;
	mov	al,00110100b		;mode 2
	out	MODE_8253,al
;
; Set the timer count to 0, so we know we won't get another
; timer interrupt right away.
; Note: this introduces an inaccuracy of up to 54 ms in the system
; clock count each time it is executed.
;
	DELAY
	sub	al,al
	out	TIMER_0_8253,al		;lsb
	DELAY
	out	TIMER_0_8253,al		;msb
;
; Wait before clearing interrupts to allow the interrupt generated
; when switching from mode 3 to mode 2 to be recognized. The delay
; must be at least 210 ns long to allow time for that interrupt to
; occur. Here, 10 jumps are used for the delay to ensure that the
; delay time will be more than long enough even on a very fast PC.
;
	rept 10
	jmp	$+2
	endm
;
; Disable interrupts to get an accurate count.
;
	cli
;
; Set the timer count to 0 again to start the timing interval.
;
	mov	al,00110100b		;set up to load initial
	out	MODE_8253,al		; timer count
	DELAY
	sub	al,al
	out	TIMER_0_8253,al		;load count lsb
	DELAY
	out	TIMER_0_8253,al		;load count msb
;
; Restore the context and return.
;
	MPOPF				;keeps interrupts off
	pop	ax
	ret

ZTimerOn	endp

;********************************************************************
;* Routine called to stop timing and get count.			    *
;********************************************************************

ZTimerOff proc	near

;
; Save the context of the program being timed.
;
	push	ax
	push	cx
	pushf
;
; Latch the count.
;
	mov	al,00000000b		;latch timer 0
	out	MODE_8253,al
;
; See if the timer has overflowed by checking the 8259 for a pending
; timer interrupt.
;
	mov	al,00001010b		;OCW3, set up to read
	out	OCW3,al			; Interrupt Request register
	DELAY
	in	al,IRR			;read Interrupt Request
					; register
	and	al,1			;set AL to 1 if IRQ0 (the
					; timer interrupt) is pending
	mov	cs:[OverflowFlag],al	;store the timer overflow
					; status
;
; Allow interrupts to happen again.
;
	sti
;
; Read out the count we latched earlier.
;
	in	al,TIMER_0_8253		;least significant byte
	DELAY
	mov	ah,al
	in	al,TIMER_0_8253		;most significant byte
	xchg	ah,al
	neg	ax			;convert from countdown
					; remaining to elapsed
					; count
	mov	cs:[TimedCount],ax
; Time a zero-length code fragment, to get a reference for how
; much overhead this routine has. Time it 16 times and average it,
; for accuracy, rounding the result.
;
	mov	cs:[ReferenceCount],0
	mov	cx,16
	cli				;interrupts off to allow a
					; precise reference count
RefLoop:
	call	ReferenceZTimerOn
	call	ReferenceZTimerOff
	loop	RefLoop
	sti
	add	cs:[ReferenceCount],8	;total + (0.5 * 16)
	mov	cl,4
	shr	cs:[ReferenceCount],cl	;(total) / 16 + 0.5
;
; Restore original interrupt state.
;
	pop	ax			;retrieve flags when called
	mov	ch,cs:[OriginalFlags]	;get back the original upper
					; byte of the FLAGS register
	and	ch,not 0fdh		;only care about original
					; interrupt flag...
	and	ah,0fdh			;...keep all other flags in
					; their current condition
	or	ah,ch			;make flags word with original
					; interrupt flag
	push	ax			;prepare flags to be popped
;
; Restore the context of the program being timed and return to it.
;
	MPOPF				;restore the flags with the
					; original interrupt state
	pop	cx
	pop	ax
	ret

ZTimerOff endp

;
; Called by ZTimerOff to start timer for overhead measurements.
;

ReferenceZTimerOn	proc	near
;
; Save the context of the program being timed.
;
	push	ax
	pushf		;interrupts are already off
;
; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause
; linear counting rather than count-by-two counting.
;
	mov	al,00110100b	;set up to load
	out	MODE_8253,al	; initial timer count
	DELAY
;
; Set the timer count to 0.
;
	sub	al,al
	out	TIMER_0_8253,al	;load count lsb
	DELAY
	out	TIMER_0_8253,al	;load count msb
;
; Restore the context of the program being timed and return to it.
;
	MPOPF
	pop	ax
	ret

ReferenceZTimerOn	endp

;
; Called by ZTimerOff to stop timer and add result to ReferenceCount
; for overhead measurements.
;

ReferenceZTimerOff proc	near
;
; Save the context of the program being timed.
;
	push	ax
	push	cx
	pushf
;
; Latch the count and read it.
;
	mov	al,00000000b		;latch timer 0
	out	MODE_8253,al
	DELAY
	in	al,TIMER_0_8253		;lsb
	DELAY
	mov	ah,al
	in	al,TIMER_0_8253		;msb
	xchg	ah,al
	neg	ax			;convert from countdown
					; remaining to amount
					; counted down
	add	cs:[ReferenceCount],ax
;
; Restore the context of the program being timed and return to it.
;
	MPOPF
	pop	cx
	pop	ax
	ret

ReferenceZTimerOff endp

;********************************************************************
;* Routine called to report timing results.			    *
;********************************************************************

ZTimerReport	proc	near

	pushf
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	ds
;
	push	cs	;DOS functions require that DS point
	pop	ds	; to text to be displayed on the screen
;
; Check for timer 0 overflow.
;
	cmp	[OverflowFlag],0
	jz	PrintGoodCount
	mov	dx,offset OverflowStr
	mov	ah,9
	int	21h
	jmp	short EndZTimerReport
;
; Convert net count to decimal ASCII in microseconds.
;
PrintGoodCount:
	mov	ax,[TimedCount]
	sub	ax,[ReferenceCount]
	mov	si,offset ASCIICountEnd - 1
;
; Convert count to microseconds by multiplying by .8381.
;
	mov	dx,8381
	mul	dx
	mov	bx,10000
	div	bx		;* .8381 = * 8381 / 10000
;
; Convert time in microseconds to 5 decimal ASCII digits.
;
	mov	bx,10
	mov	cx,5
CTSLoop:
	sub	dx,dx
	div	bx
	add	dl,'0'
	mov	[si],dl
	dec	si
	loop	CTSLoop
;
; Print the results.
;
	mov	ah,9
	mov	dx,offset OutputStr
	int	21h
;
EndZTimerReport:
	pop	ds
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	MPOPF
	ret

ZTimerReport	endp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\cr11init.inc ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    cr11init.inc
;
;  Abstract:
;
;    Crush11 initialization table
;
;    This module contains table of commands used by South Bridge to initialize
;    hardware and test memory during boot startup.  For definition of each
;    command, please see initcode.inc and command.inc
;--

        page    84,132

        .MODEL  compact
        .486p

DATA_TABLE_OFFSET  EQU 0FFFFFE00h

        INCLUDE command.inc

CODE    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:CODE, ES:NOTHING, SS:NOTHING
        ORG     0000H

IFDEF OLDNBDATA

;
; NB data for Crush 11 on the emulator
;

        dd      2B16D065h
        dd      (1 + (1 SHL 2))                 ; Intel
        dd      0
        dd      7 SHL 28
        dd      11 SHL 28
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0FFFFFF7Fh
        dd      0FFFFFFFFh
        dd      (28-11) dup (0h)
        dd      0Fh
        dd      00000000h                       ; Intel
        dd      0
        dd      0
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h

ELSE

IFDEF FIRST_TRY

;
; NB data for Crush 11 on the EVT boards
;

        db      065h, 0D0h, 016h, 02Bh          ; 2B16D065
        db      04Dh, 043h, 046h, 033h          ; 3346434D
        db      003h, 003h, 003h, 003h          ; 03030303
        db      00Eh, 015h, 01Ch, 01Ch          ; 1C1C150E
        db      003h, 015h, 000h, 000h          ; 00001503
        db      08Ah, 070h, 0E4h, 0A8h          ; A8E4708A
        db      030h, 002h, 0FDh, 045h          ; 45FD0230
        db      001h, 000h, 0E2h, 010h          ; 10E20001
        db      000h, 000h, 000h, 0F0h          ; F0000000
        dd      (55) dup (0FFFFFFFFh)           ; FFFFFFFF, ETC

ELSE

;
; NB data for Crush 11 on the EVT boards
;

        dd      2B16D065h
        dd      4444444Dh                       ; Intel
        dd      03030303h
        dd      15151515h
        dd      1503h
        dd      0A8E4708Ah
        dd      45FD0230h
        dd      10E20001h
        dd      0F0000000h
        dd      0FFFFFFFFh
        dd      0FFFFFFFFh
        dd      (28-11) dup (0h)                ; 4 DWORD follow to fill up to 128 bytes

;
; SB data for MCP1 on the EVT boards
;

        dd      0Fh
        dd      00000000h                       ; Intel
        dd      0                               ; pad for DWORD 30
        dd      0                               ; pad for DWORD 31 (32*4 = byte location 128)

;
; Force 256 byte alignment.
;

        db      (080h) dup (0)                  ; dup 0's into remaining 0x80/128 bytes

ENDIF   ; FIRST_TRY

ENDIF   ; OLDNBDATA


        ORG     0100h

data_table_test LABEL BYTE

;c00 nv_command_struct <COMMAND_TIMING_DELAY ,      5 ,                    DONT_CARE >
;c01 nv_command_struct <COMMAND_READ_MEM,           050000000h,            DONT_CARE >
;c02 nv_command_struct <COMMAND_WRITE_MEM,          050000000h,            55aa55aah >
;c04 nv_command_struct <COMMAND_PCI_CFG_WRITE,      80000004h,             7         >
;c05 nv_command_struct <COMMAND_PCI_CFG_READ,       80000004h,             DONT_CARE >
;c06 nv_command_struct <COMMAND_RMW_RESULT,         5,                     00007700h >
;c07 nv_command_struct <COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, 80000004h >

;
; Crush11 init sequence.
;

nv_command_struct< COMMAND_PCI_CFG_WRITE, 8000017Ch, 170F17C0h >        ; CR_CMC_CFG0, 0x170f17c0 | CR_CMC_CFG0_PART_INTLV_32B = 0
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000164h, 00000001h >        ; CR_CMC_NVM, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000240h, 00110401h >        ; CR_XL_DIMM_CFG_0, 0x1 | 0x10000 | 0x100000 | 0x0 | 0x400 = 0x110401
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000170h, 00000038h >        ; CR_CMC_MEMIO_CFG0, 0x38
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000190h, 22228807h >        ; CR_CMC_TIMING0, 0x22228807

nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000194h, 22452250h >        ; CR_CMC_TIMING1, 0x22452250
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000198h, 036900FFh >        ; CR_CMC_TIMING2, 0x032100FF / 0x036900FF
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000178h, 0100021Fh >        ; CR_CMC_MEMIO_CFG2, 0x0100021F
nv_command_struct< COMMAND_PCI_CFG_WRITE, 8000019Ch, 00000020h >        ; CR_CMC_ARB_PREDIVIDER, 0x20
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001C0h, 00000013h >        ; CR_CMC_ARB, 0x13

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001CCh, 00028880h >        ; CR_CMC_ARB_TIMEOUT, 0x28880
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001D0h, 00004C40h >        ; CR_CMC_ARB_XFER_SZ, 0x4C40
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001D4h, 00002220h >        ; CR_CMC_ARB_XFER_REM, 0x2220
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001D8h, 0000000Ch >        ; CR_CMC_ARB_DIFF_BANK, 0xC
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001DCh, 0000000Fh >        ; CR_CMC_CLOSE_PAGE0, 0xF

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001E0h, 0000000Bh >        ; CR_CMC_CLOSE_PAGE1, 0xB
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001E4h, 000001CFh >        ; CR_CMC_CLOSE_PAGE2, 0x1CF
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001ECh, 00000F31h >        ; CR_CMC_AUTOCLOSE, 0xF31
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001F0h, 11001018h >        ; CR_CMC_WBC, 0x11001018
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001F8h, 00000401h >        ; CR_CMC_CPU_RRQ, 0x401

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001FCh, 02750031h >        ; CR_CMC_BYPASS, 0x2750031
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000168h, 00000001h >        ; CR_CMC_PIN, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 8000016Ch, 00000001h >        ; CR_CMC_PAD, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001E8h, 24924488h >        ; CR_CMC_CMDQ, 0x24924488
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001F4h, 00001008h >        ; CR_CMC_CMDQ_PRT, 0x1008

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001c8h, 00000001h >        ; CR_CMC_PRE, 0x1

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 1

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001a0h, 8000002Ah >        ; CR_CMC_MRS_DIMM0, 0x8000002A

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 80000000h

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001a4h, 80200001h >        ; CR_CMC_EMRS_DIMM0, 0x80200001

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 80000000h

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001c8h, 00000001h >        ; CR_CMC_PRE, 0x1

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 1

; do 8 memory refresh cycles:

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001c4h, 00000001h >        ; CR_CMC_REF, 0x1

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 1

nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000168h, 00000001h >        ; CR_CMC_PIN, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000160h, 80000000h >        ; CR_CMC_REFCTRL, 0x80000000
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000084h, 03000000h >        ; CR_CPU_MEMTOP, 0x3000000 = 64MB limit (as a RMW, reads as 0x3FFFFFF)

IFDEF MEMTEST

;
; Memory test
;

nv_command_struct< COMMAND_RMW_ACCUM, 0, 0 >                              ; clear accumulator

;
; dram0 chip
;

dram0_begin:

MemBase = 0
MemChip = 0

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram0_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram0_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram0_2MB-$-4) >    ; if edi != val, jump

dram0_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram0_end-$-4) >

dram0_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram0_end-$-4) >

dram0_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram0_end:

;
; dram1 chip
;

dram1_begin:

MemBase = 010h
MemChip = 1

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram1_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE>         ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram1_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram1_2MB-$-4) >    ; if edi != val, jump

dram1_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram1_end-$-4) >

dram1_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram1_end-$-4) >

dram1_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram1_end:

;
; dram2 chip
;

dram2_begin:

MemBase = 020h
MemChip = 2

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram2_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram2_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram2_2MB-$-4)>     ; if edi != val, jump

dram2_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram2_end-$-4) >

dram2_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram2_end-$-4) >

dram2_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram2_end:

;
; dram3 chip
;

dram3_begin:

MemBase = 030h
MemChip = 3

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram3_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram3_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram3_2MB-$-4) >    ; if edi != val, jump

dram3_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram3_end-$-4) >

dram3_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram3_end-$-4) >

dram3_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram3_end:

;
; dram4 chip
;

dram4_begin:

MemBase = 04000000h
MemChip = 4

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram4_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram4_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram4_2MB-$-4) >    ; if edi != val, jump

dram4_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram4_end-$-4) >

dram4_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram4_end-$-4) >

dram4_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram4_end:

;
; dram5 chip
;

dram5_begin:

MemBase = 04000010h
MemChip = 5

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram5_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram5_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram5_2MB-$-4) >    ; if edi != val, jump

dram5_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram5_end-$-4) >

dram5_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram5_end-$-4) >

dram5_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram5_end:

;
; dram6 chip
;

dram6_begin:

MemBase = 04000020h
MemChip = 6

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram6_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram6_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram6_2MB-$-4) >    ; if edi != val, jump

dram6_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram6_end-$-4) >

dram6_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram6_end-$-4) >

dram6_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram6_end:

;
; dram7 chip
;

dram7_begin:

MemBase = 04000030h
MemChip = 7

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram7_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram7_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram7_2MB-$-4) >    ; if edi != val, jump

dram7_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram7_end-$-4) >

dram7_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram7_end-$-4) >

dram7_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram7_end:

ENDIF

;
; End of table
;

nv_command_struct < COMMAND_QUIT, DONT_CARE, DONT_CARE >

        ORG     07FFh           ; 0FFFFh

        db      00h

CODE    ENDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\command.inc ===
IFDEF MCP_XMODE2

;
; Opcodes for devkits (XMODE2)

COMMAND_RESERVED             EQU 0E7h
COMMAND_READ_MEM             EQU 09Ah
COMMAND_WRITE_MEM            EQU 05Bh
COMMAND_PCI_CFG_WRITE        EQU 0F9h
COMMAND_PCI_CFG_READ         EQU 0F5h
COMMAND_RMW_RESULT           EQU 0EDh
COMMAND_USE_RESULT_AS_DATA   EQU 068h
COMMAND_COMPARE_RESULT_JNE   EQU 004h
COMMAND_JMP                  EQU 025h
COMMAND_RMW_ACCUM            EQU 06Ch
COMMAND_OUT_BYTE             EQU 03Ch
COMMAND_IN_BYTE              EQU 0C8h
COMMAND_QUIT                 EQU 0BFh

ELSE

;
; Opcodes for internal ROM (XMODE3)
;

COMMAND_RESERVED             EQU 1h
COMMAND_READ_MEM             EQU 2h
COMMAND_WRITE_MEM            EQU 3h
COMMAND_PCI_CFG_WRITE        EQU 4h
COMMAND_PCI_CFG_READ         EQU 5h
COMMAND_RMW_RESULT           EQU 6h
COMMAND_USE_RESULT_AS_DATA   EQU 7h
COMMAND_COMPARE_RESULT_JNE   EQU 8h
COMMAND_JMP                  EQU 9h
COMMAND_RMW_ACCUM            EQU 10h
COMMAND_OUT_BYTE             EQU 11h
COMMAND_IN_BYTE              EQU 12h
COMMAND_QUIT                 EQU 0EEh

COMMAND_UNUSED1              EQU 0F5h
COMMAND_UNUSED2              EQU 080h

ENDIF


DONT_CARE                    EQU 0

nv_command_struct struct
        nv_command db 0
        nv_address dd 0
        nv_data    dd 0
nv_command_struct ends
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\enckey.inc ===
; 
; the encryption key (ROMDEC_KEYSIZE bytes)
;

EncKey:
        DB 057h,042h,029h,00Ch,030h,01Eh,0D3h,001h
        DB 0B3h,0E5h,05Dh,028h,050h,031h,0E1h,0CEh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\encrypt.inc ===
;++
;  Copyright (c) 1996, 1997 Microsoft Corporation
;
;  Copyright (C) 1987 RSA Data Security, Inc. Created 1987.
;  This is an unpublished work protected as such under copyright law.
;  This work contains proprietary, confidential, and trade secret information
;  of RSA Data Security, Inc.  Use, disclosure, or reproduction without the
;  express written authorization of RSA Data Security, Inc., is prohibited.
;
;
;  Abstract:
;
;     This code is derived from Scott Field's optimized implementation of the
;     RC4 algorithm.  Following changes were made.
;        1.  rc4_key and rc4 functionality have been merged 
;        2.  Does not preserve any registers--does not use stack
;        3.  Does not take any parameters--everything is hardcoded
;        4.  Does not update the indicies in the key structure at end
;        5.  Separate input/output buffers
;
;  Environment:
;
;     32-bit Protected Mode
;
;--



;
; RC4 key expansion functionality (rc4_key) 
;

        mov     eax, 03020100H          ; initial fill value
        mov     ecx, 64                 ; loop iteration count

        mov     esi, ROMDEC_KEYSTRUCT

        mov     edx, esi

;
; for (a=0x03020100,i=0;i<RC4_TABLESIZE/sizeof(DWORD);i++, a+= 0x04040404)
;       ((DWORD*)p)[i] = a;

init_loop:

        mov     DWORD PTR [edx], eax
        add     edx, 4

        add     eax, 04040404H
        dec     ecx

        jne     init_loop

; i = j = k = 0;

        xor     ecx, ecx                ; k = 0
        xor     edi, edi

        mov     ebp, OFFSET EncKey
        mov     BYTE PTR [esi+256], cl  ; Key->i = 0;

        mov     BYTE PTR [esi+257], cl  ; Key->j = 0;
        xor     ebx, ebx


; while (i < RC4_TABLESIZE) {

permute_loop:

        ; ti = p[i];

        ; tk = K[k];
        ; j += tk;

        ; j += ti;

        ; j &= (RC4_TABLESIZE - 1);
        ; tj = p[j];
        ; k++;

        ; p[i] = tj;

        ; i++;
        ; p[j] = ti;

        xor     edx, edx                        ; avoid p6 partial stall
        xor     eax, eax                        ; avoid p6 partial stall

        mov     dl, BYTE PTR [esi+edi]
        mov     al, BYTE PTR [ecx+ebp]

        add     bl, al                          ; add ebx, eax
        inc     ecx

        add     bl, dl                          ; add ebx, edx
        inc     edi

        ; if (k == m)

;        and     ebx, 0FFh                      ; and not needed due to 8 bit add

        mov     al, BYTE PTR [esi+ebx]
        mov     BYTE PTR [esi+edi-1], al

        cmp     ecx, ROMDEC_KEYSIZE      
        mov     BYTE PTR [esi+ebx], dl

        jne     skip_zero_k

        xor     ecx, ecx

skip_zero_k:

        cmp     edi, 256
        jb      permute_loop



;
; RC4 encryption functionality (rc4) 
;

        xor     ecx, ecx
        xor     edx, edx
        xor     edi, edi
        xor     eax, eax

        mov     esi, ROMDEC_KEYSTRUCT   ; p = Key->S
        mov     ebp, ROMDEC_BUFFERSIZE  ; byte count
        
        mov     cl, BYTE PTR [esi+256]  ; i = Key->i

        mov     dl, BYTE PTR [esi+257]  ; j = Key->j

rc4_loop:

        inc     cl                      ; i ++ ; i &= (RC4_TABLESIZE-1)

        mov     al, BYTE PTR [ecx+esi]  ; t = p[i]

        add     dl, al                  ; j += t ; j &= (RC4_TABLESIZE-1)

        mov     bl, BYTE PTR [edx+esi]  ; pickup p[j]

        mov     BYTE PTR [ecx+esi], bl  ; p[i] = p[j]
        mov     BYTE PTR [edx+esi], al  ; p[j] = t (potential bank conflict)

;
; *outputbuffer++ = *inputbuffer++ ^ p[( p[i] + t) & (RC4_TABLESIZE-1) ];
;

        add     al, bl                                  ; (t += p[i]) & RC4_TABLESIZE-1

        mov     bl, BYTE PTR ROMDEC_INPUTBUFFER[edi]    ; get byte from input buffer

        mov     al, BYTE PTR [eax+esi]                  ; pickup p[t]

        xor     bl, al                  

        mov     BYTE PTR ROMDEC_OUTPUTBUFFER[edi], bl   ; write byte to output buffer

        inc     edi                                     ; bufferindex++

        dec     ebp                                     ; loop until no input left to process
        jnz     rc4_loop                

rc4_done:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\inittbl.asm ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    inittbl.asm
;
;  Abstract:
;
;    This module contains table of commands used by South Bridge to initialize
;    hardware and test memory during boot startup.  For definition of each
;    command, please see initcode.inc and command.inc
;
;--
        INCLUDE chipset.inc

;
; To build the init table for old A02 (without M7, fansink) DVT3s, DVT2s and 
; DVT1, define INITTABLE_OLDA02.  To build the init table for fullspeed systems, 
; this should undefined.  We are currently building two init tables:
;
;
;   Init Table            Ver    Defines
;   --------------------- ------ ----------------------------------------------------------
;   DVT4/5                0x46   SYS_DVT4  
;
;   DVT6                  0x60   SYS_DVT6 (SYS_DVT4 undefined)
;
;   QT                    0x70   SYS_QT (automatically defines SYS_DVT6)
;

        INCLUDE nv2ainit.inc

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\initcode.inc ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    initcode.inc
;
;  Abstract:
;
;    This module contains code to parse and process the init table opcodes
;--


;
; Load the start address of the init table 
;        
        mov  esi, ROMDEC_INIT_TABLE


InitLoop:
;
; Load command and parameters
;        
        mov     al, ds:[esi]
        mov     ebx, ds:[esi+1]
        mov     ecx, ds:[esi+5]
        
        .if al == COMMAND_USE_RESULT_AS_DATA
;
; Use Result As Data Command 
;        
        mov     edx, ecx
        mov     al, bl
        mov     ebx, edx
        mov     ecx, edi
        .endif


IFDEF MCP_REV_B01
        .if al == COMMAND_RESERVED
;
; This used to be the "Timing Delay Command" but was broken and not used
;
        mov     dx, 80h
        rep     insb

        .elseif al == COMMAND_READ_MEM
ELSE
        .if al == COMMAND_READ_MEM
        
ENDIF   
;
; Read Memory Command 
;        
;    Disallow read memory for top of address space.  The Rev B01
;    implementation used a cmp, others use an and instruction
;
        
IFDEF MCP_REV_B01

IFDEF MCP_XMODE2
        and     ebx, 00FFFFFFFh    
        mov     edi, [ebx]
ELSE
        cmp     ebx, 0FF000000h 
        ja      ReadNotAllowed
        mov     edi, [ebx]

ReadNotAllowed:
ENDIF
        
ELSE    
        and     ebx, 00FFFFFFFh    
        mov     edi, [ebx]
ENDIF   

        .elseif al == COMMAND_WRITE_MEM
;
; Write Memory Command
;        
        mov     [ebx], ecx

        .elseif al == COMMAND_RMW_RESULT
;
; Read Modify Write Result Command
;        
        and     edi, ebx
        or      edi, ecx
        
        .elseif al == COMMAND_PCI_CFG_WRITE 
        
IFNDEF MCP_XMODE2
;
; PCI Config Write Command
;
;    Check to see if the PCI write is for the General SM Ctrl 1 register
;    which is used to turn off the SB ROM.  If it is, turn off the bit 1
;    
        cmp     ebx, 80000880h
        jnz     OKToWrite
        and     ecx, 0FFFFFFFDh 
                
OKToWrite:    

ENDIF
        mov     eax, ebx
        mov     dx, 0cf8h
        out     dx, eax
        add     dl, 4
        mov     eax, ecx
        out     dx,eax

        .elseif al == COMMAND_PCI_CFG_READ
;
; PCI Config Read Command
;        
        mov     eax, ebx
        mov     dx, 0cf8h
        out     dx, eax
        add     dl, 4
        in      eax, dx
        mov     edi, eax

        .elseif al == COMMAND_COMPARE_RESULT_JNE
;
; Compare Result Jump Command
;       
        .if edi != ebx
        add     esi, ecx
        .endif
        
        .elseif al == COMMAND_JMP
;
; Jump Command  
;       
        add  esi, ecx

        .elseif al == COMMAND_RMW_ACCUM
;
; Read Modify Write Accumulator Command
;        
        and     ebp, ebx
        or      ebp, ecx
        mov     edi, ebp
        

        .elseif al == COMMAND_OUT_BYTE
;
; OUT
;       
        mov     edx, ebx
        mov     eax, ecx
        out     dx, al

        .elseif al == COMMAND_IN_BYTE
;
; IN
;       
        mov     edx, ebx
        in      al, dx
        movzx   edi, al
        
        .elseif al == COMMAND_QUIT
        jmp     InitDone
        .endif
        
;
; Advance to next entry in the table
;
Continue:
        add     esi, SIZEOF nv_command_struct
        
        jmp     InitLoop

InitDone:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\nvidia.inc ===
COMMAND_QUIT		   EQU 0
COMMAND_TIMING_DELAY       EQU 00000001b
COMMAND_READ_MEM           EQU 00000010b
COMMAND_WRITE_MEM          EQU 00000100b
COMMAND_PCI_CFG_WRITE      EQU 00001000b
COMMAND_PCI_CFG_READ       EQU 00010000b
COMMAND_RMW_RESULT         EQU 00100000b
COMMAND_USE_RESULT_AS_DATA EQU 01000000b

DONT_CARE		   EQU 0

nv_command_struct struct
  nv_command db 0
  nv_address dd 0
  nv_data    dd 0
nv_command_struct ends

;
; Sample Table
;
;data_table_test LABEL BYTE
;c00 nv_command_struct <COMMAND_TIMING_DELAY ,      5 ,                    DONT_CARE >
;c01 nv_command_struct <COMMAND_READ_MEM,           050000000h,            DONT_CARE >
;c02 nv_command_struct <COMMAND_WRITE_MEM,          050000000h,            55aa55aah >
;c04 nv_command_struct <COMMAND_PCI_CFG_WRITE,      80000004h,             7         >
;c05 nv_command_struct <COMMAND_PCI_CFG_READ,       80000004h,             DONT_CARE >
;c06 nv_command_struct <COMMAND_RMW_RESULT,         5,                     00007700h >
;c07 nv_command_struct <COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, 80000004h >
;c19 nv_command_struct <>



  mov  esi, ROMDEC_NVIDIA_TABLE

.repeat

  mov  al, ds:[esi]
  mov  ebx, ds:[esi+1]
  mov  ecx, ds:[esi+5]
  
  .if al & COMMAND_USE_RESULT_AS_DATA
    mov  edx, ecx
    mov  al, bl
    mov  ebx, edx
    mov  ecx, edi
  .endif
  
  .if al & COMMAND_TIMING_DELAY
; cx will already have the io's to do.
    mov  dx, 80h
    rep  insb
  .elseif al & COMMAND_READ_MEM
    mov  edi, [ebx]
  .elseif al & COMMAND_WRITE_MEM
    mov  [ebx], ecx
  .elseif al & COMMAND_RMW_RESULT
    and  edi, ebx
    or   edi, ecx
  .elseif al & COMMAND_PCI_CFG_WRITE 
    mov  eax, ebx
    mov  dx, 0cf8h
    out  dx, eax
    add  dx, 4
    mov  eax, ecx
    out  dx,eax
  .elseif al & COMMAND_PCI_CFG_READ
    mov  eax, ebx
    mov  dx, 0cf8h
    out  dx, eax
    add  dx, 4
    in   eax, dx
    mov  edi, eax
  .elseif al == COMMAND_QUIT
    mov  esi, -9
  .endif
  add  esi, SIZEOF nv_command_struct
.until esi == 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\nv2a.inc ===
;
; NV2A ROM table ptr (NV20 Register Base/Limit (BAR0)
;
NV2A_XBOX_ROM_TABLE_PTR          EQU 0FF000008h

;
; Datatbl starts at this offset
;
; IMPORTANT: This must be adjusted if the size of the init table
; code has changed
;
IFDEF SYS_RETAIL
DATATBL_BASE_OFFSET              EQU 0C90h
ELSE
DATATBL_BASE_OFFSET              EQU 0BF0h
ENDIF

;
; Integrated NV20 Register Base (BAR0)
;
NV20_REG_BASE                    EQU 00F000000h    ; only during the init tbl
NV20_REG_BASE_KERNEL             EQU 0FD000000h    ; reloaded to agree with kernel code
NV20_FB_BASE                     EQU 0F0000000h
APERTURE_BASE                    EQU 040000000h

SMB_CONTROL_BASE                 EQU 00000C000h
SMB_DDC_SPIO_BASE                EQU 00000C200h

;
; NV2A config equates
;
CR_CPU_MEMTOP                    EQU 080000084h
CR_CPU_MEMTOP_LIMIT_64MB         EQU 003FFFFFFh
CR_CPU_MEMTOP_LIMIT_128MB        EQU 007FFFFFFh

CR_CPU_CST_0                     EQU 080000340h
CR_CPU_CST_1                     EQU 080000344h
CR_CPU_CST_7                     EQU 08000035Ch

CR_CPU_MPLL_COEFF                EQU 08000036Ch

CR_APC_P2P_1                     EQU 08000F004h
CR_APC_P2P_1_BUS_MSTR_MEM_IO     EQU 000000007h    ; should be RMW, still ok?

CR_APC_P2P_6                     EQU 08000F018h
CR_APC_P2P_6_SUB_SEC_PRI_BUS     EQU 000010100h    ; change CR_NV20, if bus changes

CR_APC_P2P_8                     EQU 08000F020h
CR_APC_P2P_8_MLIMIT_MBASE_INIT   EQU (NV20_REG_BASE + 0F00000h) OR (NV20_REG_BASE SHR 16)
CR_APC_P2P_8_MLIMIT_MBASE_KERNEL EQU (NV20_REG_BASE_KERNEL + 0F00000h) OR (NV20_REG_BASE_KERNEL SHR 16)
CR_APC_P2P_9                     EQU 08000F024h
CR_APC_P2P_9_PREF_MLIMIT_MBASE   EQU (NV20_FB_BASE +  7F00000h) OR (NV20_FB_BASE SHR 16)

CR_APC_P2P_19                    EQU 08000F04Ch
CR_APC_P2P_19_NV20_ENABLE        EQU 000000001h    ; enables internal graphics

;
; MCP config equates
;
MCP_LEG_CFG_1                    EQU 080000804h    ; enable IO space
MCP_LEG_CFG_2                    EQU 080000808h    ; holds MCP revision ID

IFDEF MCP_REV_C03
MCP_LEG_CFG_4                    EQU 080000884h    ; IO BAR for revs >= C03
ELSE
MCP_LEG_CFG_4                    EQU 080000810h    ; IO BAR for revs < C03
ENDIF

MCP_LEG_CFG_19                   EQU 08000084Ch
MCP_LEG_CFG_24                   EQU 080000860h
MCP_LEG_CFG_39                   EQU 08000089Ch
MCP_LEG_CFG_45                   EQU 0800008B4h

MCP_SMB_CFG_1                    EQU 080000904h
MCP_SMB_CFG_1_IO_SPACE           EQU 000000001h    ; should be RMW, still ok?

MCP_SMB_CFG_5                    EQU 080000914h
MCP_SMB_CFG_5_IO_BASE            EQU SMB_CONTROL_BASE + 1

MCP_SMB_CFG_6                    EQU 080000918h
MCP_SMB_CFG_6_IO_BASE            EQU SMB_DDC_SPIO_BASE + 1

MCP_USBA_CFG_15                  EQU 08000103Ch    ; scratch pad for meminit
MCP_USBB_CFG_15                  EQU 08000183Ch    ; scratch pad for meminit

;
; MCP registers used as scratchpad for memory test
;
MEMTEST_TYPE                     EQU 08000103Ch    ; MCP_USBA_CFG_15 
MEMTEST_RESULT                   EQU 08000183Ch    ; MCP_USBB_CFG_15 

;
; Memory test patterns
;
MEMTEST_PATTERN1                 EQU 0AAAAAAAAh
MEMTEST_PATTERN2                 EQU 05A5A5A5Ah
MEMTEST_PATTERN3                 EQU 055555555h
MEMTEST_PATTERN4                 EQU 0CCCCCCCCh


; Internal NV20 config equates (assumes bus 1)
;
CR_NV20_PCI_1                    EQU 080010004h
CR_NV20_PCI_1_BUS_MSTR_MEM_IO    EQU 000000007h    ; should be RMW, still ok?

CR_NV20_PCI_4                    EQU 080010010h
CR_NV20_PCI_5                    EQU 080010014h

;
; NV20 register offsets and init values (from nv2a\manuals\rom_table.txt)
;
NV_PBUS_DEBUG_CTRIM_0            EQU 0000010B0h
NV_PBUS_DEBUG_CTRIM_1            EQU 0000010B4h
NV_PBUS_DEBUG_CTRIM_2            EQU 0000010B8h
NV_PBUS_DEBUG_CTRIM_3            EQU 0000010BCh
NV_PBUS_DEBUG_CTRIM_4            EQU 0000010C4h
NV_PBUS_DEBUG_CTRIM_5            EQU 0000010C8h
NV_PBUS_DEBUG_CTRIM_6            EQU 0000010CCh
NV_PBUS_DEBUG_CTRIM_7            EQU 0000010D4h
NV_PBUS_DEBUG_CTRIM_8            EQU 0000010D8h
NV_PBUS_DEBUG_CTRIM_9            EQU 0000010DCh
NV_PBUS_DEBUG_CTRIM_10           EQU 0000010E8h

NV_PBUS_FBIO_CFG                 EQU 000001210h

NV_PBUS_FBIO_CALEN               EQU 000001220h
NV_PBUS_FBIO_CALEN_OFF           EQU 000000000h

NV_PBUS_FBIO_CALSEL              EQU 000001228h
NV_PBUS_FBIO_CALSEL_VALUE        EQU 000000000h

NV_PBUS_FBIO_DLY                 EQU 000001214h

NV_PBUS_FBIO_ADRDRV              EQU 00000122Ch
NV_PBUS_FBIO_CLKDRV              EQU 000001230h
NV_PBUS_FBIO_DATDRV              EQU 000001234h
NV_PBUS_FBIO_DATDRV_INIT         EQU 0AAAAAAAAh
NV_PBUS_FBIO_DQSDRV              EQU 000001238h
NV_PBUS_FBIO_DQSDRV_INIT         EQU 0AAAAAAAAh
NV_PBUS_FBIO_ADRSLW              EQU 00000123Ch
NV_PBUS_FBIO_ADRSLW_INIT         EQU 08B8B8B8Bh
NV_PBUS_FBIO_CLKSLW              EQU 000001240h
NV_PBUS_FBIO_DATSLW              EQU 000001244h
NV_PBUS_FBIO_DATSLW_INIT         EQU 08B8B8B8Bh
NV_PBUS_FBIO_DQSSLW              EQU 000001248h
NV_PBUS_FBIO_DQSSLW_INIT         EQU 08B8B8B8Bh
NV_PBUS_DISPIO_PADCTL            EQU 00000124Ch
NV_PBUS_DISPIO_PADCTL_INIT       EQU 0AA8BAA8Bh
NV_PBUS_TVDIO_PADCTL             EQU 000001250h
NV_PBUS_TVDIO_PADCTL_INIT        EQU 00000AA8Bh

NV_PBUS_TVDIO_CALEN              EQU 000001264h
NV_PBUS_TVDIO_CALEN_OFF          EQU 000000000h

NV_PEXTDEV_BOOT_0                EQU 000101000h

NV_PFB_REF                       EQU 0001002D0h
NV_PFB_PRE                       EQU 0001002D4h
NV_PFB_PRE_CMD_PRECHARGE_1       EQU 000000001h
NV_PFB_EMRS                      EQU 0001002C4h
NV_PFB_EMRS_EXT                  EQU 0001002CCh
NV_PFB_MRS                       EQU 0001002C0h
NV_PFB_MRS_DLL_RESET             EQU 000000132h
NV_PFB_MRS_EXT                   EQU 0001002C8h
NV_PFB_MRS_EXT_DLL_RESET         EQU 000000132h
NV_PFB_REFCTRL                   EQU 000100210h
NV_PFB_REFCTRL_VALID_1           EQU 080000000h
NV_PFB_WBC                       EQU 000100410h
NV_PFB_CPU_RRQ                   EQU 000100420h
NV_PFB_CPU_RRQ_FWP_LAT_ENABLE    EQU 000000401h
NV_PFB_BYPASS                    EQU 000100424h
NV_PFB_BYPASS_VALUE              EQU 0F1780031h

NV_PMC_BOOT_0                    EQU 000000000h

NV_PRAMDAC_PLL_COEFF_SELECT      EQU 00068050Ch
NV_PFB_CFG0                      EQU 000100200h
NV_PFB_CFG1                      EQU 000100204h

NV_PFB_TIMING2                   EQU 000100228h

NV_PFB_ARB_XFER_SZ               EQU 000100330h
NV_PFB_ARB_TIMEOUT               EQU 00010032Ch
NV_PFB_ARB_PREDIVIDER            EQU 000100328h
NV_PFB_ARB_DIFF_BANK             EQU 000100338h

NV_PBUS_FBIO_RAM                 EQU 000001218h

NV_PRAMDAC_NVPLL_COEFF           EQU 000680500h

NV_PGRAPH_DEBUG_2                EQU 000400880h
NV_PGRAPH_DEBUG_2_VALUE          EQU 0002EC3FFh
NV_PGRAPH_DEBUG_10               EQU 000400b88h
NV_PGRAPH_DEBUG_10_ROP_BLEND     EQU 000000003h

;
; Equates used for the memory detect/test
;
MEM_PART_0                       EQU 000000000h
MEM_PART_1                       EQU 000000010h
MEM_PART_2                       EQU 000000020h
MEM_PART_3                       EQU 000000030h
MEM_PART_4                       EQU 004000000h
MEM_PART_5                       EQU 004000010h
MEM_PART_6                       EQU 004000020h
MEM_PART_7                       EQU 004000030h


;
; First byte of the desired SMC revision
;
DESIRED_SMC_VER                  EQU 050h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\inittbl\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt6.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt6.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt6.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\nv2ainit.inc ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    nv2ainit.inc
;
;  Abstract:
;
;    NV2A initialization table
;
;    This module contains table of commands used by South Bridge to initialize
;    hardware and test memory during boot startup.  For definition of each
;    command, please see initcode.inc and command.inc
;--

page    84,132
.MODEL compact
.486p

INCLUDE COMMAND.INC
INCLUDE NV2A.INC

CODE SEGMENT PARA PUBLIC 'code'
  assume  ds:code,es:nothing,ss:nothing
org 0000h

;
; NB data for NV2A on the DVT boards
;

;
; Not currently documented, NV2A expects table ptrs to exist in the first
; 2 DWORDS of the ROM image, which point to the beginning of the ROM table.
; The MCPX still expects to find it's init values starting at 0x70.
;
dd NV2A_XBOX_ROM_TABLE_PTR + 1        ; LSB needs to be 1 to appear valid
dd NV2A_XBOX_ROM_TABLE_PTR

; CR_ROM_NB_BOOT_HEADER                    (0*32+31):(0*32+0) /* R--VF */
;
dd 2B16D065h

; CR_ROM_NB_BOOT_PROC                       (1*32+0):(1*32+0) /* R--VF */
; CR_ROM_NB_BOOT_PROC_INTEL                        0x00000001 /* R---V */
; CR_ROM_NB_BOOT_RAMTYPE                    (1*32+2):(1*32+2) /* R--VF */
; CR_ROM_NB_BOOT_RAMTYPE_DDR                       0x00000001 /* R---V */
; CR_ROM_NB_BOOT_RAMWIDTH                   (1*32+3):(1*32+3) /* R--VF */
; CR_ROM_NB_BOOT_RAMWIDTH_128                      0x00000001 /* R---V */
; CR_ROM_NB_BOOT_MEM_POSTDIV                (1*32+7):(1*32+4) /* R--VF */
; CR_ROM_NB_BOOT_AGP_POSTDIV               (1*32+11):(1*32+8) /* R--VF */
; CR_ROM_NB_BOOT_FSB_ROM                  (1*32+15):(1*32+12) /* R--VF */
; CR_ROM_NB_BOOT_FSB_66                   (1*32+19):(1*32+16) /* R--VF */
; CR_ROM_NB_BOOT_FSB_100                  (1*32+23):(1*32+20) /* R--VF */
; CR_ROM_NB_BOOT_FSB_TUALATIN             (1*32+27):(1*32+24) /* R--VF */
; CR_ROM_NB_BOOT_FSB_133                  (1*32+31):(1*32+28) /* R--VF */
;
; dd 4444444dh    ; (100MHz FSB hardcoded)
; dd 3346323Dh      ; (AGP_PDIV = 2, MEM_PDIV = 3), start at 133MHz
dd 3346322Dh    ; (AGP_PDIV = 2, MEM_PDIV = 2)

;    These COREPLL values are based on using a 13.5MHz xtal.
;
;    NOTE: If you change the MDIV, NDIV, FSB POSTDIV or MEM_POSTDIV you'll
;    need to sync the change with the  CR_CPU_MPLL_COEFF write in the inittbl
;    below.
;
; CR_ROM_NB_BOOT_COREPLL_MDIV_66            (2*32+7):(2*32+0) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_66_VALUE             0x00000007 /* R---V */ 
; CR_ROM_NB_BOOT_COREPLL_MDIV_100          (2*32+15):(2*32+8) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_100_VALUE            0x00000007 /* R---V */ 
; CR_ROM_NB_BOOT_COREPLL_MDIV_TUALATIN    (2*32+23):(2*32+16) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_TUALATIN_VALUE       0x00000007 /* R---V */ 
; CR_ROM_NB_BOOT_COREPLL_MDIV_133         (2*32+31):(2*32+24) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_133_VALUE            0x00000007 /* R---V */ 
;
; dd 07070707h
; dd 01010101h
dd 01010101h

; CR_ROM_NB_BOOT_COREPLL_NDIV_66            (3*32+7):(3*32+0) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_66_VALUE             0x00000022 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_100          (3*32+15):(3*32+8) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_100_VALUE            0x00000034 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_TUALATIN    (3*32+23):(3*32+16) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_TUALATIN_VALUE       0x00000045 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_133         (3*32+31):(3*32+24) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_133_VALUE            0x00000045 /* R---V */
;
; dd 45453422h
; dd 07070707h        ; (100MHz FSB)
; dd 08080808h        ; (106MHz FSB)
; dd 0A0A0A0Ah        ; (135MHz FSB)
; dd 09090909h        ; (133MHz FSB)
dd 08080808h          ; (133MHz FSB 16.66MHz input clock)

; CR_ROM_NB_BOOT_COREPLL_MDIV_ROM           (4*32+7):(4*32+0) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_ROM_VALUE            0x00000007 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_ROM          (4*32+15):(4*32+8) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_ROM_VALUE            0x00000045 /* R---V */
; CR_ROM_NB_BOOT_ASRC_CPU                 (4*32+23):(4*32+16) /* R--VF */
; CR_ROM_NB_BOOT_ASRC_LDT                 (4*32+31):(4*32+24) /* R--VF */
;
; dd 4507h
; dd 0801h          ; (106MHz FSB)
; dd 0701h          ; (100MHz FSB)
; dd 0A01h          ; (135MHz FSB)
; dd 1D03h          ; (133MHz FSB)
dd 0801h            ; (133MHz FSB w/ 16.66MHz input clock)

; CR_ROM_NB_BOOT_SADDOUTCLK_DLY             (5*32+3):(5*32+0) /* R--VF */
; CR_ROM_NB_BOOT_SDATAOUTCLK_DLY            (5*32+7):(5*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CPU_VREF_EN_               (5*32+8):(5*32+8) /* R--VF */
; CR_ROM_NB_BOOT_APIC_33                    (5*32+9):(5*32+9) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_SETUP            (5*32+18):(5*32+10) /* R--VF */
; CR_ROM_NB_BOOT_CPUPLL_SETUP             (5*32+27):(5*32+19) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_DLY              (5*32+31):(5*32+28) /* R--VF */
;
dd 0C8FC7C8Ah

; CR_ROM_NB_BOOT_CTRIM_CPUCLKFB             (6*32+3):(6*32+0) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLKFB_VALUE              0x00000003 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BL          (6*32+7):(6*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BL_VALUE           0x00000001 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BR         (6*32+11):(6*32+8) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BR_VALUE           0x00000002 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_NW          (6*32+15):(6*32+12) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_NW_VALUE_DONTCARE    0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SW          (6*32+19):(6*32+16) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SW_VALUE             0x00000009 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SE          (6*32+23):(6*32+20) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SE_VALUE             0x00000002 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BL         (6*32+27):(6*32+24) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BL_VALUE            0x00000002 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BR         (6*32+31):(6*32+28) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BR_VALUE            0x00000002 /* R---V */
;
dd 44290213h        ; A03


; CR_ROM_NB_BOOT_CTRIM_CPUCLKOUT            (7*32+3):(7*32+0) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLKOUT_VALUE             0x00000008 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_MCP          (7*32+7):(7*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_MCP_VALUE           0x00000009 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_CPU         (7*32+11):(7*32+8) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_CPU_VALUE           0x00000009 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_COREPLLFB          (7*32+15):(7*32+12) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_COREPLLFB_VALUE             0X00000004 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUPLLFB           (7*32+19):(7*32+16) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_SPARE1             (7*32+23):(7*32+20) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_SPARE1_VALUE_DONTCARE       0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_SPARE2             (7*32+27):(7*32+24) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_SPARE2_VALUE_DONTCARE       0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_SPARE3             (7*32+31):(7*32+28) /* R--VF */
;
IFDEF SYS_DVT6
dd 90004998h
ELSE
dd 00064998h
ENDIF

; CR_ROM_NB_BOOT_CSHAPE_CPUCLKFB            (8*32+3):(8*32+0) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLKFB_VALUE             0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK2X            (8*32+7):(8*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK2X_VALUE             0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK             (8*32+11):(8*32+8) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK_VALUE               0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLKOUT         (8*32+15):(8*32+12) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLKOUT_VALUE            0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_CPU       (8*32+19):(8*32+16) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_CPU_VALUE          0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_MCP       (8*32+23):(8*32+20) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_MCP_VALUE          0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_SPARE1            (8*32+27):(8*32+24) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_SPARE1_VALUE_DONTCARE      0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_SPARE2            (8*32+31):(8*32+28) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_SPARE2_VALUE               0x00000000 /* R---V */
;
dd 000000000h

; CR_ROM_NB_BOOT_INTEL_BPRI_                (9*32+0):(9*32+0) /* R--VF */    
; CR_ROM_NB_BOOT_INTEL_BNR_                 (9*32+1):(9*32+1) /* R--VF */    
; CR_ROM_NB_BOOT_INTEL_ADS_                 (9*32+2):(9*32+2) /* R--VF */    
; CR_ROM_NB_BOOT_INTEL_ADDR_               (9*32+31):(9*32+3) /* R--VF */    
;
dd 0FFFFFFFFh

; CR_ROM_NB_BOOT_INTEL_TRDY_              (10*32+0):(10*32+0) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_RS_                (10*32+3):(10*32+1) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_REQ_               (10*32+8):(10*32+4) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_HITM_              (10*32+9):(10*32+9) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_HIT_             (10*32+10):(10*32+10) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_DRDY_            (10*32+11):(10*32+11) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_DEFER_           (10*32+12):(10*32+12) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_DBSY_            (10*32+13):(10*32+13) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_AGTL_PLUS        (10*32+14):(10*32+14) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_SPARE1           (10*32+31):(10*32+15) /* R--VF */
;
dd 0FFFFFFFFh

;
; 14 DWORDS used (11 for CR_ROM_BOOT, 2 table ptrs, 1 DWORD ROM rev)
;
dd (28-14) dup (0h)

; ROM/Trims Revision number
;
; To keep track of TRIM changes and other inittbl/datatbl changes, we'll
; use this DWORD as the revision ID. We'll also keep the history here, so
; clear what's been changed.
;
; rev1.00 - 
;    . set QUSE_NORMAL in NV_PBUS_FBIO_CFG
;    . set NB_BOOT_CPUPLL_SETUP[3:0] and NB_BOOT_COREPLL_SETUP[3:0] to 0xF
;    . set NB_BOOT_CTRIM_CPUPLLFB to 0x6
;    . set NV_PBUS_DEBUG_CTRIM_6 to 0x66660000 and
;          NV_PBUS_DEBUG_CTRIM_2 to 0x11110000, in that order
;    . clear most significant nibble from NV_PBUS_DEBUG_CTRIM_4
;    . add SYS_DVT3 ifdef for (DVT3) 13.5 vs. (DVT4) 16.6 input clocks,
;      with changes to:
;          NB_BOOT_COREPLL_NDIV and MDIV
;          NV_PRAMDAC_NVPLL_COEFF
;          CR_CPU_MPLL_COEFF
;    . add NV2A_REV_A03 ifdef for A03 related trims:
;          CTRIM_CPUOCLK_BL = 0x4
;          CTRIM_CPUOCLK_BR = 0x4
;          CR_CPU_CST_0     = 0xF0F0C0C0
;    . update 13.5 and 16.6 calibration speedometer settings
;          (previous VCC values were incorrect for both input clocks)
;
; rev1.01 - 
;    . set WBC from 0x11000001 (which is no buffering) to 0x11000016
;    . reset PFB_ARB_XFER_SZ_ZW from 0xF (unlimited burst) to 0x8
;          since NV2A doesn't need the zcull workaround like NV20.
;    . set DQS/DQ inbound delay to 0x1/0x0 in the Samsung calibration table
;    . set the MCLK drive/slew parameters to their max (helps clock jitter).
;
; rev1.02 -
;    . change NV_PBUS_FBIO_CFG (from 0x1 to 0x10) for 1/4 clock delay
;    . change NV_PBUS_DEBUG_CTRIM_2 (from 0x11110000 to 0x0)
;
; rev1.03 - 
;    . max MCP_LEG_CFG_45_PCICLKO5_TRIM to better line up the PCI clk
;           for the LPC card 
;    . DVT6 trims (tested with the Cypress zero delay buffer):
;           PBUS_DEBUG_CTRIM_2 = 0xFFFF0000
;           CR_ROM_NB_BOOT_CTRIM_CPUPLLFB = 0x0
;           CR_ROM_NB_BOOT_CTRIM_SPARE3   = 0x9
;           change calibration inbound delay values (DQS = 0, DATA = 1)
;
; rev1.04 - 
;    . Add support for MCP C03's different base address
;
; rev1.05 - 
;    . update Micron FBIO_DLY and ADDRESS_DRIVE settings during init and
;        in the calibration table.
;    . PBUS_DEBUG_CTRIM_2 is now different between Samsung/Micron.
;
; rev1.06 - 
;    . Changed pre-calibration defaults for Samsung memory.
;    . FBIO_DLY default was 012121212 is now 009090909
;    . CLKDRV/CLKSLW value is now 0FFFFFFFF
;

;
dd 00000106h        ; bits 31:8 = major rev, 7:0 = minor rev

;
; SB data for MCPX on the DVT boards (starts at offset 0x70)
;

; MCP_ROM_BOOT_FREQ_STRAP                 (28*32+3):(28*32+0) /* R--VF */
; MCP_ROM_BOOT_FREQ_STRAP_SAFE                     0x0000000f /* R---V */
;
;dd 00000000h
dd 0Fh

; MCP_ROM_BOOT_PIC_DIS                    (29*32+0):(29*32+0) /* RWIVF */
; MCP_ROM_BOOT_PIT_DIS                    (29*32+1):(29*32+1) /* RW-VF */
; MCP_ROM_BOOT_DMA_DIS                    (29*32+2):(29*32+2) /* RW-VF */
; MCP_ROM_BOOT_P92_DIS                    (29*32+3):(29*32+3) /* RW-VF */
; MCP_ROM_BOOT_FERR_DIS                   (29*32+4):(29*32+4) /* RW-VF */
; MCP_ROM_BOOT_RTC_NMI_DIS                (29*32+5):(29*32+5) /* RW-VF */
; MCP_ROM_BOOT_USB0_DIS                   (29*32+8):(29*32+8) /* RW-VF */
; MCP_ROM_BOOT_USB1_DIS                   (29*32+9):(29*32+9) /* RW-VF */
; MCP_ROM_BOOT_MAC0_DIS                 (29*32+10):(29*32+10) /* RW-VF */
; MCP_ROM_BOOT_MAC1_DIS                 (29*32+11):(29*32+11) /* RW-VF */
; MCP_ROM_BOOT_ACI_DIS                  (29*32+12):(29*32+12) /* RW-VF */
; MCP_ROM_BOOT_MCI_DIS                  (29*32+13):(29*32+13) /* RW-VF */
; MCP_ROM_BOOT_IDE_DIS                  (29*32+14):(29*32+14) /* RW-VF */
; MCP_ROM_BOOT_P2P_DIS                  (29*32+15):(29*32+15) /* RW-VF */
; MCP_ROM_BOOT_SMB_DIS                  (29*32+16):(29*32+16) /* RW-VF */
; MCP_ROM_BOOT_FST_RST                  (29*32+24):(29*32+24) /* R--VF */
; MCP_ROM_BOOT_FST_RST_NO                          0x00000000 /* R---V */
; MCP_ROM_BOOT_REBOOT                   (29*32+25):(29*32+25) /* RW-VF */
; MCP_ROM_BOOT_REBOOT_NO                           0x00000000 /* RW--V */
; MCP_ROM_BOOT_LDT_FRQ                  (29*32+26):(29*32+26) /* RW-VF */
; MCP_ROM_BOOT_LDT_FRQ_400MHz                      0x00000000 /* RW--V */
; MCP_ROM_BOOT_LDT_FRQ_200MHz                      0x00000001 /* RW--V */
; MCP_ROM_BOOT_PROC                     (29*32+27):(29*32+27) /* RW-VF */
; MCP_ROM_BOOT_PROC_INTEL                          0x00000000 /* RWI-V */
; MCP_ROM_BOOT_APU_TYP                  (29*32+28):(29*32+28) /* RW-VF */
; MCP_ROM_BOOT_APU_TYP_256V                        0x00000000 /* RW--V */
; MCP_ROM_BOOT_IDE_SEC                  (29*32+29):(29*32+29) /* RW-VF */
; MCP_ROM_BOOT_IDE_SEC_IDE                         0x00000000 /* RWI-V */
; MCP_ROM_BOOT_XBOX_ROM_SPEED           (29*32+30):(29*32+30) /* RWIVF */
; MCP_ROM_BOOT_XBOX_ROM_SPEED_SLOW                 0x00000000 /* RWI-V */
; MCP_ROM_BOOT_XBOX_ROM_SPEED_FAST                 0x00000001 /* RW--V */
;
IFDEF SYS_RETAIL
dd 40004400h
ELSE
dd 40000000h
ENDIF
;
; Init table identifier number 
;
IFDEF SYS_DVT4
dd 000000046h            
ELSE
IFDEF SYS_QT
dd 000000070h
ELSE
dd 000000060h
ENDIF
ENDIF
;
; offset from ROM base to the datatbl
;
; IMPORTANT: If size of the init table code below changes, this offset must be adjusted
;
dd DATATBL_BASE_OFFSET   

;
; Force 128 byte alignment MCPX in XBox mode.
;
org 0080h

;//////////////////////////////////////////
;
; NV2A init sequence.
;
;//////////////////////////////////////////

IFDEF SYS_RETAIL
nv_command_struct <COMMAND_UNUSED1, 000081000h, 001h>   
nv_command_struct <COMMAND_UNUSED2, 0000114h, 0228h>   
ENDIF

        
;
; Setup the IO BAR in MCP.  MCP_LEG_CFG_4 below evaluates to different
; values based on MCP rev we are building for. 
;
nv_command_struct<COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_4, 8001h>  

;
; Enable the IO space
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_1, 3h>          

;
; Disable the TCO timer
;
nv_command_struct <COMMAND_OUT_BYTE,      08049h,     8h> 

;
; Also, the KBDRSTIN# signal should've been pulled low on XBox. It wasn't and
; was left floating. As a workaround, will change the mode to be a GPIO.
;
nv_command_struct <COMMAND_OUT_BYTE,      080D9h,     0h>       ; KBDRSTIN# in GPIO mode
nv_command_struct <COMMAND_OUT_BYTE,      08026h,     1h>       ; disable PWRBTN# in PM26

;
; First, we have to gain access to the integrated NV20. This involves
; enabling intergrated graphics and setting up the NB P2P to configure
; Bus2.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_19, CR_APC_P2P_19_NV20_ENABLE>    ; internal graphics enabled
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_6,  CR_APC_P2P_6_SUB_SEC_PRI_BUS> ; setup secondary bus 1

;
; Now, config cycles to graphics should work. Setup the memory base/limit
; on the P2P and the BAR0 of the integrated graphics, so we can access priv
; regs. Enable BUS_MASTER and MEM/IO space accesses for NV20 and P2P.
;
; Note, because of a limitation in COMMAND_READ_MEM, we can't read from an
; address larger than 28bits, so we need to make our register base mapping
; under this (0x0D000000), but there's likely kernel code that assumes we're
; at 0xFD000000, so we'll reload to this address at the end of the inittbl.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_128MB>    ; for proper P2P addr decode

nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_8,  CR_APC_P2P_8_MLIMIT_MBASE_INIT>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_9,  CR_APC_P2P_9_PREF_MLIMIT_MBASE>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_4, NV20_REG_BASE>    ; set register BAR0
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_5, NV20_FB_BASE>     ; set framebuffer BAR1
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_1, CR_NV20_PCI_1_BUS_MSTR_MEM_IO>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_1,  CR_APC_P2P_1_BUS_MSTR_MEM_IO>  ; enable spaces

;
; Also, setup the PBUS_DEBUG_CTRIM values
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (pbus_ctrim_A2-$-4)>    ; (rev >= A2)
;
pbus_ctrim_A1:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_0),    007633451h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_6),    000000000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0FFFF0000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_7),    000000005h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (pbus_ctrim_common-$-4)>

pbus_ctrim_A2:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_0),    007633461h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_6),    066660000h>

IFDEF SYS_DVT6
;
; PBUS_DEBUG_CTRIM_2 is different between Samsung/Micron
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000C0000h, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0h, (samsung_ctrim2-$-4)> 

micron_ctrim2:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0EEEE0000h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (ctrim_continue-$-4)>

samsung_ctrim2:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0FFFF0000h>

ctrim_continue:
ELSE
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    000000000h>
ENDIF
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_7),    000000009h>

pbus_ctrim_common:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_1),    000000000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_3),    000005866h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_4),    00351C858h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_5),    030007D67h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_8),    000000000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_9),    0A0423635h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_10),   00C6558C6h>

;
; Before we do MRS_EXT/EMRS_EXT cycles, make sure we've enabled the external bank
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),              003070103h>

;
; Setup WBC High water mark 
; The NV_PFB_WBC_HWM field should always be set no greater than 0x17
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_WBC),               011000016h>

;
; FB Arbitration settings 
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_XFER_SZ),       084848888h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_TIMEOUT),       0FFFFCFFFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_PREDIVIDER),    01h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_DIFF_BANK),     0DFh>


;
; Update PEXTDEV_BOOT_0 (if A01)
;
;    0x80354C01 = turn on the override, disables AGP SBA/FW
;    0x803D4C01 = also sets EMRS_MATCHED
;    0x803D4C01 = no fast writes
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (skip_strap_override-$-4)>    ; (rev >= A2)

nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0),        0803D4401h>
skip_strap_override:

;
; Setup the SMBus for talking to the encoder.
;
; On the DVT boards controller 0 isn't used, so only setup controller 1. Besides
; enabling IO's, we'll also convert the pins from GPIOs to SMBus clk/data. This
; need to be done early during boot, so there's a pixclk before setting NVCLK.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_1,     MCP_SMB_CFG_1_IO_SPACE>
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_5,     MCP_SMB_CFG_5_IO_BASE>
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_6,     MCP_SMB_CFG_6_IO_BASE>
nv_command_struct <COMMAND_OUT_BYTE,      SMB_DDC_SPIO_BASE, 70h>    ; converts from GPIO

IFNDEF FOCUS                                                                          
;
; Now, make sure the TV encoder is driving a pixclk.
;
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 08Ah>    ; CX871 slave addr

; CX871 offset 0xBA = 0x3F
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0BAh>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 03Fh>    ; turn on slave bit
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0x6C = 0x46
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 06Ch>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 046h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; write byte kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xB8 = 0x0
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0B8h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 000h>    ; autoconfig
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xCE = 0x19
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0CEh>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 019h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xC6 = 0x9C
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0C6h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 09Ch>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0x32 = 0x08
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 032h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 008h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xC4 = 0x01
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0C4h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 001h>    ; enable clk output
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

ENDIF


IFDEF SYS_RETAIL
;
; Verify SMC revision
;
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 020h>     ; SMC slave write addr
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 001h>     ; SMC revision register
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 000h>     ; Clear SMC rev pointer
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff
nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status

nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 021h>    ; SMC slave read addr
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 001h>    ; read revision register
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
nv_command_struct <COMMAND_IN_BYTE, SMB_CONTROL_BASE+6, DONT_CARE>   ; get the result

nv_command_struct <COMMAND_COMPARE_RESULT_JNE, DESIRED_SMC_VER, (SmcIsWrong-$-4)> ; if smc is bad
nv_command_struct<COMMAND_JMP, DONT_CARE, (SmcIsOK-$-4)>          ; smc is fine

SmcIsWrong:
;
; SMC is bad, flatline the clocks
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 001000000h>  

SmcIsOK:

ENDIF

;
; Set NVCLK (M, N, P may need adjusting if integrated NV20 VCOs are different)
;    0x0001ED08 = 200MHz
;    0x00011701 = 155MHz    (rev == 0xA01)
;    0x00011C01 = 189MHz
;    0x00011E01 = 202.5MHz   (rev >= 0xA02)
;    0x00011F01 = 209.25MHz  (rev >= 0xA02)
;    0x00014502 = 229.5MHz   (rev >= 0xA02 and 1.7V w/ fansink DVT3)
;
;nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      00001ED08h>
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (nvclk_200-$-4)>    ; (rev >= A2)

nvclk_155:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      000011701h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (pll_select-$-4)>

nvclk_200:

nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      000011C01h>

pll_select:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_PLL_COEFF_SELECT), 0000A0400h>

;
; Disable FBIO/TVD calibration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CALEN),  NV_PBUS_FBIO_CALEN_OFF>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CALSEL), NV_PBUS_FBIO_CALSEL_VALUE>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_TVDIO_CALEN), NV_PBUS_TVDIO_CALEN_OFF>

;
; Set the ADR_EDGE_HALF bit in FBIO_CFG
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CFG), 000000010h>

;
; DRAM configuration
;
; Determine Samsung vs Micron by checking NV_PEXTDEV_BOOT_0_STRAP_EMRS (19:18)
; 0=Micron, 3=Samsung
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000C0000h, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0h, (samsung_memory-$-4)> 

;
; Configure for Micron
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DLY),    028282828h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRDRV), 088888888h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (memory_pad_config-$-4)>

samsung_memory:
;
; Configure for Samsung
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DLY),    009090909h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRDRV), 0AAAAAAAAh> 

memory_pad_config:

;
; Memory PAD configuration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CLKDRV), 0FFFFFFFFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DATDRV), NV_PBUS_FBIO_DATDRV_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DQSDRV), NV_PBUS_FBIO_DQSDRV_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRSLW), NV_PBUS_FBIO_ADRSLW_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CLKSLW), 0FFFFFFFFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DATSLW), NV_PBUS_FBIO_DATSLW_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DQSSLW), NV_PBUS_FBIO_DQSSLW_INIT>

;
; RAM Initialization (XXX should we be waiting for cmds to complete?)
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_PRE),      NV_PFB_PRE_CMD_PRECHARGE_1>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_EMRS),     000100042h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_EMRS_EXT), 000100042h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      000000011h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  000000011h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      000000032h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  000000032h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      NV_PFB_MRS_DLL_RESET>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  NV_PFB_MRS_EXT_DLL_RESET>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REF),      000000001h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REF),      000000001h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REFCTRL),  NV_PFB_REFCTRL_VALID_1>

;
; Display PAD configuration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DISPIO_PADCTL), NV_PBUS_DISPIO_PADCTL_INIT>

;
; TVD PAD configuration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_TVDIO_PADCTL), NV_PBUS_TVDIO_PADCTL_INIT>

;
; Change PFB_TIMING2 and PBUS_FBIO_RAM
;
; NV_PFB_TIMING2 = 0x081202FF
;                = 0x081205FF    (increase REFRESH count with M=1, N=9, MEMPDIV=2)
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_TIMING2),   0081205FFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_RAM), 000010000h>

;
; Tell MCP not to generate INIT# in response to the shutdown cycle 
;
nv_command_struct<COMMAND_PCI_CFG_READ, MCP_LEG_CFG_24, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0FFFFFFFFh, 000000400h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_24>

;
; Init ISO/non-ISO bits for the various MCP unit IDs
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_19, 00000FDDEh>

;
; Make sure the USB PLL has the correct value (not the POR value).
;
; nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_39, 0851CAA0Ch>
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_39, 0871CC707h>

;
; Set the maximum PCICLK_OUT5 trim (bits 11:8 = 0xF).
;
nv_command_struct<COMMAND_PCI_CFG_READ, MCP_LEG_CFG_45, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFF0FFh, 000000F00h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_45>

;
; Set cshape/ctrim for clocks in CR_top.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_0, 0F0F0C0C0h>    ; A03
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_1, 000C00000h>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_7, 004070000h>

;
; These values have been set by the straps, but we'll write them into the
; CR_CPU_MPLL_COEFF register, so the values are knowable outside the ROM.
;
; Currently, we have MEM_PDIV of 3, which is 133MHz and will be left that
; way for A01. For A02, we set the MEM_PDIV to 2, which sets a 200MHz mclk.
;
;    (0x230901: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = 9;  MDIV = 1)
;    (0x230A01: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = A;  MDIV = 1)
;    (0x231D03: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = 1D; MDIV = 3)
;
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230901h>
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230901h>    ; 182MHz
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000231D03h>    ; 200MHz
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230A01h>    ; 202MHz
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (mclk_200-$-4)>    ; (rev >= A2)
nv_command_struct<COMMAND_JMP, DONT_CARE, (mclk_133-$-4)>              ; (rev == A1)

mclk_133:
mclk_200:
;
; Set the clocks and override. CR_CPU_MPLL_COEFF must be set once without override
; and then again with override. 
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230801h>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 001230801h>  

;
; Delay ~15 nano seconds by performing jmps
; 
nv_command_struct< COMMAND_JMP, DONT_CARE, (DelayJump1-$-4) >
DelayJump1:
nv_command_struct< COMMAND_JMP, DONT_CARE, (DelayJump2-$-4) >
DelayJump2:

; MEMORY TEST
; 
; This section does memory detection and test, and then updates
; the memory config registers and reports this config (and memory errors) back
; to the SMC.
;
; First, this is how the addressing works, with 12 row bits and an
; external bank:
;
;    E[0:0],R[11:10] | R[9:6] | R[5:2] | R[1:0],B[1:0] | C[7:4] | C[3:2],P[1:0] | C[1:0],00
;
; We determine a particular DRAMs number of row bits (11 or 12) by toggling
; the R11 bit and looking for an alias within the DRAM (row address bit doesn't
; exist with the 2Mx32 parts).
;
; For row detection with the first 4 DRAM partitions (MEM_PART_0 -> MEM_PART_3),
; we'll address at 0x2500000 (R11 = 1, ext_bank = 0) and cycle the partition bits.
; For the second set of DRAMS (MEM_PART_4 -> MEM_PART_7), we'll address at
; 0x6500000 (R11 = 1, ext_bank = 1).
;
; In addition to row detection, we'll update the SMC controller with the number
; of 2Mx32 and 4Mx32 DRAMS and any memory errors we've found. We use the 2 USB
; registers as scratchpad (reset to 0 and later overwritten by the kernel).
;
;    rows = 2^12, cols = 2^8, banks = 2^2, external bank
;


nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG1),  011448000h>

;
; Clear the scratchpad registers used in memory test
;
nv_command_struct<COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE, 0>
nv_command_struct<COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT, 0>

;-------------------------------------------------------------------------------
dram0:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram0_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram0_alt_write-$-4)>

dram0_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000001h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram0_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram0_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram1-$-4)>

dram0_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000001h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram1:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram1_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram1_alt_write-$-4)>

dram1_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000002h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram1_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram1_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram2-$-4)>

dram1_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000002h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram2:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram2_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram2_alt_write-$-4)>

dram2_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000004h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram2_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram2_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram3-$-4)>

dram2_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000004h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram3:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram3_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram3_alt_write-$-4)>

dram3_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000008h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram3_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram3_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram4-$-4)>

dram3_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000008h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram4:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram4_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram4_alt_write-$-4)>

dram4_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000010h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram4_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram4_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram5-$-4)>

dram4_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000010h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram5:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram5_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram5_alt_write-$-4)>

dram5_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000020h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram5_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram5_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram6-$-4)>

dram5_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000020h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram6:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram6_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram6_alt_write-$-4)>

dram6_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000040h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram6_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram6_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram7-$-4)>

dram6_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000040h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram7:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram7_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram7_alt_write-$-4)>

dram7_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000080h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram7_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram7_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (memtest_done-$-4)>

dram7_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000080h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


memtest_done:
;
; Start by assuming we're using a 4Mx32, 64MB config (no external bank).
; We've already set rows = 2^12, so clear the external bank bit.
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070003h>
nv_command_struct<COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_64MB>

;
; Read out our bitmask of 4Mx32 parts into the SMBus register and update our
; memory config, if necessary.
; 
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0000000FFh, 000000000h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6>

nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE+6, DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 000000000h, (dram_4M-$-4)>

; Reset back to 11 row bits and add back the external bank bit
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>    ; extbank bit
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG1),  011338000h>    ; 11 row bits
nv_command_struct<COMMAND_JMP, DONT_CARE, (mem_report-$-4)>

dram_4M:
; We've got some 4Mx32 parts, check if we're a 128MB config?
nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE+6, DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0000000FFh, (mem_report-$-4)>

; Add back the external bank bit and update MEMTOP
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>    ; extback bit
nv_command_struct<COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_128MB>


mem_report:

;
; Report the results to the SMC
;
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 020h>     ; SMC slave addr

;
; Send Memory Type (already in SMB_CONTROL_BASE+6) to SMC
;
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 013h>     ; SMC Register
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff

nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status

;
; Send Memory test results to SMC
;
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0000000FFh, 000000000h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6>

nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 012h>     ; SMC Register
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff

nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status

mem_report_end:


;
; Reload the NV20 register base (should be just prior to COMMAND_QUIT)
; to what the kernel expects.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_8,  CR_APC_P2P_8_MLIMIT_MBASE_KERNEL>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_4, NV20_REG_BASE_KERNEL>

; End of table.  First argument is used as the value for the default MTRR register
;
nv_command_struct <COMMAND_QUIT, 0806h, DONT_CARE>

;
; Drive/Slew Parameter Offset and Data.  Boot loader needs to access this data
; 

org DATATBL_BASE_OFFSET  

;DATATBL_DRVSLWPARAM_OFFSET   EQU DATATBL_BASE_OFFSET+0

;-----------------------------------------------------------------------------

DrvSlwParamBegin:
;
; Common calibration data
;
dw    20000    ; MaxMClk (230Mhz)
;
; Operating condition based on speedometer
;     (Count is from VCCQ; CountB is from VCC)
;

;
; 16.6 clock
;

db    4Eh      ; SlowCountExt
db    3Eh      ; SlowCountBExt

db    56h      ; SlowCountAvg
db    43h      ; SlowCountBAvg

db    5Dh      ; TypiCount
db    4Ah      ; TypiCountB

db    64h      ; FastCountAvg
db    50h      ; FastCountBAvg

db    6Ah      ; FastCountExt
db    55h      ; FastCountBExt

;-----------------------------------------------------------------------------
;
; Samsung Extreme FAST values 
;
db    09h      ; AdrDrvFallFastExt
db    09h      ; AdrDrvRiseFastExt
db    0Eh      ; AdrSlwFallFastExt
db    08h      ; AdrSlwRiseFastExt

db    0Fh      ; ClkDrvFallFastExt
db    0Fh      ; ClkDrvRiseFastExt
db    0Fh      ; ClkSlwFallFastExt
db    0Fh      ; ClkSlwRiseFastExt

db    09h      ; DatDrvFallFastExt
db    09h      ; DatDrvRiseFastExt
db    0Eh      ; DatSlwFallFastExt
db    08h      ; DatSlwRiseFastExt

db    09h      ; DqsDrvFallFastExt
db    09h      ; DqsDrvRiseFastExt
db    0Eh      ; DqsSlwFallFastExt
db    08h      ; DqsSlwRiseFastExt

IFDEF SYS_DVT6
db    01h      ; DataInbDelyFastExt
db    00h      ; ClkIcDelyFastExt
db    00h      ; DqsInbDelyFastExt
ELSE
db    00h      ; DataInbDelyFastExt
db    00h      ; ClkIcDelyFastExt
db    01h      ; DqsInbDelyFastExt
ENDIF
;
; Samsung Average FAST values
;
db    09h      ; AdrDrvFallFastAvg
db    09h      ; AdrDrvRiseFastAvg
db    0Eh      ; AdrSlwFallFastAvg
db    08h      ; AdrSlwRiseFastAvg

db    0Fh      ; ClkDrvFallFastAvg
db    0Fh      ; ClkDrvRiseFastAvg
db    0Fh      ; ClkSlwFallFastAvg
db    0Fh      ; ClkSlwRiseFastAvg

db    09h      ; DatDrvFallFastAvg
db    09h      ; DatDrvRiseFastAvg
db    0Eh      ; DatSlwFallFastAvg
db    08h      ; DatSlwRiseFastAvg

db    09h      ; DqsDrvFallFastAvg
db    09h      ; DqsDrvRiseFastAvg
db    0Eh      ; DqsSlwFallFastAvg
db    08h      ; DqsSlwRiseFastAvg

IFDEF SYS_DVT6
db    01h      ; DataInbDelyFastAvg
db    01h      ; ClkIcDelyFastAvg
db    00h      ; DqsInbDelyFastAvg 
ELSE
db    00h      ; DataInbDelyFastAvg
db    01h      ; ClkIcDelyFastAvg
db    01h      ; DqsInbDelyFastAvg 
ENDIF
;
; Samsung Typical values
;
db    09h      ; AdrDrvFallTypi
db    09h      ; AdrDrvRiseTypi
db    0Eh      ; AdrSlwFallTypi
db    08h      ; AdrSlwRiseTypi

db    0Fh      ; ClkDrvFallTypi
db    0Fh      ; ClkDrvRiseTypi
db    0Fh      ; ClkSlwFallTypi
db    0Fh      ; ClkSlwRiseTypi

db    09h      ; DatDrvFallTypi
db    09h      ; DatDrvRiseTypi
db    0Eh      ; DatSlwFallTypi
db    08h      ; DatSlwRiseTypi

db    09h      ; DqsDrvFallTypi
db    09h      ; DqsDrvRiseTypi
db    0Eh      ; DqsSlwFallTypi
db    08h      ; DqsSlwRiseTypi

IFDEF SYS_DVT6
db    01h      ; DataInbDelyTypi
db    02h      ; ClkIcDelyTypi
db    00h      ; DqsInbDelyTypi
ELSE
db    00h      ; DataInbDelyTypi
db    02h      ; ClkIcDelyTypi
db    01h      ; DqsInbDelyTypi
ENDIF
;
; Samsung Average SLOW values
;
db    0Ah      ; AdrDrvFallSlowAvg
db    0Bh      ; AdrDrvRiseSlowAvg
db    0Eh      ; AdrSlwFallSlowAvg
db    08h      ; AdrSlwRiseSlowAvg

db    0Fh      ; ClkDrvFallSlowAvg
db    0Fh      ; ClkDrvRiseSlowAvg
db    0Fh      ; ClkSlwFallSlowAvg
db    0Fh      ; ClkSlwRiseSlowAvg

db    0Ah      ; DatDrvFallSlowAvg
db    0Bh      ; DatDrvRiseSlowAvg
db    0Eh      ; DatSlwFallSlowAvg
db    08h      ; DatSlwRiseSlowAvg

db    0Ah      ; DqsDrvFallSlowAvg
db    0Bh      ; DqsDrvRiseSlowAvg
db    0Eh      ; DqsSlwFallSlowAvg
db    08h      ; DqsSlwRiseSlowAvg

IFDEF SYS_DVT6
db    01h      ; DataInbDelySlowAvg
db    02h      ; ClkIcDelySlowAvg
db    00h      ; DqsInbDelySlowAvg
ELSE
db    00h      ; DataInbDelySlowAvg
db    02h      ; ClkIcDelySlowAvg
db    01h      ; DqsInbDelySlowAvg
ENDIF
;
; Samsung Extreme SLOW values
;
db    0Bh      ; AdrDrvFallSlowExt
db    0Eh      ; AdrDrvRiseSlowExt
db    0Eh      ; AdrSlwFallSlowExt
db    08h      ; AdrSlwRiseSlowExt

db    0Fh      ; ClkDrvFallSlowExt
db    0Fh      ; ClkDrvRiseSlowExt
db    0Fh      ; ClkSlwFallSlowExt
db    0Fh      ; ClkSlwRiseSlowExt

db    0Bh      ; DatDrvFallSlowExt
db    0Eh      ; DatDrvRiseSlowExt
db    0Eh      ; DatSlwFallSlowExt
db    08h      ; DatSlwRiseSlowExt

db    0Bh      ; DqsDrvFallSlowExt
db    0Eh      ; DqsDrvRiseSlowExt
db    0Eh      ; DqsSlwFallSlowExt
db    08h      ; DqsSlwRiseSlowExt

IFDEF SYS_DVT6
db    01h      ; DataInbDelySlowExt
db    03h      ; ClkIcDelySlowExt
db    00h      ; DqsInbDelySlowExt
ELSE
db    00h      ; DataInbDelySlowExt
db    03h      ; ClkIcDelySlowExt
db    01h      ; DqsInbDelySlowExt
ENDIF
;-----------------------------------------------------------------------------
;
; Micron Extreme FAST values
;
db    08h      ; AdrDrvFallFastExt
db    08h      ; AdrDrvRiseFastExt
db    0Eh      ; AdrSlwFallFastExt
db    08h      ; AdrSlwRiseFastExt

db    0Fh      ; ClkDrvFallFastExt
db    0Fh      ; ClkDrvRiseFastExt
db    0Fh      ; ClkSlwFallFastExt
db    0Fh      ; ClkSlwRiseFastExt

db    09h      ; DatDrvFallFastExt
db    09h      ; DatDrvRiseFastExt
db    0Eh      ; DatSlwFallFastExt
db    08h      ; DatSlwRiseFastExt

db    09h      ; DqsDrvFallFastExt
db    09h      ; DqsDrvRiseFastExt
db    0Eh      ; DqsSlwFallFastExt
db    08h      ; DqsSlwRiseFastExt

db    00h      ; DataInbDelyFastExt
db    01h      ; ClkIcDelyFastExt
db    01h      ; DqsInbDelyFastExt
;
; Micron Average FAST values
;
db    08h      ; AdrDrvFallFastAvg
db    08h      ; AdrDrvRiseFastAvg
db    0Eh      ; AdrSlwFallFastAvg
db    08h      ; AdrSlwRiseFastAvg

db    0Fh      ; ClkDrvFallFastAvg
db    0Fh      ; ClkDrvRiseFastAvg
db    0Fh      ; ClkSlwFallFastAvg
db    0Fh      ; ClkSlwRiseFastAvg

db    09h      ; DatDrvFallFastAvg
db    09h      ; DatDrvRiseFastAvg
db    0Eh      ; DatSlwFallFastAvg
db    08h      ; DatSlwRiseFastAvg

db    09h      ; DqsDrvFallFastAvg
db    09h      ; DqsDrvRiseFastAvg
db    0Eh      ; DqsSlwFallFastAvg
db    08h      ; DqsSlwRiseFastAvg

db    00h      ; DataInbDelyFastAvg
db    01h      ; ClkIcDelyFastAvg
db    01h      ; DqsInbDelyFastAvg 
;
; Micron Typical values
;
db    08h      ; AdrDrvFallTypi
db    08h      ; AdrDrvRiseTypi
db    0Eh      ; AdrSlwFallTypi
db    08h      ; AdrSlwRiseTypi

db    0Fh      ; ClkDrvFallTypi
db    0Fh      ; ClkDrvRiseTypi
db    0Fh      ; ClkSlwFallTypi
db    0Fh      ; ClkSlwRiseTypi

db    09h      ; DatDrvFallTypi
db    09h      ; DatDrvRiseTypi
db    0Eh      ; DatSlwFallTypi
db    08h      ; DatSlwRiseTypi

db    09h      ; DqsDrvFallTypi
db    09h      ; DqsDrvRiseTypi
db    0Eh      ; DqsSlwFallTypi
db    08h      ; DqsSlwRiseTypi

db    00h      ; DataInbDelyTypi
db    01h      ; ClkIcDelyTypi
db    01h      ; DqsInbDelyTypi
;
; Micron Average SLOW values
;
db    08h      ; AdrDrvFallSlowAvg
db    08h      ; AdrDrvRiseSlowAvg
db    0Eh      ; AdrSlwFallSlowAvg
db    08h      ; AdrSlwRiseSlowAvg

db    0Fh      ; ClkDrvFallSlowAvg
db    0Fh      ; ClkDrvRiseSlowAvg
db    0Fh      ; ClkSlwFallSlowAvg
db    0Fh      ; ClkSlwRiseSlowAvg

db    0Ah      ; DatDrvFallSlowAvg
db    0Bh      ; DatDrvRiseSlowAvg
db    0Eh      ; DatSlwFallSlowAvg
db    08h      ; DatSlwRiseSlowAvg

db    0Ah      ; DqsDrvFallSlowAvg
db    0Bh      ; DqsDrvRiseSlowAvg
db    0Eh      ; DqsSlwFallSlowAvg
db    08h      ; DqsSlwRiseSlowAvg

db    00h      ; DataInbDelySlowAvg
db    01h      ; ClkIcDelySlowAvg
db    01h      ; DqsInbDelySlowAvg
;
; Micron Extreme SLOW values
;
db    08h      ; AdrDrvFallSlowExt
db    08h      ; AdrDrvRiseSlowExt
db    0Eh      ; AdrSlwFallSlowExt
db    08h      ; AdrSlwRiseSlowExt

db    0Fh      ; ClkDrvFallSlowExt
db    0Fh      ; ClkDrvRiseSlowExt
db    0Fh      ; ClkSlwFallSlowExt
db    0Fh      ; ClkSlwRiseSlowExt

db    0Bh      ; DatDrvFallSlowExt
db    0Eh      ; DatDrvRiseSlowExt
db    0Eh      ; DatSlwFallSlowExt
db    08h      ; DatSlwRiseSlowExt

db    0Bh      ; DqsDrvFallSlowExt
db    0Eh      ; DqsDrvRiseSlowExt
db    0Eh      ; DqsSlwFallSlowExt
db    08h      ; DqsSlwRiseSlowExt

db    00h      ; DataInbDelySlowExt
db    01h      ; ClkIcDelySlowExt
db    01h      ; DqsInbDelySlowExt

DrvSlwParamEnd:

DB   'Copyright (c) Microsoft Corporation. All rights reserved.'


CODE ENDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\inittbl2\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_ret.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\inittbl3\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt4.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt4.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt4.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\rstartup.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    rstartup.asm
;
; Abstract:
;
;    The module implements code to put the processor in protected mode.  This code executes
;    at processor reset vector
;
; Environment:
;
;    16-bit Real Mode
;
;--

; ==========================================================================

        .586p

        .xlist
        INCLUDE bldr.inc
        INCLUDE ks386.inc
        .list
        INCLUDE chipset.inc


_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE' 
        ASSUME  CS:_TEXT, DS:_TEXT, SS:_TEXT, ES:NOTHING


        PUBLIC  Startup16

;
; NOTE: Following ORG is hardcoded.  Changing any code below requires changing the ORG value
; so that the processor init always lines up at FFF0. To calculate this value, subtract the value of
; CodeSoFar label in the .lst file from FFF0 
;

IFDEF MCP_REV_B01
        ORG     0FFBCh  
ELSE    
        ORG     0FFB8h
ENDIF   


Startup16:

;
; Load the processor's global descriptor table by executing a 32-bit lgdt
;

        db      066h
        lgdt    cs:[RomDecGDTFWORD]
        
IFNDEF MCP_REV_B01
;
; Load the processor's interrupt descriptor table by executing a 32-bit lidt
; We point it to the same structure as the gdt to force the idt limit to be
; very small thus limiting the processor's capability to execute interrupt
; and fault handlers
;

        db      066h
        lidt    cs:[RomDecGDTFWORD]

ENDIF

;
; Enable the processor's protected mode support 
;

        mov     eax, cr0
        or      al, CR0_PE
        mov     cr0, eax

;
; Execute a 16:32 jump to the 32-bit part of romdec which is 512 bytes from 
; top of the address space
;

        db      066h, 0EAh
        dd      0FFFFFE00h
        dw      KGDT_R0_CODE
   

;
; NOTE: The linear address of this table is hardcoded in RomDecGDTFWORD below.  Changing the
; the size of this table requires updating the address
;
        ALIGN   4
RomDecGDT LABEL DWORD
        dd      0                       ; KGDT_NULL
        dd      0
        dd      00000FFFFh              ; KGDT_R0_CODE
        dd      000CF9B00h
        dd      00000FFFFh              ; KGDT_R0_DATA
        dd      000CF9300h
RomDecGDTEnd LABEL DWORD


;
; Processor will start executing code here which must be at FFFF_FFF0
;

ProcessorInit:
       
        CodeSoFar = (ProcessorInit - Startup16)

;
; Jump to the start of 16-bit code
;
        jmp     Startup16                    

;
; FWORD to initialize the processor's descriptor tables.
;

        ALIGN   4
RomDecGDTFWORD LABEL FWORD
        dw      OFFSET RomDecGDTEnd - OFFSET RomDecGDT    

        dd      0FFFFFFD8h

;
; The 32-bit part of the RomDec jumps to this code located FFFF FFFA.  This code finishes the PCI
; cycle that was started by the 32-bit code to turn of the Southbridge ROM.  Turning off SB ROM causes
; the next instruction being executed fetched from main ROM.  This code causes the next instruction 
; to fall outside of the the address space causing an unhandled exception to occur so
; we don't execute any code from main ROM
;
; The processor will be in Protected Mode while executing this code.  This code must always ORG to FFFA.
;
ShutdownEnd:
        add     dl, 04h
        mov     al, 2
        out     dx, al

_TEXT ENDS


; ==========================================================================

        END Startup16
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\i386\romdec32.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    romdec.asm
;
; Abstract:
;
;    The module decrypts the ROM loader
;
; Environment:
;
;    32-bit Protected Mode
;
;--

; ==========================================================================

        .586p

        .xlist
        INCLUDE bldr.inc
        INCLUDE ks386.inc
        .list
        
        INCLUDE chipset.inc
        

_TEXT   SEGMENT PARA USE32 PUBLIC 'CODE'
        ASSUME  DS:_TEXT, ES:_TEXT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        PUBLIC  _Startup32

_Startup32 PROC

;
; Setup segment registers
;       
        xor     eax, eax
        mov     al, KGDT_R0_DATA
        
        mov     ds, eax
        mov     es, eax
        mov     ss, eax


;
; Initialize chipset and RAM by parsing the init table
;
        INCLUDE command.inc
        INCLUDE initcode.inc

;
; Setup MTRRs and enable caching.  EBX was setup by the COMMAND_QUIT
; command in the init table and is supposed to contain the value
; used for default MTRR register
;
        xor     ecx, ecx
        mov     ch, 02h
        xor     eax, eax
        xor     edx, edx
@@:
        wrmsr
        inc     ecx
        cmp     cl, 0Fh
        jbe     @B

;
; Enable MTRR, disable fix-range MTRRs and set default memory type to UC.
;

        mov     cl, 0FFh
        mov     eax, ebx
        wrmsr

;
; Enable the processor cache by clearing cache disable and not-write-through
; flags in CR0.
;
        mov     eax, cr0
        and     eax, NOT (CR0_CD OR CR0_NW)
        mov     cr0, eax

IFNDEF MCP_XMODE2
IFNDEF MCP_XMODE3P
;
; XMODE3: Decrypt the boot loader.  Destination ROMDEC_OUTPUTBUFFER
;
        INCLUDE encrypt.inc

;
; Check to see if the encryption was successful.  RC4 algorithm does not provide
; success information.  Therefore, we check for a known signature at the end of
; decrypted boot loader
;

        mov     eax, ds:DWORD PTR [ROMDEC_OUTPUTBUFFER + ROMLDR_SIZE - ROMLDR_BOOTPARAMSIZE]
        cmp     eax, ROMLDR_SIGNATURE
        jne     Shutdown

; Jump to the boot loader startup.  The entry point of the boot loader is
; stored as the first DWORD at the decrypted code
;
; NOTE: The content of eax register must be the entry point of the boot
;       loader to indicate that we are not running in XDK box so that
;       boot loader will initialize MTRRs to enable RAM/ROM caching
; stored just prior to the signature in the boot param
;

        mov     eax, ds:DWORD PTR [ROMDEC_OUTPUTBUFFER]
        jmp     eax

ELSE ; XM3P

;
; XMODE3P: Hash the boot loader and verify that its hash is what we expect to find
;
        INCLUDE boothash.inc

; returns with ZF indicating whether we matched the hash
        jnz Shutdown

;
; Jump to the boot loader startup.  The entry point of the boot loader is
; stored just prior to the signature in the boot param
;

        jmp     _Startup32 - ROMPRELDR_SIZE

ENDIF ; XM3P
ELSE ; XM2

;
; XMODE2: Jump to the boot loader startup.  The entry point of the boot loader is
; stored just prior to the signature in the boot param
;

        jmp     _Startup32 - ROMPRELDR_SIZE

ENDIF ; XM2

;
; Sequence of instructions to turn off SB ROM and halt.  The following code
; does not do RMW because the system is shutting down
;
Shutdown:
IFDEF MCP_XMODE2

        hlt
        
ELSE

        mov     eax, 80000880h
        mov     dx, 0CF8h
        out     dx, eax

ENDIF
;
; Now jump to the top of the address space.  The code there will complete the shutdown sequence
;
        db      0EAh
        dd      0FFFFFFFAh
        dw      KGDT_R0_CODE

_Startup32 ENDP

IFNDEF MCP_XMODE2
IFNDEF MCP_XMODE3P
;
; XMODE3: Encryption key placeholder
;
        INCLUDE ENCKEY.INC
ENDIF
ENDIF


_TEXT   ENDS

; ==========================================================================

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\qtdevkit\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_qt.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_qt.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_qt.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\qtretail\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret_qt.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret_qt.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_ret_qt.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\brainbox\bbtype.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    bbtype.cpp

Abstract:
    
    Pluggable table entry for the Brain Box controller device.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    12-03-00 created by Mitchell Dernis (mitchd)

--*/
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <usb.h>
#include "xid.h"
#include "brainbox.h"

// Forward declare
void FASTCALL fProcessBrainBoxData(PXID_OPEN_DEVICE OpenDevice);

//Brain Box 
#define  XID_DEVTYPE_BRAINBOX              0x80
#define  XID_INPUT_REPORT_ID_MAX_BRAINBOX  0
#define  XID_OUTPUT_REPORT_ID_MAX_BRAINBOX 0
#define  XID_DEFAULT_MAX_BRAINBOX          2

DECLARE_XPP_TYPE(XDEVICE_TYPE_BRAINBOX)
XINPUT_BRAINBOX_DATA BrainboxDefaults = {0};  //Everything zero.
XID_REPORT_TYPE_INFO BrainboxInputReportInfoList[1] = {sizeof(XINPUT_BRAINBOX_DATA),(PVOID)&BrainboxDefaults};
WORD bmLEDDefaults[3] = {0};  //All lights are off
XID_REPORT_TYPE_INFO BrainboxOutputReportInfoList[1] = {6,(PVOID)&bmLEDDefaults};
XINPUT_POLLING_PARAMETERS BrainboxDefaultPolling = {TRUE,FALSE,0,8,0,0}; //AutoPoll On, control-OUT

XID_TYPE_INFORMATION  BrainBoxTypeInfo = 
 {XID_DEVTYPE_BRAINBOX, XID_DEFAULT_MAX_BRAINBOX, XID_INPUT_REPORT_ID_MAX_BRAINBOX, XID_OUTPUT_REPORT_ID_MAX_BRAINBOX,
  XDEVICE_TYPE_BRAINBOX, BrainboxInputReportInfoList, BrainboxOutputReportInfoList, &BrainboxDefaultPolling, fProcessBrainBoxData, 0};
     
#pragma data_seg(".XID$BrainBox")
extern "C" ULONG_PTR BrainBoxTypeInfoENTRY = (ULONG_PTR)&BrainBoxTypeInfo;
#pragma data_seg(".XPP$Data")

void
FASTCALL
fProcessBrainBoxData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Processing of brain box data.  Basically, it copies the data
   from the buffer that is ping-ponged to the hardware, to the one
   that is always available for copying from XInputGetState.

   Then it checks to see if anything changes and hits XAutoPowerDownResetTimer
--*/
{
    XINPUT_BRAINBOX_DATA *pBrainBox = (XINPUT_BRAINBOX_DATA *)OpenDevice->Report;
    if(OpenDevice->Urb.CommonTransfer.TransferBufferLength >= XID_REPORT_HEADER)
    {
        RtlCopyMemory(
          (PVOID)pBrainBox,
          (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
          OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
          );

        //
        //  XAutoPowerDownResetTimer if any digital buttons are pressed.
        //  
        int i;
        for(i=0; i<3; i++)
        {
            if(pBrainBox->bmButtons[i])
            {
                XAutoPowerDownResetTimer();
                return;
            }
        }
        //
        //  ??? Should we check any other controls to avoid auto power down. ???
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\enumtest\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_NOSYSLOCK) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\bootx\romdec32\r16\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $<

OBJ=obj\i386\rstartup.obj

obj\i386\rstartup.com: $(OBJ)

obj\i386\rstartup.obj: ..\i386\rstartup.asm

obj\i386\rstartup.com: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
obj\i386\rstartup.com



<<
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\brainbox\brainbox.h ===
//Declare the type
extern   XPP_DEVICE_TYPE       XDEVICE_TYPE_BRAINBOX_TABLE;
#define  XDEVICE_TYPE_BRAINBOX (&XDEVICE_TYPE_BRAINBOX_TABLE)

#include <PSHPACK1.H>
typedef struct _XINPUT_BRAINBOX_DATA
{
    WORD  bmButtons[3];
    WORD  wRightLeverX;
    WORD  wRightLeverY;
    WORD  wLeftLeverX;
    WORD  wUpperLeftLeverX;
    WORD  wUpperLeftLeverY;
    WORD  wFootPedal1;
    WORD  wFootPedal2;
    WORD  wFootPedal3;
    BYTE  bTuner;
    BYTE  bShiftLever;
} XINPUT_BRAINBOX_DATA;

typedef struct _XINPUT_BRAINBOX
{
  DWORD dwPacketNumber;
  XINPUT_BRAINBOX_DATA data;
} XINPUT_BRAINBOX, *PXINPUT_BRAINBOX;

// You can write your own named macros for getting at the digital buttons.
typedef struct _XINPUT_BRAINBOX_LEDS
{
    XINPUT_FEEDBACK_HEADER Header;
    WORD bmLEDs[3];
} XINPUT_BRAINBOX_LEDS, *PXINPUT_BRAINBOX_LEDS;

//UNTIL POST DECEMBER RELEASE DON'T USE GET CAPABILITIES 

#include <POPPACK.H>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\enumtest\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\enumtest\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\enumtest\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ezusbdef\ezusbdef.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ezusbdef.h

Abstract:

    This module contains the public interface for a sample USB class driver.

--*/

#ifndef _EZUSBDEF_
#define _EZUSBDEF_

#ifdef __cplusplus
extern "C" {
#endif

extern XPP_DEVICE_TYPE XDEVICE_TYPE_EZUSBDEF_TABLE;
#define XDEVICE_TYPE_EZUSBDEF (&XDEVICE_TYPE_EZUSBDEF_TABLE)

VOID
WINAPI
EzusbGetDeviceChanges(
    LPDWORD lpdwInsertions,
    LPDWORD lpdwRemovals
    );

DWORD
WINAPI
EzusbFirmwareLoad(
    DWORD dwPort,
    WORD wStartingAddress,
    LPVOID lpvFirmware,
    WORD wNumberOfBytes,
    BOOL fUpload
    );

#ifdef __cplusplus
}
#endif

#endif  // EZUSBDEF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\enumtest\main.cpp ===
#include <xtl.h>
#include "draw.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}
//
// Colors
//
#define BACKDROP_BLUE 0x000080
#define LABEL_WHITE 0xffffff
#define DISCONNECTED_BLUE 0x000040
#define CONNECTED_YELLOW 0xffff00

//
//  Useful Macro
//
#define DECLARE_DO_TWICE int doTwice;
#define DO_TWICE doTwice=2; while(doTwice--)

//
//  Forward Declations
//
void InitDisplay(Draw *pDraw);
void InitDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos);
void UpdateDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos);
LPWSTR DeviceTypeToString(PXPP_DEVICE_TYPE DeviceType);
void DrawPortTopSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos);
void DrawPortBottomSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos);

//------------------------------------------------------------------------------
// TestMain

void __cdecl main()
{
    DebugPrint("ENUMTEST APPLICATION.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    
    //Initialize core peripheral port support
    XDEVICE_PREALLOC_TYPE deviceTypes[] = 
    {
        {XDEVICE_TYPE_GAMEPAD,4},
        {XDEVICE_TYPE_MEMORY_UNIT,8},
        {XDEVICE_TYPE_VOICE_MICROPHONE,4},
        {XDEVICE_TYPE_VOICE_HEADPHONE,4}
    };
    XInitDevices(sizeof(deviceTypes)/sizeof(XDEVICE_PREALLOC_TYPE),deviceTypes);

    Draw draw;
    DWORD dwStateGamePads;
    DWORD dwStateMemoryUnits;
    DWORD dwStateChatButtons;
    DWORD dwStateChatMicrophone;
    DWORD dwStateChatHeadphone;
    InitDisplay(&draw);
    InitDevices(XDEVICE_TYPE_GAMEPAD, dwStateGamePads,  FALSE, &draw,      80);
    InitDevices(XDEVICE_TYPE_MEMORY_UNIT, dwStateMemoryUnits, TRUE, &draw,   100);
    InitDevices(XDEVICE_TYPE_VOICE_MICROPHONE, dwStateChatMicrophone, FALSE, &draw,   130);
    InitDevices(XDEVICE_TYPE_VOICE_HEADPHONE, dwStateChatHeadphone, FALSE, &draw,   150);
    while(1)
    {
        UpdateDevices(XDEVICE_TYPE_GAMEPAD, dwStateGamePads, FALSE, &draw,       80);
        UpdateDevices(XDEVICE_TYPE_MEMORY_UNIT, dwStateMemoryUnits, TRUE, &draw,   100);
        UpdateDevices(XDEVICE_TYPE_VOICE_MICROPHONE, dwStateChatMicrophone, FALSE, &draw,   130);
        UpdateDevices(XDEVICE_TYPE_VOICE_HEADPHONE, dwStateChatHeadphone, FALSE, &draw,   150);
    }
}

void InitDisplay(Draw *pDraw)
{
    DECLARE_DO_TWICE;
    DO_TWICE{
        //Draw the title screen
        pDraw->FillRect(0, 0, 640, 480, BACKDROP_BLUE); 
        pDraw->DrawText(L"USB Enumeration Test Application", 50,  50, LABEL_WHITE);
        pDraw->Present();
    }
}

void InitDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos)
{
    WCHAR FormatBuffer[80];
    DECLARE_DO_TWICE;
    if(fHasBottomSlots)
    {
        DO_TWICE{
            wsprintf(FormatBuffer, L"%ws's(Top):", DeviceTypeToString(DeviceType));
            pDraw->DrawText(FormatBuffer, 55, yPos, LABEL_WHITE);
            wsprintf(FormatBuffer, L"%ws's(Bottom):", DeviceTypeToString(DeviceType));
            pDraw->DrawText(FormatBuffer, 55, yPos+10, LABEL_WHITE);
            pDraw->Present();
        }
    } else
    {
        DO_TWICE
        {
            wsprintf(FormatBuffer, L"%ws's:", DeviceTypeToString(DeviceType));
            pDraw->DrawText(FormatBuffer, 55, yPos, LABEL_WHITE);
            pDraw->Present();
        }
    }
    dwState = XGetDevices(DeviceType);
    DebugPrint("%ws Initial State = 0x%0.8x\n", DeviceTypeToString(DeviceType), dwState);
    DrawPortTopSlotsBitmap(pDraw, dwState, yPos);
    if(fHasBottomSlots) DrawPortBottomSlotsBitmap(pDraw, dwState, yPos+10);
}

void UpdateDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos)
{
    DWORD dwInsertions, dwRemovals;
    //
    //  Only update the text, if something changed.
    //  This is why you want to ask for insertions and removals (last parameter is false)
    //  rather than state, which returns TRUE if anything is attached.
    //
    if(XGetDeviceChanges(DeviceType, &dwInsertions, &dwRemovals))
    {
        dwState &= ~dwRemovals;  //Always process removals first
        dwState |= dwInsertions;
        DebugPrint("%ws Changed, Insert=0x%0.8x, Remove=0x%0.8x, State=0x%0.8x\n", DeviceTypeToString(DeviceType), dwInsertions, dwRemovals, dwState);
        DrawPortTopSlotsBitmap(pDraw, dwState, yPos);
        if(fHasBottomSlots) DrawPortBottomSlotsBitmap(pDraw, dwState, yPos+10);
    }
}

LPWSTR DeviceTypeToString(PXPP_DEVICE_TYPE DeviceType)
{
    if(XDEVICE_TYPE_GAMEPAD == DeviceType) return L"XDEVICE_TYPE_GAMEPAD";
    if(XDEVICE_TYPE_MEMORY_UNIT  == DeviceType) return L"XDEVICE_TYPE_MEMORY_UNIT";
    if(XDEVICE_TYPE_VOICE_MICROPHONE == DeviceType) return L"XDEVICE_TYPE_VOICE_MICROPHONE";
    if(XDEVICE_TYPE_VOICE_HEADPHONE  == DeviceType) return L"XDEVICE_TYPE_VOICE_HEADPHONE";
    return L"XDEVICE_TYPE_????";
}

void DrawPortTopSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos)
/*++
    Draws the state of the top slots of players one to four.
--*/
{
  DECLARE_DO_TWICE;
  DO_TWICE
  {
      ULONG xPos = 250;
      WCHAR PortString[2]=L"0";
      for(int index = 0; index < XGetPortCount(); index++)
      {
        (*PortString)++;        
        pDraw->DrawText(PortString, xPos, yPos, (dwState&(1<<index)) ? CONNECTED_YELLOW : DISCONNECTED_BLUE);
        xPos += 20;
       }
       pDraw->Present();
  }
}

void DrawPortBottomSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos)
/*++
    Draws the state of the bottom slots of players one to four
--*/
{
  DECLARE_DO_TWICE;
  DO_TWICE
  {
      ULONG xPos = 250;
      WCHAR PortString[2]=L"0";
      for(int index = 0; index < XGetPortCount(); index++)
      {
        (*PortString)++;        
        pDraw->DrawText(PortString, xPos, yPos, (dwState&(1<<(index+16))) ? CONNECTED_YELLOW : DISCONNECTED_BLUE);
        xPos += 20;
       }
       pDraw->Present();
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\hawk\hawk2.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.CPP

Abstract:


Environment:

    kernel mode

Revision History:


--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "hawk2.h"

#include "xvocver.h"

#if DBG || DEBUG_LOG

    ULONG               HawkDebugLevel=2;     // Level of debug output

#endif

//------------------------------------------------------------------------------
//  Declaration of static tables
//------------------------------------------------------------------------------
XHawkMediaObject *XHawkMediaObject::sm_pMicrophones = NULL;
XHawkMediaObject *XHawkMediaObject::sm_pHeadphones = NULL;
USHORT            XHawkMediaObject::sm_AvailableHeadphoneResources = 0;
USHORT            XHawkMediaObject::sm_AvailableMicrophoneResources = 0;
PHAWK_STREAMING_RESOURCES XHawkMediaObject::sm_pFreeStreamingResources = NULL;
HAWK_SAMPLE_RATE_INFORMATION XHawkMediaObject::sm_HawkSampleRates[HAWK_SAMPLE_RATE_COUNT] = 
{
    { 8000, 16, 0},     // 8.000 kHz
    {11025, 22, 40},    //11.025 kHz
    {16000, 32, 0},     //16.000 kHz
    {22050, 44, 20},    //22.050 kHz
    {24000, 48, 0}      //24.000 kHz
};
PUCHAR XHawkMediaObject::sm_pRateIndices = NULL;
PUCHAR XHawkMediaObject::sm_pRateIndexRefCounts = NULL;

//------------------------------------------------------------------------------
//  Declare Hawk types and class.
//------------------------------------------------------------------------------
DECLARE_XPP_TYPE(XDEVICE_TYPE_VOICE_MICROPHONE)
DECLARE_XPP_TYPE(XDEVICE_TYPE_VOICE_HEADPHONE)
USB_DEVICE_TYPE_TABLE_BEGIN(Hawk)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_VOICE_MICROPHONE),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_VOICE_HEADPHONE)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(Hawk, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(Hawk, 1, XBOX_DEVICE_CLASS_AUDIO_DEVICE, 0xFF, 0xFF)

#pragma data_seg(".XPP$ClassHawk")
USB_CLASS_DECLARATION_POINTER(Hawk)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(Hawk, 1)
#pragma data_seg(".XPP$Data")

USB_RESOURCE_REQUIREMENTS HAWK_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_HIGH_POWER, 0, 2, 1, 0, 0, 0, 0, 2, HAWK_ISOCH_MAX_ATTACH_BUFFERS};

//------------------------------------------------------------------------------
// USB Class Driver Interface
//------------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID
HawkInit (IUsbInit *pUsbInit)
{
    DBGPRINT(3, ("enter: HawkInit\n"));
    ULONG MicrophoneCount;
    ULONG HeadphoneCount; 
    
    //sentry against double init, required because we have two driver
    //table entries (look in the tables above) - this is still in there to support some older firmware.
    #pragma BUGBUG("Supporting USB_DEVICE_CLASS_AUDIO for old Hawk FW, we don't support any USB audio, so this must go at some point.")
    static BOOL fInitialized = FALSE;
    if(fInitialized) return;
    fInitialized = TRUE;

    
    if(pUsbInit->UseDefaultCount())
    {
        MicrophoneCount = HAWK_DEFAULT_MAX_OPENED;
        HeadphoneCount = HAWK_DEFAULT_MAX_OPENED;
    } else
    {
        MicrophoneCount = pUsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_VOICE_MICROPHONE);
        HeadphoneCount = pUsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_VOICE_HEADPHONE);
        ULONG ulMaxPorts = XGetPortCount();
        RIP_ON_NOT_TRUE_WITH_MESSAGE(MicrophoneCount <= ulMaxPorts, "XInitDevices: requested more XDEVICE_TYPE_VOICE_MICROPHONE than available ports.");
        if(MicrophoneCount > ulMaxPorts) MicrophoneCount = ulMaxPorts;
        RIP_ON_NOT_TRUE_WITH_MESSAGE(HeadphoneCount <= ulMaxPorts, "XInitDevices: requested more XDEVICE_TYPE_VOICE_HEADPHONE than available ports.");
        if(HeadphoneCount > ulMaxPorts) HeadphoneCount = ulMaxPorts;
    }
    //
    //  Register for microphones and headphone
    //
    HAWK_gResourceRequirements.MaxDevices = (UCHAR)MicrophoneCount;
    pUsbInit->RegisterResources(&HAWK_gResourceRequirements);
    HAWK_gResourceRequirements.MaxDevices = (UCHAR)HeadphoneCount;
    pUsbInit->RegisterResources(&HAWK_gResourceRequirements);
    
    XHawkMediaObject::InitializeClass(MicrophoneCount, HeadphoneCount);

    DBGPRINT(3, ("exit:  HawkInit\n"));    
    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID
HawkAddDevice(
     IN IUsbDevice *Device
     )
{
	const USB_ENDPOINT_DESCRIPTOR   *pEndpointDescriptor;
    XHawkMediaObject *pHawkMediaObject = NULL;
    DWORD dwPort;

    //
	//  Get the device port and slot
	//

    dwPort = Device->GetPort();
    if(dwPort >= 16)
    {
        DBGPRINT(2,("AddDevice: dwPort %d, bottom slot, not supported!\n",  dwPort));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    //  get an endpoint descriptor for the isoch endpoint
    //  (we don't know the direction (microphone or
    //  headphone).  Try input first.
    //

    pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                TRUE,
                                0);
    if(pEndpointDescriptor)
    {
        pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
        pHawkMediaObject->m_fMicrophone = TRUE;
    }
    else {
        pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                FALSE,
                                0);
        if(pEndpointDescriptor)
        {
            pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
            pHawkMediaObject->m_fMicrophone = FALSE;
        } else 
        {
            ASSERT(FALSE && "Isoch endpoint not found");
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }
    }
    
    //
    //  Check and initialize the state 
    //
    pHawkMediaObject->m_fConnected = TRUE;

    //
    // Use XHawkMediaObject as the device extension
    //
    
    Device->SetExtension(pHawkMediaObject);
    pHawkMediaObject->m_pDevice = Device;
    
    //
    //  Record the endpoint address, and wMaxPacket
    //

    pHawkMediaObject->m_bEndpointAddress = pEndpointDescriptor->bEndpointAddress;
    pHawkMediaObject->m_wMaxPacket = pEndpointDescriptor->wMaxPacketSize;

    DBGPRINT(3,("IsochMaxPacket = %x, bEndpointAddress = 0x%02x\n, Interface = %d\n", 
                     (ULONG)pEndpointDescriptor->wMaxPacketSize,
                     (ULONG)pEndpointDescriptor->bEndpointAddress,
                     Device->GetInterfaceNumber()
                     ));

    //
    // Set the class specific type so it can be enumerated
    //
    Device->SetClassSpecificType(
                pHawkMediaObject->m_fMicrophone ? HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE : HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE
                );

    Device->AddComplete(USBD_STATUS_SUCCESS);
}


EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    )
{
    XHawkMediaObject *pHawkMediaObject = (XHawkMediaObject *)Device->GetExtension();
 
    //
    //  Mark the device as not connected 
    //

    pHawkMediaObject->m_fConnected = FALSE;

    //
    //  If the device is opened, we cannot call
    //  remove complete, because there is
    //  an endpoint open (or in the process
    //  of being closed.)
    //

    //
    //  Mark the media object remove pending,
    //
    pHawkMediaObject->m_fRemovePending = TRUE;

    //
    //  If the device is ready, we should close the endpoints
    //
    if(pHawkMediaObject->m_fReady)
    {
        //
        //  If the endpoint is not in the process
        //  of being closed, then start that process
        //
        pHawkMediaObject->CloseEndpoint();
    } else
    //
    //  The media object wasn't opened, so we can
    //  call remove complete
    //
    {
        //
        //  If a close is pending then we 
        //  cannot call RemoveComplete, but
        //  when the close completes it will
        //  see the m_fRemovePending flag.
        //
        if(!pHawkMediaObject->m_fClosePending)
        {
            pHawkMediaObject->m_pDevice = NULL;
            Device->SetExtension(NULL);
            Device->RemoveComplete();
            pHawkMediaObject->m_fRemovePending = FALSE;
        }
    }
}    

//------------------------------------------------------------------------------
//  We do not include the CRT, but we need new.
//  we declare it static, so we don't conflict on linking
//  with other modules overriding new.
//------------------------------------------------------------------------------
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize)
    {
        return ExAllocatePoolWithTag(
                            memSize,
                            'kwah'
                            );
    }
static __inline void __cdecl operator delete(void *pMemory)
    {
        ExFreePool(pMemory);
    }
#pragma warning(default:4211)


//------------------------------------------------------------------------------
// XHawkMediaObject
//------------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
void XHawkMediaObject::InitializeClass(ULONG ulMicrophoneCount, ULONG ulHeadphoneCount)
{
    //
    //  Allocate a microphone and a headphone
    //  instance for each of the ports up front.
    //
    ULONG ulPortCount = XGetPortCount();
    ULONG ulTotalStreamingResources = ulHeadphoneCount + ulMicrophoneCount;
    PHAWK_STREAMING_RESOURCES pStreamingResourceArray;
    
    //
    //  Handle insane case, where the user requested no microphone or headphones, but
    //  some how we are here anyway.
    //
    if(ulTotalStreamingResources)
        pStreamingResourceArray = new HAWK_STREAMING_RESOURCES[ulTotalStreamingResources];

    
    sm_pHeadphones = new XHawkMediaObject[ulPortCount];
    sm_pMicrophones = new XHawkMediaObject[ulPortCount];
    sm_pRateIndices = new UCHAR[ulPortCount];
    sm_pRateIndexRefCounts = new UCHAR[ulPortCount];
    
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pHeadphones, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pMicrophones, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pRateIndices, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pRateIndexRefCounts, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(pStreamingResourceArray, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    
    //
    //  Make a free list out of pStreamingResourceArray
    //
    sm_pFreeStreamingResources = NULL;
    for(ULONG i=0; i < ulTotalStreamingResources; i++)
    {
        pStreamingResourceArray[i].pNextFree = sm_pFreeStreamingResources;
        sm_pFreeStreamingResources = &pStreamingResourceArray[i];
    }
    //
    //  Initialize the number of available microphone and headphone resources
    //
    sm_AvailableMicrophoneResources = (USHORT)ulMicrophoneCount;
    sm_AvailableHeadphoneResources = (USHORT)ulHeadphoneCount;


    //
    //  Initially none of the rates are set.
    //
    RtlZeroMemory(sm_pRateIndexRefCounts, sizeof(UCHAR)*ulPortCount);
    
    //
    //  We could loop over them and morph them into
    //  microphones and headphones, but we might
    //  as well leave that until an AddDevice.
    //

}
#pragma code_seg(".XPPCODE")

STDMETHODIMP_(ULONG) XHawkMediaObject::AddRef (void)
{
	return (ULONG) InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(ULONG) XHawkMediaObject::Release (void)
{
	LONG lRefCount;
	lRefCount = InterlockedDecrement(&m_lRefCount);
	//
	//	Check for decrement below zero
	//
	if(0>lRefCount)
	{
		DBGPRINT(1, ("XHawkMediaObject: Reference Count Error: Count went below 0!\n"));
		return 0;
	} else if (0==lRefCount)
	{
        FreeStreamingResources();
	}
	return (ULONG)lRefCount;
}

STDMETHODIMP
XHawkMediaObject::GetInfo (
    OUT PXMEDIAINFO pInfo
    )
{
    //
    //  If this assert fails the reference count is hosed
    //  or the caller called us after releasing the last
    //  reference.
    //
    ASSERT(m_pStreamingResources);
    
    //
    // align values to our block size. In gets CEILed, out gets FLOORed
    //
    if (m_fMicrophone) {
        pInfo->dwFlags =
	        XMO_STREAMF_FIXED_SAMPLE_SIZE |
            XMO_STREAMF_OUTPUT_ASYNC;
        pInfo->dwOutputSize = 
            m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES;
        pInfo->dwInputSize = 0;
    } else {
        pInfo->dwFlags =
	        XMO_STREAMF_FIXED_SAMPLE_SIZE |
            XMO_STREAMF_INPUT_ASYNC;
        pInfo->dwInputSize = 
            m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES;
        pInfo->dwOutputSize = 0;
    }
    
    //
    //  Look ahead is 0.
    //
    pInfo->dwMaxLookahead = 0;
    
    return S_OK;
}

STDMETHODIMP 
XHawkMediaObject::Flush (void)
{
    return S_OK;
}
        

STDMETHODIMP 
XHawkMediaObject::Discontinuity (void)
{
    return S_OK;
}
        

STDMETHODIMP
XHawkMediaObject::GetStatus (
            OUT DWORD *pdwFlags
            )
{
    RIP_ON_NOT_TRUE("XHawkMediaObject::GetStatus", NULL!=pdwFlags);

    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    
    ASSERT(m_pStreamingResources);
    if( m_fReady && m_pStreamingResources->Free.GetHead())
    {
        if(m_fMicrophone)
        {
           *pdwFlags = XMO_STATUSF_ACCEPT_OUTPUT_DATA;
        } else
        {
           *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA;            
        }
    } else
    {
        *pdwFlags = 0;        
    }
    
    KeLowerIrql(oldIrql);
    
    return S_OK;
}
        
HRESULT
XHawkMediaObject::Process (
    IN LPCXMEDIAPACKET pInputPacket,
    IN LPCXMEDIAPACKET pOutputPacket
    )
{
    HRESULT hr = S_OK;
    LPCXMEDIAPACKET pMediaPacket;
    
    if(m_fMicrophone)
    {
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL==pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL!=pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", 
                         pOutputPacket->dwMaxSize > (DWORD)m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", 
                         0 == pOutputPacket->dwMaxSize%HAWK_BYTES_PER_SAMPLE);
        pMediaPacket = pOutputPacket;
         
    } else 
    {
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL!=pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL==pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", 
                         pInputPacket->dwMaxSize > (DWORD)m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", 
                         0 == pInputPacket->dwMaxSize%HAWK_BYTES_PER_SAMPLE);
        pMediaPacket = pInputPacket;
    }

    // Raise IRQL after rips
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    if(m_fReady)
    {

        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->Free.RemoveHead();    
        if(pPacketContext)
        {

            //
            //  Initialize the packet
            //
            
            XMOAcceptPacket(pMediaPacket);

            //
            //  Copy the media packet into the hawk packet context.
            //  The structure is identical except hawk has one extra
            //  field, for queuing
            //
            
            RtlCopyMemory(&pPacketContext->MediaPacket, pMediaPacket, sizeof(XMEDIAPACKET));
                
            //
            //  Insert the packet onto the pending programming queue.
            //

            m_pStreamingResources->PendingProgram.InsertTail(pPacketContext);
                
            //
            //  Jog the programming routine.
            //

            ProgramTransfer();
            
        } else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        }
    } else
    {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    if(FAILED(hr))
    {
        XMOCompletePacket(pMediaPacket, 0, m_pfnCallback, m_pvContext, XMEDIAPACKET_STATUS_FAILURE);
    }

    KeLowerIrql(oldIrql);
    return hr;

}

EXTERN_C HRESULT WINAPI
XVoiceCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN LPWAVEFORMATEX pwfxFormat,
      IN PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      IN PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      )
{
    HRESULT hr;
    XHawkMediaObject *pHawkMediaObject = NULL;

    hr = XVoiceCreateMediaObject(
          XppDeviceType,
          dwPort,
          dwMaxAttachedPackets,
          pwfxFormat,
          ppXmediaObject
          );

    if (SUCCEEDED(hr)) {

        //
        // save callback and context
        //

        pHawkMediaObject = (XHawkMediaObject *) *ppXmediaObject;
        pHawkMediaObject->m_pvContext = pvContext;
        pHawkMediaObject->m_pfnCallback = pfnCallback;

    }


    return hr;

}


XBOXAPI EXTERN_C HRESULT WINAPI
XVoiceCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN PWAVEFORMATEX  pwfxFormat  OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      )
/*++
    Routine Description:
        This is the factory method for XHawkMediaObjects.
        It is an exported API for games.
--*/
{
    //
    //  We need the class Id to find the device.
    //
	
    KIRQL		     oldIrql;
    PNP_CLASS_ID     classId;
    HRESULT          hr = S_OK;
    XHawkMediaObject *pHawkMediaObject = NULL;
    UCHAR            ucRateIndex=2; //default rate is 16 kHz, at index 2 in the rate table.
    
    //
    //  Verify that XInitDevices has been called.
    //
    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XVoiceCreateMediaObject: XInitDevices must be called first!");

    //
    //  Verify port
    //
    RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, dwPort<XGetPortCount());

    //
    //  Verify that a reasonable dwMaxAttachedPackets was passed.
    //
    RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, (dwMaxAttachedPackets > 1));

    //
    //  Use raised Irql to synchronize the allocation
    //  and opening of instances
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Claim an existing instance of XHawkMediaObject
    //
	
    if(XDEVICE_TYPE_VOICE_MICROPHONE == XppDeviceType)
	{
        if(0==XHawkMediaObject::sm_AvailableMicrophoneResources)
        {
            KeLowerIrql(oldIrql);
            RIP("XVoiceCreateMediaObject: attempt to exceed number of mircophones requested in XInitDevices.\n");
            return E_OUTOFMEMORY;
        }
        pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
    } else if(XDEVICE_TYPE_VOICE_HEADPHONE == XppDeviceType)
    {
        if(0==XHawkMediaObject::sm_AvailableHeadphoneResources)
        {
            KeLowerIrql(oldIrql);
            RIP("XVoiceCreateMediaObject: attempt to exceed number of headphones requested in XInitDevices.\n");
            return E_OUTOFMEMORY;
        }
        pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
    }
#if DBG    
    else {
        KeLowerIrql(oldIrql);
        RIP("XVoiceCreateMediaObject: XppDeviceType is not a valid type for XVoiceCreateMediaObject\n");
	}
#endif //DBG

    //
    //  Check the wave format
    //
    if(pwfxFormat)
    {
        //
        //  Verify that the setting are supported
        //
#if DBG
        KeLowerIrql(oldIrql);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->wFormatTag==WAVE_FORMAT_PCM);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->nChannels==1);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, 2*pwfxFormat->nSamplesPerSec==pwfxFormat->nAvgBytesPerSec);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->wBitsPerSample==16);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->nBlockAlign == 2);
        oldIrql = KeRaiseIrqlToDpcLevel();
#endif

        //
        //  First validate rate against allowed rates.
        //
        for(ucRateIndex=0; ucRateIndex < HAWK_SAMPLE_RATE_COUNT; ucRateIndex++)
        {
            if(pwfxFormat->nSamplesPerSec == (DWORD)XHawkMediaObject::sm_HawkSampleRates[ucRateIndex].nSamplePerSecond)
            {
                break;
            }
        }
#if DBG
        if(HAWK_SAMPLE_RATE_COUNT == ucRateIndex)
        {
            KeLowerIrql(oldIrql);
            RIP("XVoiceCreateMediaObject: pWaveFormatEx->nSamplesPerSec has illegal value");
        }
#endif //DBG
    }

    if( pHawkMediaObject->m_fOpened )
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
    } else if (pHawkMediaObject->m_fConnected)
    {
        //
        //  Set the sample rate
        //
        if(XHawkMediaObject::sm_pRateIndexRefCounts[dwPort])
        //
        //  If the reference count is non-zero, then the
        //  other half of this device has set the rate
        //  (microphone and headphone must have the same rate)
        //
        {
            XHawkMediaObject::sm_pRateIndexRefCounts[dwPort]++;
            //
            //  Verify that the rates match
            //
            if(XHawkMediaObject::sm_pRateIndices[dwPort]!=ucRateIndex)
            {
                // Be kinder here, return an error, I could vaguely see this slipping through testing.
                KeLowerIrql(oldIrql);
                RIP("XVoiceCreateMediaObject: Attempt to open microphone and headphone of same device with different sampling rates.");
                return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            }
        } else
        //
        //  The rate hasn't been set yet, so set it
        //
        {
            XHawkMediaObject::sm_pRateIndexRefCounts[dwPort] = 1;
            XHawkMediaObject::sm_pRateIndices[dwPort]=ucRateIndex;
            hr = pHawkMediaObject->SetSampleRate(ucRateIndex, oldIrql);
			hr = pHawkMediaObject->SetAGC(HAWK_AGC_ON, oldIrql);
        }

        //
        //  Allocate the streaming resources.
        //
        if(SUCCEEDED(hr))
        {
            hr = pHawkMediaObject->AllocateStreamingResources(dwMaxAttachedPackets, ucRateIndex);
        }
        if(SUCCEEDED(hr))
        {
            pHawkMediaObject->m_fOpened = TRUE;
            pHawkMediaObject->m_fReady = TRUE;
            pHawkMediaObject->m_lRefCount = 1;
        } else
        {
           pHawkMediaObject = NULL;
           XHawkMediaObject::sm_pRateIndexRefCounts[dwPort]--;
        }
    } else
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    // Record that we opened a device
    if(pHawkMediaObject)
    {
        if(pHawkMediaObject->m_fMicrophone) XHawkMediaObject::sm_AvailableMicrophoneResources--;
        else XHawkMediaObject::sm_AvailableHeadphoneResources--;
    }

    //
    //  Restore Irql since the stuff that needs
    //  to be synchronous is done.
    //
    KeLowerIrql(oldIrql);
    
    *ppXmediaObject = pHawkMediaObject;	
    return hr;
}
            
HRESULT XHawkMediaObject::SetSampleRate(UCHAR ucRateIndex, KIRQL BaseIrql)
/*++
    Routine Description:
        Sends a command to hawk to change the sample rate.  This routine opens the
        default pipe. Sends a vendor specific SetFeature to change the rate.  The closes
        the default pipe.  The routine is synchronous, which means it must drop to below
        DISPATCH_LEVEL.
    Parameters:
        ucRateIndex - rate index to send to the device.
        BaseIrql - the lowest irql we are permitted to drop to.
    Comments:
        Must be called at DPC level, BaseIrql must be lower than DPC.
--*/
{
    USBD_STATUS usbdStatus;
    
    //
    //  Open the default endpoints
    //
    URB Urb;
    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&Urb.OpenEndpoint);
    usbdStatus = m_pDevice->SubmitRequest(&Urb);
    if(USBD_ERROR(usbdStatus))
    {
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
    }

    //
    //  While still at DPC, set the m_fClosePending flag.  This will prevent HawkRemoveDevice
    //  from calling RemoveComplete on us.  We take on the burden of checking for m_fRemovePending
    //  when clearing this flag.
    //

    m_fClosePending = TRUE;   
    //
    //  Drop to BaseIrql so we can start doing the asynchronous parts synchronously.
    //

    ASSERT(BaseIrql < DISPATCH_LEVEL);
    KeLowerIrql(BaseIrql);

    //
    //  Send the SET_FEATURE(SampleRate) command.
    //

    USB_BUILD_CONTROL_TRANSFER(
        &Urb.ControlTransfer,
        NULL,   //Use the default endpoint
        NULL,   //No transfer buffer
        0,      
        0,
        NULL,   //Do this transfer synchronously
        0,      
        FALSE,  //Short Transfer NOT OK
        USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE | USB_HOST_TO_DEVICE,
        USB_REQUEST_SET_FEATURE,
        (USHORT) 0x0100 | ucRateIndex, // DD: ucRateIndex, //Rate Index to set, see Talon Specification.
        HAWK_VENDOR_FEATURE_SAMPLE_RATE,
        0); //Transfer length is zero

    usbdStatus = m_pDevice->SubmitRequest(&Urb);

    //
    //  Close the default endpoint
    //
    USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb.CloseEndpoint, NULL, NULL);
    m_pDevice->SubmitRequest(&Urb);

    //
    //  Now all the synchronous stuff is done we can
    //  go back up to DISPATCH_LEVEL
    //

    KeRaiseIrqlToDpcLevel();

    //
    //  We are not really open yet, nor are we pending a close.
    //

    m_fOpened = FALSE; 
    m_fClosePending = FALSE; 

    //
    //  Check the remove pending flag, and complete the remove
    //  it one was pending.
    //  Also fail this request with ERROR_DEVICE_NOT_CONNECTED.
    //
    if(m_fRemovePending)
    {
        m_pDevice->SetExtension(NULL);
        m_pDevice->RemoveComplete();
        m_pDevice = NULL;
        m_fRemovePending = FALSE;
        return HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }
    
    //
    //  If we are supporting fixed rate devices
    //  tolerate a failure, if the
    //  requested rate was 16 ksamples/second
    #ifdef HAWK_SUPPORT_FIXED_RATE
    if(ucRateIndex==2)
    {
        usbdStatus = USBD_STATUS_SUCCESS;
    }
    #endif //HAWK_SUPPORT_FIXED_RATE

    //
    //  Return the status of the request to set the data rate.  
    //

    return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
}

HRESULT XHawkMediaObject::SetAGC(UCHAR ucAGC, KIRQL BaseIrql)
/*++
    Routine Description:
        Sends a command to hawk to change the sample rate.  This routine opens the
        default pipe. Sends a vendor specific SetFeature to change the rate.  The closes
        the default pipe.  The routine is synchronous, which means it must drop to below
        DISPATCH_LEVEL.
    Parameters:
        ucAGC - rate index to send to the device.
        BaseIrql - the lowest irql we are permitted to drop to.
    Comments:
        Must be called at DPC level, BaseIrql must be lower than DPC.
--*/
{
    USBD_STATUS usbdStatus;
    
	//
    //  Open the default endpoints
    //
    URB Urb;
    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&Urb.OpenEndpoint);
    usbdStatus = m_pDevice->SubmitRequest(&Urb);
    if(USBD_ERROR(usbdStatus))
    {
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
    }

    //
    //  While still at DPC, set the m_fClosePending flag.  This will prevent HawkRemoveDevice
    //  from calling RemoveComplete on us.  We take on the burden of checking for m_fRemovePending
    //  when clearing this flag.
    //

    m_fClosePending = TRUE;   
    //
    //  Drop to BaseIrql so we can start doing the asynchronous parts synchronously.
    //

    ASSERT(BaseIrql < DISPATCH_LEVEL);
    KeLowerIrql(BaseIrql);

    //
    //  Send the SET_FEATURE(SampleRate) command.
    //

    USB_BUILD_CONTROL_TRANSFER(
        &Urb.ControlTransfer,
        NULL,   //Use the default endpoint
        NULL,   //No transfer buffer
        0,      
        0,
        NULL,   //Do this transfer synchronously
        0,      
        FALSE,  //Short Transfer NOT OK
        USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE | USB_HOST_TO_DEVICE,
        USB_REQUEST_SET_FEATURE,
        (USHORT)ucAGC, //ON/OFF, see Talon Specification.
        (USHORT)HAWK_VENDOR_FEATURE_AGC, 
        0); //Transfer length is zero

    usbdStatus = m_pDevice->SubmitRequest(&Urb);

    //
    //  Close the default endpoint
    //
    USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb.CloseEndpoint, NULL, NULL);
    m_pDevice->SubmitRequest(&Urb);

    //
    //  Now all the synchronous stuff is done we can
    //  go back up to DISPATCH_LEVEL
    //

    KeRaiseIrqlToDpcLevel();

    //
    //  We are not really open yet, nor are we pending a close.
    //

    m_fOpened = FALSE; 
    m_fClosePending = FALSE; 

    //
    //  Check the remove pending flag, and complete the remove
    //  it one was pending.
    //  Also fail this request with ERROR_DEVICE_NOT_CONNECTED.
    //
    if(m_fRemovePending)
    {
        m_pDevice->SetExtension(NULL);
        m_pDevice->RemoveComplete();
        m_pDevice = NULL;
        m_fRemovePending = FALSE;
        return HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }
    
    //
    //  Return the status of the request to set the data rate.  
    //
    return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
}


HRESULT XHawkMediaObject::AllocateStreamingResources(ULONG ulMaxAttachedPackets, ULONG ulRateIndex)
/*++
    Routine Description:
        This is a helper function called by Factory Method,
        XVoiceCreateMediaObject, to allocate resources for
        providing streaming.
--*/
{
    ULONG i;
    
    //
    //  Allocate memory for Attached Packets
    //
    PHAWK_PACKET_CONTEXT pPacketContextArray  = new HAWK_PACKET_CONTEXT[ulMaxAttachedPackets];
    if(!pPacketContextArray) return E_OUTOFMEMORY;
    RtlZeroMemory(pPacketContextArray, sizeof(HAWK_PACKET_CONTEXT)*ulMaxAttachedPackets);

    //
    //  Grab a free streaming resources  (there has to be one
    //  at this point or there is a bug somewhere in this driver.)
    //
    PHAWK_STREAMING_RESOURCES pResources = sm_pFreeStreamingResources;
    ASSERT(pResources);
    sm_pFreeStreamingResources = pResources->pNextFree;
    RtlZeroMemory(pResources, sizeof(HAWK_STREAMING_RESOURCES));
    
    //
    // Populate the free list of packet contexts
    //
    pResources->m_pContextArray = pPacketContextArray;
    for(i=0; i < ulMaxAttachedPackets; i++)
    {
        pResources->Free.InsertTail(pPacketContextArray + i);
    }

    //
    //  Copy the sample rate parameters from the rate table into the
    //  pResources structure for quick access.
    //

    pResources->BytesPerUSBFrame = sm_HawkSampleRates[ulRateIndex].BytesPerUSBFrame;
    pResources->ExtraSampleInterval = sm_HawkSampleRates[ulRateIndex].ExtraSampleInterval;
    pResources->AvailableTransferContexts = HAWK_TRANSFER_CONTEXT_BOTH;
    //pResources->ProgrammedFrame = 0; //Not necessary since the memory was zeroed.
    pResources->TransferContext[0].pHawkMediaObject =
    pResources->TransferContext[1].pHawkMediaObject = this;
    pResources->TransferContext[0].ucContextNumber = HAWK_TRANSFER_CONTEXT_0;
    pResources->TransferContext[1].ucContextNumber = HAWK_TRANSFER_CONTEXT_1;

    //
    //  Open the isoch endpoint
    //

    URB_ISOCH_OPEN_ENDPOINT OpenUrb;
    USB_BUILD_ISOCH_OPEN_ENDPOINT(
                &OpenUrb,
                m_bEndpointAddress,
                m_wMaxPacket,
                0);
    USBD_STATUS status = m_pDevice->SubmitRequest((PURB)&OpenUrb);
    
    if(USBD_ERROR(status))
    {
        delete [] pPacketContextArray;
        pResources->pNextFree = sm_pFreeStreamingResources;
        sm_pFreeStreamingResources = pResources;
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(status));
    }
    pResources->EndpointHandle = OpenUrb.EndpointHandle;

    //
    //  start the stream (since we don't have a start API)
    //

    URB_ISOCH_START_TRANSFER StartTransferUrb;
    USB_BUILD_ISOCH_START_TRANSFER(
        &StartTransferUrb,
        pResources->EndpointHandle,
        0,
        URB_FLAG_ISOCH_START_ASAP
        );
    status = m_pDevice->SubmitRequest((PURB)&StartTransferUrb);
    ASSERT(USBD_SUCCESS(status));
        
    //
    //  The stream should be ready to go, we just need to
    //  attach transfers.
    //

    m_pStreamingResources = pResources;

    return S_OK;
}

void XHawkMediaObject::CloseEndpoint( void )
{
    ASSERT(m_pStreamingResources);
    ASSERT(m_pStreamingResources->EndpointHandle);
    
    //
    //  The device is not ready, if the endpoint is not open.
    //

    m_fReady = FALSE;
    
    if(m_fClosingEndpoint) return;
    m_fClosingEndpoint = TRUE;

    //
    //  Build and submit the close URB for the Isoch endpoint
    //

    USB_BUILD_ISOCH_CLOSE_ENDPOINT(
            &m_pStreamingResources->CloseUrb,
            m_pStreamingResources->EndpointHandle,
            (PURB_COMPLETE_PROC)&XHawkMediaObject::CloseEndpointComplete,
            (PVOID)this
            );
    m_pDevice->SubmitRequest((PURB)&m_pStreamingResources->CloseUrb);
}

void XHawkMediaObject::CloseEndpointComplete (PURB pUrb, XHawkMediaObject *pThis)
/*++
    Routine Description:
        This is the call back when an isoch endpoint is closed.
        This could happen if a close is pending, or if 
        a remove is pending, or both.

--*/
{
    DWORD dwPort;
    ASSERT(USBD_SUCCESS(pUrb->Header.Status));

    //
    //  Now mark the endpoint closed.
    //
    pThis->m_pStreamingResources->EndpointHandle = NULL;

    //
    //  Decrement the reference count on the rate, for
    //  which we need the port index.
    //

    if(pThis->m_fMicrophone)
    {
        dwPort = (DWORD)(pThis - XHawkMediaObject::sm_pMicrophones);
    } else
    {
        dwPort = (DWORD)(pThis - XHawkMediaObject::sm_pHeadphones);
    }
    XHawkMediaObject::sm_pRateIndexRefCounts[dwPort]--;
    
    
    //
    //  Abort outstanding packets.
    //
    pThis->AbortMediaPackets();

    //
    //  Deal with the remove pending case.
    //

    if(pThis->m_fRemovePending)
    {
        pThis->m_pDevice->SetExtension(NULL);
        pThis->m_pDevice->RemoveComplete();
        pThis->m_pDevice = NULL;
        pThis->m_fRemovePending = FALSE;
    }

    //
    //  If this is the close pending case,
    //  then there is an event that we need to set
    //
    if(pThis->m_fClosePending)
    {
        //
        //  We have to clear the m_fClosePending
        //  and m_fOpened flags while still at
        //  DPC for synchronization purposes.
        //

        pThis->m_fClosePending = FALSE;
        pThis->m_fOpened = FALSE;

        //
        //  Signal the close event so that
        //  FreeStreamingResources can continue
        //  to clean up.
        //

        KeSetEvent(
            &pThis->m_pStreamingResources->CloseEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }
    pThis->m_fClosingEndpoint = FALSE;
}

void XHawkMediaObject::FreeStreamingResources (void)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    if(m_fConnected && m_pStreamingResources->EndpointHandle)
    {

        //
        //  Mark that this object is pending close
        //  and initialize the close event.
        //

        m_fClosePending = TRUE;
        KeInitializeEvent(
            &m_pStreamingResources->CloseEvent,
            SynchronizationEvent,
            FALSE);

        //
        //  If it is already pending remove
        //  then we can just wait for
        //  the endpoint to close, other
        //  wise we must initiate closing
        //   it.
        //
        
        if(!m_fRemovePending)
        {
            CloseEndpoint();
        }

        //
        //  Lower Irql and let the endpoint close.
        //

        KeLowerIrql(oldIrql);
        
        //
        // The endpoint close is under way,
        // wait for it to complete.
        //

        KeWaitForSingleObject (
            &m_pStreamingResources->CloseEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    } else
    {
        m_fOpened = FALSE;
        KeLowerIrql(oldIrql);
    }
    
    if(m_fMicrophone) sm_AvailableMicrophoneResources++;
    else sm_AvailableHeadphoneResources++;

    //
    //  Now we can cleanup what is left of the streaming resources
    //
    delete [] m_pStreamingResources->m_pContextArray;
    m_pStreamingResources->pNextFree = sm_pFreeStreamingResources;
    sm_pFreeStreamingResources = m_pStreamingResources;
    m_pStreamingResources = NULL;
    
}

void XHawkMediaObject::ProgramTransfer()
/*++
    Routine Description:
        This routine translates a portion of a packet into USB Isochronous
        Transfer Requests.

    Note: Sometimes this routine in called at PASSIVE_LEVEL and sometimes
    at DISPATCH_LEVEL.  This routine is not inherently reentrant so we raise
    the IRQL to DISPATCH_LEVEL all the time.
--*/
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();   
    USBD_ISOCH_BUFFER_DESCRIPTOR isochBufferDescriptor;
    PHAWK_TRANSFER_CONTEXT pTransferContext = NULL;
    int i;

    //
    //  Claim a context
    //
    if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0))
    {
        CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0);
        pTransferContext = &m_pStreamingResources->TransferContext[0];
    } else if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1))
    {
        CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1);
        pTransferContext = &m_pStreamingResources->TransferContext[1];
    }

    isochBufferDescriptor.TransferComplete = (PFNUSBD_ISOCH_TRANSFER_COMPLETE)XHawkMediaObject::TransferComplete;

    while(pTransferContext)
    {
        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->PendingProgram.GetHead();
        
        //
        //  If there are no more packet contexts pending programming, break the
        //  loop, we are done.
        //

        if(!pPacketContext)
        {
            SET_FLAG(m_pStreamingResources->AvailableTransferContexts, pTransferContext->ucContextNumber);
            break;
        }

        //
        //  Fill out the transfer context
        //

        pTransferContext->pPacketContext = pPacketContext;
        pTransferContext->pucTransferBuffer = (PUCHAR) pPacketContext->MediaPacket.pvBuffer;
        pTransferContext->ulTransferBytes = 0;
        pTransferContext->cFirstFrame = m_pStreamingResources->ProgrammedFrame;
        pTransferContext->fWrapBuffer = FALSE;
        pTransferContext->fLastTransfer = FALSE;

        //
        //  Walk through each frame, up to HAWK_USB_MAX_FRAMES,
        //

        for(i=0; i < HAWK_USB_MAX_FRAMES; i++)
        {   
            isochBufferDescriptor.Pattern[i] = m_pStreamingResources->BytesPerUSBFrame;
            if(
                m_pStreamingResources->ExtraSampleInterval && 
                (++m_pStreamingResources->ProgrammedFrame == m_pStreamingResources->ExtraSampleInterval)
            )
            {
                isochBufferDescriptor.Pattern[i] += 2;
                m_pStreamingResources->ProgrammedFrame=0;
            }
            pTransferContext->ulTransferBytes += isochBufferDescriptor.Pattern[i];
            
            if(pTransferContext->ulTransferBytes > pPacketContext->MediaPacket.dwMaxSize)
            {
                m_pStreamingResources->WrapBuffer.ulSecondPacketBytes = 
                        pTransferContext->ulTransferBytes - pPacketContext->MediaPacket.dwMaxSize;
                pTransferContext->ulTransferBytes = pPacketContext->MediaPacket.dwMaxSize;
                pTransferContext->fWrapBuffer = TRUE;
                //
                //  If this is for a headphones copy the output bytes
                //  for this packet.
                //
                if(!m_fMicrophone)
                {
                    RtlCopyMemory(
                        m_pStreamingResources->WrapBuffer.Buffer,
                        pPacketContext->MediaPacket.pvBuffer,
                        pTransferContext->ulTransferBytes);
                }
            }
            if(pTransferContext->ulTransferBytes == pPacketContext->MediaPacket.dwMaxSize)
            {
                pTransferContext->fLastTransfer = TRUE;
                i++;
                break;
            }
        }
        ASSERT(i==8 || pTransferContext->fLastTransfer);
        pPacketContext->MediaPacket.dwMaxSize -= pTransferContext->ulTransferBytes;
        isochBufferDescriptor.Context = pTransferContext;
        isochBufferDescriptor.FrameCount = i;
        isochBufferDescriptor.TransferBuffer = pPacketContext->MediaPacket.pvBuffer;
        pPacketContext->MediaPacket.pvBuffer = ((PUCHAR)pPacketContext->MediaPacket.pvBuffer) + pTransferContext->ulTransferBytes;

        //
        //  If we are done with the current packet, then pop it off the pending program queue.
        //
        if(pTransferContext->fLastTransfer)
        {
            m_pStreamingResources->PendingProgram.RemoveHead();
        }

        //
        //  If the wrap buffer is in use than we need to get the next
        //  packet and start programming it in the beginning of the wrap buffer.
        //
        if(pTransferContext->fWrapBuffer)
        {
            DBGPRINT(1,("W"));
            PHAWK_WRAP_BUFFER pWrapBuffer = &m_pStreamingResources->WrapBuffer;
            isochBufferDescriptor.TransferBuffer = pWrapBuffer->Buffer;
            pPacketContext = m_pStreamingResources->PendingProgram.GetHead();
            if(pPacketContext)
            {
                pWrapBuffer->pSecondPacket = pPacketContext;
                pWrapBuffer->pucTransferBuffer = (PUCHAR)pPacketContext->MediaPacket.pvBuffer;
                ASSERT(pWrapBuffer->ulSecondPacketBytes <= pPacketContext->MediaPacket.dwMaxSize);
                if(!m_fMicrophone)
                {
                    RtlCopyMemory(
                        pWrapBuffer->Buffer+pTransferContext->ulTransferBytes,
                        pWrapBuffer->pucTransferBuffer,
                        pWrapBuffer->ulSecondPacketBytes);
                }
                pPacketContext->MediaPacket.pvBuffer = pWrapBuffer->pucTransferBuffer + pWrapBuffer->ulSecondPacketBytes;
                pPacketContext->MediaPacket.dwMaxSize -= pWrapBuffer->ulSecondPacketBytes; 
            } else
            //
            //  No more packets pending
            //
            {
                pWrapBuffer->pSecondPacket = NULL;
                pWrapBuffer->pucTransferBuffer = NULL;
                if(!m_fMicrophone)
                {
                    RtlZeroMemory(
                        pWrapBuffer->Buffer+pTransferContext->ulTransferBytes,
                        pWrapBuffer->ulSecondPacketBytes);
                }
            }
        }

        //
        //  Build and submit a USB request
        //
        
        URB_ISOCH_ATTACH_BUFFER Urb;
        USB_BUILD_ISOCH_ATTACH_BUFFER(
            &Urb,
            m_pStreamingResources->EndpointHandle,
            USBD_DELAY_INTERRUPT_0_MS,
            &isochBufferDescriptor
            );
        
        USBD_STATUS usbdStatus = m_pDevice->SubmitRequest((PURB)&Urb);
        ASSERT(USBD_SUCCESS(usbdStatus));
        
        //
        //  Try to claim another context
        //  
        if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0))
        {
            CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0);
            pTransferContext = &m_pStreamingResources->TransferContext[0];
        } else if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1))
        {
            CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1);
            pTransferContext = &m_pStreamingResources->TransferContext[1];
        } else
        {   //
            //  no more contexts
            //
            pTransferContext = NULL;
        }
    }

    KeLowerIrql(oldIrql);
}


void XHawkMediaObject::TransferComplete(PUSBD_ISOCH_TRANSFER_STATUS Status,  PVOID pvContext)
/*++
    Routine Description:
        This is the completion routine whenever an isoch transfer completes.
        It continues to program the current media packet, releases the media
        packet when it is complete, and moves on to the next packet.
--*/
{
    PHAWK_TRANSFER_CONTEXT pTransferContext = (PHAWK_TRANSFER_CONTEXT)pvContext;
    XHawkMediaObject *pThis = pTransferContext->pHawkMediaObject;
    PHAWK_STREAMING_RESOURCES pStreamingResources = pThis->m_pStreamingResources;
    PHAWK_PACKET_CONTEXT pPacketContext = pTransferContext->pPacketContext;
    CHAR extraSampleClock = pThis->m_pStreamingResources->ExtraSampleInterval;
    if(extraSampleClock) extraSampleClock--;
   
    //
    //  Post processing of data is only useful\needed for microphones.
    //
    if(pThis->m_fMicrophone)
    {
        ULONG bytesThisFrame;
        PUSHORT pBufferPosition;
        if(pTransferContext->fWrapBuffer)
        {
            pBufferPosition = (PUSHORT)pStreamingResources->WrapBuffer.Buffer;
        } else
        {
            pBufferPosition = (PUSHORT)pTransferContext->pucTransferBuffer;
        }
        //
        //  First handle overflow and underflow conditions
        //
        
        for(ULONG ulFrameIndex = 0; ulFrameIndex < Status->FrameCount; ulFrameIndex++)
        {
            bytesThisFrame = pStreamingResources->BytesPerUSBFrame;
            if(
                extraSampleClock &&
                (ulFrameIndex + pTransferContext->cFirstFrame == (ULONG)extraSampleClock)
            )
            {
                bytesThisFrame += 2;
            }
            //
            //  Fill in short frames with data copied from the previous samples(s)
            //
            if(USBD_ISOCH_STATUS_DATA_UNDERRUN == Status->PacketStatus[ulFrameIndex].ConditionCode)
            {
                //Copy bytes from the previous sample
                if(Status->PacketStatus[ulFrameIndex].BytesRead)
                {
                    #if DBG
                    if(0!=Status->PacketStatus[ulFrameIndex].BytesRead%2)
                    {
                        DBGPRINT(1,("Hardware violated sample boundary"));
                    }
                    #endif
                    ULONG samplesToDuplicate = (bytesThisFrame - Status->PacketStatus[ulFrameIndex].BytesRead) >> 1;
                    pBufferPosition = (PUSHORT)(((ULONG_PTR)pBufferPosition) + Status->PacketStatus[ulFrameIndex].BytesRead-2);
                    USHORT sample = *pBufferPosition++;
                    while(samplesToDuplicate--)
                    {
                        *pBufferPosition++ = sample;
                    }
                } else
                //
                //  This handles devices that mute by sending zero length data packets.
                //
                {
                    RtlZeroMemory(pBufferPosition,bytesThisFrame);
                    pBufferPosition  = (PUSHORT)((ULONG_PTR)pBufferPosition + bytesThisFrame); 
                }
            } else
            {
                pBufferPosition  = (PUSHORT)((ULONG_PTR)pBufferPosition + bytesThisFrame); 
            }
            //
            //  Check for data overrun to try to adapt to 
            //  small clock differences
            //
            if(
                extraSampleClock &&
                (USBD_ISOCH_STATUS_DATA_OVERRUN == Status->PacketStatus[ulFrameIndex].ConditionCode)
            )
            {
                CHAR clockDifference = extraSampleClock - (pTransferContext->cFirstFrame+(CHAR)ulFrameIndex);
                pStreamingResources->ProgrammedFrame += clockDifference;
            }
        }
        //
        //  If the wrap buffer was in use, then we need to copy the bytes back to their
        //  original buffer
        //
        if(pTransferContext->fWrapBuffer)
        {
            //
            //  First copy the part for the first packet
            //
            RtlCopyMemory(
                pTransferContext->pucTransferBuffer,
                pStreamingResources->WrapBuffer.Buffer, 
                pTransferContext->ulTransferBytes
                );
            //
            //  Then copy the part for the second packet
            //
            if(pStreamingResources->WrapBuffer.pSecondPacket)
            {
                RtlCopyMemory(
                    pStreamingResources->WrapBuffer.pucTransferBuffer,
                    pStreamingResources->WrapBuffer.Buffer + pTransferContext->ulTransferBytes,
                    pStreamingResources->WrapBuffer.ulSecondPacketBytes
                    );
            }
        }
    } else
    {
        #if DBG
        for(ULONG ulFrameIndex = 0; ulFrameIndex < Status->FrameCount; ulFrameIndex++)
        {
            if(Status->PacketStatus[ulFrameIndex].ConditionCode!=USBD_STATUS_SUCCESS)
            {
                DBGPRINT(1,("Failed Write: Frame=%d, CC=0x%0.1x, BytesWritten=0x%0.3x", 
                        ulFrameIndex,
                        (DWORD)Status->PacketStatus[ulFrameIndex].ConditionCode,
                        (DWORD)Status->PacketStatus[ulFrameIndex].BytesRead
                        ));
            }
        }
        #endif
    }
    
    //
    //  Post processing of data is complete, update completed size
    // 
    
    if(pPacketContext->MediaPacket.pdwCompletedSize)
        *pPacketContext->MediaPacket.pdwCompletedSize += pTransferContext->ulTransferBytes;
    if( pTransferContext->fWrapBuffer&&
        pStreamingResources->WrapBuffer.pSecondPacket&&
        pStreamingResources->WrapBuffer.pSecondPacket->MediaPacket.pdwCompletedSize
    )
    {
        *pStreamingResources->WrapBuffer.pSecondPacket->MediaPacket.pdwCompletedSize += 
            pStreamingResources->WrapBuffer.ulSecondPacketBytes;
    }
    //
    //  Mark the pTransferContext as unused
    //
    BOOL fLastTransfer = pTransferContext->fLastTransfer;
    SET_FLAG(
        pStreamingResources->AvailableTransferContexts,
        pTransferContext->ucContextNumber
        );

    //
    //  Complete packet if necessary
    //
    if(fLastTransfer)
    {
        //
        //  Cache the media packet info on the stack
        //  so we can free the packet context
        //  before calling XMOCompletePacket.
        //
        XMEDIAPACKET mediaPacket;
        DWORD       dwCompletedSize = 0;
        RtlCopyMemory(&mediaPacket, &pPacketContext->MediaPacket, sizeof(XMEDIAPACKET));
        if(mediaPacket.pdwCompletedSize)
            dwCompletedSize = *mediaPacket.pdwCompletedSize;
        

        //
        //  Place the packet back on the free list  (do this before
        //  calling XMOCompletePacket) so that a packet context
        //  is available during the callback (if a callaback is
        //  used) to program the next packet.
        //
        pStreamingResources->Free.InsertTail(pPacketContext);

        XMOCompletePacket(&mediaPacket,
                          dwCompletedSize, 
                          pThis->m_pfnCallback,
                          pThis->m_pvContext,
                          XMEDIAPACKET_STATUS_SUCCESS);

    }

    //
    //  Jog the program loop (if the device is still opened and ready).
    //
    if(pThis->m_fReady)
    {
        pThis->ProgramTransfer();
    }
}

void XHawkMediaObject::AbortMediaPackets()
{

    PHAWK_PACKET_CONTEXT pPacketContext = NULL;
    if(!TEST_FLAG(m_pStreamingResources->AvailableTransferContexts,HAWK_TRANSFER_CONTEXT_0))
    {
        //
        //  Complete the packet (it cannot be on the pending program list)
        //
        if(m_pStreamingResources->TransferContext[0].fLastTransfer)
        {
            pPacketContext = m_pStreamingResources->TransferContext[0].pPacketContext;
        }
    }
    if((NULL==pPacketContext )&& !TEST_FLAG(m_pStreamingResources->AvailableTransferContexts,HAWK_TRANSFER_CONTEXT_1))
    {
        //
        //  Complete the packet (it cannot be on the pending program list)
        //
        if(m_pStreamingResources->TransferContext[1].fLastTransfer)
        {
            pPacketContext = m_pStreamingResources->TransferContext[1].pPacketContext;
        }
    }
    if(NULL==pPacketContext)
    {
        pPacketContext = m_pStreamingResources->PendingProgram.RemoveHead();
    }

    while(pPacketContext)
    {
        //
        //  Cache the media packet info on the stack
        //  so we can free the packet context
        //  before calling XMOCompletePacket.
        //
        XMEDIAPACKET mediaPacket;
        RtlCopyMemory(&mediaPacket, &pPacketContext->MediaPacket, sizeof(XMEDIAPACKET));

        //
        //  Place the packet back on the free list  (do this before
        //  calling XMOCompletePacket) so that a packet context
        //  is available during the callback (if a callaback is
        //  used) to program the next packet.
        //
        m_pStreamingResources->Free.InsertTail(pPacketContext);

        XMOCompletePacket(&mediaPacket,
                          0, 
                          m_pfnCallback,
                          m_pvContext,
                          XMEDIAPACKET_STATUS_FLUSHED);

        //
        //  Get the next packet.
        //

        pPacketContext = m_pStreamingResources->PendingProgram.RemoveHead();
    }
}




//-------------------------------------------------------------------------
// CHawkPacketQueue implementation
//-------------------------------------------------------------------------

void CHawkPacketQueue::InsertTail(PHAWK_PACKET_CONTEXT pPacketContext)
{
    pPacketContext->pNextPacket = NULL;
    if(m_pTail)
    {
        m_pTail->pNextPacket = pPacketContext;
    } else
    {
        m_pHead = pPacketContext;
    }
    m_pTail = pPacketContext;
}

PHAWK_PACKET_CONTEXT CHawkPacketQueue::RemoveHead()
{
    PHAWK_PACKET_CONTEXT pRetVal;
    if(m_pHead)
    {
         pRetVal = m_pHead;
         m_pHead = m_pHead->pNextPacket;
         if(!m_pHead) m_pTail = NULL;
    } else
    {
        pRetVal = NULL;
    }
    return pRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\hawk\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ezusbdef\ezusbdef.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ezusbdef.cpp

Abstract:

    This module implements a USB class driver for the EZ-USB default device.

--*/

#define _NTOS_
#include <ntddk.h>
#include <xtl.h>
#include <usb.h>
#include "ezusbdef.h"

//
// Declare the structure used by the USB enumeration code to internally track
// devices of this type.
//

DECLARE_XPP_TYPE(XDEVICE_TYPE_EZUSBDEF)

//
// Create the table of device types that this class driver supports.
//

USB_DEVICE_TYPE_TABLE_BEGIN(Ezusb)
    USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_EZUSBDEF)
USB_DEVICE_TYPE_TABLE_END()

//
// Create the structure that binds the USB class, subclass, and protocol codes
// to this class driver.
//

USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(Ezusb, USB_DEVICE_CLASS_VENDOR_SPECIFIC, 0xFF, 0xFF)

//
// Register the class driver with the USB core driver by placing a pointer to
// the above structure in the .XPP$Class section.
//

#pragma data_seg(".XPP$ClassEzusb")
USB_CLASS_DECLARATION_POINTER(Ezusb)
#pragma data_seg(".XPP$Data")

//
// Stores all of the per-port instance data related to a device.  Allocate the
// maximum number of devices as a global.
//

typedef struct _EZUSB_DEVICE_STATE {
    IUsbDevice *Device;
    BOOLEAN DeviceAttached : 1;
    BOOLEAN DeviceRemoved : 1;
    BOOLEAN DefaultEndpointOpened : 1;
    BOOLEAN ClosingEndpoints : 1;
    BOOLEAN RemoveDevicePending : 1;
    URB CloseEndpointUrb;
    KEVENT CloseEndpointEvent;
} EZUSB_DEVICE_STATE, *PEZUSB_DEVICE_STATE;

EZUSB_DEVICE_STATE EzusbDeviceState[XGetPortCount()];

//
// Track the device insertions and removal bitmasks here.  The application
// cannot use XGetDeviceChanges because the USB core driver only reports changes
// to XTL for devices without USB_DEVICE_CLASS_VENDOR_SPECIFIC as a class code.
//

DWORD EzusbDeviceInsertions;
DWORD EzusbDeviceRemovals;

//
// Define the EZ-USB vendor specific request codes.
//

#define EZUSB_REQUEST_FIRMWARE_LOAD                     0xA0

//
// Local support.
//

VOID
EzusbCloseEndpointsAsync(
    PEZUSB_DEVICE_STATE DeviceState
    );

VOID
EzusbInit(
    IUsbInit *UsbInit
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver to initialize the class
    driver.  This routine can allocate resources for the expected number of
    devices (either statically known or dynamically determined from the values
    from XInitDevices) and register resource requirements with the core USB
    driver.

Arguments:

    UsbInit - Specifies a virtual table of functions that can be used to control
        the behavior of this class driver.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PEZUSB_DEVICE_STATE DeviceState;

    for (dwPort = 0; dwPort < XGetPortCount(); dwPort++) {

        DeviceState = &EzusbDeviceState[dwPort];

        //
        // Initialize the event used to synchronize the closing of endpoints.
        //

        KeInitializeEvent(&DeviceState->CloseEndpointEvent,
            NotificationEvent, FALSE);
    }
}

VOID
EzusbAddDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been added that is supported by this class driver.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PEZUSB_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Verify that the device is attached to a legal port number.  Note that if
    // the device were plugged into the bottom slot of a hub, then the port
    // number will exceed XGetPortCount() and we'll ignore the device.
    //

    dwPort = Device->GetPort();

    if (dwPort >= XGetPortCount()) {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    DeviceState = &EzusbDeviceState[dwPort];

    //
    // Verify that we haven't already seen a device attached.
    //

    if (DeviceState->DeviceAttached) {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Remember that a device is physically attached.
    //

    DeviceState->DeviceAttached = TRUE;

    //
    // Store information about the device in our globals.
    //

    DeviceState->Device = Device;

    //
    // Notify the USB enumeration code that we have successfully added the
    // device.
    //

    DeviceState->Device->AddComplete(USBD_STATUS_SUCCESS);

    //
    // Remember that this device has been inserted in the global device bitmap.
    //

    EzusbDeviceInsertions |= (1 << dwPort);
}

VOID
EzusbRemoveDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been removed that had successfully been added before.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PEZUSB_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    dwPort = Device->GetPort();

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &EzusbDeviceState[dwPort];

    ASSERT(DeviceState->DeviceAttached);
    ASSERT(DeviceState->Device == Device);

    //
    // Remember that we're in the middle of a device removal.
    //

    DeviceState->RemoveDevicePending = TRUE;

    //
    // Close all of the open endpoints.  When this operation completes, the
    // remove device process will be completed.
    //

    EzusbCloseEndpointsAsync(DeviceState);

    //
    // Remember that this device has been removed in the global device bitmap.
    //

    EzusbDeviceRemovals |= (1 << dwPort);
}

VOID
EzusbCloseEndpointsComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after the URB has completed to close an endpoint.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to URB_BUILD_CONTROL_TRANSFER.

Return Value:

    None.

--*/
{
    PEZUSB_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceState = (PEZUSB_DEVICE_STATE)Context;

    if (DeviceState->DefaultEndpointOpened) {

        //
        // Close the default endpoint.
        //

        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb->CloseEndpoint,
                                         EzusbCloseEndpointsComplete,
                                         DeviceState);

        DeviceState->DefaultEndpointOpened = FALSE;

    } else {

        //
        // All endpoints are closed.  Signal the close endpoint event in case a
        // thread is waiting for the close endpoint to complete.
        //

        KeSetEvent(&DeviceState->CloseEndpointEvent, IO_NO_INCREMENT,
            FALSE);
        DeviceState->ClosingEndpoints = FALSE;

        //
        // If the device has been removed, then complete the device removal
        // process by notifying the USB enumeration code.
        //

        if (DeviceState->RemoveDevicePending) {

            DeviceState->RemoveDevicePending = FALSE;
            DeviceState->DeviceAttached = FALSE;
            DeviceState->DeviceRemoved = TRUE;

            DeviceState->Device->RemoveComplete();
        }

        return;
    }

    //
    // There's at least one endpoint still open.  If an endpoint is open, then
    // we must still think the device is logically attached and connected to
    // this device extension.
    //

    ASSERT(DeviceState->DeviceAttached);

    //
    // Submit the close request and wait for the USB driver to close the
    // endpoint.
    //

    DeviceState->Device->SubmitRequest(Urb);
}

VOID
EzusbCloseEndpointsAsync(
    PEZUSB_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine asynchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be closed.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we haven't already started closing endpoints, then kick off the
    // process.
    //

    if (!DeviceState->ClosingEndpoints) {

        //
        // Clear the close endpoint event used for synchronous close operations.
        //

        KeClearEvent(&DeviceState->CloseEndpointEvent);
        DeviceState->ClosingEndpoints = TRUE;

        //
        // Enter the close endpoints state machine.
        //

        EzusbCloseEndpointsComplete(&DeviceState->CloseEndpointUrb,
            DeviceState);
    }
}

VOID
EzusbCloseEndpoints(
    PEZUSB_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine synchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be opened.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Asynchronously close all of the open endpoints.  When all of the
    // endpoints are closed, the close endpoint event is signaled.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    EzusbCloseEndpointsAsync(DeviceState);

    KeLowerIrql(OldIrql);

    //
    // Block until the endpoints have been closed.
    //

    KeWaitForSingleObject(&DeviceState->CloseEndpointEvent, Executive,
        KernelMode, FALSE, NULL);
}

VOID
EzusbGetDeviceChanges(
    LPDWORD lpdwInsertions,
    LPDWORD lpdwRemovals
    )
/*++

Routine Description:

    This routine is the equivalent of XGetDeviceChanges for the EZ-USB device.

Arguments:

    lpdwInsertions - Specifies the buffer to receive the bitmask of devices that
        have been inserted.

    lpdwRemovals - Specifies the buffer to receive the bitmask of devices that
        have been removed.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    OldIrql = KeRaiseIrqlToDpcLevel();

    *lpdwInsertions = EzusbDeviceInsertions;
    *lpdwRemovals = EzusbDeviceRemovals;

    EzusbDeviceInsertions = 0;
    EzusbDeviceRemovals = 0;

    KeLowerIrql(OldIrql);
}

VOID
EzusbSignalEventComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after a generic URB has completed.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to the URB builder macro.

Return Value:

    None.

--*/
{
    //
    // Wake up the thread waiting for the URB to complete.
    //

    KeSetEvent((PKEVENT)Context, EVENT_INCREMENT, FALSE);
}

DWORD
EzusbFirmwareLoad(
    DWORD dwPort,
    WORD wStartingAddress,
    LPVOID lpvFirmware,
    WORD wNumberOfBytes,
    BOOL fUpload
    )
/*++

Routine Description:

    This routine performs a firmware upload or download for the EZ-USB default
    device.

Arguments:

    dwPort - Specifies the port number of the device to be accessed.

    wStartingAddress - Specifies the starting address to begin the transfer.

    lpvFirmware - Specifies the buffer that contains the data to be uploaded or
        the buffer to receive the data to be downloaded.

    wNumberOfBytes - Specifies the number of bytes to transfer.

    fUpload - Specifies TRUE if data is to be uploaded to the EZ-USB device,
        else FALSE if data is to be downloaded from the EZ-USB device.

Return Value:

    Status of operation.

--*/
{
    PEZUSB_DEVICE_STATE DeviceState;
    KIRQL OldIrql;
    DWORD UsbdStatus;
    KEVENT Event;
    URB Urb;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &EzusbDeviceState[dwPort];

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Verify that the device is attached.
    //

    if (!DeviceState->DeviceAttached) {
        KeLowerIrql(OldIrql);
        return ERROR_DEVICE_NOT_CONNECTED;
    }

    //
    // Open the default control endpoint, if we haven't already opened it.
    //

    if (!DeviceState->DefaultEndpointOpened) {

        USB_BUILD_OPEN_DEFAULT_ENDPOINT(&Urb.OpenEndpoint);

        UsbdStatus = DeviceState->Device->SubmitRequest(&Urb);

        if (!USBD_SUCCESS(UsbdStatus)) {
            KeLowerIrql(OldIrql);
            return IUsbDevice::Win32FromUsbdStatus(Urb.Header.Status);
        }

        DeviceState->DefaultEndpointOpened = TRUE;
    }

    //
    // Initialize the event used to wait URBs to complete.
    //

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Build and submit the vendor specific command to transfer the buffer.
    //

    USB_BUILD_CONTROL_TRANSFER(&Urb.ControlTransfer,
                               NULL,
                               lpvFirmware,
                               wNumberOfBytes,
                               USB_TRANSFER_DIRECTION_IN,
                               EzusbSignalEventComplete,
                               &Event,
                               TRUE,
                               USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_DEVICE,
                               EZUSB_REQUEST_FIRMWARE_LOAD,
                               wStartingAddress,
                               0,
                               wNumberOfBytes);

    if (fUpload) {
        Urb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_OUT;
        Urb.ControlTransfer.SetupPacket.bmRequestType =
            USB_HOST_TO_DEVICE | USB_VENDOR_COMMAND | USB_COMMAND_TO_DEVICE;
    }

    DeviceState->Device->SubmitRequest(&Urb);

    //
    // Wait for the URB to complete.  This must be done at lowered IRQL.
    //

    KeLowerIrql(OldIrql);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

    //
    // Check the URB for any errors.
    //

    if (USBD_ERROR(Urb.Header.Status)) {
        DbgPrint("EzusbFirmwareLoad failed %08x\n", Urb.Header.Status);
        return IUsbDevice::Win32FromUsbdStatus(Urb.Header.Status);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\hawk\hawk2.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.H

Abstract:

    Header file for hawk driver

Environment:

    kernel mode

Revision History:

    06-28-2000 : started : georgioc

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#define _XAPI_
#define _KERNEL32_
#define NODSOUND  //so we can use the private version
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <usb.h>
#include <xapidrv.h>
#include <dsoundp.h>
#include <xdbg.h>

//*****************************************************************************
// Useful Macros
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#if DBG || DEBUG_LOG

    extern ULONG               HawkDebugLevel;     // Level of debug output

#endif

#if !DBG

#define DBGPRINT(level, _x_)

#else

#define DBGPRINT(level, _x_) do { \
    if (level <= HawkDebugLevel) { \
        KdPrint(("HAWK: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

//*****************************************************************************
// A few remainder macros shamelessly stolen from dsound.
//*****************************************************************************
#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)
                                
//
// #pragma Reminders
//

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)
#define BUGBUG(a)               MESSAGE("BUGBUG: " a)
#define HACKHACK(a)             MESSAGE("HACKHACK: " a)

//*****************************************************************************
// Helpful defintions
//*****************************************************************************
#define HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE 0
#define HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE  1
#define HAWK_VENDOR_FEATURE_AGC             1
#define HAWK_VENDOR_FEATURE_SAMPLE_RATE     0
#define HAWK_BYTES_PER_SAMPLE               2
#define HAWK_USB_MAX_FRAMES                 8
#define HAWK_ISOCH_MAX_ATTACH_BUFFERS       3
#define HAWK_MIN_PACKET_FRAMES              10
#define HAWK_DEFAULT_MAX_OPENED             4
#define HAWK_MAX_SAMPLES_PER_USB_FRAME      24  //The highest support rate is 24 kHz
#define HAWK_MAX_BYTES_PER_USB_FRAME        (HAWK_MAX_SAMPLES_PER_USB_FRAME * HAWK_BYTES_PER_SAMPLE)
#define HAWK_WRAP_BUFFER_SIZE               (HAWK_USB_MAX_FRAMES * HAWK_MAX_BYTES_PER_USB_FRAME + 2)

#define HAWK_AGC_ON                         1
#define HAWK_AGC_OFF                        0
	
typedef struct _HAWK_STREAMING_RESOURCES *PHAWK_STREAMING_RESOURCES;
typedef struct _HAWK_PACKET_CONTEXT *PHAWK_PACKET_CONTEXT;
typedef struct _HAWK_TRANSFER_CONTEXT *PHAWK_TRANSFER_CONTEXT;
typedef struct _HAWK_WRAP_BUFFER *PHAWK_WRAP_BUFFER;
class XHawkMediaObject;

//*****************************************************************************
//  HAWK_PACKET_CONTEXT tracks a packet submitted via XMediaObject::Process  
//*****************************************************************************
typedef struct _HAWK_PACKET_CONTEXT
{
    XMEDIAPACKET         MediaPacket;
    PHAWK_PACKET_CONTEXT pNextPacket;
} HAWK_PACKET_CONTEXT;

//*****************************************************************************
//  HAWK_WRAP_BUFFER used to wrap 
//*****************************************************************************
typedef struct _HAWK_WRAP_BUFFER
{
    PHAWK_PACKET_CONTEXT pSecondPacket;
    PUCHAR               pucTransferBuffer;   //The beginning of the second buffer
    ULONG                ulSecondPacketBytes;
    UCHAR                Buffer[HAWK_WRAP_BUFFER_SIZE]; 
} HAWK_WRAP_BUFFER;

//*****************************************************************************
//  HAWK_TRANSFER_CONTEXT represents an oustanding Isoch Transfer
//*****************************************************************************
typedef struct _HAWK_TRANSFER_CONTEXT
{
    XHawkMediaObject           *pHawkMediaObject;    //The media object we are acting for.
    PHAWK_PACKET_CONTEXT        pPacketContext;      //The context we are tracking
    PUCHAR                      pucTransferBuffer;   //The beginning of this transfer
    ULONG                       ulTransferBytes;     //Bytes programmed in this transfer
    BOOLEAN                     fWrapBuffer;         //If TRUE, the wrap buffer was used.
    CHAR                        cFirstFrame;         //The first frame programmed
    UCHAR                       ucContextNumber;     //Number of this transfer frame.
    BOOLEAN                     fLastTransfer;       //Last Transfer of a Packet
} HAWK_TRANSFER_CONTEXT;

//*****************************************************************************
//  HAWK_SAMPLE_RATE_INFORMATION 
//*****************************************************************************
typedef struct _HAWK_SAMPLE_RATE_INFORMATION
{
    USHORT nSamplePerSecond;
    UCHAR  BytesPerUSBFrame;
    UCHAR  ExtraSampleInterval;
} HAWK_SAMPLE_RATE_INFORMATION, *PHAWK_SAMPLE_RATE_INFORMATION;
#define HAWK_SAMPLE_RATE_COUNT 5

class CHawkPacketQueue
{
    public:

     void InsertTail(PHAWK_PACKET_CONTEXT pPacketContext);
     PHAWK_PACKET_CONTEXT RemoveHead();
     PHAWK_PACKET_CONTEXT GetHead () {return m_pHead;}
        
    private:

     PHAWK_PACKET_CONTEXT m_pHead;
     PHAWK_PACKET_CONTEXT m_pTail;
};

#define HAWK_BCF_SHORT_PACKET  1
#define HAWK_BCF_DISCONTINUITY 2

#define HAWK_TRANSFER_CONTEXT_0 1
#define HAWK_TRANSFER_CONTEXT_1 2
#define HAWK_TRANSFER_CONTEXT_BOTH 3

typedef struct _HAWK_STREAMING_RESOURCES *PHAWK_STREAMING_RESOURCES;
typedef struct _HAWK_STREAMING_RESOURCES
{
    
    union
    {
        PHAWK_PACKET_CONTEXT m_pContextArray; //used to track the original allocation.
                                              //of packet contexts, so we can free them.

        PHAWK_STREAMING_RESOURCES pNextFree;  //only used while the streaming resources is on the 
                                              //free list.
    };      
    //
    //  Packet Queues
    //

    CHawkPacketQueue PendingProgram;
    CHawkPacketQueue Free;
    

    //
    //  USB Frame Information
    //
    
    CHAR  BytesPerUSBFrame;           //Bytes per USB frame (at some rates there is an extra 2 bytes, every
                                       //ExtraSampleInterval frames.
    CHAR  ExtraSampleInterval;        //USB frame intervals for which we must send\receive an extra sample.
    CHAR  ProgrammedFrame;            //Counts up to the ExtraSampleInterval
    CHAR  AvailableTransferContexts;  //Bit 0, is the 0

    //
    //  Contexts for keeping track of outstanding DMA
    //
    HAWK_TRANSFER_CONTEXT TransferContext[2];
    HAWK_WRAP_BUFFER      WrapBuffer;

    //
    //  Members for communicating with USB stack
    //
    KEVENT CloseEvent;
    URB_ISOCH_CLOSE_ENDPOINT     CloseUrb;
    PVOID EndpointHandle;
    
} HAWK_STREAMING_RESOURCES, *PHAWK_STREAMING_RESOURCES;


EXTERNUSB VOID
HawkInit (IUsbInit *pUsbInit);

EXTERNUSB VOID
HawkAddDevice (
    IN IUsbDevice *Device
    );

EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    );

XBOXAPI
EXTERN_C
HRESULT
WINAPI
XVoiceCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN PWAVEFORMATEX  pwfxFormat OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      );

EXTERN_C
HRESULT
WINAPI
XVoiceCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN LPWAVEFORMATEX pwfxFormat,
      IN PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      IN PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      );

//*****************************************************************************
// XHawkMediaObject
//*****************************************************************************

class XHawkMediaObject : public XMediaObject
{

    public:
        //
        //  Declaration of IUnknown members
        //  (minus QI which was nuked)
        
        STDMETHOD_(ULONG, AddRef) (void);

        STDMETHOD_(ULONG, Release) (void);

        //
        //  Declaration of XMediaObject members
        //
       STDMETHOD(GetInfo) (
            OUT PXMEDIAINFO pInfo
            );
        
        STDMETHOD(Flush) (void);
        
        STDMETHOD(Discontinuity) (void);
        
        STDMETHOD(GetStatus) (
            OUT DWORD *pdwFlags
            );
        
        STDMETHOD(Process) (
            IN LPCXMEDIAPACKET   pInputPacket,
            IN LPCXMEDIAPACKET   pOutputPacket
            );
        
        XHawkMediaObject() :
            m_pDevice(NULL),
		    m_wMaxPacket(0),
            m_bEndpointAddress(0),
            m_fConnected(FALSE),
		    m_fOpened(FALSE),
		    m_fClosePending(FALSE),
            m_fRemovePending(FALSE),
            m_fMicrophone(FALSE),
            m_fReady(FALSE),
            m_fClosingEndpoint(FALSE),
            m_Reserved(0),
            m_lRefCount(0),
            m_pStreamingResources(NULL),
            m_pfnCallback(NULL),
            m_pvContext(NULL)
            {}

        static void InitializeClass(ULONG ulMicrophoneCount, ULONG ulHeadphoneCount); //Initialize static members
	
		//
        //	Keeps track of the static list
		//	of objects
		//
		static XHawkMediaObject *sm_pMicrophones;	//Array of microphone instances
		static XHawkMediaObject *sm_pHeadphones;	//Array of headphone instances
        static UCHAR            *sm_pRateIndices;   //Array of sample rate indices for device instances
        static UCHAR            *sm_pRateIndexRefCounts; //Array of reference counts on rate indices
        static USHORT           sm_AvailableHeadphoneResources; //Count of streaming resources available for headphones
        static USHORT           sm_AvailableMicrophoneResources; //Count of streaming resources available for microphones
        static PHAWK_STREAMING_RESOURCES sm_pFreeStreamingResources; //Free list of streaming resource structures.
        static HAWK_SAMPLE_RATE_INFORMATION sm_HawkSampleRates[HAWK_SAMPLE_RATE_COUNT];
        

    private:
        
        //
		//	Information Detected During enumeration.
		//
        IUsbDevice          *m_pDevice;
		WORD			    m_wMaxPacket;
        UCHAR			    m_bEndpointAddress;
		
		//
		//	Running Per Instance State Information
		//
        //  Notes on state flag.  Connecting
        //  and opening a device is synchronous.
        //  Closing a device is asynchronous.
        //
        
		UCHAR			   m_fConnected:1;
		UCHAR			   m_fOpened:1;
		UCHAR			   m_fClosePending:1;
        UCHAR			   m_fRemovePending:1;
        UCHAR			   m_fMicrophone:1;
        UCHAR              m_fReady:1;
        UCHAR              m_fClosingEndpoint:1;
        UCHAR              m_Reserved:1;

        LONG			   m_lRefCount;

        //
        //  For internal callbacks
        //
        PFNXMEDIAOBJECTCALLBACK    m_pfnCallback;
        PVOID                      m_pvContext;

	    //
		//	Streaming Resources (only needed for operation)
		//
		PHAWK_STREAMING_RESOURCES m_pStreamingResources;

        //
        //  Private help methods
        //
        HRESULT AllocateStreamingResources (ULONG ulMaxAttachedPackets, ULONG ulRateIndex);
        void FreeStreamingResources (void);
        void CloseEndpoint (void);
        static void CloseEndpointComplete (IN PURB, IN XHawkMediaObject *pThis);
        void ProgramTransfer(void);
        static void TransferComplete(IN PUSBD_ISOCH_TRANSFER_STATUS Status, IN PVOID pvContext);
        void AbortMediaPackets();
        HRESULT SetSampleRate(UCHAR ucRateIndex, KIRQL BaseIrql);
		HRESULT SetAGC(UCHAR ucAGC, KIRQL BaseIrql);


    //
    //  The XcreateHawkMediaObject factory method, and the
    //  USB interface methods, need to be friends.  They
    //  all would be members, but they must be C calleable.
    //
    friend HRESULT 
    XVoiceCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN PWAVEFORMATEX  pwfxFormat  OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      );

    friend HRESULT
    XVoiceCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN LPWAVEFORMATEX pwfxFormat,
      IN PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      IN PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      );

    
    friend VOID HawkInit (IUsbInit *pUsbInit);

    friend VOID HawkAddDevice (
                    IN IUsbDevice *Device
                    );

    friend VOID HawkRemoveDevice (
                    IN IUsbDevice *Device
                    );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\inc\debug.h ===
/*++

Copyright (c) 1990 Microsoft Corporation


Module Name:

    debug.h

Abstract:

    Debug related definitions and declarations used in uhcd, usbd, usbn, and usbh.

    The following compiler definitions are effective

    DBG - Debug function, only works in debug builds.
    RAISE_TODO_AND_BUGBUG - causes USB_TODO() and USB_BUGBUG statments to compile
    DBG_MAX     - Changes the default Traceout Level to Maximum (does NOT include RAISE_TODO_AND_BUGBUG)
    DBG_CALL    - Changes the default Traceout Level to include function entry and exit

Environment:

    XBOX kernel mode only

Notes:

Revision History:

    12-27-99 created by Mitchell Dernis (mitchd)

--*/

#ifndef DEBUG_H
#define DEBUG_H

#pragma warning(push, 4)
#pragma warning(disable:4244) //This warning seems to be broken.
#pragma warning(disable:4505) //XUSBDbg* functions should be discarded if not used
#include <xdbg.h>


/*
**  Definitions for compiler warnings.
**
*/
#define QUOTE0(a)  #a
#define QUOTE1(a)  QUOTE0(a)
#define MESSAGE(a) message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)    MESSAGE("TODO: " a)
#define BUGBUG(a)  MESSAGE("BUGBUG: " a)

/*
**  Definitions for DEBUG BUILDS
**
**
*/
#if DBG

//
//  Declaration for debug module
//

#define DEFINE_USB_DEBUG_FUNCTIONS(Module) \
    static VOID XUSBDbgErr(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_ERROR, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgWrn(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_WARNING, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgTrc(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_TRACE, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgEnt(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_ENTRY, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgExt(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_EXIT, Module, Format, args); va_end(args); }

//
//  Conditional debug output procedures
//

#if (XDBG_COMPILE_LEVEL >= XDBG_ENTRY)
#define USB_DBG_ENTRY_PRINT(__x__) XUSBDbgEnt __x__;
#else
#define USB_DBG_ENTRY_PRINT(__x__)
#endif
    
#if (XDBG_COMPILE_LEVEL >= XDBG_EXIT)
#define USB_DBG_EXIT_PRINT(__x__) XUSBDbgExt __x__;
#else
#define USB_DBG_EXIT_PRINT(__x__)
#endif
    
#if (XDBG_COMPILE_LEVEL >= XDBG_WARNING)
#define USB_DBG_WARN_PRINT(__x__) XUSBDbgWrn __x__;
#else
#define USB_DBG_WARN_PRINT(__x__)
#endif

#ifdef PROMOTE_TRACE_TO_WARN
#define USB_DBG_TRACE_PRINT(__x__) XUSBDbgWrn __x__;
#else
#if (XDBG_COMPILE_LEVEL >= XDBG_TRACE)
#define USB_DBG_TRACE_PRINT(__x__) XUSBDbgTrc __x__;
#else
#define USB_DBG_TRACE_PRINT(__x__)
#endif
#endif
    
#if (XDBG_COMPILE_LEVEL >= XDBG_ERROR)
#define USB_DBG_ERROR_PRINT(__x__) XUSBDbgErr __x__;
#else
#define USB_DBG_ERROR_PRINT(__x__)
#endif
    
#define DBG_BREAK() DbgBreakPoint()

#undef  PAGED_CODE
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) \
    {\
        USB_DBG_CRITICAL_PRINT(("Pageable code called at IRQL %ld (file: %s, line:#%ld)\n", KeGetCurrentIrql(),__FILE__,__LINE__))\
        ASSERT(FALSE);\
    }

#define ASSERT_LESS_THAN_DISPATCH_LEVEL() \
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)   \
    {\
        DbgPrint("%s(%ld): Assertion that IRQL was below DISPATCH_LEVEL failed: IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }

#define ASSERT_LESS_THAN_OR_EQUAL_DISPATCH_LEVEL() \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL)    \
    {\
        DbgPrint("%s(%ld): Assertion that IRQL was less than or equal to DISPATCH_LEVEL failed: IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }

#define ASSERT_PASSIVE_LEVEL()\
{\
    if(KeGetCurrentIrql() != PASSIVE_LEVEL)\
    {\
        DbgPrint("%s(%ld): Routine which must be called at PASSIVE_LEVEL was called at IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }\
}

#define ASSERT_DISPATCH_LEVEL()\
{\
    if(KeGetCurrentIrql() != DISPATCH_LEVEL)\
    {\
        DbgPrint("%s(%ld): Routine which must be called at DISPATCH_LEVEL was called at IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }\
}

#define USING_CASE_FALLTHROUGH_TRACE    ULONG macro_ulTraceoutSentAlready = FALSE;
#define START_CASE_FALLTHROUGH_TRACE    macro_ulTraceoutSentAlready = FALSE;
#define TRACEOUT_THIS_CASE_ONLY         if(!macro_ulTraceoutSentAlready && (macro_ulTraceoutSentAlready=TRUE) )



//#define RTL_ALLOCATE_HEAP(_size_) ExAllocatePoolWithTag(_size_,MODULE_POOL_TAG)
//#define RTL_FREE_HEAP(_block_) ExFreePool(_block_)

//
//  Beefed up allocate pool with traceout
//
#ifdef USB_TRACE_MEMORY_ALLOCATE_FREE
static PVOID pvAllocateTemp;
#define RTL_ALLOCATE_HEAP(_size_)\
    ( \
        (pvAllocateTemp = ExAllocatePoolWithTag((_size_),MODULE_POOL_TAG)),\
        DbgPrint( "%s(%d): RTL_ALLOCATE_HEAP(%d) returning 0x%0.8x\n",\
                    __FILE__,\
                    __LINE__,\
                    _size_,\
                    pvAllocateTemp\
        ),\
        pvAllocateTemp\
    )

#define RTL_FREE_HEAP(_block_)\
    (\
        DbgPrint("%s(%d): RTL_FREE_HEAP(0x%0.8x)\n", __FILE__, __LINE__, _block_),\
        ExFreePool(_block_)\
    )

#else  //not defined USB_TRACE_MEMORY_ALLOCATE_FREE

#define RTL_ALLOCATE_HEAP(_size_) ExAllocatePoolWithTag((_size_),MODULE_POOL_TAG)
#define RTL_FREE_HEAP(_block_) ExFreePool(_block_)

#endif //USB_TRACE_MEMORY_ALLOCATE_FREE

/*
**  Definitions for RELEASE builds
**
**
*/

#else       // DBG=0

#define USB_DBG_ENTRY_PRINT(__x__)
#define USB_DBG_EXIT_PRINT(__x__)
#define USB_DBG_TRACE_PRINT(__x__)
#define USB_DBG_WARN_PRINT(__x__)
#define USB_DBG_ERROR_PRINT(__x__)
#define DEFINE_USB_DEBUG_FUNCTIONS(Module)
#define DBG_BREAK()
#undef  PAGED_CODE
#define PAGED_CODE()
#define ASSERT_LESS_THAN_DISPATCH_LEVEL()
#define ASSERT_LESS_THAN_OR_EQUAL_DISPATCH_LEVEL()
#define ASSERT_DISPATCH_LEVEL()
#define ASSERT_PASSIVE_LEVEL()
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)
#define SET_MODULE_DEBUG_LEVEL(__x__)
#define USING_CASE_FALLTHROUGH      
#define START_CASE_FALLTHROUGH_TRACE
#define TRACEOUT_THIS_CASE_ONLY     

#define EX_ALLOCATE_POOL(_size_) ExAllocatePool(_size_)
#define EX_FREE_POOL(_block_) ExFreePool(_block_)
#define RTL_ALLOCATE_HEAP(_size_) ExAllocatePool(_size_)
#define RTL_FREE_HEAP(_block_) ExFreePool(_block_)

#endif  // DBG=?

//===========================================================================
//  Profiling things
//===========================================================================
#ifdef PERFORM_PROFILING


//
//  Some macros for neatly adding profiling checks and traceouts
//  in the future we may choose to log these instead.
//
#define PROFILE_DECLARE_TIME_STAMP(_Timer_)\
            LARGE_INTEGER _Timer_;
#define PROFILE_BEGIN_TIMING(_Timer_)\
            _Timer_ = KeQueryPerformanceCounter();
#define PROFILE_END_TIMING(_Timer_)\
        {\
            LARGE_INTEGER _TempTimeDiff_;\
            LARGE_INTEGER _TempTimerFreq_;\
            ULONG         _TempTimeDiffUs_;\
            _TempTimeDiff_ = (_Timer_ - KeQueryPerformanceCounter(&_TempTimerFreq_);\
            _TempTimerFreq_.QuadPart /= 100000; /*Convert to ticks per us*/\
            _TempTimeDiffUs_ = (ULONG)(_TempTimeDiff_.QuadPart / _TempTimerFreq_.QuadPart);
            DbgPrint( USB_TRACE_NAME );\
            DbgPrint( ": " );\
            DbgPrint("\'%s\' took %d us.\n", #_Timer_, _TempTimeDiffUs_);\
        }


#else //PERFORM_PROFILING

//
//  These are all NOPs
//
#define PROFILE_DECLARE_TIME_STAMP(_Timer_)
#define PROFILE_BEGIN_TIMING(_Timer_)
#define PROFILE_END_TIMING(_Timer_)

#endif //PERFORM_PROFILING


//===========================================================================
//          End
//===========================================================================

#endif  // DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\inc\hcdi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    hcdi.h

    Generated from usb.x

Abstract:

    Header File for  host controller driver

Environment:

    Xbox

--*/

#ifndef __USB_X__
#define __USB_X__



//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")

#include <usb100.h>

//
// XBOX platform USB device classes
//

#define XBOX_DEVICE_CLASS_INPUT_DEVICE              0x58
#define XBOX_DEVICE_CLASS_XDCS                      0x59
#define XBOX_DEVICE_CLASS_AUDIO_DEVICE              0x78

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          10 - completed with error, endpoint not stalled
//          11 - completed with error, endpoint stalled
//
//
//      Code - is the status code
//

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)

//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)

//
//	Status returned by hub, when a reset completes successfully and the
//	device is low-speed.
//
#define USBD_STATUS_LOWSPEED				 ((USBD_STATUS)0x01000000L)


//------------------------------------------------------------------------------------
// URB Function Codes   - High bit indicates that USBD (pre-)processes URB
//------------------------------------------------------------------------------------
//-- special bit in URB_FUNCTION codes -----------------
#define URB_FUNCTION_USBD_PROCESSED                 0x80    
#define URB_FUNCTION_ASYNCHRONOUS                   0x40
//------------------------------------------------------
#define URB_FUNCTION_CONTROL_TRANSFER               (0x00 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     (0x01 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_OPEN_ENDPOINT                  0x02
#define URB_FUNCTION_CLOSE_ENDPOINT                 (0x03 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_ENDPOINT_STATE             0x04
#define URB_FUNCTION_SET_ENDPOINT_STATE             0x05
#define URB_FUNCTION_ABORT_ENDPOINT                 (0x06 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_FRAME_NUMBER               0x07
#define URB_FUNCTION_OPEN_DEFAULT_ENDPOINT          (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_OPEN_ENDPOINT)
#define URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT         (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_CLOSE_ENDPOINT)
#define URB_FUNCTION_RESET_PORT                     (URB_FUNCTION_USBD_PROCESSED | 0x08)
#define URB_FUNCTION_ISOCH_OPEN_ENDPOINT            0x09
#define URB_FUNCTION_ISOCH_CLOSE_ENDPOINT           (0x0A | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_ISOCH_ATTACH_BUFFER            0x0B
#define URB_FUNCTION_ISOCH_START_TRANSFER           0x0C
#define URB_FUNCTION_ISOCH_STOP_TRANSFER            0x0D

//------------------------------------------------------------------------------------
//  Values for the transfer directions
//------------------------------------------------------------------------------------
#define USB_TRANSFER_DIRECTION_OUT              0x01
#define USB_TRANSFER_DIRECTION_IN               0x02

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_GET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_HALTED              	0x01    //Set on return if endpoint is halted.
#define USB_ENDPOINT_STATE_TRANSFERS_QUEUED     0x02    //Set on return if one or more transfers are queued to endpoint.

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_SET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_CLEAR_HALT		    0x00    //Clear endpoint halt.
#define USB_ENDPOINT_STATE_KEEP_HALT		    0x01    //Do not clear enddpoint halt
#define USB_ENDPOINT_STATE_DATA_TOGGLE_RESET    0x04    //Reset data toggle. (i.e. DATA0)
#define USB_ENDPOINT_STATE_DATA_TOGGLE_SET      0x08    //Set data toggle. (i.e. DATA1), provided for testing.
//There is no USB_ENDPOINT_STATE_SET_HALT, since only the hardware may set it.

//----------------------------------------------------------------------------------------------------------------------
// Macros for the InterruptDelay variable in transfer and attach buffer URBs - this is really an OpenHCI thing,
// but gives more control to class drivers.  These are the same as OHCI_TD_DELAY_INTERRUPT_XXX
// DUE TO BUG 9512 IT IS ONLY SAFE TO USE USBD_DELAY_INTERRUPT_0_MS.  OTHERWISE, YOU MAY EXPERIENCE PROBLEMS
// WHEN CLOSING THE ENDPOINT.  SEE BUG 9512 FOR MORE DETAILS.
//----------------------------------------------------------------------------------------------------------------------
#define USBD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define USBD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define USBD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 4 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 5 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_6_MS        6   // Interrupt within  frame of TD compeletion
#define USBD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD

//------------------------------------------------------------------------------------
// USBD Structures for class drivers
//------------------------------------------------------------------------------------
typedef union _URB *PURB;
typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

//
//  See approptate HCD header file for
//  for flags.
//
struct _URB_HCD_AREA
{
    union
    {
        USHORT  HcdTDCount;
        USHORT  HcdOriginalLength;  //While programed contains the original length
    
	};
    USHORT  HcdUrbFlags;
	PURB    HcdUrbLink;     //Used while the URB is pending
};

struct _URB_HEADER
{
    UCHAR               Length;
    UCHAR               Function;
    USBD_STATUS         Status;
    PURB_COMPLETE_PROC  CompleteProc;       // A completetion routine if the URB is not associated with an Irp
    PVOID               CompleteContext;    // Context to pass into the completion routine.
};

typedef struct _USB_CONTROL_SETUP_PACKET
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_CONTROL_SETUP_PACKET;

typedef struct _URB_CONTROL_TRANSFER
{
    struct _URB_HEADER          Hdr;                    
    PVOID                       EndpointHandle;
    ULONG                       TransferBufferLength;
    PVOID                       TransferBuffer;
    UCHAR                       TransferDirection;
    BOOLEAN                     ShortTransferOK;
    UCHAR                       InterruptDelay;
    UCHAR                       Padding;
    struct _URB_HCD_AREA        Hca;
    USB_CONTROL_SETUP_PACKET    SetupPacket;
} URB_CONTROL_TRANSFER, *PURB_CONTROL_TRANSFER;

typedef struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   TransferBufferLength;
    PVOID                   TransferBuffer;
    UCHAR                   TransferDirection;
    BOOLEAN                 ShortTransferOK;
    UCHAR                   InterruptDelay;
    UCHAR                   Padding;
    struct _URB_HCD_AREA    Hca;   // fields for HCD use
} URB_BULK_OR_INTERRUPT_TRANSFER, *PURB_BULK_OR_INTERRUPT_TRANSFER;


typedef struct _URB_OPEN_ENDPOINT
{
    struct _URB_HEADER          Hdr;
    PVOID                       EndpointHandle;
    UCHAR                       FunctionAddress;
    UCHAR                       EndpointAddress;
    UCHAR                       EndpointType;
    UCHAR                       Interval;
    PULONG                      DataToggleBits; // Filled out by USBD
    USHORT                      MaxPacketSize;
    BOOLEAN                     LowSpeed;   //Temporary - filled out by USBD
} URB_OPEN_ENDPOINT, *PURB_OPEN_ENDPOINT;

typedef struct _URB_CLOSE_ENDPOINT
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    PURB                   HcdNextClose;   // An extra pointer which Hcd can use to link pending closes.
    PULONG                 DataToggleBits; // Filled out by USBD
} URB_CLOSE_ENDPOINT, *PURB_CLOSE_ENDPOINT;

typedef struct _URB_GET_SET_ENDPOINT_STATE
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   EndpointState;
} URB_GET_SET_ENDPOINT_STATE, *PURB_GET_SET_ENDPOINT_STATE;

typedef struct _URB_ABORT_ENDPOINT
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    PURB                    HcdNextAbort;   // An extra pointer which Hcd can use to link pending aborts.
} URB_ABORT_ENDPOINT, *PURB_ABORT_ENDPOINT;

typedef struct _URB_RESET_PORT
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    UCHAR               PortNumber;
} URB_RESET_PORT, *PURB_RESET_PORT;

typedef struct _URB_GET_FRAME_NUMBER
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    ULONG               FrameNumber;
} URB_GET_FRAME_NUMBER, *PURB_GET_FRAME_NUMBER;


//------------------------------------------------
// Isoch related URBs and related structures
//------------------------------------------------
typedef struct _USBD_ISOCH_PACKET_STATUS_WORD
{
    USHORT BytesRead:12;
    USHORT ConditionCode:4;
} USBD_ISOCH_PACKET_STATUS_WORD, *PUSBD_ISOCH_PACKET_STATUS_WORD;

typedef struct _USBD_ISOCH_TRANSFER_STATUS
{
    USBD_STATUS                     Status;
    ULONG                           FrameCount;
    USBD_ISOCH_PACKET_STATUS_WORD   PacketStatus[8];
} USBD_ISOCH_TRANSFER_STATUS, *PUSBD_ISOCH_TRANSFER_STATUS;

typedef VOID (*PFNUSBD_ISOCH_TRANSFER_COMPLETE)(PUSBD_ISOCH_TRANSFER_STATUS Status, PVOID Context);

typedef struct _USBD_ISOCH_BUFFER_DESCRIPTOR
{
    ULONG                               FrameCount;
    PVOID                               TransferBuffer;
    USHORT                              Pattern[8];
    PFNUSBD_ISOCH_TRANSFER_COMPLETE     TransferComplete;
    PVOID                               Context;
} USBD_ISOCH_BUFFER_DESCRIPTOR, *PUSBD_ISOCH_BUFFER_DESCRIPTOR;

typedef struct _URB_ISOCH_ATTACH_BUFFER
{
    struct _URB_HEADER            Hdr;
    PVOID                         EndpointHandle;
    UCHAR                         InterruptDelay;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR BufferDescriptor;
} URB_ISOCH_ATTACH_BUFFER, *PURB_ISOCH_ATTACH_BUFFER;

typedef struct _URB_ISOCH_START_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    ULONG                  FrameNumber;
    ULONG                  Flags;
} URB_ISOCH_START_TRANSFER, *PURB_ISOCH_START_TRANSFER;
#define URB_FLAG_ISOCH_START_ASAP 0x0001
#define USBD_ISOCH_START_FRAME_RANGE 1024

typedef struct _URB_ISOCH_STOP_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
} URB_ISOCH_STOP_TRANSFER, *PURB_ISOCH_STOP_TRANSFER;

typedef struct _URB_ISOCH_OPEN_ENDPOINT
{
    struct _URB_HEADER              Hdr;
    PVOID                           EndpointHandle;
    UCHAR                           FunctionAddress;
    UCHAR                           EndpointAddress;
    USHORT                          MaxPacketSize;
    USHORT                          Flags;
    USHORT                          Pad;
} URB_ISOCH_OPEN_ENDPOINT, *PURB_ISOCH_OPEN_ENDPOINT;
#define URB_FLAG_ISOCH_CIRCULAR_DMA 0x0001

typedef struct _URB_CLOSE_ENDPOINT URB_ISOCH_CLOSE_ENDPOINT, *PURB_ISOCH_CLOSE_ENDPOINT;

//------------------------------------------------
// Union of all URBs
//------------------------------------------------
typedef union _URB
{
    struct _URB_HEADER              Header;
    URB_CONTROL_TRANSFER            ControlTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkOrInterruptTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  CommonTransfer;
    URB_OPEN_ENDPOINT               OpenEndpoint;
    URB_CLOSE_ENDPOINT              CloseEndpoint;
    URB_GET_SET_ENDPOINT_STATE      GetSetEndpointState;
    URB_ABORT_ENDPOINT              AbortEndpoint;
    URB_RESET_PORT                  ResetPort;
    URB_GET_FRAME_NUMBER            GetFrame;
    URB_ISOCH_ATTACH_BUFFER         IsochAttachBuffer;
    URB_ISOCH_START_TRANSFER        IsochStartTransfer;
    URB_ISOCH_STOP_TRANSFER         IsochStopTransfer;
    URB_ISOCH_OPEN_ENDPOINT         IsochOpenEndpoint;
    URB_ISOCH_CLOSE_ENDPOINT        IsochCloseEndpoint;
} URB;

//------------------------------------------------------------------------------------
// Macros to build USB Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CONTROL_TRANSFER(\
                        _UrbControlTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_,\
                        _bmRequestType_,\
                        _bRequest_,\
                        _wValue_,\
                        _wIndex_,\
                        _wLength_\
    )\
    {\
        (_UrbControlTransfer_)->Hdr.Length                  =   sizeof(URB_CONTROL_TRANSFER);\
        (_UrbControlTransfer_)->Hdr.Function                =   URB_FUNCTION_CONTROL_TRANSFER;\
        (_UrbControlTransfer_)->Hdr.CompleteProc            =   (_CompleteProc_);\
        (_UrbControlTransfer_)->Hdr.CompleteContext         =   (_CompleteContext_);\
        (_UrbControlTransfer_)->EndpointHandle              =   (_EndpointHandle_);\
        (_UrbControlTransfer_)->TransferBuffer              =   (_TransferBuffer_);\
        (_UrbControlTransfer_)->TransferBufferLength        =   (_TransferBufferLength_);\
        (_UrbControlTransfer_)->TransferDirection           =   (_TransferDirection_);\
        (_UrbControlTransfer_)->ShortTransferOK             =   (_ShortTransferOK_);\
        (_UrbControlTransfer_)->InterruptDelay              =   USBD_DELAY_INTERRUPT_0_MS;\
        (_UrbControlTransfer_)->SetupPacket.bmRequestType   =   (_bmRequestType_);\
        (_UrbControlTransfer_)->SetupPacket.bRequest        =   (_bRequest_);\
        (_UrbControlTransfer_)->SetupPacket.wValue          =   (_wValue_);\
        (_UrbControlTransfer_)->SetupPacket.wIndex          =   (_wIndex_);\
        (_UrbControlTransfer_)->SetupPacket.wLength         =   (_wLength_);\
    }


#define USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(\
                        _UrbBulkOrInterruptTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_\
    )\
    {\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Length          =   sizeof(URB_BULK_OR_INTERRUPT_TRANSFER);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Function        =   URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteProc    =   (_CompleteProc_);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteContext =   (_CompleteContext_);\
        (_UrbBulkOrInterruptTransfer_)->EndpointHandle      =   (_EndpointHandle_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBuffer      =   (_TransferBuffer_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBufferLength=   (_TransferBufferLength_);\
        (_UrbBulkOrInterruptTransfer_)->TransferDirection   =   (_TransferDirection_);\
        (_UrbBulkOrInterruptTransfer_)->ShortTransferOK     =   (_ShortTransferOK_);\
        (_UrbBulkOrInterruptTransfer_)->InterruptDelay      =   USBD_DELAY_INTERRUPT_0_MS;\
    }

//
// Isoch requests
//

#define USB_BUILD_ISOCH_OPEN_ENDPOINT(\
                        _UrbIsochOpenEndpoint_,\
                        _EndpointAddress_,\
                        _MaxPacketSize_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochOpenEndpoint_)->Hdr.Length         =   sizeof(URB_ISOCH_OPEN_ENDPOINT);\
        (_UrbIsochOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_ISOCH_OPEN_ENDPOINT;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteContext=   NULL;\
        (_UrbIsochOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbIsochOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
        (_UrbIsochOpenEndpoint_)->Flags              =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_CLOSE_ENDPOINT(\
                        _UrbIsochCloseEndpoint_,\
                        _EndpointHandle_,\
						_CompleteProc_,\
						_CompleteContext_\
    )\
    {\
        (_UrbIsochCloseEndpoint_)->Hdr.Length           =   sizeof(URB_ISOCH_CLOSE_ENDPOINT);\
        (_UrbIsochCloseEndpoint_)->Hdr.Function         =   URB_FUNCTION_ISOCH_CLOSE_ENDPOINT;\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteProc     =   (_CompleteProc_);\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteContext  =   (_CompleteContext_);\
        (_UrbIsochCloseEndpoint_)->EndpointHandle       =   (_EndpointHandle_);\
    }

#define USB_BUILD_ISOCH_START_TRANSFER(\
                        _UrbIsochStartTransfer_,\
                        _EndpointHandle_,\
                        _FrameNumber_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochStartTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_START_TRANSFER);\
        (_UrbIsochStartTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_START_TRANSFER;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStartTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochStartTransfer_)->FrameNumber          =   (_FrameNumber_);\
        (_UrbIsochStartTransfer_)->Flags                =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_STOP_TRANSFER(\
                        _UrbIsochStopTransfer_,\
                        _EndpointHandle_\
    )\
    {\
        (_UrbIsochStopTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_STOP_TRANSFER);\
        (_UrbIsochStopTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_STOP_TRANSFER;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStopTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
    }


#define USB_BUILD_ISOCH_ATTACH_BUFFER(\
                        _UrbIsochAttachBuffer_,\
                        _EndpointHandle_,\
                        _InterruptDelay_,\
                        _BufferDescriptor_\
    )\
    {\
        (_UrbIsochAttachBuffer_)->Hdr.Length            =   sizeof(URB_ISOCH_ATTACH_BUFFER);\
        (_UrbIsochAttachBuffer_)->Hdr.Function          =   URB_FUNCTION_ISOCH_ATTACH_BUFFER;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteProc      =   NULL;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteContext   =   NULL;\
        (_UrbIsochAttachBuffer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochAttachBuffer_)->InterruptDelay       =   (_InterruptDelay_);\
        (_UrbIsochAttachBuffer_)->BufferDescriptor     =   (_BufferDescriptor_);\
    }

//
// Bulk or Interrupt requests
//

#define USB_BUILD_OPEN_ENDPOINT(\
                        _UrbOpenEndpoint_,\
                        _EndpointAddress_,\
                        _EndpointType_,\
                        _MaxPacketSize_,\
                        _Interval_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbOpenEndpoint_)->EndpointType       =   (_EndpointType_);\
        (_UrbOpenEndpoint_)->Interval           =   (_Interval_);\
        (_UrbOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
    }

#define USB_BUILD_CLOSE_ENDPOINT(\
                        _UrbCloseEndpoint_,\
                        _EndpointHandle_,\
                        _CompleteProc_,\
                        _CompleteContext_\
    )\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
        (_UrbCloseEndpoint_)->EndpointHandle    =   (_EndpointHandle_);\
    }

#define USB_BUILD_OPEN_DEFAULT_ENDPOINT(\
                            _UrbOpenEndpoint_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_DEFAULT_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
    }

#define USB_BUILD_CLOSE_DEFAULT_ENDPOINT(_UrbCloseEndpoint_, _CompleteProc_, _CompleteContext_)\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
    }

#define USB_BUILD_GET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_GET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_SET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_, _StateFlags_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_SET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
    (_UrbGetSetEndpointState_)->EndpointState       =   (_StateFlags_);\
}

#define USB_BUILD_ABORT_ENDPOINT(_UrbAbortEndpoint_, _EndpointHandle_, _CompleteProc_, _CompleteContext_)\
{\
    (_UrbAbortEndpoint_)->Hdr.Length          =   sizeof(URB_ABORT_ENDPOINT);\
    (_UrbAbortEndpoint_)->Hdr.Function        =   URB_FUNCTION_ABORT_ENDPOINT;\
    (_UrbAbortEndpoint_)->Hdr.CompleteProc    =   (_CompleteProc_);\
	(_UrbAbortEndpoint_)->Hdr.CompleteContext =   (_CompleteContext_);\
    (_UrbAbortEndpoint_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_RESET_PORT(_UrbResetPort_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_RESET_PORT);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_RESET_PORT;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

#define USB_BUILD_GET_FRAME(_UrbGetFrame_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_GET_FRAME);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_GET_FRAME;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

//------------------------------------------------------------------------------------
// Macros to build standard USB Command Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CLEAR_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_CLEAR_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_SET_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_GET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Configuration_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_Configuration_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = TRUE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}

#define USB_BUILD_SET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_OUT;\
    (_UrbControlTransfer_)->ShortTransferOK             = FALSE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}


#define USB_BUILD_GET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_AlternateSetting_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_AlternateSetting_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_STATUS(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _Index_,\
                _Status_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Status_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|(_Recipient_));\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_STATUS;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

#define USB_BUILD_SYNC_FRAME(\
                _UrbControlTransfer_,\
                _Endpoint_,\
                _Frame_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Frame_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|USB_COMMAND_TO_ENDPOINT);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SYNC_FRAME;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Endpoint_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

//-------------------------------------------------------------------------------------------------------------
// Get the USB status code
//-------------------------------------------------------------------------------------------------------------
#define URB_STATUS(urb) ((urb)->Header.Status)
//------------------------------------------------------------------------------------
// bmRequestType values for commands over control pipes, belongs in usb100.h
//------------------------------------------------------------------------------------

//  Data Direction
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

//  Type
#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

//  Recipient
#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//------------------------------------------------------------------------------------
// The enumerator only provides the first eight bytes of the device descriptor
//------------------------------------------------------------------------------------
typedef struct _USB_DEVICE_DESCRIPTOR8 {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
} USB_DEVICE_DESCRIPTOR8, *PUSB_DEVICE_DESCRIPTOR8;
//---------------------------------------------------------------------------------------------------------------
// USB_HOST_CONTROLLER - Host Controller Configuration Selection
//---------------------------------------------------------------------------------------------------------------
#define USB_SINGLE_HOST_CONTROLLER 1
#define USB_DUAL_HOST_CONTROLLER_XDK 2
//  Select which configuragtion to use.

#ifndef USB_HOST_CONTROLLER_CONFIGURATION
#ifdef SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_DUAL_HOST_CONTROLLER_XDK
#else  //!SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_SINGLE_HOST_CONTROLLER
#endif ////!SILVER
#endif  USB_HOST_CONTROLLER_CONFIGURATION


#

//--------------------------------------------------------------------------------
//  Resource structure shared between USBD and OHCD
//--------------------------------------------------------------------------------
#define HCD_INTERRUPT_TD_QUOTA 3
typedef struct _HCD_RESOURCE_REQUIREMENTS
{
    ULONG EndpointCount;
    ULONG IsochEndpointCount;
    ULONG TDCount;
    UCHAR ControlTDQuota;
    UCHAR BulkTDQuota;
    UCHAR IsochMaxBuffers;
} HCD_RESOURCE_REQUIREMENTS, *PHCD_RESOURCE_REQUIREMENTS;


//--------------------------------------------------------------------------------
//  Interface between the host controller driver and usbd
//--------------------------------------------------------------------------------

//
// HCD specific URBs
//
#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002

//
// Common transfer request definition, all transfer
// requests passed to the HCD will be mapped to this
// format.  The HCD will can use this structure to
// reference fields that are common to all transfers
// as well as fields specific to isochronous and
// control transfers.

//
// bandwidth related definitions
//

// overhead in bytes/ms

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13

  
//-------------------------------------------------------------
// Utility procedures supported by USB System Driver
//-------------------------------------------------------------
VOID
USBD_CompleteRequest(
    IN  PURB Urb
    );

USHORT
USBD_CalculateUsbBandwidth(
    IN USHORT   MaxPacketSize,
    IN UCHAR    EndpointType,
    IN BOOLEAN  LowSpeed
    );

VOID
USBD_DeviceConnected(
    IN  PVOID    HcdExtension,
    IN  UCHAR    PortNumber
    );

VOID
USBD_DeviceDisconnected(
    IN  PVOID HcdExtension,
    IN  UCHAR PortNumber
    );

VOID
USBD_NewHostController(
    IN PPCI_DEVICE_DESCRIPTOR PciDevice,
	IN ULONG HcdDeviceExtensionSize
    );

//-------------------------------------------------------------
// Procedures which must be exported by Host Controller Driver
//-------------------------------------------------------------
VOID
HCD_DriverEntry(
    PHCD_RESOURCE_REQUIREMENTS ResourceRequirements
    );

VOID
HCD_EnumHardware();

NTSTATUS
HCD_NewHostController(
    IN PVOID  HcdExtension,
    IN UCHAR  HostControllerNumber,
    IN PPCI_DEVICE_DESCRIPTOR PciDevice
    );

USBD_STATUS
HCD_SubmitRequest(
    IN PVOID HcdExtension,
    IN PURB Urb
    );

USBD_STATUS
HCD_CancelRequest(
    IN PVOID HcdExtension,
    IN PURB  Urb
    );

typedef
VOID
(*PFNHCD_RESET_COMPLETE)(
    IN USBD_STATUS  Status,
    IN PVOID        Context
    );

VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    );

VOID
HCD_DisableRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber
    );


#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\hawk\hawkxmo.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.CPP

Abstract:


Environment:

    kernel mode

Revision History:


--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "hawkxmo.h"

#if DBG || DEBUG_LOG

    ULONG               HawkDebugLevel=3;     // Level of debug output

#endif


//------------------------------------------------------------------------------
//  Declare Hawk types and class.
//------------------------------------------------------------------------------
DECLARE_XPP_TYPE(XDEVICE_TYPE_CHAT_MICROPHONE)
DECLARE_XPP_TYPE(XDEVICE_TYPE_CHAT_HEADPHONE)
USB_DEVICE_TYPE_TABLE_BEGIN(Hawk)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_CHAT_MICROPHONE, USB_CONNECTOR_TYPE_HIGH_POWER,1,0,0,2,4,40,0),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_CHAT_HEADPHONE, USB_CONNECTOR_TYPE_HIGH_POWER,1,0,0,2,4,40,0)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(Hawk, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(Hawk, 1, XBOX_DEVICE_CLASS_AUDIO_DEVICE, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassHawk")
USB_CLASS_DECLARATION_POINTER(Hawk)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(Hawk, 1)
#pragma data_seg(".XPP$Data")

//------------------------------------------------------------------------------
// USB Class Driver Interface
//------------------------------------------------------------------------------

EXTERNUSB VOID
HawkInit ()
{
    DBGPRINT(2, ("enter: HawkInit\n"));
    
    XHawkMediaObject::InitializeClass();

    DBGPRINT(2, ("exit:  HawkInit\n"));    
    return;
}


EXTERNUSB VOID
HawkAddDevice(
     IN IUsbDevice *Device
     )
{
	const USB_ENDPOINT_DESCRIPTOR   *pEndpointDescriptor;
    XHawkMediaObject *pHawkMediaObject = NULL;
    DWORD dwPort;

    //
	//  Get the device port and slot
	//

    dwPort = Device->GetPort();
    if(dwPort >= 16)
    {
        DBGPRINT(2,("AddDevice: dwPort %d, bottom slot, not supported!\n",  dwPort));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    //  get an endpoint descriptor for the isoch endpoint
    //  (we don't know the direction (microphone or
    //  headphone).  Try input first.
    //

    pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                TRUE,
                                0);
    if(pEndpointDescriptor)
    {
        pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
        pHawkMediaObject->m_pTypeSettings = &pHawkMediaObject->sm_MicrophoneSettings;
    }
    else {
        pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                FALSE,
                                0);
        if(pEndpointDescriptor)
        {
            pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
            pHawkMediaObject->m_pTypeSettings = &pHawkMediaObject->sm_HeadphoneSettings;
        } else 
        {
            ASSERT(FALSE && "Isoch endpoint not found");
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }
    }
    
    //
    //  Check and initialize the state 
    //
    pHawkMediaObject->m_fConnected = TRUE;

    //
    // Use XHawkMediaObject as the device extension
    //
    
    Device->SetExtension(pHawkMediaObject);
    pHawkMediaObject->m_pDevice = Device;
    
    //
    //  Record the endpoint address, and wMaxPacket
    //

    pHawkMediaObject->m_bEndpointAddress = pEndpointDescriptor->bEndpointAddress;
    pHawkMediaObject->m_wMaxPacket = pEndpointDescriptor->wMaxPacketSize;

    DBGPRINT(2,("IsochMaxPacket = %x, bEndpointAddress = 0x%02x\n, Interface = %d\n", 
                     (ULONG)pEndpointDescriptor->wMaxPacketSize,
                     (ULONG)pEndpointDescriptor->bEndpointAddress,
                     Device->GetInterfaceNumber()
                     ));

    //
    // Set the class specific type so it can be enumerated
    //
    Device->SetClassSpecificType(
                (UCHAR)pHawkMediaObject->m_pTypeSettings->ulHawkClassSpecificType
                );

    Device->AddComplete(USBD_STATUS_SUCCESS);
}


EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    )
{
    XHawkMediaObject *pHawkMediaObject = (XHawkMediaObject *)Device->GetExtension();
 
    //
    //  Mark the device as not connected 
    //

    pHawkMediaObject->m_fConnected = FALSE;

    //
    //  If the device is opened, we cannot call
    //  remove complete, because there is
    //  an endpoint open (or in the process
    //  of being closed.
    //

    if(pHawkMediaObject->m_fOpened)
    {
        //
        //  Mark the media object remove pending,
        //  so that when the endpoint finishes
        //  closing, the CloseEndpointComplete
        //  routine will call RemoveComplete.
        //

        pHawkMediaObject->m_fRemovePending = TRUE;

        //
        //  If the endpoint is not in the process
        //  of being closed, then start that process
        //

        if(!pHawkMediaObject->m_fClosePending)
        {
            pHawkMediaObject->CloseEndpoint();
        }

    } else

    //
    //  The media object wasn't opened, so we can
    //  call remove complete
    //

    {
        pHawkMediaObject->m_pDevice = NULL;
        Device->SetExtension(NULL);
        Device->RemoveComplete();
    }
}    

//------------------------------------------------------------------------------
//  We do not include the CRT, but we need new.
//  we declare it static, so we don't conflict on linking
//  with other modules overriding new.
//------------------------------------------------------------------------------
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize)
    {
        return ExAllocatePoolWithTag(
                            memSize,
                            'kwah'
                            );
    }
static __inline void __cdecl operator delete(void *pMemory)
    {
        ExFreePool(pMemory);
    }
#pragma warning(default:4211)

//------------------------------------------------------------------------------
//  Declaration of static tables
//------------------------------------------------------------------------------
XHawkMediaObject *XHawkMediaObject::sm_pMicrophones = NULL;
XHawkMediaObject *XHawkMediaObject::sm_pHeadphones = NULL;


WAVEFORMATEX 
XHawkMediaObject::sm_MicrophoneWaveformat = 
    {
        WAVE_FORMAT_PCM, //wFormatTag
        1,               //nChannels
        HAWK_MICROPHONE_SAMPLE_RATE*1000,   //nSamplesPerSec 
        HAWK_MICROPHONE_SAMPLE_RATE*1000*
        HAWK_MICROPHONE_BYTES_PER_SAMPLE,   //nAvgBytesPerSec
        HAWK_MICROPHONE_BYTES_PER_SAMPLE,   //nBlockAlign
        HAWK_MICROPHONE_BYTES_PER_SAMPLE*8, //wBitsPerSample
        0                                  //cbSize
    };

WAVEFORMATEX 
XHawkMediaObject::sm_HeadphoneWaveformat = 
    {
        WAVE_FORMAT_PCM, //wFormatTag
        1,               //nChannels
        HAWK_HEADPHONE_SAMPLE_RATE*1000,   //nSamplesPerSec 
        HAWK_HEADPHONE_SAMPLE_RATE*1000*
        HAWK_HEADPHONE_BYTES_PER_SAMPLE,   //nAvgBytesPerSec
        HAWK_HEADPHONE_BYTES_PER_SAMPLE,   //nBlockAlign
        HAWK_HEADPHONE_BYTES_PER_SAMPLE*8, //wBitsPerSample
        0                //cbSize
    };  

HAWK_TYPE_SETTINGS 
XHawkMediaObject::sm_MicrophoneSettings = 
    {
        HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE,        //ulHawkClassSpecificType
        &XHawkMediaObject::sm_MicrophoneWaveformat, //pWaveFormat
        XMO_STREAMF_WHOLE_SAMPLES	|
	    XMO_STREAMF_FIXED_SAMPLE_SIZE |
        XMO_STREAMF_OUTPUT_ASYNC,                   //dwFlags
        HAWK_BYTES_PER_USB_FRAME,                   //cbSize
        0,                                          //cbMaxLookahead
        1                                           //cbAlignment
    };

HAWK_TYPE_SETTINGS 
XHawkMediaObject::sm_HeadphoneSettings = 
    {
        HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE,        //ulHawkClassSpecificType
        &XHawkMediaObject::sm_HeadphoneWaveformat, //pWaveFormat
        XMO_STREAMF_WHOLE_SAMPLES |
	    XMO_STREAMF_FIXED_SAMPLE_SIZE |
        XMO_STREAMF_INPUT_ASYNC,                    //dwFlags
        HAWK_BYTES_PER_USB_FRAME,                   //cbSize
        0,                                          //cbMaxLookahead
        1                                           //cbAlignment
    };

//------------------------------------------------------------------------------
// XHawkMediaObject
//------------------------------------------------------------------------------
void XHawkMediaObject::InitializeClass()
{
    //
    //  Allocate a microphone and a headphone
    //  instance for each of the ports up front.
    //
    ULONG ulPortCount = XGetPortCount();
    sm_pHeadphones = new XHawkMediaObject[ulPortCount];
    sm_pMicrophones = new XHawkMediaObject[ulPortCount];
    
    //
    //  We could loop over them and morph them into
    //  microphones and headphones, but we might
    //  as leave that until an AddDevice.
    //
}


STDMETHODIMP_(ULONG) XHawkMediaObject::AddRef (void)
{
	return (ULONG) InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(ULONG) XHawkMediaObject::Release (void)
{
	LONG lRefCount;
	lRefCount = InterlockedDecrement(&m_lRefCount);
	//
	//	Check for decrement below zero
	//
	if(0>lRefCount)
	{
		DBGPRINT(1, ("XHawkMediaObject: Reference Count Error: Count went below 0!\n"));
		return 0;
	} else if (0==lRefCount)
	{
        FreeStreamingResources();
	}
	return (ULONG)lRefCount;
}

STDMETHODIMP
XHawkMediaObject::GetInfo (
    IN OUT PXMEDIAINFO pInfo
    )
{
    #pragma TODO("RIP args for XHawkMediaObject::GetInputInfo")
    
    pInfo->dwFlags = m_pTypeSettings->dwFlags;
    
    if (HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == m_pTypeSettings->ulHawkClassSpecificType) {

        pInfo->dwInputSize = 0;
        pInfo->dwOutputSize = m_pTypeSettings->cbSize;

    } else {

        pInfo->dwInputSize = m_pTypeSettings->cbSize;
        pInfo->dwOutputSize = 0;
    }

    pInfo->dwMaxLookahead = m_pTypeSettings->cbMaxLookahead;
    
    return ERROR_SUCCESS;
}
        

STDMETHODIMP 
XHawkMediaObject::Flush (void)
{
    #pragma TODO("Implement Flush")
    return E_NOTIMPL;
}
        

STDMETHODIMP 
XHawkMediaObject::Discontinuity (void)
{
    return S_OK;
}
        

STDMETHODIMP
XHawkMediaObject::GetStatus (
            OUT DWORD *pdwFlags
            )
{
    
    #pragma TODO("RIP args for XHawkMediaObject::GetStatus")

    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    
    if( m_fConnected && m_pStreamingResources->Free.GetHead())
    {
        if(HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == m_pTypeSettings->ulHawkClassSpecificType)
        {
            *pdwFlags = XMO_STATUSF_ACCEPT_OUTPUT_DATA;
    
        } else
        {
            *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA;            
        }

    } else
    {
        *pdwFlags = 0;
    }
    
    KeLowerIrql(oldIrql);
    
    return S_OK;
}
        
HRESULT
XHawkMediaObject::Process (
    IN const XMEDIAPACKET *pInputPacket,
    IN const XMEDIAPACKET *pOutputPacket
    )
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    HRESULT hr = S_OK;
    const XMEDIAPACKET *pMediaPacket;
    
    if(HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == m_pTypeSettings->ulHawkClassSpecificType)
    {
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL==pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL!=pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", pOutputPacket->dwMaxSize > 0);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", 0 == (pOutputPacket->dwMaxSize % m_pTypeSettings->cbSize));
        
        pMediaPacket = pOutputPacket;
         
    } else 
    {
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL!=pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL==pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", pInputPacket->dwMaxSize > 0);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", 0 == (pInputPacket->dwMaxSize % m_pTypeSettings->cbSize));

        pMediaPacket = pInputPacket;
    }

    if(m_fConnected)
    {

        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->Free.RemoveHead();    
        if(pPacketContext)
        {

            //
            //  Copy the media packet into the hawk packet context.
            //  The structure is identical except hawk has one few extra
            //  field, for queuing
            //

            RtlCopyMemory(&pPacketContext->mediaPacket, pMediaPacket, sizeof(XMEDIAPACKET));

            //
            //  Record that we haven't done anything yet, and that 
            //  the request is pending.
            //
            XMOAcceptPacket(&pPacketContext->mediaPacket);
            pPacketContext->dwCompletedSize=0;

            //
            //  Insert the packet onto the pending programming queue.
            //

            m_pStreamingResources->PendingProgram.InsertTail(pPacketContext);
            
            //
            //  Jog the programming routine.
            //

            ProgramTransfer();
            
        } else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        }

    } else 
    {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    if(FAILED(hr))
    {
        XMOCompletePacket(pMediaPacket, 0, m_pfnCallback, m_pvContext, XMEDIAPACKET_STATUS_FAILURE);
    }

    KeLowerIrql(oldIrql);
    return hr;

}


EXTERN_C HRESULT WINAPI
XHawkCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
      PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      )
{
    HRESULT hr;
    XHawkMediaObject *pHawkMediaObject = NULL;

    hr = XHawkCreateMediaObject(
          XppDeviceType,
          dwPort,
          dwMaxAttachedPackets,
          pwfxFormat,
          ppXmediaObject
          );

    if (SUCCEEDED(hr)) {

        //
        // save callback and context
        //

        pHawkMediaObject = (XHawkMediaObject *) *ppXmediaObject;
        pHawkMediaObject->m_pvContext = pvContext;
        pHawkMediaObject->m_pfnCallback = pfnCallback;

    }


    return hr;

}

EXTERN_C HRESULT WINAPI
XHawkCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      )
/*++
    Routine Description:
        This is the factory method for XHawkMediaObjects.
        It is an exported API for games.
--*/
{
    #pragma TODO("RIP args for XcreateHawkMediaObject")

    //
    //  We need the class Id to find the device.
    //
	
    KIRQL		     oldIrql;
    PNP_CLASS_ID     classId;
    HRESULT          hr = S_OK;
    XHawkMediaObject *pHawkMediaObject = NULL;
    USHORT           portBit = (SHORT)(1 << dwPort);
    
    
    //
    //  Use raised Irql to synchronize the allocation
    //  and opening of instances
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Claim an existing instance of XHawkMediaObject
    //
	
    if(XDEVICE_TYPE_CHAT_MICROPHONE == XppDeviceType)
	{
	    pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
    } else if(XDEVICE_TYPE_CHAT_HEADPHONE == XppDeviceType)
    {

        pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
    } else
    {
        RIP("XHawkCreateMediaObject: XppDeviceType is not a valid type for XHawkCreateMediaObject\n");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	};
	
    if( pHawkMediaObject->m_fOpened )
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);

    } else if (pHawkMediaObject->m_fConnected)
    {

        //
        //  Allocate the streaming resources.
        //
        hr = pHawkMediaObject->AllocateStreamingResources(dwMaxAttachedPackets);
        if(SUCCEEDED(hr))
        {
            pHawkMediaObject->m_fOpened = TRUE;
            pHawkMediaObject->m_lRefCount = 1;
        } else
        {
           pHawkMediaObject = NULL;
        }

    } else
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    //
    //  Restore Irql since the stuff needs
    //  to be synchronously is done.
    //

    KeLowerIrql(oldIrql);

    //
    //  Fill out the pWaveFormatEx output
    //
    if(pwfxFormat && pHawkMediaObject)
    {
        RtlCopyMemory(
            pwfxFormat,
            pHawkMediaObject->m_pTypeSettings->pWaveFormat,
            sizeof(*pwfxFormat)
            );
    }

    *ppXmediaObject = pHawkMediaObject;	
    return hr;
}


HRESULT XHawkMediaObject::AllocateStreamingResources(ULONG ulMaxAttachedPackets)
/*++
    Routine Description:
        This is a helper function called by Factory Method,
        XcreateHawkMediaObject, to allocate resources for
        providing streaming.
--*/
{
    ULONG i;
    
    //
    //  Allocate memory for streaming resources
    //
    ULONG AllocLength = sizeof(HAWK_STREAMING_RESOURCES) + 
                        (sizeof(HAWK_PACKET_CONTEXT)*ulMaxAttachedPackets);
    PUCHAR pResourceMemory = new UCHAR[AllocLength];
    if(!pResourceMemory) return E_OUTOFMEMORY;    

    //
    //  Zero the memory for good measure.
    //

    RtlZeroMemory(pResourceMemory, AllocLength);
    
    //
    //  Break that memory up into the pStreamingResouces and ulMaxAttachedPackets
    //  count of packet contexts.
    //
    
    PHAWK_STREAMING_RESOURCES pResources = (PHAWK_STREAMING_RESOURCES)pResourceMemory;
    PHAWK_PACKET_CONTEXT  pPacketContextArray = (PHAWK_PACKET_CONTEXT) (pResourceMemory +
                                                sizeof(HAWK_STREAMING_RESOURCES));

    //
    // Populate the free list of packet contexts
    //

    for(i=0; i < ulMaxAttachedPackets; i++)
    {
        pResources->Free.InsertTail(pPacketContextArray + i);
    }
         
    //
    //  Open the isoch endpoint
    //

    URB_ISOCH_OPEN_ENDPOINT OpenUrb;
    USB_BUILD_ISOCH_OPEN_ENDPOINT(
                &OpenUrb,
                m_bEndpointAddress,
                m_wMaxPacket,
                HAWK_ISOCH_MAX_ATTACH_BUFFERS,
                0);
    USBD_STATUS status = m_pDevice->SubmitRequest((PURB)&OpenUrb);
    
    if(USBD_ERROR(status))
    {
        delete pResources;
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(status));
    }
    pResources->EndpointHandle = OpenUrb.EndpointHandle;

    //
    //  Initialize the portion of the IsochBufferDescriptor
    //  that is the same for all transfers.
    //

    for(i =0; i < 8; i++)
    {
        pResources->IsochBufferDescriptor.Pattern[i] = HAWK_BYTES_PER_USB_FRAME;
    }
    pResources->IsochBufferDescriptor.TransferComplete = (PFNUSBD_ISOCH_TRANSFER_COMPLETE)XHawkMediaObject::TransferComplete;
    pResources->IsochBufferDescriptor.Context = (PVOID) this;

    //
    //  start the stream (since we don't have a start API)
    //

    URB_ISOCH_START_TRANSFER StartTransferUrb;
    USB_BUILD_ISOCH_START_TRANSFER(
        &StartTransferUrb,
        pResources->EndpointHandle,
        0,
        URB_FLAG_ISOCH_START_ASAP
        );
    status = m_pDevice->SubmitRequest((PURB)&StartTransferUrb);
    ASSERT(USBD_SUCCESS(status));
        
    //
    //  The stream should be ready to go, we just need to
    //  attach transfers.
    //

    m_pStreamingResources = (PHAWK_STREAMING_RESOURCES) pResources;

    return S_OK;
}

void XHawkMediaObject::CloseEndpoint( void )
{
    ASSERT(m_pStreamingResources);
    //
    //  Build and submit the close URB for the Isoch endpoint
    //

    USB_BUILD_ISOCH_CLOSE_ENDPOINT(
            &m_pStreamingResources->CloseUrb,
            m_pStreamingResources->EndpointHandle,
            (PURB_COMPLETE_PROC)&XHawkMediaObject::CloseEndpointComplete,
            (PVOID)this
            );
    m_pStreamingResources->EndpointHandle = NULL;
    m_pDevice->SubmitRequest((PURB)&m_pStreamingResources->CloseUrb);
}

void XHawkMediaObject::CloseEndpointComplete (PURB pUrb, XHawkMediaObject *pThis)
/*++
    Routine Description:
        This is the call back when an isoch endpoint is closed.
        This could happen if a close is pending, or if 
        a remove is pending, or both.

--*/
{
    ASSERT(USBD_SUCCESS(pUrb->Header.Status));

    //
    //  Deal with the remove pending case.
    //

    if(pThis->m_fRemovePending)
    {
        pThis->m_pDevice->SetExtension(NULL);
        pThis->m_pDevice->RemoveComplete();
        pThis->m_pDevice = NULL;
        pThis->m_fRemovePending = FALSE;
    }

    //
    //  If this is the close pending case,
    //  then there is an event that we need to set
    //
    if(pThis->m_fClosePending)
    {
        //
        //  We have to clear the m_fClosePending
        //  and m_fOpened flags while still at
        //  DPC for synchronization purposes.
        //

        pThis->m_fClosePending = FALSE;
        pThis->m_fOpened = FALSE;

        //
        //  Signal the close event so that
        //  FreeStreamingResources can continue
        //  to clean up.
        //

        KeSetEvent(
            &pThis->m_pStreamingResources->CloseEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }
}

void XHawkMediaObject::FreeStreamingResources (void)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    if(m_fConnected)
    {

        //
        //  Mark that this object is pending close
        //  and initialize the close event.
        //

        m_fClosePending = TRUE;
        KeInitializeEvent(
            &m_pStreamingResources->CloseEvent,
            SynchronizationEvent,
            FALSE);

        //
        //  If it is already pending remove
        //  then we can just wait for
        //  the endpoint to close, other
        //  wise we must initiate closing
        //   it.
        //

        if(!m_fRemovePending)
        {
            CloseEndpoint();
        }

        //
        //  Lower Irql and let the endpoint close.
        //

        KeLowerIrql(oldIrql);
        
        //
        // The endpoint close is under way,
        // wait fpr it to complete.
        //

        KeWaitForSingleObject (
            &m_pStreamingResources->CloseEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    } else
    {
        m_fOpened = FALSE;
        KeLowerIrql(oldIrql);
    }

    //
    //  Now we can cleanup what is left of the streaming resources
    //
    AbortMediaPackets(&m_pStreamingResources->PendingComplete);
    AbortMediaPackets(&m_pStreamingResources->PendingProgram);
    delete m_pStreamingResources;
    m_pStreamingResources = NULL;
}


void XHawkMediaObject::ProgramTransfer()
/*++
    Routine Description:
        This routine translates a portion of a packet into USB Isochronous
        Transfer Requests.

    Note: Sometimes this routine in called at PASSIVE_LEVEL and sometimes
    at DISPATCH_LEVEL.  This routine is not inherently reentrant so we raise
    the IRQL to DISPATCH_LEVEL all the time.
--*/
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();   
 
    while(m_pStreamingResources->ulOutstandingTransfers < HAWK_ISOCH_MAX_ATTACH_BUFFERS)
    {
        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->PendingProgram.GetHead();
        
        //
        //  If there are no more packet contexts pending programming, break the
        //  loop, we are done.
        //

        if(!pPacketContext) break;
        
        //
        //  If there are no bytes remaining, then this item was just added to the
        //  pending program list, so reset a programing context for this packet
        //

        if(0 == m_pStreamingResources->ulBytesRemaining)
        {
            //
            //  ulBytesComplete may start as non-zero if there was data
            //  in the packet prior to the calling ProcessOutput.
            //

            m_pStreamingResources->ulBytesRemaining = pPacketContext->mediaPacket.dwMaxSize;
        }

        //
        //  Calculate the maximum number of frames we can transfer
        //
        
        ULONG ulFrameCount = m_pStreamingResources->ulBytesRemaining/HAWK_BYTES_PER_USB_FRAME;
        if(ulFrameCount > HAWK_USB_MAX_FRAMES) ulFrameCount = HAWK_USB_MAX_FRAMES;
        m_pStreamingResources->IsochBufferDescriptor.FrameCount = ulFrameCount;
        
        //
        //  Update the transfer packet information
        //
        
        m_pStreamingResources->IsochBufferDescriptor.TransferBuffer = pPacketContext->mediaPacket.pvBuffer;
                
        //
        //  Update the Current Buffer Pos and the bytes remaining.
        //

        ULONG ulTransferBytes = HAWK_BYTES_PER_USB_FRAME * ulFrameCount;
        pPacketContext->mediaPacket.pvBuffer = (PVOID)(((PUCHAR)pPacketContext->mediaPacket.pvBuffer) + ulTransferBytes);
        m_pStreamingResources->ulBytesRemaining -= ulTransferBytes;

        //
        //  If there are no bytes remaining, move this packet context
        //  onto the pending complete queue

        if(0 == m_pStreamingResources->ulBytesRemaining)
        {
            m_pStreamingResources->PendingProgram.RemoveHead();
            m_pStreamingResources->PendingComplete.InsertTail(pPacketContext);
        }

        //
        //  Build and submit a USB request
        //
        
        URB_ISOCH_ATTACH_BUFFER Urb;
        USB_BUILD_ISOCH_ATTACH_BUFFER(
            &Urb,
            m_pStreamingResources->EndpointHandle,
            USBD_DELAY_INTERRUPT_0_MS,
            &m_pStreamingResources->IsochBufferDescriptor
            );
        
        m_pStreamingResources->ulOutstandingTransfers++;

        USBD_STATUS usbdStatus = m_pDevice->SubmitRequest((PURB)&Urb);
        ASSERT(USBD_SUCCESS(usbdStatus));
        
    }

    KeLowerIrql(oldIrql);
}

void XHawkMediaObject::TransferComplete(PUSBD_ISOCH_TRANSFER_STATUS Status, XHawkMediaObject *pThis)
/*++
    Routine Description:
        This is the completion routine whenever an isoch transfer completes.
        It continues to program the current media packet, releases the media
        packet when it is complete, and moves on to the next packet.
--*/
{

    PHAWK_STREAMING_RESOURCES pStreamingResources = pThis->m_pStreamingResources;

    //
    //  Diagnostics to determine data overrun and data underrun
    //
    #ifdef HAWK_OVERRUN_UNDERRUN_SPEW
    static int TotalCalls=0;
    static int Overrun=0;
    static int Underrun=0;
    TotalCalls++;
    if(HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == pThis->m_pTypeSettings->ulHawkClassSpecificType)
    {
        for(ULONG i=0; i<Status->FrameCount;i++)
        {
            if(USBD_ISOCH_STATUS_DATA_OVERRUN==Status->PacketStatus[i].ConditionCode)
            {
                DbgPrint("Overrun:%dof%d\n", ++Overrun,TotalCalls);
            } else if(32!=Status->PacketStatus[i].BytesRead)
            {
                DbgPrint("Underrun:%dof%d\n", ++Underrun,TotalCalls);
            }
        }
    }
    #endif
                
    //
    //  Find the correct packet context.  It is the oldest context waiting
    //  for completion. Either the head of the PendingComplete Queue, or
    //  the head of PendingProgram queue.
    //
    PHAWK_PACKET_CONTEXT pPacketContext = pStreamingResources->PendingComplete.GetHead();
    if(NULL == pPacketContext)
    {
        pPacketContext = pStreamingResources->PendingProgram.GetHead();
        ASSERT(pPacketContext);
    }

    //
    //  increment the count of completed bytes.
    //
    pPacketContext->dwCompletedSize += Status->FrameCount*HAWK_BYTES_PER_USB_FRAME;

    //
    //  Check if this completion, completes the whole packet
    //

    ASSERT(pPacketContext->dwCompletedSize <= pPacketContext->mediaPacket.dwMaxSize);
    if(pPacketContext->dwCompletedSize == pPacketContext->mediaPacket.dwMaxSize)
    {
        //
        //  Remove the packet from the pending complete list
        //

        PHAWK_PACKET_CONTEXT pCompletedPacketContext = pStreamingResources->PendingComplete.RemoveHead();
        ASSERT(pCompletedPacketContext == pPacketContext);

        //
        //  Move the packet context to the free list
        //

        pStreamingResources->Free.InsertTail(pCompletedPacketContext);

        //
        //  Update the users status and signal the event if there is one.
        //
        XMOCompletePacket(&pCompletedPacketContext->mediaPacket,
                          pPacketContext->dwCompletedSize,
                          pThis->m_pfnCallback,
                          pThis->m_pvContext,
                          XMEDIAPACKET_STATUS_SUCCESS);
    }

    pStreamingResources->ulOutstandingTransfers--;

    //
    // Jog Program Transfer, as we just freed up a transfer
    //
    if(pThis->m_fConnected && pThis->m_fOpened && !pThis->m_fClosePending)
    {
        pThis->ProgramTransfer();
    }
}

void XHawkMediaObject::AbortMediaPackets(CHawkPacketQueue *pPacketQueue)
{
    PHAWK_PACKET_CONTEXT pPacketContext = pPacketQueue->RemoveHead();
    while(pPacketContext)
    {
        //
        //  Move the packet context to the free list
        //
        m_pStreamingResources->Free.InsertTail(pPacketContext);

        //
        //  Update the users status and signal the event if there is one.
        //

        XMOCompletePacket(&pPacketContext->mediaPacket,
                          0,
                          m_pfnCallback,
                          m_pvContext,
                          XMEDIAPACKET_STATUS_FLUSHED);

        //
        //  Get the next packet.
        //
        pPacketContext = pPacketQueue->RemoveHead();
    }
}


//-------------------------------------------------------------------------
// CHawkPacketQueue implementation
//-------------------------------------------------------------------------

void CHawkPacketQueue::InsertTail(PHAWK_PACKET_CONTEXT pPacketContext)
{
    pPacketContext->pNextPacket = NULL;
    if(m_pTail)
    {
        m_pTail->pNextPacket = pPacketContext;
    } else
    {
        m_pHead = pPacketContext;
    }
    m_pTail = pPacketContext;
}

PHAWK_PACKET_CONTEXT CHawkPacketQueue::RemoveHead()
{
    PHAWK_PACKET_CONTEXT pRetVal;
    if(m_pHead)
    {
         pRetVal = m_pHead;
         m_pHead = m_pHead->pNextPacket;
         if(!m_pHead) m_pTail = NULL;
    } else
    {
        pRetVal = NULL;
    }
    return pRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\hawk\hawkxmo.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.H

Abstract:

    Header file for hawk driver

Environment:

    kernel mode

Revision History:

    06-28-2000 : started : georgioc

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#define _XAPI_
#define _KERNEL32_
#define NODSOUND
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <usb.h>
#include <xapidrv.h>
#include <dsoundp.h>
#include <xdbg.h>

//
// BUGBUG   If we are using a standard USB reader for dev, set this define
//

#define STANDARD_USB_DEVICE 1

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#if DBG || DEBUG_LOG

    extern ULONG               HawkDebugLevel;     // Level of debug output

#endif

#if !DBG

#define DBGPRINT(level, _x_)

#else

#define DBGPRINT(level, _x_) do { \
    if (level <= HawkDebugLevel) { \
        KdPrint(("HAWK: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

//*****************************************************************************
// A few remainder macros shamelessly stolen from dsound.
//*****************************************************************************
#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)
                                
//
// #pragma Reminders
//

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)
#define BUGBUG(a)               MESSAGE("BUGBUG: " a)
#define HACKHACK(a)             MESSAGE("HACKHACK: " a)

//*****************************************************************************
// Helpful defintions
//*****************************************************************************
#define HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE 0
#define HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE 1

//*****************************************************************************
//  The sample rate and size of the device are hardcoded by specification.
//  The sources file can override this for building against test hardware
//  that doesn't meet spec.
//*****************************************************************************
#ifndef HAWK_CONSTANTS_PREDEFINED
#define HAWK_MICROPHONE_SAMPLE_RATE 16 //In kilohertz
#define HAWK_MICROPHONE_BYTES_PER_SAMPLE 2
#define HAWK_HEADPHONE_SAMPLE_RATE 16 //In kilohertz
#define HAWK_HEADPHONE_BYTES_PER_SAMPLE 2
#endif

#pragma TODO("Performance tune HAWK_ISOCH_MAX_ATTACH_BUFFERS")
#define HAWK_ISOCH_MAX_ATTACH_BUFFERS 3
#define HAWK_BYTES_PER_USB_FRAME (HAWK_HEADPHONE_SAMPLE_RATE*HAWK_HEADPHONE_BYTES_PER_SAMPLE)
#define HAWK_USB_MAX_FRAMES 8 //This is a fundemental USB isoch thing.

#if (HAWK_MICROPHONE_SAMPLE_RATE!=HAWK_HEADPHONE_SAMPLE_RATE)
#error Microphone Sample Rate Must Equal Headphone Sample Rate
#endif
#if (HAWK_MICROPHONE_BYTES_PER_SAMPLE!=HAWK_HEADPHONE_BYTES_PER_SAMPLE)
#error Microphone Bytes Per Sample Must Equal Headphone Bytes Per Sample
#endif

    
typedef struct _HAWK_TYPE_SETTINGS
{
    ULONG         ulHawkClassSpecificType;
    
    // Pointer to waveformat to report
    PWAVEFORMATEX pWaveFormat;

    // Fixed parameters returned by GetInputInfo,
    // or GetOutputInfo
    DWORD dwFlags;
    DWORD cbSize;
    DWORD cbMaxLookahead;
    DWORD cbAlignment;

} HAWK_TYPE_SETTINGS, *PHAWK_TYPE_SETTINGS;


typedef struct _HAWK_PACKET_CONTEXT *PHAWK_PACKET_CONTEXT;
typedef struct _HAWK_PACKET_CONTEXT
{
    XMEDIAPACKET         mediaPacket;
    DWORD                dwCompletedSize;
    PHAWK_PACKET_CONTEXT pNextPacket;
} HAWK_PACKET_CONTEXT;

class CHawkPacketQueue
{
    public:

     void InsertTail(PHAWK_PACKET_CONTEXT pPacketContext);
     PHAWK_PACKET_CONTEXT RemoveHead();
     PHAWK_PACKET_CONTEXT GetHead () {return m_pHead;}
        
    private:

     PHAWK_PACKET_CONTEXT m_pHead;
     PHAWK_PACKET_CONTEXT m_pTail;
};


#define HAWK_BCF_SHORT_PACKET  1
#define HAWK_BCF_DISCONTINUITY 2

typedef struct _HAWK_STREAMING_RESOURCES
{
    PVOID EndpointHandle;

    //
    //  Packet Queues
    //

    CHawkPacketQueue PendingProgram;
    CHawkPacketQueue PendingComplete;
    CHawkPacketQueue Free;

    //
    //  Programming State
    //

    ULONG ulBytesRemaining; 
    ULONG ulOutstandingTransfers;

    //
    //  The IsochBufferDescriptor could be allocated
    //  on the stack in ProgramTransfer, but many
    //  of the arguments are set at open time (a.k.a.
    //  XcreateHawkMediaObject) so we just keep
    //  the structure around.
    //
    //  CloseEvent is used to synchronize
    //  closing the endpoint handle when the
    //  object reference count goes to zero.
    //  Since ProgramTransfer won't initiate
    //  any transfers after a close is initiated
    //  the memory can be shared with IsochBufferDescriptor.
    //

    union 
    {
        USBD_ISOCH_BUFFER_DESCRIPTOR IsochBufferDescriptor;
        KEVENT CloseEvent;
    };
    
    //
    //  The close urb is needed when it is time to close  
    //  the stream.
    //
    
    URB_ISOCH_CLOSE_ENDPOINT     CloseUrb;
    
} HAWK_STREAMING_RESOURCES, *PHAWK_STREAMING_RESOURCES;


EXTERNUSB VOID
HawkInit ();

EXTERNUSB VOID
HawkAddDevice (
    IN IUsbDevice *Device
    );

EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    );


//*****************************************************************************
// XHawkMediaObject
//*****************************************************************************

class XHawkMediaObject : public XMediaObject
{

    public:
        //
        //  Declaration of IUnknown members
        //  (minus QI which was nuked)
        
        STDMETHOD_(ULONG, AddRef) (void);

        STDMETHOD_(ULONG, Release) (void);

        //
        //  Declaration of XMediaObject members
        //
        STDMETHOD(GetInfo) (
            IN OUT LPXMEDIAINFO pInfo
            );
                
        STDMETHOD(Flush) (void);
        
        STDMETHOD(Discontinuity) (void);
        
        STDMETHOD(GetStatus) (
            OUT DWORD *pdwFlags
            );
        
        STDMETHOD(Process) (
            IN const XMEDIAPACKET *pInputPacket,
            IN const XMEDIAPACKET *pOutputPacket
            );
        
        XHawkMediaObject() :
            m_pTypeSettings(NULL),
            m_pDevice(NULL),
		    m_wMaxPacket(0),
            m_bEndpointAddress(0),
            m_fConnected(FALSE),
		    m_fOpened(FALSE),
		    m_fClosePending(FALSE),
            m_fRemovePending(FALSE),
            m_Reserved(0),
            m_lRefCount(0),
            m_pStreamingResources(NULL),
            m_pfnCallback(NULL),
            m_pvContext(NULL)
            {}

        static void InitializeClass(); //Initialize static members
	
		//
        //	Keeps track of the static list
		//	of objects
		//
		static XHawkMediaObject *sm_pMicrophones;	//Array of microphone instances
		static XHawkMediaObject *sm_pHeadphones;	//Array of headphone instances

    private:
		//
		//	Static tables that apply to all instances
		//	(or for all instances of one type.)s
		//

		static WAVEFORMATEX sm_MicrophoneWaveformat;
		static WAVEFORMATEX sm_HeadphoneWaveformat;

		static HAWK_TYPE_SETTINGS sm_MicrophoneSettings;
		static HAWK_TYPE_SETTINGS sm_HeadphoneSettings;
		
		//
		//	Information Detected During enumeration.
		//

		PHAWK_TYPE_SETTINGS m_pTypeSettings;
        IUsbDevice          *m_pDevice;
		WORD			    m_wMaxPacket;
        UCHAR			    m_bEndpointAddress;
		
		//
		//	Running Per Instance State Information
		//
        //  Notes on state flag.  Connecting
        //  and opening a device is synchronous.
        //  Closing a device is asynchronous, because
        //  the 
        
		UCHAR			   m_fConnected:1;
		UCHAR			   m_fOpened:1;
		UCHAR			   m_fClosePending:1;
        UCHAR			   m_fRemovePending:1;
		UCHAR			   m_Reserved:4;
        
        
        LONG			   m_lRefCount;

        //
        // callback values
        //

        PFNXMEDIAOBJECTCALLBACK    m_pfnCallback;
        PVOID                      m_pvContext;

	    //
		//	Streaming Resources (only needed for operation)
		//
		PHAWK_STREAMING_RESOURCES m_pStreamingResources;

        //
        //  Private help methods
        //
        HRESULT AllocateStreamingResources (ULONG ulMaxAttachedPackets);
        void FreeStreamingResources (void);
        void CloseEndpoint (void);
        static void CloseEndpointComplete (IN PURB, IN XHawkMediaObject *pThis);
        void ProgramTransfer(void);
        static void TransferComplete(IN PUSBD_ISOCH_TRANSFER_STATUS Status, IN XHawkMediaObject *pThis);
        void AbortMediaPackets(IN CHawkPacketQueue *pPacketQueue);

    //
    //  The XcreateHawkMediaObject factory method, and the
    //  USB interface methods, need to be friends.  They
    //  all would be members, but they must be C calleable.
    //
    friend HRESULT WINAPI
    XHawkCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      );
    

    friend HRESULT WINAPI
    XHawkCreateMediaObjectInternal(
          IN PXPP_DEVICE_TYPE XppDeviceType,
          IN DWORD dwPort,
          IN DWORD dwMaxAttachedPackets,
          OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
          PFNXMEDIAOBJECTCALLBACK    pfnCallback,
          PVOID                      pvContext,
          OUT XMediaObject **ppXmediaObject
          );

    friend VOID HawkInit ();

    friend VOID HawkAddDevice (
                    IN IUsbDevice *Device
                    );

    friend VOID HawkRemoveDevice (
                    IN IUsbDevice *Device
                    );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\kdexts\mu\mukdx.cpp ===
/*++

Copyright (c) 1998	Microsoft Corporation

Module Name: 

    1394kdx.c

Abstract


Author:


Revision History:
--*/

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <imagehlp.h>

#include <memory.h>
#pragma hdrstop

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#include <ntverp.h>
#include <imagehlp.h>

#include <mu.h>
#include "usb.h"
#include "urb.h"

//
//  Globals
//

EXT_API_VERSION        ApiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };

WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

PSTR    ApiDescriptions[] =
{
    "\nUSB MU driver debugging Extensions\n\n",
    "help           - displays help for this extension\n",
    "ext            - dump the contents of a device extension\n",
    "\n"
};

#define NUMBER_API_DESCRIPTIONS     3

//
//  LibMain32
//
BOOL
WINAPI
DLLMain(
    HINSTANCE   hInstance, 
    ULONG       ulReason, 
    LPVOID      pvReserved
    )
{
    switch(ulReason) {

        case DLL_PROCESS_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        default:
            break;
    }

    return(TRUE);
} // DLLMain

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )
{
    ExtensionApis = *pExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
} // WinDbgExtensionDllInit

void
CheckVersion(void)
{

} // CheckVersion

LPEXT_API_VERSION
ExtensionApiVersion(void)
{
    return(&ApiVersion);
} // ExtensionApiVersion

DECLARE_API(help)
{
    ULONG   i;

    for (i=0; i < NUMBER_API_DESCRIPTIONS; i++)
        dprintf(ApiDescriptions[i]);

    return;
} // version

DECLARE_API(ext)
{
    DEVICE_EXTENSION    ext;
    ULONG   Address, BytesRead;

    if (0 == args[0]) {

        dprintf("ext <PDEVICE_EXTENSION>\n");
        return;
    }

    sscanf(args, "%lx", &Address);

    dprintf("\nohci DeviceExtension = 0x%x\n\n", Address);

    if (!ReadMemory(Address, &ext, sizeof(DEVICE_EXTENSION), &BytesRead)) {

        dprintf("Unable to read extension\n");
        return;
    }

    if (BytesRead < sizeof(DEVICE_EXTENSION)) {

        dprintf("Only read %d bytes of extension, expected %d\n", BytesRead, sizeof(DEVICE_EXTENSION));
        return;
    }

    dprintf("\text.FdoDeviceObject = 0x%x\n", ext.FdoDeviceObject);
    dprintf("\text.IUsbDevice = 0x%x\n", ext.Device);
    dprintf("\text.UsbDeviceData.InterfaceNumber = 0x%x\n", ext.UsbDeviceData.InterfaceNumber);
    dprintf("\text.UsbDeviceData.PlayerSlot = 0x%x\n", ext.UsbDeviceData.PlayerSlot);
    dprintf("\text.UsbDeviceData.ControllerSlot = 0x%x\n", ext.UsbDeviceData.ControllerSlot);
    dprintf("\text.UsbDeviceData.BulkInEndpointAddress = 0x%x\n", ext.UsbDeviceData.BulkInEndpointAddress);
    dprintf("\text.UsbDeviceData.BulkOutEndpointAddress = 0x%x\n", ext.UsbDeviceData.BulkOutEndpointAddress);

    dprintf("\text.PendingIoCount = 0x%x\n", ext.PendingIoCount);
    dprintf("\text.DeviceFlags = 0x%x\n", ext.DeviceFlags);
    dprintf("\text.OriginalMrb = 0x%x\n", ext.OriginalMrb);

    dprintf("\text.PendingIrp = 0x%x\n", &ext.PendingIrp);

    dprintf("\text.DiskExtension.Fdo = 0x%x\n", ext.DiskExtension.Fdo);
    dprintf("\text.DiskExtension.SectorShift = 0x%x\n", ext.DiskExtension.SectorShift);
    dprintf("\text.DiskExtension.PartitionLength.LowPart = 0x%x\n", ext.DiskExtension.PartitionLength.LowPart);
    dprintf("\text.DiskExtension.PartitionLength.HighPart = 0x%x\n", ext.DiskExtension.PartitionLength.HighPart);

    dprintf("\text.CbwCswMdl = 0x%x\n", ext.CbwCswMdl);

    dprintf("\n");
    return;
} // device extension
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\kdexts\usb\dumpstruct.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    usbkdx.cpp

Abstract:

    Debugger extensions to dump out (pretty print) different 
    classes and structs

Author:

    Josh Poley (jpoley)

Revision History:


USB Globals:

    ohcd\isr.c
        int                                 IsrEntryCount=0;

    xid\xid.cpp
        XID_GLOBALS                         XID_Globals;
        USB_PNP_CLASS_DRIVER_DESCRIPTION    GLOBAL_ClassDescription
        USB_PNP_DEVICE_TYPE_DESCRIPTION     GLOBAL_DeviceTypes[XINPUT_DEVTYPE_COUNT];

    usbd\usbd.cpp
        UCHAR                               GLOBAL_HostControllerCount;
        PDRIVER_OBJECT                      GLOBAL_DriverObject;
        XAPI_NOTIFICATION_SOURCE            GLOBAL_NotificationSource;

    usbd\tree.cpp
        CDeviceTree                         g_DeviceTree;

    usbd\notify.cpp
        USBD_NOTIFICATIONS                  g_Notifications={0};

    usbpnp\pnp.cpp
        PFNUSBHUB_ResetHubPort              g_ResetRoutine = NULL;
        PUSB_PNP_CLASS_DRIVER_DESCRIPTION   g_FirstClassDriver = NULL;
        BOOLEAN                             g_BaseDriverCalledYet = FALSE;

    usbhub\hub.cpp
        USBHUB_INFO						    GLOBAL_HubInfo;
        USBHUB_ENUM_BLOCK				    GLOBAL_HubEnum;
        USB_PNP_CLASS_DRIVER_DESCRIPTION    GLOBAL_ClassDescription;

--*/

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntos.h>
#include <stdio.h>
#include <string.h>
#include <ntverp.h>
#include <wdbgexts.h>


//
// include the necessary USB headers
//
#include <xinput.h>
//#include <xusbenum.h>
#include "usb.h"
#include "urb.h"
#include "xid.h"
#include "hub.h"
#include "usbd.h"


extern void PrintHexDump(const void* buffer, DWORD length);


/*****************************************************************************

Routine Description:

    xidglobals

    Dumps out the values of the global XID_GLOBALS struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(xidglobals)
    {
    XID_GLOBALS *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("xidglobals <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (XID_GLOBALS *)address;

    dprintf("\nXID_GLOBALS:\n");
    dprintf("    DeviceNodeCount:       %u\n", globals->DeviceNodeCount);
    dprintf("    DeviceNodeInUseCount:  %u\n", globals->DeviceNodeInUseCount);
    dprintf("    DeviceNodes:           0x%X\n", globals->DeviceNodes);
    dprintf("    OpenDeviceList:        0x%X\n", globals->OpenDeviceList);
    dprintf("    EnumNode:              %u\n", globals->EnumNode);
    dprintf("    EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->EnumUrb.Header.CompleteContext);

    //union
    //{
    //    XID_DESCRIPTOR          EnumXidDescriptor;
    //    USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    //};
    //UCHAR                       EnumMdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      EnumWatchdogTimer;
    //KDPC                        EnumWatchdogTimerDpc;

    return;
    } // xidglobals


/*****************************************************************************

Routine Description:

    hubinfo

    Dumps out the values of the global USBHUB_INFO struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubinfo)
    {
    USBHUB_INFO *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubinfo <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_INFO *)address;

    dprintf("\nUSBHUB_INFO:\n");
    dprintf("    NodeCount:             %u\n", globals->NodeCount);
    dprintf("    NodesInUse:            %u\n", globals->NodesInUse);
    dprintf("    EndpointMemory:        0x%X\n", globals->EndpointMemory);
    dprintf("    Nodes:\n");
    for(unsigned i=0; i<USBHUB_MAXIMUM_HUB_COUNT; i++)
        {
        dprintf("      %02d InUse:                  %u\n", i, globals->Nodes[i].InUse);
        dprintf("         OutstandingRequest:     %u\n", globals->Nodes[i].OutstandingRequest);
        dprintf("         RemovePending:          %u\n", globals->Nodes[i].RemovePending);
        dprintf("         PoweringPorts:          %u\n", globals->Nodes[i].PoweringPorts);
        dprintf("         UsbNodeIndex:           %u\n", globals->Nodes[i].UsbNodeIndex);
        dprintf("         PortCount:              %u\n", globals->Nodes[i].PortCount);
        dprintf("         PortProcessIndex:       %u\n", globals->Nodes[i].PortProcessIndex);
        dprintf("         PortStatusChangeBitmap: %u\n", globals->Nodes[i].PortStatusChangeBitmap);
        dprintf("         PortConnectedBitmap:    %u\n", globals->Nodes[i].PortConnectedBitmap);
        dprintf("         InterruptEndpointHandle:0x%X\n", globals->Nodes[i].InterruptEndpointHandle);
        //URB				Urb;
        //union
        //{
        //    UCHAR			RequestBuffer[4];
        //    struct {
        //	    USHORT		Status;
        //	    USHORT		StatusChange;
        //    }				PortStatus;
        //};
	    //UCHAR			MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        }

    return;
    } // hubinfo


/*****************************************************************************

Routine Description:

    hubenum

    Dumps out the values of the global USBHUB_ENUM_BLOCK struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubenum)
    {
    USBHUB_ENUM_BLOCK *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubenum <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_ENUM_BLOCK*)address;

    dprintf("\nUSBHUB_ENUM_BLOCK:\n");
    dprintf("    EnumBuffer:\n");
    PrintHexDump(globals->EnumBuffer, 32);
    dprintf("    ResetUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->ResetUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->ResetUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->ResetUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->ResetUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->ResetUrb.Header.CompleteContext);
    dprintf("    ResetContext:          %u\n", globals->ResetContext);

    //UCHAR						MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      WatchdogTimer;
    //KDPC                        WatchdogTimerDpc;

    return;
    } // hubenum

/*****************************************************************************

Routine Description:

    hubclass

    Dumps out the values of the global USB_PNP_CLASS_DRIVER_DESCRIPTION struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubclass)
    {
    USB_PNP_CLASS_DRIVER_DESCRIPTION *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubclass <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USB_PNP_CLASS_DRIVER_DESCRIPTION *)address;

    dprintf("\nUSB_PNP_CLASS_DRIVER_DESCRIPTION:\n");
    dprintf("    ClassId:\n");
    dprintf("        AsLong:            %u\n", globals->ClassId.AsLong);
    dprintf("        bClassSpecificType:%u\n", globals->ClassId.USB.bClassSpecificType);
    dprintf("        bClass:            %u\n", globals->ClassId.USB.bClass);
    dprintf("        bSubClass:         %u\n", globals->ClassId.USB.bSubClass);
    dprintf("        bProtocol:         %u\n", globals->ClassId.USB.bProtocol);
    dprintf("    Context:               0x%X\n", globals->Context);
    dprintf("    Reserved:              0x%X\n", globals->Reserved);
    dprintf("    DeviceTypeCount:       %u\n", globals->DeviceTypeCount);

/*
    PFNADD_USB_DEVICE                AddDevice;
    PFNREMOVE_USB_DEVICE             RemoveDevice;
    PUSB_PNP_DEVICE_TYPE_DESCRIPTION DeviceTypes;
*/
    return;
    } // hubclass


/*****************************************************************************

Routine Description:

    tree

    Dumps out the values of the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(tree)
    {
    CDeviceTree *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("tree <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree:\n");
    dprintf("    m_InProgress:          %u\n", globals->m_InProgress);
    dprintf("    m_DeviceRemoved:       %u\n", globals->m_DeviceRemoved);
    dprintf("    m_EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->m_EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->m_EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->m_EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->m_EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->m_EnumUrb.Header.CompleteContext);
    dprintf("    m_TimerReason:         %u\n", globals->m_TimerReason);
    dprintf("    m_FirstFree:           %u\n", globals->m_FirstFree);
    dprintf("    m_Topology:            %02X %02X %02X %02X\n", globals->m_Topology[0], globals->m_Topology[1], globals->m_Topology[2], globals->m_Topology[3]);
    dprintf("    m_DeviceDescriptor:\n");
    dprintf("        bLength:           %u\n", globals->m_DeviceDescriptor.bLength);
    dprintf("        bDescriptorType:   %u\n", globals->m_DeviceDescriptor.bDescriptorType);
    dprintf("        bcdUSB:            %u\n", globals->m_DeviceDescriptor.bcdUSB);
    dprintf("        bDeviceClass:      %u\n", globals->m_DeviceDescriptor.bDeviceClass);
    dprintf("        bDeviceSubClass:   %u\n", globals->m_DeviceDescriptor.bDeviceSubClass);
    dprintf("        bDeviceProtocol:   %u\n", globals->m_DeviceDescriptor.bDeviceProtocol);
    dprintf("        bMaxPacketSize0:   %u\n", globals->m_DeviceDescriptor.bMaxPacketSize0);
    if(globals->m_InterfaceDescriptor)
        {
        dprintf("    m_InterfaceDescriptor:\n");
        dprintf("        bLength:           %u\n", globals->m_InterfaceDescriptor->bLength);
        dprintf("        bDescriptorType:   %u\n", globals->m_InterfaceDescriptor->bDescriptorType);
        dprintf("        bInterfaceNumber:  %u\n", globals->m_InterfaceDescriptor->bInterfaceNumber);
        dprintf("        bAlternateSetting: %u\n", globals->m_InterfaceDescriptor->bAlternateSetting);
        dprintf("        bNumEndpoints:     %u\n", globals->m_InterfaceDescriptor->bNumEndpoints);
        dprintf("        bInterfaceClass:   %u\n", globals->m_InterfaceDescriptor->bInterfaceClass);
        dprintf("        bInterfaceSubClass:%u\n", globals->m_InterfaceDescriptor->bInterfaceSubClass);
        dprintf("        bInterfaceProtocol:%u\n", globals->m_InterfaceDescriptor->bInterfaceProtocol);
        dprintf("        iInterface:        %u\n", globals->m_InterfaceDescriptor->iInterface);
        }

/*
    UCHAR                       m_MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    KDPC                        m_EnumDpc;
    KTIMER                      m_EnumTimer;
    CUsbDevice                  *m_FirstPendingEnum;
    CUsbDevice                  *m_CurrentEnum;
    UCHAR                       m_ConfigurationDescriptorBuffer[USBD_MAX_CONFIG_DESC_SIZE];
    CUsbDevice                  m_Devices[UDN_MAX_NODES];
*/

    return;
    } // tree


/*****************************************************************************

Routine Description:

    device

    Dumps out the values of a CUsbDevice from the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(device)
    {
    CDeviceTree *globals;
    ULONG address;
    unsigned index;

    if(0 == args[0])
        {
        dprintf("device <address> <index>\n");
        return;
        }

    sscanf(args, "%lx %u", &address, &index);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree.CUsbDevice[%u]:\n", index);
    dprintf("    m_Type:                %u\n", globals->m_Devices[index].m_Type);
    dprintf("    m_NextFree:            %u\n", globals->m_Devices[index].m_NextFree);
    dprintf("    m_bInterfaceNumber:    %u\n", globals->m_Devices[index].m_bInterfaceNumber);
    dprintf("    m_Sibling:             %u\n", globals->m_Devices[index].m_Sibling);
    dprintf("    m_PortNumber:          %u\n", globals->m_Devices[index].m_PortNumber);
    dprintf("    m_Address:             %u\n", globals->m_Devices[index].m_Address);
    dprintf("    m_MaxPacket0:          %u\n", globals->m_Devices[index].m_MaxPacket0);
    dprintf("    m_ClassSpecificType:   %u\n", globals->m_Devices[index].m_ClassSpecificType);
    dprintf("    m_DefaultEndpoint:     0x%X\n", globals->m_Devices[index].m_DefaultEndpoint);
    if(globals->m_Devices[index].m_HostController)
        {
        dprintf("    m_HostController:\n");
        dprintf("        ControllerNumber:  %u\n", globals->m_Devices[index].m_HostController->ControllerNumber);
        dprintf("        RootHub:           0x%X\n", globals->m_Devices[index].m_HostController->RootHub);
        dprintf("        AddressList:       %X %X %X %X\n", globals->m_Devices[index].m_HostController->AddressList[0], globals->m_Devices[index].m_HostController->AddressList[1], globals->m_Devices[index].m_HostController->AddressList[2], globals->m_Devices[index].m_HostController->AddressList[3]);
        dprintf("        HcdExtension:      0x%X\n", &globals->m_Devices[index].m_HostController->HcdExtension);
        }
    dprintf("    m_ClassDriverExtension:0x%X\n", globals->m_Devices[index].m_ClassDriverExtension);
    dprintf("    m_ExternalPort:         %u\n", globals->m_Devices[index].m_ExternalPort);

    return;
    } // device
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mu\mrb.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    mrb.cpp

Abstract:

    This source file contains the state machine for 
    MU requests blocks to the device.  The bulk-only protocol
    specifices three stages for every transfer.

    The only entry point to the MRB state machine is

    MU_fStartMrb

Environment:

    kernel mode

Revision History:

    06-12-2000 : started rewrite : georgioc
    10-20-2000 : major cleanup (separated out the MRB state machine,
                 from the partial write state machine, which is now
                 in disk.cpp : mitchd
    03-07-2001 : generalized the way write commands are handled to aid
                 the partial write state machine (in disk.cpp) support
                 more flexible block sizes : mitchd

--*/


/*++
    Description of MRB state machine changes started on 03/07/01.
    
    Even after the cleanup on 10-20-2000, there was still a special case in
    the state machine to transfer the data stage of an MRB from two buffers:
    the user's buffer, and the MU WriteBuffer used to maintain media block
    integrity.  This code peered into disk.cpp's flags to figure out when this
    was necessary, somewhat of a hack.  The problem with this code is that it
    only supports a media block size that is double the emulated sector size.  
    We now need to lift this restriction in order to support larger media.

    So this change formalizes the hack by adding supporting a new MRB flag,
    MRB_FLAGS_SPLIT_WRITE, and to new fields filled out by disk.cpp: UserStartOffset,
    and UserEndOffset.  When MRB_FLAGS_SPLIT_WRITE the transfer length, must be
    exactly one media block.  The write is performed as follows:

    1) Write UserStartOffset bytes from the beginning of the WriteBuffer.
    2) Write (UserEndOffset-UserStartOffset) bytes from the beginning of the
       user buffer.
    3) Write (MediaBlockSize-UserEndOffset) bytes from the WriteBuffer begining
       UserStartOffset bytes into the WriteBuffer.

    This process allows a write to be submitted from the WriteBuffer inserting an
    arbitrary number of bytes from the user buffer at any point.  In the process
    the MRB state machine becomes more independent of the disk.cpp layer.  The
    new code should be ever scalable to larger and larger media block sizes.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "mu.h"

//*****************************************************************************
// Local Functions
//*****************************************************************************
DEFINE_USB_DEBUG_FUNCTIONS("MU");
VOID
FASTCALL
MU_fCbwTransfer(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_CbwCompletion (
    IN PURB   Urb,
    IN PVOID  Context
    );

VOID
FASTCALL
MU_fDataTransfer (
    PURB Urb,
    PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_DataCompletion (
    IN PURB  Urb,
    IN PVOID Context
    );

VOID
FASTCALL
MU_fCswTransfer (
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_CswCompletion (
    IN PURB            Urb,
    IN PVOID           Context
    );

//
//  MU_MrbTimeout is local, but declared also in mu.h, because
//  mu.cpp sets up the DPC at init time.
//

VOID
MU_MrbTimeout (
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FASTCALL
MU_fMrbErrorHandler(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );


VOID
MU_ResetDeviceCompletionRoutine (
    IN PURB             Urb,
    IN PVOID            Context
    );

#if DBG
VOID
FASTCALL
MU_fValidateMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );
#define MU_DBG_VALIDATE_MRB(DeviceExtension) MU_fValidateMrb(DeviceExtension)
#else
#define MU_DBG_VALIDATE_MRB(DeviceExtension)
#endif

//*****************************************************************************
// Implementation
//*****************************************************************************

VOID
FASTCALL
MU_fStartMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++

    Routine Description:
        Entry point for the MRB state machine.
            
        Does some sanity checks in debug, makes
        sure the device is still connected,
        and calls MU_fCbwTransfer - the first
        phase of any request.

--*/
{
    KIRQL oldIrql;

    USB_DBG_ENTRY_PRINT(("MU_fStartMrb(0x%0.8x)", DeviceExtension));

    //
    //  In Debug perform some simple tests
    //  to make sure that the MRB is well formed.
    //

    MU_DBG_VALIDATE_MRB(DeviceExtension);

    

    //
    //  Raise Irql to synchronize with removal
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Make sure that the device is still there.
    //

    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_PENDING_REMOVE|DF_REMOVED))
    {
        //
        //  Call the callback with a failure.
        //
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", DeviceExtension));
        DeviceExtension->Mrb.CompletionRoutine(DeviceExtension, STATUS_DEVICE_NOT_CONNECTED);
    } else
    {
        //
        //  Send the CBW
        //

        ASSERT(!TEST_FLAG(DeviceExtension->DeviceFlags, DF_ANY_URB_PENDING|DF_RESET_STEPS));
        MU_fCbwTransfer(DeviceExtension);
    }
    KeLowerIrql(oldIrql);
    return;
}

VOID
FASTCALL
MU_fCbwTransfer(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
         Builds an URB for the CBW phase and send it.
--*/
{

    PMU_REQUEST_BLOCK       mrb;
    PCBW                    cbw;
    LARGE_INTEGER           deltaTime;

    USB_DBG_ENTRY_PRINT(("MU_CbwTransfer(DeviceExtension=0x%0.8x)", DeviceExtension));

    //
    // Get the mrb
    //

    mrb = &DeviceExtension->Mrb;

    //
    // Initialize the Command Block Wrapper
    //

    cbw = &DeviceExtension->Mrb.Cbw;
    cbw->dCBWSignature = CBW_SIGNATURE;
    cbw->dCBWTag = PtrToUlong(DeviceExtension->PendingIrp);
    cbw->dCBWDataTransferLength = mrb->TransferLength;
    cbw->bCBWFlags = (UCHAR)((mrb->Flags & MRB_FLAGS_DATA_IN) ? CBW_FLAGS_DATA_IN : CBW_FLAGS_DATA_OUT);
    cbw->bCBWLUN = 0; // Xbox supports only signle LUN
    cbw->bCDBLength = 10;  //Xbox supports on 10 byte cdb's

    //
    //  The caller filled out the CDB in the CBW
    //

    //
    // start the request timer
    //
    SET_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    deltaTime.QuadPart = MRB_STANDARD_TIMEOUT * MRB_TIMEOUT_UNIT;
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);
    
    
    //
    //  Build and submit an URB for the CBW
    //
    SET_FLAG(DeviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING);
    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
        &DeviceExtension->Urb.BulkOrInterruptTransfer,
        DeviceExtension->BulkOutEndpointHandle,
        cbw,
        sizeof(CBW),
        USB_TRANSFER_DIRECTION_OUT,
        MU_CbwCompletion,
        DeviceExtension,
        FALSE //short transfer is an error
        );

    //
    //  Don't worry about errors the completion
    //  routine will handle them.
    //
    ASSERT(DeviceExtension->MuInstance);
    DeviceExtension->MuInstance->Device->SubmitRequest(&DeviceExtension->Urb);

    USB_DBG_EXIT_PRINT(("MU_CbwTransfer returning"));

    return;
}

VOID
MU_CbwCompletion (
    IN PURB            Urb,
    IN PVOID           Context
    )
/*
    Routine Description:
        Completion routine for MU_fStartMrb.
        
        If any type of error occured (including a timeout) call MU_HandleBulkError()
        to handle it, and exit.

        On success, if a data phase is required start it, otherwise call MU_fCswTransfer.
*/
{
    PMU_DEVICE_EXTENSION    deviceExtension;
    PMU_REQUEST_BLOCK       mrb;

    USB_DBG_ENTRY_PRINT(("MU_CbwCompletion(Urb=0x%0.8x,Context=0x%0.8x)", Urb, Context));

    deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    ASSERT(Urb == &deviceExtension->Urb);

    //
    //  If the URB failed (which includes being cancelled by the timer DPC) 
    //  call the error handling code.
    //

    if(USBD_ERROR(Urb->Header.Status) || 
       TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE)
    )
    {
        USB_DBG_WARN_PRINT(("CBW transfer failed, usbdStatus=0x%0.8x", Urb->Header.Status));
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING);
        MU_fMrbErrorHandler(deviceExtension, IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status));
        return;
    }
    
    mrb = &deviceExtension->Mrb;
    
    // The CBW Bulk Transfer was successful.  Start the next phase, either
    // the Data Bulk Transfer or CSW Bulk Transfer, and do not complete the
    // request yet.
    //

    if(mrb->DataBuffer)
    {

        ASSERT(mrb->TransferLength != 0);
        mrb->BytesSubmitted = 0;
        
        //
        // Start the first URB
        //
        
        ASSERT(TEST_FLAG(deviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING));
        MU_fDataTransfer(&deviceExtension->Urb, deviceExtension);
        
        //
        //  If there is more data, start up with the second URB
        //
        
        if(mrb->BytesSubmitted < mrb->TransferLength)
        {
            SET_FLAG(deviceExtension->DeviceFlags, DF_SECONDARY_URB_PENDING);
            MU_fDataTransfer((PURB)&deviceExtension->BulkUrbSecondary, deviceExtension);
        }

    } else
    {
        ASSERT(0 == mrb->TransferLength);
        MU_fCswTransfer(deviceExtension);
    }

    USB_DBG_EXIT_PRINT(("MU_CbwCompletion returning"));
    return;
}

VOID
FASTCALL
MU_fDataTransfer (
    PURB Urb,
    PMU_DEVICE_EXTENSION DeviceExtension
    )
/*
    Routine Description:
        Submit URB for the data stage of the MRB
        stage machine.  It uses the URB passed to it.

        Since USB guarantees that multiple requests
        on the same endpoint will complete in sequence
        we can just keep alternating them until the
        whole transfer buffer is sent.
*/
{
    PMU_REQUEST_BLOCK  mrb;
    PVOID              endpointHandle;
    PVOID              transferBuffer;
    ULONG              transferLength;
    UCHAR              direction;
    
    USB_DBG_ENTRY_PRINT(("MU_DataTransfer(Urb=0x%0.8x,DeviceExtension=0x%0.8x)", Urb, DeviceExtension));

    
    mrb = &DeviceExtension->Mrb;
    
    //
    // Bulk IN or Bulk OUT?
    //

    if ((mrb->Flags & MRB_FLAGS_UNSPECIFIED_DIRECTION) == MRB_FLAGS_DATA_IN)
    {
        endpointHandle = DeviceExtension->BulkInEndpointHandle;
        direction = USB_TRANSFER_DIRECTION_IN;
    } else {
        ASSERT((mrb->Flags & MRB_FLAGS_UNSPECIFIED_DIRECTION) == MRB_FLAGS_DATA_OUT);
        endpointHandle = DeviceExtension->BulkOutEndpointHandle;
        direction = USB_TRANSFER_DIRECTION_OUT;
    }

    //**
    //**  Calculate the transfer buffer for this URB
    //**
    if(TEST_FLAG(mrb->Flags,MRB_FLAGS_SPLIT_WRITE))
    //
    //  MRB_FLAGS_SPLIT_WRITE has three stages, handle
    //  the correct one.
    {
        ASSERT(USB_TRANSFER_DIRECTION_OUT == direction);
        if (mrb->BytesSubmitted < mrb->UserStartOffset)
        //
        //  First stage - from beginning of WriteBuffer
        //
        {
            transferBuffer = MU_DriverExtension.WriteBuffer + mrb->BytesSubmitted;

        } else if(mrb->BytesSubmitted < mrb->UserEndOffset)
        //
        //  Second stage - from User's buffer
        //
        {
            transferBuffer = mrb->DataBuffer + (mrb->BytesSubmitted - mrb->UserStartOffset);

        } else
        //
        //  Third stage - from end of WriteBuffer
        //
        {
            transferBuffer = MU_DriverExtension.WriteBuffer + mrb->UserStartOffset + (mrb->BytesSubmitted - mrb->UserEndOffset);
        }
    } else
    //
    //  The MRB_FLAGS_SPLIT_WRITE is NOT set, so just do the simple thing
    //  from the user buffer.
    {
        transferBuffer = mrb->DataBuffer + mrb->BytesSubmitted;
    }
    
    //
    //  Calculate the transfer length
    //

    transferLength = mrb->TransferLength - mrb->BytesSubmitted;
    if(transferLength > MRB_TRANSFER_SIZE)
    {
        transferLength = MRB_TRANSFER_SIZE;
    }
    mrb->BytesSubmitted += transferLength;

    //
    //  Build and submit an URB for the Transfer
    //

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
        &Urb->BulkOrInterruptTransfer,
        endpointHandle,
        transferBuffer,
        transferLength,
        direction,
        MU_DataCompletion,
        DeviceExtension,
        FALSE //short transfer is an error
        );

    //
    //  Extend the timeout.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = MRB_DATA_TIMEOUT * MRB_TIMEOUT_UNIT;
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);

    //
    //  Don't worry about errors the completion
    //  routine will handle them.
    //
    ASSERT(DeviceExtension->MuInstance);
    DeviceExtension->MuInstance->Device->SubmitRequest(Urb);

    return;
}

VOID
MU_DataCompletion (
    IN PURB  Urb,
    IN PVOID Context
    )
/*++
    Routine Description:
        This is the completion routine for MU_fDataTransfer.
        
        On an error (from USB), it calls MU_HandleBulkErrors.
        Then it returns.

        If there is more data to submit it loops back to
        MU_fDataTransfer to keep the data moving.

        If there is no more data to submit, it checks to
        see if there is an other URB outstanding.  If there
        are no more URBs outstanding, then it moves on to the
        next stage by calling MU_fTransferCsw.
--*/
{
    PMU_DEVICE_EXTENSION    deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    PMU_REQUEST_BLOCK       mrb;

    mrb = &deviceExtension->Mrb;

    //
    //  Check to see if there is an error pending (from the other URB)
    //

    if(TEST_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING))
    {
        USBD_STATUS usbdStatus;

        
        //
        //  DF_ERROR_PENDING was set only so that we get here,
        //  clear it now.
        //

        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING);

        // Grab the status from the OTHER Urb
        if(Urb == &deviceExtension->Urb)
        {
            usbdStatus = deviceExtension->BulkUrbSecondary.Hdr.Status;
        } else
        {
            usbdStatus = deviceExtension->Urb.Header.Status;
        }
        //
        //  There is definately no URB pending now.
        //  (it is more efficient to clear both flags, than to
        //  figure out which one we need to clear).
        //
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING|DF_SECONDARY_URB_PENDING);
        MU_fMrbErrorHandler(deviceExtension, IUsbDevice::NtStatusFromUsbdStatus(usbdStatus));
        return;
    }

    //
    //  If this URB failed, cancel the other URB, if it is outstanding,
    //  otherwise, start handling the error here.
    //

    if(USBD_ERROR(Urb->Header.Status) ||
       TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE)
    )
    {
        USB_DBG_WARN_PRINT(("Data transfer failed (USB status)0x%0.8x", Urb->Header.Status));
        
        //
        //  On error, we figure out which URB we are processing and
        //  clear its pending flag.  If the URB is pending we need
        //  to cancel it, and return.
        //
        if(Urb == &deviceExtension->Urb)
        {
            CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
            if(TEST_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING))
            {
               ASSERT(deviceExtension->MuInstance);
               SET_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING);
               deviceExtension->MuInstance->Device->CancelRequest((PURB)&deviceExtension->BulkUrbSecondary);
               return;
            }
        } else
        {
            ASSERT(Urb == (PURB)&deviceExtension->BulkUrbSecondary);
            CLEAR_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING);
            if(TEST_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING))
            {
                ASSERT(deviceExtension->MuInstance);
                SET_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING);
                deviceExtension->MuInstance->Device->CancelRequest(&deviceExtension->Urb);
                return;
            }
        }

        //
        //  If we are here there are no outstanding URBs for this device, so
        //  we can start the error handling.
        //

        MU_fMrbErrorHandler(deviceExtension, IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status));
        return;
    }

    //
    //  Ugh, that was a lot of error handling code,
    //  but we want to be robust!
    //
    
    //
    //  If there is more data to submit
    //  then call MU_fDataTransfer,
    //  and return.
    //
    if(mrb->BytesSubmitted < mrb->TransferLength)
    {
        MU_fDataTransfer(Urb, deviceExtension);
        return;
    }

    //
    //  We could just move on to the CSW stage now,
    //  even if the other URB is still pending for
    //  a read or write.  This is acceptable, because
    //  of 3.3 of the Bulk-Only specification.  However,
    //  we do not lose measurable efficiency by only
    //  continuing if there are no more data URB
    //  outstanding.  This method reduces the number
    //  of possible error cases we need to check,
    //  and there are already too many!
    //

    if(Urb == &deviceExtension->Urb)
    {
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
        if(TEST_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING))
        {
            // Nothing to do, because our twin URB is still pending
            return;
        }
    } else
    {
        ASSERT(Urb == (PURB)&deviceExtension->BulkUrbSecondary);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING);
        if(TEST_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING))
        {
            // Nothing to do, because our twin URB is still pending
            return;
        }
    }

    //
    //  Reset the primary URB flag as MU_fCswTransfer will use it.
    //

    SET_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    
    //
    //  The data transfer is over, go on to CSW stage
    //
    MU_fCswTransfer(deviceExtension);

    return;
}

VOID
FASTCALL
MU_fCswTransfer (
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
        Builds and submits an URB for the CswTransfer.  It is broken
        out as a separate routineas it is called from two places
        (MU_DataCompletion and MU_CbwCompletion).
--*/
{
    USB_DBG_ENTRY_PRINT(("MU_DataTransfer(DeviceExtension=0x%0.8x)",DeviceExtension));

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
        &DeviceExtension->Urb.BulkOrInterruptTransfer,
        DeviceExtension->BulkInEndpointHandle,
        &DeviceExtension->Mrb.Csw,
        sizeof(CSW),
        USB_TRANSFER_DIRECTION_IN,
        MU_CswCompletion,
        DeviceExtension,
        FALSE //short transfer is an error
        );

    //
    //  Extend the timeout for the CSW.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = ((LONGLONG)DeviceExtension->Mrb.TimeOutValue) * MRB_TIMEOUT_UNIT;
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);

    //
    //  Submit the URB, the completion routine will worry about errors.
    //
    ASSERT(DeviceExtension->MuInstance);
    DeviceExtension->MuInstance->Device->SubmitRequest(&DeviceExtension->Urb);
    
    USB_DBG_EXIT_PRINT(("MU_CswTransfer returning"));

    return;
}

VOID
MU_CswCompletion (
    IN PURB            Urb,
    IN PVOID           Context
    )
/*++
    Routine Description:
        Completion routine for the CSW transfer.

        Checks for a number of possible error conditions.
        If any are found it calls MU_HandleBulkError.

        Otherwise calls the MRBs completion routine
        with STATUS_SUCCESS.
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION)Context;
    NTSTATUS status = STATUS_SUCCESS;

    USB_DBG_ENTRY_PRINT(("MU_CswCompletion(Urb=0x%0.8x,Context=0x%0.8x)", Urb, Context));

    //
    //  Cancel the timer
    //
    
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
    {
        KeCancelTimer(&deviceExtension->Mrb.Timer);
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    }
    CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);

    if(USBD_ERROR(Urb->Header.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        USB_DBG_WARN_PRINT(("CSW transfer failed, usbdStatus=0x%0.8x", Urb->Header.Status));
        status = IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status);
    }
    
    //
    //  Check Signature.
    //

    if(deviceExtension->Mrb.Csw.dCSWSignature != CSW_SIGNATURE)
    {
        USB_DBG_WARN_PRINT(("CSW signature incorrect."));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Check Tag
    //
    
    if(deviceExtension->Mrb.Csw.dCSWTag != deviceExtension->Mrb.Cbw.dCBWTag)
    {
        USB_DBG_WARN_PRINT(("CSW tag incorrect, expecting 0x%0.8x, was 0x%0.8x.", 
                                                deviceExtension->Mrb.Cbw.dCBWTag,
                                                deviceExtension->Mrb.Csw.dCSWTag
                                                ));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Check For Phase Error (means missed handshake in the protocol)
    //

    if(deviceExtension->Mrb.Csw.bCSWStatus == CSW_STATUS_PHASE_ERROR)
    {
        USB_DBG_WARN_PRINT(("CSW returned CSW_STATUS_PHASE_ERROR\n"));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Check for failed CSW.  Basically the device had trouble
    //  completing the command.  It could be that we sent an unsupported
    //  command or that we tried to write past the end of the media
    //  or some other error on our part.  OR, THE MEDIA IS BAD.
    //  On a read or write, we ASSUME that this driver did not screw up
    //  and infact a media block has failed!!!  It sucks that we don't
    //  have more specific errors, but we didn't invent the protocol,
    //  we just borrowed it from the USB mass storage committee.
    //

    if(deviceExtension->Mrb.Csw.bCSWStatus == CSW_STATUS_FAILED)
    {
        USB_DBG_WARN_PRINT(("CSW returned CSW_STATUS_FAILED\n"));
        status = STATUS_DATA_ERROR;
    }

    ASSERT(!TEST_FLAG(deviceExtension->DeviceFlags, DF_ANY_URB_PENDING));
     
    //
    //  If any error occurred, call the handle bulk error routine.
    //

    if(NT_ERROR(status))
    {
        MU_fMrbErrorHandler(deviceExtension, status);
        return;
    }
    
    ASSERT(deviceExtension->Mrb.Csw.bCSWStatus == CSW_STATUS_GOOD);

    //
    // Call the MRB completion routine with a success code
    //        
    USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_SUCCESS)", deviceExtension));
    deviceExtension->Mrb.CompletionRoutine(deviceExtension, STATUS_SUCCESS);
    
    USB_DBG_EXIT_PRINT(("MU_CswCompletion returning"));

    return;
}


VOID
MU_MrbTimeout (
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
    Routine Description:
        
        This is the DPC routine for the MRB timeout timer.  The timer is set
        before the Cbw is transmitted, and canceled when the bulk-only request
        completes by receiving a Csw, or when error occurs aborting the request.

        The timer is intended to protect against devices that NAK forever.
        Device that are just extremely slow will hit this as well.  This code
        does not protect against software bugs in this driver or lower in the
        USB stack.

        All this routine does is cancel any URBs that are outstanding.  This will break
        the deadlock, and the normal error handling in the state machine will kick in.
        
    Timeout Timing:

        The timer is set at CBW, and extended at each data stage and at CSW.
        The length of the timeout for the data stages and CSW is fixed.  The caller
        in the disk layer can set the timeout for the CBW.  This is to accomodate commands
        like VERIFY that may require very long timeouts on the CBW and they don't have
        a data stage.

--*/
{
    PMU_DEVICE_EXTENSION  deviceExtension = (PMU_DEVICE_EXTENSION) Context;

    USB_DBG_WARN_PRINT(("MRB state machine timed out."));

    CLEAR_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);

    if(TEST_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING))
    {
        ASSERT(deviceExtension->MuInstance);
        deviceExtension->MuInstance->Device->CancelRequest(&deviceExtension->Urb);
    }

    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_SECONDARY_URB_PENDING))
    {
        ASSERT(deviceExtension->MuInstance);
        deviceExtension->MuInstance->Device->CancelRequest((PURB)&deviceExtension->BulkUrbSecondary);
    }
}

VOID
FASTCALL
MU_fMrbErrorHandler(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        This routine is called whenever a stage of the Mrb state machine detects
        an error (USB failure, device removed, CSW problem, or timeout).  There
        should be no outstanding Urbs when this routine is called.  
        
        If the MRB timer is running, cancel it.

        If the device has been removed, this routine cleans up the Mrb state machine
        and calls the Mrb competion routine with STATUS_DEVICE_NOT_CONNECTED.

        If the device is still present, it kicks of the USB bulk-only reset
        sequence.  This a fairly gentle way to get the bulk-only transport
        protocol back in-sync between the device and this driver.
        
        See the MU_ResetDeviceCompletionRoutine description for details on
        the reset sequence.  This routine performs the first two steps,
        then second of which is asynchronous and completes in
        MU_ResetDeviceCompletionRoutine.
--*/
{
    PMU_INSTANCE muInstance = DeviceExtension->MuInstance;

    //
    //  Stop the Mrb Timer, if it is running
    //

    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
    {
        KeCancelTimer(&DeviceExtension->Mrb.Timer);
        CLEAR_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    }

    //
    //  There should be no URB's pending when this routine is hit.
    //

    ASSERT(!TEST_FLAG(DeviceExtension->DeviceFlags, DF_ANY_URB_PENDING));
    
    //
    //  Check if the device has been removed
    //

    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE))
    {
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", DeviceExtension));
        DeviceExtension->Mrb.CompletionRoutine(DeviceExtension, STATUS_DEVICE_NOT_CONNECTED);
        return;
    }

    ASSERT(muInstance);

    //**
    //**  Start the reset sequence,
    //**
    
    USB_DBG_TRACE_PRINT(("Initiating Bulk-Only reset sequence."));
    
    SET_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP1);

    //
    //  stored the failed status, so that we still have it 
    //  after a reset.  Note this field is a union with 
    //  BytesSubmitted so it is not valid if we resubmit the MRB.
    //
    DeviceExtension->Mrb.FailedStatus = Status;

    //
    //  Clear the data toggle and software halt flag.  This is a
    //  synchronous USB request and should never fail.
    //

    USB_BUILD_SET_ENDPOINT_STATE(
            &DeviceExtension->Urb.GetSetEndpointState,
            DeviceExtension->BulkInEndpointHandle,
            USB_ENDPOINT_STATE_DATA_TOGGLE_RESET | USB_ENDPOINT_STATE_CLEAR_HALT
            );
    if(USBD_ERROR(muInstance->Device->SubmitRequest(&DeviceExtension->Urb)))
    {
        USB_DBG_WARN_PRINT(("MU_ResetDeviceDpc: Bulk-IN SetEndpointStatus failed!\n"));
        ASSERT(FALSE);
    }

    //
    //  Set the MRB timer to time the reset.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = MRB_RESET_TIMEOUT*MRB_TIMEOUT_UNIT;
    SET_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    SET_FLAG(DeviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);

    //
    // now send CLEAR_FEATURE(ENDPOINT_STALL) for the IN endpoint
    //

    USB_BUILD_CLEAR_FEATURE(
            &DeviceExtension->Urb.ControlTransfer,
            USB_COMMAND_TO_ENDPOINT,
            USB_FEATURE_ENDPOINT_STALL,
            muInstance->BulkInEndpointAddress,
            (PURB_COMPLETE_PROC)MU_ResetDeviceCompletionRoutine,
            DeviceExtension
            );

    //
    //  The completion routine deal with errors.
    //
    muInstance->Device->SubmitRequest(&DeviceExtension->Urb);
}

VOID
MU_ResetDeviceCompletionRoutine (
    IN PURB             Urb,
    IN PVOID            Context
    )
/*++
    Routine Description:
        
        This routine is the heart of the USB Bulk-Only Mass Storage Reset Sequence.
        The reset sequence consists of:
            1) Clear the STALL on the Bulk-IN endpoint.
            2) Clear the STALL on the Bulk-OUT endpoint.
            3) Send the the BULK_ONLY_MASS_STORAGE_RESET command on the control pipe.

        Clearing a STALL is a two step process on Xbox, first you send a 
        SET_ENDPOINT_STATE Urb to clear the endpoint HALT bit, and to reset the
        data toggle.  Then you send a CLEAR_FEATURE(ENDPOINT_STALL) over the 
        control endpoint to the device, so it clears its STALL bit.

        Step 1) was initiated by MU_fMrbErrorHandler.  So this routine verifies
        that that succeeded.

        Steps 2) and 3) are both asynchronous.  So this routine is a multistage
        state machine.  DeviceFlags are used to keep track of the stage.

        Any failure during the reset sequence, results in reporting the device as
        not responding to the core USB stack, if MU_Remove has not been called in
        the interm.  The core USB stack will drop the device (notifying everyone
        it is gone), and then reenumerate.  This procedure is not gentle!

        At the end of the reset sequence the retry count of the MRB is decremented
        and checked, if there are still retries remaining, then MU_fCbwTransfer is
        called to restart the Mrb.

        Otherwise, the MRB completion routine is called with STATUS_UNSUCCESSFUL.
        Unfortunately, the original error (timeout, or transmission failure)
        has not been propogated.
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    ULONG                resetStage = deviceExtension->DeviceFlags & DF_RESET_STEPS;
    PMU_INSTANCE         muInstance = deviceExtension->MuInstance;

    //
    //  Mark that the primary URB is not outstanding
    //
    CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);

    //
    //  Stop the MRB timer if it is running
    //
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
    {
        KeCancelTimer(&deviceExtension->Mrb.Timer);
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    }

    //
    //  Check for device not connected.
    //
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE))
    {
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", deviceExtension));
        deviceExtension->Mrb.CompletionRoutine(deviceExtension, STATUS_DEVICE_NOT_CONNECTED);
        return;
    }

    ASSERT(muInstance);

    //
    //  Check for USB errors
    //

    if(USBD_ERROR(Urb->Header.Status))
    {
        
        USB_DBG_WARN_PRINT(("Reset Sequence Failed, reporting device as not responding."));
        
        //
        //  Clear all the reset flags, reset is over, wherever it was
        //  
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEPS);

        //
        //  Report the device as not responding
        //
        muInstance->Device->DeviceNotResponding();
        
        //
        //  Fail the MRB as STATUS_DEVICE_NOT_CONNECTED
        //
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", deviceExtension));
        deviceExtension->Mrb.CompletionRoutine(deviceExtension, STATUS_DEVICE_NOT_CONNECTED);

        return;
    }

    //
    //  Move on to the next stage of the Reset sequence.
    //  (note that we are switching on the resetStage 
    //  of the just completed stage.)
    //

    switch(resetStage)
    {
        case DF_RESET_STEP1:
            
            //
            //  Switch the flag to indicate step2
            //

            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP1);
            SET_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP2);

            //
            //  Clear the data toggle and software halt flag for Bulk-OUT
            //  This is a synchronous USB request and should never fail.
            //

            USB_BUILD_SET_ENDPOINT_STATE(
                    &deviceExtension->Urb.GetSetEndpointState,
                    deviceExtension->BulkOutEndpointHandle,
                    USB_ENDPOINT_STATE_DATA_TOGGLE_RESET | USB_ENDPOINT_STATE_CLEAR_HALT
                    );

            if(USBD_ERROR(muInstance->Device->SubmitRequest(&deviceExtension->Urb)))
            {
                USB_DBG_WARN_PRINT(("MU_ResetDeviceDpc: Bulk-OUT SetEndpointStatus failed!"));
                ASSERT(FALSE);
            }

            //
            // Build CLEAR_FEATURE(ENDPOINT_STALL) for the OUT endpoint
            // (it will get sent at the end of this routine.)

            USB_BUILD_CLEAR_FEATURE(
                    &deviceExtension->Urb.ControlTransfer,
                    USB_COMMAND_TO_ENDPOINT,
                    USB_FEATURE_ENDPOINT_STALL,
                    muInstance->BulkOutEndpointAddress,
                    (PURB_COMPLETE_PROC)MU_ResetDeviceCompletionRoutine,
                    deviceExtension
                    );

            break;
        case DF_RESET_STEP2:
            
            //
            //  Switch the flag to indicate step2
            //
            
            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP2);
            SET_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP3);

            //
            // Build the BULK_ONLY_MASS_STORAGE_RESET command
            // (it will get sent at the end of this routine.)

            USB_BUILD_CONTROL_TRANSFER(
                &deviceExtension->Urb.ControlTransfer,
                NULL,
                NULL, 
                0,
                USB_TRANSFER_DIRECTION_OUT,
                MU_ResetDeviceCompletionRoutine,
                deviceExtension,
                FALSE,
                (USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
                BULK_ONLY_MASS_STORAGE_RESET,
                0,
                muInstance->InterfaceNumber,
                0);

            break;
        case DF_RESET_STEP3:
            
            //
            //  Clear DF_RESET_STEP3, the reset sequence is over.
            //

            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP3);

            //
            //  Check for retries.
            //
            //  retries = (total tries) - 1, so post decrement
            //  when checking.
            //

            if(deviceExtension->Mrb.Retries--)
            {
               //
               //   If we resubmit the Mrb we need to pet the
               //   watchdog, it wasn't intended to wait through
               //   lots of retries.
               //
               MU_DEBUG_PET_WATCHDOG(deviceExtension);
               //
               //   Resubmit the Mrb
               //
               MU_fCbwTransfer(deviceExtension);
            } else
            {
               //
               //   Fail with status unsuccessful
               //
               USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_UNSUCCESSFUL)", deviceExtension));
               deviceExtension->Mrb.CompletionRoutine(deviceExtension, deviceExtension->Mrb.FailedStatus);
            }

            return;

        default:
            USB_DBG_ERROR_PRINT(("Reaching here indicates an MU driver bug!"));
            return;
    }

    //
    //  Set the MRB timer to time the reset.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = MRB_RESET_TIMEOUT*MRB_TIMEOUT_UNIT;
    SET_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    SET_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    KeSetTimer(&deviceExtension->Mrb.Timer, deltaTime, &deviceExtension->Mrb.TimeoutDpcObject);

    //
    //  Submit the URB built in either case DF_RESET_STEP1, 
    //  or case DF_RESET_STEP2.
    //
    SET_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    
    return;
}


#if DBG
VOID
FASTCALL
MU_fValidateMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
        Debug Only routine that validates the current mrb.  All this
        routine does is spew errors or possible errors, otherwise
        it does not effect the operation of the driver.
      
--*/
{
    //
    //  1) If no direction flag is set, then the DataBuffer
    //     and TransferLength are NULL, and 0.
    //
    if(!TEST_FLAG(DeviceExtension->Mrb.Flags, MRB_FLAGS_UNSPECIFIED_DIRECTION))
    {
        if(DeviceExtension->Mrb.DataBuffer || DeviceExtension->Mrb.TransferLength)
        {
            USB_DBG_ERROR_PRINT(("No direction, but non-NULL DataBuffer or non-zero length"));
        }
    }
        
    //
    //  2) Only one direction flag is set.
    //
    if(TEST_ALL_FLAGS(DeviceExtension->Mrb.Flags, MRB_FLAGS_UNSPECIFIED_DIRECTION))
    {
        USB_DBG_ERROR_PRINT(("More than one direction flag is set in Mrb!"));
    }
    //
    //  3) If a direction flag is that the DataBuffer is non-NULL
    //     and that the size is finite.
    //
    if(TEST_FLAG(DeviceExtension->Mrb.Flags, MRB_FLAGS_UNSPECIFIED_DIRECTION))
    {
        if(NULL == DeviceExtension->Mrb.DataBuffer)
        {
            USB_DBG_ERROR_PRINT(("Mrb with transfer to\from NULL DataBuffer!"));
        }
        if(0 == DeviceExtension->Mrb.TransferLength)
        {
            USB_DBG_ERROR_PRINT(("Mrb with transfer of 0 length!"));
        }
    }

    return;
}

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mu\mu.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MU.H

Abstract:

    Header file for MU driver

Environment:

    kernel mode

Revision History:

    06-13-2000 : started rewrite : georgioc
    10-11-2000 : cleanup : mitchd

--*/

//*****************************************************************************
// Includes
//*****************************************************************************
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <rbc.h>
#include <ntdddisk.h>
#include <xtl.h>
#include <xdbg.h>
#include <usb.h>
#define  MODULE_POOL_TAG '__UM'
#include <debug.h>

//*****************************************************************************
// Forward declaration
//*****************************************************************************


//*****************************************************************************
// Useful Macros
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))
#define TEST_ALL_FLAGS(Flags, Bits) ((Bits) == ((Flags) & (Bits)))

#if DBG || DEBUG_LOG

    extern ULONG               MU_DebugFlags;     // DBGF_* Flags
    extern ULONG               MU_DebugLevel;     // Level of debug output

#endif


// A better WhichBit written as an inline template function.
// It returns the lowest order bit set.  If only one bit is set
// 
template <class T>
inline UCHAR WhichBit(T data)
{
    UCHAR bit;
    T mask;
    for(
        bit=0, mask=1;
        bit < sizeof(T)*8;
        bit++, mask <<= 1)
    {
        if(mask&data) break;
    }
    ASSERT(bit != sizeof(T)*8);
    return bit;
}

template <class T>
inline BOOL IsPowerOf2(T data)
/*
    Routine Description:
        Returns TRUE if data is a power of 2.  Implemented
        as inline template to work on any data type, with
        the type safety of a real function, but the efficiency
        of a MACRO.

        bitwise ANDing a value with itself minus one
        drops the lowest bit.  If the result is zero
        then it is a power of 2, provided that it
        wasn't zero or one to begin with.

        Ex. 010110 => 010110 & 010101 == 010100 NOT Power of 2.
        Ex. 001000 => 001000 & 000111 == 000000 Power of 2.
*/
{
    return ((data > 1) && !(data&(data-1))) ? TRUE : FALSE;
}


//
//  ReverseEndian for ULONG and USHORT, could have
//  used a template instead of overloading, but
//  the loop would have been less efficient.
//
inline ULONG ReverseEndian(ULONG Data)
{
    ULONG RetData;
    ((BYTE *)&RetData)[0]=((BYTE *)&Data)[3];
    ((BYTE *)&RetData)[1]=((BYTE *)&Data)[2];
    ((BYTE *)&RetData)[2]=((BYTE *)&Data)[1];
    ((BYTE *)&RetData)[3]=((BYTE *)&Data)[0];
    return RetData;
}
inline USHORT ReverseEndian(USHORT Data)
{
    USHORT RetData;
    ((BYTE *)&RetData)[0]=((BYTE *)&Data)[1];
    ((BYTE *)&RetData)[1]=((BYTE *)&Data)[0];
    return RetData;
}


//*****************************************************************************
// Defintions for a debug only IRP watchdog
//*****************************************************************************
#if DBG
#define MU_DEBUG_DECLARE_WATCHDOG_PARAMETERS() \
    KTIMER        DbgIrpTimer;\
    KDPC          DbgIrpTimeoutDpc;\
    LARGE_INTEGER DbgIrpTimeoutTime;
#define MU_DEBUG_INIT_WATCHDOG_PARAMETERS(DeviceExtension) MUDebugInitWatchDogParameters(DeviceExtension)
#define MU_DEBUG_SET_WATCHDOG(DeviceExtension) MuDebugSetWatchDogTimer(DeviceExtension)
#define MU_DEBUG_PET_WATCHDOG(DeviceExtension) MuDebugPetWatchDogTimer(DeviceExtension)
#define MU_COMPLETE_REQUEST(DeviceExtension, Irp, PriorityBoost) MuDebugCompleteRequest(DeviceExtension, Irp, PriorityBoost)
#else
#define MU_DEBUG_INIT_WATCHDOG_PARAMETERS(DeviceExtension)
#define MU_DEBUG_DECLARE_WATCHDOG_PARAMETERS()
#define MU_DEBUG_SET_WATCHDOG(DeviceExtension)
#define MU_DEBUG_PET_WATCHDOG(DeviceExtension)
#define MU_COMPLETE_REQUEST(DeviceExtension, Irp, PriorityBoost) IoCompleteRequest((Irp), (PriorityBoost))
#endif


//*****************************************************************************
// USB Definitions that are not elsewhere
//*****************************************************************************

//
// Interface Descriptor values
//

#define MU_SUBCLASS_RBC                 0x01
#define MU_SUBCLASS_TRANSPARENT         42
#define MU_PROTOCOL_BULK_ONLY           0x50

//
// Bulk-Only class-specific bRequest codes
//

#define BULK_ONLY_MASS_STORAGE_RESET    0xFF


//*****************************************************************************
// Declarations for performing diagnostics on Memory Units (requires special build)
//*****************************************************************************
#ifdef MU_DIAGNOSTIC_IOCTLS

//
//  VENDOR Specific Debug Commands bRequest
//

#define MU_VSC_GET_BAD_BLOCK_TABLE   0
#define MU_VSC_MEMORY_TEST           1

//
//  Definitions for VENDOR  Specific Debug Commands
//

#define MU_VSC_BAD_BLOCK_TABLE_SIZE (sizeof(USHORT)*16)
#define MU_VSC_BAD_BLOCK_COUNT_SIZE sizeof(USHORT)

//
// IOCTL to expose the vendor specific commands
// (supported only in debug builds)
//

#define MU_IOCTL_GET_BAD_BLOCK_TABLE\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_GET_BAD_BLOCK_TABLE, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MU_IOCTL_MEMORY_TEST\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_MEMORY_TEST, METHOD_NEITHER, FILE_ANY_ACCESS)

#endif  //end of DIAGNOSTIC IOCTLS


//*****************************************************************************
// USB Bulk-Only Protocol Definitions
//*****************************************************************************

//
//  The MU driver requires that MU BULK endpoints
//  have a wMaxPacket of MU_MAX_BULK_PACKET_SIZE
//  (extra stringent Xbox requirement)

#define MU_MAX_BULK_PACKET_SIZE         0x40

//
// Command Block Wrapper Signature 'USBC'
//

#define CBW_SIGNATURE               0x43425355
#define CBW_FLAGS_DATA_IN           0x80
#define CBW_FLAGS_DATA_OUT          0x00

//
// Command Status Wrapper Signature 'USBS'
//

#define CSW_SIGNATURE               0x53425355

#define CSW_STATUS_GOOD             0x00
#define CSW_STATUS_FAILED           0x01
#define CSW_STATUS_PHASE_ERROR      0x02


#pragma pack (push, 1)

//
// Command Block Wrapper
//
typedef struct _CBW
{
    ULONG   dCBWSignature;

    ULONG   dCBWTag;

    ULONG   dCBWDataTransferLength;

    UCHAR   bCBWFlags;

    UCHAR   bCBWLUN;

    UCHAR   bCDBLength;
    union
    {
        UCHAR   CBWCDB[16];
        CDB     Cdb;
    };
} CBW, *PCBW;


// Command Status Wrapper
//
typedef struct _CSW
{
    ULONG   dCSWSignature;

    ULONG   dCSWTag;

    ULONG   dCSWDataResidue;

    UCHAR   bCSWStatus;

} CSW, *PCSW;

#pragma pack (pop)

//******************************************************************************
//  Various Hard-coded sizes.
//
//      EMULATED_SECTOR_SIZE - This is the sector size reported to the filesystem.
//          It is the smallest unit of data the filesystem will ever try to
//          read or write.
//
//      MEDIA_BLOCK_SIZE - This is the size of a block on the media.  A block on the
//          media is the smallest unit which can be erased.  All writes must
//          start on a block boundary and end on a block boundary.  The Xbox MU
//          protocol does NOT currently provide a mechanism to query the device.
//          This value is is hardcoded as 8192 bytes.  Devices with smaller
//          media block sizes should work fine with this driver, devices with
//          larger media block sizes would not work.
//
//      The other type of block size is the logical block size.  This is reported
//      back as BytesPerBlock in the READ_CAPACITY_DATA structure received in
//      in response to a read capacity command.  Any power of 2 value less than
//      4096 is supported.  This is typically the page size of the media, which
//      is the smallest unit which may be read or written (but not erased,
//      or rewritten).  For the standard Xbox hawk this value is 512 bytes.
//
//      WRITE_BUFFER_SIZE - This buffer is used store the original contents
//          of the portion of a media block that we need to write over.  When
//          a write for a portion of a media block is requested, the original
//          contents are read into this block, and then the whole thing is
//          written back out.
//
//******************************************************************************
#define EMULATED_SECTOR_SIZE             4096
#define EMULATED_SECTOR_SHIFT            12
#define MAXIMUM_MEDIA_BLOCK_SIZE         16384
#define DEFAULT_MEDIA_BLOCK_SIZE         8192
#define WRITE_BUFFER_SIZE                (MAXIMUM_MEDIA_BLOCK_SIZE - EMULATED_SECTOR_SIZE)

//*****************************************************************************
// Forward declarations of pointer to structure types
//*****************************************************************************
typedef struct _MU_DRIVER_EXTENSION *PMU_DRIVER_EXTENSION;
typedef struct _MU_INSTANCE *PMU_INSTANCE;
typedef struct _MU_DEVICE_EXTENSION *PMU_DEVICE_EXTENSION;

//*****************************************************************************
// Driver object and driver(not device) specific definitions
//*****************************************************************************
#define MU_CONTROLLERS_PER_PORT 2
#define MU_DEFAULT_MAX_MOUNTED  8
/* DEVICE_INDEX_FROM_PORT_AND_SLOT depends on MU_CONTROLLERS_PER_PORT = 2 */
#define NODE_INDEX_FROM_PORT_AND_SLOT(port, slot) ((port<<1)+slot)

typedef struct MU_DRIVER_EXTENSION {
   
    PMU_DEVICE_EXTENSION DeviceObjectFreeList;
    //
    //  Resources for handling writes to only a portion of
    //  a media block.  Not that there is one global WriteBuffer
    //  and partial requests are queued.
    //
    
    LIST_ENTRY  PartialRequestQueue;
    UCHAR       WriteBuffer[WRITE_BUFFER_SIZE];
    
    PMU_INSTANCE Nodes;

}  MU_DRIVER_EXTENSION;

extern MU_DRIVER_EXTENSION MU_DriverExtension;

//*****************************************************************************
// MU Request Block (MRB) defintions
//*****************************************************************************

#define MRB_TIMEOUT_UNIT                      (-100000) //This constant represents 10 ms to the timer routines.
#define MRB_STANDARD_TIMEOUT                  (8)       //Standard Timeout is 80 ms (spec says 50 ms), this applies to CBW's
#define MRB_DATA_TIMEOUT                      (15)      //Time out is 150 ms for each 2k portion of a read or write.
#define MRB_RESET_TIMEOUT                     (10)      //Time out is 100 ms for each stage of the reset sequence.
                                                          
#define MRB_READ_CAPACITY_TIMEOUT             (10)      // a 100 ms delay for the CSW of read capacity.
#define MRB_VERIFY_TIMEOUT_PER_64K            (100)     // 1 second per 64 kbytes verified for CSW of VERIFY.
#define MRB_CALC_VERIFY_TIMEOUT(VerifyLength) ((USHORT)(MRB_VERIFY_TIMEOUT_PER_64K*((VerifyLength) >> 16)))

#define MRB_MAXIMUM_RETRIES                    2        //Maximum number of times an MRB is retried.

#define MRB_FLAGS_NO_DATA_TRANSFER  0x00
#define MRB_FLAGS_DATA_IN           0x01
#define MRB_FLAGS_DATA_OUT          0x02
#define MRB_FLAGS_SPLIT_WRITE       0x04
#define MRB_FLAGS_UNSPECIFIED_DIRECTION (MRB_FLAGS_DATA_IN | MRB_FLAGS_DATA_OUT)
#define MRB_TRANSFER_SIZE           1024 //size of each transfer
#define MU_BULK_MIN_TD_QUOTA        ((2*MRB_TRANSFER_SIZE)/MU_MAX_BULK_PACKET_SIZE)

typedef VOID (*PFMU_IO_COMPLETION)(PMU_DEVICE_EXTENSION DeviceExtension, NTSTATUS Status);

typedef struct _MU_REQUEST_BLOCK {
    // filled out by disk layer
    // (are guaranteed to remain intact)
    PUCHAR             DataBuffer;
    ULONG              TransferLength;
    PFMU_IO_COMPLETION CompletionRoutine;
    USHORT             TimeOutValue; //in 10's of milliseconds
    UCHAR              Retries;
    UCHAR              Flags;
    ULONG              UserStartOffset; //For partial writes (read\modify\write)
    ULONG              UserEndOffset;   //Specifies which portion of the read goes
                                        //into the user buffer.
    CBW                Cbw; // Disk layer fills out only CDB
    //  Used by the MRB state machine
    CSW                Csw;
    union
    {
    NTSTATUS            FailedStatus;    //used to hold failure during reset.       
    ULONG              BytesSubmitted;
    };
    
    KTIMER             Timer;
    KDPC               TimeoutDpcObject;
} MU_REQUEST_BLOCK, *PMU_REQUEST_BLOCK;

//*****************************************************************************
// MU DeviceExtension and related defintions
//*****************************************************************************

//
// PDEVICE_EXTENSION->DeviceFlags state flags
//
#define DF_PENDING_CLOSE           0x00000001
#define DF_PENDING_REMOVE          0x00000002
#define DF_REMOVED                 0x00000004

//
//  Flags used by the MRB state machine,
//  these are internal to it.  The flags
//  in the MRB is only a direction.
//

#define DF_MRB_TIMER_RUNNING       0x00000100
#define DF_PRIMARY_URB_PENDING     0x00000200
#define DF_SECONDARY_URB_PENDING   0x00000400
#define DF_ERROR_PENDING           0x00000800
#define DF_RESET_STEP1             0x00001000
#define DF_RESET_STEP2             0x00002000
#define DF_RESET_STEP3             0x00004000
#define DF_RESET_STEPS (DF_RESET_STEP1|DF_RESET_STEP2|DF_RESET_STEP3)

#define DF_ANY_URB_PENDING (DF_PRIMARY_URB_PENDING|DF_SECONDARY_URB_PENDING)

//
// PDEVICE_EXTENSION->DeviceFlags state flags
// related to the endpoint state machine.
//

#define DF_ENDPOINT_FLAGS          0x000F0000
#define DF_DEFAULT_ENDPOINT_OPEN   0x00010000
#define DF_BULK_IN_ENDPOINT_OPEN   0x00020000
#define DF_BULK_OUT_ENDPOINT_OPEN  0x00040000
#define DF_CLOSING_ENDPOINTS       0x00080000
#define DF_ENDPOINTS_READY         0x00070000

//
// PDEVICE_EXTENSION->DeviceFlags state flags
// related to the write state machine.
//

#define MU_WRITE_HAS_INITIAL_PORTION 0x02000000
#define MU_WRITE_HAS_FINAL_PORTION   0x04000000
#define MU_WRITE_HAS_MIDDLE_PORTION  0x08000000
#define MU_WRITE_HAS_FLAGS   (MU_WRITE_HAS_INITIAL_PORTION|MU_WRITE_HAS_FINAL_PORTION|MU_WRITE_HAS_MIDDLE_PORTION)

//
//  Write state machine flags for the normal
//  partial write state machine.
//
#define MU_WRITE_STATE_START         0x10000000
#define MU_WRITE_STATE_INITIAL_READ  0x20000000
#define MU_WRITE_STATE_INITIAL_WRITE 0x30000000
#define MU_WRITE_STATE_FINAL_READ    0x40000000
#define MU_WRITE_STATE_FINAL_WRITE   0x50000000
#define MU_WRITE_STATE_DONE          0x60000000
#define MU_WRITE_STATE_BITS          0xF0000000
#define MU_WRITE_STATE_INCREMENT     0x10000000

//
//  Write state machine flags for the "middle" partial
//  write state machine.
//
#define MU_WRITE_STATE_MIDDLE_START        0x10000000
#define MU_WRITE_STATE_MIDDLE_READ_BEFORE  0x20000000
#define MU_WRITE_STATE_MIDDLE_READ_AFTER   0x30000000
#define MU_WRITE_STATE_MIDDLE_WRITE        0x40000000
#define MU_WRITE_STATE_MIDDLE_DONE         0x50000000


//
//  Pattern that we use for marking corrupt sectors.
//  (Don't worry how long it is (except for code space;),
//  in the success case, we stop comparing on the first
//  mismatch.  In the error case we have plenty of time
//  anyway.)  The number pattern at the beginning is part
//  of GUID generated with GUIDGEN.
//
const char tagMU_CORRUPT_SECTOR_PATTERN[]="951F0EF630DC46d9_CORRUPT_SECTOR";
#define MU_CORRUPT_SECTOR_PATTERN ((PULONG)tagMU_CORRUPT_SECTOR_PATTERN)
#define MU_CORRUPT_SECTOR_PATTERN_SIZE sizeof(tagMU_CORRUPT_SECTOR_PATTERN)
#define MU_CORRUPT_SECTOR_PATTERN_ULONG_COUNT (MU_CORRUPT_SECTOR_PATTERN_SIZE/sizeof(ULONG))

//
// MU_INSTANCE contains context data for each MU.
// These are statically allocated at startup time.
// 

typedef struct _MU_INSTANCE
{
    //
    // Device class interface to USB core stack
    //

    IUsbDevice      *Device;
    
    //
    // USB related data retrieved during 
    // enumeration, or when opening endpoints
    //

    UCHAR  InterfaceNumber;
    UCHAR  BulkInEndpointAddress;
    UCHAR  BulkOutEndpointAddress;
    UCHAR  AddRemoveCount;  //DEBUG ONLY, catches double removes and\or adds.    
    
    //
    //  Pointer to assigned device extension
    //

    PMU_DEVICE_EXTENSION DeviceExtension;

} MU_INSTANCE; 


typedef struct _MU_DEVICE_EXTENSION
{
    //
    //  Points to the Device Object
    //
    PDEVICE_OBJECT DeviceObject;

    //
    //  Number (used to regenerate the name)
    //
    ULONG DeviceObjectNumber;

    //
    //  Points to our MU_INSTANCE
    //
    union {
        PMU_INSTANCE         MuInstance;
        PMU_DEVICE_EXTENSION NextFree;
    };
    //
    // Various DF_xxxx flags
    //

    ULONG   DeviceFlags;

    
    //***
    //*** Above here is maintained while the device object
    //*** is on the free list, below is always zeroed.
    //***

    //
    // At any time, each device is processing
    // one IRP, this is it.
    //

    PIRP    PendingIrp;
    ULONG   IrpCount;   //Count of outstanding IRPs

    //  Variables to cache results of calculations
    //  for partial writes
    ULONG   InitialWriteByteCount;
    ULONG   FinalWriteByteCount;

    PVOID   BulkInEndpointHandle;
    PVOID   BulkOutEndpointHandle;

    //
    // The Mrb for managing commands
    //

    MU_REQUEST_BLOCK    Mrb;

    //
    //  Each instance maitains three independent URBs
    //  for communication with the device.
    //  This is so that two bulk URBs can be outstanding
    //  at once (which better utilizes bandwidth).
    //  Furthermore, a dedicated close URB is provided
    //  so that the close state machine does not need
    //  to synchronize with the MRB state machine.
    //
    
    URB                             Urb;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkUrbSecondary;
    URB_CLOSE_ENDPOINT              CloseEndpointUrb;
    KEVENT                          CloseEvent; //signaled when a close completes

    //
    //  Geomerty Information
    //

    DISK_GEOMETRY       DiskGeometry;
    ULONG               LogicalBlockShift;
    LARGE_INTEGER       PartitionLength;
    ULONG               MediaBlockSize;

    //
    //  Watchdog timer parameters
    //  
    MU_DEBUG_DECLARE_WATCHDOG_PARAMETERS()

} MU_DEVICE_EXTENSION;


//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************
// Only those between translation units.

//
//  inline [acquire and release preallocate device objects.
//
__inline 
PMU_DEVICE_EXTENSION
MU_AcquireDeviceObject()
{ 
    PMU_DEVICE_EXTENSION retVal;
    retVal = MU_DriverExtension.DeviceObjectFreeList;
    if(retVal)
    {
        MU_DriverExtension.DeviceObjectFreeList = retVal->NextFree;
        retVal->DeviceFlags = 0;
        retVal->MuInstance = NULL;
    }
    return retVal;
}

__inline 
VOID
MU_ReleaseDeviceObject(PMU_DEVICE_EXTENSION DeviceExtension)
{
    RtlZeroMemory(&DeviceExtension->PendingIrp, sizeof(MU_DEVICE_EXTENSION)-FIELD_OFFSET(MU_DEVICE_EXTENSION, PendingIrp));
    DeviceExtension->DeviceFlags = DF_REMOVED;
    DeviceExtension->NextFree = MU_DriverExtension.DeviceObjectFreeList;
    MU_DriverExtension.DeviceObjectFreeList = DeviceExtension;
}




//
// mu.cpp  [These are all called from outside the MU driver]
//

EXTERNUSB VOID
MU_Init(IUsbInit *pUsbInit);

EXTERNUSB VOID
MU_AddDevice (
    IN IUsbDevice *Device
    );

EXTERNUSB VOID
MU_RemoveDevice (
    IN IUsbDevice *Device
    );

extern "C"
{
NTSTATUS
MU_CreateDeviceObject(
    IN  ULONG            Port,
    IN  ULONG            Slot,
    IN  POBJECT_STRING  DeviceName
    );

VOID
MU_CloseDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );

PDEVICE_OBJECT
MU_GetExistingDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );
}
//
// mrb.cpp
//

VOID
FASTCALL
MU_fStartMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_MrbTimeout (
    IN PKDPC Dpc,
    IN PVOID fdoDeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
//  disk.cpp
//

NTSTATUS
MU_InternalIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
MU_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
//  Debug Only Methods, defined at the bottom of disk.cpp
//
#if DBG
VOID
MUDebugWatchdogDpcRoutine(
    PKDPC,
    PMU_DEVICE_EXTENSION DeviceExtension,
    PVOID,
    PVOID
    );

VOID
MUDebugInitWatchDogParameters(
    PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID 
MuDebugSetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    );
VOID
MuDebugPetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID 
MuDebugCompleteRequest(
    PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    CCHAR PriorityBoost
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mu\disk.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    MU disk and partition routines. Top level interface of MU driver

Environment:

    kernel mode

Revision History:

    06/12/2000 - started re-write - georgioc 
    03/08/20001 - arbitray media block size support, see comments - mitchd

--*/


/*++

    03/08/2001 - MEDIA BLOCK SIZES.  Flash ROM media in used in the Memory
                 Units has two relevant lengths: a media page size and a
                 media block size.  The media page size is the smallest
                 unit of storage that can be read from or written to.  The
                 catch is that write doesn't really write it just ORs.
                 The media block size is the smallest block unit of storage
                 that can be erased.

                 A typical media page size is 512 bytes, and a typical media
                 block size is 8k for an 8 MB media and larger for larger media.
                 On all products for Windows, the FW in the media drives report the
                 SCSI Logical Block Size as their page size.  The devices manage
                 the media block internally using on-board RAM to buffer writes
                 as needed.  In addition to supporting much smaller logical
                 block sizes, the extra RAM helps them improve through-put.  An
                 erase operation takes significant time.  Without on-board RAM
                 a write command stalls while blocks are being erased.  With enough 
                 on-board the write is buffered during the erase and transfer proceeds
                 at the USB bandwidth limit.  Still the media write (and read) is
                 comparable and often slower than the USB bus.  Again the RAM helps
                 by allowing multiple blocks to be read to and written from simultaneously.
                 With a well implemented media drive, the USB bus is definately the
                 bottle-neck.

                 On Xbox, COGS were a signficant issue since the media drive and the
                 media are both sold as a single integrated unit.  Thus there is no
                 tolerance for added cost to the drive.  RAM was reduced to a minimum
                 and the Xbox side Memory Unit driver (this code) manages the media block
                 size.  The FW is designed to erase the relevant blocks with any write.
                 So all writes must be to full media blocks, or there adjacent media pages
                 will be erased.  A simple solution is to increase the sector size reported
                 to the filesystem to the media block size.  Unfortunately, the filesystem
                 only supports sector sizes up to one x86 page of 4 kilobytes, while the
                 media block size are typically larger than this.  So writes to less than
                 a full block are supported by reading the remaining portion of the block
                 and writing the whole block out.

                 The initial implementation was designed around the 8 MB media with 8 kbyte
                 media block sizes.  The simplifying assumption that the block size is
                 twice the 4k sector size of the filesystem was used extensively. However,
                 it has become clear that media prices are dropping and larger media (With
                 larger block sizes) are becoming available.

                 This revision addresses this issue by generalizing the scheme to support any
                 media block size that is a positive integral multiple of the 4k sector size.
                 Since the driver is not allowed to dynamically allocate memory according to
                 the MU size, for predictability reasons, a maximum buffer size and thus maximum
                 media block size must be set at compile time of XSS.  That limit has been
                 chosen as of this date to be 16 kbyte.  The code has been written so that this
                 limit is simply a #define and can be changed at any time.  However, if units
                 with larger block sizes become available, the games compiled with the
                 smaller maximum block size will refuse to mount them.  Unfortunately, it is
                 much more difficult to completely hide the units from these games.

                 All writes are broken up into up to three of four phases.  An initial unaligned
                 portion, a whole portion that is completely aligned, and a final portion that
                 is unaligned on the end.  The fourth type I have dubbed a "middle partial portion"
                 which is a small write that begins and ends within a single media block and is
                 not aligned to either end of the block.

                 Partial Middle Writes have their own state machine that reads the portion before,
                 then the portion after and then spits out the whole block.

                 Other writes, send the whole poriton first (if there is one), and then if there
                 was an initial or final portion enter a state machine that handles the initial
                 and final portions in sequence.

                 In order to minimize buffer memory there is one global buffer for partial writes.
                 Requests to either state machine are queued in a single global queue.  Note that
                 since requests for a given device are also queued, there can never be more than
                 one request per device in the partial write queue.  Both state machines, whenever
                 they complete a partial write, pull the next request off the partial write queue
                 and start in the proper state machine.

                 See the comments at the top mrb.cpp for discussion of changes to the mrb state
                 machine (that implements the MU Bulk-Only protocol) to better accomodate the
                 needs of the more generalized buffering.

--*/

//*******************************************************************************
// Includes
//*******************************************************************************
#include "mu.h"

//*******************************************************************************
// local function declarations
//*******************************************************************************
DEFINE_USB_DEBUG_FUNCTIONS("MU");

VOID
MU_fDiskDeviceControl(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
MU_fDiskReadDriveCapacity(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    );

VOID
MU_DiskReadCapacityCompletion(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
FASTCALL
MU_fDiskVerify(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
MU_DiskReadComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
MU_DiskIoComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
FASTCALL
MU_fDiskReadWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
MU_DiskStartPartialWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
MU_DiskWriteBuildPartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
MU_DiskWriteBuildMiddlePartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
FASTCALL
MU_fMarkWriteBufferCorrupt(
    IN PMU_REQUEST_BLOCK Mrb
    );


VOID
MU_DiskWriteStartNextPartialRequest();




//*******************************************************************************
// Declarations for diagnostic IOCTL's
//*******************************************************************************

#ifdef MU_DIAGNOSTIC_IOCTLS

NTSTATUS
FASTCALL         
MU_fVscCommand(
 IN PMU_DEVICE_EXTENSION DeviceExtension,
 IN PIRP Irp,
 IN BYTE bRequest,
 IN ULONG ulOutputSize
 );


VOID
MU_VscComplete(
    IN PURB   Urb,
    IN PVOID  Context
    );

#endif


//*******************************************************************************
// debug write log stuff
//*******************************************************************************
#if DBG

    #define WRITE_LOG_LENGTH 2000
    ULONG WriteLog[WRITE_LOG_LENGTH];
	ULONG WriteBlock[WRITE_LOG_LENGTH];
    LONG  WriteCount = 0;

    ULONG MU_GetWriteSize(LONG count) { return WriteLog[count]; }
	ULONG MU_GetWriteBlock(LONG count) { return WriteBlock[count]; }
    LONG MU_GetWriteCount() { return WriteCount; }

#endif

//*******************************************************************************
// Implementation
//*******************************************************************************
NTSTATUS
MU_InternalIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
    Routine Description:
    
      Entry Point for:
        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_DEVICE_CONTROL
        IRP_MJ_INTERNAL_DEVICE

    In other words, excepting IRP_MJ_CREATE and IRP_MJ_CLOSE, all
    supported IRPs go through here.

    Since all USB requests to a single device are serialized by the bulk-only
    protocol anyway, we just serialize all the IRPs coming in with a device queue.


--*/
{
    PMU_DEVICE_EXTENSION deviceExtension;
    KIRQL                oldIrql;
    NTSTATUS             ntStatus = STATUS_PENDING;

    USB_DBG_ENTRY_PRINT(("MU_InternalIo(DeviceObject=0x%0.8x,Irp=0x%0.8x)", DeviceObject, Irp));

    deviceExtension = (PMU_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Other parts of the system (XAPI, or intelligent private caller of MU_CreateDeviceObject
    //  and MU_CloseDeviceObject) are supposed to ensure that we do not have outstanding I/O
    //  before calling MU_CloseDeviceObject, and that no new I/O will be initiated after calling
    //  MU_CloseDeviceObject.  We will just ASSERT that this is so.
    //

    ASSERT(!TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE));

    //
    //  Ensure that device is connected.
    //
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE))
    {
        ntStatus = STATUS_DEVICE_NOT_CONNECTED;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        USB_DBG_WARN_PRINT(("An I/O Request has been sent to an MU which is removed"));
    } else
    {
        //
        //  Mark the Irp Pending and add it to the device queue.
        //
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject,
                      Irp,
                      NULL);
    }
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("MU_InternalIo returning 0x%0.8x", ntStatus));
    return ntStatus;
}

VOID
MU_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
    Routine Description:
        Typical StartIo routine.  Handles one request at a time
        and dispatches it.
--*/
{
    PMU_DEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    USB_DBG_ENTRY_PRINT(("MU_StartIo(DeviceObject=0x%0.8x,Irp=0x%0.8x)", DeviceObject, Irp));

    deviceExtension = (PMU_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    USB_DBG_ENTRY_PRINT(("MU_StartIo(0x%0.8x(0x%0.8x), 0x%0.8x)", DeviceObject, deviceExtension, Irp));

    //
    //  Other parts of the system (XAPI, or intelligent private caller of MU_CreateDeviceObject
    //  and MU_CloseDeviceObject) are supposed to ensure that we do not have outstanding I/O
    //  before calling MU_CloseDeviceObject, and that no new I/O will be initiated after calling
    //  MU_CloseDeviceObject.  We will just ASSERT that this is so.
    //

    ASSERT(!TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE));

    //
    //  If the console is preparing to reset or shutdown, there's no reason to
    //  continue processing this request.
    //

    if (HalIsResetOrShutdownPending())
    {
        Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceObject);
        return;
    }

    //
    //  Store our device object in the
    //  our stack so we can get back at it.
    //  (This is used by the partial write queue
    //  to relate an Irp back to its device object.)
    //

    irpStack->DeviceObject = DeviceObject;

    //
    //  Save the IRP we are working on
    //  so it doesn't need to be passed everywhere.
    //

    deviceExtension->PendingIrp = Irp;

    //
    //  For debug builds only set a watchdog timer
    //  on the IRP.
    //
    MU_DEBUG_SET_WATCHDOG(deviceExtension);

    //
    //  Handle\Dispatch the request
    //

    switch (irpStack->MajorFunction)
    {
      case IRP_MJ_DEVICE_CONTROL:
        MU_fDiskDeviceControl(deviceExtension,Irp);
        break;
      case IRP_MJ_WRITE:
        IoMarkIrpMustComplete(Irp);
        // FALL THROUGH
      case IRP_MJ_READ:
        MU_fDiskReadWrite(deviceExtension,Irp);
        break;
      default:
        ASSERT("MU called with unsupported I/O Request.");
    }

    USB_DBG_EXIT_PRINT(("MU_StartIo returning"));
    return;
}

VOID
MU_fDiskDeviceControl(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by MU_StartIo to handle
    IRP_MJ_DEVICE_CONTROL sent to an MU.
        
    The following IOCTLs are supported, others spew ERROR strings:
        IOCTL_DISK_GET_DRIVE_GEOMETRY
        IOCTL_DISK_GET_PARTITION_INFO
        IOCTL_DISK_VERIFY

    Whenever possible these are satisified with cached information.
    Otherwise, they are dispatched to a routine which builds and
    submits an Mrb to the MRB state machine.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None

--*/
{
    NTSTATUS               status;
    PDISK_GEOMETRY         diskGeometry;
    PPARTITION_INFORMATION partitionInformation;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);


    //
    //  Most of the time, the request
    //  will just be pending, so set it here,
    //  and change it if necessary when processing
    //  specific cases.
    //

    status = STATUS_PENDING;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_DISK_GET_DRIVE_GEOMETRY:

        diskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
        //debug parameter check
        ASSERT(sizeof(DISK_GEOMETRY) <= irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        //
        //  If the Partition Length is zero, we need
        //  to fetch the capacity from the device.
        //
        if (DeviceExtension->PartitionLength.QuadPart == 0)
        {
            //
            //  MU_fDiskReadDriveCapacity doesn't
            //  return a status, it always, pends
            //  the IRP.
            //

            USB_DBG_TRACE_PRINT(("GetDriveGeometry, issuing read capacity"));
            status = MU_fDiskReadDriveCapacity(DeviceExtension,Irp);

        } else
        //
        //  We already know the geometry, just copy it.
        //
        {

            RtlCopyMemory(diskGeometry, &DeviceExtension->DiskGeometry,
                          sizeof(DISK_GEOMETRY));

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
        }

        break;        

      case IOCTL_DISK_GET_PARTITION_INFO:

        //debug parameter check
        ASSERT(sizeof(PARTITION_INFORMATION) <= irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        //
        // Fill in the output buffer and return.
        //

        partitionInformation = (PPARTITION_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(partitionInformation, sizeof(PARTITION_INFORMATION));

        //
        //  If the Partition Length is zero, we need
        //  to fetch the capacity from the device.
        //

        if (DeviceExtension->PartitionLength.QuadPart == 0) {

            //
            //  MU_fDiskReadDriveCapacity doesn't
            //  return a status, it always pends
            //  the IRP.
            //

            USB_DBG_TRACE_PRINT(("GetPartitionInfo, issuing read capacity"));
            status = MU_fDiskReadDriveCapacity(DeviceExtension,Irp);

        } else
        //
        //  We already know the partition length, just copy it.
        //
        {
            partitionInformation->PartitionLength = DeviceExtension->PartitionLength;
            partitionInformation->RecognizedPartition = TRUE;
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        }

        break;

      case IOCTL_DISK_VERIFY:
        
        //
        //  MU_fDiskVerify doesn't return status, it always
        //  pends the IRP.
        //
        MU_fDiskVerify(DeviceExtension, Irp);
        break;

        //
        //  The following requests are for running
        //  diagnostics on the memory unit and require
        //  a special build.
        //

#ifdef MU_DIAGNOSTIC_IOCTLS
      case MU_IOCTL_GET_BAD_BLOCK_TABLE:
         
        ASSERT(Irp->UserBuffer && "MU_IOCTL_GET_BAD_BLOCK_TABLE");
         
        ASSERT((MU_VSC_BAD_BLOCK_TABLE_SIZE <= irpStack->Parameters.DeviceIoControl.OutputBufferLength) &&
                "MU_IOCTL_GET_BAD_BLOCK_TABLE");

        //
        //  MU_VSC_GET_BAD_BLOCK_TABLE, must always be proceeded
        //  by a read capacity.
        //
        status = MU_fDiskReadDriveCapacity(DeviceExtension,Irp);
        break;

      case MU_IOCTL_MEMORY_TEST:
   
        ASSERT(Irp->UserBuffer && "MU_IOCTL_MEMORY_TEST");
         
        ASSERT((MU_VSC_BAD_BLOCK_COUNT_SIZE <= irpStack->Parameters.DeviceIoControl.OutputBufferLength) && 
                MU_IOCTL_MEMORY_TEST);
        
        status = MU_fVscCommand(
                    DeviceExtension,
                    Irp,
                    MU_VSC_MEMORY_TEST,
                    MU_VSC_BAD_BLOCK_COUNT_SIZE
                    );
        break;
      
#endif

      default:
        USB_DBG_ERROR_PRINT((
            "MuDiskDeviceControl: disk device doesn't handle IOCTL %08x\n",
            irpStack->Parameters.DeviceIoControl.IoControlCode
            ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    
    //
    //  If the status is not pending, complete
    //  the current IRP and return an error
    //

    if(status != STATUS_PENDING)
    {
        Irp->IoStatus.Status = status;
        MU_COMPLETE_REQUEST(DeviceExtension, Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceExtension->DeviceObject);
    }
    return;    
}


NTSTATUS
FASTCALL
MU_fDiskReadDriveCapacity(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
/*++
    Routine Description:
        Builds an MRB for Read Capacity and submits it
        to the MRB state machine
--*/
{
    PREAD_CAPACITY_DATA readCapacityBuffer;
    PMU_REQUEST_BLOCK   mrb;

    //
    // Allocate read capacity buffer
    //

    readCapacityBuffer = (PREAD_CAPACITY_DATA) RTL_ALLOCATE_HEAP(sizeof(READ_CAPACITY_DATA));
    
    if (!readCapacityBuffer)
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        USB_DBG_WARN_PRINT(("Insufficient Memory to allocate READ_CAPACITY_DATA buffer"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill out the mrb
    //
 
    mrb = &DeviceExtension->Mrb;
    mrb->DataBuffer = (PUCHAR) readCapacityBuffer;
    mrb->TransferLength = sizeof(READ_CAPACITY_DATA);
    mrb->CompletionRoutine = MU_DiskReadCapacityCompletion;
    mrb->TimeOutValue = MRB_READ_CAPACITY_TIMEOUT;
    mrb->Retries = MRB_MAXIMUM_RETRIES;
    mrb->Flags = MRB_FLAGS_DATA_IN;

    //
    //  Fill out the CDB
    //

    RtlZeroMemory(&mrb->Cbw.Cdb, sizeof(CDB));
    mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;
    
    //
    //  Submit the MRB
    //

    MU_fStartMrb(DeviceExtension);

    return STATUS_PENDING;
} // end MuDiskReadDriveCapacity()

VOID
MU_DiskReadCapacityCompletion(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        The MRB completion routine called when SCIOP_READ_CAPACITY
        returns.

        This was called either so we could complete an
        IOCTL_DISK_GET_DRIVE_GEOMETRY request or to complete
        IOCTL_DISK_GET_PARTITION_INFO.

        So we calculate both and cache them, then figure
        out which Irp is outstanding and complete it.
--*/
{

    PDISK_GEOMETRY diskGeometry;
    PPARTITION_INFORMATION partitionInformation;
    PREAD_CAPACITY_DATA readCapacityBuffer = (PREAD_CAPACITY_DATA) DeviceExtension->Mrb.DataBuffer;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(DeviceExtension->PendingIrp);

    //
    //  If the Mrb failed, then fail the Irp.  The Mrb
    //

    if(NT_ERROR(Status))
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        DeviceExtension->PendingIrp->IoStatus.Status = Status;
        USB_DBG_WARN_PRINT(("ReadCapacity Transfer Failed"));
        goto MU_DiskReadCapacityCompletionCleanup;
    }
        
    ULONG bytesPerLogicalBlock = ReverseEndian(readCapacityBuffer->BytesPerLogicalBlock);
    ULONG mediaBlockSize = bytesPerLogicalBlock * 
                           ReverseEndian(readCapacityBuffer->LogicalBlocksPerMediaBlock);
    ULONG logicalBlockCount = ReverseEndian(readCapacityBuffer->LogicalBlockAddress) + 1;
    ULONGLONG totalCapacity = ((ULONGLONG)logicalBlockCount) * bytesPerLogicalBlock ;

    // The LogicalBlocksPerMediaBlock was added after the original FW, so if it is zero
    // use the default value.
    if(0 == mediaBlockSize) 
        mediaBlockSize = DEFAULT_MEDIA_BLOCK_SIZE;

    //
    //  Check the capacity data to ensure we can support the device.
    //  If any of our requirements are not met, we will fail the IRP.
    //  This effectively makes the MU unmountable.
    //  Requirements:
    //  1) BytesPerLogicalBlock - Must be a power of 2 not greater than the EMULATED_SECTOR_SIZE(=4096).
    //  2) MediaBlockSize - Must be an integer multiple of the EMULATED_SECTOR_SIZE, but not greater than
    //                      the MAXIMUM_MEDIA_BLOCK_SIZE.
    //  3) Total Capacity - must be not less than the mediaBlockSize and not greater than 2^32 = 4 GB.
    //  4) logicalBlockCount - must be non-zero.  This is an artifact of adding 1 to the LogicalBlockAddress
    //                         really it is saying that the LogicalBlockAddress may not be the maximum
    //                         value, which would exceed the capacity limit anyway.
    if(
        !IsPowerOf2(bytesPerLogicalBlock) ||
        (bytesPerLogicalBlock > EMULATED_SECTOR_SIZE) ||
        (mediaBlockSize > MAXIMUM_MEDIA_BLOCK_SIZE) ||
        (mediaBlockSize%EMULATED_SECTOR_SIZE) ||
        (0 == logicalBlockCount) ||
        (totalCapacity < mediaBlockSize) ||
        (totalCapacity > (((ULONGLONG)1)<<32))
    )
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        DeviceExtension->PendingIrp->IoStatus.Status = STATUS_UNRECOGNIZED_VOLUME;
        USB_DBG_WARN_PRINT(("The logical block configuration of an MU is outside supported parameter ranges."));
        goto MU_DiskReadCapacityCompletionCleanup;
    }

    //
    //  Store media capacity and media block size
    //
    DeviceExtension->PartitionLength.QuadPart = totalCapacity;
    DeviceExtension->MediaBlockSize = mediaBlockSize;
    
    //
    // Calculate logical block to byte shift.
    //
    DeviceExtension->LogicalBlockShift = WhichBit(bytesPerLogicalBlock);
    
    //
    //  Fill out the geometry information (note that BytesPerSector
    //  is our fixed EMULATED_SECTOR_SIZE.)
    USB_DBG_TRACE_PRINT(("Geometry Buffer @ 0x%0.8x", &DeviceExtension->DiskGeometry));
    DeviceExtension->DiskGeometry.MediaType = FixedMedia;
    DeviceExtension->DiskGeometry.Cylinders.QuadPart = totalCapacity/mediaBlockSize;
    DeviceExtension->DiskGeometry.TracksPerCylinder = 1; 
    DeviceExtension->DiskGeometry.SectorsPerTrack = mediaBlockSize / EMULATED_SECTOR_SIZE;
    DeviceExtension->DiskGeometry.BytesPerSector = EMULATED_SECTOR_SIZE;

    //
    // now fill the appropriate Irp buffer results
    //

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_DISK_GET_DRIVE_GEOMETRY:

        diskGeometry = (PDISK_GEOMETRY)DeviceExtension->PendingIrp->UserBuffer;
        RtlCopyMemory(diskGeometry, &DeviceExtension->DiskGeometry, sizeof(DISK_GEOMETRY));

        DeviceExtension->PendingIrp->IoStatus.Information = sizeof(DISK_GEOMETRY);
        DeviceExtension->PendingIrp->IoStatus.Status = STATUS_SUCCESS;

        break;        

      case IOCTL_DISK_GET_PARTITION_INFO:

        //
        // Fill in the output buffer and return.
        //

        partitionInformation = (PPARTITION_INFORMATION)DeviceExtension->PendingIrp->UserBuffer;

        RtlZeroMemory(partitionInformation, sizeof(PARTITION_INFORMATION));

        partitionInformation->PartitionLength = DeviceExtension->PartitionLength;
        partitionInformation->RecognizedPartition = TRUE;

        DeviceExtension->PendingIrp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        DeviceExtension->PendingIrp->IoStatus.Status = STATUS_SUCCESS;

        break;

#ifdef MU_DIAGNOSTIC_IOCTLS
      //
      //  MU_IOCTL_GET_BAD_BLOCK_TABLE requires a READ_CAPACITY to proceed it.
      //  This could be why we are here.
      //
      case MU_IOCTL_GET_BAD_BLOCK_TABLE:
        {        
          NTSTATUS status = MU_fVscCommand(
                              DeviceExtension,
                              DeviceExtension->PendingIrp,
                              MU_VSC_GET_BAD_BLOCK_TABLE,
                              MU_VSC_BAD_BLOCK_TABLE_SIZE
                              );
          if(STATUS_PENDING == status)
          {
            RTL_FREE_HEAP(readCapacityBuffer);
            return;
          }
        }        
        break;            
#endif

    }

MU_DiskReadCapacityCompletionCleanup: //error paths rejoin here for cleanup

    //
    // Deallocate read capacity buffer.
    //

    RTL_FREE_HEAP(readCapacityBuffer);

    //
    //  Complete the Irp
    //

    MU_COMPLETE_REQUEST(DeviceExtension, DeviceExtension->PendingIrp, IO_NO_INCREMENT);
    
    //
    //  Start processing the next Irp.
    //

    IoStartNextPacket(DeviceExtension->DeviceObject);

   return;
} 

VOID
FASTCALL
MU_fDiskVerify(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_VERIFY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PVERIFY_INFORMATION verifyInfo = (PVERIFY_INFORMATION)irpStack->Parameters.DeviceIoControl.InputBuffer;
    PMU_REQUEST_BLOCK    mrb = &DeviceExtension->Mrb;

    ULONG         logicalBlockOffset;
    USHORT        logicalBlockCount;

    //
    // Verify sectors
    //

    mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_VERIFY;

    //
    //  Assert that the parameter to verify are reasonable.
    //
    ASSERT(sizeof(VERIFY_INFORMATION) <= irpStack->Parameters.DeviceIoControl.InputBufferLength);
    ASSERT(verifyInfo);
    ASSERT(0==verifyInfo->StartingOffset.QuadPart%EMULATED_SECTOR_SIZE);
    ASSERT(verifyInfo->Length);
    ASSERT(0==verifyInfo->Length%EMULATED_SECTOR_SIZE);
    
    //
    // Convert byte offset to logical block offset.
    //

    logicalBlockOffset = (ULONG)(verifyInfo->StartingOffset.QuadPart >> DeviceExtension->LogicalBlockShift);

    //
    // Convert ULONG byte count to USHORT sector count.
    //
    
    logicalBlockCount = (USHORT)(verifyInfo->Length >> DeviceExtension->LogicalBlockShift);

    //
    // Fill out the mrb
    //
 
    mrb->DataBuffer = NULL;
    mrb->TransferLength = 0;
    mrb->CompletionRoutine = MU_DiskIoComplete;
    mrb->TimeOutValue = MRB_CALC_VERIFY_TIMEOUT(verifyInfo->Length);
    mrb->Retries = MRB_MAXIMUM_RETRIES;
    mrb->Flags = MRB_FLAGS_NO_DATA_TRANSFER;
    
    //
    //  Fill out the CDB
    //

    RtlZeroMemory(&mrb->Cbw.Cdb, sizeof(CDB));
    mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_VERIFY;
    
    //
    // Move little endian values into CDB in big endian format.
    //

    mrb->Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(logicalBlockOffset);
    mrb->Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian(logicalBlockCount);

    //
    //  Submit the MRB
    //

    MU_fStartMrb(DeviceExtension);

    return;
}


VOID
MU_DiskReadComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        Completion routine for read requests.  Added so we can check for
        the corruption pattern at the start of each EMULATED_SECTOR.
--*/
{

    PUCHAR buffer = DeviceExtension->Mrb.DataBuffer;
    PUCHAR bufferEnd = DeviceExtension->Mrb.DataBuffer + DeviceExtension->Mrb.TransferLength;
    //Loop over the buffer checking the beginning of each emulated sector
    for(; buffer < bufferEnd; buffer += EMULATED_SECTOR_SIZE)
    {
        ULONG patternOffset = 0;
        //
        //  Loop as long as the pattern matches
        //
        while( ((PULONG)buffer)[patternOffset] == MU_CORRUPT_SECTOR_PATTERN[patternOffset])
        {
            //If we have reach the end of the pattern, then there is a match
            //we need to complete with an error
            if(++patternOffset == MU_CORRUPT_SECTOR_PATTERN_ULONG_COUNT)
            {
                ULONG oldProtect = MmQueryAddressProtect(buffer);
                ULONG newProtect = ((ULONG)-1);
                USB_DBG_WARN_PRINT(("MU_DiskReadComplete Corrupt Sector Found"));

                //Only change the status, if it was a success code.
                if(NT_SUCCESS(Status)) 
                {
                    Status = STATUS_DATA_ERROR;
                }

                //erase the pattern from the return buffer (if the user doesn't
                //check the error and reads it, then they may write and this
                //will make us return more problems.  Just nip it in the bud
                //here. Fill with "FAIL" a.k.a 'LIAF'.
                //
                // BTW, even though we read into it via DMA, if it is the filesystem
                // cache it may be marked PAGE_READONLY.  If so we need to
                // switch that off first, then switch it back on.
                if(PAGE_READONLY == ((PAGE_READONLY|PAGE_READWRITE)&oldProtect))
                {
                    newProtect = oldProtect; //Use the old protection as the base.
                    newProtect &= ~PAGE_READONLY; //clear readonly
                    newProtect |= PAGE_READWRITE; //set readwrite
	                MmSetAddressProtect(buffer, MU_CORRUPT_SECTOR_PATTERN_SIZE, newProtect);
                }
                
                while(patternOffset--)
                {
                    ((PULONG)buffer)[patternOffset] = 'LIAF';
                }
        
                if(((ULONG)-1) != newProtect)
                {
                    MmSetAddressProtect(buffer, MU_CORRUPT_SECTOR_PATTERN_SIZE, oldProtect);
                }
                break;
            }
        }
    }

    MU_DiskIoComplete(DeviceExtension, Status);
    return;
}


VOID
MU_DiskIoComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        General compeltion routine for MRB requests that require no post processing.
        The status is checked and the Irp is completed accordingly.  On success,
        Information is set to the length of the transfer, on failure it is set to
        zero.

    This is used as the completion for MU_fDiskVerify and MU_fDiskRead.  Unfortunately,
    it cannot be worked into the write state machine.
--*/
{
    DeviceExtension->PendingIrp->IoStatus.Status = Status;
    if(NT_ERROR(Status))
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        USB_DBG_WARN_PRINT(("MU_DiskIoComplete Transfer Failed"));
    } else
    {
        DeviceExtension->PendingIrp->IoStatus.Information = DeviceExtension->Mrb.TransferLength;
    }
    
    //
    //  Complete the request
    //

    MU_COMPLETE_REQUEST(DeviceExtension, DeviceExtension->PendingIrp, IO_NO_INCREMENT);
    
    //
    //  Start processing the next Irp.
    //
    IoStartNextPacket(DeviceExtension->DeviceObject);
}


VOID
FASTCALL
MU_fDiskReadWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
    Routine Description:
       Does the basic work of setting up a Read or Write to determine if
       a the operation may be performed, to calculate the logical block
       offset and count. On read submits the Mrb and sets MU_DiskIoComplete
       as the completion routine.  On write, it needs to worry about
       aligment issues and to submit the request to the MrbState machine.
--*/
{
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PUCHAR              virtualAddress = NULL;

    ULONG               byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart;
    ASSERT(0==irpStack->Parameters.Read.ByteOffset.HighPart);

    ULONG               transferLength = irpStack->Parameters.Read.Length;

    //
    //  Check the byteOffset and transferLength against the disk
    //  partition length, also double check that they are properly
    //  sector aligned.
    //
    if(
        (0!=byteOffset%EMULATED_SECTOR_SIZE) ||
        (0!=transferLength%EMULATED_SECTOR_SIZE) ||
        (irpStack->Parameters.Read.ByteOffset.QuadPart + transferLength) >
        DeviceExtension->PartitionLength.QuadPart)
    {
        USB_DBG_WARN_PRINT(("MU_fDiskReadWrite: failing transfer with illegal byte offset or length"));
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }

    //
    //  Check for Zero length transfer, just succeed these
    //

    else if (transferLength == 0)
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    //  Get the usable virtual address of the buffer to send,
    //  or receive data.
    //
    else
    {

        //
        //  SL_FSCACHE_REQUEST indicate that the transfer is to\from cached memory mapped
        //  by the buffer in the irpStack.
        //

        if(TEST_FLAG(irpStack->Flags,SL_FSCACHE_REQUEST))
        {
            virtualAddress = (PUCHAR) irpStack->Parameters.Read.CacheBuffer;

            ASSERT(virtualAddress != NULL);
        }
        else
        //
        //  SL_FSCACHE_REQUEST is not set.  The transfer is to\from the UserBuffer.
        //
        {
            virtualAddress = (PUCHAR) Irp->UserBuffer;

            ASSERT(virtualAddress != NULL);

            //
            //  Add the buffer offset to the address we were passed.
            //
            virtualAddress += irpStack->Parameters.Read.BufferOffset;
        }

        //
        //  For convience we reuse the BufferOffset to store
        //  the computed virtual address for later.
        //

        irpStack->Parameters.Read.BufferOffset = (ULONG) virtualAddress;
    }

    //
    //  If for some reason no transfer is required
    //  complete the Irp and start the next one.
    //

    if(NULL == virtualAddress)
    {
        Irp->IoStatus.Information = 0;
        MU_COMPLETE_REQUEST(DeviceExtension, Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceExtension->DeviceObject);
        return;
    }

    //
    //  Zero out the Cdb, we will start filling it out.
    //

    RtlZeroMemory(&DeviceExtension->Mrb.Cbw.Cdb, sizeof(CDB));
    
    //
    //  If this is a write then make then check for alignment,
    //  set flags and make appropriate adjustment.
    //

    if(IRP_MJ_WRITE == irpStack->MajorFunction)
    {

        //
        //  Clear the write state machine has flags
        //

        CLEAR_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FLAGS);

        //
        //  Adjust the starting offset alignment.
        //

        if(byteOffset%DeviceExtension->MediaBlockSize)
        {
            ULONG initialLength = DeviceExtension->MediaBlockSize - (byteOffset%DeviceExtension->MediaBlockSize);
            DeviceExtension->InitialWriteByteCount = initialLength;
            
            // Check for a Partial Middle Write (i.e. a write
            // which starts in the middle of a media block and
            // and ends before the end of the same media block).
            if(initialLength > transferLength)
            {
                //Set the middle portion flag 
                SET_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_MIDDLE_PORTION);
                //Fix up the FinalWriteByteCount the way the middle state machine likes it.
                DeviceExtension->FinalWriteByteCount = initialLength - transferLength;
                //Start the partial write state machine.
                MU_DiskStartPartialWrite(DeviceExtension, STATUS_SUCCESS);
                return;
            }
            byteOffset += initialLength;
            virtualAddress += initialLength;
            transferLength -= initialLength;
            SET_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_INITIAL_PORTION);
            USB_DBG_TRACE_PRINT(("Write has initial portion."));
        }

        //
        //  Adjust the ending alignment
        //
        if(transferLength%DeviceExtension->MediaBlockSize)
        {
            DeviceExtension->FinalWriteByteCount = transferLength%DeviceExtension->MediaBlockSize;
            transferLength -= DeviceExtension->FinalWriteByteCount;
            SET_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FINAL_PORTION);
            USB_DBG_TRACE_PRINT(("Write has final portion."));
        }

        //
        //  If there is no whole portion, then jump into partial
        //  transfer state machine.
        //

        if(0 == transferLength)
        {
           MU_DiskStartPartialWrite(DeviceExtension, STATUS_SUCCESS);
           return;
        }

        USB_DBG_TRACE_PRINT(("Write has whole portion."));
        //
        //  If there were alignment adjustments then set the completion
        //  routine to MU_DiskStartPartialWrite, otherwise
        //  it is a one step write and we can use MU_DiskIoComplete.
        //

        if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FLAGS))
        {
            DeviceExtension->Mrb.CompletionRoutine = MU_DiskStartPartialWrite;        
        } else
        {
            DeviceExtension->Mrb.CompletionRoutine = MU_DiskIoComplete;
        }

        //
        //  Setup the parts of the MRB that indicate a write request
        //

        DeviceExtension->Mrb.Flags = MRB_FLAGS_DATA_OUT;
        DeviceExtension->Mrb.Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;

    } else
    //
    //  This is a read request, setup the parts of the MRB
    //  that indicate a read request
    //
    {
        DeviceExtension->Mrb.CompletionRoutine = MU_DiskReadComplete;
        DeviceExtension->Mrb.Flags = MRB_FLAGS_DATA_IN;
        DeviceExtension->Mrb.Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;
    }
    
    //
    //  Setup the rest of the MRB
    //

    DeviceExtension->Mrb.DataBuffer = virtualAddress;
    DeviceExtension->Mrb.TransferLength = transferLength;
    DeviceExtension->Mrb.TimeOutValue = MRB_STANDARD_TIMEOUT;
    DeviceExtension->Mrb.Retries = MRB_MAXIMUM_RETRIES;

    //
    //  Set the block information in the CDB
    //
    DeviceExtension->Mrb.Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(byteOffset >> DeviceExtension->LogicalBlockShift);
    DeviceExtension->Mrb.Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian((USHORT)(transferLength >> DeviceExtension->LogicalBlockShift));

    //
    //  Submit the MRB
    //

    MU_fStartMrb(DeviceExtension);
}

VOID
MU_DiskStartPartialWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        This routine is called to begin writes of partial media blocks.  It can
        be called directly by MU_fDiskReadWrite if there is no contiguous portion
        of the write or it is called as the MRB completion routine for the
        contiguous portion.  Either way, it is called at DPC level.

        Partial Write requests use a global write buffer.  As such they must be
        serialized system wide across all MUs.  This routine either begins
        the partial transfer, or it inserts the request into the queue.
--*/
{
    PIRP irp = DeviceExtension->PendingIrp;
    
    //
    //  Clear the write state machine flags
    //
    CLEAR_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_BITS);

    //
    //  Make sure that the previous stage succeeded, if not
    //  just fail the Irp here.
    //
    if(NT_ERROR(Status))
    {
       irp->IoStatus.Status = Status;
       irp->IoStatus.Information = 0;
       MU_COMPLETE_REQUEST(DeviceExtension, irp, IO_NO_INCREMENT);
       IoStartNextPacket(DeviceExtension->DeviceObject);
       return;
    }

    //
    //  We can setup the common section of the MRB here
    //
    
    PMU_REQUEST_BLOCK mrb = &DeviceExtension->Mrb;
    RtlZeroMemory(&mrb->Cbw.Cdb, sizeof(CDB));
    mrb->TimeOutValue = MRB_STANDARD_TIMEOUT;
    mrb->Retries = MRB_MAXIMUM_RETRIES;

    // Choose the correct state machine, and initialize to start.
    if(TEST_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_HAS_MIDDLE_PORTION))
    {
        mrb->CompletionRoutine = MU_DiskWriteBuildMiddlePartialRequest;
        SET_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_MIDDLE_START);
    } else
    {
        mrb->CompletionRoutine = MU_DiskWriteBuildPartialRequest;
        SET_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_START);
    }

    //
    // see if the list of pending partial requests is empty
    //

    if (IsListEmpty(&MU_DriverExtension.PartialRequestQueue))
    {
        //
        // process this one immediately
        //

        InsertHeadList(&MU_DriverExtension.PartialRequestQueue,
                       &irp->Tail.Overlay.ListEntry);

        USB_DBG_TRACE_PRINT(("StartPartialRequest: Queuing Irp at the head %x, flink %x, blink %x",
                   irp,
                   MU_DriverExtension.PartialRequestQueue.Flink,
                   MU_DriverExtension.PartialRequestQueue.Blink));
        //
        //  Start the request, call through the mrb->CompletionRoutine
        //  pointer so as to start the proper state machine.
        //

        mrb->CompletionRoutine(DeviceExtension, STATUS_SUCCESS);
        return;
       
    } else {

        ASSERT(MU_DriverExtension.PartialRequestQueue.Flink != (PLIST_ENTRY)&irp->Tail.Overlay.ListEntry);

        //
        // queue this request...
        //

        InsertTailList(&MU_DriverExtension.PartialRequestQueue, &irp->Tail.Overlay.ListEntry);

        USB_DBG_TRACE_PRINT(("StartPartialRequest: Queuing Irp %x, f %x, b %x",
                       irp,
                       MU_DriverExtension.PartialRequestQueue.Flink,
                       MU_DriverExtension.PartialRequestQueue.Blink));
    }
}

VOID
MU_DiskWriteBuildPartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        This routine is the heart of MU write state machine.  It is its own completion routine
        routine.   It builds and submits MRBs.  It works as follows:

        1) Increment the write state to the next state needed based on the DF_WRITE_HAS_XXX
        flags.

        2) switch the new state, and build an appriopriate MRB.

        3) submit the MRB.

        When the last required stage completes:
        
        4) Complete the Irp.

        5) Call IoStartNextPacket for current device

        5) Continue with the next pending partial write (for a different device)

   Note:
    There are fields of the MRB that are NOT setup here:  


    These are the same for every stage and MU_DiskStartPartialWrite before the partial portion of the request
    is queued.

--*/
{
        PIRP irp = DeviceExtension->PendingIrp;
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
        ULONG  byteOffset;
        ULONG  writeState = DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS;

        if(NT_SUCCESS(Status))
        {
            //
            // Increment to the next state.  
            //
            writeState += MU_WRITE_STATE_INCREMENT;
        
            //
            //  If the current stage is an initial read, and an initial
            //  read is not required, skip to final read.
            //
            if(MU_WRITE_STATE_INITIAL_READ == writeState)
            {
                if(!TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_INITIAL_PORTION))
                {
                    writeState = MU_WRITE_STATE_FINAL_READ;
                }
            }

            //
            //  If the current stage is a final read, and a final
            //  read is not required, skip to done.
            //

            if(MU_WRITE_STATE_FINAL_READ == writeState)
            {
                if(!TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FINAL_PORTION))
                {
                    writeState = MU_WRITE_STATE_DONE;
                }
            }
        } else
        //
        //  On any read errors in the state machine
        //  we need to modify the buffer with a bad
        //  sector pattern pattern and proceed to
        //  the write stage anyway
        //
        {
            //
            if(
                ( (MU_WRITE_STATE_INITIAL_READ == writeState)
                  ||(MU_WRITE_STATE_FINAL_READ == writeState) ) &&
                (STATUS_DATA_ERROR == Status)
            )
            {
                MU_fMarkWriteBufferCorrupt(&DeviceExtension->Mrb);
                // Go on to the next phase
                Status = STATUS_SUCCESS;
                writeState += MU_WRITE_STATE_INCREMENT;
            } else
            //
            //  If the write failed during a write phase, or
            //  for a reason other than a STATUS_DATA_ERROR
            //  (failed CSW), then just keep the error go to
            //  the done state, which will complete the IRP
            //  with the error.
            //
            {
                writeState = MU_WRITE_STATE_DONE;
            }
        }

        //
        //  Write the writeState back
        //
        CLEAR_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_BITS);
        SET_FLAG(DeviceExtension->DeviceFlags,writeState);
        
        //
        //  Start working on the mrb.
        //
        PMU_REQUEST_BLOCK mrb = &DeviceExtension->Mrb;
        
        //
        //  switch on the stage we need to program
        //
        switch(writeState)
        {
          case MU_WRITE_STATE_INITIAL_READ:
            USB_DBG_TRACE_PRINT(("Starting initial portion."));
            
            //
            //  Read the portion of the first block prior to the start of the
            //  requested write.
            //

            mrb->DataBuffer = MU_DriverExtension.WriteBuffer;
            mrb->TransferLength = DeviceExtension->MediaBlockSize - DeviceExtension->InitialWriteByteCount;
            mrb->Flags = MRB_FLAGS_DATA_IN;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;

            //
            //  The byteOffset is transfer length bytes behind the original byteOffset of the
            //  write request
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->TransferLength;
            

            break;
          case MU_WRITE_STATE_INITIAL_WRITE:

            //
            //  Write one media block size out.  DataBuffer points to the user's
            //  data we are writing.

            //
            //  Setup MRB_FLAGS_SPLIT_WRITE feature, and its parameters: UserStartOffset,
            //  UserEndOffset so that MRB state machine knows to get the remaining data
            //  from the WriteBuffer.
            //
            mrb->Flags = MRB_FLAGS_DATA_OUT | MRB_FLAGS_SPLIT_WRITE;
            mrb->UserStartOffset = mrb->TransferLength;  //the UserStartOffset is the length we just read.
            mrb->UserEndOffset = DeviceExtension->MediaBlockSize; //The UserEndOffset is the end of the block

            mrb->DataBuffer = (PUCHAR)irpStack->Parameters.Read.BufferOffset;
            mrb->TransferLength = DeviceExtension->MediaBlockSize;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;
            
            //
            //  The byteOffset is the UserStartOffset before the original write request byteOffset
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->UserStartOffset;
            break;

          case MU_WRITE_STATE_FINAL_READ:
            
            USB_DBG_TRACE_PRINT(("Starting final portion."));
            
            //
            //  Read the the end of the block behind the final write byte count
            //
            
            mrb->DataBuffer = MU_DriverExtension.WriteBuffer;
            mrb->TransferLength = DeviceExtension->MediaBlockSize - DeviceExtension->FinalWriteByteCount;
            mrb->Flags = MRB_FLAGS_DATA_IN;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;
            
            //
            //  The logicalBlockAddress should be the sector right after the length that
            //  we really want to write to.
            //
            //
            //  The byteOffset is the end of the original write request.
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart +
                         irpStack->Parameters.Read.Length;

            break;
          case MU_WRITE_STATE_FINAL_WRITE:

            //
            //  Write one media block size out.  DataBuffer points to the user's buffer.
            //
            
            //
            //  Setup MRB_FLAGS_SPLIT_WRITE feature, and its parameters: UserStartOffset,
            //  UserEndOffset so that MRB state machine knows to get the remaining data
            //  from the WriteBuffer.
            //
            mrb->Flags = MRB_FLAGS_DATA_OUT | MRB_FLAGS_SPLIT_WRITE;
            mrb->UserStartOffset = 0;  //The UserStartOffset is the beginning of the write.
            mrb->UserEndOffset = DeviceExtension->FinalWriteByteCount; //The UserEndOffset is the size of the user data
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;

            //
            //  The user data comes from the end of the user buffer.
            //
            mrb->DataBuffer = (PUCHAR) (irpStack->Parameters.Read.BufferOffset +
                                        irpStack->Parameters.Read.Length -
                                        DeviceExtension->FinalWriteByteCount);
            mrb->TransferLength = DeviceExtension->MediaBlockSize;

            //
            //  The byte offset is the length of the user buffer, DeviceExtension->FinalWriteByteCount
            //  before the end of the of the original request
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart +
                         irpStack->Parameters.Read.Length -
                         DeviceExtension->FinalWriteByteCount;

            break;
          case MU_WRITE_STATE_DONE:

            //*
            //* This case can be reached due to an error or because
            //* the transfer is over, either way the Status is correct
            //* complete the Irp with that status.
            //

            //
            //  Clear the write state flags.
            //

            CLEAR_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_STATE_BITS);

            //
            // Remove the IRP we are working on from the global queue.
            //

            ASSERT(!IsListEmpty(&MU_DriverExtension.PartialRequestQueue));
            RemoveHeadList(&MU_DriverExtension.PartialRequestQueue);
            
            //
            //  Complete the write Irp
            //

            irp->IoStatus.Information = irpStack->Parameters.Read.Length;
            irp->IoStatus.Status = Status;
            MU_COMPLETE_REQUEST(DeviceExtension, irp, IO_NO_INCREMENT);

            //
            //  Start the next partial request.
            //  NOTE: that this request could not be
            //  for the same device we just finished with.
            //
            MU_DiskWriteStartNextPartialRequest();

            //
            //  Start the next I/O for the current device.
            //
            IoStartNextPacket(DeviceExtension->DeviceObject);

            return;

          default:

            //
            //  Reaching here is a bug in the write state machine.
            //

            ASSERT(FALSE);
            return; //To avoid a compiler warning, without extra code.
        }

        //
        //  Do the endian conversions to plug the LBA and Block Counts
        //  into the Cdb structure.
        //

        mrb->Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(byteOffset >> DeviceExtension->LogicalBlockShift);
        mrb->Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian((USHORT)(mrb->TransferLength >> DeviceExtension->LogicalBlockShift));
        
        //
        //  Start the MRB
        //

        MU_fStartMrb(DeviceExtension);

        return;
}

VOID
MU_DiskWriteBuildMiddlePartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    This routine is an alternative MU write state machine.  It is its own completion routine
    routine.   It handles the special case of a write to a "middle" partial request, that is a request
    that starts unaligned on the media block boundary and ends unaligned on the same media block.

    This state machine breaks a single media block up as follows:

    1) Read the portion of the media block before user's buffer into the WriteBuffer.
    2) Read the portion of the media block after the user's buffer into the WriteBuffer
       after the data read in 1).
    3) Write, use the MRB_FLAG_SPLIT_WRITE flag, to glue it all together properly.

    Only one instance of this state machine or the MU_DiskWriteBuildPartialRequest state machine
    can be running on the system globally.  Thus these routine work in tandem.

    NOTE: InitialWriteByteCount and FinalWriteByteCount were really named for the other
    state machine.  The interpretation here is as follows:
        InitialWriteByteCount - The length from offset of the beginning of the user buffer to
                                the end of the media block.
        FinalWriteByteCount - The length from offset of the end of the user buffer to
                              the end of the media block. (This is actually set after MU_fDiskReadWrite
                              knows the write will end up here).

--*/
{

        PIRP irp = DeviceExtension->PendingIrp;
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
        ULONG  byteOffset;
        ULONG  writeState = DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS;

        if(NT_SUCCESS(Status))
        {
            //
            // Increment to the next state.  
            //
            writeState += MU_WRITE_STATE_INCREMENT;
        } else
        //
        //  Handle errors
        //
        {

            //
            //  If the error occured during either of the read
            //  states and it was STATUS_DATA_ERROR, mark the
            //  sector as corrupt and continue
            //
            if(
                ( (MU_WRITE_STATE_MIDDLE_READ_BEFORE == writeState)
                  ||(MU_WRITE_STATE_MIDDLE_READ_AFTER == writeState) ) &&
                (STATUS_DATA_ERROR == Status)
            )
            {
                MU_fMarkWriteBufferCorrupt(&DeviceExtension->Mrb);
                // Go on to the next phase
                Status = STATUS_SUCCESS;
                writeState += MU_WRITE_STATE_INCREMENT;
            } else
            //
            //  If the write failed during a write phase, or
            //  for a reason other than a STATUS_DATA_ERROR
            //  (failed CSW), then just keep the error and go to
            //  the done state, which will complete the IRP
            //  with the error.
            //
            {
                writeState = MU_WRITE_STATE_MIDDLE_DONE;
            }
        }

        //
        //  Write the writeState back
        //
        CLEAR_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_BITS);
        SET_FLAG(DeviceExtension->DeviceFlags,writeState);
        
        //
        //  Start working on the mrb.
        //
        PMU_REQUEST_BLOCK mrb = &DeviceExtension->Mrb;
        
        //
        //  switch on the stage we need to program
        //
        switch(writeState)
        {
      
          case MU_WRITE_STATE_MIDDLE_READ_BEFORE:
                
            //
            //  Read operation goes in
            //
            mrb->Flags = MRB_FLAGS_DATA_IN;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;
            //
            //  Read the length of the media block before the requested read
            //  into the start of the WriteBuffer.
            //
            mrb->DataBuffer = MU_DriverExtension.WriteBuffer;
            mrb->TransferLength = DeviceExtension->MediaBlockSize - DeviceExtension->InitialWriteByteCount;
            //
            //  byteOffset start transferLength before the requested write.
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->TransferLength;
            break;

          case MU_WRITE_STATE_MIDDLE_READ_AFTER:
            // Still a read since the last step.

            // Pickup read into the buffer where we left off in the last step, and
            // read until the end of the block
            mrb->DataBuffer = MU_DriverExtension.WriteBuffer + mrb->TransferLength;
            mrb->TransferLength = DeviceExtension->FinalWriteByteCount;
            //  
            //  The byteOffset starts right after the original requested write.
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart+
                                   irpStack->Parameters.Read.Length;

            break;

          case MU_WRITE_STATE_MIDDLE_WRITE:
            //
            //  Switch to a write operation and use MRB_FLAGS_SPLIT_WRITE
            //  feature.
            //
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;
            mrb->Flags = MRB_FLAGS_DATA_OUT | MRB_FLAGS_SPLIT_WRITE;

            //Set the offsets for the split write
            mrb->UserStartOffset = DeviceExtension->MediaBlockSize - DeviceExtension->InitialWriteByteCount;
            mrb->UserEndOffset = DeviceExtension->MediaBlockSize - DeviceExtension->FinalWriteByteCount;

            //The data buffer is the users data buffer, the transfer length
            //is a full media block
            mrb->DataBuffer = (PUCHAR)irpStack->Parameters.Read.BufferOffset;
            mrb->TransferLength = DeviceExtension->MediaBlockSize;

            //The byteOffste is StartOffset before the requested write.
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->UserStartOffset;
            break;

          case MU_WRITE_STATE_MIDDLE_DONE:       
            //*
            //* This case can be reached due to an error or because
            //* the transfer is over, either way the Status is correct
            //* complete the Irp with that status.
            //

            //
            //  Clear the write state flags.
            //

            CLEAR_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_STATE_BITS);

            //
            // Remove the IRP we are working on from the global queue.
            //

            ASSERT(!IsListEmpty(&MU_DriverExtension.PartialRequestQueue));
            RemoveHeadList(&MU_DriverExtension.PartialRequestQueue);
            
            //
            //  Complete the write Irp
            //

            irp->IoStatus.Information = irpStack->Parameters.Read.Length;
            irp->IoStatus.Status = Status;
            MU_COMPLETE_REQUEST(DeviceExtension, irp, IO_NO_INCREMENT);

            //
            //  Start the next partial request.
            //  NOTE: that this request could not be
            //  for the same device we just finished with.
            //
            MU_DiskWriteStartNextPartialRequest();

            //
            //  Start the next I/O for the current device.
            //
            IoStartNextPacket(DeviceExtension->DeviceObject);

            return;

          default:

            //
            //  Reaching here is a bug in the write state machine.
            //

            ASSERT(FALSE);
            return; //To avoid a compiler warning, without extra code.
        }
        
        //
        //  Do the endian conversions to plug the LBA and Block Counts
        //  into the Cdb structure.
        //

        mrb->Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(byteOffset >> DeviceExtension->LogicalBlockShift);
        mrb->Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian((USHORT)(mrb->TransferLength >> DeviceExtension->LogicalBlockShift));

        //
        //  Start the MRB
        //

        MU_fStartMrb(DeviceExtension);

        return;
}

VOID MU_DiskWriteStartNextPartialRequest()
/*++
  Routine Description:
    When either of the partial write state machines completes
    it calls this function to start the next pending partial
    on the correct state machine.
--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PMU_DEVICE_EXTENSION deviceExtension;

    if(!IsListEmpty(&MU_DriverExtension.PartialRequestQueue))
    {
        //
        //  Peek at head of list to get IRP, but don't
        //  dequeue it.
        //
        irp = CONTAINING_RECORD(
               MU_DriverExtension.PartialRequestQueue.Flink,
               IRP,
               Tail.Overlay.ListEntry
               );

        //
        //  We can find the device object in the stack location
        //  for the irp.  From their we get the device extension
        //  to start the irp on the proper partial write state machine
        //
        irpStack = IoGetCurrentIrpStackLocation(irp);
        deviceExtension = (PMU_DEVICE_EXTENSION) irpStack->DeviceObject->DeviceExtension;
        deviceExtension->Mrb.CompletionRoutine(deviceExtension,STATUS_SUCCESS);
    }
};



VOID
FASTCALL
MU_fMarkWriteBufferCorrupt(
    IN PMU_REQUEST_BLOCK Mrb
    )
/*++
    Routine Description:
        Marks up the WriteBuffer (used for partial write
        operations) with a pattern marking corruption at the
        beginning of each emulated sector.  This routine
        is called when the read phase of a partial write fails
        with a STATUS_DATA_ERROR (i.e. the device returned
        an error in the CSW).
--*/
{
    //
    //  Write the corrupt sector pattern at the beginning of each 4k of the 
    //  the data buffer in the MRB (should point somewhere into global write
    //  buffer).
    //
    for(ULONG Offset = 0; Offset < Mrb->TransferLength; Offset += EMULATED_SECTOR_SIZE)
    {
        RtlCopyMemory(
            Mrb->DataBuffer+Offset,
            MU_CORRUPT_SECTOR_PATTERN,
            MU_CORRUPT_SECTOR_PATTERN_SIZE
            );
    }
}


//*
//* These IOCTL are for running diagnostics on Memory Units.  The production line tests application
//* is the intended client, but there may be others.  A special compile switch is required
//* to build this.
//*
//*
#ifdef MU_DIAGNOSTIC_IOCTLS

NTSTATUS
FASTCALL         
MU_fVscCommand(
 IN PMU_DEVICE_EXTENSION DeviceExtension,
 IN PIRP Irp,
 IN BYTE bRequest,
 IN ULONG ulOutputSize
 )
/*++
    Routine Description:
       Sets up a request to get the Bad Block Table from an MU.
       
    Arguments:
        Irp->UserBuffer should have the output buffer for the
        Bad Block Table
        
        irpStack->DeviceIoControl.OutputBufferLength should be greater
        than or equal to MU_VSD_BAD_BLOCK_TABLE_SIZE
--*/
{
    NTSTATUS status = STATUS_PENDING;
    if(DeviceExtension->MuInstance)
    {
        PURB urb = (PURB)RTL_ALLOCATE_HEAP(sizeof(URB));
        if(urb)
        {
            //
            //  Build VSC request
            //
            
            USB_BUILD_CONTROL_TRANSFER(
                &urb->ControlTransfer,
                NULL,
                Irp->UserBuffer,
                ulOutputSize,
                USB_TRANSFER_DIRECTION_IN,
                MU_VscComplete,
                DeviceExtension,
                FALSE,
                USB_DEVICE_TO_HOST|USB_CLASS_COMMAND|USB_COMMAND_TO_INTERFACE,
                bRequest,
                0,
                DeviceExtension->MuInstance->InterfaceNumber,
                ulOutputSize
                );
            //
            //  Submit the request
            //

            DeviceExtension->MuInstance->Device->SubmitRequest(urb);
        } else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else
    {
        status = STATUS_DEVICE_NOT_CONNECTED;
    }

    return status;
}

VOID
MU_VscComplete(
    IN PURB   Urb,
    IN PVOID  Context
    )
/*++
    Routine Description:
       Completion routine for all VSC, just fills out
       the Irp.IoStatus fields and completes the IRP.
--*/
{

    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION)Context;
    PIRP irp = deviceExtension->PendingIrp;

    irp->IoStatus.Status = IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status);
    irp->IoStatus.Information = Urb->ControlTransfer.TransferBufferLength;

    //
    //  Free the URB
    //
    RTL_FREE_HEAP(Urb);

     //
    //  Complete the Irp
    //

    MU_COMPLETE_REQUEST(deviceExtension, irp, IO_NO_INCREMENT);
    
    //
    //  Start processing the next Irp.
    //

    IoStartNextPacket(deviceExtension->DeviceObject);

    return;
}

#endif


//*
//* These routines are called via macros that should only call them in debug
//* builds.
//*

#if DBG

VOID
MUDebugWatchdogDpcRoutine(
    PKDPC,
    PMU_DEVICE_EXTENSION DeviceExtension,
    PVOID,
    PVOID
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(DeviceExtension->PendingIrp);
    //
    //  This gets hit when an IRP hangs.
    //  Spew as much useful information
    //  The call KeDebugBreak;
    //
    DbgPrint("MU DRIVER IRP WATCHDOG TIMER HAS EXPIRED. Please report this hang.\n");
    DbgPrint("MU Device Extension: 0x%0.8x, Irp: 0x%0.8x\n", DeviceExtension, DeviceExtension->PendingIrp);

    // Print Irp Information
    switch (irpStack->MajorFunction)
    {
      case IRP_MJ_DEVICE_CONTROL:
        switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_DISK_GET_DRIVE_GEOMETRY:
                DbgPrint("IOCTL_DISK_GET_DRIVE_GEOMETRY\n");
                break;
            case IOCTL_DISK_GET_PARTITION_INFO:
                DbgPrint("IOCTL_DISK_GET_PARTITION_INFO\n");
                break;
            case IOCTL_DISK_VERIFY:
                DbgPrint("IOCTL_DISK_VERIFY: Offset = 0x%0.8x, Length = 0x%0.8x\n",
                        irpStack->Parameters.Read.ByteOffset.LowPart,irpStack->Parameters.Read.Length);
                break;
            #ifdef MU_DIAGNOSTIC_IOCTLS
            case MU_IOCTL_GET_BAD_BLOCK_TABLE:
                DbgPrint("MU_IOCTL_GET_BAD_BLOCK_TABLE\n");
                break;
            case MU_IOCTL_MEMORY_TEST:
                DbgPrint("MU_IOCTL_MEMORY_TEST\n");
                break;
            #endif
            default:
                DbgPrint("IOCTL = 0x%0.8x\n", irpStack->Parameters.DeviceIoControl.IoControlCode);
                break;
        }
        break;
      case IRP_MJ_WRITE:
        DbgPrint("Write: Buffer = 0x%0.8x, Offset = 0x%0.8x, Length = 0x%0.8x\n",
            irpStack->Parameters.Read.BufferOffset,
            irpStack->Parameters.Read.ByteOffset.LowPart,
            irpStack->Parameters.Read.Length
            );
        if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_MIDDLE_PORTION))
        {
            DbgPrint("Middle Partial Write:");
            switch(DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS)
            {
                case MU_WRITE_STATE_MIDDLE_START:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_START\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_READ_BEFORE:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_READ_BEFORE\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_READ_AFTER:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_READ_AFTER\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_WRITE:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_WRITE\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_DONE:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_DONE\n");
                    break;
                default:
                    break;
            }
        } else
        {
            if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_INITIAL_PORTION))
                DbgPrint("Start on a block aligned.\n");
            if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FINAL_PORTION))
                DbgPrint("End on a block aligned.\n");
            DbgPrint("Partial Write State:");
            switch(DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS)
            {
                case MU_WRITE_STATE_START:
                    DbgPrint("MU_WRITE_STATE_START\n");
                    break;
                case MU_WRITE_STATE_INITIAL_READ:
                    DbgPrint("MU_WRITE_STATE_INITIAL_READ\n");
                    break;
                case MU_WRITE_STATE_INITIAL_WRITE:
                    DbgPrint("MU_WRITE_STATE_INITIAL_WRITE\n");
                    break;
                case MU_WRITE_STATE_FINAL_READ:
                    DbgPrint("MU_WRITE_STATE_FINAL_READ\n");
                    break;
                case MU_WRITE_STATE_FINAL_WRITE:
                    DbgPrint("MU_WRITE_STATE_FINAL_WRITE\n");
                case MU_WRITE_STATE_DONE:
                    DbgPrint("MU_WRITE_STATE_DONE\n");
                default:
                    break;
            }
        }
        break;
      case IRP_MJ_READ:
        DbgPrint("Read: Buffer = 0x%0.8x, Offset = 0x%0.8x, Length = 0x%0.8x\n",
            irpStack->Parameters.Read.BufferOffset,
            irpStack->Parameters.Read.ByteOffset.LowPart,
            irpStack->Parameters.Read.Length
            );
        break;
      default:
        DbgPrint("Unknown Request: 0x%0.8x\n", irpStack->MajorFunction);
    }
    //Now print out MRB state machine information
    DbgPrint("MU Request State machine flags:\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
      DbgPrint("   DF_MRB_TIMER_RUNNING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING))
      DbgPrint("   DF_PRIMARY_URB_PENDING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_SECONDARY_URB_PENDING))
      DbgPrint("   DF_SECONDARY_URB_PENDING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_ERROR_PENDING))
      DbgPrint("   DF_ERROR_PENDING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP1))
      DbgPrint("   DF_RESET_STEP1\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP2))
      DbgPrint("   DF_RESET_STEP2\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP3))
      DbgPrint("   DF_RESET_STEP3\n");

    // Print out state machine info
    DbgPrint("Primary Urb @0x%0.8x, Secondary Urb @0x%0.8x\n", &DeviceExtension->Urb, &DeviceExtension->BulkUrbSecondary);
    //Break into debugger
    DbgBreakPoint();
}


VOID
MUDebugInitWatchDogParameters(
    PMU_DEVICE_EXTENSION DeviceExtension
    )
{
    KeInitializeTimer(&DeviceExtension->DbgIrpTimer);
    KeInitializeDpc(
        &DeviceExtension->DbgIrpTimeoutDpc, 
        (PKDEFERRED_ROUTINE)MUDebugWatchdogDpcRoutine,
        (PVOID)DeviceExtension
        );
}

VOID 
MuDebugSetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    )
{
    //If the timer is running cancel it, it should not have been
    //running so ASSERT that it wasn't.
    LARGE_INTEGER timeoutTime;
    
    BOOL fWasSet = KeCancelTimer(&DeviceExtension->DbgIrpTimer);
    ASSERT(!fWasSet);
    
    
    //
    //  GEt the stack location
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(DeviceExtension->PendingIrp);

    //
    //  Based on the IRP, guess how long this should take, in ms
    //  (we will multiple accordingly after the switch statements)
    //
    switch (irpStack->MajorFunction)
    {
      case IRP_MJ_DEVICE_CONTROL:
        switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            case IOCTL_DISK_GET_PARTITION_INFO:
                timeoutTime.QuadPart = 2000;  // 2 second
                break;
            case IOCTL_DISK_VERIFY:
                timeoutTime.QuadPart = irpStack->Parameters.Read.Length; //assume 25k verified per second
                timeoutTime.QuadPart /= 25;
                timeoutTime.QuadPart += 4000; //add 4 seconds for overhead
                break;
            #ifdef MU_DIAGNOSTIC_IOCTLS
            case MU_IOCTL_GET_BAD_BLOCK_TABLE:
                timeoutTime.QuadPart = 4000; // 4 seconds
                break;
            case MU_IOCTL_MEMORY_TEST:
                timeoutTime.QuadPart = 60000; //1 minute
                break;
            #endif
            default:
                timeoutTime.QuadPart = 10000; //10 seconds for anything else (there are none at this time)
        }
        break;
      case IRP_MJ_WRITE:
        timeoutTime.QuadPart = irpStack->Parameters.Read.Length; //assume 25k written per second
        timeoutTime.QuadPart /= 25;
        timeoutTime.QuadPart += 4000; //add 4 seconds for overhead
        break;
      case IRP_MJ_READ:
        timeoutTime.QuadPart = irpStack->Parameters.Read.Length; //assume 50k read per second
        timeoutTime.QuadPart /= 50;
        timeoutTime.QuadPart += 4000; //add 4 seconds for overhead
        break;
      default:
        timeoutTime.QuadPart = 10000; // 10 seconds in all other cases, actually there shouldn't be any.
    }
    
    //Convert from milliseconds to relative .1 microsecond units.
    timeoutTime.QuadPart *= -10000;
    DeviceExtension->DbgIrpTimeoutTime.QuadPart = timeoutTime.QuadPart;
    //Set the timer running
    KeSetTimer(&DeviceExtension->DbgIrpTimer, timeoutTime, &DeviceExtension->DbgIrpTimeoutDpc);
}

VOID 
MuDebugPetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    )
{
    KeSetTimer(&DeviceExtension->DbgIrpTimer, DeviceExtension->DbgIrpTimeoutTime, &DeviceExtension->DbgIrpTimeoutDpc);
}
 

VOID 
MuDebugCompleteRequest(
    PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    CCHAR PriorityBoost
    )
{
    
    BOOL fWasSet = KeCancelTimer(&DeviceExtension->DbgIrpTimer);
    ASSERT(fWasSet);
    IoCompleteRequest(Irp, PriorityBoost);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mu\rbc.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    rbc.h

Abstract:

    This was scsi.h from the Windows 2000 tree.  Our Xbox MU protocol is an extreme subset of the
    SCSI commands.  Additionally, we are packing a little extra information into the READ_CAPACITY
    command than is specified in the RBC specification.  Not really an issue, since do not need to
    be SCSI compatible anyway.

    So this file is paired don't to have only relevant definitions

Authors:

Revision History:

--*/
#ifndef __RBC_H__
#define __RBC_H__

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#include <pshpack1.h>
typedef union _CDB {
    
    //
    // Standard 10-byte CDB
    //

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        union {
            struct {
                UCHAR LogicalBlockByte0;
                UCHAR LogicalBlockByte1;
                UCHAR LogicalBlockByte2;
                UCHAR LogicalBlockByte3;
            };
            ULONG LogicalBlock;
        };
        UCHAR Reserved2;
        union {
            struct {
                UCHAR TransferBlocksMsb;
                UCHAR TransferBlocksLsb;
            };
            USHORT TransferBlocks;
        };
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Access as array of ULONGS or BYTES
    //

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#include <poppack.h>

//
// SCSI CDB operation codes
//

#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_VERIFY              0x2F

//
// Read Capacity Data - returned in Big Endian format
//
// (CAVEAT! - this is not the structure defined by SCSI!!!)
// We added the LogicalBlocKPerMediaBlock by carving away
// 16 bits 

typedef struct _READ_CAPACITY_DATA {
    ULONG  LogicalBlockAddress;
    USHORT LogicalBlocksPerMediaBlock; 
    USHORT BytesPerLogicalBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

#endif // !defined __RBC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\kdexts\usb\usbkdx.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name: 

    usbkdx.cpp

Abstract:

    Debugger extension for the XBox USB stack

Author:

    Josh Poley (jpoley)

Revision History:


USB Globals:
    ohcd\isr.c
        int IsrEntryCount=0;

    xid\xid.cpp
        XID_GLOBALS XID_Globals;
        USB_PNP_CLASS_DRIVER_DESCRIPTION GLOBAL_ClassDescription
        USB_PNP_DEVICE_TYPE_DESCRIPTION GLOBAL_DeviceTypes[XINPUT_DEVTYPE_COUNT];

    usbd\usbd.cpp
        UCHAR                    GLOBAL_HostControllerCount;
        PDRIVER_OBJECT           GLOBAL_DriverObject;
        XAPI_NOTIFICATION_SOURCE GLOBAL_NotificationSource;

    usbd\tree.cpp
        CDeviceTree g_DeviceTree;

    usbd\notify.cpp
        USBD_NOTIFICATIONS g_Notifications={0};

    usbpnp\pnp.cpp
        PFNUSBHUB_ResetHubPort				g_ResetRoutine = NULL;
        PUSB_PNP_CLASS_DRIVER_DESCRIPTION	g_FirstClassDriver = NULL;
        BOOLEAN								g_BaseDriverCalledYet = FALSE;

    usbhub\hub.cpp
        USBHUB_INFO						 GLOBAL_HubInfo;
        USBHUB_ENUM_BLOCK				 GLOBAL_HubEnum;
        USB_PNP_CLASS_DRIVER_DESCRIPTION GLOBAL_ClassDescription;

--*/

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <imagehlp.h>

#include <memory.h>
#pragma hdrstop

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#include <ntverp.h>
#include <imagehlp.h>

//
// include the necessary USB headers
//
#include "usb.h"
#include "urb.h"
//#include <xusbenum.h>
#include <xinput.h>

#include "xid.h"
#include "hub.h"
#include "usbd.h"


//
//  Globals
//
EXT_API_VERSION apiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };

WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

PSTR apiDescriptions =
    "\nUSB Debugging Extensions:\n\n"
    "help - show this help text\n"

    "device - displays a CUsbDevice from the CDeviceTree class\n"
    "    !usbkdx.device <&g_DeviceTree> <index>\n"
    "    dd g_DeviceTree l1\n"

    "hubclass - displays the global USB_PNP_CLASS_DRIVER_DESCRIPTION struct\n"
    "    !usbkdx.hubclass <&GLOBAL_ClassDescription>\n"
    "    dd GLOBAL_ClassDescription l1\n"

    "hubenum - displays the global USBHUB_ENUM_BLOCK struct\n"
    "    !usbkdx.hubenum <&GLOBAL_HubEnum>\n"
    "    dd GLOBAL_HubEnum l1\n"

    "hubinfo - displays the global USBHUB_INFO struct\n"
    "    !usbkdx.hubinfo <&GLOBAL_HubInfo>\n"
    "    dd GLOBAL_HubInfo l1\n"

    "tree - displays the global CDeviceTree class\n"
    "    !usbkdx.tree <&g_DeviceTree>\n"
    "    dd g_DeviceTree l1\n"

    "xidglobals - displays the global XID_GLOBALS struct\n"
    "    !usbkdx.xidglobals <&XID_Globals>\n"
    "    dd XID_Globals l1\n"
    "\n";


void PrintHexDump(const void* buffer, DWORD length);


//
//  DLLMain
//
BOOL WINAPI DLLMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
    {
    switch(ulReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;
        }

    return(TRUE);
    }


/*****************************************************************************

Routine Description:

    help

    Describes the extensions available from this library

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(help)
    {
    dprintf(apiDescriptions);
    return;
    } // help


/*****************************************************************************

Routine Description:

    xidglobals

    Dumps out the values of the global XID_GLOBALS struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(xidglobals)
    {
    XID_GLOBALS *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("xidglobals <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (XID_GLOBALS *)address;

    dprintf("\nXID_GLOBALS:\n");
    dprintf("    DeviceNodeCount:       %u\n", globals->DeviceNodeCount);
    dprintf("    DeviceNodeInUseCount:  %u\n", globals->DeviceNodeInUseCount);
    dprintf("    DeviceNodes:           0x%X\n", globals->DeviceNodes);
    dprintf("    OpenDeviceList:        0x%X\n", globals->OpenDeviceList);
    dprintf("    EnumNode:              %u\n", globals->EnumNode);
    dprintf("    EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->EnumUrb.Header.CompleteContext);

    //union
    //{
    //    XID_DESCRIPTOR          EnumXidDescriptor;
    //    USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    //};
    //UCHAR                       EnumMdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      EnumWatchdogTimer;
    //KDPC                        EnumWatchdogTimerDpc;

    return;
    } // xidglobals


/*****************************************************************************

Routine Description:

    hubinfo

    Dumps out the values of the global USBHUB_INFO struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubinfo)
    {
    USBHUB_INFO *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubinfo <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_INFO *)address;

    dprintf("\nUSBHUB_INFO:\n");
    dprintf("    NodeCount:             %u\n", globals->NodeCount);
    dprintf("    NodesInUse:            %u\n", globals->NodesInUse);
    dprintf("    EndpointMemory:        0x%X\n", globals->EndpointMemory);
    dprintf("    Nodes:\n");
    for(unsigned i=0; i<USBHUB_MAXIMUM_HUB_COUNT; i++)
        {
        dprintf("      %02d InUse:                  %u\n", i, globals->Nodes[i].InUse);
        dprintf("         OutstandingRequest:     %u\n", globals->Nodes[i].OutstandingRequest);
        dprintf("         RemovePending:          %u\n", globals->Nodes[i].RemovePending);
        dprintf("         PoweringPorts:          %u\n", globals->Nodes[i].PoweringPorts);
        dprintf("         UsbNodeIndex:           %u\n", globals->Nodes[i].UsbNodeIndex);
        dprintf("         PortCount:              %u\n", globals->Nodes[i].PortCount);
        dprintf("         PortProcessIndex:       %u\n", globals->Nodes[i].PortProcessIndex);
        dprintf("         PortStatusChangeBitmap: %u\n", globals->Nodes[i].PortStatusChangeBitmap);
        dprintf("         PortConnectedBitmap:    %u\n", globals->Nodes[i].PortConnectedBitmap);
        dprintf("         InterruptEndpointHandle:0x%X\n", globals->Nodes[i].InterruptEndpointHandle);
        //URB				Urb;
        //union
        //{
        //    UCHAR			RequestBuffer[4];
        //    struct {
        //	    USHORT		Status;
        //	    USHORT		StatusChange;
        //    }				PortStatus;
        //};
	    //UCHAR			MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        }

    return;
    } // hubinfo


/*****************************************************************************

Routine Description:

    hubenum

    Dumps out the values of the global USBHUB_ENUM_BLOCK struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubenum)
    {
    USBHUB_ENUM_BLOCK *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubenum <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_ENUM_BLOCK*)address;

    dprintf("\nUSBHUB_ENUM_BLOCK:\n");
    dprintf("    EnumBuffer:\n");
    PrintHexDump(globals->EnumBuffer, 32);
    dprintf("    ResetUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->ResetUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->ResetUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->ResetUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->ResetUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->ResetUrb.Header.CompleteContext);
    dprintf("    ResetContext:          %u\n", globals->ResetContext);

    //UCHAR						MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      WatchdogTimer;
    //KDPC                        WatchdogTimerDpc;

    return;
    } // hubenum

/*****************************************************************************

Routine Description:

    hubclass

    Dumps out the values of the global USB_PNP_CLASS_DRIVER_DESCRIPTION struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubclass)
    {
    USB_PNP_CLASS_DRIVER_DESCRIPTION *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubclass <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USB_PNP_CLASS_DRIVER_DESCRIPTION *)address;

    dprintf("\nUSB_PNP_CLASS_DRIVER_DESCRIPTION:\n");
    dprintf("    ClassId:\n");
    dprintf("        AsLong:            %u\n", globals->ClassId.AsLong);
    dprintf("        bClassSpecificType:%u\n", globals->ClassId.USB.bClassSpecificType);
    dprintf("        bClass:            %u\n", globals->ClassId.USB.bClass);
    dprintf("        bSubClass:         %u\n", globals->ClassId.USB.bSubClass);
    dprintf("        bProtocol:         %u\n", globals->ClassId.USB.bProtocol);
    dprintf("    Context:               0x%X\n", globals->Context);
    dprintf("    Reserved:              0x%X\n", globals->Reserved);
    dprintf("    DeviceTypeCount:       %u\n", globals->DeviceTypeCount);

/*
    PFNADD_USB_DEVICE                AddDevice;
    PFNREMOVE_USB_DEVICE             RemoveDevice;
    PUSB_PNP_DEVICE_TYPE_DESCRIPTION DeviceTypes;
*/
    return;
    } // hubclass


/*****************************************************************************

Routine Description:

    tree

    Dumps out the values of the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(tree)
    {
    CDeviceTree *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("tree <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree:\n");
    dprintf("    m_InProgress:          %u\n", globals->m_InProgress);
    dprintf("    m_DeviceRemoved:       %u\n", globals->m_DeviceRemoved);
    dprintf("    m_EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->m_EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->m_EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->m_EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->m_EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->m_EnumUrb.Header.CompleteContext);
    dprintf("    m_TimerReason:         %u\n", globals->m_TimerReason);
    dprintf("    m_FirstFree:           %u\n", globals->m_FirstFree);
    dprintf("    m_Topology:            %02X %02X %02X %02X\n", globals->m_Topology[0], globals->m_Topology[1], globals->m_Topology[2], globals->m_Topology[3]);
    dprintf("    m_DeviceDescriptor:\n");
    dprintf("        bLength:           %u\n", globals->m_DeviceDescriptor.bLength);
    dprintf("        bDescriptorType:   %u\n", globals->m_DeviceDescriptor.bDescriptorType);
    dprintf("        bcdUSB:            %u\n", globals->m_DeviceDescriptor.bcdUSB);
    dprintf("        bDeviceClass:      %u\n", globals->m_DeviceDescriptor.bDeviceClass);
    dprintf("        bDeviceSubClass:   %u\n", globals->m_DeviceDescriptor.bDeviceSubClass);
    dprintf("        bDeviceProtocol:   %u\n", globals->m_DeviceDescriptor.bDeviceProtocol);
    dprintf("        bMaxPacketSize0:   %u\n", globals->m_DeviceDescriptor.bMaxPacketSize0);
    if(globals->m_InterfaceDescriptor)
        {
        dprintf("    m_InterfaceDescriptor:\n");
        dprintf("        bLength:           %u\n", globals->m_InterfaceDescriptor->bLength);
        dprintf("        bDescriptorType:   %u\n", globals->m_InterfaceDescriptor->bDescriptorType);
        dprintf("        bInterfaceNumber:  %u\n", globals->m_InterfaceDescriptor->bInterfaceNumber);
        dprintf("        bAlternateSetting: %u\n", globals->m_InterfaceDescriptor->bAlternateSetting);
        dprintf("        bNumEndpoints:     %u\n", globals->m_InterfaceDescriptor->bNumEndpoints);
        dprintf("        bInterfaceClass:   %u\n", globals->m_InterfaceDescriptor->bInterfaceClass);
        dprintf("        bInterfaceSubClass:%u\n", globals->m_InterfaceDescriptor->bInterfaceSubClass);
        dprintf("        bInterfaceProtocol:%u\n", globals->m_InterfaceDescriptor->bInterfaceProtocol);
        dprintf("        iInterface:        %u\n", globals->m_InterfaceDescriptor->iInterface);
        }

/*
    UCHAR                       m_MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    KDPC                        m_EnumDpc;
    KTIMER                      m_EnumTimer;
    CUsbDevice                  *m_FirstPendingEnum;
    CUsbDevice                  *m_CurrentEnum;
    UCHAR                       m_ConfigurationDescriptorBuffer[USBD_MAX_CONFIG_DESC_SIZE];
    CUsbDevice                  m_Devices[UDN_MAX_NODES];
*/

    return;
    } // tree


/*****************************************************************************

Routine Description:

    device

    Dumps out the values of a CUsbDevice from the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(device)
    {
    CDeviceTree *globals;
    ULONG address;
    unsigned index;

    if(0 == args[0])
        {
        dprintf("device <address> <index>\n");
        return;
        }

    sscanf(args, "%lx %u", &address, &index);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree.CUsbDevice[%u]:\n", index);
    dprintf("    m_Type:                %u\n", globals->m_Devices[index].m_Type);
    dprintf("    m_NextFree:            %u\n", globals->m_Devices[index].m_NextFree);
    dprintf("    m_bInterfaceNumber:    %u\n", globals->m_Devices[index].m_bInterfaceNumber);
    dprintf("    m_Sibling:             %u\n", globals->m_Devices[index].m_Sibling);
    dprintf("    m_PortNumber:          %u\n", globals->m_Devices[index].m_PortNumber);
    dprintf("    m_Address:             %u\n", globals->m_Devices[index].m_Address);
    dprintf("    m_MaxPacket0:          %u\n", globals->m_Devices[index].m_MaxPacket0);
    dprintf("    m_ClassSpecificType:   %u\n", globals->m_Devices[index].m_ClassSpecificType);
    dprintf("    m_DefaultEndpoint:     0x%X\n", globals->m_Devices[index].m_DefaultEndpoint);
    if(globals->m_Devices[index].m_HostController)
        {
        dprintf("    m_HostController:\n");
        dprintf("        ControllerNumber:  %u\n", globals->m_Devices[index].m_HostController->ControllerNumber);
        dprintf("        RootHub:           0x%X\n", globals->m_Devices[index].m_HostController->RootHub);
        dprintf("        AddressList:       %X %X %X %X\n", globals->m_Devices[index].m_HostController->AddressList[0], globals->m_Devices[index].m_HostController->AddressList[1], globals->m_Devices[index].m_HostController->AddressList[2], globals->m_Devices[index].m_HostController->AddressList[3]);
        dprintf("        HcdExtension:      0x%X\n", &globals->m_Devices[index].m_HostController->HcdExtension);
        }
    dprintf("    m_ClassDriverExtension:0x%X\n", globals->m_Devices[index].m_ClassDriverExtension);
    dprintf("    m_ExternalPort:         %u\n", globals->m_Devices[index].m_ExternalPort);

    return;
    } // device

void WinDbgExtensionDllInit(PWINDBG_EXTENSION_APIS pExtensionApis, USHORT MajorVersion, USHORT MinorVersion)
    {
    ExtensionApis = *pExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
    }

void CheckVersion(void)
    {
    }

LPEXT_API_VERSION ExtensionApiVersion(void)
    {
    return &apiVersion;
    }


/*****************************************************************************

Routine Description:

    PrintHexDump

    Outputs a hex dump of memory

Arguments:

        const void* buffer - pointer to start of the memory
        DWORD length - how many bytes to dump

Return Value:

    none

*****************************************************************************/
void PrintHexDump(const void* buffer, DWORD length)
    {
    DWORD i,count,index;
    CHAR rgbLine[100];
    char cbLine;
    const char *buff = (const char*)buffer;

    for(index = 0; length; length -= count, buff += count, index += count)
        {
        count = (length > 16) ? 16:length;

        sprintf(rgbLine, "%4.4X  ",index);
        cbLine = 6;

        for(i=0;i<count;i++)
            {
            sprintf(rgbLine+cbLine, "%02X", buff[i]);
            cbLine +=2;

            if(i == 7)
                {
                rgbLine[cbLine++] = ' ';
                }
            else
                {
                rgbLine[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            }

        rgbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buff[i] < 32 || buff[i] > 126)
                {
                rgbLine[cbLine++] = '.';
                }
            else
                {
                rgbLine[cbLine++] = buff[i];
                }
            }

        rgbLine[cbLine++] = 0;
        dprintf("    %s\n", rgbLine);
        }

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mutest\lowlvl.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MUTEST.CPP

Abstract:

    This source file contains a simple test code for the MU

Environment:

    kernel mode

Revision History:

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <stdio.h>
#include <xtl.h>
extern "C" {
#include <ntos.h>
#include <xapip.h>  //private XAPI methods for low-level tests
}

#include <mutest.h>
#include <stdio.h>

//
// to test the double buffering code on the 8k fw restricted writes
// play with the two values below
// I tested (A=8k aligned, NA=non aligned)
// a) offset=A, length=N, 4k
// b) offset=NA,length=A, 8k
// c) offset=A, length=N, 12k
// d) offset=NA,length=N, 12k
// f) offset=NA,length=N, 4k
// g) offset=NA,length=A, 16k

#define WRITE_SIZE       (4096*256)   //1MB write size
#define TEST_BUFFER_SIZE (4096*32)    //128KB
#define TRANSFER_SIZE    4096
#define MU_MEDIA_OFFSET  4096*8

#define EXTRA_SIZE 4096
#define SECTOR_MASK 0xFFFFFF000

VOID
LowLevelTest(
          ULONG Port,
          ULONG Slot
          )
{
	
	ULONG					tryCount = 0;
    OCHAR                   name[64];
    HRESULT                 hr;
    HANDLE                  hFile;
    PUCHAR buffer,buffer2;
    UCHAR pattern[4] = {1,2,3,4};
    ULONG i;
    HANDLE hVolume;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    OCHAR oszDeviceObjectBuffer[64];
    OBJECT_STRING objName;
    NTSTATUS status;
    ULONG   totalErrorCount = 0;
    ULONG   localErrorCount = 0;
    ULONGLONG bytesPerSecond = 0;
    

    //
    //  Create a device object for the MU
    //
    objName.Length = 
    objName.MaximumLength = sizeof(oszDeviceObjectBuffer)-1;
    objName.Buffer = oszDeviceObjectBuffer;
    status = MU_CreateDeviceObject(Port, Slot, &objName);
    if(NT_ERROR(status))
    {
        DebugPrint("Could not create device object for MU, status = 0x%0.8x");
        return;
    }

    buffer =  (PUCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TEST_BUFFER_SIZE+EXTRA_SIZE);
    buffer2 =  (PUCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TEST_BUFFER_SIZE+EXTRA_SIZE);

    //
    // sector align buffers
    //

    buffer = (PUCHAR)((ULONG) buffer & SECTOR_MASK);
    buffer += EXTRA_SIZE;

    buffer2 = (PUCHAR)((ULONG) buffer2 & SECTOR_MASK);
    buffer2 += EXTRA_SIZE;

    //
    // fill the buffer with a pattern
    //

    for (i=0;i<TEST_BUFFER_SIZE/sizeof(ULONG);i++) {

        *((PULONG)buffer+i) = i;

    }

    DebugPrint("MUTEST: LowLevelTest: Test buffer 1 at %x, 2 at %x\n",buffer,buffer2);

    InitializeObjectAttributes(&oa, (POBJECT_STRING) &objName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    DebugPrint("MUTEST: LowLevelTest: Opening volume \n");

    status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(status)) {

        status = NtDeviceIoControlFile(hVolume,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                       NULL,
                                       0,
                                       &diskGeometry,
                                       sizeof(diskGeometry));

        if (NT_SUCCESS(status)) {
            PARTITION_INFORMATION pi;
            ULONG ulSectorSize = diskGeometry.BytesPerSector;
            ULONG ulSectorsPerTrack = diskGeometry.SectorsPerTrack;
            ULONG ulHeads = diskGeometry.TracksPerCylinder;
            ULONG ulTotalSectorCount = (RtlExtendedIntegerMultiply(
                                        diskGeometry.Cylinders,
                                        diskGeometry.SectorsPerTrack *
                                            diskGeometry.TracksPerCylinder)).LowPart;

            DebugPrint("MUTEST: SectorSize %x, SectorCount %x\n",
                       ulSectorSize,
                       ulTotalSectorCount);
                                            
            status = NtDeviceIoControlFile(hVolume,
                                           0,
                                           NULL,
                                           NULL,
                                           &statusBlock,
                                           IOCTL_DISK_GET_PARTITION_INFO,
                                           NULL,
                                           0,
                                           &pi,
                                           sizeof(pi));
                                                      
            if ((NT_SUCCESS(status) && pi.RecognizedPartition) ||
                (status == STATUS_NOT_SUPPORTED)) {

                LARGE_INTEGER offset;
                LARGE_INTEGER start, end;
                LARGE_INTEGER freq;
                
                offset.QuadPart = MU_MEDIA_OFFSET;
                freq = KeQueryPerformanceFrequency();
                start = KeQueryPerformanceCounter();
                
                DebugPrint("MUTEST: Writing complete test pattern to offset %x, iterations %x, write length %x\n",
                           offset.LowPart,
                           WRITE_SIZE/TEST_BUFFER_SIZE,
                           TEST_BUFFER_SIZE);

                

                for (i=0;i<WRITE_SIZE/TEST_BUFFER_SIZE;i++) {

                    //DebugPrint("MUTEST: current offset %x\n",
                    //       offset.LowPart);

                    status = NtWriteFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer,
                                         TEST_BUFFER_SIZE,
                                         &offset
                                         );
                    offset.QuadPart += TEST_BUFFER_SIZE;
                    if(NT_ERROR(status)) localErrorCount++;
                }

                end = KeQueryPerformanceCounter();
                end.QuadPart -= start.QuadPart;                

                if(localErrorCount)
                {
                    DebugPrint("MUTEST: %d write errors occured.\n", localErrorCount);
                    totalErrorCount += localErrorCount;
                }
                
                //
                //  Calculate bytes per second.
                //
                bytesPerSecond = (WRITE_SIZE * freq.QuadPart)/end.QuadPart;
                DebugPrint("MUTEST: data rate writing %d bytes was %d bytes per second.\n", WRITE_SIZE, (ULONG)bytesPerSecond);
                
                

                ///////////////////////////////////////////////////////////////
                //
                // READ perf test
                //
                ///////////////////////////////////////////////////////////////

                offset.QuadPart = MU_MEDIA_OFFSET;
                localErrorCount = 0;
                start = KeQueryPerformanceCounter();
                
                DebugPrint("MUTEST: Reading complete test pattern to offset %x, iterations %x, write length %x\n",
                           offset.LowPart,
                           WRITE_SIZE/TEST_BUFFER_SIZE,
                           TEST_BUFFER_SIZE);

                for (i=0;i<WRITE_SIZE/TEST_BUFFER_SIZE;i++) {

                    //DebugPrint("MUTEST: current offset %x\n",
                    //       offset.LowPart);

                    status = NtReadFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer2,
                                         TEST_BUFFER_SIZE,
                                         &offset
                                         );
                    offset.QuadPart += TEST_BUFFER_SIZE;
                    if(NT_ERROR(status)) localErrorCount++;
                }

                end = KeQueryPerformanceCounter();
                end.QuadPart -= start.QuadPart;                

                if(localErrorCount)
                {
                    DebugPrint("MUTEST: %d read errors occured.\n", localErrorCount);
                    totalErrorCount += localErrorCount;
                }
                
                //
                //  Calculate bytes per second.
                //
                bytesPerSecond = (WRITE_SIZE * freq.QuadPart)/end.QuadPart;
                DebugPrint("MUTEST: data rate reading %d bytes was %d bytes per second.\n", WRITE_SIZE, (ULONG)bytesPerSecond);

                ///////////////////////////////////////////////////////////////
                //
                // check loop back for errors
                //
                ///////////////////////////////////////////////////////////////
                
                localErrorCount = TEST_BUFFER_SIZE - RtlCompareMemory(buffer, buffer2, TEST_BUFFER_SIZE);
                if(0==localErrorCount)
                {
                  DebugPrint("MUTEST: data read back matched what was written.\n");
                } else
                {
                    DebugPrint("MUTEST: There were %d errors in the read back.\n", localErrorCount);
                    totalErrorCount += localErrorCount;
                    DebugPrint("MUTEST: Offset: Written,  Read\n", i, buffer[i], buffer2[i]);
                    int errorCount = 0;
                    for(int i=0; i<TEST_BUFFER_SIZE; i++)
                    {
                        if(buffer[i]!=buffer2[i])
                        {
                            errorCount++;
                            if(errorCount < 5)
                            {
                                DebugPrint("MUTEST: 0x%0.4x:   0x%0.2x,  0x%0.2x\n", i, (ULONG)buffer[i], (ULONG)buffer2[i]);
                            } else
                            {
                                break;
                            }
                        }
                    }
                    _asm int 3;
                }


                ///////////////////////////////////////////////////////////////
                //
                // alignment fault check.
                //
                //  Test on 4k, 8k, 12k and 16k writes.  Induce alignment faults by
                //  repeating each write at three times changing the offset by
                //  4k each time.  
                //  
                //  Test by wiping the read back buffer, and reading the entire
                //  MU contents.  These should match the cached buffer with
                //  what ever changes were made to the pattern in the portion
                //  written.
                //
                ///////////////////////////////////////////////////////////////

                offset.QuadPart = MU_MEDIA_OFFSET;

                
                //
                //  Loop over write size
                //
                ULONG writeOffset = 0;
                for(ULONG writeLength = 0x1000; writeLength <= 0x4000; writeLength += 0x1000)
                {
                    //
                    //  repeat each length with three different offsets.
                    //  never reset the offset to 0, just keep incrementing by 4k
                    for(ULONG offsetRepeat = 0; offsetRepeat < 3; offsetRepeat++, writeOffset += 0x1000)
                    {
                        DebugPrint("MUTEST: Alignment Test: writeOffset = 0x%0.8x, writeLength = 0x%0.8x", writeOffset, writeLength);
                        //
                        //  fill write buffer with test pattern
                        //
                        
                        for(i=0; i < writeLength; i+=4)
                        {
                            *((PULONG)(buffer+i+writeOffset)) = writeLength-i;
                        }
                        
                        //
                        //  Setup offset, we bias the offset to try to avoid
                        //  corrupting a formatted MU.
                        //

                        offset.QuadPart = MU_MEDIA_OFFSET + writeOffset;

                        //
                        //  Execute write
                        //
                        status = NtWriteFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer + writeOffset,
                                         writeLength,
                                         &offset
                                         );

                        if (!NT_SUCCESS(status)) {
                            DebugPrint("\nMUTEST: Write failed with status 0x%0.8x\n", status);
                            continue;
                        }

                        //
                        //  wipe read buffer
                        //
                        
                        RtlZeroMemory(buffer2, TEST_BUFFER_SIZE);

                        //
                        //  Reset offset to beginning of MU test area
                        //

                        offset.QuadPart = MU_MEDIA_OFFSET;

                        //
                        //  execute read on whole test area
                        //
                        status = NtReadFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer2,
                                         TEST_BUFFER_SIZE,
                                         &offset
                                         );
                        if (!NT_SUCCESS(status)) {
                            DebugPrint("\nMUTEST: read failed with status 0x%0.8x\n", status);
                            continue;
                        }

                        //
                        //  Byte compare the buffers
                        //
                        localErrorCount = TEST_BUFFER_SIZE - RtlCompareMemory(buffer, buffer2, TEST_BUFFER_SIZE);
                        if(0==localErrorCount)
                        {
                            DebugPrint(": Success\n");
                        } else
                        {
                            DebugPrint(": Error\nMUTEST: There were %d errors, dumping first five errors.\n", localErrorCount);
                            totalErrorCount += localErrorCount;
                            DebugPrint("MUTEST: Offset: Written,  Read\n", i, buffer[i], buffer2[i]);
                            int errorCount = 0;
                            for(int i=0; i<TEST_BUFFER_SIZE; i++)
                            {
                                if(buffer[i]!=buffer2[i])
                                {
                                    errorCount++;
                                    if(errorCount < 5)
                                    {
                                        DebugPrint("MUTEST: 0x%0.4x:   0x%0.2x,  0x%0.2x\n", i, (ULONG)buffer[i], (ULONG)buffer2[i]);
                                    } else
                                    {
                                        break;
                                    }
                                }
                            }
                            _asm int 3;
                        }

                    }   //loop over write offset
                } //loop over write length
            } else  // if get geometry failed
            {
                DebugPrint("MUTEST: Couldn't get drive geometry, status 0x%0.8x\n", status);
                totalErrorCount++;
            }
        } else  // if get partition info failed
        {
                DebugPrint("MUTEST: Couldn't get partition info, status 0x%0.8x\n", status);
                totalErrorCount++;
        }
        //
        //  Close the volume
        //
        NtClose(hVolume);
    } else  //if NtOpenFile failed
    {
            DebugPrint("MUTEST: NtOpenFileFailed, status 0x%0.8x\n", status);
            totalErrorCount++;
    }
    if(totalErrorCount)
    {
        DebugPrint("MUTEST: FAILURE: Test completed with %d errors\n", totalErrorCount);
    } else
    {
        DebugPrint("MUTEST: SUCCESS: No Errors\n");
    }

    //
    //  Format the Mu
    //
    
    DebugPrint("MUTEST: Formatting the MU, so we can do the higher level tests\n");
    if (XapiFormatFATVolume(&objName))
    {
        DbgPrint("FormatFATVolume() succeeded\n");
    } else
    {
        DbgPrint("FormatFATVolume() failed\n");
    }

    //
    //  Close the device object that we created to test the mu.
    //

    MU_CloseDeviceObject(Port, Slot);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mu\mu.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MU.CPP

Abstract:

    This source file implements the major entry points to the MU driver.

        Entries required by the USB core stack:
            MU_Init
            MU_AddDevice
            MU_RemoveDevice
        Entries used by XAPI for making MU's accessible.



Environment:

    Xbox USB class driver.

Revision History:

    George Chrysanthakopoulos (georgioc) wrote the original several months ago, loosely based
    on the existing Win2k USB mass storage driver.

    10-18-00 : Mitchell Dernis(mitchd) - systematic code and comment cleanup, now that all
               the major architectural issues are resolved.
    11-08-00 : Mitchell Dernis(mitchd) - change when DeviceObject are allocated

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "mu.h"
#include <stdio.h>

//*****************************************************************************
// Global Declarations
//*****************************************************************************
MU_DRIVER_EXTENSION MU_DriverExtension;

DRIVER_OBJECT MU_DriverObject = {
    MU_StartIo,                         // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IoInvalidDeviceRequest,         // IRP_MJ_CREATE
        IoInvalidDeviceRequest,         // IRP_MJ_CLOSE
        MU_InternalIo,                  // IRP_MJ_READ
        MU_InternalIo,                  // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        MU_InternalIo,                  // IRP_MJ_DEVICE_CONTROL
        MU_InternalIo,                  // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//This is exposed for XAPI so that XMountMU can check if the user tries to exceed it.
#if DBG
extern "C" ULONG MU_MaxUserDevices = MU_DEFAULT_MAX_MOUNTED;
#endif 

//*****************************************************************************
// Local Function Declarations
//*****************************************************************************
DEFINE_USB_DEBUG_FUNCTIONS("MU");

VOID
FASTCALL
MU_fCloseEndpoints (
    IN PMU_DEVICE_EXTENSION   DeviceExtension
    );

VOID
MU_CloseEndpointCompletion (
    IN PURB Urb,
    IN PVOID Context
    );


//*****************************************************************************
//  Declare XID types and class.
//*****************************************************************************
DECLARE_XPP_TYPE(XDEVICE_TYPE_MEMORY_UNIT)
USB_DEVICE_TYPE_TABLE_BEGIN(MU_)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_MEMORY_UNIT)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(MU_, USB_DEVICE_CLASS_STORAGE, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassMU")
USB_CLASS_DECLARATION_POINTER(MU_)
#pragma data_seg(".XPP$Data")

USB_RESOURCE_REQUIREMENTS MU_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_LOW_POWER, 0, 0, 1, 2, 0, 0, MU_BULK_MIN_TD_QUOTA, 0, 0};

//*****************************************************************************
// Implementation of USB Required Entry Points:
//  MU_Init,
//  MU_AddDevice,
//  MU_RemoveDevice
//*****************************************************************************
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID MU_Init (IUsbInit *pUsbInit)
/*++
    Routine Description:

        Called by the USB core stack if the MU driver's description table is
        linked in to the application.
--*/
{
    ULONG portCount;
    ULONG maxDeviceCount;
    ULONG maxOpenCount;
    ULONG allocSize;
    ULONG index;
    OBJECT_STRING deviceObjectName;
    PMU_DEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;

    USB_DBG_ENTRY_PRINT(("entering MU_Init\n"));

    //
    //  The "MU_DriverExtension" is just a global.  Initialize it.
    //

    RtlZeroMemory(&MU_DriverExtension,sizeof(MU_DRIVER_EXTENSION));
    InitializeListHead(&MU_DriverExtension.PartialRequestQueue);

    //
    //  Calculate maxDeviceCount and allocate the array of devices.
    //

    portCount = XGetPortCount();
    maxDeviceCount =  portCount * MU_CONTROLLERS_PER_PORT;

    //
    // Allocate an array of pointers to hold the nodes (MU_INSTANCES)
    //

    allocSize = sizeof(MU_INSTANCE)*maxDeviceCount;
    MU_DriverExtension.Nodes = (PMU_INSTANCE) RTL_ALLOCATE_HEAP(allocSize);
    ASSERT(MU_DriverExtension.Nodes);  //This allocation happens at boot, it better not fail.
    RtlZeroMemory(MU_DriverExtension.Nodes, allocSize);
    
    //
    //  Register the user selected devices
    //
    if(pUsbInit->UseDefaultCount())
    {
        maxOpenCount = MU_DEFAULT_MAX_MOUNTED;
    } else
    {
        maxOpenCount = pUsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_MEMORY_UNIT);
        RIP_ON_NOT_TRUE_WITH_MESSAGE(maxOpenCount <= maxDeviceCount, "XInitDevices: requested more XDEVICE_TYPE_MEMORY_UNIT than available ports.");
        
        // Save the number of devices that the user requested so we can RIP in debug versions of XMountMU if the user tries to exceed this.
        #if DBG
        MU_MaxUserDevices = maxOpenCount;
        #endif 
        
        // Bump up the maximum opened count. This is because API's such as XGetMUNameFromPortAndSlot,
        // and XReadMUMetaData may need to mount an MU behind the game's back, the game has not already mounted it.
        // These API's are smart enough never to mount more than one at a time beyond what the game has mounted.
        maxOpenCount++; 
        // The maximum count never needs to exceed the maximum physical devices.
        if(maxOpenCount > maxDeviceCount) maxOpenCount = maxDeviceCount;
    }

    //
    //  Allocate all the device objects and place them on a free list
    //
    RtlInitObjectString(&deviceObjectName, OTEXT("\\Device\\MU_0"));
    for(index = 0; index < maxOpenCount; index++)
    {
        NTSTATUS status;
        deviceObjectName.Buffer[sizeof("\\Device\\MU")] = (index > 9) ? (index + OTEXT('A')) : (index + OTEXT('0'));
        status = IoCreateDevice(
                    &MU_DriverObject,
                    sizeof(MU_DEVICE_EXTENSION),
                    &deviceObjectName,
                    FILE_DEVICE_MEMORY_UNIT,
                    FALSE,
                    &deviceObject
                    );
        if(NT_SUCCESS(status))
        {
            
            deviceExtension = (PMU_DEVICE_EXTENSION)deviceObject->DeviceExtension;
            RtlZeroMemory(deviceExtension, sizeof(MU_DEVICE_EXTENSION));    
            deviceExtension->DeviceObject = deviceObject;
            deviceExtension->DeviceObjectNumber = index;
            deviceExtension->DeviceFlags = DF_REMOVED;
            deviceObject->StackSize = 1;
            deviceObject->Flags |=  DO_DIRECT_IO;
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            MU_ReleaseDeviceObject(deviceExtension);
        } else break;
    }

#if DBG 
    if(index < maxOpenCount)
    {
        RIP("XInitDevices: Memory Unit failed to allocate memory all requested instances.");
    }
#endif 

    //
    //  Register the resources for the support device count
    //
    MU_gResourceRequirements.MaxDevices = maxOpenCount;
    if(maxOpenCount > 1) MU_gResourceRequirements.MaxBulkTDperTransfer *= 2;
    pUsbInit->RegisterResources(&MU_gResourceRequirements);

    //
    //  Xbox has no concept of drivers failing load
    //  so there is no point in returning an error code
    //  other than STATUS_SUCCESS
    //
    
    USB_DBG_EXIT_PRINT(("exiting MU_Init\n"));

    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID MU_AddDevice(IN IUsbDevice *Device)
/*++
    Routine Description:
        Standard USB class driver AddDevice routine.

        Verifies that MU is supported.

        Claims a preallocated MU_INSTANCE, and caches
        enumtime information needed later.
        
        Connects the IUsbDevice to the MU_INSTANCE.

    Arguments:
        Device - Interface to USB core stack for device.

    Notes:
        AddDevice routines are always called at DPC level.
--*/
{
    PMU_INSTANCE      muInstance;
    ULONG             port;
    ULONG             slot;
	const USB_ENDPOINT_DESCRIPTOR *endpointDescriptor;

    USB_DBG_ENTRY_PRINT(("MU_AddDevice(Device=0x%0.8x)", Device));

    //
    //  Get the device port and slot
    //

    port = Device->GetPort();
    if(port >= 16)
    {
        port -= 16;
        slot = 1;
    } else
    {
        slot = 0;
    }
    USB_DBG_TRACE_PRINT(("Memory Unit Added: Port = %d, Slot = %d", port, slot));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(port,slot)];
    ASSERT(1==++muInstance->AddRemoveCount);
    //
    //	get the endpoint descriptor for bulk-IN
    //

    endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, TRUE, 0);
    if(endpointDescriptor)
    {

        muInstance->BulkInEndpointAddress = endpointDescriptor->bEndpointAddress;
        
        //
        //  Verify wMaxPacketSize, for Xbox performance reasons, we require
        //  MU_MAX_BULK_PACKET_SIZE (64 bytes).  Furthermore, assumptions are
        //  made regarding max packet size based on 64 bytes.  So this really
        //  is a requirement.
        //

        if (endpointDescriptor->wMaxPacketSize != MU_MAX_BULK_PACKET_SIZE)
        {
            USB_DBG_WARN_PRINT(("unsupported device: wMaxPacketSize is incorrect for the bulk-IN endpoint."));
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }

    } else
    {
        USB_DBG_WARN_PRINT(("unsupported device: endpoint descriptor not found for bulk-IN."));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    //	get the endpoint descriptor for bulk-OUT
    //
    
    endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, FALSE, 0);
    if (endpointDescriptor)
    {
        muInstance->BulkOutEndpointAddress =  endpointDescriptor->bEndpointAddress;

        //
        //  Verify wMaxPacketSize, see comments a few lines above regarding wMaxPacketSize
        //  for the bulk-IN endpoint.
        //

        if (endpointDescriptor->wMaxPacketSize != MU_MAX_BULK_PACKET_SIZE)
        {
            USB_DBG_WARN_PRINT(("unsupported device: wMaxPacketSize is incorrect for the bulk-OUT endpoint."));
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }

    } else {
        USB_DBG_WARN_PRINT(("unsupported device: endpoint descriptor not found for bulk-OUT."));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Set our muInstance in our IUsbDevice
    //

    Device->SetExtension(muInstance);

    //
    // save our IUsbDevice pointer
    //

    muInstance->Device = Device;
    muInstance->InterfaceNumber = Device->GetInterfaceNumber();

    //
    // set the class specific type so that it gets enumerated to applications.
    //

    Device->SetClassSpecificType(0);
    Device->AddComplete(USBD_STATUS_SUCCESS);
}

EXTERNUSB VOID
MU_RemoveDevice (
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
        Standard USB class driver RemoveDevice routine.
        
        There are two possibilities: the device is in use (has a 
        DeviceObject attached and the endpoints are opened), or
        the device is not in use.  In the former case, we mark
        the device as DF_PENDING_REMOVE, and kick off the state
        machine to close the endpoints.  The last step of that state
        machine will see DF_PENDING_REMOVE and call Device->RemoveComplete()
        for us.  In the latter case, we can just call Device->RemoveComplete().

    Arguments:
        Device - Interface to USB core stack for device that is to be
                 removed.
    Notes:
        RemoveDevice routines are always called at DPC level.
--*/
{
    USB_DBG_ENTRY_PRINT(("MU_RemoveDevice(Device=0x%0.8x)", Device));

    PMU_INSTANCE           muInstance = (PMU_INSTANCE) Device->GetExtension();
    PMU_DEVICE_EXTENSION   deviceExtension = muInstance->DeviceExtension;
    ASSERT(0==--muInstance->AddRemoveCount);

    //
    //  If the MU_INSTANCE is currently attached to a device object
    //  for the current muInstance, then the endpoints are open and need to
    //  be closed before we can complete the remove.  However, it is possible
    //  that the deviceExtension is for a previous incarnation of this
    //  muInstance (a.k.a. the MU was removed, added, and now is being removed 
    //  again, without the device object ever having been closed).  In this
    //  bizarre circumstance, we can just complete the remove.
    //
    if(deviceExtension && !TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED))
    {
        //
        //  Mark the device remove pending and let the close
        //  endpoint state machine take care of the rest.
        //
        SET_FLAG(deviceExtension->DeviceFlags, DF_PENDING_REMOVE);
        MU_fCloseEndpoints(deviceExtension);
    } else
    //
    //  Otherwise, the device is not in use, we can just complete the
    //  remove right here.
    //
    {
        muInstance->Device->RemoveComplete();
        muInstance->Device = NULL;
    }
    
    USB_DBG_EXIT_PRINT(("exiting MU_RemoveDevice"));

}

//*****************************************************************************
// Implementation of XAPI Entry Points:
//  MU_CreateDeviceObject,
//  MU_CloseDeviceObject
//*****************************************************************************

NTSTATUS
MU_CreateDeviceObject(
    IN  ULONG            Port,
    IN  ULONG            Slot,
    IN  POBJECT_STRING   DeviceName
    )
/*++
    Routine Description:

        This routine is called to expose an MU as a device object.  It is called by XMountMU,
        and it also must be called to open a device with the RAW filesystem, which is used for
        formatting and some low-level tests.

        All endpoint handles are opened at them same time.

    Arguments:

        Port         - port of MU to open
        Slot         - slot of MU to open
        DeviceName   - name to give device object

    Notes:
        
        MU_CloseDeviceObject reverses MU_CreateDeviceObject
        freeing all memory.

        MU_CreateDeviceObject should only be called once on a particular port and slot.
--*/
{
    PMU_INSTANCE         muInstance;
    PMU_DEVICE_EXTENSION deviceExtension;
    NTSTATUS             status = STATUS_SUCCESS;
    USBD_STATUS          usbdStatus;
    KIRQL                oldIrql;

    USB_DBG_ENTRY_PRINT(("MU_CreateDeviceObject(Port=0x%0.8x, Slot=0x%0.8x)", Port, Slot));

    //
    //  ASSERT arguments.
    //

    ASSERT(Port < XGetPortCount());
    ASSERT((Slot == XDEVICE_TOP_SLOT) || (Slot == XDEVICE_BOTTOM_SLOT));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(Port,Slot)];

    oldIrql = KeRaiseIrqlToDpcLevel();

    deviceExtension = MU_AcquireDeviceObject();

    if(NULL == deviceExtension)
    {
        KeLowerIrql(oldIrql);
        RIP("XMountMu() - exceeded number of devices requested with XInitDevices");
        return STATUS_NO_MEMORY;
    }

    //
    //  Verify that the device is connected.
    //
    if(!muInstance->Device)
    {
        MU_ReleaseDeviceObject(deviceExtension);
        KeLowerIrql(oldIrql);
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    //  Point the MU_INSTANCE to the device extension
    //  and vice versa.  Now the failure processing
    //  can survive the normal close processing, even
    //  if the reset of open fails.
    //
    ASSERT(NULL == muInstance->DeviceExtension);
    muInstance->DeviceExtension = deviceExtension;
    deviceExtension->MuInstance = muInstance;

    //
    //  Initialize the DPC object and mrb timeouts
    //

    KeInitializeDpc(&deviceExtension->Mrb.TimeoutDpcObject, MU_MrbTimeout, deviceExtension);
    KeInitializeTimer(&deviceExtension->Mrb.Timer);

    //
    //  Initialize the debug watchdog parameters
    //
    MU_DEBUG_INIT_WATCHDOG_PARAMETERS(deviceExtension);

    //
    //  Initialize the close event.
    //

    KeInitializeEvent(&deviceExtension->CloseEvent, NotificationEvent, FALSE);

    //
    // Open the default endpoint
    //
    
    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&deviceExtension->Urb.OpenEndpoint);
    usbdStatus = muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    if(USBD_SUCCESS(usbdStatus))
    {
        SET_FLAG(deviceExtension->DeviceFlags,DF_DEFAULT_ENDPOINT_OPEN);
    } else
    {
        status = IUsbDevice::NtStatusFromUsbdStatus(usbdStatus);
        USB_DBG_WARN_PRINT(("Failed to open the default endpoint for an MU: usbdStatus = 0x%0.8x", usbdStatus));
        goto SkipRemainingEndpointOpens;
    }

    //
    // Open the Bulk-IN endpoint
    //
    USB_BUILD_OPEN_ENDPOINT(
        &deviceExtension->Urb.OpenEndpoint,
        muInstance->BulkInEndpointAddress,
        USB_ENDPOINT_TYPE_BULK,
        MU_MAX_BULK_PACKET_SIZE,
        0 //interval unimportant for bulk endpoint 
        );
    usbdStatus = muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    if(USBD_SUCCESS(usbdStatus))
    {
        SET_FLAG(deviceExtension->DeviceFlags,DF_BULK_IN_ENDPOINT_OPEN);
        deviceExtension->BulkInEndpointHandle = deviceExtension->Urb.OpenEndpoint.EndpointHandle;
    } else 
    {
        status = IUsbDevice::NtStatusFromUsbdStatus(usbdStatus);
        USB_DBG_WARN_PRINT(("Failed to open the bulk-IN endpoint for an MU: usbdStatus = 0x%0.8x", usbdStatus));
        goto SkipRemainingEndpointOpens;
    }

    //
    // Open the Bulk-OUT endpoint (if needed)
    //

    USB_BUILD_OPEN_ENDPOINT(
       &deviceExtension->Urb.OpenEndpoint,
       muInstance->BulkOutEndpointAddress,
       USB_ENDPOINT_TYPE_BULK,
       MU_MAX_BULK_PACKET_SIZE,
       0
       );
    usbdStatus = muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    if(USBD_SUCCESS(usbdStatus))
    {
        SET_FLAG(deviceExtension->DeviceFlags,DF_BULK_OUT_ENDPOINT_OPEN);
        deviceExtension->BulkOutEndpointHandle =  deviceExtension->Urb.OpenEndpoint.EndpointHandle;
    } else
    {
        status = IUsbDevice::NtStatusFromUsbdStatus(usbdStatus);
        USB_DBG_WARN_PRINT(("Failed to open the bulk-OUT endpoint for an MU: usbdStatus = 0x%0.8x", usbdStatus));
    }

SkipRemainingEndpointOpens:

    KeLowerIrql(oldIrql);

    //
    //  If an error occured, the device may be "half" opened.
    //  MU_CloseDeviceObject is smart enough to close a partially
    //  opened device, so we will just call it.
    //
    if(NT_ERROR(status))
    {
        MU_CloseDeviceObject(Port, Slot);
    }  else
    {
        //generate the device object name in the caller's buffer
        DeviceName->Length = (sizeof(OTEXT("\\Device\\MU_0"))/sizeof(OCHAR))-1;
        ASSERT(DeviceName->MaximumLength-1 >= DeviceName->Length);
        ASSERT(deviceExtension->DeviceObjectNumber < 16);
        soprintf(DeviceName->Buffer, OTEXT("\\Device\\MU_%x"), deviceExtension->DeviceObjectNumber);
    }

    USB_DBG_EXIT_PRINT(("MU_CreateDeviceObject returning 0x%0.8x" status));
    return status;
}

VOID
MU_CloseDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    )
/*++
    Routine Description:
        Reverse MU_CreateDeviceObject.

    Argument:
        DeviceObject - MU DeviceObject to close.
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension;
    PMU_INSTANCE         muInstance;
    KIRQL                oldIrql;

    USB_DBG_ENTRY_PRINT(("MU_CloseDeviceObject(Port=%d,Slot=%d)", Port, Slot));

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    //
    //  ASSERT arguments.
    //

    ASSERT(Port < XGetPortCount());
    ASSERT((Slot == XDEVICE_TOP_SLOT) || (Slot == XDEVICE_BOTTOM_SLOT));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(Port,Slot)];

    //
    //  Raise Irql to synchronize
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Get the deviceExtension from the muInstance.
    //

    deviceExtension = muInstance->DeviceExtension;

    //
    //  Hitting assert probably indicates that MU_CloseDeviceObject was called
    //  for an MU that was already closed.  Since this is not a
    //  public API, we just ASSERT.  Fix the calling code!
    //

    ASSERT(deviceExtension);

    //
    //  If the device extension points back to an active MU_INSTANCE behind this device object,
    //  close the endpoints on it first.
    //

    if(deviceExtension->MuInstance)
    {
        //
        //  Mark the device as pending close
        //
        SET_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE);

        //
        //  Let the close endpoint state machine finish up the work of closing.
        //
        MU_fCloseEndpoints(deviceExtension);

        //
        //  Lower irql for synchronization purposes.
        //
        KeLowerIrql(oldIrql);

        //
        //  Wait for the close endpoint state machine to finish
        //
        KeWaitForSingleObject(&deviceExtension->CloseEvent, Executive, KernelMode, FALSE, NULL);
        
    } else
    {
        muInstance->DeviceExtension = NULL;
        KeLowerIrql(oldIrql);
    }
    //
    //  The MU instance can now forget about the device object.
    //
    MU_ReleaseDeviceObject(deviceExtension);

    USB_DBG_EXIT_PRINT(("MU_CloseDeviceObject returning."));
    return;
};

PDEVICE_OBJECT
MU_GetExistingDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    )
{
    PMU_INSTANCE         muInstance;

    USB_DBG_ENTRY_PRINT(("MU_GetExistingDeviceObject(Port=%d,Slot=%d)", Port, Slot));

    //
    //  ASSERT arguments.
    //

    ASSERT(Port < XGetPortCount());
    ASSERT((Slot == XDEVICE_TOP_SLOT) || (Slot == XDEVICE_BOTTOM_SLOT));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(Port,Slot)];

    //
    //  This routine should only be invoked for a MU object that has been
    //  created.  The caller is responsible for synchronizing calls to create
    //  and close MUs with this routine.
    //

    ASSERT(muInstance->DeviceExtension);

    return muInstance->DeviceExtension->DeviceObject;
}

//*****************************************************************************
//  Implementation of local functions:
//      MU_fCloseEndpoints
//      MU_CloseEndpointCompletion
//*****************************************************************************
VOID
FASTCALL
MU_fCloseEndpoints (
    IN PMU_DEVICE_EXTENSION   DeviceExtension
    )
/*++
    Routine Description:
        Enters the close endpoint state machine.

        It is protected against reentrancy, by checking
        a flag.

        If an MU_fOpenEndpoints is in progress, it signals
        that MU_fOpenEndpoints should call it when it
        syncs up its new status.
--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    // If a close is not already in progress, start one
    //

    if(!TEST_FLAG(DeviceExtension->DeviceFlags, DF_CLOSING_ENDPOINTS))
    {
       SET_FLAG(DeviceExtension->DeviceFlags,DF_CLOSING_ENDPOINTS);
       MU_CloseEndpointCompletion(NULL, DeviceExtension);
    }

    return;
}

VOID
MU_CloseEndpointCompletion (
    PURB Urb,
    PVOID Context
    )
/*++
    Routine Description:

        This is the heart of the close endpoint state machine.
        Each time it is called, it looks for an endpoint that
        needs to be closed, and builds an URB to close it and
        return back to this routine when it is closed.  At the
        end of the routine, whichever URB was built is submitted.
        
        When all the endpoints are closed, it will get to the
        last else clause.  It will complete a remove if one
        was pending, and exit the close endpoint state machine,
        before the URB is submitted (since it build one).
    
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    PMU_INSTANCE muInstance = deviceExtension->MuInstance;
    
    ASSERT_DISPATCH_LEVEL();

    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_BULK_OUT_ENDPOINT_OPEN))
    //
    //  The Bulk-OUT endpoint needs to be closed.
    //
    {
        //
        //  Build the URB.
        //

        USB_BUILD_CLOSE_ENDPOINT(
          &deviceExtension->CloseEndpointUrb,
          deviceExtension->BulkOutEndpointHandle,
          MU_CloseEndpointCompletion,
          deviceExtension
          );

        //
        //  Mark the endpoint closed
        //

        deviceExtension->BulkOutEndpointHandle = 0;
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_BULK_OUT_ENDPOINT_OPEN);

    } else if(TEST_FLAG(deviceExtension->DeviceFlags, DF_BULK_IN_ENDPOINT_OPEN))
    //
    //  The Bulk-IN endpoint needs to be closed.
    //
    {
        //
        //  Build the URB.
        //

        USB_BUILD_CLOSE_ENDPOINT(
          &deviceExtension->CloseEndpointUrb,
          deviceExtension->BulkInEndpointHandle,
          MU_CloseEndpointCompletion,
          deviceExtension
          );

        //
        //  Mark the endpoint closed
        //

        deviceExtension->BulkInEndpointHandle = 0;
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_BULK_IN_ENDPOINT_OPEN);

    } else if(TEST_FLAG(deviceExtension->DeviceFlags, DF_DEFAULT_ENDPOINT_OPEN))
    //
    //  The default endpoint needs to be closed.
    //
    {
        //
        //  Build the URB.
        //

        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
          &deviceExtension->CloseEndpointUrb,
          MU_CloseEndpointCompletion,
          deviceExtension
          );

        //
        //  Mark the endpoint closed
        //

        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_DEFAULT_ENDPOINT_OPEN);

    } else
    //
    // Our state machine is done closing endpoints
    //
    {

        //
        //  We are no longer closing endpoints.
        //
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_CLOSING_ENDPOINTS);

        //
        //  This state machine has been invoked because
        //  a remove and\or close is pending.  In either
        //  case, the device object needs to forget about
        //  the MU_INSTANCE, but NOT vice versa.  The MuInstance
        //  only forgets about the device object on close.
        //
        deviceExtension->MuInstance = NULL;

        //
        //  If a close is pending, signal the close event
        //  so the close caller that started the state machine
        //  can finish up its processing.
        //
        if(TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE))
        {
            //
            //  We can forget about the device object now
            //  as it will be deleted by MU_CloseDeviceObject
            //  when we signal the close event.
            //
            muInstance->DeviceExtension = NULL;
            KeSetEvent(&deviceExtension->CloseEvent, IO_NO_INCREMENT, FALSE);
            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE);
        }

        //
        //  If a remove is pending, then process it.
        //

        if(TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_REMOVE))
        {
            //
            //  if remove was pending, call remove complete
            //

            muInstance->Device->RemoveComplete();
            muInstance->Device = NULL;

            //
            //  it is now removed, not remove pending.
            //

            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PENDING_REMOVE);
            SET_FLAG(deviceExtension->DeviceFlags, DF_REMOVED);
        }
        
        //
        //  We are done, so return before submitting the URB
        //

        return;
    }

    //
    //  If we are here, we have built an URB, submit it.
    //

    muInstance->Device->SubmitRequest((PURB)&deviceExtension->CloseEndpointUrb);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mutest\mutest.h ===
// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

VOID
LowLevelTest(
          ULONG Port,
          ULONG Slot
          );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\client\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\client\precomp.h ===
#define DEBUG_KEYBOARD

#include <stddef.h>
#include <ntos.h>
#include <xtl.h>
#include <xdbg.h>
#include <xbdm.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\mutest\mutest.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MUTEST.CPP

Abstract:

    This source file contains a simple test code for the MU

Environment:

    kernel mode

Revision History:

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <xtl.h>
#include <xboxp.h>

#include <mutest.h>
#include <devioctl.h>
#include <ntdddisk.h>
#include <stdio.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

VOID
ReadWriteTest(
          CHAR DriveLetter
          );

VOID
ReadWriteScatterGatherTest(
          CHAR DriveLetter
          );

VOID
MUNameTest(
          CHAR DriveLetter
          );

VOID
DumpLogicalDriveList()
{
    CHAR szDriveStrings[] = "D:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0T:\\\0U:\\\0X:\\";
    LPSTR pszDrive;

    DebugPrint("Logical drive list:");
    pszDrive = szDriveStrings;
    while ('\0' != *pszDrive)
    {
        ULARGE_INTEGER ullFreeAvail, ullFree, ullTotal;
        if (GetDiskFreeSpaceEx(pszDrive, &ullFreeAvail, &ullTotal, &ullFree))
        {
            DebugPrint(" %s", pszDrive);
        }
        // Seek until next NULL:
        while (L'\0' != *pszDrive)
        {
            pszDrive++;
        }
        // Skip over the NULL:
        pszDrive++;
    }
    DebugPrint("\n");
}

VOID
WINAPI
GetDriveTypeTest()
{
    CHAR szDriveStrings[] = "D:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0T:\\\0U:\\\0X:\\";
    LPSTR pszDrive;

    // GetDriveType test
    DebugPrint("Logical drive list:\n");
    pszDrive = szDriveStrings;
    while (L'\0' != *pszDrive)
    {
        ULARGE_INTEGER ullFreeAvail, ullFree, ullTotal;
        if (GetDiskFreeSpaceEx(pszDrive, &ullFreeAvail, &ullTotal, &ullFree))
        {
            CHAR szLabel[MAX_PATH], szFileSystem[MAX_PATH];
            DWORD dwSerial, dwMaxNameLength, dwFSFlags;

            // Shift into a dword (right shift 20 and label as MB) to we can print it out..
            ullFreeAvail.LowPart = (ullFreeAvail.LowPart >> 20) | (ullFreeAvail.HighPart << 12);
            ullTotal.LowPart = (ullTotal.LowPart >> 20) | (ullTotal.HighPart << 12);
            ullFree.LowPart = (ullFree.LowPart >> 20) | (ullFree.HighPart << 12);

            if (GetVolumeInformation(pszDrive,
                                     szLabel,
                                     ARRAYSIZE(szLabel),
                                     &dwSerial,
                                     &dwMaxNameLength,
                                     &dwFSFlags,
                                     szFileSystem,
                                     ARRAYSIZE(szFileSystem)))
            {
                DebugPrint("Drive %s (label \"%s\", serial 0x%08x, maxname %lu, fsflags %lu, fs \"%s\")\n"
                           "          (total %lu MB, free %lu MB, avail %lu MB)\n",
                            pszDrive, szLabel, dwSerial, dwMaxNameLength, dwFSFlags, szFileSystem,
                            ullTotal.LowPart, ullFree.LowPart, ullFreeAvail.LowPart);
            }
            else
            {
                DWORD dwErr = GetLastError();
                DebugPrint("GetVolumeInformation() failed for %s: GetLastError()=0x%08x\n", pszDrive, dwErr);
            }
        }
        // Seek until next NULL:
        while (L'\0' != *pszDrive)
        {
            pszDrive++;
        }
        // Skip over the NULL:
        pszDrive++;
    }
    DebugPrint("\n");
}

VOID
WINAPI
FindFirstFindNextTest(LPCSTR pcszFilter)
{
    // FindFirstFile/FindNextFile/FindClose test
    WIN32_FIND_DATA wfd;
    HANDLE hFind = FindFirstFile(pcszFilter, &wfd);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        DebugPrint("Directory listing for %s\n", pcszFilter);
        do
        {
            DebugPrint("%s, size=0x%08x, attributes=\n", wfd.cFileName,
                wfd.nFileSizeLow, wfd.dwFileAttributes);
            
        } while (FindNextFile(hFind, &wfd));
        
        FindClose(hFind);
    }
    else
    {
        DWORD dwErr = GetLastError();
        DebugPrint("FindFirstFile() failed for %s: GetLastError()=0x%08x\n", pcszFilter, dwErr);
    }
    DebugPrint("\n");
}


void __cdecl main()
{
    DWORD err;
    ULONG DeviceTypes = 0xFFFF0000;//USB_DEVICE_TYPE_MU;
    CHAR szFilter[] = "C:\\*";
    DWORD dwInsertions, dwRemovals;
    int i;
    
    DebugPrint("MUTEST: Built on %s at %s\n", __DATE__,__TIME__);
    
    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    
    DebugPrint("MUTEST: Polling for device insertions/removals..\n");

    while (TRUE) {

        if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &dwInsertions, &dwRemovals))
        {
        
            DebugPrint("MUTEST: Insertions 0x%08x, Removals 0x%08x\n", dwInsertions, dwRemovals);

            for(i=0; i < 32; i++)
            {
                if(dwRemovals&(1 << i))
                {
                    DWORD dwSlot;
                    DWORD dwPort;
                    if(i < 16)
                    {
                        dwPort = i;
                        dwSlot = XDEVICE_TOP_SLOT;
                    } else
                    {
                        dwPort = i-16;
                        dwSlot = XDEVICE_BOTTOM_SLOT;
                    }
                    XUnmountMU(dwPort, dwSlot);
                }
                //
                //  Handle Insertions
                //
                if(dwInsertions&(1 << i))
                {
                    CHAR chDrive;
                    DWORD dwSlot;
                    DWORD dwPort;
                    if(i < 16)
                    {
                        dwPort = i;
                        dwSlot = XDEVICE_TOP_SLOT;
                    } else
                    {
                        dwPort = i-16;
                        dwSlot = XDEVICE_BOTTOM_SLOT;
                    }
                    if(dwPort >= 4)
                    {
                        DebugPrint("ERROR: MU in illegal port, p=%d, s=%s\n", dwPort, (XDEVICE_TOP_SLOT==dwSlot) ? "XDEVICE_TOP_SLOT" : "XDEVICE_BOTTOM_SLOT" );
                    }

                    LowLevelTest(dwPort, dwSlot);


                    DWORD dwErr = XMountMU(dwPort, dwSlot, &chDrive);

                    if (ERROR_SUCCESS == dwErr)
                    {

                        DebugPrint("XMountMU() succeeded, dr=%lc, p=%d, s=%d\n",
                                   chDrive,
                                   XMUPortFromDriveLetter(chDrive),
                                   XMUSlotFromDriveLetter(chDrive));

                        GetDriveTypeTest();

                        szFilter[0] = chDrive;

                        FindFirstFindNextTest(szFilter);

                        ReadWriteTest(chDrive);

                        ReadWriteScatterGatherTest(chDrive);

                        FindFirstFindNextTest(szFilter);

                        MUNameTest(chDrive);
                    }
                    else
                    {
                        DebugPrint("XMountMU() failed, error = 0x%08x\n", dwErr);
                    }
                }
            } // for loop
            DumpLogicalDriveList();
        } // if

    } // while
}


#define TEST_BUFFER_SIZE 8192
#define EXTRA_SIZE 8192
#define SECTOR_MASK 0xFFFFE000

VOID
ReadWriteTest(
          CHAR DriveLetter
          )
{

	ULONG					tryCount = 0;
    CHAR                    name[64];
    HRESULT                 hr;
    HANDLE                  hFile;
    PUCHAR buffer,buffer2;
    UCHAR pattern[4] = {1,2,3,4};
    ULONG i;

    sprintf(name,"C:\\test.dat");

    name[0] = DriveLetter;

    hFile = CreateFile(name,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_WRITE_THROUGH,
                    NULL,
                    OPEN_ALWAYS,
                    0,
                    NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    buffer =  (PUCHAR)LocalAlloc(LPTR, TEST_BUFFER_SIZE+EXTRA_SIZE);
    buffer2 =  (PUCHAR)LocalAlloc(LPTR, TEST_BUFFER_SIZE+EXTRA_SIZE);

    //
    // sector align buffers
    //

    buffer = (PUCHAR)((ULONG) buffer & SECTOR_MASK);
    buffer += EXTRA_SIZE;

    buffer2 = (PUCHAR)((ULONG) buffer2 & SECTOR_MASK);
    buffer2 += EXTRA_SIZE;

    //
    // fill the buffer with a pattern
    //

    for (i=0;i<TEST_BUFFER_SIZE;i+=sizeof(pattern)) {

        RtlCopyMemory(buffer+i,pattern,sizeof(pattern));

    }

    DebugPrint("MUTEST: Test buffer 1 at %x, 2 at %x\n",buffer,buffer2);

    DebugPrint("MUTEST: Writing pattern to file\n");

    //
    // write the pattern to the file, close the file then read it
    //

    if (!WriteFile(hFile,
                  buffer,
                  TEST_BUFFER_SIZE,
                  &i,
                  NULL)) {

        hr = GetLastError();
        DebugPrint("MUTEST: Write Failed with %x\n",hr);

        LocalFree(buffer);
        LocalFree(buffer2);

    }

    DebugPrint("MUTEST: Closing file\n");

    //
    // close the file
    //

    CloseHandle(hFile);

    DebugPrint("MUTEST: Re-opening file\n");

    //
    // open the file and read from it
    //

    hFile = CreateFile(name,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_NO_BUFFERING,
                NULL,
                OPEN_ALWAYS,
                0,
                NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    DebugPrint("MUTEST: Reading pattern to file\n");

    if (!ReadFile(hFile,
                  buffer2,
                  TEST_BUFFER_SIZE,
                  &i,
                  NULL)) {

        hr = GetLastError();
        DebugPrint("MUTEST: Read Failed with %x\n",hr);

        LocalFree(buffer);
        LocalFree(buffer2);

    }

    CloseHandle(hFile);

    DebugPrint("MUTEST: Success: Test buffer at %x\n",buffer);
}


#define PAGE_SIZE 4096
#define TEST_SG_BUFFER_SIZE (PAGE_SIZE * 5)

VOID
ReadWriteScatterGatherTest(
          CHAR DriveLetter
          )
{

	ULONG					tryCount = 0;
    CHAR                    name[64];
    HRESULT                 hr;
    HANDLE                  hFile;
    PUCHAR buffer,buffer2;
    FILE_SEGMENT_ELEMENT sg1[TEST_SG_BUFFER_SIZE / PAGE_SIZE + 1];
    FILE_SEGMENT_ELEMENT sg2[TEST_SG_BUFFER_SIZE / PAGE_SIZE + 1];
    UCHAR pattern[4] = {1,2,3,4};
    ULONG i;
    OVERLAPPED ov;

    sprintf(name,"C:\\testsg.dat");

    name[0] = DriveLetter;

    hFile = CreateFile(name,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_WRITE_THROUGH,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                    NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    buffer =  (PUCHAR)VirtualAlloc(NULL,TEST_SG_BUFFER_SIZE,MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    buffer2 =  (PUCHAR)VirtualAlloc(NULL,TEST_SG_BUFFER_SIZE,MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    ZeroMemory(sg1, sizeof(sg1));
    ZeroMemory(sg2, sizeof(sg2));

    for (i = 0; i < TEST_SG_BUFFER_SIZE / PAGE_SIZE; i++) {
        sg1[i].Buffer = buffer + i * PAGE_SIZE;
        sg2[i].Buffer = buffer2 + i * PAGE_SIZE;
    }

    //
    // fill the buffer with a pattern
    //

    for (i=0;i<TEST_SG_BUFFER_SIZE;i+=sizeof(pattern)) {

        RtlCopyMemory(buffer+i,pattern,sizeof(pattern));

    }

    DebugPrint("MUTEST: Scatter/gather test\n");

    DebugPrint("MUTEST: Test S/G buffer 1 at %x, 2 at %x\n",buffer,buffer2);

    DebugPrint("MUTEST: Writing pattern to file\n");

    //
    // write the pattern to the file, close the file then read it
    //

    ZeroMemory(&ov, sizeof(ov));

    if (!WriteFileGather(hFile,
                  sg1,
                  TEST_SG_BUFFER_SIZE,
                  NULL,
                  &ov)) {

        hr = GetLastError();

        if (hr != ERROR_IO_PENDING ||
            !GetOverlappedResult(hFile, &ov, &i, TRUE)) {

            hr = GetLastError();

            DebugPrint("MUTEST: Write Failed with %x\n",hr);
        }
    }

    DebugPrint("MUTEST: Closing file\n");

    //
    // close the file
    //

    CloseHandle(hFile);

    DebugPrint("MUTEST: Re-opening file\n");

    //
    // open the file and read from it
    //

    hFile = CreateFile(name,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_NO_BUFFERING,
                NULL,
                OPEN_ALWAYS,
                FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    DebugPrint("MUTEST: Reading pattern to file\n");

    ZeroMemory(&ov, sizeof(ov));

    if (!ReadFileScatter(hFile,
                  sg2,
                  TEST_SG_BUFFER_SIZE,
                  NULL,
                  &ov)) {

        hr = GetLastError();

        if (hr != ERROR_IO_PENDING ||
            !GetOverlappedResult(hFile, &ov, &i, TRUE)) {

            hr = GetLastError();

            DebugPrint("MUTEST: Read Failed with %x\n",hr);
        }
    }

    CloseHandle(hFile);

    DebugPrint("MUTEST: Success: Test S/G buffer at %x\n",buffer);
}

VOID
MUNameTest(
          CHAR DriveLetter
          )
{
    DWORD error;
    WCHAR MUName[MAX_MUNAME];

    RtlFillMemory(MUName, sizeof(MUName), 0xCC);

    error = XMUWriteNameToDriveLetter(DriveLetter, L"Test Name");

    if (error != ERROR_SUCCESS) {
        DebugPrint("MUTEST: Failed to write MU name with %x\n", error);
    }

    error = XMUNameFromDriveLetter(DriveLetter, MUName, MAX_MUNAME);

    if (error == ERROR_SUCCESS) {

        if (lstrcmpW(MUName, L"Test Name") != 0) {
            DebugPrint("MUTEST: Failed to read back correct MU name\n");
        }

    } else {
        DebugPrint("MUTEST: Failed to read MU name with %x\n", error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\client\xirm_client.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xirm_client.c

Abstract:

    Remote XInput - client code

--*/

#include "precomp.h"
#include "xinput_remote.h"

// Module name string for the debug spews
#define MYMODNAME "XIRM"

// Global critical section for synchronization
CRITICAL_SECTION XIrmCriticalSection;
#define XIrmUnlock() LeaveCriticalSection(&XIrmCriticalSection)
#define XIrmLockAndServiceNet() do { \
            EnterCriticalSection(&XIrmCriticalSection); \
            XIrmNetService(); \
        } while (0)

//
// Current state of input devices
//
DWORD XIrmCurrentDevices;
DWORD XIrmDeviceInsertions;
DWORD XIrmDeviceRemovals;

#define XIRM_OPENPORT 0x80000000
struct DeviceData {
    DWORD cookie;
    XINPUT_STATE states;
    XINPUT_CAPABILITIES devicecaps;
} XIrmDevices[XIRM_PORTMAX];

#define XIrmCookieFromHandle(hdev) (((DWORD) (hdev) >> XIRM_PORTSHIFT) | XIRM_OPENPORT)
#define XIrmPortFromHandle(hdev) ((DWORD) (hdev) & (XIRM_PORTMAX-1))
#define XIrmMakeHandle(port) ((HANDLE) ((XIrmDevices[port].cookie << XIRM_PORTSHIFT) | (port)))
#define XIrmIsDeviceOpen(port) ((XIrmDevices[port].cookie & XIRM_OPENPORT) != 0)
#define XIrmMarkDeviceAsOpened(port) (XIrmDevices[port].cookie |= XIRM_OPENPORT)
#define XIrmMarkDeviceAsClosed(port) (XIrmDevices[port].cookie &= ~XIRM_OPENPORT)

//
// Current state of the keyboard
//
#define XIRM_KEYBOARD_HANDLE 0x7fffffff
DWORD XIrmKeyboardDevice;
DWORD XIrmKeyboardPending;
HANDLE XIrmKeyboardHandle;

XINPUT_DEBUG_KEYSTROKE* XIrmKeyboardQueue;
DWORD XIrmKeyboardQueueLimit = 32;
DWORD XIrmKeyboardQueueCount;
DWORD XIrmKeyboardQueueHead;
DWORD XIrmKeyboardQueueTail;
DWORD XIrmKeyboardQueueFlags =
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN |
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT |
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP;

// Current sequence numbers for the client and the server
DWORD XIrmClientSeq;
DWORD XIrmServerSeq;

// Socket for connection with the server
SOCKET XIrmSock;
CHAR XIrmPacketBuf[XIRM_MAX_PACKET_SIZE];

//
// Send an acknowledgement packet to the server
//  NOTE: ACK packets don't affect the send sequence number.
//
BOOL
XIrmSendAck()
{
    XIrmPacketHeader pkt;
    INT err;

    pkt.type = PKTTYPE_ACK;
    pkt.sendseq = XIrmClientSeq;
    pkt.ackseq = XIrmServerSeq;

    err = send(XIrmSock, (CHAR*) &pkt, sizeof(pkt), 0);
    if (err != sizeof(pkt)) {
        XDBGWRN(MYMODNAME, "send ack failed: %d, %d", err, GetLastError());
        return FALSE;
    }

    return TRUE;
}

//
// Send a SET_STATE packet to the server
//
DWORD
XIrmSendSetState(
    DWORD port,
    XINPUT_FEEDBACK* feedback
    )
{
    XIrmPacketSetState pkt;
    INT count;

    pkt.header.type = PKTTYPE_SET_STATE;
    pkt.header.sendseq = XIrmClientSeq;
    pkt.header.ackseq = XIrmServerSeq;
    pkt.port = port;
    pkt.feedback = *feedback;

    count = send(XIrmSock, (CHAR*) &pkt, sizeof(pkt), 0);
    return (count == SOCKET_ERROR) ? WSAGetLastError() : ERROR_SUCCESS;
}

//
// Handle the packet that has validated to be in sequence
//
VOID
XIrmHandlePacket(
    XIrmPacketHeader* pkt,
    INT pktlen
    )
{
    INT devcount, port;
    DWORD masks;
    XIrmPacketDeviceChanges* devchgpkt;
    XIrmPacketStateChanges* stchgpkt;
    XINPUT_CAPABILITIES* devcaps;
    XINPUT_STATE* states;
    XINPUT_DEBUG_KEYSTROKE* key;

    // Increment the next expected server sequence number
    XIrmServerSeq++;

    switch (pkt->type) {
    case PKTTYPE_DEVICE_CHANGES:
        pktlen -= offsetof(XIrmPacketDeviceChanges, devicecaps);
        ASSERT(pktlen >= 0);
        devchgpkt = (XIrmPacketDeviceChanges*) pkt;
        devcount = XIrmCountDevices(devchgpkt->active_devices);
        ASSERT(pktlen == devcount * sizeof(XINPUT_CAPABILITIES));

        XIrmCurrentDevices = masks = devchgpkt->active_devices;
        XIrmDeviceInsertions = devchgpkt->insertions;
        XIrmDeviceRemovals = devchgpkt->removals;

        // NOTE: we don't report keyboard removal.
        if ((devchgpkt->keyboard_device & 1) && !XIrmKeyboardDevice)
            XIrmKeyboardDevice = XIrmKeyboardPending = 1;

        // Update the cached device capabilities information
        devcaps = devchgpkt->devicecaps;
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (masks & (1 << port))
                XIrmDevices[port].devicecaps = *devcaps++;
        }

        // If there is any change for a port, change its cookie
        masks = XIrmDeviceInsertions | XIrmDeviceRemovals;
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (masks & (1 << port))
                XIrmDevices[port].cookie += 1;

            if (XIrmDeviceRemovals & (1 << port)) {
                struct DeviceData* device = &XIrmDevices[port];
                memset(&device->states, 0, sizeof(device->states));
                memset(&device->devicecaps, 0, sizeof(device->devicecaps));
            }
        }
        break;

    case PKTTYPE_STATE_CHANGES:
        pktlen -= offsetof(XIrmPacketStateChanges, states);
        ASSERT(pktlen >= 0);
        stchgpkt = (XIrmPacketStateChanges*) pkt;
        devcount = XIrmCountDevices(stchgpkt->device_masks);
        ASSERT(pktlen == devcount * sizeof(XINPUT_STATE));

        states = stchgpkt->states;
        masks = stchgpkt->device_masks;
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (masks & (1 << port))
                XIrmDevices[port].states = *states++;
        }
        break;

    case PKTTYPE_KEYSTROKE:
        if (!XIrmKeyboardHandle) break;

        ASSERT(pktlen == sizeof(XIrmPacketKeystroke));
        key = &((XIrmPacketKeystroke*) pkt)->keystroke;

        // Filter out unwanted keystrokes
        if (!(key->Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP) &&
            !(XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN) ||
            (key->Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP) &&
            !(XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP) ||
            (key->Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT) &&
            !(XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT) ||
            (key->Ascii == 0) &&
            (XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY))
            break;

        // Queue up the keystroke
        if (XIrmKeyboardQueueCount < XIrmKeyboardQueueLimit) {
            XIrmKeyboardQueueCount++;
            XIrmKeyboardQueue[XIrmKeyboardQueueTail++] = *key;
            if (XIrmKeyboardQueueTail == XIrmKeyboardQueueLimit)
                XIrmKeyboardQueueTail;
        }
        break;

    default:
        XDBGWRN(MYMODNAME, "server packet type? %d", pkt->type);
        break;
    }
}

//
// Process a received packet from the server
//

// Cached list of packets that were received out-of-sequence
typedef struct _XIrmRecvBuf {
    struct _XIrmRecvBuf* next;
    INT datalen;
    XIrmPacketHeader data;
} XIrmRecvBuf;
XIrmRecvBuf* XIrmRecvq;

INT
XIrmProcessReceivedPacket(
    INT pktlen
    )
{
    XIrmPacketHeader* pkt = (XIrmPacketHeader*) XIrmPacketBuf;
    INT index, acks;

    if (pkt->ackseq != XIrmClientSeq) {
        XDBGTRC(MYMODNAME, "server packet ack? %u, %u", pkt->ackseq, XIrmClientSeq);
    }

    index = (INT) (pkt->sendseq - XIrmServerSeq);
    if (index == 0) {
        // Normal case - in sequence packet
        acks = 1;
        XIrmHandlePacket(pkt, pktlen);

        while (XIrmRecvq && XIrmRecvq->data.sendseq == XIrmServerSeq) {
            XIrmRecvBuf* p = XIrmRecvq;
            XIrmRecvq = p->next;
            acks++;

            XIrmHandlePacket(&p->data, p->datalen);
            free(p);
        }
    } else if (index > 0 && index < XIRM_SEND_WINDOW) {
        // Out-of-sequence but inside the send window
        XIrmRecvBuf** list;
        XDBGTRC(MYMODNAME, "server packet out-of-seq: %u, %u", pkt->sendseq, XIrmServerSeq);

        list = &XIrmRecvq;
        while (*list && (*list)->data.sendseq < pkt->sendseq)
            list = &(*list)->next;
        
        if (*list && (*list)->data.sendseq == pkt->sendseq) {
            // duplicate packet - just throw it away
            XDBGTRC(MYMODNAME, "server packet duplicate");
        } else {
            XIrmRecvBuf* p;
            p = (XIrmRecvBuf*) malloc(offsetof(XIrmRecvBuf, data) + pktlen);
            if (p) {
                *list = p;
                p->next = NULL;
                p->datalen = pktlen;
                memcpy(&p->data, pkt, pktlen);
            } else {
                XDBGWRN(MYMODNAME, "out of memory");
            }
        }

        // Send an ack immediately
        acks = XIRM_DELAY_ACKS;
    } else {
        XDBGTRC(MYMODNAME,
            "server packet unexpected: %u, %u",
            pkt->sendseq,
            XIrmServerSeq);

        acks = 0;
    }

    return acks;
}

//
// Service network traffic from the server
//
VOID
XIrmNetService()
{
    // NOTE: we assume the caller has acquired the global lock at this point.
    u_long bytesavail;
    INT err, count;
    INT delayacks = 0;

    // Check if we have any data to read
    while (TRUE) {
        err = ioctlsocket(XIrmSock, FIONREAD, &bytesavail);
        if (err == NO_ERROR) {
            if (!bytesavail) break;
            count = recv(XIrmSock, XIrmPacketBuf, sizeof(XIrmPacketBuf), 0);
            if (count >= sizeof(XIrmPacketHeader)) {
                delayacks += XIrmProcessReceivedPacket(count);
                if (delayacks >= XIRM_DELAY_ACKS && XIrmSendAck())
                    delayacks = 0;
            } else {
                XDBGTRC(MYMODNAME, "server packet size? %d, %d", count, GetLastError());
            }
        } else {
            XDBGWRN(MYMODNAME, "ioctlsocket failed: %d", GetLastError());
            break;
        }
    }

    // Send the last ACK if needed
    if (delayacks) {
        XIrmSendAck();
    }
}

//
// Send out client-init broadcasts and wait for a server connection
//
VOID
XIrmFindServer()
{
    INT err, opt;
    struct sockaddr_in sockname;
    XIrmPacketClientInit initpkt;
    DWORD namelen;
    HRESULT hr;
    struct timeval timeout;
    fd_set readfds;

    // BUGBUG - spew out a debug message even on free builds
    DbgPrint("XINPUT_REMOTE: Trying to connect to a server...\n");

    // Enable broadcast on the socket
    opt = 1;
    err = setsockopt(XIrmSock, SOL_SOCKET, SO_BROADCAST, (CHAR*) &opt, sizeof(opt));
    ASSERT(err == NO_ERROR);

    XIrmClientSeq = XIrmGetISN();

    // Assemble the client-init packet
    memset(&initpkt, 0, sizeof(initpkt));
    initpkt.header.type = PKTTYPE_CLIENT_INIT;
    initpkt.header.sendseq = XIrmClientSeq++;
    initpkt.header.ackseq = 0;
    initpkt.protocol_version = XIRM_PROTOCOL_VERSION;

    // Get xbox name
    namelen = sizeof(initpkt.client_name);
    hr = DmGetXboxName(initpkt.client_name, &namelen);
    if (FAILED(hr)) {
        memset(initpkt.client_name, 0, sizeof(initpkt.client_name));
    }

    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    timeout.tv_sec = XIRM_CLIENT_INIT_INTERVAL / 1000;
    timeout.tv_usec = (XIRM_CLIENT_INIT_INTERVAL % 1000) * 1000;

    while (TRUE) {
        XDBGTRC(MYMODNAME, "broadcast client-init: %u", initpkt.header.sendseq);

        // Broadcast the client-init packet
        sockname.sin_port = htons(XIRM_SERVER_PORT);
        sockname.sin_addr.s_addr = INADDR_BROADCAST;
        err = sendto(XIrmSock,
                     (CHAR*) &initpkt,
                     sizeof(initpkt),
                     0,
                     (struct sockaddr*) &sockname,
                     sizeof(sockname));
        ASSERT(err != SOCKET_ERROR);

        // Wait for a server to respond
        FD_ZERO(&readfds);
        FD_SET(XIrmSock, &readfds);
        err = select(1, &readfds, NULL, NULL, &timeout);

        if (err == 1) {
            // Read the packet from the server
            XIrmPacketHeader* pkt = (XIrmPacketHeader*) XIrmPacketBuf;
            INT fromlen = sizeof(sockname);
            INT count = recvfrom(
                            XIrmSock,
                            XIrmPacketBuf,
                            sizeof(XIrmPacketBuf),
                            0, 
                            (struct sockaddr*) &sockname,
                            &fromlen);

            if (count >= sizeof(*pkt)) {
                if (pkt->type == PKTTYPE_SERVER_INIT && pkt->ackseq == XIrmClientSeq) {
                    // Great - we got a connection
                    // Remember the server sequence number and proceed
                    XIrmServerSeq = pkt->sendseq+1;
                    break;
                } else {
                    XDBGTRC(MYMODNAME, "server packet type/ack? %d %u", pkt->type, pkt->ackseq);
                }
            } else {
                XDBGTRC(MYMODNAME, "server packet size? %d, %d", count, GetLastError());
            }
        } else if (err != 0) {
            XDBGWRN(MYMODNAME, "select failed: %d, %d", err, GetLastError());
        }
    }

    // Disable broadcast on the socket
    opt = 0;
    err = setsockopt(XIrmSock, SOL_SOCKET, SO_BROADCAST, (CHAR*) &opt, sizeof(opt));
    ASSERT(err == NO_ERROR);

    // Now connect the socket to the server
    err = connect(XIrmSock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);
    XDBGTRC(MYMODNAME, "connected to server: %u.%u.%u.%u", sockname.sin_addr.S_un.S_un_b.s_b1, sockname.sin_addr.S_un.S_un_b.s_b2, sockname.sin_addr.S_un.S_un_b.s_b3, sockname.sin_addr.S_un.S_un_b.s_b4);

    // Acknowledge the server-init packet
    XIrmSendAck();

    // Wait for a while to receive the initial packets from the server
    FD_ZERO(&readfds);
    FD_SET(XIrmSock, &readfds);
    timeout.tv_sec = XIRM_RETRANSMIT_TIMEOUT / 1000;
    timeout.tv_usec = (XIRM_RETRANSMIT_TIMEOUT % 1000) * 1000;

    err = select(1, &readfds, NULL, NULL, &timeout);

    if (err == 1) {
        XIrmNetService();
    } else if (err != 0) {
        XDBGWRN(MYMODNAME, "select failed: %d, %d", err, GetLastError());
    }
}

//------------------------------------------------------------------
// Public APIs
//------------------------------------------------------------------

VOID WINAPI
XInitDevices(
    IN DWORD NumDeviceTypes,
    IN PXDEVICE_PREALLOC_TYPE DeviceTypes
    )
{
    INT err;
    WSADATA wsadata;
    struct sockaddr_in sockname;

    XDBGENT(MYMODNAME, "XInitDevices: %d %x", NumDeviceTypes, DeviceTypes);

    InitializeCriticalSection(&XIrmCriticalSection);

    // Initialize the network stack
    err = XNetStartup(NULL);
    ASSERT(err == NO_ERROR);

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    XIrmSock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(XIrmSock != INVALID_SOCKET);

    // Bind the socket to a randomly-chosen port
    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = bind(XIrmSock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    // Send out client-init broadcasts and wait for a server connection
    XIrmFindServer();
}

DWORD WINAPI
XGetDevices(
    IN PXPP_DEVICE_TYPE DeviceType
    )
{
    DWORD devices;

    XDBGENT(MYMODNAME, "XGetDevices: %x", DeviceType);

    XIrmLockAndServiceNet();
    if (DeviceType == XDEVICE_TYPE_GAMEPAD) {
        devices = XIrmCurrentDevices;
        XIrmDeviceInsertions = XIrmDeviceRemovals = 0;
    } else if (DeviceType == XDEVICE_TYPE_DEBUG_KEYBOARD) {
        devices = XIrmKeyboardDevice;
        XIrmKeyboardPending = 0;
    } else {
        devices = 0;
    }
    XIrmUnlock();

    return devices;
}

BOOL WINAPI
XGetDeviceChanges(
    IN PXPP_DEVICE_TYPE DeviceType,
    OUT PDWORD pInsertions,
    OUT PDWORD pRemovals
    )
{
    BOOL changed;

    XDBGENT(MYMODNAME, "XGetDeviceChanges: %x %x %x", DeviceType, pInsertions, pRemovals);

    XIrmLockAndServiceNet();
    if (DeviceType == XDEVICE_TYPE_GAMEPAD) {
        *pInsertions = XIrmDeviceInsertions;
        *pRemovals = XIrmDeviceRemovals;
        changed = (XIrmDeviceInsertions | XIrmDeviceRemovals) != 0;
        XIrmDeviceInsertions = XIrmDeviceRemovals = 0;
    } else if (DeviceType == XDEVICE_TYPE_DEBUG_KEYBOARD) {
        // Note: we don't have keyboard insertion and removal.
        *pInsertions = XIrmKeyboardPending;
        *pRemovals = 0;
        changed = XIrmKeyboardPending != 0;
        XIrmKeyboardPending = 0;
    } else {
        changed = FALSE;
    }
    XIrmUnlock();

    return changed;
}

HANDLE WINAPI
XInputOpen(
    IN PXPP_DEVICE_TYPE XppDeviceType,
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
    )
{
    HANDLE hdev;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputOpen: %x %d %d %x",
        XppDeviceType,
        dwPort,
        dwSlot,
        pPollingParameters);

    XIrmLockAndServiceNet();

    if (XppDeviceType == XDEVICE_TYPE_GAMEPAD) {
        ASSERT(dwPort >= XDEVICE_PORT0 &&
               dwPort <= XDEVICE_PORT3 &&
               dwSlot == XDEVICE_NO_SLOT);

        if (XIrmIsDeviceOpen(dwPort)) {
            // The specified port is already open
            err = ERROR_BUSY;
        } else if (XIrmCurrentDevices & (1 << dwPort)) {
            XIrmMarkDeviceAsOpened(dwPort);
            hdev = XIrmMakeHandle(dwPort);
            err = ERROR_SUCCESS;
        } else {
            // The specified port doesn't have anything plugged in
            err = ERROR_DEVICE_NOT_CONNECTED;
        }
    } else if (XppDeviceType == XDEVICE_TYPE_DEBUG_KEYBOARD) {
        // We support at most one keyboard
        ASSERT(dwPort == XDEVICE_PORT0 && dwSlot == XDEVICE_NO_SLOT);
        if (XIrmKeyboardHandle) {
            err = ERROR_BUSY;
        } else if (XIrmKeyboardDevice == 0) {
            err = ERROR_DEVICE_NOT_CONNECTED;
        } else if (!XIrmKeyboardQueue) {
            // XInputDebugInitKeyboardQueue must be called first
            err = ERROR_INVALID_STATE;
        } else {
            hdev = XIrmKeyboardHandle = (HANDLE) XIRM_KEYBOARD_HANDLE;
            err = ERROR_SUCCESS;
        }
    } else {
        err = ERROR_CALL_NOT_IMPLEMENTED;
    }

    XIrmUnlock();

    if (err == ERROR_SUCCESS) {
        return hdev;
    } else {
        SetLastError(err);
        return NULL;
    }
}

VOID WINAPI
XInputClose(
    IN HANDLE hDevice
    )
{
    DWORD port;

    XDBGENT(MYMODNAME, "XInputClose: %x", hDevice);

    if (hDevice == NULL) return;
    XIrmLockAndServiceNet();

    if (hDevice == XIrmKeyboardHandle) {
        // Close keyboard device
        XIrmKeyboardHandle = NULL;
        XIrmKeyboardQueueCount =
        XIrmKeyboardQueueHead =
        XIrmKeyboardQueueTail = 0;
    } else {
        port = XIrmPortFromHandle(hDevice);
        if (XIrmIsDeviceOpen(port)) {
            XIrmMarkDeviceAsClosed(port);
        } else {
            XDBGWRN(MYMODNAME, "port already closed: %d", port);
        }
    }

    XIrmUnlock();
}

DWORD WINAPI
XInputGetCapabilities(
    IN HANDLE hDevice,
    OUT PXINPUT_CAPABILITIES pCapabilities
    )
{
    DWORD port;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputGetCapabilities: %x %x", hDevice, pCapabilities);
    ASSERT(hDevice != NULL);
    
    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) == XIrmDevices[port].cookie) {
        *pCapabilities = XIrmDevices[port].devicecaps;
    } else {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputGetState(
    IN HANDLE hDevice,
    OUT PXINPUT_STATE pState
    )
{
    DWORD port;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputGetState: %x %x", hDevice, pState);
    ASSERT(hDevice != NULL);
    
    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) == XIrmDevices[port].cookie) {
        *pState = XIrmDevices[port].states;
    } else {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputSetState(
    IN HANDLE hDevice,
    OUT PXINPUT_FEEDBACK pFeedback
    )
{
    DWORD port, err;

    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) == XIrmDevices[port].cookie) {
        err = XIrmSendSetState(port, pFeedback);
    } else {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputPoll(
    IN HANDLE hDevice
    )
{
    DWORD port;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputPoll: %x", hDevice);
    ASSERT(hDevice != NULL);

    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) != XIrmDevices[port].cookie) {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputDebugInitKeyboardQueue(
    IN PXINPUT_DEBUG_KEYQUEUE_PARAMETERS pParameters OPTIONAL
    )
{
    DWORD err;
    XIrmLockAndServiceNet();

    if (XIrmKeyboardQueue) {
        // Keyboard already initialized
        err = ERROR_ALREADY_INITIALIZED;
    } else {
        if (pParameters) {
            XIrmKeyboardQueueFlags = pParameters->dwFlags;
            if (pParameters->dwQueueSize)
                XIrmKeyboardQueueLimit = pParameters->dwQueueSize;
        }

        XIrmKeyboardQueue = (XINPUT_DEBUG_KEYSTROKE*)
            malloc(XIrmKeyboardQueueLimit*sizeof(XINPUT_DEBUG_KEYSTROKE));
        err = XIrmKeyboardQueue ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
    }
    
    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputDebugGetKeystroke(
    OUT PXINPUT_DEBUG_KEYSTROKE pKeystroke
    )
{
    DWORD err;

    ASSERT(pKeystroke != NULL);
    XIrmLockAndServiceNet();

    if (!XIrmKeyboardHandle) {
        // Must have called XInputDebugInitKeyboardQueue and XInputOpen
        err = ERROR_NOT_READY;
    } else if (XIrmKeyboardQueueCount == 0) {
        err = ERROR_HANDLE_EOF;
    } else {
        XIrmKeyboardQueueCount--;
        *pKeystroke = XIrmKeyboardQueue[XIrmKeyboardQueueHead++];
        if (XIrmKeyboardQueueHead == XIrmKeyboardQueueLimit)
            XIrmKeyboardQueueHead = 0;

        err = ERROR_SUCCESS;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XMountMUA(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT POCHAR pchDrive
    )
{
    XDBGWRN(MYMODNAME, "XMountMU not supported");
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
XUnmountMU(
    IN DWORD dwPort,
    IN DWORD dwSlot
    )
{
    XDBGWRN(MYMODNAME, "XUnmountMU not supported");
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
XMUPortFromDriveLetterA(
    OCHAR chDrive
    )
{
    XDBGWRN(MYMODNAME, "XMUPortFromDriveLetter not supported");
    return (DWORD) -1;
}

DWORD WINAPI
XMUSlotFromDriveLetterA(
    OCHAR chDrive
    )
{
    XDBGWRN(MYMODNAME, "XMUSlotFromDriveLetter not supported");
    return (DWORD) -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\server\precomp.h ===
#define DEBUG_KEYBOARD

#include <stddef.h>
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\client\test\xirmtest.c ===
#define DEBUG_KEYBOARD

#include <xtl.h>
#include <xdbg.h>

#ifdef D3DTEST
//
// One-time D3D initialization
//
#define CHECKHR(expr) do { hr = (expr); ASSERT(SUCCEEDED(hr)); } while (0)
IDirect3DDevice8* d3ddev;
VOID D3DInitialize()
{
    D3DPRESENT_PARAMETERS d3dpp;
    HRESULT hr;

    IDirect3D8* d3d = Direct3DCreate8(D3D_SDK_VERSION);
    ASSERT(d3d != NULL);

    memset(&d3dpp, 0, sizeof(d3dpp));
    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    CHECKHR(IDirect3D8_CreateDevice(d3d,
                D3DADAPTER_DEFAULT,
                D3DDEVTYPE_HAL,
                NULL,
                D3DCREATE_HARDWARE_VERTEXPROCESSING,
                &d3dpp,
                &d3ddev));

    IDirect3D8_Release(d3d);

    CHECKHR(IDirect3DDevice8_Clear(d3ddev,
                0,
                NULL,
                D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                0x00000080,
                1.0,
                0));

    CHECKHR(IDirect3DDevice8_Present(d3ddev, NULL, NULL, NULL, NULL));
    IDirect3DDevice8_BlockUntilIdle(d3ddev);
}
#endif // D3DTEST


ULONG __cdecl DbgPrint(CHAR*, ...);

#define MAXPORTS 4
struct DeviceData {
    HANDLE handle;
    XINPUT_STATE states;
    XINPUT_CAPABILITIES devicecaps;
} devices[MAXPORTS];
DWORD active_device_masks;
HANDLE keyboard;

CHAR* GetDeviceType(UINT type)
{
    static CHAR* typestrs[3] = {
        "Gamepad",
        "Joystick",
        "Wheel"
    };

    return (type < 3) ? typestrs[type] : "<Unknown>";
}

VOID DumpThumbField(CHAR* name, SHORT old, SHORT new)
{
    if (old != new) {
        DbgPrint("  %10s: %d\n", name, new);
    }
}

VOID DumpGamepadChanges(XINPUT_GAMEPAD* oldst, XINPUT_GAMEPAD* newst)
{
    static CHAR* dbuttons[8] = {
        "UP",
        "DOWN",
        "LEFT",
        "RIGHT",
        "START",
        "BACK",
        "L-THUMB",
        "R-THUMB"
    };
    static CHAR* abuttons[8] = {
        "A",
        "B",
        "X",
        "Y",
        "BLACK",
        "WHITE",
        "L-TRIGGER",
        "R-TRIGGER"
    };

    INT i;
    DWORD dw0, dw1;

    // digital buttons
    dw0 = oldst->wButtons;
    dw1 = newst->wButtons;
    for (i=0; i < 8; i++) {
        DWORD m0 = dw0 & (1 << i);
        DWORD m1 = dw1 & (1 << i);
        if (m0 != m1) {
            DbgPrint("  %10s %s\n", dbuttons[i], m0 ? "-" : "+");
        }
    }

    // analog buttons
    for (i=0; i < 8; i++) {
        if (oldst->bAnalogButtons[i] != newst->bAnalogButtons[i]) {
            DbgPrint("  %10s %d\n", abuttons[i], newst->bAnalogButtons[i]);
        }
    }

    #define DUMPTHUMBFIELD(name) DumpThumbField(#name, oldst->s##name, newst->s##name)
    DUMPTHUMBFIELD(ThumbLX);
    DUMPTHUMBFIELD(ThumbLY);
    DUMPTHUMBFIELD(ThumbRX);
    DUMPTHUMBFIELD(ThumbRY);
}

VOID ClosePort(DWORD port)
{
    struct DeviceData* device = &devices[port];
    if (device->handle) {
        DbgPrint("Closing port %d...\n", port);
        XInputClose(device->handle);
        memset(device, 0, sizeof(*device));
    }
}

BOOL OpenPort(DWORD port)
{
    struct DeviceData* device = &devices[port];
    DWORD err;

    DbgPrint("Opening port %d...\n", port);
    if (device->handle) {
        DbgPrint("*** Port already open\n");
    }

    device->handle = XInputOpen(
                        XDEVICE_TYPE_GAMEPAD,
                        port,
                        XDEVICE_NO_SLOT,
                        NULL);

    if (device->handle == NULL) {
        DbgPrint("*** XInputOpen failed: %d\n", GetLastError());
        return FALSE;
    }

    err = XInputGetCapabilities(device->handle, &device->devicecaps);
    if (err != ERROR_SUCCESS) {
        DbgPrint("*** XInputGetCapabilities failed: %d\n", err);
        return FALSE;
    }

    DbgPrint("  device type: %s\n", GetDeviceType(device->devicecaps.SubType));
    return TRUE;
}

VOID PollInput()
{
    DWORD insertions, removals;
    DWORD port;
    static XINPUT_FEEDBACK feedback;
    XINPUT_DEBUG_KEYSTROKE key;

    // Check if there has been any device changes
    if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &insertions, &removals)) {
        DbgPrint("Device changes: in = %x out = %x\n", insertions, removals);

        // close devices that have been removed
        for (port=0; port < MAXPORTS; port++) {
            if (removals & (1 << port)) {
                if (devices[port].handle) {
                    ClosePort(port);
                }
            }
        }

        // open devices that have been inserted
        for (port=0; port < MAXPORTS; port++) {
            if (insertions & (1 << port)) {
                if (!OpenPort(port)) {
                    // If we failed to open the port, treat it as not plugged in
                    removals |= (1 << port);
                    insertions &= ~(1 << port);
                    ClosePort(port);
                }
            }
        }

        active_device_masks &= ~removals;
        active_device_masks |= insertions;
        DbgPrint("  active devices: %x\n", active_device_masks);
    }

    // Now for currently inserted devices, update the state information
    for (port=0; port < MAXPORTS; port++) {
        struct DeviceData* device = &devices[port];
        if (device->handle) {
            XINPUT_STATE states;
            DWORD err = XInputGetState(device->handle, &states);
            if (err == ERROR_SUCCESS) {
                if (memcmp(&device->states, &states, sizeof(states)) != 0) {
                    DbgPrint("Input state change: port %d\n", port);
                    DumpGamepadChanges(&device->states.Gamepad, &states.Gamepad);

                    if (states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] !=
                        device->states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X]) {
                        feedback.Rumble.wLeftMotorSpeed =
                            (WORD) states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] << 8;
                        DbgPrint("Rumble-L: %d\n", feedback.Rumble.wLeftMotorSpeed);
                        err = XInputSetState(device->handle, &feedback);
                        if (err != ERROR_SUCCESS) {
                            DbgPrint("*** XInputSetState failed: %d\n", err);
                        }
                    }

                    device->states = states;
                }
            } else {
                DbgPrint("*** XInputGetState failed: %d\n", err);
            }
        }
    }

    // Poll keystrokes
    #define DumpKeyFlags(f) \
            if (key.Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_##f) { DbgPrint(" %s", #f); }
    while (XInputDebugGetKeystroke(&key) == ERROR_SUCCESS) {
        DbgPrint("Keystroke: ");
        DbgPrint(isprint(key.Ascii) ? "%c " : "%02x", key.Ascii);
        DbgPrint(" %02x", key.VirtualKey);
        DumpKeyFlags(KEYUP);
        DumpKeyFlags(REPEAT);
        DumpKeyFlags(CTRL);
        DumpKeyFlags(SHIFT);
        DumpKeyFlags(ALT);
        DumpKeyFlags(CAPSLOCK);
        DumpKeyFlags(NUMLOCK);
        DumpKeyFlags(SCROLLLOCK);
        DbgPrint("\n");
    }
}

VOID InitKeyboardDevice()
{
    DWORD err, devices;

    err = XInputDebugInitKeyboardQueue(NULL);
    if (err == ERROR_SUCCESS) {
        devices = XGetDevices(XDEVICE_TYPE_DEBUG_KEYBOARD);
        if (devices & 1) {
            keyboard = XInputOpen(
                            XDEVICE_TYPE_DEBUG_KEYBOARD,
                            XDEVICE_PORT0,
                            XDEVICE_NO_SLOT,
                            NULL);
        }
    }

    if (keyboard) DbgPrint("Keyboard initialized.\n");
}

void __cdecl main()
{
    DbgPrint("Starting XInput Remote tests...\n");
    XInitDevices(0, NULL);
    InitKeyboardDevice();

    #ifdef D3DTEST
    D3DInitialize();
    #endif

    while (TRUE) {
        PollInput();
        Sleep(20);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\inc\xinput_remote.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xinput_remote.h

Abstract:

    Remote XInput protocol declarations

--*/

#ifndef _XINPUT_REMOTE_H
#define _XINPUT_REMOTE_H

//
// XIrm packet format
//
typedef struct _XIrmPacketHeader {
    // Packet type
    DWORD type;

    #define PKTTYPE_CLIENT_INIT     1
    #define PKTTYPE_SERVER_INIT     2
    #define PKTTYPE_DEVICE_CHANGES  3
    #define PKTTYPE_STATE_CHANGES   4
    #define PKTTYPE_SET_STATE       5
    #define PKTTYPE_ACK             6
    #define PKTTYPE_KEYSTROKE       7

    // Sender sequence number
    DWORD sendseq;

    // Acknowledgement sequence number
    DWORD ackseq;
} XIrmPacketHeader;

// for PKTTYPE_CLIENT_INIT
#define XIRM_MACHINE_NAME_MAXLEN 32
#define XIRM_CLIENT_INIT_INTERVAL 1000 // msecs
typedef struct _XIrmPacketClientInit {
    XIrmPacketHeader header;
    DWORD protocol_version;
    CHAR client_name[XIRM_MACHINE_NAME_MAXLEN];
} XIrmPacketClientInit;
        
// for PKTTYPE_DEVICE_CHANGES
typedef struct _XIrmPacketDeviceChanges {
    XIrmPacketHeader header;
    DWORD keyboard_device;
    DWORD active_devices;
    DWORD insertions;
    DWORD removals;
    XINPUT_CAPABILITIES devicecaps[1];
} XIrmPacketDeviceChanges;

// for PKTTYPE_STATE_CHANGES
typedef struct _XIrmPacketStateChanges {
    XIrmPacketHeader header;
    DWORD device_masks;
    XINPUT_STATE states[1];
} XIrmPacketStateChanges;

// for PKTTYPE_SET_STATE
typedef struct _XIrmPacketSetState {
    XIrmPacketHeader header;
    DWORD port;
    XINPUT_FEEDBACK feedback;
} XIrmPacketSetState;

// for PKTTYPE_KEYSTROKE
typedef struct _XIrmPacketKeystroke {
    XIrmPacketHeader header;
    XINPUT_DEBUG_KEYSTROKE keystroke;
} XIrmPacketKeystroke;


//
// Protocol version number
//
#define XIRM_PROTOCOL_VERSION 0x00010001

//
// UDP port numbers used by XInput remote
//
#define XIRM_SERVER_PORT 8873

//
// Send retransmission timeout (in msec)
//
#define XIRM_RETRANSMIT_TIMEOUT 500
#define XIRM_RETRANSMIT_RETRY 3

//
// Send window size, i.e. number of packets that can be sent
// before we must receive an acknowledgement
//
#define XIRM_SEND_WINDOW 8

//
// Number of packets that can be received before
// we must send out an acknowledgement
//
#define XIRM_DELAY_ACKS 4

//
// Maximum packet size
//
#define XIRM_MAX_PACKET_SIZE 1024

//
// Generate a random initial sequence number
//
__inline DWORD XIrmGetISN() {
    DWORD isn;
    FILETIME filetime;

    // Get the current CPU cycle count
    __asm {
        rdtsc
        mov isn, eax
    }

    // XOR with the current time
    GetSystemTimeAsFileTime(&filetime);
    return isn ^ filetime.dwLowDateTime;
}

//
// Max number of supported devices
//
#define XIRM_PORTMAX    4   // must be a power of 2
#define XIRM_PORTSHIFT  2

// Count the number of device mask bits
__inline INT XIrmCountDevices(DWORD device_masks) {
    INT count = 0;
    DWORD i = 1 << (XIRM_PORTMAX-1);
    do {
        if (device_masks & i) count++;
        i = i >> 1;
    } while (i);
    return count;
}

#endif // !_XINPUT_REMOTE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\server\list.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    list.h

Abstract:

    Macros for manipulating linked lists

Notes:

    Copied here from ntrtl.h ...

--*/

#pragma once

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\win2k\xboxstub.h ===
#pragma once

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
// XInput types
//
#include <PSHPACK1.H>

typedef struct _XINPUT_GAMEPAD
{
    WORD    wButtons;
    BYTE    bAnalogButtons[8];
    SHORT   sThumbLX;
    SHORT   sThumbLY;
    SHORT   sThumbRX;
    SHORT   sThumbRY;
} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;

#define XINPUT_GAMEPAD_DPAD_UP          0x00000001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x00000002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x00000004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x00000008
#define XINPUT_GAMEPAD_START            0x00000010
#define XINPUT_GAMEPAD_BACK             0x00000020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x00000040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x00000080

#define XINPUT_GAMEPAD_A                0
#define XINPUT_GAMEPAD_B                1
#define XINPUT_GAMEPAD_X                2
#define XINPUT_GAMEPAD_Y                3
#define XINPUT_GAMEPAD_BLACK            4
#define XINPUT_GAMEPAD_WHITE            5
#define XINPUT_GAMEPAD_LEFT_TRIGGER     6
#define XINPUT_GAMEPAD_RIGHT_TRIGGER    7

typedef struct _XINPUT_RUMBLE
{
   WORD   wLeftMotorSpeed;
   WORD   wRightMotorSpeed;
} XINPUT_RUMBLE, *PXINPUT_RUMBLE;

typedef struct _XINPUT_STATE
{
    DWORD dwPacketNumber;
    union
    {
        XINPUT_GAMEPAD Gamepad;
    };
} XINPUT_STATE, *PXINPUT_STATE;

#define XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE 58
typedef struct _XINPUT_FEEDBACK_HEADER
{
    DWORD           dwStatus;
    HANDLE OPTIONAL hEvent;
    BYTE            Reserved[XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE];
} XINPUT_FEEDBACK_HEADER, *PXINPUT_FEEDBACK_HEADER;

typedef struct _XINPUT_FEEDBACK
{
    XINPUT_FEEDBACK_HEADER Header;
    union
    {
      XINPUT_RUMBLE              Rumble;
    };
} XINPUT_FEEDBACK, *PXINPUT_FEEDBACK;

typedef struct _XINPUT_CAPABILITIES
{
    BYTE    SubType;
    WORD    Reserved;
    union
    {
      XINPUT_GAMEPAD Gamepad;
    } In;
    union
    {
      XINPUT_RUMBLE Rumble;
    } Out;
} XINPUT_CAPABILITIES, *PXINPUT_CAPABILITIES;

#include <POPPACK.H>

#define XINPUT_DEVSUBTYPE_GC_GAMEPAD	 0x01
#define XINPUT_DEVSUBTYPE_GC_GAMEPAD_ALT 0x02
#define XINPUT_DEVSUBTYPE_GC_WHEEL		 0x10
#define XINPUT_DEVSUBTYPE_KBD_STANDARD   0

typedef struct _XINPUT_DEBUG_KEYSTROKE
{
    BYTE VirtualKey;
    CHAR Ascii;
    BYTE Flags;
} XINPUT_DEBUG_KEYSTROKE, *PXINPUT_DEBUG_KEYSTROKE;

#define XINPUT_DEBUG_KEYSTROKE_FLAG_CTRL       0x01
#define XINPUT_DEBUG_KEYSTROKE_FLAG_SHIFT      0x02
#define XINPUT_DEBUG_KEYSTROKE_FLAG_ALT        0x04
#define XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK   0x08
#define XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK    0x10
#define XINPUT_DEBUG_KEYSTROKE_FLAG_SCROLLLOCK 0x20
#define XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP      0x40
#define XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT     0x80

typedef struct _XINPUT_DEBUG_KEYQUEUE_PARAMETERS
{
    DWORD dwFlags;
    DWORD dwQueueSize;
    DWORD dwRepeatDelay;
    DWORD dwRepeatInterval;
} XINPUT_DEBUG_KEYQUEUE_PARAMETERS, *PXINPUT_DEBUG_KEYQUEUE_PARAMETERS;

#define XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN      0x00000001
#define XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT    0x00000002
#define XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP        0x00000004
#define XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY   0x00000010
#define XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE    0x00000020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\devsys.h ===
#ifndef __DEVSYS_H__
#define __DEVSYS_H__

#ifdef PERFORM_DEVSYS_OPERATIONS
//
//  If development system only operations are on
//  the macros call functions
//

#define OHCD_DEVSYS_CHECK_HARDWARE(_DeviceExtension_)   OHCD_DevSysCheckHardware(_DeviceExtension_);
#define OHCD_DEVSYS_TAKE_CONTROL(_DeviceExtension_) OHCD_DevSysTakeControl(_DeviceExtension_);

// 
// The functions behind the macros
//
VOID
OHCD_DevSysCheckHardware(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

VOID
OHCD_DevSysTakeControl(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

#else

//
//  If development system only operations are off
//  the macros are NOPs.
//
#define OHCD_DEVSYS_CHECK_HARDWARE(_DeviceExtension_)
#define OHCD_DEVSYS_TAKE_CONTROL(_DeviceExtension_)

#endif


#endif//__DEVSYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\server\xirm_server.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xirm_server.c

Abstract:

    XInput remote server program

--*/

#include "precomp.h"
#include "xinput_remote.h"
#include "list.h"

// Our module name for debug spews
#define MYMODNAME "XIRM"

BOOL dosetup;
SOCKET sock, listensock;
HANDLE recvevt;
CHAR recvbuf[XIRM_MAX_PACKET_SIZE];
struct sockaddr_in clientaddr;
#define CLIENTADDR clientaddr.sin_addr.s_addr

BOOL autonetmode;
CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
DWORD connecttime;
DWORD clientisn, clientseq;
DWORD serverseq_una, serverseq_nxt;
INT fastrexmit, rexmit_timer, rexmit_count;
BOOL rexmit_disabled;
LIST_ENTRY sendq;

struct ConnectionRequest {
    DWORD clientisn;
    struct sockaddr_in clientaddr;
    CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
} connection_request;
CRITICAL_SECTION connection_request_lock;

#define ConnectReqLock()    EnterCriticalSection(&connection_request_lock)
#define ConnectReqUnlock()  LeaveCriticalSection(&connection_request_lock)
#define HasPendingConnectReq() (connection_request.clientaddr.sin_addr.s_addr != 0)

__inline BOOL GetPendingConnectReq(struct ConnectionRequest* connreq) {
    ConnectReqLock();
    *connreq = connection_request;
    connection_request.clientaddr.sin_addr.s_addr = 0;
    ConnectReqUnlock();

    return (connreq->clientaddr.sin_addr.s_addr != 0);
}

#define GetSendqHead() ((SendBuf*) sendq.Flink)
#define GetSendqLen() ((INT) (serverseq_nxt - serverseq_una))
#define IsSendqFull() (GetSendqLen() >= XIRM_SEND_WINDOW)
#define IsSendqEmpty() (serverseq_una == serverseq_nxt)

typedef struct _SendBuf {
    LIST_ENTRY links;
    INT datalen;
    XIrmPacketHeader data;
} SendBuf;

DWORD active_device_masks;
DWORD pending_insertions;
DWORD pending_removals;
struct DeviceData {
    HANDLE handle;
    XINPUT_STATE current_states;
    XINPUT_STATE last_states;
    XINPUT_CAPABILITIES devicecaps;
} devices[XIRM_PORTMAX];

//
// Main server loop sampling interval (10 msecs = 100Hz)
//
#define SAMPLING_INTERVAL 10

//
// Read the processor timestamp counter in milliseconds
//
__inline DWORD ReadTimestamp() {
    __asm {
        rdtsc
        mov ebx, 733000
        div ebx
    }
}

//
// Read the client configuration file
//
#define CONFIGFILENAME "d:\\xirmsrv.cfg"

BOOL
ReadConfig()
{
    CHAR buf[256];
    FILE* fin = fopen(CONFIGFILENAME, "r");

    if (!fin) {
        XDBGTRC(MYMODNAME, "cannot open config file");
        return FALSE;
    }

    while (fgets(buf, sizeof(buf), fin)) {
        CHAR *p, *val;
        
        p = strchr(buf, '=');
        if (!p) continue;

        *p++ = '\0';
        while (*p && isspace(*p)) p++;
        val = p;

        while (*p && *p != '\r' && *p != '\n' && !isspace(*p)) p++;
        *p = '\0';

        if (*val == '\0') continue;
        if (strcmp(buf, "name") == 0) {
            if (strlen(val) < XIRM_MACHINE_NAME_MAXLEN) {
                strcpy(clientname, val);
            }
        } else if (strcmp(buf, "ipaddr") == 0) {
            ULONG addr = inet_addr(val);
            if (addr != INADDR_NONE)
                CLIENTADDR = addr;
        }
    }
    fclose(fin);

    XDBGTRC(MYMODNAME, "client config: %s %u.%u.%u.%u", clientname, clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4);
    return (clientname[0] != '\0' || CLIENTADDR != 0);
}

//
// Write the client configuration file
//
BOOL
WriteConfig()
{
    FILE* fout = fopen(CONFIGFILENAME, "w");
    if (!fout) return FALSE;

    fprintf(fout, "name=%s\n", clientname[0] ? clientname : "<NONE>");
    fprintf(fout, "ipaddr=%u.%u.%u.%u\n", clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4);
    fclose(fout);
    return TRUE;
}

//
// Close the specified port
//
VOID ClosePort(DWORD port) {
    struct DeviceData* device = &devices[port];
    if (device->handle) {
        XInputClose(device->handle);
        memset(device, 0, sizeof(*device));
    }
}

//
// Open the specified port
//
BOOL OpenPort(DWORD port) {
    struct DeviceData* device = &devices[port];
    DWORD err;

    ASSERT(device->handle == NULL);
    device->handle = XInputOpen(
                        XDEVICE_TYPE_GAMEPAD,
                        port,
                        XDEVICE_NO_SLOT,
                        NULL);

    if (device->handle == NULL) {
        XDBGWRN(MYMODNAME, "XInputOpen failed: %d", GetLastError());
        return FALSE;
    }

    err = XInputGetCapabilities(device->handle, &device->devicecaps);
    if (err != ERROR_SUCCESS) {
        XDBGWRN(MYMODNAME, "XInputGetCapabilities failed: %d", err);
        return FALSE;
    }

    return TRUE;
}

//
// Poll the input states
//
VOID
PollInput()
{
    DWORD insertions, removals;
    DWORD port;

    // Check if there has been any device changes
    if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &insertions, &removals)) {
        // close devices that have been removed
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (removals & (1 << port)) {
                if (devices[port].handle) {
                    ClosePort(port);
                }
            }
        }

        // open devices that have been inserted
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (insertions & (1 << port)) {
                if (!OpenPort(port)) {
                    // If we failed to open the port, treat it as not plugged in
                    removals |= (1 << port);
                    insertions &= ~(1 << port);
                    ClosePort(port);
                }
            }
        }

        active_device_masks &= ~removals;
        active_device_masks |= insertions;

        pending_removals |= removals;
        pending_insertions &= ~removals;
        pending_insertions |= insertions;
    }

    // Now for currently inserted devices, update the state information
    for (port=0; port < XIRM_PORTMAX; port++) {
        struct DeviceData* device = &devices[port];
        if (device->handle) {
            DWORD err = XInputGetState(device->handle, &device->current_states);
            if (err != ERROR_SUCCESS) {
                XDBGWRN(MYMODNAME, "XInputGetState failed: %d", err);
                device->current_states = device->last_states;
            }
        }
    }
}

//
// Initialize the input module
//
#define MAGIC_KEYCOMBO (XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK)

VOID
InitInput()
{
    DWORD port;

    XInitDevices(0, NULL);
    Sleep(2000);

    // Get the initial device states
    PollInput();

    // Look for the special key combination to enter Setup mode
    for (port=0; port < XIRM_PORTMAX; port++) {
        if (devices[port].handle &&
            devices[port].current_states.Gamepad.wButtons == MAGIC_KEYCOMBO &&
            devices[port].current_states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X]) {
            dosetup = TRUE;
            break;
        }
    }
}

//
// Transmit the first packet in the send queue
//
#define SetRexmitTimer() (rexmit_timer = ReadTimestamp() + XIRM_RETRANSMIT_TIMEOUT)
__inline VOID EnableRexmit() {
    if (rexmit_disabled) {
        rexmit_disabled = FALSE;
        rexmit_count = 1;
    }
}

VOID
SendqXmit(
    SendBuf* sendbuf
    )
{
    INT count;

    count = send(sock, (CHAR*) &sendbuf->data, sendbuf->datalen, 0);
    if (count != sendbuf->datalen) {
        XDBGWRN(MYMODNAME, "send failed: %d, %d", count, GetLastError());
    }

    if (sendbuf == GetSendqHead()) {
        SetRexmitTimer();
    }
    rexmit_count++;
    fastrexmit = 0;
}

//
// Do retransmission if needed
//
VOID
CheckRexmit()
{
    if (rexmit_disabled || IsSendqEmpty()) return;

    if ((INT) (rexmit_timer - ReadTimestamp()) < 0) {
        if (rexmit_count >= XIRM_RETRANSMIT_RETRY) {
            // If too many retries, we assume the client is down
            // and stop retransmitting until we receive a packet
            // from the client or there is an input state change.
            XDBGTRC(MYMODNAME, "client down?");
            rexmit_disabled = TRUE;
        } else {
            SendqXmit(GetSendqHead());
        }
    }
}

//
// Insert a new send buffer to the end of the send queue
// and then transmit it out to the client
//
VOID
InsertSendBuf(
    SendBuf* sendbuf
    )
{
    if (IsListEmpty(&sendq)) rexmit_count = 0;

    InsertTailList(&sendq, &sendbuf->links);
    SendqXmit(sendbuf);
}

//
// Allocate memory buffer for a new outgoing packet
//
SendBuf*
AllocSendBuf(
    INT size
    )
{
    SendBuf* sendbuf = (SendBuf*) malloc(offsetof(SendBuf, data) + size);

    if (sendbuf) {
        sendbuf->datalen = size;
        sendbuf->data.sendseq = serverseq_nxt++;
        sendbuf->data.ackseq = clientseq;
    } else {
        XDBGWRN(MYMODNAME, "out of memory");
    }
    return sendbuf;
}

//
// Send device changes to the client
//
VOID
SendDeviceChanges()
{
    SendBuf* sendbuf;
    XIrmPacketDeviceChanges* devchgpkt;
    XINPUT_CAPABILITIES* devcaps;
    INT pktlen;
    DWORD port;

    // Return immediately if:
    //  there has been no changes, or
    //  the send queue is full
    if ((pending_insertions | pending_removals) == 0 || IsSendqFull())
        return;

    pktlen = offsetof(XIrmPacketDeviceChanges, devicecaps) +
             XIrmCountDevices(active_device_masks) * sizeof(XINPUT_CAPABILITIES);
   
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    devchgpkt = (XIrmPacketDeviceChanges*) &sendbuf->data;
    devchgpkt->header.type = PKTTYPE_DEVICE_CHANGES;
    devchgpkt->active_devices = active_device_masks;
    devchgpkt->insertions = pending_insertions;
    devchgpkt->removals = pending_removals;

    // NOTE: We don't bother with keyboard support on silver box.
    devchgpkt->keyboard_device = 0;

    pending_insertions = pending_removals = 0;
    devcaps = devchgpkt->devicecaps;

    for (port=0; port < XIRM_PORTMAX; port++) {
        if (active_device_masks & (1 << port)) {
            *devcaps++ = devices[port].devicecaps;
        }
    }

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Send input state changes to the client
//
VOID
SendStateChanges()
{
    DWORD port, masks = 0;
    INT pktlen = 0;
    SendBuf* sendbuf;
    XIrmPacketStateChanges* stchgpkt;
    XINPUT_STATE* states;
    
    if (IsSendqFull()) return;

    // Check if there has been any state changes
    for (port=0; port < XIRM_PORTMAX; port++) {
        if (devices[port].handle) {
            ASSERT(active_device_masks & (1 << port));
            if (memcmp(&devices[port].current_states,
                       &devices[port].last_states,
                       sizeof(XINPUT_STATE)) != 0) {
                masks |= (1 << port);
                pktlen++;
            }
        }
    }
    if (masks == 0) return;

    pktlen = offsetof(XIrmPacketStateChanges, states) + pktlen * sizeof(XINPUT_STATE);
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    stchgpkt = (XIrmPacketStateChanges*) &sendbuf->data;
    stchgpkt->header.type = PKTTYPE_STATE_CHANGES;
    stchgpkt->device_masks = masks;
    states = stchgpkt->states;
    for (port=0; port < XIRM_PORTMAX; port++) {
        if (masks & (1 << port)) {
            *states++ = devices[port].last_states = devices[port].current_states;
        }
    }

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Initialize the connection with the client
//
VOID
InitClient(
    struct ConnectionRequest* connreq
    )
{
    SendBuf* sendbuf;
    DWORD port;
    INT err;

    strcpy(clientname, connreq->clientname);
    clientaddr = connreq->clientaddr;

    XDBGTRC(MYMODNAME,
        "connected to client: %s %u.%u.%u.%u:%d",
        clientname,
        clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4,
        ntohs(clientaddr.sin_port));

    err = connect(sock, (struct sockaddr*) &clientaddr, sizeof(clientaddr));
    ASSERT(err == NO_ERROR);

    connecttime = ReadTimestamp();
    rexmit_disabled = FALSE;
    clientisn = connreq->clientisn;
    clientseq = clientisn+1;
    serverseq_una = serverseq_nxt = XIrmGetISN();

    while (!IsListEmpty(&sendq)) {
        LIST_ENTRY* p = RemoveHeadList(&sendq);
        free(p);
    }

    sendbuf = AllocSendBuf(sizeof(XIrmPacketHeader));
    ASSERT(sendbuf != NULL);
    sendbuf->data.type = PKTTYPE_SERVER_INIT;
    InsertSendBuf(sendbuf);

    // Send the initial device caps and states
    pending_insertions = active_device_masks;
    pending_removals = 0;
    for (port=0; port < XIRM_PORTMAX; port++) {
        memset(&devices[port].last_states, 0, sizeof(devices[port].last_states));
    }

    SendDeviceChanges();
    SendStateChanges();
}

//
// Process a set-state packet from the client
//
VOID
ProcessClientSetState(
    XIrmPacketSetState* pkt
    )
{
    static XINPUT_FEEDBACK feedback;
    DWORD err;

    if (pkt->port < XIRM_PORTMAX &&
        devices[pkt->port].handle &&
        feedback.Header.dwStatus != ERROR_IO_PENDING) {
        feedback = pkt->feedback;
        err = XInputSetState(devices[pkt->port].handle, &feedback);
        if (err != ERROR_SUCCESS &&
            err != ERROR_IO_PENDING &&
            err != ERROR_NOT_SUPPORTED) {
            XDBGWRN(MYMODNAME, "XInputSetState failed: %d", err);
        }
    }
}

//
// Check to see if we should serve an incoming connection request from a client
//
__inline BOOL IsAutonetAddr(ULONG addr) {
    // autonet address range is 169.254.x.x/16
    addr = ntohl(addr);
    return (addr & 0xffff0000) == 0xa9fe0000;
}

INT
MatchClient(
    CHAR* name,
    ULONG addr
    )
{
    XNADDR  XnAddr;
    static struct in_addr myaddr;

    // Try name match first
    if (clientname[0] && strcmp(clientname, name) == 0) return 1;

    // Then try explicit address match
    if (CLIENTADDR && CLIENTADDR == addr) return 2;

    // Now check to see if both client and server are using autonet addresses
    if (IsAutonetAddr(addr)) {
        if (myaddr.s_addr == 0) {
            XNetGetTitleXnAddr(&XnAddr);
            CopyMemory(&myaddr, &XnAddr.ina, sizeof(myaddr));
        }
        if (IsAutonetAddr(myaddr.s_addr)) return 3;
    }

    return 0;
}

//
// Process a client-init packet from the client
//
VOID
ProcessClientInit()
{
    struct ConnectionRequest connreq;

    if (GetPendingConnectReq(&connreq) &&
        MatchClient(connreq.clientname, connreq.clientaddr.sin_addr.s_addr)) {
        // Figure out how long has it been since the last connect
        INT time = ReadTimestamp() - connecttime;
        if (connreq.clientisn == clientisn && time >= 0 && time <= 3000) {
            // The packet is a duplicate - just drop it
        } else {
            // The client must have rebooted, reestablish connection
            XDBGTRC(MYMODNAME, "client must have rebooted");
            InitClient(&connreq);
        }
    }
}

//
// Process an acknowledgement packet from the client
//
VOID
ProcessClientAck(
    XIrmPacketHeader* pkt
    )
{
    DWORD ack;
    INT index, sent;

    ack = pkt->ackseq;
    index = (INT) (ack - serverseq_una);
    sent = GetSendqLen();

    if (index > 0 && index <= sent) {
        // The acknowledgement is valid
        ASSERT(!IsListEmpty(&sendq));
        serverseq_una = ack;

        do {
            SendBuf* sendbuf = GetSendqHead();
            if (sendbuf->data.sendseq == ack) {
                SetRexmitTimer();
                rexmit_count = 1;
                fastrexmit = 0;
                break;
            }
            RemoveHeadList(&sendq);
            free(sendbuf);
        } while (!IsListEmpty(&sendq));

    } else if (index == 0 && sent != 0) {
        // Fast retransmit
        if (++fastrexmit >= 2) {
            XDBGTRC(MYMODNAME, "fast rexmit");
            SendqXmit(GetSendqHead());
        }
    } else {
        XDBGTRC(MYMODNAME,
            "ack ignored: %u, %u, %u",
            ack, serverseq_una, serverseq_nxt);
    }
}

//
// Service network traffic from the client
//
VOID
ServiceClient()
{
    static BOOL pending = FALSE;
    static WSAOVERLAPPED overlapped;
    DWORD bytesrecv, flags;
    INT err;

    while (TRUE) {
        // Issue the overlapped recv request if necessary
        if (!pending) {
            WSABUF wsabuf;
            wsabuf.buf = recvbuf;
            wsabuf.len = sizeof(recvbuf);
            flags = 0;
            overlapped.hEvent = recvevt;
            err = WSARecv(sock, &wsabuf, 1, &bytesrecv, &flags, &overlapped, NULL);
            if (err == SOCKET_ERROR) {
                err = WSAGetLastError();
                if (err == WSA_IO_PENDING) {
                    pending = TRUE;
                } else {
                    XDBGWRN(MYMODNAME, "failed to issue recv request: %d", err);
                    return;
                }
            }
        }

        // If an overlapped recv request is pending,
        // check to see if it's completed yet.
        if (pending) {
            if (!WSAGetOverlappedResult(sock, &overlapped, &bytesrecv, FALSE, &flags)) {
                err = WSAGetLastError();
                if (err == WSA_IO_INCOMPLETE) return;

                //
                // This is very bad -
                //  cancel the pending recv request and try to issue a new one
                //
                XDBGWRN(MYMODNAME, "get overlapped result failed: %d", err);
                WSACancelOverlappedIO(sock);
                pending = FALSE;
                continue;
            }
            pending = FALSE;
        }

        // Client must be alive again - enable retransmission
        EnableRexmit();

        if (bytesrecv >= sizeof(XIrmPacketHeader)) {
            XIrmPacketHeader* pkt = (XIrmPacketHeader*) recvbuf;

            if (pkt->sendseq != clientseq) {
                XDBGTRC(MYMODNAME,
                    "client packet seq? %d %u, %u",
                    pkt->type, pkt->sendseq, clientseq);
            }

            switch (pkt->type) {
            case PKTTYPE_ACK:
                if (bytesrecv == sizeof(XIrmPacketHeader)) {
                    ProcessClientAck(pkt);
                }
                break;

            case PKTTYPE_SET_STATE:
                if (bytesrecv == sizeof(XIrmPacketSetState)) {
                    ProcessClientSetState((XIrmPacketSetState*) pkt);
                }
                break;

            default:
                XDBGTRC(MYMODNAME, "client packet type? %d", pkt->type);
                break;
            }
        } else {
            XDBGWRN(MYMODNAME, "client packet size? %d", bytesrecv);
        }
    }
}

//
// Wait for a client connection
//
VOID
WaitForClient()
{
    struct ConnectionRequest connreq;
    INT match = 0;
    
    XDBGTRC(MYMODNAME,
        "waiting for client connection: %u.%u.%u.%u %s",
        clientname,
        clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4);

    do {
        Sleep(SAMPLING_INTERVAL);
        if (HasPendingConnectReq() && GetPendingConnectReq(&connreq)) {
            match = MatchClient(connreq.clientname, connreq.clientaddr.sin_addr.s_addr);
            if (!match) {
                // the connection request wasn't valid
                XDBGTRC(MYMODNAME, "client-init doesn't match");
            }
        }
    } while (!match);

    if (match == 2 && connreq.clientname[0]) {
        // We have an address match and the client has a name.
        // Update the config file with the client name so
        // that we can do name match next time around.
        strcpy(clientname, connreq.clientname);
        WriteConfig();
    }

    InitClient(&connreq);
}

//
// Server loop
//
VOID
RunServer()
{
    DWORD timer;

    recvevt = WSACreateEvent();
    ASSERT(recvevt != NULL);
    ServiceClient();

    timer = ReadTimestamp() + SAMPLING_INTERVAL;
    while (TRUE) {
        INT timeout = timer - ReadTimestamp();

        if (timeout > 0) {
            DWORD wait = WaitForSingleObject(recvevt, timeout);
            if (wait == WAIT_OBJECT_0) {
                // Process packets from the client
                ServiceClient();
            }
        } else {
            if (HasPendingConnectReq()) {
                ProcessClientInit();
            }

            // Do retransmit if necessary
            CheckRexmit();

            // Check input state changes
            PollInput();
            SendDeviceChanges();
            SendStateChanges();

            timer = ReadTimestamp() + SAMPLING_INTERVAL;
        }
    }
}

//
// Client setup mode
//
VOID
DoSetup()
{
    struct ConnectionRequest connreq;

    XDBGTRC(MYMODNAME, "enter setup mode");
    memset(clientname, 0, sizeof(clientname));
    CLIENTADDR = 0;

    while (TRUE) {
        Sleep(SAMPLING_INTERVAL);
        if (HasPendingConnectReq()) {
            if (!GetPendingConnectReq(&connreq)) continue;

            // If both the client and server are using autonet address,
            // we'll automatically accept the client connection request.
            if (MatchClient(connreq.clientname, connreq.clientaddr.sin_addr.s_addr)) {
                autonetmode = TRUE;
                break;
            }

            // Display the client name / address in the UI and
            // ask the user for confirmation.
            // BUGBUG - not yet implemented
            XDBGWRN(MYMODNAME,
                "accept connection from %s %u.%u.%u.%u?",
                connreq.clientname,
                connreq.clientaddr.sin_addr.S_un.S_un_b.s_b1, connreq.clientaddr.sin_addr.S_un.S_un_b.s_b2, connreq.clientaddr.sin_addr.S_un.S_un_b.s_b3, connreq.clientaddr.sin_addr.S_un.S_un_b.s_b4);
        }
    }

    InitClient(&connreq);
}

//
// Initialize network stack
//
VOID
InitNet()
{
    INT err;
    WSADATA wsadata;
    struct sockaddr_in sockname;

    err = XNetStartup(NULL);
    ASSERT(err == NO_ERROR);

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(sock != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = bind(sock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    listensock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(listensock != INVALID_SOCKET);

    sockname.sin_port = htons(XIRM_SERVER_PORT);
    err = bind(listensock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);
}

//
// Server thread that listens for incoming client connection requests
//
DWORD WINAPI
ListenThreadProc(
    VOID* param
    )
{
    CHAR buf[XIRM_MAX_PACKET_SIZE];
    struct sockaddr sockname;
    struct sockaddr_in* sockin;
    XIrmPacketClientInit* initpkt;
    INT err;

    initpkt = (XIrmPacketClientInit*) buf;
    memset(&sockname, 0, sizeof(sockname));
    sockin = (struct sockaddr_in*) &sockname;

    while (TRUE) {
        INT fromlen = sizeof(sockname);
        INT count = recvfrom(listensock, buf, sizeof(buf), 0, &sockname, &fromlen);

        if (count != sizeof(*initpkt) || initpkt->header.type != PKTTYPE_CLIENT_INIT) {
            if (count >= sizeof(XIrmPacketHeader)) {
                XDBGTRC(MYMODNAME, "packet from %u.%u.%u.%u:%d discard: %d",
                    sockin->sin_addr.S_un.S_un_b.s_b1, sockin->sin_addr.S_un.S_un_b.s_b2, sockin->sin_addr.S_un.S_un_b.s_b3, sockin->sin_addr.S_un.S_un_b.s_b4,
                    ntohs(sockin->sin_port),
                    initpkt->header.type);
            } else {
                XDBGWRN(MYMODNAME, "recv error? %d, %d", count, GetLastError());
            }
            continue;
        }

        XDBGTRC(MYMODNAME,
            "client-init from %u.%u.%u.%u:%d - %x %u",
            sockin->sin_addr.S_un.S_un_b.s_b1, sockin->sin_addr.S_un.S_un_b.s_b2, sockin->sin_addr.S_un.S_un_b.s_b3, sockin->sin_addr.S_un.S_un_b.s_b4,
            ntohs(sockin->sin_port),
            initpkt->protocol_version,
            initpkt->header.sendseq);

        if (initpkt->protocol_version != XIRM_PROTOCOL_VERSION) {
            XDBGTRC(MYMODNAME, "client version mismatch: %x %x");
            continue;
        }

        ConnectReqLock();
        connection_request.clientisn = initpkt->header.sendseq;
        connection_request.clientaddr = *sockin;
        memcpy(connection_request.clientname, initpkt->client_name, XIRM_MACHINE_NAME_MAXLEN-1);
        ConnectReqUnlock();
    }
}


void __cdecl main()
{
    HANDLE thread;
    DWORD tid;

    InitializeListHead(&sendq);

    // Initialize network stack
    InitNet();

    // Initialize input
    InitInput();

    // Create server listening thread
    InitializeCriticalSection(&connection_request_lock);
    thread = CreateThread(NULL, 0, ListenThreadProc, NULL, 0, &tid);
    ASSERT(thread != NULL);
    CloseHandle(thread);

    // Check if the config file is present
    if (!dosetup) {
        if (!ReadConfig()) dosetup = TRUE;
    }

    if (dosetup) {
        DoSetup();
    } else {
        // Server loop
        WaitForClient();
    }

    RunServer();
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\netsim\win2k\xbinput.cpp ===
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock2.h>
#include <xboxdbg.h>

extern "C" {
#include "xboxstub.h"
#include "xinput_remote.h"
}

#define DIRECTINPUT_VERSION 0x0700
#include <initguid.h>
#include <dinput.h>

CHAR* programname;
HINSTANCE appinstance;
HWND hwndmain;
BOOL hasfocus;
SOCKET sock, listensock;
HANDLE recvevt;
CHAR recvbuf[XIRM_MAX_PACKET_SIZE];
CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
CHAR xboxname[XIRM_MACHINE_NAME_MAXLEN];
ULONG clientaddr;
INT connected;
DWORD connecttime;
DWORD clientisn, clientseq;
DWORD serverseq_una, serverseq_nxt;
INT fastrexmit, rexmit_timer, rexmit_count;
BOOL rexmit_disabled;
IDirectInput7* dinput7;

//
// Pending connection request
//
struct ConnectionRequest {
    BOOL active;
    DWORD clientisn;
    struct sockaddr_in clientaddr;
    CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
} connection_request;
CRITICAL_SECTION connection_request_lock;

#define ConnectReqLock()    EnterCriticalSection(&connection_request_lock)
#define ConnectReqUnlock()  LeaveCriticalSection(&connection_request_lock)
#define HasPendingConnectReq() (connection_request.active)

//
// Send queue
//
#define GetSendqHead() ((SendBuf*) sendq.Flink)
#define GetSendqLen() ((INT) (serverseq_nxt - serverseq_una))
#define IsSendqFull() (GetSendqLen() >= XIRM_SEND_WINDOW)
#define IsSendqEmpty() (serverseq_una == serverseq_nxt)

LIST_ENTRY sendq;
typedef struct _SendBuf {
    LIST_ENTRY links;
    INT datalen;
    XIrmPacketHeader data;
} SendBuf;

//
// Device state information
//
DWORD device_count;
XINPUT_CAPABILITIES device_caps;
struct DeviceData {
    GUID guid_instance;
    IDirectInputDevice7* indev7;
    XINPUT_GAMEPAD current_states;
    XINPUT_GAMEPAD last_states;
} devices[XIRM_PORTMAX];

//
// InterAct HammerHead FX product GUID and capabilities
//
const GUID HammerHeadGuid = {
    0x262A05FD,
    0,
    0,
    { 0x00, 0x00, 0x50, 0x49, 0x44, 0x56, 0x49, 0x44 }
};

//
// Main server loop sampling interval (10 msecs = 100Hz)
//
#define SAMPLING_INTERVAL 10


//
// Error handling functions
//
inline VOID errormsg(CHAR* msg) {
    MessageBox(hwndmain, msg, programname, MB_OK|MB_ICONERROR);
}

VOID error(CHAR* format, ...)
{
    CHAR buf[1024];
    va_list arglist;

    va_start(arglist, format);
    vsprintf(buf, format, arglist);
    va_end(arglist);

    errormsg(buf);
    exit(-1);
}

#define ASSERT(cond) do { if (!(cond)) assert(__LINE__, #cond); } while(0)
VOID assert(INT line, CHAR* msg)
{
    error("Assertion failed: line %d\n"
          "  %s\n"
          "  error code = %d",
          line, msg, GetLastError());
}

VOID usage()
{
    CHAR buf[256];

    sprintf(buf, "usage: %s [-x xboxname]", programname);
    errormsg(buf);
    exit(1);
}

//
// Initialize the input module
//
BOOL CALLBACK EnumDevicesCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
{
    if (memcmp(&lpddi->guidProduct, &HammerHeadGuid, sizeof(HammerHeadGuid)) == 0 &&
        device_count < XIRM_PORTMAX) {
        devices[device_count++].guid_instance = lpddi->guidInstance;
    }
    return DIENUM_CONTINUE;
}

VOID InitInput()
{
    //
    // Initialize DirectInput
    //
    HRESULT hr;
    hr= DirectInputCreateEx(
            appinstance,
            DIRECTINPUT_VERSION,
            IID_IDirectInput7,
            (VOID**) &dinput7,
            NULL);

    ASSERT(SUCCEEDED(hr)); 

    //
    // Enumerate attached HammerHead controllers
    //
    hr = dinput7->EnumDevices(
            DIDEVTYPE_JOYSTICK ,
            EnumDevicesCallback,
            0,
            DIEDFL_ATTACHEDONLY);

    if (device_count == 0) {
        error("Found no HammerHead controller.");
    }

    //
    // Acquire all enumerated controllers for exclusive access
    //
    for (DWORD i=0; i < device_count; i++) {
        IDirectInputDevice7* indev7;
        hr = dinput7->CreateDeviceEx(
                devices[i].guid_instance,
                IID_IDirectInputDevice7,
                (VOID**) &indev7,
                NULL);

        if (FAILED(hr)) break;

        hr = indev7->SetDataFormat(&c_dfDIJoystick);
        if (FAILED(hr)) break;
        
        DIPROPDWORD prop;
        prop.diph.dwSize = sizeof(prop);
        prop.diph.dwHeaderSize = sizeof(prop.diph);
        prop.diph.dwObj = 0;
        prop.diph.dwHow = DIPH_DEVICE;
        prop.dwData = DIPROPAXISMODE_ABS;
        hr = indev7->SetProperty(DIPROP_AXISMODE, &prop.diph);
        if (FAILED(hr)) break;

        hr = indev7->SetCooperativeLevel(hwndmain, DISCL_EXCLUSIVE|DISCL_BACKGROUND);
        if (FAILED(hr)) break;

        hr = indev7->Acquire();
        if (FAILED(hr)) break;
        devices[i].indev7 = indev7;
    }

    if (i != device_count) {
        error("Failed to acquire controller %d: %x", i, hr);
    }

    XINPUT_GAMEPAD* gamepad = &device_caps.In.Gamepad;
    device_caps.SubType = XINPUT_DEVSUBTYPE_GC_GAMEPAD;
    gamepad->wButtons = 0xff;
    memset(gamepad->bAnalogButtons, 0x80, 8);
    gamepad->sThumbLX =
    gamepad->sThumbLY =
    gamepad->sThumbRX =
    gamepad->sThumbRY = (SHORT) 0xff00;
}

//
// Transmit the first packet in the send queue
//
#define SetRexmitTimer() (rexmit_timer = GetTickCount() + XIRM_RETRANSMIT_TIMEOUT)
inline VOID EnableRexmit() {
    if (rexmit_disabled) {
        rexmit_disabled = FALSE;
        rexmit_count = 1;
    }
}

VOID SendqXmit(SendBuf* sendbuf)
{
    send(sock, (CHAR*) &sendbuf->data, sendbuf->datalen, 0);
    if (sendbuf == GetSendqHead()) {
        SetRexmitTimer();
    }
    rexmit_count++;
    fastrexmit = 0;
}

//
// Do retransmission if needed
//
VOID CheckRexmit()
{
    if (rexmit_disabled || IsSendqEmpty()) return;

    if ((INT) (rexmit_timer - GetTickCount()) < 0) {
        if (rexmit_count >= XIRM_RETRANSMIT_RETRY) {
            // If too many retries, we assume the client is down
            // and stop retransmitting until we receive a packet
            // from the client or there is an input state change.
            rexmit_disabled = TRUE;
        } else {
            SendqXmit(GetSendqHead());
        }
    }
}

//
// Insert a new send buffer to the end of the send queue
// and then transmit it out to the client
//
VOID InsertSendBuf(SendBuf* sendbuf)
{
    if (IsListEmpty(&sendq)) rexmit_count = 0;

    InsertTailList(&sendq, &sendbuf->links);
    SendqXmit(sendbuf);
}

//
// Allocate memory buffer for a new outgoing packet
//
SendBuf* AllocSendBuf(INT size)
{
    SendBuf* sendbuf = (SendBuf*) malloc(offsetof(SendBuf, data) + size);

    if (sendbuf) {
        sendbuf->datalen = size;
        sendbuf->data.sendseq = serverseq_nxt++;
        sendbuf->data.ackseq = clientseq;
    }
    return sendbuf;
}

//
// Send device changes to the client
//
VOID
SendDeviceChanges()
{
    SendBuf* sendbuf;
    XIrmPacketDeviceChanges* devchgpkt;
    INT pktlen;

    pktlen = offsetof(XIrmPacketDeviceChanges, devicecaps) +
             device_count * sizeof(XINPUT_CAPABILITIES);
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    devchgpkt = (XIrmPacketDeviceChanges*) &sendbuf->data;
    devchgpkt->header.type = PKTTYPE_DEVICE_CHANGES;

    devchgpkt->keyboard_device = 1;
    devchgpkt->active_devices = 
    devchgpkt->insertions = (1 << device_count) - 1;
    devchgpkt->removals = 0;

    for (DWORD i=0; i < device_count; i++)
        devchgpkt->devicecaps[i] = device_caps;

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Send input state changes to the client
//
VOID SendStateChanges()
{
    static DWORD pktnumber;
    SendBuf* sendbuf;
    XIrmPacketStateChanges* stchgpkt;
    
    // Send queue is full, do nothing during this interval
    if (IsSendqFull()) return;

    // Check to see if anything has changed
    DWORD masks = 0;
    INT pktlen = 0;
    for (DWORD i=0; i < device_count; i++) {
        if (memcmp(&devices[i].current_states,
                   &devices[i].last_states,
                   sizeof(XINPUT_GAMEPAD)) != 0) {
            masks |= (1 << i);
            pktlen++;
        }
    }
    if (masks == 0) return;

    pktlen = offsetof(XIrmPacketStateChanges, states) + pktlen*sizeof(XINPUT_STATE);
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    stchgpkt = (XIrmPacketStateChanges*) &sendbuf->data;
    stchgpkt->header.type = PKTTYPE_STATE_CHANGES;
    stchgpkt->device_masks = masks;

    XINPUT_STATE* states = stchgpkt->states;
    for (i=0; i < XIRM_PORTMAX; i++) {
        if (masks & (1 << i)) {
            states->Gamepad = devices[i].last_states = devices[i].current_states;
            states->dwPacketNumber = pktnumber++;
        }
    }

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Poll the current state of the controllers
//
#define BUTTON_MAP1(x, w) \
        if (joystate.rgbButtons[w-1] & 0x80) buttons |= x

#define BUTTON_MAP2(x, w) \
        xstate->bAnalogButtons[x] = (joystate.rgbButtons[w-1] & 0x80)

#define BUTTON_MAP3(d) \
        buttons |= XINPUT_GAMEPAD_DPAD_##d

#define BUTTON_MAP4(d1, d2) \
        buttons |= (XINPUT_GAMEPAD_DPAD_##d1 | XINPUT_GAMEPAD_DPAD_##d2)

#define BUTTON_MAP5(x, w) \
        xstate->x = MapThumbValue(joystate.w)

inline SHORT MapThumbValue(LONG val) {
    // convert from range 0-ffff to 0-ff
    val = (val >> 8) & 0xff;

    // 0 - 8000
    // 7f and 80 - 0
    // ff - 7fff
    return (SHORT) ((val == 0x7f || val == 0x80) ? 0 : ((val | (val << 8)) - 0x8000));
}

VOID PollInput()
{
    IDirectInputDevice7* indev7;
    HRESULT hr;
    DIJOYSTATE joystate;

    if (!connected) return;

    for (DWORD i=0; i < device_count; i++) {
        indev7 = devices[i].indev7;
        
        memset(&joystate, 0, sizeof(joystate));
        indev7->Poll();
        hr = indev7->GetDeviceState(sizeof(joystate), &joystate);
        if (FAILED(hr)) continue;

        // Map the buttons
        XINPUT_GAMEPAD* xstate = &devices[i].current_states;
        DWORD buttons = 0;

        BUTTON_MAP1(XINPUT_GAMEPAD_LEFT_THUMB, 9);
        BUTTON_MAP1(XINPUT_GAMEPAD_RIGHT_THUMB, 10);
        BUTTON_MAP1(XINPUT_GAMEPAD_START, 11);
        BUTTON_MAP1(XINPUT_GAMEPAD_BACK, 12);

        BUTTON_MAP2(XINPUT_GAMEPAD_X, 1);
        BUTTON_MAP2(XINPUT_GAMEPAD_Y, 2);
        BUTTON_MAP2(XINPUT_GAMEPAD_WHITE, 3);
        BUTTON_MAP2(XINPUT_GAMEPAD_A, 4);
        BUTTON_MAP2(XINPUT_GAMEPAD_B, 5);
        BUTTON_MAP2(XINPUT_GAMEPAD_BLACK, 6);
        BUTTON_MAP2(XINPUT_GAMEPAD_B, 5);
        BUTTON_MAP2(XINPUT_GAMEPAD_LEFT_TRIGGER, 7);
        BUTTON_MAP2(XINPUT_GAMEPAD_RIGHT_TRIGGER, 8);
        
        DWORD pov = (joystate.rgdwPOV[0] & 0xffff);
        if (pov != 0xffff) {
            switch ((pov / 4500) % 8) {
            case 0:
                BUTTON_MAP3(UP); break;
            case 1:
                BUTTON_MAP4(UP,RIGHT); break;
            case 2:
                BUTTON_MAP3(RIGHT); break;
            case 3:
                BUTTON_MAP4(RIGHT,DOWN); break;
            case 4:
                BUTTON_MAP3(DOWN); break;
            case 5:
                BUTTON_MAP4(DOWN,LEFT); break;
            case 6:
                BUTTON_MAP3(LEFT); break;
            case 7:
                BUTTON_MAP4(LEFT,UP); break;
            }
        }
        xstate->wButtons = (WORD) buttons;

        joystate.lY ^= 0xffff;
        joystate.lRz ^= 0xffff;
        
        BUTTON_MAP5(sThumbLX, lX);
        BUTTON_MAP5(sThumbLY, lY);
        BUTTON_MAP5(sThumbRX, lZ);
        BUTTON_MAP5(sThumbRY, lRz);
    }

    SendStateChanges();
}

//
// Process an acknowledgement packet from the client
//
VOID ProcessClientAck(XIrmPacketHeader* pkt)
{
    DWORD ack;
    INT index, sent;

    ack = pkt->ackseq;
    index = (INT) (ack - serverseq_una);
    sent = GetSendqLen();

    if (index > 0 && index <= sent) {
        // The acknowledgement is valid
        ASSERT(!IsListEmpty(&sendq));
        serverseq_una = ack;

        do {
            SendBuf* sendbuf = GetSendqHead();
            if (sendbuf->data.sendseq == ack) {
                SetRexmitTimer();
                rexmit_count = 1;
                fastrexmit = 0;
                break;
            }
            RemoveHeadList(&sendq);
            free(sendbuf);
        } while (!IsListEmpty(&sendq));

    } else if (index == 0 && sent != 0) {
        // Fast retransmit
        if (++fastrexmit >= 2) {
            SendqXmit(GetSendqHead());
        }
    }
}

//
// Service network traffic from the client
//
VOID
ServiceClient()
{
    static BOOL pending = FALSE;
    static WSAOVERLAPPED overlapped;

    XIrmPacketHeader* pkt;
    DWORD bytesrecv, flags;
    INT err;

    while (TRUE) {
        // Issue the overlapped recv request if necessary
        if (!pending) {
            WSABUF wsabuf;
            wsabuf.buf = recvbuf;
            wsabuf.len = sizeof(recvbuf);
            flags = 0;
            overlapped.hEvent = recvevt;
            err = WSARecv(sock, &wsabuf, 1, &bytesrecv, &flags, &overlapped, NULL);
            if (err == SOCKET_ERROR) {
                err = WSAGetLastError();
                if (err == WSA_IO_PENDING) {
                    pending = TRUE;
                } else {
                    // recv failed, try again
                    continue;
                }
            }
        }

        // If an overlapped recv request is pending,
        // check to see if it's completed yet.
        if (pending) {
            if (!WSAGetOverlappedResult(sock, &overlapped, &bytesrecv, FALSE, &flags)) {
                err = WSAGetLastError();
                if (err == WSA_IO_INCOMPLETE) return;

                //
                // This is very bad -
                //  cancel the pending recv request and try to issue a new one
                //
                CancelIo((HANDLE) sock);
                pending = FALSE;
                continue;
            }
            pending = FALSE;
        }

        // Client must be alive again - enable retransmission
        EnableRexmit();

        // The only packet type we care about is ACK
        pkt = (XIrmPacketHeader*) recvbuf;
        if (bytesrecv == sizeof(XIrmPacketHeader) &&
            pkt->type == PKTTYPE_ACK) {
            ProcessClientAck(pkt);
        }
    }
}

//
// Initialize the connection with the client
//
VOID InitClient(struct ConnectionRequest* connreq)
{
    SendBuf* sendbuf;
    INT err;

    connected++;
    strcpy(clientname, connreq->clientname);
    clientaddr = connreq->clientaddr.sin_addr.s_addr;
    err = connect(sock, (struct sockaddr*) &connreq->clientaddr, sizeof(connreq->clientaddr));
    ASSERT(err == NO_ERROR);

    // Force a window update
    InvalidateRect(hwndmain, NULL, TRUE);

    connecttime = GetTickCount();
    rexmit_disabled = FALSE;
    clientisn = connreq->clientisn;
    clientseq = clientisn+1;
    serverseq_una = serverseq_nxt = XIrmGetISN();

    while (!IsListEmpty(&sendq)) {
        LIST_ENTRY* p = RemoveHeadList(&sendq);
        free(p);
    }

    sendbuf = AllocSendBuf(sizeof(XIrmPacketHeader));
    ASSERT(sendbuf != NULL);
    sendbuf->data.type = PKTTYPE_SERVER_INIT;
    InsertSendBuf(sendbuf);

    // Send the initial device caps and states
    for (DWORD i=0; i < device_count; i++) {
        memset(&devices[i].last_states, 0, sizeof(XINPUT_GAMEPAD));
    }
    SendDeviceChanges();
    
    PollInput();
}

//
// Process a client-init packet from the client
//
VOID ProcessClientInit()
{
    struct ConnectionRequest connreq;

    // Retrieve information about the pending connection request
    ConnectReqLock();
    connreq = connection_request;
    connection_request.active = FALSE;
    ConnectReqUnlock();

    if (clientname[0] && strcmp(clientname, connreq.clientname) == 0 ||
        clientaddr == connreq.clientaddr.sin_addr.s_addr) {
        if (connected) {
            // We were connected to the client already.
            // Check to see if this client-init packet is a duplicate
            // or if the client has been rebooted.
            INT time = GetTickCount() - connecttime;
            if (connreq.clientisn == clientisn && time >= 0 && time <= 3000) return;
        }
        InitClient(&connreq);

        // For first time connection, start the overlapped receive request
        if (connected == 1) {
            ServiceClient();
        }
    }
}

//
// Handle keyboard events
//
VOID HandleKeyEvents(INT vkey, INT flags, BOOL keydown)
{
    SendBuf* sendbuf;
    XIrmPacketKeystroke* kbdpkt;
    BYTE xflags = 0;

    // Send queue is full, drop the keystroke
    if (!connected || IsSendqFull()) return;

    sendbuf = AllocSendBuf(sizeof(XIrmPacketKeystroke));
    if (!sendbuf) return;

    kbdpkt = (XIrmPacketKeystroke*) &sendbuf->data;
    kbdpkt->header.type = PKTTYPE_KEYSTROKE;

    kbdpkt->keystroke.VirtualKey = (BYTE) vkey;
    kbdpkt->keystroke.Ascii = (CHAR) MapVirtualKey(vkey, 2);
    
    if (!keydown) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP;
    if (keydown && (flags & (1 << 30))) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT;
    if (GetKeyState(VK_SHIFT) & 0x8000) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_SHIFT;
    if (GetKeyState(VK_CONTROL) & 0x8000) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_CTRL;
    if (GetKeyState(VK_MENU) & 0x8000) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_ALT;
    if (GetKeyState(VK_CAPITAL) & 1) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK;
    if (GetKeyState(VK_NUMLOCK) & 1) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK;
    if (GetKeyState(VK_SCROLL) & 1) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_SCROLLLOCK;
    kbdpkt->keystroke.Flags = xflags;

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Handle window repaint event
//
VOID DoPaint(HWND hwnd)
{
    static HFONT font;
    HDC hdc;
    PAINTSTRUCT ps;
    CHAR* p;
    INT x, y;
    CHAR buf[64];

    hdc = BeginPaint(hwnd, &ps);

    if (font == NULL) {
        LOGFONT lf;
        INT mmy = GetDeviceCaps(hdc, VERTSIZE);
        INT pixy = GetDeviceCaps(hdc, VERTRES);
        double pt = pixy * 25.4 / (mmy * 72);

        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -(INT) (10 * pt);
        lf.lfWeight = FW_BOLD;
        strcpy(lf.lfFaceName, "Arial");
        font = CreateFontIndirect(&lf);
    }

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, RGB(0, 255, 0));
    SelectObject(hdc, font);

    x = 5;
    y = 0;
    if (connected) {
        sprintf(buf, "Connected to client (%d):", connected);
        p = buf;
    } else {
        p = "Waiting for client connection...";
    }
    TextOut(hdc, x, y, p, strlen(p));

    if (clientname[0]) {
        p = clientname;
        y += 20;
        TextOut(hdc, x, y, p, strlen(p));
    }

    if (clientaddr) {
        p = inet_ntoa(*((struct in_addr*) &clientaddr));
        y += 20;
        TextOut(hdc, x, y, p, strlen(p));
    }

    EndPaint(hwnd, &ps);
}

//
// Window callback procedure
//
LRESULT CALLBACK MyWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg) {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_SETFOCUS:
        hasfocus = TRUE;
        break;

    case WM_KILLFOCUS:
        hasfocus = FALSE;
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_KEYDOWN:
    case WM_KEYUP:
        HandleKeyEvents(wparam, lparam, msg==WM_KEYDOWN);
        break;

    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        HandleKeyEvents(wparam, lparam, msg==WM_SYSKEYDOWN);
        // fall through to the default winproc

    default:
        return DefWindowProc(hwnd, msg, wparam, lparam);
    }

    return 0;
}

//
// Create the main application window
//
VOID CreateMainWindow()
{
    HBITMAP bitmap;
    BITMAP bmpinfo;
    HBRUSH brush;
    LOGBRUSH logbrush;
    INT ret;

    WNDCLASS wndclass = {
        0,
        MyWindowProc,
        0,
        0,
        appinstance,
        LoadIcon(appinstance, MAKEINTRESOURCE(128)),
        LoadCursor(NULL, IDC_ARROW),
        NULL,
        NULL,
        "XBINPUT"
    };

    // Load the background bitmap
    bitmap = LoadBitmap(appinstance, MAKEINTRESOURCE(128));
    ASSERT(bitmap != NULL);
    ret = GetObject(bitmap, sizeof(bmpinfo), &bmpinfo);
    ASSERT(ret != 0);

    // Create the pattern brush
    logbrush.lbStyle = BS_PATTERN;
    logbrush.lbColor = 0;
    logbrush.lbHatch = (LONG) bitmap;
    brush = CreateBrushIndirect(&logbrush);
    ASSERT(brush != NULL);

    wndclass.hbrBackground = brush;
    RegisterClass(&wndclass);

    hwndmain = CreateWindowEx(
                    WS_EX_APPWINDOW|WS_EX_OVERLAPPEDWINDOW,
                    "XBINPUT",
                    programname,
                    WS_POPUPWINDOW|WS_CAPTION|WS_MINIMIZEBOX,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    bmpinfo.bmWidth +
                        2*GetSystemMetrics(SM_CXFIXEDFRAME),
                    bmpinfo.bmHeight +
                        2*GetSystemMetrics(SM_CYFIXEDFRAME) +
                        GetSystemMetrics(SM_CYCAPTION),
                    NULL,
                    NULL,
                    appinstance,
                    NULL);

    ASSERT(hwndmain != NULL);
    ShowWindow(hwndmain, SW_SHOW);
}

//
// Server loop
//
VOID RunServer()
{
    MSG msg;
    DWORD wait;

    while (TRUE) {
        // NOTE: We can't call MsgWaitForMultipleObjects when we're inactive
        //  because it doesn't return long after the event is signaled.
        if (hasfocus) {
            wait = MsgWaitForMultipleObjects(1, &recvevt, FALSE, SAMPLING_INTERVAL, QS_ALLEVENTS);
        } else {
            wait = WaitForSingleObject(recvevt, SAMPLING_INTERVAL);
        }

        // Process client packets
        if (wait == WAIT_OBJECT_0) {
            ServiceClient();
        }

        // Check if there is any pending connection request
        if (HasPendingConnectReq()) {
            ProcessClientInit();
        }
        
        // Process window messages
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) return;
            DispatchMessage(&msg);
        }

        // Check input state changes
        PollInput();

        // Do retransmit if necessary
        CheckRexmit();
    }
}

//
// Initialize network stack
//
VOID InitNet()
{
    INT err;
    WSADATA wsadata;
    struct sockaddr_in sockname;

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(sock != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = bind(sock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    listensock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(listensock != INVALID_SOCKET);

    sockname.sin_port = htons(XIRM_SERVER_PORT);
    err = bind(listensock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);
}

//
// Server thread that listens for incoming client connection requests
//
DWORD WINAPI ListenThreadProc(VOID* param)
{
    CHAR buf[XIRM_MAX_PACKET_SIZE];
    struct sockaddr sockname;
    struct sockaddr_in* sockin;
    XIrmPacketClientInit* initpkt;

    initpkt = (XIrmPacketClientInit*) buf;
    memset(&sockname, 0, sizeof(sockname));
    sockin = (struct sockaddr_in*) &sockname;

    while (TRUE) {
        INT fromlen = sizeof(sockname);
        INT count = recvfrom(listensock, buf, sizeof(buf), 0, &sockname, &fromlen);

        if (count != sizeof(*initpkt) ||
            initpkt->header.type != PKTTYPE_CLIENT_INIT ||
            initpkt->protocol_version != XIRM_PROTOCOL_VERSION) {
            continue;
        }

        ConnectReqLock();
        connection_request.clientisn = initpkt->header.sendseq;
        connection_request.clientaddr = *sockin;
        memcpy(connection_request.clientname, initpkt->client_name, XIRM_MACHINE_NAME_MAXLEN-1);
        connection_request.active = TRUE;
        ConnectReqUnlock();
    }
}

INT __cdecl main(INT argc, CHAR** argv)
{
    HANDLE thread;
    DWORD tid;
    HRESULT hr;

    appinstance = GetModuleHandle(NULL);
    programname = *argv++;
    argc--;

    hr = CoInitialize(NULL);
    ASSERT(SUCCEEDED(hr));

    InitializeCriticalSection(&connection_request_lock);
    InitializeListHead(&sendq);
    recvevt = WSACreateEvent();
    ASSERT(recvevt != NULL);

    // Parse command line arguments
    while (argc) {
        CHAR* opt = *argv++;
        argc--;

        if (strcmp(opt, "-x") == 0 && argc > 0 &&
            strlen(*argv) < XIRM_MACHINE_NAME_MAXLEN && !xboxname[0]) {
            strcpy(xboxname, *argv);
            argv++;
            argc--;
        } else {
            usage();
        }
    }

    // Initialize network stack
    InitNet();

    if (xboxname[0]) {
        hr = DmSetXboxName(xboxname);
    } else {
        DWORD size = sizeof(xboxname);
        hr = DmGetXboxName(xboxname, &size);
    }

    if (FAILED(hr)) {
        error("Failed to determine the client xbox name");
    }

    clientaddr = inet_addr(xboxname);
    if (clientaddr == INADDR_NONE) clientaddr = 0;
    if (!clientaddr) {
        strcpy(clientname, xboxname);
    }

    // Create the main application window
    CreateMainWindow();

    // Initialize input
    InitInput();

    // Create server listening thread
    thread = CreateThread(NULL, 0, ListenThreadProc, NULL, 0, &tid);
    ASSERT(thread != NULL);
    CloseHandle(thread);

    RunServer();

    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\devsys.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    devsys.c

Abstract:
    
    Implementation of code that is conditionally compiled to perform
    operation on development systems (i.e. non-final development system
    hardware.)  This code may also be useful for verifying final hardware.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-21-00 created by Mitchell Dernis (mitchd)

--*/

//
//  This file only compiles if development system
//  operations are enabled.
#ifdef PERFORM_DEVSYS_OPERATIONS

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


#pragma code_seg(".XPPCINIT")

VOID
OHCD_DevSysCheckHardware(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    )


{
    ULONG Revision;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_DevSysCheckHardware"));
    //
    //  Read the OHCI version
    //
    Revision = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcRevision);
    USB_DBG_TRACE_PRINT(("OpenHCI controller version = %d.%d", ((0xF0 & Revision) >> 4), (0x0F & Revision)));
    
    //
    //  We only support version 1.0 of OpenHCI
    //
    ASSERT( (0x10 == (0xFF & Revision)) && "We only support version 1.0 of OpenHCI");
    USB_DBG_EXIT_PRINT(("Exiting OHCD_DevSysCheckHardware"));
}


VOID
OHCD_DevSysTakeControl(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    )
{
    LARGE_INTEGER DelayTime;
    HC_CONTROL_REGISTER HcControl;
    HC_COMMAND_STATUS   HcCommandStatus;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_DevSysTakeControl"));
    //
    //  Read control register to determine if we have an SMM or BIOS driver
    //  to steel control from
    HcControl.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControl.ul);
    
    //
    //  Check for SMM driver (spec. says to check InterruptRouting Bit)
    //
    if(HcControl.InterruptRouting)
    {
        USB_DBG_TRACE_PRINT(("Placing OwnerShipChangeRequest to get control from SMM driver."));
        //
        //  Put in an OwnerShipChangeRequest
        //
        HcCommandStatus.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcCommandStatus.ul);
        HcCommandStatus.OwnerShipChangeRequest = 1;
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcCommandStatus.ul, HcCommandStatus.ul);

        //
        //  Wait for SMM driver to clear the interrupt routing bit
        //
        do
        {
            HcControl.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControl.ul);
        }while(HcControl.InterruptRouting);
        USB_DBG_TRACE_PRINT(("SMM driver has yielded control."));
    }
    //
    //  If not SMM driver check for BIOS driver
    //
    else if(HC_OPSTATE_USB_RESET != HcControl.HostControllerFunctionalState )
    {
        USB_DBG_TRACE_PRINT(("A BIOS driver was present, set to UsbResume to get control."));
        //
        //  If the state is not operational set it to resume and wait
        //
        if(HC_OPSTATE_USB_OPERATIONAL != HcControl.HostControllerFunctionalState)
        {
            HcControl.HostControllerFunctionalState = HC_OPSTATE_USB_RESUME;
            //
            //  Signal RESUME and WAIT 20 ms.
            //
            WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControl.ul, HcControl.ul);
            DelayTime.QuadPart = -200000;
            KeDelayExecutionThread( KernelMode, FALSE, &DelayTime);
        }
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_DevSysTakeControl"));
}

#endif //PERFORM_DEVSYS_OPERATIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\ohcd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    ohcd.c

Abstract:
    
    Basic entry point implementation of the OpenHCI
    driver.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-17-00 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
#include <ntos.h>
#include <pci.h>


//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff
#include "devsys.h"     //checks for development systems

//----------------------------------------------------------------------------
//  Spew the build settings during compile
//----------------------------------------------------------------------------
#ifdef OHCD_XBOX_HARDWARE_ONLY
#pragma message("OHCD: Xbox Hardware Only Build")
#endif
#if(USB_HOST_CONTROLLER_CONFIGURATION==USB_SINGLE_HOST_CONTROLLER)
#pragma message("OHCD: Single Host Controller Support")
#endif
#if(USB_HOST_CONTROLLER_CONFIGURATION==USB_DUAL_HOST_CONTROLLER_XDK)
#pragma message("OHCD: Dual Host Controller for Silver XDK boxes")
#endif

//----------------------------------------------------------------------------
// Interrupt objects for each HC - this cannot come from the pool,
// because it has code in it, and the pool is not executable.
//----------------------------------------------------------------------------
KINTERRUPT OHCD_InterruptObject[HCD_MAX_HOST_CONTROLLERS];

//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
USBD_STATUS
FASTCALL
OHCD_fOpenEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );

USBD_STATUS
FASTCALL
OHCD_fCloseEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );
USBD_STATUS
FASTCALL
OHCD_fGetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );

USBD_STATUS
FASTCALL
OHCD_fSetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );
USBD_STATUS
FASTCALL
OHCD_fAbortEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );
VOID
FASTCALL
OHCD_fSetResources(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    PPCI_DEVICE_DESCRIPTOR      PciDevice
    );
VOID
FASTCALL
OHCD_fDequeueControlTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    );
VOID
FASTCALL
OHCD_fDequeueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    );
VOID
FASTCALL
OHCD_fDequeueInterruptTransfer(
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    );
VOID
FASTCALL
OHCD_fCancelQueuedUrbs(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    );

VOID
OHCD_ShutDown(
    PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration
    );


//----------------------------------------------------------------------------
// Implementation of all entry points:
//      HCD_DriverEntry
//      HCD_NewHostController
//      HCD_SubmitRequest
//      HCD_CancelRequest
//----------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
VOID
HCD_DriverEntry(
    IN PHCD_RESOURCE_REQUIREMENTS ResourceRequirements
    )
/*++

Routine Description:
    
    Performs one time initialization of driver.  Returns the size of the
    HCD portion of the extension.

Arguments:
    
    ResourceRequirements - tells the host controller how many resources
    to preallocate.

Return Value:

    None.

--*/
{
    USB_DBG_ENTRY_PRINT(("Entering HCD_DriverEntry"));
    USB_DBG_TRACE_PRINT(("Built on %s @%s", __DATE__,__TIME__));
    
    OHCD_fPoolInit(ResourceRequirements);
    
    USB_DBG_EXIT_PRINT(("Exiting HCD_DriverEntry"));
    return;
}

#ifdef SILVER
VOID
HCD_EnumHardware()
/*++
Routine Description:

  The HCD layer is responsible for calling HAL to find its hardware.
  This layer must do it, because only this layer knows the PCI PnP ID
  information about the proper host controller type.

  We call back USBD_NewHostController which allocates the USBD portion
  of the host controller and calls back HCD_NewHostController to
  initialize the hardware.

--*/

{
    PCI_DEVICE_DESCRIPTOR pciDevices[HCD_MAX_HOST_CONTROLLERS];
    ULONG hostControllerIndex=0;
    ULONG hostControllerCount=HCD_MAX_HOST_CONTROLLERS;
    //
    //  Initialize pciDevices array to HAL what we are looking for.
    //
    while(hostControllerCount--)
    {
        pciDevices[hostControllerCount].Bus=(ULONG)-1;
        pciDevices[hostControllerCount].Slot=(ULONG)-1;
        pciDevices[hostControllerCount].VendorID=(USHORT)-1;
		pciDevices[hostControllerCount].DeviceID=(USHORT)-1;
        pciDevices[hostControllerCount].BaseClass=PCI_CLASS_SERIAL_BUS_CTLR;
        pciDevices[hostControllerCount].SubClass=PCI_SUBCLASS_SB_USB;
        pciDevices[hostControllerCount].ProgIf=OHCI_PCI_PROGRAM_INTERFACE;
    }
    //
    //  Ask HAL to find our controllers
    //
    hostControllerCount=HCD_MAX_HOST_CONTROLLERS;
    HalSetupPciDevice(pciDevices, &hostControllerCount);
    
    //
    //  Kick off initialization by notifying USBD about each device.
    //  (Be sure not to change the order that we got from HAL.)
    //
    while(hostControllerIndex < hostControllerCount)
    {
        USBD_NewHostController(pciDevices+hostControllerIndex, sizeof(OHCD_DEVICE_EXTENSION));
        hostControllerIndex++;
    }
}
#else //!SILVER
VOID
HCD_EnumHardware()
/*++
Routine Description:

  On the real hardware the resource information is just hardcoded.
  HCD_MAX_HOST_CONTROLLERS is defined for 1 or 2.

  We call back USBD_NewHostController which allocates the USBD portion
  of the host controller and calls back HCD_NewHostController to
  initialize the hardware.

--*/

{
    PCI_DEVICE_DESCRIPTOR pciDevice;

    //Just return if this is Xbox MCP version A1.  USB cause interrupt storms on this
    //revision and doesn't work at all anyway.
    if (XboxHardwareInfo->McpRevision == 0xa1) return;

    pciDevice.ResourceData.Address[0].Type = CmResourceTypeMemory;
    pciDevice.ResourceData.Address[0].u.Memory.Length = XPCICFG_USB0_MEMORY_REGISTER_LENGTH_0;
    pciDevice.ResourceData.Address[0].u.Memory.TranslatedAddress = (PVOID)XPCICFG_USB0_MEMORY_REGISTER_BASE_0;
    pciDevice.ResourceData.Interrupt.Vector = HalGetInterruptVector(XPCICFG_USB0_IRQ, &pciDevice.ResourceData.Interrupt.Irql);
    USBD_NewHostController(&pciDevice, sizeof(OHCD_DEVICE_EXTENSION));
    if(1==HCD_MAX_HOST_CONTROLLERS) return;

    pciDevice.ResourceData.Address[0].Type = CmResourceTypeMemory;
    pciDevice.ResourceData.Address[0].u.Memory.Length = XPCICFG_USB1_MEMORY_REGISTER_LENGTH_0;
    pciDevice.ResourceData.Address[0].u.Memory.TranslatedAddress = (PVOID)XPCICFG_USB1_MEMORY_REGISTER_BASE_0;
    pciDevice.ResourceData.Interrupt.Vector = HalGetInterruptVector(XPCICFG_USB1_IRQ, &pciDevice.ResourceData.Interrupt.Irql);
    USBD_NewHostController(&pciDevice, sizeof(OHCD_DEVICE_EXTENSION));
}
#endif //!SILVER
    

NTSTATUS
HCD_NewHostController(
    IN PVOID  HcdExtension,
    IN UCHAR  HostControllerNumber,
    IN PPCI_DEVICE_DESCRIPTOR PciDevice
    )
/*++

Routine Description:
    
    When the USBD goes through HAL

Arguments:
    
    DeviceObject - device object associated with host controller.
    ResourceList - list of resources obtained from PCI bus.

Return Value:

    STATUS_SUCCESS.  Otherwise we will KeBugcheck before returning.

--*/
{
    HC_COMMAND_STATUS           HcCommandStatus;
    KIRQL                       oldIrql;
    POHCD_DEVICE_EXTENSION      deviceExtension = (POHCD_DEVICE_EXTENSION)HcdExtension;
    HC_FRAME_INTERVAL           frameInterval;
    BOOLEAN                     interruptConnected;
    POHCI_OPERATIONAL_REGISTERS operationalRegisters = NULL;

    //ULONG frameIntervalSniff1;
    //ULONG frameIntervalSniff2;
    //ULONG frameIntervalSniff3;
    //ULONG frameIntervalSniff4;
    //ULONG frameIntervalSniff5;

    
    USB_DBG_ENTRY_PRINT(("Entering HCD_NewHostController"));
    
    PROFILE_DECLARE_TIME_STAMP(ResetTiming);

    //
    //  Before we go initializing fields zero the whole extension.
    //  That way we can use a NULL check on pointers to see if something
    //  has been initialized yet.
    //  (Not necessary, USBD does this for us.)
    //RtlZeroMemory( (PVOID)deviceExtension, sizeof(OHCD_DEVICE_EXTENSION));

    //
    //  Remember the host controller number, it will come in
    //  handy when need to search the global TD pool for stuff
    //  that our hardware lost!
    //  (one based for USBD, but we want 0 based.)
    deviceExtension->HostControllerNumber = --HostControllerNumber;

    //
    //  Set the resources for the card.
    //
    OHCD_fSetResources(deviceExtension, PciDevice);

    //frameIntervalSniff1 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);
    //
    //  Do a quick check of version and stuff.
    //  This should only happen on preliminary development
    //  system hardware. It is used to verify that
    //  a development system is using an XBOX compatible 
    //  USB driver.  It will also be used on XBOX
    //  to verify that the hardware is what we think it
    //  should be.
    //
    OHCD_DEVSYS_CHECK_HARDWARE(deviceExtension);

    //
    //  On a development system without the final XBOX
    //  BIOS, there may be an SMM driver or BIOS
    //  driver using the Host Controller.  We need
    //  to take control.
    //
    OHCD_DEVSYS_TAKE_CONTROL(deviceExtension);

    //
    //  Get the operational registers
    //
    operationalRegisters = deviceExtension->OperationalRegisters;

#ifdef OHCD_XBOX_HARDWARE_ONLY
    //
    //  Set up the few root hub registers that should be done while
    //  the host controller is in the reset state (or before reseting).
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul, HC_RH_DESCRIPTOR_A_INIT_XBOX);
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul, HC_RH_DESCRIPTOR_B_INIT_XBOX);
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul, HC_RH_STATUS_INIT_XBOX);
#endif

    //
    //  Initialize the IsrDPC
    //
    KeInitializeDpc(&deviceExtension->IsrDpc, OHCD_IsrDpc, deviceExtension);
    
    //
    //  Get the HCCA and the physical address of it
    //
    deviceExtension->HCCA = OHCD_PoolGetHcca(HostControllerNumber);
    
    //
    //  Reset the host controller.
    //  
    //  TIMING NOTES:
    //      After writing the reset bit we must wait 10us before setting the hardware registers.
    //      However, we must complete setup and set it back to operational within 2 ms.
    //      We can easily do this in under 2ms as along as our quantum doesn't run out so
    //      raise IRQL to prevent it.
    //
    //
    HcCommandStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcCommandStatus.ul);
    HcCommandStatus.HostControllerReset = 1;
    PROFILE_BEGIN_TIMING(ResetTiming);
    oldIrql = KeRaiseIrqlToDpcLevel();
    WRITE_REGISTER_ULONG(&operationalRegisters->HcCommandStatus.ul, HcCommandStatus.ul);
    
    //
    //  Delay for 10 us  
    //
    KeStallExecutionProcessor(10);

    //frameIntervalSniff2 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);

    //
    //  Set up periodic schedule and HCCA
    //
    OHCD_ScheduleInitialize(deviceExtension);

    //frameIntervalSniff3 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);
    //
    //  See header file with HC_CONTROL_REGISTER_START
    //  it saves a few instruction rather than using the
    //  bit fields to construct the ULONG.
    //
    //  Basically, we set the state to operational, disable all of the lists,
    //  and initialize things like wakeup behavior.
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcControl.ul,HC_CONTROL_REGISTER_START|HC_CONTROL_ISOCH_ENABLE_STATE);
    
    
    //
    //  Apparently the FullSpeedMaximumPacketSize gets reset when moving to the
    //  operational state. This is slightly different then what the OpenHCI 
    //  specification seems to imply.  I read it has reseting this value to its
    //  default of 0x2edf when the
    //  So we moved these couple of lines out of OHCD_ScheduleInitialize
    //  and put them here.
    //
    
    
    frameInterval.ul = READ_REGISTER_ULONG(&operationalRegisters->HcFmInterval.ul);
    //frameIntervalSniff4 = frameInterval.ul;
    frameInterval.FrameInterval = OHCI_DEFAULT_FRAME_INTERVAL;
    frameInterval.FullSpeedMaximumPacketSize = OHCI_CLOCKS_TO_BITS(OHCI_DEFAULT_FRAME_INTERVAL);
    frameInterval.FrameIntervalToggle ^= 1;
    WRITE_REGISTER_ULONG(&operationalRegisters->HcFmInterval.ul, frameInterval.ul);
    

    //
    //  The 2ms time limit is up.  If profiling
    //  is turned let's make sure we made it
    //  within a comfortable margin.
    //  We are not worried about being interrupt
    //  so we can lower the IRQL again.
    //
    PROFILE_END_TIMING(ResetTiming);
    KeLowerIrql(oldIrql);

    //frameIntervalSniff5 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);

    //
    // Setup the interrupt vector
    //
    KeInitializeInterrupt (
        &OHCD_InterruptObject[HostControllerNumber],
        (PKSERVICE_ROUTINE) OHCD_InterruptService,            
        (PVOID) deviceExtension,                        
        PciDevice->ResourceData.Interrupt.Vector,
        PciDevice->ResourceData.Interrupt.Irql,
        LevelSensitive,
        TRUE
        );

    interruptConnected = KeConnectInterrupt(&OHCD_InterruptObject[HostControllerNumber]);
    
    ASSERT(interruptConnected && "Failed to connect to interrupt");
    
    USB_DBG_TRACE_PRINT(("Interrupt Resource Set:"));
    USB_DBG_TRACE_PRINT(("  Irql(Level) = %d", PciDevice->ResourceData.Interrupt.Irql));
    USB_DBG_TRACE_PRINT(("  Vector      = %d", PciDevice->ResourceData.Interrupt.Vector));
    USB_DBG_TRACE_PRINT(("  Assigned InterruptObject at 0x%0.8x", &OHCD_InterruptObject[HostControllerNumber]));
    USB_DBG_TRACE_PRINT(("  IoConnectInterrupt returned 0x%0.8x", ntStatus));

    //
    //  Register for shutdown notification (now that we have an interrupt object,
    //  but before enabling interrupts.
    //

    deviceExtension->ShutdownRegistration.NotificationRoutine = OHCD_ShutDown;
    deviceExtension->ShutdownRegistration.Priority = 1;
    InitializeListHead(&deviceExtension->ShutdownRegistration.ListEntry);
    HalRegisterShutdownNotification(&deviceExtension->ShutdownRegistration, TRUE);

    //
    //  Enable Interrupts
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcInterruptEnable, 
                            HCINT_SchedulingOverrun |
                            HCINT_WritebackDoneHead |
                            HCINT_UnrecoverableError |
                            HCINT_FrameNumberOverflow |
                            HCINT_MasterInterruptEnable
                            );

    //USB_DBG_WARN_PRINT(("frameIntervalSniff1 = 0x%0.8x", frameIntervalSniff1));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff2 = 0x%0.8x", frameIntervalSniff2));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff3 = 0x%0.8x", frameIntervalSniff3));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff4 = 0x%0.8x", frameIntervalSniff4));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff5 = 0x%0.8x", frameIntervalSniff5));

    //
    //  Now kick of detection of devices, by initializing the root hub.
    //
    OHCD_RootHubInitialize(deviceExtension);


    USB_DBG_EXIT_PRINT(("Exiting HCD_NewHostController"));
    return STATUS_SUCCESS;
}
#pragma code_seg(".XPPCODE")

USBD_STATUS
HCD_SubmitRequest(
    IN PVOID        HcdDeviceExtension,
    IN PURB         Urb
    )
/*++

Routine Description:

   Process URBs from the USBD layer.

Arguments:

   DeviceObject - pointer to a device object

   HcdUrb - pointer to a USB Request Block

Return Value:


--*/
{
    USBD_STATUS             usbdStatus = USBD_STATUS_SUCCESS;
    POHCD_DEVICE_EXTENSION  deviceExtension = (POHCD_DEVICE_EXTENSION)HcdDeviceExtension;
    
    USB_DBG_ENTRY_PRINT(("Entering HCD_SubmitRequest"));
    switch (Urb->Header.Function)
    {
        //
        // Open Endpoint and Close Endpoint IRPs are serialized
        // within USBD so we can execute them now.
        //
        case URB_FUNCTION_OPEN_ENDPOINT:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_OPEN_ENDPOINT"));
            usbdStatus = OHCD_fOpenEndpoint(deviceExtension, Urb);
            break;
        case URB_FUNCTION_CLOSE_ENDPOINT:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_CLOSE_ENDPOINT"));
            usbdStatus = OHCD_fCloseEndpoint(deviceExtension, Urb);
            break;
        case URB_FUNCTION_CONTROL_TRANSFER:
        case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_<XXXX>_TRANSFER"));
            ASSERT(Urb->CommonTransfer.EndpointHandle);
            usbdStatus = OHCD_fQueueTransferRequest(deviceExtension, Urb);
            break;
        case URB_FUNCTION_GET_FRAME_NUMBER:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_GET_CURRENT_FRAME_NUMBER"));
            Urb->GetFrame.FrameNumber = OHCD_Get32BitFrameNumber(deviceExtension);
            usbdStatus = USBD_STATUS_SUCCESS;
            break;
        case URB_FUNCTION_GET_ENDPOINT_STATE:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_GET_ENDPOINT_STATE"));
            usbdStatus=OHCD_fGetEndpointState(deviceExtension, Urb);
            break;
        case URB_FUNCTION_SET_ENDPOINT_STATE:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_SET_ENDPOINT_STATE"));
            usbdStatus=OHCD_fSetEndpointState(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ABORT_ENDPOINT:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_ABORT_ENDPOINT"));
            usbdStatus=OHCD_fAbortEndpoint(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_OPEN_ENDPOINT:
            usbdStatus=OHCD_ISOCH_OPEN_ENDPOINT(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_CLOSE_ENDPOINT:
            usbdStatus=OHCD_ISOCH_CLOSE_ENDPOINT(deviceExtension, Urb);
            break;                                
        case URB_FUNCTION_ISOCH_ATTACH_BUFFER:
            usbdStatus=OHCD_ISOCH_ATTACH_BUFFERS(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_START_TRANSFER:
            usbdStatus=OHCD_ISOCH_START_TRANSFER(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_STOP_TRANSFER:
            usbdStatus=OHCD_ISOCH_STOP_TRANSFER(deviceExtension, Urb);
            break;
        default:
            ASSERT(FALSE && "Unsupported URB");
            usbdStatus = USBD_STATUS_INVALID_URB_FUNCTION;
    }

    //
    //  If we are not returning a pending status
    //  than we should call CompleteUsbRequest.
    //  
    if(!USBD_PENDING(usbdStatus ))
    {
        Urb->Header.Status = usbdStatus;
        USBD_CompleteRequest(Urb);
    }
    USB_DBG_EXIT_PRINT(("Exiting HCD_SubmitRequest: usbdStatus = 0x%0.8x", usbdStatus));
    return usbdStatus;
}


USBD_STATUS
HCD_CancelRequest(
    IN PVOID    HcdDeviceExtension,
    IN PURB     Urb
    )
/*++

Routine Description:

    Entry point called by USBD to cancel a transfer request.
    
    The URB could be either in a queue waiting to be programmed,
    or already programmed.
    
    If it is in a queue, we can find it, remove it, and complete
    as canceled right here.

    If it has been programmed, then we need to pause the endpoint,
    and place the Urb on the PendingCancels list.  On the next
    frame, we can access the endpoint from the DPC and cancel the URB.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to previously submitted URB to cancel

  Return Value:
        USBD_STATUS_CANCELED    - Urb has been canceled.
        USBD_STATUS_CANCELING   - Urb is in process of being canceled.
--*/
{
    POHCD_ENDPOINT          endpoint;
    USBD_STATUS             status = USBD_STATUS_CANCELED;
    POHCD_DEVICE_EXTENSION  deviceExtension = (POHCD_DEVICE_EXTENSION)HcdDeviceExtension;
    KIRQL                   oldIrql;

    USB_DBG_ENTRY_PRINT(("Entering HCD_CancelRequest"));
    //
    //  Only control, bulk and interrupt transfers can be cancelled.
    //  if the URB is not a transfer (or an isochronous transfer).
    //  There is a bug in the caller's code (USBD, or class driver).
    //
    ASSERT( 
        (URB_FUNCTION_CONTROL_TRANSFER == Urb->Header.Function) ||
        (URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER == Urb->Header.Function)
        );

    //
    //  It is not inconceivable that an URB would legitimately get canceled twice.
    //  Just ignore it if it happens.
    //
    if(Urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_CANCELED)
    {
        return USBD_STATUS_CANCELING;
    }

    //
    //  We need to be at dispatch level while handling
    //  queues and stuff.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  If the URB has been queued, but not yet programmed
    //  we can handle everything here and now.
    endpoint = (POHCD_ENDPOINT)Urb->CommonTransfer.EndpointHandle;
    
    //
    //  If the endpoint is in the process of being closed
    //  ignore the cancel request.
    //
    if(OHCD_ENDPOINT_FLAG_CLOSING&endpoint->Flags)
    {
        status = USBD_STATUS_CANCELING;
        goto ExitHCD_CancelRequest;
    }

    if(Urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_QUEUED)
    {
        //
        //  Dispatch to the proper routine to dequeue the URB
        //
        switch(endpoint->EndpointType)
        {
            case USB_ENDPOINT_TYPE_CONTROL:
                OHCD_fDequeueControlTransfer(deviceExtension, Urb);
                break;
            case USB_ENDPOINT_TYPE_BULK:
                OHCD_fDequeueBulkTransfer(deviceExtension, Urb);
                break;
            case USB_ENDPOINT_TYPE_INTERRUPT:
                OHCD_fDequeueInterruptTransfer(endpoint, Urb);
                break;
            default:
                //ISOCH endpoint never expected here.
                USB_DBG_ERROR_PRINT(("Unrecognized or Unsupported endpoint type in HCD_CancelRequest"));
                //Execution should be able to continue.
                status = USBD_STATUS_REQUEST_FAILED;
                goto ExitHCD_CancelRequest;
        }
        endpoint->QueuedUrbCount--;
        Urb->Header.Status = USBD_STATUS_CANCELED;
        Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_CANCELED;
        USBD_CompleteRequest(Urb);
        status = USBD_STATUS_SUCCESS;
    } else 
    {
        //
        //  If we are not queued than we ought to be programmed.
        //
        ASSERT(Urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_PROGRAMMED);

        //
        //  Mark the URB canceled.
        //
        Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_CANCELED;

        //
        //  Add the URB to the PendingCancels list.
        //
        Urb->CommonTransfer.Hca.HcdUrbLink = deviceExtension->PendingCancels;
        deviceExtension->PendingCancels = Urb;

        //
        //  Pause the endpoint, the IsrDPC
        //  will take care of the rest.
        //
        OHCD_fPauseEndpoint(deviceExtension, endpoint);
        status = USBD_STATUS_CANCELING;
    }
    
    //
    //  Done with queues and stuff
    //
ExitHCD_CancelRequest:
    KeLowerIrql(oldIrql);
    
    USB_DBG_EXIT_PRINT(("Exiting HCD_CancelRequest: status = 0x%0.8x", status));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fOpenEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

    Opens an endpoint.  This is a multistep process:

    1)  Get an endpoint

    2)  Zero the memory.
      
    3)  Initialize the endpoint header
    
    4)  Insert Endpoint in schedule.
	5)  Update the handle, or cleanup if something failed.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to URB which contains an open endpoint 
                        request

  Return Value:

    Error code several failure cases:
    1) Cannot allocate Endpoint.
    2) Cannot reserved descriptor blocks
    3) Not enough bandwidth in schedule (isoch and interrupt only)

--*/
{
    POHCD_ENDPOINT  newEndpoint = NULL;
    USBD_STATUS     status = USBD_STATUS_SUCCESS;
    KIRQL           oldIrql;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_OpenEndpoint"));

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  1) Allocate an endpoint from the pool.
    //
    newEndpoint = OHCD_PoolAllocateEndpoint();
    if(!newEndpoint)
    {
        USB_DBG_WARN_PRINT(("Attempt to exceed registered endpoints."));
        status = USBD_STATUS_NO_MEMORY;
        goto ExitOpenEndpoint;
    }

    //
    // 2) Zero memory and set flags
    //
    USB_DBG_ENTRY_PRINT(("Zeroing structure."));
    RtlZeroMemory( (PVOID)newEndpoint, sizeof(OHCD_ENDPOINT));

    //
    //  It is helpful to cache our physical address
    //
    newEndpoint->PhysicalAddress = OHCD_PoolGetPhysicalAddress(newEndpoint);

    //
    //  Save off the endpoint type
    //
    newEndpoint->EndpointType = Urb->OpenEndpoint.EndpointType;

    //
    //  Fill out polling interval, and bandwidth
    //
    newEndpoint->PollingInterval = Urb->OpenEndpoint.Interval;
    newEndpoint->Bandwidth = USBD_CalculateUsbBandwidth(
                                    Urb->OpenEndpoint.MaxPacketSize,
                                    newEndpoint->EndpointType,
                                    Urb->OpenEndpoint.LowSpeed
                                    );

    //
    //  Fill out everything in the control structure.
    //  Note the Direction here is set correctly for non-control endpoints.
    //  in the next step we have an if USB_ENDPOINT_TYPE_CONTROL and we fix it
    //  for the control endpoints.
    //
    newEndpoint->HcEndpointDescriptor.Control.FunctionAddress = Urb->OpenEndpoint.FunctionAddress;
    newEndpoint->HcEndpointDescriptor.Control.EndpointAddress = Urb->OpenEndpoint.EndpointAddress;
    if(USB_ENDPOINT_TYPE_CONTROL == newEndpoint->EndpointType)
    {
        newEndpoint->HcEndpointDescriptor.Control.Direction = 0;
    }else
    {
        newEndpoint->HcEndpointDescriptor.Control.Direction = (USB_ENDPOINT_DIRECTION_MASK & Urb->OpenEndpoint.EndpointAddress) ? 2 : 1;
    }
    newEndpoint->HcEndpointDescriptor.Control.Speed =  Urb->OpenEndpoint.LowSpeed;
    newEndpoint->HcEndpointDescriptor.Control.Skip = 1;
    newEndpoint->HcEndpointDescriptor.Control.Format = 0;
    newEndpoint->HcEndpointDescriptor.Control.MaximumPacketSize = Urb->OpenEndpoint.MaxPacketSize;

    //
    //  We do not have any URBs now either.
    //
    /*  Unneccessary, we zeroed the structure right after allocating it.
    newEndpoint->PendingUrbHeadP =
    newEndpoint->PendingUrbTailP =
    newEndpoint->PendingUrbCurrentP = NULL;
    */

    //
    //  3) Initialize Endpoint descriptor.
    //
    newEndpoint->HcEndpointDescriptor.NextED = 0;
    newEndpoint->HcEndpointDescriptor.HeadPHaltCarry = 0;
    newEndpoint->HcEndpointDescriptor.TailP = 0;

    //
    //  Set the initial data toggle
    //
    if(Urb->OpenEndpoint.DataToggleBits)
    {
        ULONG dataToggleMask = 1 << newEndpoint->HcEndpointDescriptor.Control.EndpointAddress;
        if(newEndpoint->HcEndpointDescriptor.Control.Direction == 2)
        {
            dataToggleMask <<= 16;
        }
        if((*Urb->OpenEndpoint.DataToggleBits)&dataToggleMask)
        {
            SET_TOGGLECARRY(&newEndpoint->HcEndpointDescriptor);
        }
    }

    //
    //  4) Insert endpoint into schedule, and
    //
    if( USB_ENDPOINT_TYPE_CONTROL == newEndpoint->EndpointType ||
        USB_ENDPOINT_TYPE_BULK == newEndpoint->EndpointType )
    //
    //  Control or bulk
    //
    {
        OHCD_ScheduleAddEndpointControlOrBulk(DeviceExtension, newEndpoint);
    }
    else
    //
    //  Interrupt
    //
    {
        ASSERT(USB_ENDPOINT_TYPE_INTERRUPT == newEndpoint->EndpointType);
        //
        //  Scheduling Periodic Endpoints can fail due to lack of bandwidth.
        //
        status = OHCD_ScheduleAddEndpointPeriodic(DeviceExtension, newEndpoint);
    }

    //
    //  5) Udpate URB handle
    //
    if(USBD_SUCCESS(status))
    {
        Urb->OpenEndpoint.EndpointHandle = newEndpoint;
    }
    else
    {
        Urb->OpenEndpoint.EndpointHandle = NULL;
        OHCD_PoolFreeEndpoint(newEndpoint);
    }

ExitOpenEndpoint:
    Urb->Header.Status = status;
    KeLowerIrql(oldIrql);
    USB_DBG_EXIT_PRINT(("Exiting OHCD_OpenEndpoint: usbdStatus = 0x%0.8x", status));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fCloseEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
{
    POHCD_ENDPOINT  endpoint = (POHCD_ENDPOINT)Urb->CloseEndpoint.EndpointHandle;
    KIRQL           oldIrql;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_CloseEndpoint"));

    oldIrql = KeRaiseIrqlToDpcLevel();
    endpoint->Flags |= OHCD_ENDPOINT_FLAG_CLOSING;

    //
    //  Cancel any queued URBs (but not programmed) right now.
    //
    OHCD_fCancelQueuedUrbs(DeviceExtension, endpoint);

    //
    //  Remove endpoint from schedule
    //
    ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS != endpoint->EndpointType);
    if( USB_ENDPOINT_TYPE_CONTROL == endpoint->EndpointType ||
        USB_ENDPOINT_TYPE_BULK == endpoint->EndpointType )
    //
    //  Control or bulk
    //
    {
        OHCD_ScheduleRemoveEndpointControlOrBulk(DeviceExtension, endpoint);
    }
    else
    //
    //  Interrupt
    //
    {
        OHCD_ScheduleRemoveEndpointPeriodic(DeviceExtension, endpoint);
    }

    //
    //  Add to endpoint reclamation queue, we do not need to pause it,
    //  but the pause routine is convenient.
    //
    OHCD_fPauseEndpoint(DeviceExtension, endpoint);
    
    //
    //  Link the URB into the list of pending closes.
    //

    ASSERT(DeviceExtension->PendingCloses != Urb);
    
    Urb->CloseEndpoint.HcdNextClose = DeviceExtension->PendingCloses;
    DeviceExtension->PendingCloses = Urb;
    
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_CloseEndpoint: usbdStatus = USBD_STATUS_PENDING"));
    return USBD_STATUS_PENDING;
}

USBD_STATUS
FASTCALL
OHCD_fGetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

    Gets the endpoint state.  The state consists of two flags:

        USB_ENDPOINT_TRANSFERS_QUEUED
        USB_ENDPOINT_HALTED

Arguments:

    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to URB that we are servicing.

  Return Value:

    USBD_STATUS_SUCCESS

--*/

{
    POHCD_ENDPOINT endpoint = (POHCD_ENDPOINT)Urb->GetSetEndpointState.EndpointHandle;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_GetEndpointState"));
    USB_DBG_TRACE_PRINT(("Endpoint state flags:"));
    //
    //  Get whether or not is halted
    //
    Urb->GetSetEndpointState.EndpointState = 
        GET_HALTED(&endpoint->HcEndpointDescriptor) ? USB_ENDPOINT_STATE_HALTED : 0;

    USB_DBG_TRACE_PRINT(("%s",(Urb->GetSetEndpointState.EndpointState&USB_ENDPOINT_STATE_HALTED)?"     USB_ENDPOINT_HALTED":NULL));

    //
    //  Now set the USB_ENDPOINT_TRANSFERS_QUEUED flag.
    //
    
    if(endpoint->QueuedUrbCount || endpoint->ProgrammedUrbCount)
    {
        Urb->GetSetEndpointState.EndpointState |= USB_ENDPOINT_STATE_TRANSFERS_QUEUED;
        USB_DBG_TRACE_PRINT(("     USB_ENDPOINT_STATE_TRANSFERS_QUEUED"));
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_GetEndpointState"));
    return USBD_STATUS_SUCCESS;
}

USBD_STATUS
FASTCALL
OHCD_fSetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

    Sets the endpoint state.  Basically, it can do only do things.
    Restart a halted endpoint.  Reset the data toggle on an endpoint.

    1) If USB_ENDPOINT_RESET_DATA_TOGGLE is set, we will reset the data toggle.
    2) If USB_ENDPOINT_HALTED is clear, we clear the halt bit.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to URB that we are servicing.

  Return Value:

    USBD_STATUS_SUCCESS

--*/
{
    POHCD_ENDPOINT endpoint = (POHCD_ENDPOINT)Urb->GetSetEndpointState.EndpointHandle;
    ULONG state = Urb->GetSetEndpointState.EndpointState;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_SetEndpointState"));
    if(state & USB_ENDPOINT_STATE_DATA_TOGGLE_RESET)
    {
        USB_DBG_TRACE_PRINT(("Clearing the toggle carry."));
        CLEAR_TOGGLECARRY(&endpoint->HcEndpointDescriptor);
    }
    if(state & USB_ENDPOINT_STATE_DATA_TOGGLE_SET)
    {
        USB_DBG_TRACE_PRINT(("Setting the toggle carry."));
        SET_TOGGLECARRY(&endpoint->HcEndpointDescriptor);
    }
    if(!(state & USB_ENDPOINT_STATE_KEEP_HALT) && GET_HALTED(&endpoint->HcEndpointDescriptor))
    {
        USB_DBG_TRACE_PRINT(("Clearing a halt condition."));
        CLEAR_HALTED(&endpoint->HcEndpointDescriptor);
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_SetEndpointState"));
    return USBD_STATUS_SUCCESS;
}

USBD_STATUS
FASTCALL
OHCD_fAbortEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

   Cancels all of the requests associated with a particular
   endpoint.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    Urb             - Pointer to URB that we are servicing.

  Return Value:

    USBD_STATUS_SUCCESS

--*/
{
//
    POHCD_ENDPOINT  endpoint = (POHCD_ENDPOINT)Urb->AbortEndpoint.EndpointHandle;
    KIRQL           oldIrql;
    USBD_STATUS     status = USBD_STATUS_SUCCESS;
    
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  Cancel any queued URBs (but not programmed) right now.
    //
    OHCD_fCancelQueuedUrbs(DeviceExtension, endpoint);

    //
    //  If there are urbs programmed, we need to queue
    //  the abort urb, and pause the endpoint.
    //
    if(endpoint->ProgrammedUrbCount)
    {
        //
        //  Queue Abort Urb
        //
        Urb->AbortEndpoint.HcdNextAbort = DeviceExtension->PendingAborts;
        DeviceExtension->PendingAborts = Urb;
        OHCD_fPauseEndpoint(DeviceExtension, endpoint);
        status = USBD_STATUS_PENDING;
    }
    KeLowerIrql(oldIrql);

    return status;
}


#pragma code_seg(".XPPCINIT")
VOID
FASTCALL
OHCD_fSetResources(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    PPCI_DEVICE_DESCRIPTOR      PciDevice
    )
/*++

Routine Description:

    This routines uses the Hal routines to configure
    the PCI bus for the card.  And store those settings.
    
    This is two stages:
    1) Initialize out device extension with proper base address.
    2) Create an NT interrupt object.

Arguments:

   DeviceExtension      - DeviceExtension for this USB controller.
   PciDevice            - PCI BAR for device

Return Value:

    None

Failures:
    Assume everything works.  Assert failures.  Basically
    any possible errors are configuration, these shouldn't
    happen.

--*/
{
    USB_DBG_ENTRY_PRINT(("Entering OHCD_SetResources"));
    //
    //  Record memory resource
    //
    ASSERT(PciDevice->ResourceData.Address[0].Type == CmResourceTypeMemory);
    ASSERT(PciDevice->ResourceData.Address[0].u.Memory.Length >= sizeof(OHCI_OPERATIONAL_REGISTER_SIZE));
    DeviceExtension->OperationalRegistersLength = PciDevice->ResourceData.Address[0].u.Memory.Length;
    DeviceExtension->OperationalRegisters = 
        (POHCI_OPERATIONAL_REGISTERS)PciDevice->ResourceData.Address[0].u.Memory.TranslatedAddress;
    USB_DBG_TRACE_PRINT(("Virtual Register Address = 0x%0.8x", DeviceExtension->OperationalRegisters));
    
    USB_DBG_EXIT_PRINT(("Exiting OHCD_SetResources"));
    return;
}
#pragma code_seg(".XPPCODE")

VOID
FASTCALL
OHCD_fDequeueControlTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    )
{
    //
    //  Walk the control transfer queue and find the URB
    //
    PURB urbOnQueue = DeviceExtension->ControlUrbHeadP;
    PURB prevUrbOnQueue = NULL;
    while(urbOnQueue != Urb)
    {
        //
        //  Serious error, if we got to the end of the queue and didn't find it.
        //
        ASSERT(urbOnQueue != DeviceExtension->ControlUrbTailP);
        //
        //  Walk link for next iteration
        //
        prevUrbOnQueue = urbOnQueue;
        urbOnQueue = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    
    //
    //  Remove the Urb
    //
    if(NULL == prevUrbOnQueue)
    {
        DeviceExtension->ControlUrbHeadP = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    } else
    {
        prevUrbOnQueue->CommonTransfer.Hca.HcdUrbLink = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    //
    //  If it was the last URB, update the tail pointer too.
    //
    if(Urb == DeviceExtension->ControlUrbTailP)
    {
        DeviceExtension->ControlUrbTailP = prevUrbOnQueue;
    }
}

VOID
FASTCALL
OHCD_fDequeueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    )
{
    //
    //  Walk the control transfer queue and find the URB
    //
    PURB urbOnQueue = DeviceExtension->BulkUrbHeadP;
    PURB prevUrbOnQueue = NULL;
    while(urbOnQueue != Urb)
    {
        //
        //  Serious error, if we got to the end of the queue and didn't find it.
        //
        ASSERT(urbOnQueue != DeviceExtension->BulkUrbTailP);
        //
        //  Walk link for next iteration
        //
        prevUrbOnQueue = urbOnQueue;
        urbOnQueue = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    
    //
    //  Remove the Urb
    //
    if(NULL == prevUrbOnQueue)
    {
        DeviceExtension->BulkUrbHeadP = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    } else
    {
        prevUrbOnQueue->CommonTransfer.Hca.HcdUrbLink = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    //
    //  If it was the last URB, update the tail pointer too.
    //
    if(Urb == DeviceExtension->BulkUrbTailP)
    {
        DeviceExtension->BulkUrbTailP = prevUrbOnQueue;
    }
}

VOID
FASTCALL
OHCD_fDequeueInterruptTransfer(
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    )
{
    //
    //  Walk the control transfer queue and find the URB
    //
    PURB urbOnQueue = Endpoint->PendingUrbHeadP;
    PURB prevUrbOnQueue = NULL;
    while(urbOnQueue != Urb)
    {
        //
        //  Serious error, if we got to the end of the queue and didn't find it.
        //
        ASSERT(urbOnQueue != Endpoint->PendingUrbTailP);
        //
        //  Walk link for next iteration
        //
        prevUrbOnQueue = urbOnQueue;
        urbOnQueue = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    
    //
    //  Remove the Urb
    //
    if(NULL == prevUrbOnQueue)
    {
        Endpoint->PendingUrbHeadP = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    } else
    {
        prevUrbOnQueue->CommonTransfer.Hca.HcdUrbLink = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    //
    //  If it was the last URB, update the tail pointer too.
    //
    if(Urb == Endpoint->PendingUrbTailP)
    {
        Endpoint->PendingUrbTailP = prevUrbOnQueue;
    }
}

VOID
FASTCALL
OHCD_fCancelQueuedUrbs(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

 Routine Description:

    Called by OHCD_AbortEndpoint and OHCD_CloseEndpoint, to
    cancel any Urbs which have been queued, but not yet programmed.
   
    Different types of endpoints have URBs queued in different
    places.  We first switch on the endpoint type, to initialize
    pointers to the queue pointers.

    Then we walk the queue using pointers to pointers.  I will
    be the first to admit that this is style of code is not
    terribly readable.  However, it is efficient, so I tried to
    just comment well.
    
Arguments:

   DeviceExtension      - DeviceExtension for this USB controller.

   Endpoint             - Endpoint to cancel URBs for.

Return Value:

    None

--*/
{

    PURB    *currentUrbP;                       //Pointer to official pointer to the URB we are currently processing
    PURB    *tailUrbP;                          //Pointer to official pointer to the tail URB in queue
    PURB    currentUrb = NULL;                  //Local pointer to current URB we are working.
    PURB    previousUrb;                        //Local pointer to the last URB prior to the current one that was not canceled.
    PVOID   endpointHandle = (PVOID) Endpoint;

    //
    //  We need to synchronize.
    //
    ASSERT_DISPATCH_LEVEL();
        
    //
    //  If there are any Urbs in the queue . . .
    //
    if(Endpoint->QueuedUrbCount)
    {
        //
        //  Where the heads and tails are stored
        //  depends on the endpoint type.
        //
        switch(Endpoint->EndpointType)
        {
            case USB_ENDPOINT_TYPE_CONTROL:
                currentUrbP = &DeviceExtension->ControlUrbHeadP;
                tailUrbP = &DeviceExtension->ControlUrbTailP;
                break;
            case USB_ENDPOINT_TYPE_BULK:
                currentUrbP = &DeviceExtension->BulkUrbHeadP;
                tailUrbP = &DeviceExtension->BulkUrbTailP;
                break;
            case USB_ENDPOINT_TYPE_INTERRUPT:
                currentUrbP = &Endpoint->PendingUrbHeadP;
                tailUrbP = &Endpoint->PendingUrbTailP;
                break;
			default:
                //ISOCH endpoint never expected here.
                USB_DBG_ERROR_PRINT(("Unrecognized endpoint type in OHCD_CancelQueuedUrbs"));
                //This is a serious error, continued execution might be feasible.
                return;
        }
        //
        //  Walk queue and remove any URB associated with Endpoint
        //
        do
        {
            currentUrb = *currentUrbP;
            ASSERT(currentUrb); //A serious coding error if we hit this.
            //
            //  If the URB belongs to this endpoint cancel it.
            //
            if(currentUrb->CommonTransfer.EndpointHandle == endpointHandle)
            {
                //
                //  Whoever was pointing at this urb, should now point to whoever
                //  this urb is pointing to.
                //
                *currentUrbP = currentUrb->CommonTransfer.Hca.HcdUrbLink;
                //
                //  Cancel the Urb
                //
                currentUrb->Header.Status = USBD_STATUS_CANCELED;
                Endpoint->QueuedUrbCount--;
                USBD_CompleteRequest(currentUrb);
            }
            //
            //  Otherwise skip the urb.
            //
            else
            {
                //
                //  This urb is now the official pointer to the next current URB.
                //  Since we didn't cancel it, it also the new previousUrb.
                //
                previousUrb = currentUrb;
                currentUrbP = &currentUrb->CommonTransfer.Hca.HcdUrbLink;
            }
        }while(*tailUrbP != currentUrb);
        //
        //  The official pointer to the tail URB, should now
        //  point to the last URB we didn't cancel.
        //
        *tailUrbP = previousUrb;
        //
        //  That should have dequeued every urb associated with the endpoint.
        //
        ASSERT(0 == Endpoint->QueuedUrbCount);
    }
}

VOID
FASTCALL
OHCD_fPauseEndpoint(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT  Endpoint
    )
/*++

 Routine Description:

    This routines makes sure that endpoint gets paused if it is not already.

Arguments:

   DeviceExtension      - DeviceExtension for this USB controller.

   Endpoint             - Endpoint to pause.

Return Value:

    None

--*/
{
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_PauseEndpoint"));
    
    ASSERT_DISPATCH_LEVEL();
    
    //
    // We reference count pauses
    //
    Endpoint->PendingPauseCount++;
    //
    //  If a pause is not already in progess,
    //  then pause it.
    if(!(Endpoint->Flags & OHCD_ENDPOINT_FLAG_PAUSING))
    {
        //
        //  Set the Skip bit
        //
        Endpoint->HcEndpointDescriptor.Control.Skip = TRUE;
        //
        //  Set the frame that we need to wait for.
        //
        Endpoint->PauseFrame = OHCD_Get32BitFrameNumber(DeviceExtension) + 1;
        
        //
        // Decide if we need to set the delay pause flag,
        // if are called between an interrupt and the DPC
        // to handle that interupt.  THIS MUST BE AFTER SETTING
        // THE SKIP BIT. The call to OHCD_Get32BitFrameNumber
        // should ensure that the compiler doesn't reorder this.
        //
        if(DeviceExtension->IsrDpc_Context.InterruptsSignaled)
        {
            Endpoint->Flags |= OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
        }

        //
        //  Clear the status indicator for StartOfFrame.
        //
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcInterruptStatus, HCINT_StartOfFrame);
        //
        //  Enable the StartOfFrame interrupt
        //
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcInterruptEnable, HCINT_StartOfFrame);
        //
        //  Set the OHCD_ENDPOINT_FLAG_PAUSING_FLAG;
        //
        Endpoint->Flags |= OHCD_ENDPOINT_FLAG_PAUSING;
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_PauseEndpoint"));
}


VOID
OHCD_ShutDown(
    PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration
    )
/*++
    Routine Description: 
        Called by the HAL in order to do a quick reboot.  Basically,
        our job is to shut off the host controller, so that no extraneous
        calls happen during shutdown.
    Arguments:
        ShutdownRegistration - Shutdown registration that we passed to 
            HalRegisterShutdown.  We can use CONTAINING_RECORD to
            our device extension.
--*/
{
    POHCD_DEVICE_EXTENSION deviceExtension;
    KIRQL oldIrql;
    
    deviceExtension = CONTAINING_RECORD(
                            ShutdownRegistration,
                            OHCD_DEVICE_EXTENSION,
                            ShutdownRegistration
                            );

    KeRaiseIrql((KIRQL)OHCD_InterruptObject[deviceExtension->HostControllerNumber].Irql, &oldIrql);

    //
    //  Disable all interrupts
    //
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcInterruptDisable,
        HCINT_SchedulingOverrun |
        HCINT_WritebackDoneHead |
        HCINT_UnrecoverableError |
        HCINT_FrameNumberOverflow |
        HCINT_MasterInterruptEnable
       );

    //
    //  Reset the Host Controller
    //
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcControl.ul,
        HC_CONTROL_REGISTER_STOP
        );

    KeLowerIrql(oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\isr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    isr.c

Abstract:
    
    Implementation of the OpenHCI interrupt service routine and related code
    including the DPC.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-24-00 created by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

int IsrEntryCount=0;
//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
VOID
FASTCALL
OHCD_fProcessDoneTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    );

VOID
FASTCALL
OHCD_fProcessFailedTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    );

VOID
FASTCALL
OHCD_fCompleteRequest(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    );

VOID
FASTCALL
OHCD_fCreditTDQuota(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint
    );

BOOLEAN
FASTCALL
OHCD_fProcessCancelPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    );

BOOLEAN
FASTCALL
OHCD_fProcessAbortPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    );

BOOLEAN
FASTCALL
OHCD_fProcessClosePendingList(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    );

VOID
FASTCALL
OHCD_fCleanEndpointTDs(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint
    );

//----------------------------------------------------------------------------
// Implementation of function called from other modules:
//      OHCD_InterruptService
//      OHCD_IsrDpc
//      OHCD_Get32BitFrameNumber
//----------------------------------------------------------------------------
BOOLEAN 
OHCD_InterruptService( 
    IN PKINTERRUPT Interrupt, 
    IN PVOID ServiceContext 
    )
{
    POHCD_DEVICE_EXTENSION      deviceExtension = (POHCD_DEVICE_EXTENSION)ServiceContext;
    ULONG                       interruptsSignaled;
    ULONG                       interruptEnable;
    POHCI_OPERATIONAL_REGISTERS HcRegs = deviceExtension->OperationalRegisters;
        
    IsrEntryCount++;
    //
    //  Get the interrupts which are actually signaled on USB.  According to OpenHCI 7.1.5
    //  the ine bits set in HcInterruptEnable and in HcInterrupt are actually signaled.
    //
    //
    interruptEnable = READ_REGISTER_ULONG(&HcRegs->HcInterruptEnable);
    interruptsSignaled = interruptEnable &  READ_REGISTER_ULONG(&HcRegs->HcInterruptStatus);

    //
    //  If an enabled interrupt was not signaled, or if the master interrupt
    //  is off this interrupt couldn't have been for us.
    //
    if( (0 == interruptsSignaled) || !(interruptEnable&HCINT_MasterInterruptEnable) ) return FALSE;

    //
    // Disable Interrupts on Host Controller
    //
    WRITE_REGISTER_ULONG(&HcRegs->HcInterruptDisable, HCINT_MasterInterruptEnable);

    //**
    //**    In sequence check and handle the following conditions:
    //**
    //**    SchedulingOverrun
    //**    FrameNumberOverflow
    //**
    //**    The following conditions are handled only in the DPC:
    //**
    //**    WritebackDoneHead
    //**    StartOfFrame
    //**    UnrecoverableError
    //**    RootHubStatusChange
    //**

    //
    // Today we ack but otherwise ignore a SchedulingOverrun interrupt.
    // In the future we may want to do something as suggested in section
    // 5.2.10.1 of the OpenHCI specification.
    //
    if (interruptsSignaled & HCINT_SchedulingOverrun)
    {
        WRITE_REGISTER_ULONG(&HcRegs->HcInterruptStatus, HCINT_SchedulingOverrun);
        //
        //  record that we handled the interrupt
        //
        interruptsSignaled &= ~HCINT_SchedulingOverrun;
    }

    //
    // Check for Frame Number Overflow The following insures that the 32 bit
    // frame never runs backward.
    //
    if (interruptsSignaled & HCINT_FrameNumberOverflow)
    {
        //
        //  Fix up our high part.
        //
        deviceExtension->FrameHighPart += 0x10000 -
                    (0x8000 & (deviceExtension->HCCA->FrameNumber ^ deviceExtension->FrameHighPart));
        //
        //  Clear the status flag, we handled it.
        //
        WRITE_REGISTER_ULONG(&HcRegs->HcInterruptStatus, HCINT_FrameNumberOverflow);

        //
        //  record that we handled the interrupt
        //
        interruptsSignaled &= ~HCINT_FrameNumberOverflow;
    };
    
    //
    //  If there is something left to do,
    //  queue a DPC item, let the DPC reenable interrupts
    //  when it is done.
    //
    if(interruptsSignaled)
    {
        deviceExtension->IsrDpc_Context.InterruptsSignaled  = interruptsSignaled;
        KeInsertQueueDpc(&deviceExtension->IsrDpc, NULL, NULL);
    }
    else
    {
        //
        // If we didn't queue anything than reenable interrupts.
        //
        WRITE_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcInterruptEnable, HCINT_MasterInterruptEnable);
    }
    return TRUE;
}

VOID
OHCD_IsrDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    )
/*++

Routine Description:

  The OHCD_InterruptService will have queued the DPC, if any of the following
  conditions occured:

    WritebackDoneHead
    StartOfFrame
    UnrecoverableError
    RootHubStatusChange

  We handled any and all of these conditions which are present, and then
  reenable interrupts for the host controller.

Arguments:

    Dpc                 - pointer to our DPC object
    DeviceExtensionPtr  - pointer to device extension for our HC.

    Bogus1              - These are arguments that the ISR
    Bogus2              - could have supplied, but we don't need them.

Return Value:
    
    Noned

--*/               
{
    //
    //  Declare and initialize a whole bunch of convenience variables.
    //
    POHCD_DEVICE_EXTENSION          deviceExtension = (POHCD_DEVICE_EXTENSION)DeviceExtensionPtr;
    POHCI_OPERATIONAL_REGISTERS     hcRegs = deviceExtension->OperationalRegisters;
    ULONG                           interruptsSignaled = deviceExtension->IsrDpc_Context.InterruptsSignaled;
    ULONG                           doneHead;
    POHCD_TRANSFER_DESCRIPTOR       completedTDs = NULL;
    POHCD_TRANSFER_DESCRIPTOR       tempTD = 0;
    BOOLEAN                         fItemsStillPending = FALSE;
    ULONG                           currentFrame;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_IsrDpc"));

    //
    //  The pause routine checks this to see if it
    //  is between an ISR and the DPC executing.
    //

    deviceExtension->IsrDpc_Context.InterruptsSignaled = 0;

    //
    //  Check for UnrecoverableError first, because there is no point.
    //  in doing anything else, if this has occured.
    //
    if (interruptsSignaled & HCINT_UnrecoverableError)
    {
        ASSERT(FALSE && "Wow, what do we do here?  Try reseting USB?  Reset the whole box?");
    }

    // 
    // Check for WritebackDoneHead, to see if we have TDs on the done list
    //
    if(interruptsSignaled & HCINT_WritebackDoneHead)
    {
        USB_DBG_TRACE_PRINT(("HCINT_WritebackDoneHead is set: processing . . ."));
        doneHead = deviceExtension->HCCA->DoneHead;
        doneHead &= 0xFFFFFFF0;    //LSb's can be used to indicate other interrupt conditions, get rid of them
        deviceExtension->HCCA->DoneHead = 0;

#ifdef SILVER
        //
        //  If the done head was lost, try to find it.
        //
        if(0==doneHead)
        {
            doneHead = OHCD_fPoolFindLostDoneHead(deviceExtension);
        }
#else 
        ASSERT(doneHead && "Xbox hardware should not have this bug");
#endif
        //
        //  The Done Queue can be treated as a LIFO.  Furthermore, they are linked only
        //  by physical address pointers.  So in one fell swoop we:
        //      1) dequeue them from the head
        //      2) reverse the links
        //      3) switch the physical addresses to virtual addresses.
        //
        while(doneHead)
        {
            //
            //  Get a virtual pointer to a TD
            //
            tempTD = OHCD_PoolTDFromPhysicalAddress(doneHead);
            ASSERT(tempTD);

            //
            //  Dequeue TD  from Host Controller Queue
            //
            doneHead = tempTD->HcTransferDescriptor.NextTD;

            //
            //  Queue TD at head our CompletedTDs list
            //
            tempTD->HcTransferDescriptor.NextTDVirtual = (POHCI_TRANSFER_DESCRIPTOR)completedTDs;
            completedTDs = tempTD;
        }
        //
        //  Now step through each TD in the order of completion
        //  and deal with it.
        //
        while(completedTDs)
        {
            //
            //  Dequeue a TD off the head
            //
            tempTD = completedTDs;
            completedTDs = (POHCD_TRANSFER_DESCRIPTOR)tempTD->HcTransferDescriptor.NextTDVirtual;
            //
            //  Process the TD
            //
            if(OHCD_IS_ISOCH_TD(tempTD))
            {
                OHCD_PROCESS_ISOCHRONOUS_TD(deviceExtension, tempTD);
            } else
            {
                OHCD_fProcessDoneTD(deviceExtension, tempTD);
            }
        }
        //
        //  Tell the Host Controller we are done
        //
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, HCINT_WritebackDoneHead);
        interruptsSignaled &= ~HCINT_WritebackDoneHead;
        //
        //  This shouldn't be necessary! However, in some cases we added to the schedule while interrupts were
        //  still disabled and the operation completed before this DPC routine finished.  The interrupt seems to
        //  be lost in these cases.  Hitting these flags after restoring the interrupt gets things going again.
        //  I would call this a hardware bug.  Not worth complaining about though, this fix is pretty straightforward.
        //
        WRITE_REGISTER_ULONG((PULONG)&deviceExtension->OperationalRegisters->HcCommandStatus, HCCS_ControlListFilled | HCCS_BulkListFilled);
    }

    // 
    // Check for StartOfFrame
    //
    if (interruptsSignaled & HCINT_StartOfFrame)
    {
        //
        //  Why did we ask for a SOF?  Probably to guarantee an interrupt so
        //  that we could deal with closing endpoints, or canceling requests
        //
        
        //
        //  We treat SOF interrupts as one time events, so shut them
        //  back off.
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, HCINT_StartOfFrame);
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptDisable, HCINT_StartOfFrame);
        interruptsSignaled &= ~HCINT_StartOfFrame;
    }

    //
    //  Handle pending cancels
    //
    currentFrame = OHCD_Get32BitFrameNumber(deviceExtension);
    if(OHCD_fProcessCancelPendingList(deviceExtension, currentFrame))
    {
        fItemsStillPending = TRUE;
    }

    //
    //  Handle pending aborts
    //
    //  IT IS IMPORTANT TO HANDLE PENDING ABORTS BEFORE PENDING
    //  CLOSES, SO THAT WE DO NOT CLOSE AN ENDPOINT WITH AN ABORT
    //  PENDING.
    //
    if(OHCD_fProcessAbortPendingList(deviceExtension, currentFrame))
    {
        fItemsStillPending = TRUE;
    }

    //
    //  Handle pending closes
    //
    if(OHCD_fProcessClosePendingList(deviceExtension, currentFrame))
    {
        fItemsStillPending = TRUE;
    }

    //
    //  If there anything (cancels, aborts, or closes)
    //  are still pending, then set an interrupt at
    //  the next start of frame.
    //
    if(fItemsStillPending)
    {
        USB_DBG_TRACE_PRINT(("Items still pending setting an SOF interrupt."));
        WRITE_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcInterruptStatus, HCINT_StartOfFrame);
        WRITE_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcInterruptEnable, HCINT_StartOfFrame);
    }

    // 
    // Process Root Hub changes 
    //
    if(interruptsSignaled & HCINT_RootHubStatusChange)
    {

        USB_DBG_TRACE_PRINT(("Root hub interrupt signaled"));
        OHCD_RootHubProcessInterrupt(deviceExtension);
        
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, HCINT_RootHubStatusChange);                                  
        interruptsSignaled &= ~HCINT_RootHubStatusChange;
    }
    
    //
    //  If some interrupt occured and we haven't
    //  handled it, we obviously don't care about it, so disable
    //  it.
    if(interruptsSignaled)
    {
        ASSERT(FALSE && "Not expecting interrupts that we don't handle.");
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, interruptsSignaled);
        interruptsSignaled = 0;
    }

    //
    //  Turn interrupts back on.
    //
    WRITE_REGISTER_ULONG(&hcRegs->HcInterruptEnable, HCINT_MasterInterruptEnable);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_IsrDpc"));
}

ULONG
FASTCALL
OHCD_Get32BitFrameNumber(
    POHCD_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG hp, fn, n;
    /* This code accounts for the fact that HccaFrameNumber is updated by the
     * HC before the HCD gets an interrupt that will adjust FrameHighPart. No
     * synchronization is necessary due to great cleaverness. */
    hp = DeviceExtension->FrameHighPart;
    fn = DeviceExtension->HCCA->FrameNumber;
    n = ((fn & 0x7FFF) | hp) + ((fn ^ hp) & 0x8000);
    return n;
}

//----------------------------------------------------------------------------
// Implementation of functions used only locally:
//      OHCD_ProcessDoneTD
//      OHCD_ProcessFailedTD
//      OHCD_ProcessCancelPendingList
//----------------------------------------------------------------------------

VOID
FASTCALL
OHCD_fProcessDoneTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    )
/*++

Routine Description:

    Called from the IsrDpc to cleanup each TD that was
    in the done queue.  There are a large number of cases.

Arguments:

    DeviceExtension - pointer to device extension for our HC.
    TD              - Transfer Descriptor that completed.
    

Return Value:
    
    None

--*/               
{
    PURB                        urb = TD->Urb;
    POHCD_ENDPOINT              endpoint = TD->Endpoint;
    POHCD_TRANSFER_DESCRIPTOR   setupBlock;
    BOOLEAN                     isLastTD;
    USB_DBG_ENTRY_PRINT(("Entering OHCD_ProcessDoneTD"));
    
    //
    //  Success or failure, if this is a setup TD, we need to free the
    //  setupBlock.
    //
    if(OHCD_TD_TYPE_SETUP == TD->Type)
    {
        USB_DBG_TRACE_PRINT(("TD is a setup TD, so free the descriptor used for the data payload."));
        //
        //  Clean up the setup packet which we stored in a descriptor block.
        //  Get the virtual address of the setup packet (BufferEnd points
        //  to the physical address of the last byte of the 8 byte setup
        //  packet).  
        //
        setupBlock = OHCD_PoolTDFromPhysicalAddress(TD->HcTransferDescriptor.BufferEnd - 7);
        //
        //  With Virtual address in hand we can free it.
        //
        OHCD_PoolFreeTD(setupBlock);
        OHCD_PoolCreditControlTDQuota(1);
    }

    //
    //  If this TD completed with an error, than
    //  let OHCD_ProcessFailedTD take over.
    //
    if(OHCI_CC_NO_ERROR != TD->HcTransferDescriptor.ConditionCode)
    {
        USB_DBG_TRACE_PRINT(("TD @0x%0.8x had an error. CC = %x", TD, TD->HcTransferDescriptor.ConditionCode));   
        ASSERT(TD->Type != OHCD_TD_TYPE_DUMMY);
        
        OHCD_fProcessFailedTD(DeviceExtension, TD);
        return;
    }

    //
    //  Calculate bytes transfered.
    //
    if(TD->HcTransferDescriptor.CurrentBufferPointer)
    {
        //
        //  We do everything signed to account for page wrap
        //
        LONG currentBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.CurrentBufferPointer);
        LONG endBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.BufferEnd);
        LONG bytesTransfered;
        if(endBufferPointerOffset >= currentBufferPointerOffset)
        {
            bytesTransfered = TD->Bytes - (endBufferPointerOffset - currentBufferPointerOffset);
        } else
        {
            bytesTransfered = TD->Bytes - (PAGE_SIZE - (currentBufferPointerOffset - endBufferPointerOffset));
        }
        bytesTransfered--;
        ASSERT(bytesTransfered >= 0);
        urb->CommonTransfer.TransferBufferLength += bytesTransfered;
    } else
    {
        urb->CommonTransfer.TransferBufferLength += TD->Bytes;
    }
    //
    //  Record whether this was the last TD in an URB
    //
    isLastTD = TD->Flags & OHCD_TD_FLAG_LAST_TD;

    //
    //  Free the TD
    //
    OHCD_PoolFreeTD(TD);

    //
    //  Credit the proper quota
    //
    OHCD_fCreditTDQuota(DeviceExtension, endpoint);
    
    //
    //  If that TD completed the URB then we need to process
    //  the URB
    //
    if(isLastTD)
    {
        USB_DBG_TRACE_PRINT(("TD was last in an URB."));

        urb->Header.Status = USBD_STATUS_SUCCESS;
        OHCD_fCompleteRequest(DeviceExtension, endpoint, urb);
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProcessDoneTD"));
    //
    //  Nothing else to do
    //
    return;
}


VOID
FASTCALL
OHCD_fProcessFailedTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    )
/*++

Routine Description:

    Called from the OHCD_ProcessDoneTD (in the context of IsrDPC),
    because the condition code indicated an error.  Not called if
    TD is for an isochronous endpoint.

    Our job is to deal with that condition.  Firstly, the
    associated endpoint has definately been halted, so we
    can party on the endpoint. In most cases we do
    the following:
        1) Copy the error condition into the URB's status field.
        2) Clean up all the TD's associated with that URB.
        5) Complete the URB.

    There is one exceptions for DataUnderrun when ShortXferOK. There
    is a slight difference in the way control endpoints are handled.
    For Bulk and  Interrupt endpoints we proceed as follows:
        1) Clean up all the remaining TD's associated with the URB.
        2) Complete the URB successfully.
    
    For control endpoints we do the following:
        1) Clean up all the remaining TD's associated with the URB, except
        the status TD.

    When we are done the endpoint should be ready to go again.  The
    caller must clear the halted bit though.
        
Arguments:

    DeviceExtension - pointer to device extension for our HC.
    TD              - Transfer Descriptor that completed.

Return Value:
    
    None

--*/               
{
    PURB                        urb = TD->Urb;
    POHCD_ENDPOINT              endpoint = TD->Endpoint;
    BOOLEAN                     errorCondition = TRUE;
    BOOLEAN                     isLastTD;
    ULONG                       tempTDPhysical;
    POHCD_TRANSFER_DESCRIPTOR   tempTD;
    
    ASSERT(OHCI_CC_NO_ERROR != TD->HcTransferDescriptor.ConditionCode);

    //
    //  DataUnderrun when USBD_SHORT_TRANSFER_OK, is not an error
    //  mark it as success, and record the bytes that were transfered
    //
    if(
        (OHCI_CC_DATA_UNDERRUN == TD->HcTransferDescriptor.ConditionCode) &&
        (urb->CommonTransfer.ShortTransferOK)
    )
    {
       if(TD->HcTransferDescriptor.CurrentBufferPointer)
       {
            //
            //  We do everything signed to account for page wrap
            //
            LONG currentBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.CurrentBufferPointer);
            LONG endBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.BufferEnd);
            LONG bytesTransfered;
            if(endBufferPointerOffset >= currentBufferPointerOffset)
            {
                bytesTransfered = TD->Bytes - (endBufferPointerOffset - currentBufferPointerOffset);
            } else
            {
                bytesTransfered = TD->Bytes - (PAGE_SIZE - (currentBufferPointerOffset - endBufferPointerOffset));
            }
            bytesTransfered--;
            ASSERT(bytesTransfered >= 0);
            urb->CommonTransfer.TransferBufferLength += bytesTransfered;
        } else
        {
            urb->CommonTransfer.TransferBufferLength += TD->Bytes;
        }

        USB_DBG_TRACE_PRINT(("OHCI_CC_DATA_UNDERRUN with ShortTransferOK"));
        urb->Header.Status = USBD_STATUS_SUCCESS;
        errorCondition = FALSE;
    }
    else
    //
    //  It really is an error, convert the condition code to a USBD_STATUS_XXXX code.
    //
    {
        if(OHCI_CC_NOT_ACCESSED2 == TD->HcTransferDescriptor.ConditionCode)
        {
            //
            //  TDs are initialized with OHCD_CC_DATA_NOT_ACCESSED.  If the condition
            //  code is OHCD_CC_DATA_NOT_ACCESSED2, it is because the OHCD_ProcessCancelPendingList
            //  called OHCD_ProcessDoneTD to finish off its dirty work.
            //
            urb->Header.Status = USBD_STATUS_CANCELED;
        }
        urb->Header.Status = OHCI_CC_TO_USBD_STATUS(TD->HcTransferDescriptor.ConditionCode);
        
    }
    
    tempTD = TD;
    //
    //  tempTDPhysical will be kept one TD ahead of tempTD
    //  on the queue.  This is because, we need to get the
    //  first one from the endpoints programmed queue (it hasn't
    //  failed yet, so it was not in the done queue).  Subsequent
    //  tempTDPhysical values are obtained in the loop, by walking the
    //  queue.
    //
    tempTDPhysical = READ_HEADP(&endpoint->HcEndpointDescriptor);
    //
    //  Loop until all the TDs of the failed URB are freed.
    //
    USB_DBG_TRACE_PRINT(("Freeing TDs from failed Transfer:"));
    do
    {
        //
        //  Before freeing the TD, record whether or
        //  not it is the last one in the URB.
        //
        isLastTD = tempTD->Flags & OHCD_TD_FLAG_LAST_TD;

        //
        //  Free the TD
        //
        USB_DBG_TRACE_PRINT(("0x%0.8x", tempTD));
        OHCD_PoolFreeTD(tempTD);

        //
        //  Credit the proper quota
        //
        OHCD_fCreditTDQuota(DeviceExtension, endpoint);

        //
        //  update tempTD for the next iteration.
        //
        tempTD = OHCD_PoolTDFromPhysicalAddress(tempTDPhysical);
        tempTDPhysical = tempTD->HcTransferDescriptor.NextTD;
        
        //
        //  If tempTD is a OHCD_TD_TYPE_STATUS and we
        //  did not really fail, than we should break out
        //  before freeing it.
        //
        if( (OHCD_TD_TYPE_STATUS == tempTD->Type) && !errorCondition)
        {
            USB_DBG_TRACE_PRINT(("Leaving Status TD (0x%0.8x) on ED", tempTD));
            break;
        }
    } while(!isLastTD);
        
    //
    //  Update the Queue to reflect that we freed all of them TDs
    //  (remember that tempTDPhysical was one TD ahead of the last
    //  one we didn't free)
    tempTDPhysical = tempTD->PhysicalAddress;
    WRITE_HEADP(&endpoint->HcEndpointDescriptor, tempTDPhysical);
    
    //
    // If we cleaned up a whole URB (i.e. it was not
    // a short control transfer) then complete the Urb.
    //
    if(isLastTD)
    {
        OHCD_fCompleteRequest(DeviceExtension, endpoint, urb);
    }

    //
    //  For control endpoints and short transfers, automatically clear the
    //  halted condition.
    //
    if(USB_ENDPOINT_TYPE_CONTROL == endpoint->EndpointType || !errorCondition)
    {
        CLEAR_HALTED(&endpoint->HcEndpointDescriptor);
    }
}


VOID
FASTCALL
OHCD_fCompleteRequest(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    )
/*++
  Routine Description:
    Helper method for OHCD_fProcessDoneTD and OHCD_fProcessFailedTD.
    It just pulls some duplicate code out, and puts it in one place.

   Actions Performed:
    
    1) Clean up Urb out of endpoint.
    2) If the Urb is pending cancel, do maintenance
       on the pending cancel list and endpoint.
    3) Mark Urb Completed.
    4) Complete URb.

    It does not set the Urb status, the caller does that.
--*/
{
    Endpoint->ProgrammedUrbCount--;
    
    //
    //  Unlock buffer pages if needed
    //
    if(Urb->CommonTransfer.TransferBuffer)
    {
        MmLockUnlockBufferPages(Urb->CommonTransfer.TransferBuffer, Urb->CommonTransfer.Hca.HcdOriginalLength, TRUE);
        #ifdef DVTSNOOPBUG
        OHCD_PoolEndDoubleBufferTransfer(Urb);
        #endif
    }

    //
    //  If OHCD_URB_FLAG_CANCELED is set, it may mean
    //  that the URB is sitting in our device extension's
    //  pending cancel list.  If so we have some work to do.
    //
    if(OHCD_URB_FLAG_CANCELED&Urb->CommonTransfer.Hca.HcdUrbFlags)
    {
        //
        //  Search the pending cancel list for the Urb.
        //
        PURB urbPrev=NULL;
        PURB urbCur=DeviceExtension->PendingCancels;
        while(urbCur && Urb!=urbCur)
        {
            urbPrev = urbCur;
            urbCur = urbPrev->CommonTransfer.Hca.HcdUrbLink;
        }

        //
        // If we find it, better clean up.
        //
        if(urbCur)
        {
            ASSERT(urbCur==Urb);

            //
            //  Splice the Urb out of the pending cancel list.
            //
            if(!urbPrev)
            {
                DeviceExtension->PendingCancels = urbCur->CommonTransfer.Hca.HcdUrbLink;
            } else
            {
                urbPrev->CommonTransfer.Hca.HcdUrbLink = urbCur->CommonTransfer.Hca.HcdUrbLink;
            }
            urbCur->CommonTransfer.Hca.HcdUrbLink = NULL;
    
            //
            //  Handle the endpoint pause associated with the Urb pending cancel.
            //
            if( 0 == --Endpoint->PendingPauseCount)
            {   
                Endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_PAUSING;
                Endpoint->HcEndpointDescriptor.Control.Skip = 0;
            }

        } else
        //
        //  There is only one legitimate reason that the Urb would
        //  not be in the pending cancel list.  That is if 
        //  OHCD_fProcessCancelPendingList is in our call stack.  If that
        //  is the case Urb->Header.Status  will already be set to
        //  USBD_STATUS_CANCELED.
        //
        {
            ASSERT(USBD_STATUS_CANCELED == Urb->Header.Status);
        }
    }
    
    //
    //  Complete the request.
    //

    Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_COMPLETED;
    USBD_CompleteRequest(Urb);
}

VOID
FASTCALL
OHCD_fCreditTDQuota(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint
    )
/*++
    Routine Description:
        Called whenever a TD is retired.  It credits the proper
        quota (control, bulk or interrupt), and jogs the appropriate
        queue that may be waiting to fit under the quota.

   DeviceExtension - pointer to device extension for our HC.
   Endpoint - endpoint the TD was associated with.

--*/
{
    switch(Endpoint->EndpointType)
    {
        case USB_ENDPOINT_TYPE_CONTROL:
            OHCD_PoolCreditControlTDQuota(1);
            OHCD_fProgramControlTransfer(DeviceExtension);
            break;
        case USB_ENDPOINT_TYPE_BULK:
            OHCD_PoolCreditBulkTDQuota(1);
            OHCD_fProgramBulkTransfer(DeviceExtension);
            break;
        case USB_ENDPOINT_TYPE_INTERRUPT:
            Endpoint->TDInUseCount--;
            OHCD_fProgramInterruptTransfer(DeviceExtension, Endpoint);
            break;
		default:
            //ISOCH endpoint never expected here.
            USB_DBG_ERROR_PRINT(("Unrecognized endpoint type in OHCD_ProcessDoneTD"));
            //This is a serious error, please dump the stack, bug it, and reboot.
    }
}

BOOLEAN
FASTCALL
OHCD_fProcessCancelPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    )
/*++

Routine Description:

    Called from the IsrDpc to cleanup any pending cancels.
    The DPC has to do it, because the endpoint must be paused.

Arguments:

    DeviceExtension - pointer to device extension for our HC.

    Return Value:
    
    None

--*/               
{
    PURB            stillPending = NULL;
    PURB            urb;
    POHCD_ENDPOINT  endpoint;

    ASSERT_DISPATCH_LEVEL();
    //
    //  Pop the first URB in each request pending cancel off
    //  the Pending Cancel queue and deal with it.  Note that
    //  we have an inner loop to deal with URBs of the same request.
    //
    while(DeviceExtension->PendingCancels)
    {
        //
        //  pop an urb off the pending cancels queue
        //
        urb = DeviceExtension->PendingCancels;
        DeviceExtension->PendingCancels = urb->CommonTransfer.Hca.HcdUrbLink;

        //
        //  Get the endpoint for the urb
        //
        endpoint = (POHCD_ENDPOINT)urb->CommonTransfer.EndpointHandle;
        
        //
        //  If the endpoint is not paused yet, hold the urb aside on
        //  the stillPending list.
        //
        if(CurrentFrame < endpoint->PauseFrame)
        {
            urb->CommonTransfer.Hca.HcdUrbLink = stillPending;
            stillPending = urb;
        } else if(endpoint->Flags&OHCD_ENDPOINT_FLAG_DELAY_PAUSE)
        {
            // Change the pause frame so that OHCD_fProcessAbortPendingList
            // and OHCD_fProcessClosePendingList won't process anything for
            // this endpoint until the next interrupt.
            endpoint->PauseFrame = CurrentFrame+1; 
            // Clear the delay pause flag.
            endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
            // Put the Urb on the still pending list
            urb->CommonTransfer.Hca.HcdUrbLink = stillPending;
            stillPending = urb;
        } else   
        {
            //
            //  The endpoint is paused,  we need to cleanup all the TDs associated with
            //  the Urb and complete it.  We can leverage the OHCD_ProcessDoneTD routine,
            //  here's how:
            //
            //  1) Find our URB on the endpoints queue.
            //  2) Save physical pointers to the original first TD, and the
            //     last TD prior to the first TD of our URB.
            //  3) Set the head of the queue to point the second TD of our URB.
            //  4) Set the condition code of the first TD is set to
            //     OHCI_CC_NOT_ACCESSED2.
            //  5) Call OHCD_ProcessDoneTD.
            //  6) Restore the portion of the queue prior to our URB
            //
            
            ULONG                       firstTDPhysical;
            ULONG                       priorTDPhysical;
            ULONG                       currentTDPhysical;
            POHCD_TRANSFER_DESCRIPTOR   currentTD;

            //
            //  ASSERT that the Urb is not yet completed.
            //
            ASSERT(!(urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_COMPLETED));

            //
            //  Loop until we find the first TD of our URB, or until we found the end
            //  of the queue.
            //  Steps 1) and 2)
            //
            priorTDPhysical = 0;
            firstTDPhysical =
            currentTDPhysical = READ_HEADP(&endpoint->HcEndpointDescriptor);
            currentTD = OHCD_PoolTDFromPhysicalAddress(currentTDPhysical);
            while(
                (urb != currentTD->Urb) &&
                (currentTDPhysical != endpoint->HcEndpointDescriptor.TailP)
            )
            {
                priorTDPhysical = currentTDPhysical;
                currentTDPhysical = currentTD->HcTransferDescriptor.NextTD;
                currentTD = OHCD_PoolTDFromPhysicalAddress(currentTDPhysical);
            }
            //
            //  ASSERT that we found the Urb.  Basically, we should
            //  always find it.  If we didn't, it got lost, and that
            //  would be very bad.
            //
            ASSERT(urb == currentTD->Urb);
            
            //
            //  3) Adjusting queue for OHCD_ProcessDoneTD
            //
            WRITE_HEADP(&endpoint->HcEndpointDescriptor, currentTD->HcTransferDescriptor.NextTD);
            //
            //  4) Verify that the condition code of the first TD is set to
            //     OHCI_CC_NOT_ACCESSED2.
            currentTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED2;
            //
            //  5) Call OHCD_ProcessDoneTD.
            //
            OHCD_fProcessDoneTD(DeviceExtension, currentTD);
            //
            //  6) Restore endpoint's queue
            //
            if(0 != priorTDPhysical)
            {
                currentTD = OHCD_PoolTDFromPhysicalAddress(priorTDPhysical);
                currentTD->HcTransferDescriptor.NextTD = READ_HEADP(&endpoint->HcEndpointDescriptor);
                WRITE_HEADP(&endpoint->HcEndpointDescriptor, firstTDPhysical);
            }
            //
            //  Decrement pending pause count, and restart the endpoint
            //  if it is time.
            //
            if( 0 == --endpoint->PendingPauseCount)
            {   
                endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_PAUSING;
                endpoint->HcEndpointDescriptor.Control.Skip = 0;
            }
        }
    }//Loop over all URBs pending cancel
        
    //
    //  Put all the cancels we passed over back on the
    //  pending list.
    //
    DeviceExtension->PendingCancels = stillPending;
    return stillPending ? TRUE : FALSE;
}

BOOLEAN
FASTCALL
OHCD_fProcessAbortPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    )
/*++

Routine Description:

    Called from the IsrDpc to cleanup any pending aborts.
    The DPC has to do it, because the endpoint must be paused.

Arguments:

    DeviceExtension - pointer to device extension for our HC.

    Return Value:
    
    None

--*/               
{
    PURB            stillPending = NULL;
    PURB            urb;
    POHCD_ENDPOINT  endpoint;

    ASSERT_DISPATCH_LEVEL();
    //
    //  Pop the first URB in each request pending cancel off
    //  the Pending Cancel queue and deal with it.  Note that
    //  we have an inner loop to deal with URBs of the same request.
    //
    while(DeviceExtension->PendingAborts)
    {
        //
        //  pop an urb off the pending aborts queue
        //
        urb = DeviceExtension->PendingAborts;
        DeviceExtension->PendingAborts = urb->CommonTransfer.Hca.HcdUrbLink;

        //
        //  Get the endpoint for the urb
        //
        endpoint = (POHCD_ENDPOINT)urb->CommonTransfer.EndpointHandle;
        
        //
        //  If the endpoint is not paused yet, hold the urb aside on
        //  the stillPending list.
        if(CurrentFrame < endpoint->PauseFrame)
        {
            urb->AbortEndpoint.HcdNextAbort = stillPending;
            stillPending = urb;
        } else if(endpoint->Flags&OHCD_ENDPOINT_FLAG_DELAY_PAUSE)
        {
            // Change the pause frame so that OHCD_fProcessClosePendingList won't
            // process anything for this endpoint until the next interrupt.
            endpoint->PauseFrame = CurrentFrame+1; 
            // Clear the delay pause flag.
            endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
            // Put the Urb on the still pending list
            urb->AbortEndpoint.HcdNextAbort = stillPending;
            stillPending = urb;
        } else
        //
        //  The endpoint is paused.
        //
        {
            OHCD_fCleanEndpointTDs(DeviceExtension, endpoint);
            //
            //  Decrement PendingPauseCount, and restart endpoint if necessary.
            //
            if(0 == --endpoint->PendingPauseCount)
            {   
                endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_PAUSING;
                endpoint->HcEndpointDescriptor.Control.Skip = 0;
            }
            //
            //  Complete the Abort URB
            //
            urb->Header.Status = USBD_STATUS_SUCCESS;
            USBD_CompleteRequest(urb);
        }
    }//Loop over all URBs pending cancel
        
    //
    //  Put all the cancels we passed over back on the
    //  pending list.
    //
    DeviceExtension->PendingAborts = stillPending;
    return stillPending ? TRUE : FALSE;
}

BOOLEAN
FASTCALL    
OHCD_fProcessClosePendingList(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                     CurrentFrame
    )
{
    PURB_CLOSE_ENDPOINT urb;
    PURB_CLOSE_ENDPOINT notClosedYet = NULL;
    POHCD_ENDPOINT      endpoint;
    
    while(DeviceExtension->PendingCloses)
    {
        //
        // Remove an endpoint from the queue.
        //
        urb = &DeviceExtension->PendingCloses->CloseEndpoint;
        DeviceExtension->PendingCloses = urb->HcdNextClose;
        
        //
        //  Retrieve the endpoint from the URB
        //
        endpoint = (POHCD_ENDPOINT)urb->EndpointHandle;

        //
        //  If the endpoint is not paused yet, hold the endpoint aside on
        //  the notClosedYet list.
        //
        if(CurrentFrame < endpoint->PauseFrame)
        {
            urb->HcdNextClose = (PURB)notClosedYet;
            notClosedYet = urb;
        } else if(endpoint->Flags&OHCD_ENDPOINT_FLAG_DELAY_PAUSE)
        {
            // Clear the delay pause flag.
            endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
            // Put the Urb on the still pending list
            urb->HcdNextClose = (PURB)notClosedYet;
            notClosedYet = urb;
        }
        //
        //  Otherwise, cleanup the endpoint and complete the URB
        //
        else
        {
            if(OHCD_IS_ISOCH_CLOSE(urb))
            {
                OHCD_ISOCH_COMPLETE_CLOSE_ENDPOINT(DeviceExtension, urb);
            } else
            {
                //
                //  Cleanup any straggling TDS, canceling any pending transfers
                //  in the process.
                //
                OHCD_fCleanEndpointTDs(DeviceExtension, endpoint);

                //
                //  Serious programming error if we haven't cleaned everything.
                //
                ASSERT(0==endpoint->QueuedUrbCount);
                ASSERT(0==endpoint->ProgrammedUrbCount);
                ASSERT(0==--endpoint->PendingPauseCount);
                //
                //  Update the data toggle bits in the close URB
                //
                if(urb->DataToggleBits)
                {
                    ULONG dataToggleMask = 1 << endpoint->HcEndpointDescriptor.Control.EndpointAddress;
                    if(endpoint->HcEndpointDescriptor.Control.Direction == 2)
                    {
                        dataToggleMask <<= 16;
                    }
                    if(GET_TOGGLECARRY(&endpoint->HcEndpointDescriptor))
                    {
                        *urb->DataToggleBits |= dataToggleMask;
                    } else
                    {
                        *urb->DataToggleBits &= ~dataToggleMask;
                    }
                }
                OHCD_PoolFreeEndpoint(endpoint);
                urb->Hdr.Status = USBD_STATUS_SUCCESS;
                USBD_CompleteRequest((PURB)urb);
            }
        }
    }
    //
    //  Place the endpoints that weren't closed yet, back on
    //  the PendingCloses list.  So what if we reversed the order.
    //
    DeviceExtension->PendingCloses = (PURB)notClosedYet;
    return notClosedYet ? TRUE : FALSE;
}

VOID
FASTCALL
OHCD_fCleanEndpointTDs(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint
    )
{
    ULONG                       TDPhysical;
    POHCD_TRANSFER_DESCRIPTOR   TD = NULL;
    BOOLEAN                     done = FALSE;
    
    //
    //  1) Pull the TDs off one at a time.
    //  2) Make sure that the ConditionCode is OHCI_CC_NOT_ACCESSED2.
    //  3) Call OHCD_ProcessDoneTD, which will call OHCD_ProcessFailedTD,
    //     which will:
    //          a) Clean all the TDs associated with the same URB.
    //          b) Complete the URB as USBD_STATUS_CANCELED
    //  4) Clean up the dummy TD when we get to it.     
    //  
    while(!done)
    {
        TDPhysical = READ_HEADP(&Endpoint->HcEndpointDescriptor);
        if(0 == TDPhysical) break;
        TD = OHCD_PoolTDFromPhysicalAddress(TDPhysical);
        if(TDPhysical != Endpoint->HcEndpointDescriptor.TailP)
        {
            ASSERT(OHCD_TD_TYPE_DUMMY != TD->Type);
            TD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED2;
            WRITE_HEADP(&Endpoint->HcEndpointDescriptor, TD->HcTransferDescriptor.NextTD);
            OHCD_fProcessDoneTD(DeviceExtension, TD);
        }else
        {
            ASSERT(OHCD_TD_TYPE_DUMMY == TD->Type);
            WRITE_HEADP(&Endpoint->HcEndpointDescriptor, 0);
            Endpoint->HcEndpointDescriptor.TailP = 0;
            OHCD_PoolFreeTD(TD);
            done = TRUE;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\isoch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    isoch.h

Abstract:

    This file contains Macros and Declaration need
    for Isochronous support.  Since USBD can be compiled
    with or without isoch support there are two
    versions of every macro.

Environment:

    Designed for XBOX.

Notes:

Revision History:

    06-29-00 created by Mitchell Dernis (mitchd)

--*/
#ifndef __ISOCH_H__
#define __ISOCH_H__


#ifdef  OHCD_ISOCHRONOUS_SUPPORTED

//
//  Forward declaration of pointer types.
//
typedef struct _OHCD_ISOCH_ENDPOINT             *POHCD_ISOCH_ENDPOINT;
typedef struct _OHCD_ISOCH_TRANSFER_DESCRIPTOR  *POHCD_ISOCH_TRANSFER_DESCRIPTOR;
typedef struct _OHCD_ISOCH_TRANSFER_DESCRIPTOR
{
    OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR  IsochTransferDescriptor;
    POHCD_ISOCH_ENDPOINT                  Endpoint;
    PFNUSBD_ISOCH_TRANSFER_COMPLETE       TransferComplete;
    PVOID                                 Context;
    UCHAR                                 TdIndex;
    UCHAR                                 TdIndexPrev;
    USHORT                                Pad;
    USHORT                                Offsets[8];
} OHCD_ISOCH_TRANSFER_DESCRIPTOR;

typedef struct _OHCD_ISOCH_ENDPOINT
{
    //
    //  OHCI mandated portion of endpoint.  This structure
    //  must start on a paragraph(16-byte) boundary.
    //
    OHCI_ENDPOINT_DESCRIPTOR    HcEndpointDescriptor;
    //
    //  Fields for managing the schedule (especially for interrupt)
    //
    UCHAR                       Flags;                  //Endpoint flags
    UCHAR                       EndpointType;           //Type of endpoint
    UCHAR                       ScheduleIndex;          //Index in schedule - see definitions above
    UCHAR                       PollingInterval;        //Maximum polling interval (in ms)
    
    ULONG                       PhysicalAddress;        //Physical address of this structure.
    POHCD_ENDPOINT              Next;                   //Next endpoint in schedule

    ULONG                       PauseFrame;             //Used to verify that we have waited at least

    UCHAR                       PendingPauseCount;      //Number of reasons that we are paused.
    UCHAR                       Padding;                //Padding to keep up DWORD alignement.
    USHORT                      Bandwidth;              //Bandwidth required by this endpoint (interrupt and isoch only)
    
    //
    //  Above here must be identical to OHCD_ENDPOINT so that the schedule routines work,
    //  and part of the close routines.
    //
    UCHAR                       MaxAttachedBuffers;
    UCHAR                       AttachedBuffers;

    UCHAR                       NextFreeTD;
    UCHAR                       Alignment;

    ULONG                           NextUnusedFrame;
    POHCD_ISOCH_TRANSFER_DESCRIPTOR TransferDescriptors;
} OHCD_ISOCH_ENDPOINT;

#define OHCD_ISOCH_EDFL_CIRCULAR_DMA 0x01
#define OHCD_ISOCH_EDFL_TRANSFERING  0x02
#define OHCD_ISOCH_EDFL_STOPPING     0x04
#define OHCD_ISOCH_EDFL_PAUSING      OHCD_ENDPOINT_FLAG_PAUSING

//
//  Isochronous function definitions
//
USBD_STATUS
FASTCALL
OHCD_fIsochOpenEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochCloseEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochAttachBuffer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochStartTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochStopTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

VOID
FASTCALL
OHCD_fIsochProcessTD(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_TRANSFER_DESCRIPTOR TransferDescriptor
    );

VOID
FASTCALL
OHCD_fIsochCompleteCloseEndpoint
    (
    IN POHCD_DEVICE_EXTENSION       DeviceExtension,
    IN PURB_ISOCH_CLOSE_ENDPOINT    Urb
    );

//
//  Macros used outside of isoch.c that require stub definitions.
//
#define OHCD_ISOCH_OPEN_ENDPOINT(DeviceExtension, Urb)\
           OHCD_fIsochOpenEndpoint(DeviceExtension, Urb)

#define OHCD_ISOCH_CLOSE_ENDPOINT(DeviceExtension, Urb)\
           OHCD_fIsochCloseEndpoint(DeviceExtension, Urb)

#define OHCD_ISOCH_ATTACH_BUFFERS(DeviceExtension, Urb)\
           OHCD_fIsochAttachBuffer(DeviceExtension, Urb)

#define OHCD_ISOCH_START_TRANSFER(DeviceExtension, Urb)\
           OHCD_fIsochStartTransfer(DeviceExtension, Urb)

#define OHCD_ISOCH_STOP_TRANSFER(DeviceExtension, Urb)\
           OHCD_fIsochStopTransfer(DeviceExtension, Urb)

//
//  The format bit should be clear for non-isoch transfers.
//  In non-isoch builds it doesn't really matter.  However,
//  the non-isoch checked build does some testing to make sure
//  that it is always cleared when it should be.
//
#define OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(TD)\
          TD->HcTransferDescriptor.Format = 0;
#define OHCD_IS_ISOCH_TD(TD)\
           (TD->HcTransferDescriptor.Format)
#define OHCD_PROCESS_ISOCHRONOUS_TD(DeviceExtension, TD)\
           OHCD_fIsochProcessTD(DeviceExtension, TD)
#define OHCD_IS_ISOCH_CLOSE(urb)\
           (URB_FUNCTION_ISOCH_CLOSE_ENDPOINT == urb->Hdr.Function)
#define OHCD_ISOCH_COMPLETE_CLOSE_ENDPOINT(DeviceExtension, Urb)\
            OHCD_fIsochCompleteCloseEndpoint(DeviceExtension, Urb)
#define HC_CONTROL_ISOCH_ENABLE_STATE   0x00000008

#define OHCD_ISOCH_ENDPOINT_SIZE(MaxAttachedBuffers)\
    (sizeof(OHCD_ISOCH_ENDPOINT) +\
     MaxAttachedBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR))
#define OHCD_ISOCH_POOL ULONG_PTR IsochFreeEndpoints; ULONG IsochMaxBuffers;

#else

/*
**  DEFINITIONS WHEN COMPILED WITHOUT ISOCHRONOUS
**  AND CHECKED OR FREE DOESN'T MATTER
*/
#define HC_CONTROL_ISOCH_ENABLE_STATE   0
#define OHCD_IS_ISOCH_CLOSE(urb) (FALSE)
#define OHCD_ISOCH_COMPLETE_CLOSE_ENDPOINT(DeviceExtension, Urb)
#define OHCD_ISOCH_ENDPOINT_SIZE(MaxAttachedBuffers) 0
#define OHCD_ISOCH_FREE_ENDPOINTS

#if DBG
/*
**  DEFINITIONS WHEN COMPILED WITHOUT
**  ISOCHRONOUS SUPPORT AND CHECKED BUILD
**  In the checked build, some macros spew debug information
**  and/or break into the debugger if they are hit.
*/  

//
//  Stub for Isochronous Support Error.
//
__inline USBD_STATUS OHCD_ErrorNoIsochSupport()
{
    DbgPrint("ERROR: THIS VERSION OF USBD.SYS WAS BUILT WITHOUT SUPPORT FOR USING ISOCHRONOUS DEVICES.\n");
    DbgPrint("ERROR: THIS ERROR SHOULD NOT BE HIT MERELY BECAUSE AN ISOCHRONOUS DEVICE IS PLUGGED IN,\n");
    DbgPrint("ERROR: BUT ONLY IF A CLASS DRIVER FOR THE DEVICE IS PRESENT AND IF AN OPEN ON THE DEVICE\n");
    DbgPrint("ERROR: IS ATTEMPTED.\n");
    DbgBreakPoint();
    return USBD_STATUS_ISOCH_NOT_SUPPORTED;
}

//
//  Macros definitons
//  

#define OHCD_ISOCH_OPEN_ENDPOINT(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_CLOSE_ENDPOINT(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_ATTACH_BUFFERS(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_START_TRANSFER(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_STOP_TRANSFER(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

//
//  Even though isochronous support is off, we keep track of the Format bit like in
//  an isoch build.  If OHCD_PROCESS_ISOCHRONOUS_TD is ever hit as a result,
//  it errors out and then calls OHCD_ProcessDoneTD, like it should anyway.
//  This should help find problems with how the format bit is being used, and may
//  reveal problems that would be hard to find or solve in the builds with isoch support.
//
#define OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(TD) TD->HcTransferDescriptor.Format = 0;
#define OHCD_IS_ISOCH_TD(TD) (TD->HcTransferDescriptor.Format)
#define OHCD_PROCESS_ISOCHRONOUS_TD(deviceExtension, tempTD)\
{\
    DbgPrint("ERROR: Found TD with Format bit set in a build that does not support Isochronous transfers.\n");\
    DbgPrint("ERROR: This indicates that the format bit is not being cleared properly for non-isoch transfers.\n");\
    DbgPrint("ERROR: Hitting this suggests that builds which do support isochronous transfers may have undetected errors.\n");\
    DbgPrint("ERROR: If you hit 'g' in the debugger, it will handle this properly as a non-isoch TD.\n");\
    DbgBreakPoint();\
    OHCD_fProcessDoneTD(deviceExtension, tempTD);\
}

/*
**  DEFINITIONS WHEN COMPILED WITHOUT
**  ISOCHRONOUS SUPPORT AND FREE BUILD
**
**  In the free build, we do not spew debug information.  Macros that shouldn't
**  be hit simply return an ERROR.
*/
#else //DBG!=1

#define OHCD_ISOCH_OPEN_ENDPOINT(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_CLOSE_ENDPOINT(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_ATTACH_BUFFERS(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_START_TRANSFER(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_STOP_TRANSFER(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED


#define OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(TD) //NOP, not necessary to clear the bit, if isoch not supported.
#define OHCD_IS_ISOCH_TD(TD) (FALSE)       //We don't care.
#define OHCD_PROCESS_ISOCHRONOUS_TD(deviceExtension, tempTD) //Should never be hit

#endif //end of else DBG!=1
#endif //end of else clause for ifdef OHCD_ISOCHRONOUS_SUPPORTED
#endif //__ISOCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\isoch.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    isoch.c

Abstract:

    Functions used to support isochronous transfers.

Environment:

    Designed for XBOX.

Notes:

Revision History:

    06-29-00 created by Mitchell Dernis (mitchd)

--*/
#ifdef  OHCD_ISOCHRONOUS_SUPPORTED
//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff

USBD_STATUS
FASTCALL
OHCD_fIsochOpenEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        Called to open an isochronous endpoint.
--*/
{
    POHCD_ISOCH_ENDPOINT     endpoint = NULL;
    USBD_STATUS              status = USBD_STATUS_SUCCESS;
    ULONG                    allocSize;
    ULONG                    maxBuffers;
    ULONG_PTR                endpointMemory;
    UCHAR                    index;
    ULONG_PTR                nextTdPhysical;
    ULONG_PTR                tdPhysical;
    KIRQL                    oldIrql;


    USB_DBG_ENTRY_PRINT(("Entering OHCD_OpenEndpoint"));

    maxBuffers = OHCD_IsochPoolGetMaxBuffers();
    allocSize = maxBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR)+sizeof(OHCD_ISOCH_ENDPOINT);

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Allocate the isoch endpoint (with prepended TD's) form pool
    //
    endpointMemory = OHCD_IsochPoolAllocateEndpoint();
    
    //
    //  If there was no memory than fail the open.
    //
    if(!endpointMemory)
    {
        status = USBD_STATUS_NO_MEMORY;
        goto ExitOpenIsochEndpoint;
    }
    
    //
    //  Zero the memory
    //
    RtlZeroMemory((PVOID)endpointMemory, allocSize);

    //
    // Break the memory up into the endpoint and the transfer descriptor memory.
    // (The endpoint starts after the transfer descriptor memory).
    //
    endpoint = (POHCD_ISOCH_ENDPOINT)(
                            endpointMemory +
                            maxBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR)
                            );
    endpoint->TransferDescriptors = (POHCD_ISOCH_TRANSFER_DESCRIPTOR)(endpointMemory);
    endpoint->PhysicalAddress = OHCD_PoolGetPhysicalAddress(endpoint);
    endpoint->EndpointType = USB_ENDPOINT_TYPE_ISOCHRONOUS;
    endpoint->PollingInterval = 1;
    endpoint->Bandwidth = USBD_CalculateUsbBandwidth(
                                Urb->IsochOpenEndpoint.MaxPacketSize,
                                endpoint->EndpointType, 
                                FALSE
                                );
    endpoint->MaxAttachedBuffers = (UCHAR)maxBuffers;
    endpoint->Flags = (Urb->IsochOpenEndpoint.Flags&URB_FLAG_ISOCH_CIRCULAR_DMA) ? OHCD_ISOCH_EDFL_CIRCULAR_DMA : 0;

    //
    //  Fill out everything in the control structure.
    //  Note the Direction here is set correctly for non-control endpoints.
    //  in the next step we have an if USB_ENDPOINT_TYPE_CONTROL and we fix it
    //  for the control endpoints.
    //
    endpoint->HcEndpointDescriptor.Control.FunctionAddress = Urb->IsochOpenEndpoint.FunctionAddress;
    endpoint->HcEndpointDescriptor.Control.EndpointAddress = Urb->IsochOpenEndpoint.EndpointAddress;
    endpoint->HcEndpointDescriptor.Control.Direction = (USB_ENDPOINT_DIRECTION_MASK & Urb->OpenEndpoint.EndpointAddress) ? 2 : 1;
    endpoint->HcEndpointDescriptor.Control.Speed = 0;
    endpoint->HcEndpointDescriptor.Control.Skip = 1;
    endpoint->HcEndpointDescriptor.Control.Format = 1;
    endpoint->HcEndpointDescriptor.Control.MaximumPacketSize = Urb->IsochOpenEndpoint.MaxPacketSize;

    //
    //  Set the head and tail pointer to point to the first transfer descriptor
    //
    tdPhysical = OHCD_PoolGetPhysicalAddress(endpoint->TransferDescriptors);
    WRITE_HEADP(&endpoint->HcEndpointDescriptor, (ULONG)tdPhysical);
    endpoint->HcEndpointDescriptor.TailP = (ULONG)tdPhysical;
    //
    //  Link up all transfer descriptors in a big circle.
    //  The hardware won't see them because HeadP and TailP point
    //  to the same one.
    //  
    for(index = 0; index < maxBuffers; index++)
    {
        nextTdPhysical = OHCD_PoolGetPhysicalAddress(endpoint->TransferDescriptors+index+1);
        endpoint->TransferDescriptors[index].TdIndexPrev = index-1;
        endpoint->TransferDescriptors[index].TdIndex = index;
        endpoint->TransferDescriptors[index].Endpoint = endpoint;
        endpoint->TransferDescriptors[index].Context = NULL;
        endpoint->TransferDescriptors[index].TransferComplete = NULL;
        endpoint->TransferDescriptors[index].IsochTransferDescriptor.Format=1;
        endpoint->TransferDescriptors[index].IsochTransferDescriptor.NextTD = nextTdPhysical;
        tdPhysical = nextTdPhysical;
    }
    endpoint->TransferDescriptors[index-1].IsochTransferDescriptor.NextTD = 0;
    endpoint->TransferDescriptors[0].TdIndexPrev = index - 1;

    //
    //  Insert the endpoint into the schedule (it will then be visible to the hardware).
    //  (The cast is safe because, the beginning of the endpoint structure is the same
    //  as the beginning of the isochronous endpoint structure.)
    //
    status = OHCD_ScheduleAddEndpointPeriodic(DeviceExtension, (POHCD_ENDPOINT)endpoint);
    //
    //  Udpate URB handle
    //
    if(USBD_SUCCESS(status))
    {
        Urb->IsochOpenEndpoint.EndpointHandle = endpoint;
    }
    else
    {
        Urb->IsochOpenEndpoint.EndpointHandle = NULL;
        //
        // Free the endpoint memory
        //
        OHCD_IsochPoolFreeEndpoint(endpointMemory);
    }

ExitOpenIsochEndpoint:
    Urb->Header.Status = status;
    KeLowerIrql(oldIrql);
    USB_DBG_EXIT_PRINT(("Exiting OHCD_OpenIsochEndpoint: usbdStatus = 0x%0.8x", status));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fIsochCloseEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_CLOSE_ENDPOINT
        
        By the time this routine returns, all of the attached buffers can be freed.

    Parameters:

        DeviceExtension - host controller context
        Urb             - urb to handle

    Return Value:

        USBD_STATUS_SUCCESS                     success
--*/
{
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochCloseEndpoint.EndpointHandle;
    KIRQL oldIrql;
    //
    //  Use high Irql to synchronize.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Remove the endpoint from the schedule.
    //
    OHCD_ScheduleRemoveEndpointPeriodic(DeviceExtension, (POHCD_ENDPOINT)endpoint);

    //
    //  Pause the endpoint.  The cast is OK, because the relevant fields are the same.
    //
    OHCD_fPauseEndpoint(DeviceExtension, (POHCD_ENDPOINT)endpoint);
    
    //
    //  Link the URB into the list of pending closes.
    //
    ASSERT(DeviceExtension->PendingCloses != Urb);
    Urb->CloseEndpoint.HcdNextClose = DeviceExtension->PendingCloses;
    DeviceExtension->PendingCloses = Urb;
    //
    //  At this point, the only software that knows about the endpoint is us, so high
    //  Irql is no longer needed.
    //
    KeLowerIrql(oldIrql);
   
    //
    //  Complete this as pending.
    //
    return USBD_STATUS_PENDING;
}

VOID
FASTCALL
OHCD_fIsochCompleteCloseEndpoint(
    IN POHCD_DEVICE_EXTENSION      DeviceExtension,
    IN PURB_ISOCH_CLOSE_ENDPOINT   Urb
    )
{
    
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->EndpointHandle;
    ULONG_PTR endpointMemory;
    POHCD_ISOCH_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG descriptorIndex = endpoint->NextFreeTD + (endpoint->MaxAttachedBuffers - endpoint->AttachedBuffers);

    //
    //  Unlock pages of attached buffers
    //
    
    while(endpoint->AttachedBuffers--)
    {
        descriptorIndex = descriptorIndex%endpoint->MaxAttachedBuffers;
        transferDescriptor = endpoint->TransferDescriptors + (descriptorIndex++);
        //
        //  Unlock the page(s)
        //
        //
        MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferPage0, TRUE);
        if((transferDescriptor->IsochTransferDescriptor.BufferPage0 ^ transferDescriptor->IsochTransferDescriptor.BufferEnd) & ~(PAGE_SIZE-1))
        {
            MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferEnd, TRUE);
        }
    }

    //
    //  Find the original endpoint pointer allocated
    //
    
    endpointMemory = ((ULONG_PTR)(endpoint)) - (endpoint->MaxAttachedBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR));
    OHCD_IsochPoolFreeEndpoint(endpointMemory);
    
    //
    //  Complete the close
    //
    Urb->Hdr.Status = USBD_STATUS_SUCCESS;
    USBD_CompleteRequest((PURB)Urb);
}


USBD_STATUS
FASTCALL
OHCD_fIsochAttachBuffer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_ATTACH_BUFFER
        1) check parameters
        2) figure out which TD to use, and fill out basic stuff.
        3) calculate the offset information
        4) Move the tail pointer
        5) Deal with starting frame if transfers are started.
        
    Parameters:
        DeviceExtension - host controller context
        Urb             - urb to handle
    Return Value:
        USBD_STATUS_SUCCESS                     success
        USBD_STATUS_ISOCH_ALREADY_STARTED       the transfers have already been started.
        USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS   circular DMA and fewer the MaxAttached Buffers are attached.
        USBD_STATUS_BAD_START_FRAME             Start frame is in the past or too far in the future.
--*/

{
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochAttachBuffer.EndpointHandle;
    USBD_STATUS status = USBD_STATUS_SUCCESS;
    POHCD_ISOCH_TRANSFER_DESCRIPTOR transferDescriptor;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR bufferDescriptor;
    ULONG_PTR physicalAddress;
    ULONG initialByteOffset, byteOffset;
    ULONG frameIndex;
    ULONG tdIndex;
    ULONG bufferSize;
    KIRQL oldIrql;

    ASSERT(endpoint);

    //
    //  Raise IRQL for synchronization purposes.  Also it would
    //  could cause some frame problems if we were interrupted for
    //  an extended period of time.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    
    //
    //  make sure we have transfer descriptors for the buffers.
    //
    if(endpoint->MaxAttachedBuffers == endpoint->AttachedBuffers)
    {
        status = USBD_STATUS_ISOCH_TOO_MANY_BUFFERS;
        goto ExitIsochAttachBuffers;
    }
    //
    //  Get a pointer to the buffer descriptor and transfer descriptor
    //
    bufferDescriptor = Urb->IsochAttachBuffer.BufferDescriptor;
    tdIndex = endpoint->NextFreeTD;
    transferDescriptor =  endpoint->TransferDescriptors + tdIndex;
    endpoint->NextFreeTD = (endpoint->NextFreeTD+1)%endpoint->MaxAttachedBuffers;
    
    //
    //  Fill out the software section of the TD.
    //
    transferDescriptor->TransferComplete = bufferDescriptor->TransferComplete;
    transferDescriptor->Context = bufferDescriptor->Context;
    transferDescriptor->Endpoint = endpoint;
    //
    //  Fill copy the Delay interrupt information.
    //
    transferDescriptor->IsochTransferDescriptor.DelayInterrupt = Urb->IsochAttachBuffer.InterruptDelay;
    
    //
    //  Fill out the offset from the pattern.
    //
    transferDescriptor->IsochTransferDescriptor.FrameCount = bufferDescriptor->FrameCount-1;
    initialByteOffset = byteOffset = BYTE_OFFSET(bufferDescriptor->TransferBuffer);
    for(frameIndex = 0; frameIndex < bufferDescriptor->FrameCount; frameIndex++)
    {
        transferDescriptor->IsochTransferDescriptor.Offset_PSW[frameIndex] = (USHORT)(byteOffset|(OHCI_CC_NOT_ACCESSED << 12));
        byteOffset += bufferDescriptor->Pattern[frameIndex];
    }
    bufferSize = (byteOffset-initialByteOffset);

    //
    //  Fillout the start address (and lock it)
    //
    MmLockUnlockBufferPages(bufferDescriptor->TransferBuffer, bufferSize, FALSE);
    physicalAddress = MmGetPhysicalAddress(bufferDescriptor->TransferBuffer);
    transferDescriptor->IsochTransferDescriptor.BufferPage0 = physicalAddress;
    
    //
    //  Fill out the end address (and lock it, if it is a different page).
    //
    physicalAddress = ((ULONG_PTR)(bufferDescriptor->TransferBuffer)) + bufferSize - 1;
    physicalAddress = MmGetPhysicalAddress((PVOID)physicalAddress);
    transferDescriptor->IsochTransferDescriptor.BufferEnd = physicalAddress;

    //
    //   If we are in circular DMA mode, cache the offset information.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_CIRCULAR_DMA)
    {
        RtlCopyMemory((PVOID)(&transferDescriptor->Offsets), (PVOID)transferDescriptor->IsochTransferDescriptor.Offset_PSW, sizeof(USHORT)*8);
    }
    //
    //  If the endpoint is running than we need to deal with the starting frame stuff.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_TRANSFERING)
    {
        //
        //  If the next unused frame is not in the past, use it.
        //  Otherwise, use the current frame (plus one for safety).
        //
        ULONG frame = OHCD_Get32BitFrameNumber(DeviceExtension)+1;
        if( 0 < (((LONG)endpoint->NextUnusedFrame) - ((LONG)frame)) )
        {
            frame = endpoint->NextUnusedFrame;
        }
        transferDescriptor->IsochTransferDescriptor.StartingFrame = frame;
        endpoint->NextUnusedFrame = frame + bufferDescriptor->FrameCount;
    }
    //
    //   Mark that we used a TD
    //
    endpoint->AttachedBuffers++;
    //
    //   Move the tail pointer, if we can, if we cannot, the completion routine
    //   will get it.
    if(endpoint->AttachedBuffers == endpoint->MaxAttachedBuffers)
    {
        ASSERT(0 == transferDescriptor->IsochTransferDescriptor.NextTD);
    } else
    {
        ASSERT(transferDescriptor->IsochTransferDescriptor.NextTD);
        endpoint->HcEndpointDescriptor.TailP = transferDescriptor->IsochTransferDescriptor.NextTD;        
    }
    
   
ExitIsochAttachBuffers:
    //
    //  Done, we can lower the IRQL again.
    //
    KeLowerIrql(oldIrql);
    Urb->Header.Status = status;
    USBD_CompleteRequest(Urb);
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fIsochStartTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_START_TRANSFER
        1) check parameters
        2) Make sure transfer's are stopped.
        3) Fix up starting frame information.
        4) Clear the skip bit.
        5) Set the transfering flag.
    Parameters:
        DeviceExtension - host controller context
        Urb             - urb to handle
    Return Value:
        USBD_STATUS_SUCCESS                     success
        USBD_STATUS_ISOCH_ALREADY_STARTED       the transfers have already been started.
        USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS   circular DMA and fewer the MaxAttached Buffers are attached.
        USBD_STATUS_BAD_START_FRAME             Start frame is in the past or too far in the future.
--*/
{
    ULONG startingFrame, currentFrame;
    UCHAR startingTD, tdIndex;
    USBD_STATUS status = STATUS_SUCCESS;
    KIRQL oldIrql;
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochStartTransfer.EndpointHandle;
    
    ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS == endpoint->EndpointType);
    
    //
    //  Raise IRQL for synchronization purposes.  Also it would
    //  could cause some frame problems if we were interrupted for
    //  an extended period of time.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  Make sure that the endpoint is not running already.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_TRANSFERING) 
    {
        status = USBD_STATUS_ISOCH_ALREADY_STARTED;
        goto ExitIsochStartTransfer;
    }
    //
    //  If the endpoint has been stopped, make sure it is late enough to restart.
    //
    currentFrame = OHCD_Get32BitFrameNumber(DeviceExtension); //We need the current frame now.
    if(endpoint->Flags & OHCD_ISOCH_EDFL_STOPPING)
    {
        endpoint->Flags &= ~OHCD_ISOCH_EDFL_STOPPING;
        //
        //  If the pause frame is the current frame, than wait a millsecond to
        //  make sure that the stop completed.
        //
        if(endpoint->PauseFrame == currentFrame)
        {
           LARGE_INTEGER Wait;
           KeLowerIrql(oldIrql);  //Can't wait at high Irql
           Wait.QuadPart = -10000;
           KeDelayExecutionThread(KernelMode, FALSE, &Wait);
           oldIrql = KeRaiseIrqlToDpcLevel();
        }
        //The frame has changed by now
        currentFrame = OHCD_Get32BitFrameNumber(DeviceExtension);
    }

    //
    //  If circular DMA, make sure that all of the buffers are attached.
    //
    if(
        (endpoint->Flags&OHCD_ISOCH_EDFL_CIRCULAR_DMA) && 
        (endpoint->MaxAttachedBuffers != endpoint->AttachedBuffers)
    )
    {
        status = USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS;
        goto ExitIsochStartTransfer;
    }
    //
    //  Check that the starting frame is valid.
    //
    startingFrame = currentFrame+1;
    if(!(Urb->IsochStartTransfer.Flags&URB_FLAG_ISOCH_START_ASAP))
    {
        //
        //  Signed subtraction account for wrap around
        //
        LONG FrameDiff = (LONG)Urb->IsochStartTransfer.FrameNumber - (LONG)startingFrame;
        if( FrameDiff < 0 || FrameDiff > USBD_ISOCH_START_FRAME_RANGE)
        {
            status = USBD_STATUS_BAD_START_FRAME;
            goto ExitIsochStartTransfer;
        } else
        {
            startingFrame = Urb->IsochStartTransfer.FrameNumber;            
        }
    }
    //
    //  Propogate the frame information into all the TDs
    //
    //
    startingTD = (endpoint->MaxAttachedBuffers - endpoint->AttachedBuffers) + endpoint->NextFreeTD;
    startingTD = startingTD%endpoint->MaxAttachedBuffers;
    tdIndex = startingTD;
    do
    {
        endpoint->TransferDescriptors[tdIndex].IsochTransferDescriptor.StartingFrame = startingFrame;
        startingFrame += endpoint->TransferDescriptors[tdIndex].IsochTransferDescriptor.FrameCount+1;        
        tdIndex = (tdIndex+1)%endpoint->MaxAttachedBuffers;
    }while(tdIndex != endpoint->NextFreeTD);

    endpoint->NextUnusedFrame = startingFrame;

    //
    //  Clear the skip bit.
    //
    endpoint->HcEndpointDescriptor.Control.Skip = 0;

    //
    //  Set the OHCD_ISOCH_EDFL_TRANSFERING flag
    //
    endpoint->Flags |= OHCD_ISOCH_EDFL_TRANSFERING;

ExitIsochStartTransfer:
    KeLowerIrql(oldIrql);
    Urb->Header.Status = status;
    USBD_CompleteRequest((PURB)Urb);
    return status;

}

USBD_STATUS
FASTCALL
OHCD_fIsochStopTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_STOP_TRANSFER
        1) Set the Skip Bit.
        2) Record the current frame number.
    Parameters:
        DeviceExtension - host controller context
        Urb             - urb to handle
    Return Value:
    USBD_STATUS_SUCCESS or 
    USBD_STATUS_ISOCH_NOT_STARTED if the device has not been started.

--*/
{
    KIRQL oldIrql;
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochStartTransfer.EndpointHandle;
    USBD_STATUS  status = USBD_STATUS_SUCCESS;

    ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS == endpoint->EndpointType);
    
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  If the transfer is started, stop it.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_TRANSFERING)
    {
        //
        //  Set the skip bit.
        //
        endpoint->HcEndpointDescriptor.Control.Skip = TRUE;
        //
        //  Set the frame that we need to wait for.
        //
        endpoint->PauseFrame = OHCD_Get32BitFrameNumber(DeviceExtension)+2;
        //
        //   Change the flags.
        //
        endpoint->Flags &= ~OHCD_ISOCH_EDFL_TRANSFERING;
        endpoint->Flags |= OHCD_ISOCH_EDFL_STOPPING;
    } else
    {
        status = USBD_STATUS_ISOCH_NOT_STARTED;
    }
    KeLowerIrql(oldIrql);
    Urb->Header.Status = status;
    USBD_CompleteRequest((PURB)Urb);
    return status;
}

VOID
FASTCALL
OHCD_fIsochProcessTD(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_TRANSFER_DESCRIPTOR TransferDescriptor
    )
/*++
    Routine Description:
        This routine is called every time a transfer descriptor is retired.
        1) copy the status and notify the class driver.
        2) Relink the TD on to the end of the queue.
        3) if circular mode, recopy the offsets and set the starting frame
        4) if circular or needs dummy, move the tail pointer.
        5) if not circular mode, "free" the attached buffer (decrease attached buffer count).
    Parameters:
        DeviceExtension - host controller context
        TransferDescriptor - needs to be cast to an isoch transfer descriptor.
--*/
{
    POHCD_ISOCH_TRANSFER_DESCRIPTOR transferDescriptor = (POHCD_ISOCH_TRANSFER_DESCRIPTOR)TransferDescriptor;
    ULONG tdPhysical;
    POHCD_ISOCH_ENDPOINT endpoint = transferDescriptor->Endpoint;
    UCHAR tdIndexPrev = transferDescriptor->TdIndexPrev;
    PFNUSBD_ISOCH_TRANSFER_COMPLETE       transferComplete;
    PVOID                                 callbackContext;
    USBD_ISOCH_TRANSFER_STATUS            transferStatus;
    BOOLEAN  moveTail;
    
    //
    //  Copy the info we need for the callback, including the status, the callback itself, and the context
    //
    transferStatus.Status = (USBD_STATUS) transferDescriptor->IsochTransferDescriptor.ConditionCode;
    transferStatus.FrameCount = transferDescriptor->IsochTransferDescriptor.FrameCount + 1;
    RtlCopyMemory((PVOID)transferStatus.PacketStatus, (PVOID)transferDescriptor->IsochTransferDescriptor.Offset_PSW, sizeof(USHORT)*8);
    callbackContext = transferDescriptor->Context;
    transferComplete = transferDescriptor->TransferComplete;
    //
    //  Relink the transfer descriptor at the end of the endpoints queue.
    //
    transferDescriptor->IsochTransferDescriptor.NextTD = 0;
    tdPhysical = OHCD_PoolGetPhysicalAddress((PVOID)transferDescriptor);
    endpoint->TransferDescriptors[tdIndexPrev].IsochTransferDescriptor.NextTD = tdPhysical;
    
    //
    //  If we are in circular DMA mode, update the starting frame
    //  and recopy the offset information, and move nextFree
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_CIRCULAR_DMA)
    {
        ULONG startingFrame = OHCD_Get32BitFrameNumber(DeviceExtension)+1;
        LONG FrameDiff = (LONG)endpoint->NextUnusedFrame - (LONG)startingFrame;
        if(FrameDiff >= 0)
        {
            startingFrame = endpoint->NextUnusedFrame;
        }
        transferDescriptor->IsochTransferDescriptor.StartingFrame = startingFrame;
        endpoint->NextUnusedFrame = startingFrame + transferDescriptor->IsochTransferDescriptor.FrameCount+1;
        RtlCopyMemory((PVOID)transferDescriptor->IsochTransferDescriptor.Offset_PSW, (PVOID)&transferDescriptor->Offsets, sizeof(USHORT)*8);
        //
        //  NextFreeTD is moved so that if we get a stop request it can restart on the
        //  next TD.  This may or may not be desirable.
        //
        endpoint->NextFreeTD = (endpoint->NextFreeTD+1)%endpoint->MaxAttachedBuffers;
        //
        //  Always move the tail pointer for circular mode.
        //
        moveTail = TRUE;
    } else
    {
        //
        //  Unlock the page(s)
        //
        //
        MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferPage0, TRUE);
        if((transferDescriptor->IsochTransferDescriptor.BufferPage0 ^ transferDescriptor->IsochTransferDescriptor.BufferEnd) & ~(PAGE_SIZE-1))
        {
            MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferEnd, TRUE);
        }
        //
        //  The number of attached buffers (prior to this one completing) is at the
        //  maximum, then the attach routine would not have been able to move the
        //  tail pointer to point to a dummy, so set moveTail.
        //
        moveTail = (endpoint->AttachedBuffers == endpoint->MaxAttachedBuffers) ? TRUE : FALSE;
        
        //
        //  Mark that the buffer is now unattached.  (i.e. the TD can be reused.
        //
        endpoint->AttachedBuffers--;
    }
    //
    //  If moveTail is TRUE, either because we are in circular, or because we need to
    //  add a dummy TD, then do it now.
    if(moveTail)
    {
        endpoint->HcEndpointDescriptor.TailP = tdPhysical;
    }
    //
    //  Call the class driver's callback
    //
    transferComplete(&transferStatus, callbackContext);
}

#endif  //OHCD_ISOCHRONOUS_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\ohci.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    ohci.h

Abstract:

    OpenHCI Version 1.0a defined registers and data structures
    Some comments included.  See OpenHCI specification for more details.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-13-00 created by Mitchell Dernis (mitchd)

--*/
#ifndef __OCHI_H__
#define __OCHI_H__

//
//  Program interface code for PCI configuration space.
//  Couldn't find it in OpenHCI or UniversalHCI specification.
//  I figure it out by looking at the Win2k usb.inf file.
//
#define OHCI_PCI_PROGRAM_INTERFACE 0x10

//
//  Endpoint Control
//
typedef union _OHCI_ENDPOINT_CONTROL
{
    ULONG ul;
    struct {
        ULONG   FunctionAddress:7;      //Address of function (or hub) containing endpoint
        ULONG   EndpointAddress:4;      //Address of endpoint within function (or hub)
        ULONG   Direction:2;            //00b - 11b = read from TD, 01b = OUT, 10b = IN
        ULONG   Speed:1;                //0 = full speed, 1 = low speed
        ULONG   Skip:1;                 //When set, HC skips this Endpoint in the schedule
        ULONG   Format:1;               //0 = Control, Bulk or Interrupt, 1=Isochronous
        ULONG   MaximumPacketSize:11;   //Maximum bytes in a single packet
        ULONG   FutureSoftwareUse:5;    //Preserved by HC, available for driver use.
    };
} OHCI_ENDPOINT_CONTROL, *POHCI_ENDPOINT_CONTROL;

//
//  Structure OHCI_ENDPOINT_DESCRIPTOR
//  This structure is used to represent an endpoint in the USB schedule on OHCI controllers.
//  (DO NOT CONFUSE WITH USB_ENDPOINT_DESCRIPTOR DEFINED IN USB SPECIFICATION)
//
//  Comments:
//
//  Must be 4 DWORDs (16 bytes) long.
//
//  When TailP = HeadP the list contains no TD that the HC can process.
//
//
typedef struct _OHCI_ENDPOINT_DESCRIPTOR
{
    //First DWORD
    OHCI_ENDPOINT_CONTROL Control;  //see OHCI_ENDPOINT_CONTROL

    //Second DWORD
    ULONG   TailP;                  //Points to last TD for Endpoint.  Pointer should be
                                    //paragraph(16 bytes) aligned.  4 lsb are ignored.
    
    //Third DWORD
    ULONG   HeadPHaltCarry;         //Point to first TD for Endpoint. Pointer should be
                                    //paragraph(16 bytes) aligned.  2 lsb are used though
                                    //for Halt and toggleCarry fields.  Bits 3, 4 must be zero.
                                    //Therefore, use access macros.  WRITE_HEADP/READ_HEADP,
                                    //SET_HALTED/CLEAR_HALTED/GET_HALTED, and SET_TOGGLECARRY/
                                    //CLEAR_TOGGLECARRY/GET_TOGGLECARRY defined below.

    //Fourth DWORD
    ULONG   NextED;                 //Points to next endpoint.  Pointer should be
                                    //paragraph(16 bytes) aligned.  4 lsb are ignored.

} OHCI_ENDPOINT_DESCRIPTOR, *POHCI_ENDPOINT_DESCRIPTOR;

//
//  Macros for access to HeadPHaltCarry element of OHCI_ENDPOINT_DESCRIPTOR
//
#define WRITE_HEADP(_endpoint_descriptor_pointer_, _HeadP_)\
            (_endpoint_descriptor_pointer_)->HeadPHaltCarry = (_HeadP_ & 0xFFFFFFF0) | \
            ((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0x0000000F);
#define READ_HEADP(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0xFFFFFFF0)

#define SET_HALTED(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry |= 0x00000001)
#define CLEAR_HALTED(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry &= ~0x00000001)
#define GET_HALTED(_endpoint_descriptor_pointer_) \
            (((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0x00000001) ? TRUE : FALSE)


#define SET_TOGGLECARRY(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry |= 0x00000002)
#define CLEAR_TOGGLECARRY(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry &= ~0x00000002)
#define GET_TOGGLECARRY(_endpoint_descriptor_pointer_) \
            (((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0x00000002) ? TRUE : FALSE)


//
//  Structure OHCI_TRANSFER_DESCRIPTOR
//  This structure is used to represent bulk, interrupt and control transfers
//  descriptors in the USB schedule on OHCI controllers.
//
//  Must be 4 DWORDs (16 bytes) long.
//
typedef struct _OHCI_TRANSFER_DESCRIPTOR *POHCI_TRANSFER_DESCRIPTOR;
typedef struct _OHCI_TRANSFER_DESCRIPTOR
{
    //First DWORD
    ULONG FutureSoftwareUse1:16;    //Preserved by HC, available for driver use.
    ULONG Format:1;                 //Preserved by HC, XBOX OHCD driver defined analog to format set in ED
    ULONG FutureSoftwareUse2:1;     //Preserved by HC, available for driver use.
    ULONG BufferRounding:1;         //If clear, than short packets generate an error.
    ULONG Direction_PID:2;          //00b = SETUP, 01b = OUT, 10b = IN, 11b = Reserved
    ULONG DelayInterrupt:3;         //Time (in frames) before interrupt must generated after
                                    //this is TD is completed.  111b = No Interrupt
    ULONG DataToggle:2;             //Used for DATA0\DATA1 toggling.  MSb = 0 indicates
                                    //that toggleCarry in ED should be used.  MSb = 1 indicates
                                    //that LSb should be used.
    ULONG ErrorCount:2;             //Error count on attempts to process TD.  After 3, TD is
                                    //retired as a failure with the ConditionCode set. Endpoint
                                    //is halted.
    ULONG ConditionCode:4;          //Status of TD

    //Second DWORD
    ULONG CurrentBufferPointer;     //Pointer to current location in data buffer which receives
                                    //or sends data.

    //Third DWORD
    //  When a TD is handed over to the HC NextTD has a correct physical address.
    //  However, after dequeueing a TD from the DoneQueue, we use NextTDVirtual
    //  so that the driver may easily traverse the list.
    //
    union
    {
        ULONG                       NextTD;         //Pointer to next Transfer Desciptor.  Must be paragraph
        POHCI_TRANSFER_DESCRIPTOR   NextTDVirtual;  //aligned, i.e. bits 0-3 must be 0. We also
    };

    //Fourth DWORD
    ULONG BufferEnd;                //BufferEnd - used for 2 page scatter\gather on long packets.
                                    //see OHCI specification.
} OHCI_TRANSFER_DESCRIPTOR;


//
//  Macros for OHCI_TRANSFER_DESCRIPTOR.Direction_PID
//
#define OHCI_TD_DIRECTION_PID_SETUP         0
#define OHCI_TD_DIRECTION_PID_OUT           1
#define OHCI_TD_DIRECTION_PID_IN            2


//
// Macros for OHCI_TRANSFER_DESCRIPTOR.DelayInterrupt;
//
#define OHCI_TD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define OHCI_TD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_6_MS        6   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD


//
// Macros for OHCI_TRANSFER_DESCRIPTOR.DataToggle
//
#define OHCI_TD_TOGGLE_FROM_ED          0   // Get the toggle from the ED 
#define OHCI_TD_TOGGLE_DATA_MASK        1   // Mask used for toggling the lsb.
#define OHCI_TD_TOGGLE_DATA0            2   // DATA0 and MSb is set, so it will not use
                                            // endpoint toggle carry.
#define OHCI_TD_TOGGLE_DATA1            3   // DATA1 and MSb is set, so it will not use
                                            // endpoint toggle carry.


//
//  Condition Code definitions for both general and isochronous transfers
//
#define OHCI_CC_NO_ERROR                0x0 //Completed without detected error
#define OHCI_CC_CRC                     0x1 //CRC error
#define OHCI_CC_BIT_STUFFING            0x2 //Bit-stuffing error
#define OHCI_CC_DATA_TOGGLE_MISMATCH    0x3 //DATA0\DATA1 mismatched
#define OHCI_CC_STALL                   0x4 //Stall 
#define OHCI_CC_DEVICE_NOT_RESPONDING   0x5 //Device screwed up handshake
#define OHCI_CC_PID_CHECK_FAILURE       0x6 //Send PID was not valid for endpoint
#define OHCI_CC_UNEXPECTED_PID          0x7 //Receive PID was not valid for endpoint
#define OHCI_CC_DATA_OVERRUN            0x8 //Endpoint returned more data than MaximumPacketSize
#define OHCI_CC_DATA_UNDERRUN           0x9 //Endpoint returned short packet (only if BufferRounding = 0)
#define OHCI_CC_RESERVED1               0xA //Reserved
#define OHCI_CC_RESERVED2               0xB //Reserved
#define OHCI_CC_BUFFER_OVERRUN          0xC //During an IN, HC received data faster than it could
                                            //write it with DMA.
#define OHCI_CC_BUFFER_UNDERRUN         0xD //During an OUT, HC could not fetch data fast enough
                                            //through DMA.
#define OHCI_CC_NOT_ACCESSED            0xE //Either of these may be set by driver before TD
#define OHCI_CC_NOT_ACCESSED2           0xF //is inserted in schedule


//
//  A little 'coincidence' in the way USBD_STATUS_XXXX codes are defined.
//  we can convert very easily.
//
#define OHCI_CC_TO_USBD_STATUS(_ConditionCode_)  ((ULONG)_ConditionCode_ | 0xC0000000)

//
//  Structure OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR
//  This structure is used to represent isochronous transfers
//  in the USB schedule on OHCI controllers.
//
//  Must be 8 DWORDs (32 bytes) long.
//
typedef struct _OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR
{
    //DWORD 0
    ULONG   StartingFrame:16;       //Describes which frame transfer should start in.
    ULONG   Format:1;               //Preserved by HC, XBOX driver defined analog to format set in ED
    ULONG   FutureSoftwareUse:4;    //Preserved by HC, available for driver use.
    ULONG   DelayInterrupt:3;       //Time (in frames) before interrupt must generated after
                                    //this is TD is completed.  111b = No Interrupt
    ULONG   FrameCount:3;           //One less than count of Data Packets (one data packet = one frame)
    ULONG   FutureSoftwareUse2:1;   //Preserved by HC, available for driver use.
    ULONG   ConditionCode:4;        //Status of TD
    
    //DWORD 1
    ULONG   BufferPage0;            //Pointer to current location in data buffer which receives
                                    //or sends data.
    //DWORD 2
    ULONG   NextTD;                 //Pointer to next Transfer Desciptor.  Must be paragraph
                                    //aligned, i.e. bits 0-3 must be 0.

    //DWORD 3
    ULONG   BufferEnd;              //BufferEnd - used for 2 page scatter\gather on long packets.
                                    //see OHCI specification.

    //DWORDs 4-7
    USHORT  Offset_PSW[8];          //On input each of these is a buffer offset for
                                    //primitive scatter gather processing for each packet.
                                    //When retired, they contain the size and status
                                    //of transfers.
                                    //There are eight of these, one for each possible frame
                                    //that data can be sent in.
} OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR, *POHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR;


//
//  Structure Represented Host Controller Communications Area(HCCA)
//
typedef struct _OHCI_HCCA
{
    ULONG   InterruptTable[32];     //Each entry points to list of Interrupt Endpoints.
                                    //These lists build the frame schedule for interrupts.
    USHORT  FrameNumber;            //Current Frame number (16 bits)
    USHORT  Pad1;                   //HC clears this when the FrameNumber is updated
    ULONG   DoneHead;               //Pointer to List of completed TDs
    UCHAR   Reserved[120];          //Scratch area for HC except for last 4 bytes which are
                                    //padding so that this is divisible by 32.
} OHCI_HCCA, *POHCI_HCCA;

//
//  Bit field for accessing the HcControl register
//
typedef union _HC_CONTROL_REGISTER
{
    ULONG   ul;
    struct
    {
        ULONG   ControlBulkServiceRatio:2;      //One less than the count of control to bulk packets services
        ULONG   PeriodicListEnable:1;           //If set, processing periodic lists is enabled
        ULONG   IsochronousEnable:1;            //If set, processing of Isochronous TD is enable if PeriodLists are.
        ULONG   ControlListEnable:1;            //If set, processing of Control Endpoints is enabled
        ULONG   BulkListEnable:1;               //If set, processing of Bulk Endpoints is enabled
        ULONG   HostControllerFunctionalState:2;//See HC_OPSTATE_USB_XXX definitions below
        ULONG   InterruptRouting:1;             //If set, interrupts are SMI routed, if clear normal bus interrupts
        ULONG   RemoteWakeupConnected:1;        //If set, HC supports remote wakeup.
        ULONG   RemoteWakeupEnabled:1;          //If set, remote wakeup is enabled.
        ULONG   Reserved:21;        
    };
} HC_CONTROL_REGISTER, *PHC_CONTROL_REGISTER;
#define HC_OPSTATE_USB_RESET        0
#define HC_OPSTATE_USB_RESUME       1
#define HC_OPSTATE_USB_OPERATIONAL  2
#define HC_OPSTATE_USB_SUSPEND      3
//
//  Bit fields are a bit inefficient.  When we are changing a 2 bit field
//  or even a bit at a time, it makes the code more readable.  However,
//  during the vary initial setup we want to go to the running state
//  while slamming a bunch of bits.  Here's what we slam.
//  
//  1) Control\Bulk Service Ratio start at 2:1
//
//  2) Periodic, Bulk, and Contorl lists are
//     enabled. Isochronous is disabled.
//
//  3) HostControllerFunctionState is UsbOperational
//  
//  4) Interrupt Routing is normal (bit clear)
//
//  5) Remote wakeup is disabled.
#define HC_CONTROL_REGISTER_START   0x000000B6

//
//  For quick reboot, we shutdown USB.  We slam it into the
//  following stopped state.
//
//  1) Control\Bulk Service Ratio 2:1
//
//  2) All list processing disabled.
//
//  3) HostControllerFunctionState is UsbReset
//
//  4) Interrupt Routing is normal (bit clear)
//
//  5) Remote wakeup is disabled.
#define HC_CONTROL_REGISTER_STOP  0x00000002

//
//  Bit field for accessing the HcCommandStatus register
//
typedef union _HC_COMMAND_STATUS
{
    ULONG   ul;
    struct {
        ULONG   HostControllerReset:1;          //Set to initiate software reset.
        ULONG   ControlListFilled:1;            //Set to indicate that a TD was added to a control ED
        ULONG   BulkListFilled:1;               //Set to indicate that a TD was added to a bulk ED
        ULONG   OwnerShipChangeRequest:1;       //Set to request control from SMM
        ULONG   Reserved:12;
        ULONG   SchedulingOverrunCount:2;       //Count of schedule overruns.
        ULONG   Reserved2:14;
    };
} HC_COMMAND_STATUS, *PHC_COMMAND_STATUS;

//
//  Macros to use insted for ControlListFilled and BulkListFilled
//
#define HCCS_ControlListFilled  0x00000002
#define HCCS_BulkListFilled     0x00000004


//
//  Macros for HcInterruptEnable and HcInterruptDisable bit fields
//
//  The HCD can write to both HcInterruptEnable and HcInterruptDisable, however, only bit
//  setting is processed not bit clearing.  To enable an interrupt, set the corresponding bit
//  in HcInterruptEnable.  To disable an interrupt write to HcInterruptDisable.  Since the
//  bit layouts are identical, there are only one set of macros.
//
#define HCINT_SchedulingOverrun     0x00000001  //Enables\Disables interrupt on scheduling overrun
#define HCINT_WritebackDoneHead     0x00000002  //Enables\Disables interrupt on Writeback of HcDoneHead
#define HCINT_StartOfFrame          0x00000004  //Enables\Disables interrupt on Start of Frame
#define HCINT_ResumeDetect          0x00000008  //Enables\Disables interrupt on Resume detect
#define HCINT_UnrecoverableError    0x00000010  //Enables\Disables interrupt on Unrecoverable Error
#define HCINT_FrameNumberOverflow   0x00000020  //Enables\Disables interrupt on HcFmNumber changes
#define HCINT_RootHubStatusChange   0x00000040  //Enables\Disables interrupt on HcRhStatus or HcRhPortStatus[n] changes
//Bunch of reserved bits
#define HCINT_OwnershipChange       0x40000000  //Enables\Disables interrupt on Ownership change
#define HCINT_MasterInterruptEnable 0x80000000  //Master switch for enabling interrupts

//
//  Bit Field structure for HcFmInterval
//
typedef union _HC_FRAME_INTERVAL
{
    ULONG   ul;
    struct{
        ULONG   FrameInterval:14;               //adjustable interval in clocks between SOF, can be used
                                                //to sync to external clock source
        ULONG   Reserved:2;                     
        ULONG   FullSpeedMaximumPacketSize:15;  //Maximum number of bits in full speed packets to send
                                                //with scheduling over flow.  Calculated by HCD at initialization.
        ULONG   FrameIntervalToggle:1;          //Toggled by HCD when FrameInterval changes.
    };
} HC_FRAME_INTERVAL, *PHC_FRAME_INTERVAL;


//
//  The frame interval is set in terms of clocks.  However, there is overhead from SOF and other
//  minutia.  Additionally, there is bit stuffing which eats on average one out of 7 bits.
//  According to OHCI we need to calculate this.
//  210 is an estimate of the overhead.  I found this formula in existing Win2k code.
//
#define OHCI_DEFAULT_FRAME_INTERVAL 0x2EDF
#define OHCI_CLOCKS_TO_BITS(_Clocks_) ((((_Clocks_) - 210) * 6)/7)

//
//  bit field structure fpr HcRhDescriptorA
//
typedef union _HC_RH_DESCRIPTOR_A
{
    ULONG ul;
    struct
    {
        //First byte
        UCHAR   NumberDownstreamPorts;          //Count of downstream ports off of root hub.

        //Second byte
        UCHAR   PowerSwitchingMode:1;           //If NoPowerSwitch is set, this determines the mode.
        UCHAR   NoPowerSwitch:1;                //0 = ports are power switchable, 1 = ports powered if HC powered.
        UCHAR   DeviceType:1;                   //Should always be 0, because Root Hub is not a compound device.
        UCHAR   OverCurrentProtectionMode:1;    //If set overcurrent is reported on per port basis.fs
        UCHAR   NoOverCurrentProtection:1;      //If set overcurrent is not reported.
        UCHAR   ReservedBits:3;

        //Third byte
        UCHAR   Reserved;

        //Fourth byte
        UCHAR   PowerOnToPowerGoodTime;         //Time HCD waits after powering hub before accessing hub.
                                                //Reported in 2 ms units.
    };
} HC_RH_DESCRIPTOR_A, *PHC_RH_DESCRIPTOR_A;

//
//  bit field structure fpr HcRhDescriptorB
//
typedef union _HC_RH_DESCRIPTOR_B
{
    ULONG ul;
    struct
    {
        USHORT  DeviceRemovable;                //Each bit is dedicated to a port.  If set indicates
                                                //that device can NOT be removed from root hub.
        USHORT  PortPowerControlMask;           //Each bit is dedicated to a port.  If set indicates
                                                //that device is only effected by per port power control.
                                                //Ignored if PowerSwitchingMode is cleared.
    };
} HC_RH_DESCRIPTOR_B, *PHC_RH_DESCRIPTOR_B;

//
//  macros and struct for HcRhStatus register
//
//  The HubStatus part represents the status if read.
//  Write a one to the corresponding bit in HubStatusChange.
//
//  However to complicate matter, the LocalPower bit can be written
//  to in HubStatus.  It has the effect of turning off power.  The corresponding
//  bit in HubStatusChange turns power on.  Guess what, reading LocalPower in the
//  HubStatusChange register always returns 0.
//
//  OverCurrentIndicator works as expected.  On read of HubStatus it returns the
//  state, it is not writeable. In HubStatusChange a read returns one if the state
//  change.   You can clear it with a write of a one to HubStatusChange.
//
//  Reading DeviceRemoteWakeup in HubStatus indicates whether a remote wakeup was signaled.
//  Writing a one to HubStatus enables remote wakeup.  Writing a one to HubStatusChange
//  disables remote wakeup.
//
#define HC_RH_STATUS_LocalPower                 0x0001
#define HC_RH_STATUS_OvercurrentIndicator       0x0002
#define HC_RH_STATUS_DeviceRemoteWakeupEnable   0x8000
typedef union _HC_RH_STATUS
{
    ULONG   ul;
    struct {
        USHORT  HubStatus;              //bit field indicating hub status
        USHORT  HubStatusChange;        //bit field for changing hub status
    };
} HC_RH_STATUS, *PHC_RH_STATUS;

//
//  Values for initializing the RootHub on Xbox
//

#define HC_RH_DESCRIPTOR_A_INIT_XBOX         0x00001200  //NoOverCurrentProtection|NoPowerSwitch
#define HC_RH_DESCRIPTOR_B_INIT_XBOX         0x00000000  
#define HC_RH_STATUS_INIT_XBOX               0x80000000  //Clears DeviceRemoteWakeupEnable

//
//  macros and struct for HcRhPortStatus,
//  !!!!Some of the bits do double duty (different on read and write)
//  so there may be more than one macro per bit!!!
//
#define HC_RH_PORT_STATUS_CurrentConnectStatus      0x0001  //Read PortStatus, 1 if device currently connected
#define HC_RH_PORT_STATUS_ClearPortEnable           0x0001  //Set PortStatus, disables  clears PortEnableStatus
                                                            //Read PortStatusChange, 1 indicates connect or disconnect
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortEnableStatus          0x0002  //Read PortStatus, 1 if port is enable
#define HC_RH_PORT_STATUS_SetPortEnable             0x0002  //Set PortStatus, enables device
                                                            //Read PortStatusChange, 1 indicates change in PortStatus bit
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortSuspendStatus         0x0004  //Read PortStatus, 1 if port is suspended
#define HC_RH_PORT_STATUS_SetPortSuspend            0x0004  //Set PortStatus suspends device
                                                            //Read PortStatusChange, 1 indicates change in PortStatus bit
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortOverCurrentIndicator  0x0008  //Read PortStatus, 1 if port is overcurrent detected
#define HC_RH_PORT_STATUS_ClearSuspendStatus        0x0008  //Set PortStatus resumes device
                                                            //Read PortStatusChange, 1 indicates change in PortStatus bit
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortResetStatus           0x0010  //Read PortStatus, 1 if port reset signal is active
#define HC_RH_PORT_STATUS_SetPortReset              0x0010  //Set PortStatus initiates reset signal
                                                            //Read PortStatusChange, 1 indicates reset signal completed (10 ms)
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortPowerStatus           0x0100  //Read PortStatus, 1 if port power is on
#define HC_RH_PORT_STATUS_SetPortPower              0x0100  //Set PortStatus turns power on
                                                            //There is no PortStatusChange bit
#define HC_RH_PORT_STATUS_LowSpeedDeviceAttach      0x0200  //Read PortStatus, 1 connected device is low speed.
#define HC_RH_PORT_STATUS_ClearPortPower            0x0200  //Set PortStatus, shut port power off.
                                                            //There is no PortStatusChange bit

typedef union _HC_RH_PORT_STATUS
{
    ULONG   ul;
    struct
    {
        USHORT  PortStatus;             //bit field indicating\changing port status
        USHORT  PortStatusChange;       //bit field for indicating changes in port status
    };
} HC_RH_PORT_STATUS, *PHC_RH_PORT_STATUS;

                                                            
//
// Operational Registers
//
typedef struct _OHCI_OPERATIONAL_REGISTERS
{
    //Control and Status
    ULONG               HcRevision;             //LSB is BCD revision of OpenHCI
    HC_CONTROL_REGISTER HcControl;
    HC_COMMAND_STATUS   HcCommandStatus;
    ULONG               HcInterruptStatus;      //See HCINT_Xxxx macros above
    ULONG               HcInterruptEnable;      //See HCINT_Xxxx macros above
    ULONG               HcInterruptDisable;     //See HCINT_Xxxx macros above

    //Memory Pointers
    //  All are pointers to physical memory.  Excepting HcHCCA they are paragraph (16 bytes)
    //  aligned.  HcHCCA is on 256 byte boundary at minimum, some controllers require more
    //  stringent alignmnet.  Test by writing 0xFFFFFFFF and reading back to see how many
    //  of the least signficant bits are 0.
    ULONG   HcHCCA;                 //HCCA area
    ULONG   HcPeriodCurrentED;      //Current ED being processed in (interrupt and isoch lists)
    ULONG   HcControlHeadED;        //Head of ED list for control pipes
    ULONG   HcControlCurrentED;     //Current location ED list for control pipes
    ULONG   HcBulkHeadED;           //Head of ED list for bulk pipes
    ULONG   HcBulkCurrentED;        //Current location ED list for bulk pipes
    ULONG   HcDoneHead;             //Pointer list of completed TDs.  Head of list is last completed.

    //Frame Counter
    HC_FRAME_INTERVAL   HcFmInterval;   //HC_FRAME_INTERVAL for comments
    ULONG               HcFmRemaining;  //14 bit down counter of bits remaining in current frame
                                        //high bit is a toggle, to sync with FrameInterval
    ULONG               HcFmNumber;     //16-bit Frame Counter
    ULONG               HcPeriodicStart;//14-bit value calculated by HCD to reserve enough bandwidth
                                        //for the interrupt and isoch ED list processing.  It is the number
                                        //of bits into the frame before moving to periodic processing.
    ULONG               HcLSThreshold;  //12-bit value for minimum number of bits in frame for which to
                                        //attempt transfering an 8 byte low-speed packet.

    //Root Hub
    //  Registers which are involved with with the root hub emulation
    HC_RH_DESCRIPTOR_A  HcRhDescriptorA;    
    HC_RH_DESCRIPTOR_B  HcRhDescriptorB;
    HC_RH_STATUS        HcRhStatus;
    HC_RH_PORT_STATUS   HcRhPortStatus[1];  //Variable length really, depends on count of hubs
} OHCI_OPERATIONAL_REGISTERS, *POHCI_OPERATIONAL_REGISTERS;
//
//  This is not necessarily sizeof(OHCI_OPERATIONAL_REGISTERS).
//  Rather it is the address space that it occupies in memory.
//
#define OHCI_OPERATIONAL_REGISTER_SIZE 0x1000
#endif //__OCHI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\pool.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    pool.c

Abstract:
    
    Implementation of transfer descriptor pool manager.


    OHCI implements a multi-plexed DMA scheme.  Rather than having a number of fixed registers for
    programming DMA.  The host controller and the host controller driver share a common data structure.
    This structure must be locked down in physical memory at all times.

    The structure is a linked list of queues.  The head of each queue is referred to as an Endpoint Descriptor
    (Not to be confused to the endpoint descriptor in the USB specification, which is a different entity
    entirely.)  Each endpoint descriptor points to the head and tail of singly linked list of Transfer Descriptors.
    Each TD describes the user buffer for transfering a single packet of data across the USB wire.  The host controller
    walks through this schedule and pulls of transfer descriptors one at a time.  It performs the transfer (or records
    an error).  Then it places the TD on a DoneHead and moves on to the next one.

    Each of these TDs is 16 bytes long as defined by hardware.  However, the software needs additional fields so
    each block is expanded to 32 bytes.
    
    Isochronous Endpoints to not use a TD pool, but instead come as part of the Isochronous part of the URB extension.

    The code in this module allocates two pages of memory.  The first part of the first page is returned for use as the HCCA area.
    The rest is broken into 32 byte blocks.

    01-12-01  Originally, this code allocate memory for the TD's and the HCCA area.  There was a separate
    TD pool for each host controller.  Now there will be one TD pool for both host controllers, plus endpoints
    will also come out of here.  We can do this, because we are moving to an upfront iniitialization of everything.
    We also allocate isochronous endpoints from here.

Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-17-00 created by Mitchell Dernis (mitchd)
    01-12-01 changed name to pool.c (mitchd)

--*/

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

//
//  Pull in usb headers
//

#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff

OHCD_POOL OHCD_GlobalPool;

#pragma code_seg(".XPPCINIT")


//------------------------------------------
//  Initialize Pool
//------------------------------------------
VOID
FASTCALL
OHCD_fPoolInit(
    IN PHCD_RESOURCE_REQUIREMENTS pResourceRequirements
    )
{
    ULONG                       poolSize;
    ULONG                       pageCount;
    ULONG_PTR                   poolMemory;
    ULONG_PTR                   poolEnd;
    ULONG                       index;
    ULONG                       isochEndpointSize;
    ULONG                       combinedEndpointSize;
    ULONG                       transferDescriptorsCount;
    POHCD_TRANSFER_DESCRIPTOR   transferDescriptor;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_InitPool."));

    //
    //  Figure out how much memory is needed.
    //
    isochEndpointSize = OHCD_ISOCH_ENDPOINT_SIZE(pResourceRequirements->IsochMaxBuffers);
    combinedEndpointSize = isochEndpointSize+sizeof(OHCD_ENDPOINT);
    ASSERT(0==isochEndpointSize%16);
    ASSERT(0==(combinedEndpointSize)%32);
    ASSERT(0==sizeof(OHCI_HCCA)%32);
    ASSERT(32==sizeof(OHCD_TRANSFER_DESCRIPTOR));

    if(pResourceRequirements->EndpointCount < pResourceRequirements->IsochEndpointCount)
    {
        pResourceRequirements->EndpointCount = pResourceRequirements->IsochEndpointCount;
    }

    poolSize = sizeof(OHCI_HCCA)*HCD_MAX_HOST_CONTROLLERS +
               pResourceRequirements->IsochEndpointCount*isochEndpointSize +
               pResourceRequirements->EndpointCount * sizeof(OHCD_ENDPOINT) +
               pResourceRequirements->TDCount * sizeof(OHCD_TRANSFER_DESCRIPTOR);

    USB_DBG_TRACE_PRINT(("Required Pool Size = %d bytes.", poolSize));
    //
    //  Figure out how many pages are needed.
    //  (divide by PAGE_SIZE, but make sure that it rounds up, not down)
    //
    pageCount = (poolSize + PAGE_SIZE - 1)/PAGE_SIZE;

    //
    //  Alignment issues may require 16 bytes of dead space
    //  at the end of each page. Make sure we have it just in case.
    if(pageCount*PAGE_SIZE < (pageCount*16+poolSize))
    {
        pageCount++;
    }

    USB_DBG_TRACE_PRINT(("Low-level XPP uses %d pages.", pageCount));
    USB_DBG_TRACE_PRINT(("Max EndpointCount = %d.", pResourceRequirements->EndpointCount));
    USB_DBG_TRACE_PRINT(("Max IsochEndpointCount = %d.", pResourceRequirements->IsochEndpointCount));
    
    //
    //  Allocate PageCount pages of memory.
    //
    poolSize = pageCount*PAGE_SIZE;
#ifdef DVTSNOOPBUG
    OHCD_PoolCreateDoubleBufferPool();
    poolMemory = (ULONG_PTR)MmAllocateContiguousMemoryEx(poolSize, 0, MAXULONG_PTR, 0, PAGE_READWRITE|PAGE_NOCACHE);
    __asm wbinvd; //flush cache
#else
    poolMemory = (ULONG_PTR)MmAllocateContiguousMemory(poolSize);
#endif //DVTSNOOPBUG
   
    RIP_ON_NOT_TRUE_WITH_MESSAGE(poolMemory, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    
    //
    //  Lock it all down.
    //
    MmLockUnlockBufferPages((PVOID)poolMemory, poolSize, FALSE);

    //
    //  Record the difference between the virtual and physical addresses.
    //  (use this for quick conversion.)
    OHCD_GlobalPool.VirtualToPhysical = poolMemory - MmGetPhysicalAddress((PVOID)poolMemory);

    //
    //  Initialize page
    //
    RtlZeroMemory((PVOID)poolMemory, poolSize);

    //**
    //**  Carve up the pool into HCCA's, isoch endpoints, endpoints, and TDs.
    //**  
    poolEnd = poolMemory + poolSize;
    
    //
    // HCCA
    //
    for(index=0; index < HCD_MAX_HOST_CONTROLLERS; index++)
    {
        OHCD_GlobalPool.Hcca[index] = (POHCI_HCCA)poolMemory;
        poolMemory += sizeof(OHCI_HCCA);
        ASSERT(poolEnd > poolMemory);
    }

    //
    //  OHCD_ISOCH_ENDPOINT
    //  (allocate an OHCD_ENDPOINT with each OHCD_ISOCH_ENDPOINT
    //   to keep the alignment requirements.)
    //
    
    index = 0;  //we want index initialized, outside the conditionally compiled
                //isochronous code.
    OHCD_GlobalPool.FreeEndpoints = NULL;
#ifdef OHCD_ISOCHRONOUS_SUPPORTED
    OHCD_GlobalPool.IsochMaxBuffers = pResourceRequirements->IsochMaxBuffers;
    OHCD_GlobalPool.IsochFreeEndpoints = 0;
    for(; index < pResourceRequirements->IsochEndpointCount; index++)
    {
        // An isoch endpoint is 48 bytes long +
        // an integer multiple of 64 bytes, yet the hardware requires 32 byte alignment.
        // So these cannot be densly packet.  To achieve better packing we intersperse
        // regular endpoints which are 48 bytes long, but require only 16 byte alignment.
    
            
        // allocate an isoch endpoint            
        *((PULONG_PTR)(poolMemory)) = OHCD_GlobalPool.IsochFreeEndpoints;
        OHCD_GlobalPool.IsochFreeEndpoints = (ULONG_PTR)(poolMemory);
        poolMemory += isochEndpointSize;
        ASSERT(poolEnd > poolMemory);
        // allocate an endpoint
        ((POHCD_ENDPOINT)(poolMemory))->Next = OHCD_GlobalPool.FreeEndpoints;
        OHCD_GlobalPool.FreeEndpoints = (POHCD_ENDPOINT)(poolMemory);
        poolMemory += sizeof(OHCD_ENDPOINT);
        ASSERT(poolEnd > poolMemory);
    }
#endif //OHCD_ISOCHRONOUS_SUPPORTED
    
    //
    // OHCD_ENDPOINT - don't reset index, since it already 
    //                 records how many were allocated with
    //                 OHCD_ISOCH_ENDPOINTs.
    //
    for(; index < pResourceRequirements->EndpointCount; index++)
    {
        // allocate an endpoint
        ((POHCD_ENDPOINT)(poolMemory))->Next = OHCD_GlobalPool.FreeEndpoints;
        OHCD_GlobalPool.FreeEndpoints = (POHCD_ENDPOINT)(poolMemory);
        poolMemory += sizeof(OHCD_ENDPOINT);
        ASSERT(poolEnd > poolMemory);
    }

    //
    //  OHCD_TRANSFER_DESCRIPTOR - we can always use extras, so
    //                             allocate until the end of the pool.
    //
    transferDescriptorsCount = 0;
    OHCD_GlobalPool.FreeTDs = NULL;
    OHCD_GlobalPool.FirstTD = (POHCD_TRANSFER_DESCRIPTOR)poolMemory;
    while((poolMemory + sizeof(OHCD_TRANSFER_DESCRIPTOR)) <= poolEnd)
    {
        transferDescriptor = (POHCD_TRANSFER_DESCRIPTOR)poolMemory;
        transferDescriptor->PhysicalAddress = OHCD_PoolGetPhysicalAddress(transferDescriptor);
        OHCD_PoolFreeTD(transferDescriptor);
        poolMemory += sizeof(OHCD_TRANSFER_DESCRIPTOR);
        transferDescriptorsCount++;
    }
    OHCD_GlobalPool.LastTD = transferDescriptor;
    OHCD_GlobalPool.LostDoneHeadCount = 0;
    OHCD_GlobalPool.LostMinimumDoneListLength = 1000; //init to a large value.
    
    //
    //  If this assert fails we under-allocated.  Hitting this is a pretty serious
    //  bug in the pool initialization code.
    //
    ASSERT(transferDescriptorsCount >= pResourceRequirements->TDCount);

    //
    //  Record the quotas in the pool
    //
    OHCD_GlobalPool.ControlQuota = pResourceRequirements->ControlTDQuota;
    OHCD_GlobalPool.BulkQuota = pResourceRequirements->BulkTDQuota;

    //
    //  At this point, the memory should be carved up.
    //  Figure out how many extra TD's we got out of it
    //  and apply it to the TD quotas.  
    //
    if(transferDescriptorsCount > pResourceRequirements->TDCount)
    {
       UCHAR extraTDs = transferDescriptorsCount - pResourceRequirements->TDCount;
       // If there is a bulk quota, apply half of the extra TD's to it.
       if(OHCD_GlobalPool.BulkQuota)
       {
           OHCD_GlobalPool.BulkQuota += extraTDs/2;
           extraTDs -= extraTDs/2;
       }
       // Apply the remaining extra TD's tp the control TD quota
       OHCD_GlobalPool.ControlQuota += extraTDs;
       pResourceRequirements->TDCount = transferDescriptorsCount;
    }
    
    USB_DBG_TRACE_PRINT(("TDCount = %d.", pResourceRequirements->TDCount));
    USB_DBG_TRACE_PRINT(("ControlTDQuota = %d.", OHCD_GlobalPool.ControlQuota));
    USB_DBG_TRACE_PRINT(("BulkTDQuota = %d.", OHCD_GlobalPool.BulkQuota));
    OHCD_GlobalPool.ControlQuotaRemaining = OHCD_GlobalPool.ControlQuota;
    OHCD_GlobalPool.BulkQuotaRemaining = OHCD_GlobalPool.BulkQuota;

    USB_DBG_EXIT_PRINT(("Exiting OHCD_TDPoolInit."));
}

#ifdef SILVER

ULONG
FASTCALL
OHCD_fPoolFindLostDoneHead(
    POHCD_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
        Compaq's original OpenHCI design (code named Hydra) had a serious bug
    where it would sometimes lose the done head.  This flaw was subsequently
    propogated to a number of chips based off that design.  nVidia claims that
    this bug was in the original MCPX design for xbox, but that it was fixed
    even before the first silicon.  In the meantime, we need to support it on
    the pre-DVT development kits using the Opti Chipset, some of which seem
    to suffer from the flaw.

        The code walks the TD pool and figures out which one is the head
    of our missing done list.  The implementation is taken from the Windows 2000
    code base.  However, this code base has one little catch.  A single global
    pool is used for both host controllers  (The first version of MCPX for XBox
    has two controllers.  In fact, launch titles will only use one, but we need
    to support two for the development kits - even after going to DVT - and in 
    the future we may decide to support the second host controller for shipping
    games - who knows).  The solution is to stamp the TD's with the host controller
    number, and erase the stamp when freeing the TD's (see above).  This is
    equivalent to the InUse flag in the Win2k implementation, except we have
    more than one bit of actual information in it.

    BUGBUG: WARNING!!!: THIS CODE FAILS AT THIS TIME IF THE LOST LIST CONTAINS ANY
    ISOCHRONOUS TDS, AS THESE TDS ARE NOT IN THE POOL!!!  (This was entered as 
    bug #4463.  The bug was resolved as "won't fix", since this code does not execute
    on MCPX, the bug is extremely rare and it is not critical to support isoch on the
    pre-DVT boxes.)

    The algorithm for searching is as follows:

    1) Find the tails of the lists.  There are two lists: HcDoneHead points to the
    head of a private list that the HC is building (the hardware presumably doesn't
    lose this one) and Hcca.DoneHead (the one that is lost).  The tail TD of both of
    these lists look the same: the NextTD member is NULL, and the HostControllerNumber
    is the same as the HostControllerNumber in the DeviceExtension.  We saw to both
    of these conditions in OHCD_PoolFreeTD by initializing these 0xFFFFFFFF and 0xFF,
    and by setting HostControllerNumber in OHCD_PoolAllocateTD.  So NextTD might get
    changed to a valid pointer (but not NULL), when an URB is programmed, but only
    the HostController changes NexTD to NULL.

    2) a snap shot of HcDoneHead is taken.

    3) After finding the tails, the lists are built up by repeatedly walking the pool
    looking for TD's that point to the heads of the two lists.  If one is found it
    is the new head.

    4) Each time a new head is found (including before the first iteration),
    it is compared to the snap shot of HcDoneHead taken in step 2).  If it
    matches HcDoneHead, we can throw away that list and just keep building the
    other list, which must be the lost one.

    5) The first time through the whole pool that we find no changes, we can
    be sure that we got the whole missing list.
    
--*/
{
    UCHAR HostControllerNumber = (UCHAR)DeviceExtension->HostControllerNumber;
    POHCD_TRANSFER_DESCRIPTOR   Td;
    ULONG                       TdList1 = 0;
    ULONG                       TdList1Length = 0;
    ULONG                       TdList2 = 0;
    ULONG                       TdList2Length = 0;
    ULONG                       HcDoneHead = 0;
    BOOLEAN                     updated;

    USB_DBG_WARN_PRINT(("Lost DoneHead %d time(s).", ++OHCD_GlobalPool.LostDoneHeadCount));

    //
    // Scan the TD pool looking for TDs with a NULL NextTD pointer.
    // A TD should only have NULL NextTD pointer if it is the tail of
    // a done TD list.  There might be two such lists:  the list of TDs
    // that were completed the last time the HC should have updated the
    // HCCA->HccaDoneHead, and the list of TDs that have completed since
    // then.
    //

    for (Td = OHCD_GlobalPool.FirstTD; Td <= OHCD_GlobalPool.LastTD; Td++)
    {
        if (Td->HostControllerNumber == HostControllerNumber)
        {
            if (0 == Td->HcTransferDescriptor.NextTD)
            {
                // This TD has a NULL NextTD pointer.  Save it as the
                // tail of either TdList1 or TdList2.
                //
                if (0 == TdList1)
                {
                    TdList1 = Td->PhysicalAddress;
                    TdList1Length++;
                }
                else
                {
                    // We expect to find at most two TDs with NULL
                    // NextTD pointers.
                    //
                    ASSERT(0 == TdList2);

                    TdList2 = Td->PhysicalAddress;
                    TdList2Length++;
                }
            }
        }
    }


    if (0 == TdList1)
    {
        USB_DBG_WARN_PRINT(("Lost DoneHead not found."));
        return 0;
    }

    if (TdList2 != 0)
    {
        // There are two lists of completed TDs.  One list should be
        // pointed to by HCCA->HccaDoneHead, and the other list should be
        // pointed to by HC->HcDoneHead.  Read HC->HcDoneHead so we can
        // determine which list is pointed to (or should have been pointed
        // to) by HCCA->HccaDoneHead and which list is pointed to by
        // HC->HcDoneHead.
        //
        HcDoneHead = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcDoneHead);

        // If HC->HcDoneHead is NULL, then something is does not match our
        // expectations.
        //
        ASSERT(HcDoneHead != 0);
    }

    do
    {
        updated = FALSE;

        if (HcDoneHead)
        {
            if (HcDoneHead == TdList1)
            {
                // TdList1 is pointed to by HC->HcDoneHead.  Toss TdList1
                // and keep TdList2
                //
                TdList1 = TdList2;
                TdList1Length = TdList2Length;
                TdList2 = 0;
            }
            else if (HcDoneHead == TdList2)
            {
                // TdList2 is pointed to by HC->HcDoneHead.  Toss TdList2
                // and keep TdList1
                //
                TdList2 = 0;
            }
        }

        //
        // Scan the TD pool looking for TDs with NextTD pointers that
        // point to the head of either TdList1 or TdList2.  If such a TD
        // is found, it becomes the new head of the appropriate list, and
        // loop around at least one more time.  If no such TD is found, then
        // the current heads of the lists must be the true heads and we can
        // quit looping.
        //

        for (Td = OHCD_GlobalPool.FirstTD; Td <= OHCD_GlobalPool.LastTD; Td++)
        {
            if(
                (Td->HostControllerNumber == HostControllerNumber) &&
                (Td->HcTransferDescriptor.NextTD != 0)
            )
            {
               if (Td->HcTransferDescriptor.NextTD == TdList1)
               {
                    TdList1 = Td->PhysicalAddress;
                    TdList1Length++;
                    updated = TRUE;
               }
               else if (Td->HcTransferDescriptor.NextTD == TdList2)
               {
                    TdList2 = Td->PhysicalAddress;
                    TdList2Length++;
                    updated = TRUE;
                }
            }
        }
    } while (updated);

    //For logging purposes keep the minimum list length
    if(TdList1Length < OHCD_GlobalPool.LostMinimumDoneListLength)
    {
        OHCD_GlobalPool.LostMinimumDoneListLength = TdList1Length;
        USB_DBG_WARN_PRINT(("New LostMinimumDoneListLength %d .", OHCD_GlobalPool.LostMinimumDoneListLength));
    }

    ASSERT(TdList1 != 0);
    ASSERT(TdList2 == 0);

    return TdList1;
}

#endif //SILVER

/**
*** Another type of pool type workaround.  This workaround is for a broken a NV2A on the first
*** silicon revision.  It should be fixed on the next revision, but unfortunately we need a
*** workaround to get through the next several weeks.
***
*** All transfers need to be executed to\from uncached memory.  A big sweeping fix is to double
*** buffer all transfers.  This code manages that.
***
*** During initialization of the pool, OHCD_PoolCreateDoubleBufferPool is called.  It allocates
*** a pool and creates two free lists, one for large buffer and one for small buffers.
***
*** OHCD_PoolStartDoubleBufferTransfer is called whenever an URB is about to be programmed.
*** It pops a buffer off the correctfree list and assigns it to the URB.  On a write, it also copies
*** the data over.
***
*** OHCD_PoolEndDoubleBufferTransfer is called whenever a transfer completes.  On a read, it first
*** copies over the bytes read to the original buffer.  Then it places the double buffer back on
*** the correct free list and restores the original buffer in the URB.
***
*** It is asserted that POOL_DOUBLE_BUFFER_SIZE and POOL_DOUBLE_BUFFER_COUNT are large enough.
***
**/  

#ifdef DVTSNOOPBUG

//These values should allocate 3 4k pages.
#define POOL_LARGE_DOUBLE_BUFFER_SIZE  1024
#define POOL_LARGE_DOUBLE_BUFFER_COUNT 9
#define POOL_SMALL_DOUBLE_BUFFER_SIZE  64
#define POOL_SMALL_DOUBLE_BUFFER_COUNT 27

typedef struct _OHCD_POOL_UNCACHED_BUFFER *POHCD_POOL_UNCACHED_BUFFER;
typedef struct _OHCD_POOL_UNCACHED_BUFFER
{
  PVOID                         UserBuffer;
  union
  {
    POHCD_POOL_UNCACHED_BUFFER  *PoolHead;
    POHCD_POOL_UNCACHED_BUFFER  NextFree;
  };
  CHAR                          Buffer[0];
} OHCD_POOL_UNCACHED_BUFFER;

POHCD_POOL_UNCACHED_BUFFER OHCD_PoolSmallDoubleBufferFreeList = NULL;
POHCD_POOL_UNCACHED_BUFFER OHCD_PoolLargeDoubleBufferFreeList = NULL;

VOID OHCD_PoolCreateDoubleBufferPool()
{
    ULONG     poolSize;
    ULONG_PTR poolMemory;
    POHCD_POOL_UNCACHED_BUFFER bufferPtr;
    ULONG largeBufferSize = sizeof(OHCD_POOL_UNCACHED_BUFFER)+POOL_LARGE_DOUBLE_BUFFER_SIZE;
    ULONG smallBufferSize = sizeof(OHCD_POOL_UNCACHED_BUFFER)+POOL_SMALL_DOUBLE_BUFFER_SIZE;
    int i;

    //Allocate the memory
    poolSize = largeBufferSize*POOL_LARGE_DOUBLE_BUFFER_COUNT+
               smallBufferSize*POOL_SMALL_DOUBLE_BUFFER_COUNT;
    //round up to a full page
    if(poolSize%PAGE_SIZE) poolSize += (PAGE_SIZE-(poolSize%PAGE_SIZE));
    poolMemory = (ULONG_PTR)MmAllocateContiguousMemoryEx(
                                poolSize, 0, MAXULONG_PTR, 0, PAGE_READWRITE|PAGE_NOCACHE);    
    ASSERT(poolMemory);

    // Create the large buffer free list
    bufferPtr = (POHCD_POOL_UNCACHED_BUFFER)poolMemory;
    for(i=0; i < POOL_LARGE_DOUBLE_BUFFER_COUNT; i++)
    {
        bufferPtr->NextFree = OHCD_PoolLargeDoubleBufferFreeList;
        OHCD_PoolLargeDoubleBufferFreeList = bufferPtr;
        bufferPtr = (POHCD_POOL_UNCACHED_BUFFER)(((ULONG_PTR)bufferPtr)+largeBufferSize);
    }

    // Create the small buffer free list
    for(i=0; i < POOL_SMALL_DOUBLE_BUFFER_COUNT; i++)
    {
        bufferPtr->NextFree = OHCD_PoolSmallDoubleBufferFreeList;
        OHCD_PoolSmallDoubleBufferFreeList = bufferPtr;
        bufferPtr = (POHCD_POOL_UNCACHED_BUFFER)(((ULONG_PTR)bufferPtr)+smallBufferSize);
    }
}

VOID OHCD_PoolStartDoubleBufferTransfer(PURB Urb)
{
    POHCD_POOL_UNCACHED_BUFFER uncachedBuffer;
    ULONG                      transferLength = Urb->CommonTransfer.TransferBufferLength;
    
    ASSERT(0 != transferLength);
    ASSERT(0 != Urb->CommonTransfer.TransferBuffer);
    ASSERT(POOL_LARGE_DOUBLE_BUFFER_SIZE >= transferLength);

    //Grab a buffer from a free list
    if(transferLength > POOL_SMALL_DOUBLE_BUFFER_SIZE)
    {
        uncachedBuffer = OHCD_PoolLargeDoubleBufferFreeList;
        ASSERT(uncachedBuffer); //increase POOL_DOUBLE_BUFFER_COUNT if this is hit
        OHCD_PoolLargeDoubleBufferFreeList = uncachedBuffer->NextFree;
        uncachedBuffer->PoolHead = &OHCD_PoolLargeDoubleBufferFreeList;
    } else
    {
        uncachedBuffer = OHCD_PoolSmallDoubleBufferFreeList;
        ASSERT(uncachedBuffer); //increase POOL_DOUBLE_BUFFER_COUNT if this is hit
        OHCD_PoolSmallDoubleBufferFreeList = uncachedBuffer->NextFree;
        uncachedBuffer->PoolHead = &OHCD_PoolSmallDoubleBufferFreeList;
    }
    
    //swap the original buffer for the uncached buffer.
    uncachedBuffer->UserBuffer = Urb->CommonTransfer.TransferBuffer;
    Urb->CommonTransfer.TransferBuffer = uncachedBuffer->Buffer;

    //if it is a write copy the data to the uncached buffer
    if(USB_TRANSFER_DIRECTION_OUT == Urb->CommonTransfer.TransferDirection)
    {
       RtlCopyMemory(uncachedBuffer->Buffer, uncachedBuffer->UserBuffer, transferLength);
    }

}

VOID OHCD_PoolEndDoubleBufferTransfer(PURB Urb)
{
    
    POHCD_POOL_UNCACHED_BUFFER uncachedBuffer = CONTAINING_RECORD(
                                                  Urb->CommonTransfer.TransferBuffer,
                                                  OHCD_POOL_UNCACHED_BUFFER,
                                                  Buffer
                                                  );
    POHCD_POOL_UNCACHED_BUFFER *poolHead = uncachedBuffer->PoolHead;

    //if it was a read, copy the data to the user buffer
    if(USB_TRANSFER_DIRECTION_IN == Urb->CommonTransfer.TransferDirection)
    {
        ULONG transferLength = Urb->CommonTransfer.TransferBufferLength;
        ASSERT(uncachedBuffer);
        ASSERT(uncachedBuffer->UserBuffer);
        ASSERT(transferLength <= Urb->CommonTransfer.Hca.HcdOriginalLength);
        if(transferLength)
        {
            //
            //  The wierdness that follows is to due to the fact that one may
            //  DMA into PAGE_READONLY memory, but not write to under CPU control.
            //  The workaround here is to detect PAGE_READONLY memory, switch it
            //  to PAGE_READWRITE, perform the copy and then switch it back.
            //
            PVOID userBuffer = uncachedBuffer->UserBuffer;
            ULONG oldProtect = MmQueryAddressProtect(userBuffer);
            if(PAGE_READONLY == ((PAGE_READONLY | PAGE_READWRITE)&oldProtect))
            {
                ULONG newProtect = oldProtect;
                newProtect &= ~PAGE_READONLY; //clear readonly
                newProtect |= PAGE_READWRITE; //set readwrite
	            MmSetAddressProtect(userBuffer, transferLength, newProtect);
	            RtlCopyMemory(
                 userBuffer,
                 uncachedBuffer->Buffer,
                 transferLength
                 );   
	            MmSetAddressProtect(userBuffer, transferLength, oldProtect);
            } else
            {
                RtlCopyMemory(
                 userBuffer,
                 uncachedBuffer->Buffer,
                 transferLength
                 );   
            }
        }
    }

    //swap the original buffer for the uncached buffer.
    Urb->CommonTransfer.TransferBuffer = uncachedBuffer->UserBuffer;

    //return the uncached buffer to the free list
    uncachedBuffer->NextFree = *poolHead;
    *poolHead = uncachedBuffer;
}

#endif //DVTSNOOPBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\ohcd.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    ohcd.h

Abstract:

    Structures used by the OpenHCI hardware dependent driver.
    These are constructs specific to this driver implementation.
    Standard Structures defined by Specification are in ohci.h
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-14-00 created by Mitchell Dernis (mitchd)

--*/
#ifndef __OCHD_H__
#define __OCHD_H__

//
//  Pull in the hardware spec stuff
//
#include "ohci.h"

//
//  forward declaration of pointer types, easy access later.
//
typedef struct _OHCD_TRANSFER_DESCRIPTOR        *POHCD_TRANSFER_DESCRIPTOR;
typedef struct _OHCD_SETUP_BUFFER               *POHCD_SETUP_BUFFER;
typedef struct _OHCD_ENDPOINT                   *POHCD_ENDPOINT;
typedef struct _OHCD_POOL                       *POHCD_POOL;
typedef struct _OHCD_INTERRUPT_SCHEDULE_NODE    *POHCD_INTERRUPT_SCHEDULE_NODE;
typedef struct _OHCD_ENDPOINT_SCHEDULE          *POHCD_ENDPOINT_SCHEDULE;
typedef struct _OHCD_DEVICE_EXTENSION           *POHCD_DEVICE_EXTENSION;


//
//  READ_REGISTER_ULONG and WRITE_REGISTER_ULONG are no longer
//  support in the Xbox Kernel.  Registers must be mapped to 
//  noncached memory.  Define macros here that simply do
//  a C assignement.
//
#define WRITE_REGISTER_ULONG(preg,value)  (*((volatile ULONG *)(preg))=value)
#define READ_REGISTER_ULONG(preg)  (*((volatile ULONG *)(preg)))

//
// struct OHCD_TRANSFER_DESCRIPTOR
//
//  This is the transfer descriptor as seen by the OHCD driver.
//  It is padded with 16 bytes of driver related fields.
//  Followed by the OHCI defined structure.
//
typedef struct _OHCD_TRANSFER_DESCRIPTOR
{
    //
    //  OHCI defined structure
    //
    OHCI_TRANSFER_DESCRIPTOR    HcTransferDescriptor;

    //
    //  16 bytes of Extra driver related fields
    //
    ULONG                       PhysicalAddress;        //Physical address of this descriptor
    union{
    POHCD_TRANSFER_DESCRIPTOR   NextFree;               //Used when the block is on the free list.
    POHCD_ENDPOINT              Endpoint;               //Endpoint which executed this transfer
    };
    PURB                        Urb;                    //Urb we are connected to
    UCHAR                       Flags;                  //Various flags
    UCHAR                       Bytes;                  //Various flags
    UCHAR                       Type;                   //Type of TD
    UCHAR                       HostControllerNumber;   //0xFF when not in use.
} OHCD_TRANSFER_DESCRIPTOR;

#define OHCD_TD_FLAG_CANCEL_PENDING 0x00000001  //TD has been marked for cancel
#define OHCD_TD_FLAG_LAST_TD        0x00000002  //Last TD of an URB

#define OHCD_TD_TYPE_DATA           0   //Setup TD of control transfer
#define OHCD_TD_TYPE_SETUP          1   //Setup TD of control transfer
#define OHCD_TD_TYPE_STATUS         2   //Status TD of control transfer
#define OHCD_TD_TYPE_DUMMY          3   //Dummy TD of control transfer


//
//  Flags used for the HcdUrbFlags found in the HCD area
//  of asynchronous transfer URBS.  These flags are used
//  for tracking the state of an URB so that it can be
//  cancelled.
//
#define OHCD_URB_FLAG_CANCELED      0x0001
#define OHCD_URB_FLAG_QUEUED        0x0002
#define OHCD_URB_FLAG_PROGRAMMED    0x0004
#define OHCD_URB_FLAG_COMPLETED     0x0008
//  Flags for isoch use are defined in isoch.h
//  This mask just claims the bits.
#define OHCD_URB_FLAG_ISOCH_USE     0x0F00


//
// struct OHCD_SETUP_STATUS_BUFFER
//
//  This structure is used for control transfers
//  to hold the setup packet data.  We define it as a type of
//  descriptor block so that we can leverage
//  the same code used for EDs and TDs
//  
typedef struct _OHCD_SETUP_BUFFER
{
    UCHAR                   Setup[8];       //Holds the data for a setup packet
    ULONG                   Pad1[2];        //Padding to keep the structure the correct size
                                            
    //
    //  Standard driver dependent part of block
    //
    ULONG                   PhysicalAddress;        //Physical address of this block
    ULONG                   Pad2[3];                //Pad to 32 bytes
} OHCD_SETUP_BUFFER;

//
//  Interrupt Node - see schedule.c for overview
//
typedef struct _OHCD_INTERRUPT_SCHEDULE_NODE
{
    BOOLEAN         RegisterHead;
    UCHAR           Pad;
    USHORT          Bandwidth;
    USHORT          BandwidthChildren;
    USHORT          BandwidthParents;
    POHCD_ENDPOINT  EndpointHead;
    POHCD_ENDPOINT  EndpointTail;
} OHCD_INTERRUPT_SCHEDULE_NODE;


//
//  Endpoint schedule - see schedule.c for overview
//
typedef struct _OHCD_ENDPOINT_SCHEDULE
{
    OHCD_INTERRUPT_SCHEDULE_NODE InterruptSchedule[64];
    POHCD_ENDPOINT               ControlHead;
    POHCD_ENDPOINT               BulkHead;
    USHORT                       BandwidthPeriodic;
    USHORT                       BandwidthTotal;                         
} OHCD_ENDPOINT_SCHEDULE;


//
//  Endpoint.   Due to the first member this structure must start on a 16-byte boundary.
//
typedef struct _OHCD_ENDPOINT
{
    //
    //  OHCI mandated portion of endpoint.  This structure
    //  must start on a paragraph(16-byte) boundary.
    //
    OHCI_ENDPOINT_DESCRIPTOR    HcEndpointDescriptor;
    //
    //  Fields for managing the schedule (especially for interrupt)
    //
    UCHAR                       Flags;                  //Endpoint flags
    UCHAR                       EndpointType;           //Type of endpoint
    UCHAR                       ScheduleIndex;          //Index in schedule - see definitions above
    UCHAR                       PollingInterval;        //Maximum polling interval (in ms)
    
    ULONG                       PhysicalAddress;        //Physical address of this structure.
    POHCD_ENDPOINT              Next;                   //Next endpoint in schedule

    ULONG                       PauseFrame;             //Used to verify that we have waited at least

    UCHAR                       PendingPauseCount;      //Number of reasons that we are paused.
    UCHAR                       Padding;                //Padding to keep up DWORD alignement.
    USHORT                      Bandwidth;              //Bandwidth required by this endpoint (interrupt and isoch only)
    
    USHORT                      TDInUseCount;           //Count of TDs in use.
    UCHAR                       QueuedUrbCount;         //Count of URBs that are queued waiting to be programmed.
    UCHAR                       ProgrammedUrbCount;     //Count URBs that are currently programmed.
    
    //
    //  Fields for managing URBs and keeping track of transfers
    //
    PURB                        PendingUrbHeadP;
    PURB                        PendingUrbTailP;
    
} OHCD_ENDPOINT;


#define OHCD_ENDPOINT_FLAG_CLOSING      0x10        //Flag used to indicate that endpoint is being
                                                    //closed, block cancels when endpoint is closing
#define OHCD_ENDPOINT_FLAG_PAUSING      0x20        //Flag used so that we don't try
                                                    //to pause the endpoint twice.
#define OHCD_ENDPOINT_FLAG_DELAY_PAUSE  0x40        //Indicates that the endpoint should not be considered
                                                    //paused until the next interrupt, set by the pause
                                                    //routine if a DPC was already queued.

typedef struct _OHCD_ROOT_HUB_OBJECT
{
    UCHAR                   NumberOfPorts;              //Number of ports present on the root hub.
    UCHAR                   DeviceDetectedBitmap;       //Bitmap of ports which have a detected device
    LARGE_INTEGER           PowerOnToGoodTime;          //PowerOnToGoodTime in relative 100ns intervals
    PFNHCD_RESET_COMPLETE   ResetComplete;              //Completion Routine.
    PVOID                   ResetContext;               //Completion Context.
    KTIMER                  ResetTimeoutTimer;          //Timer in case reset times out.
    KDPC                    ResetTimeoutDPC;            //DPC to be called if reset time-out occurs.
} OHCD_ROOT_HUB_OBJECT, *POHCD_ROOT_HUB_OBJECT;

VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdDeviceExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    );


typedef struct _OHCD_DEVICE_EXTENSION
{
    
    POHCI_OPERATIONAL_REGISTERS OperationalRegisters;       //Port address of operational registers
    ULONG                       OperationalRegistersLength; //May vary depending on downstream port count
    POHCI_HCCA                  HCCA;                       //HCD accessable pointer to HCCA
    OHCD_ENDPOINT_SCHEDULE      Schedule;                   //Everything we need to know about the schedule
    ULONG                       FrameHighPart;              //The high part of a 32-bit frame counter.
                                                            //The hardware only keeps 16 bits.
    PURB                        ControlUrbHeadP;            //Head of URBs for control transfers
    PURB                        ControlUrbTailP;            //Tail of URBs for control transfers
    PURB                        BulkUrbHeadP;               //Head of URBs for bulk transfers
    PURB                        BulkUrbTailP;               //Tail of URBs for bulk transfers
    PURB                        PendingCancels;             //URBs that need to be canceled.
    PURB                        PendingAborts;              //URBs that need to be aborted.
    PURB                        PendingCloses;              //URBs representing pending closes.
    struct
    {  /* A context structure between Isr and Dpc */
      ULONG InterruptsSignaled;     //Bit field of interrupt conditions signaled
      ULONG Frame;                  //The frame number when the interrupt occured
    } IsrDpc_Context;
    KDPC                        IsrDpc;                     //DPC for the ISR
    ULONG                       HostControllerNumber;       //Host Controller Number - really only a byte
    OHCD_ROOT_HUB_OBJECT        RootHubObject;              //Everything the root hub needs to know
    HAL_SHUTDOWN_REGISTRATION   ShutdownRegistration;
} OHCD_DEVICE_EXTENSION;

//
//  WorkItem Payload for Hotplug items.
//
typedef struct _OHCD_PORT_INFO
{
    USHORT                  PortsConnectionChanged;     //Bitfield of ports whose connection status needs updating
    USHORT                  PortsConnected;             //Bitfield of ports that now show connected status
} OHCD_PORT_INFO, *POHCD_PORT_INFO;


//---------------------------------------------------------------------------------------------------------------
// Choose max controller based on the number of controllers
//---------------------------------------------------------------------------------------------------------------
#define HCD_MAX_HOST_CONTROLLERS 1
#if (USB_HOST_CONTROLLER_CONFIGURATION!=USB_SINGLE_HOST_CONTROLLER)
#undef  HCD_MAX_HOST_CONTROLLERS
#define HCD_MAX_HOST_CONTROLLERS 2
#endif

//------------------------------------------------------
//  Pull in Isochronous Support (or stubs)
//------------------------------------------------------
#include "isoch.h"

//------------------------------------------------------
//  Implemented in OHCD.C
//------------------------------------------------------
VOID
FASTCALL
OHCD_fPauseEndpoint(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT  endpoint
    );
//--------------------------------------------------------
// Implemented in Schedule.c
//--------------------------------------------------------
VOID
FASTCALL
OHCD_ScheduleInitialize(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

USBD_STATUS
FASTCALL
OHCD_ScheduleAddEndpointPeriodic(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointPeriodic(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

VOID
FASTCALL
OHCD_ScheduleAddEndpointControlOrBulk(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointControlOrBulk(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

//------------------------------------------------------------
// Implemented in Isr.c
//------------------------------------------------------------

BOOLEAN
OHCD_InterruptService( 
    IN PKINTERRUPT Interrupt, 
    IN PVOID ServiceContext 
    );

VOID
OHCD_IsrDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    );

ULONG
FASTCALL
OHCD_Get32BitFrameNumber(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

//------------------------------------------------------------
// Implemented in transfer.c
//------------------------------------------------------------
USBD_STATUS
FASTCALL
OHCD_fQueueTransferRequest(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    PURB                    HcdUrb
    );

VOID
FASTCALL
OHCD_fProgramInterruptTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    POHCD_ENDPOINT          Endpoint
    );

VOID
FASTCALL
OHCD_fProgramBulkTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    );

VOID
FASTCALL
OHCD_fProgramControlTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    );

//------------------------------------------------------------
// Implemented in roothub.c
//------------------------------------------------------------
VOID
FASTCALL
OHCD_RootHubInitialize(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    );
VOID
FASTCALL
OHCD_RootHubProcessInterrupt(
    POHCD_DEVICE_EXTENSION      DeviceExtension
);

VOID
FASTCALL
OHCD_RootHubProcessHotPlug(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_PORT_INFO          PortInfo
);

//------------------------------------------------------
//  Implemented in pool.c
//------------------------------------------------------

//
//  struct OHCD_POOL - Global structure pool for
//                     all DMA managed structures
//
typedef struct _OHCD_POOL
{
    
    ULONG                       VirtualToPhysical;
    POHCI_HCCA                  Hcca[HCD_MAX_HOST_CONTROLLERS];
    POHCD_ENDPOINT              FreeEndpoints;
    POHCD_TRANSFER_DESCRIPTOR   FreeTDs;
    POHCD_TRANSFER_DESCRIPTOR   FirstTD;                   //First TD in pool
    POHCD_TRANSFER_DESCRIPTOR   LastTD;                    //Last TD in pool
    ULONG                       LostDoneHeadCount;         //Number of times the DoneHead was lost.
    ULONG                       LostMinimumDoneListLength; //minimum length of the DoneHead when
                                                           //it was lost
    USHORT                      ControlQuota;
    USHORT                      ControlQuotaRemaining;
    USHORT                      BulkQuota;
    USHORT                      BulkQuotaRemaining;
    OHCD_ISOCH_POOL
} OHCD_POOL;
extern OHCD_POOL OHCD_GlobalPool;
#define OHCD_INTERRUPT_TD_QUOTA  3 //Per endpoint quota

VOID
FASTCALL
OHCD_fPoolInit(
    IN PHCD_RESOURCE_REQUIREMENTS pResourceRequirements
    );

#ifdef SILVER
ULONG
FASTCALL
OHCD_fPoolFindLostDoneHead(
    POHCD_DEVICE_EXTENSION DeviceExtension
    );
#endif //SILVER

__inline
POHCI_HCCA
OHCD_PoolGetHcca(
    IN UCHAR HostControllerNumber
    )
{
    ASSERT(HCD_MAX_HOST_CONTROLLERS > HostControllerNumber);
    return OHCD_GlobalPool.Hcca[HostControllerNumber];
}

__inline
POHCD_ENDPOINT
OHCD_PoolAllocateEndpoint()
{
    POHCD_ENDPOINT retVal;
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    retVal = OHCD_GlobalPool.FreeEndpoints;
    if(retVal)
    {
        OHCD_GlobalPool.FreeEndpoints = retVal->Next;
    }
    ASSERT(retVal);
    return retVal;
}

__inline
VOID
OHCD_PoolFreeEndpoint(POHCD_ENDPOINT Endpoint)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    Endpoint->Next = OHCD_GlobalPool.FreeEndpoints;
    OHCD_GlobalPool.FreeEndpoints = Endpoint;
}


__inline
POHCD_TRANSFER_DESCRIPTOR
OHCD_PoolAllocateTD(UCHAR HostControllerNumber)
{
    POHCD_TRANSFER_DESCRIPTOR retVal;
    retVal = OHCD_GlobalPool.FreeTDs;
    if(retVal)
    {
        OHCD_GlobalPool.FreeTDs = retVal->NextFree;
    }
    ASSERT(retVal);
    retVal->HostControllerNumber = HostControllerNumber;
    OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(retVal);
    return retVal;
}

__inline
VOID
OHCD_PoolFreeTD(
    IN  POHCD_TRANSFER_DESCRIPTOR   TransferDescriptor
    )
{
    // We want the hardware NextTD to be an invalid
    // non-NULL address.  This aids in searching for
    // lost TD lists.
    TransferDescriptor->HcTransferDescriptor.NextTD = 0xFFFFFFFF;
    TransferDescriptor->HostControllerNumber  = 0xFF;
    TransferDescriptor->NextFree = OHCD_GlobalPool.FreeTDs;
    OHCD_GlobalPool.FreeTDs = TransferDescriptor;
}

__inline
POHCD_TRANSFER_DESCRIPTOR
OHCD_PoolTDFromPhysicalAddress(
    IN  ULONG           PhysicalAddress
    )
{
    return (POHCD_TRANSFER_DESCRIPTOR)(OHCD_GlobalPool.VirtualToPhysical + PhysicalAddress);
}

__inline
ULONG
OHCD_PoolGetPhysicalAddress(PVOID VirtualAddress)
{
    return ((ULONG)VirtualAddress) - OHCD_GlobalPool.VirtualToPhysical;
}

__inline
USHORT
OHCD_PoolGetControlQuota()
{ return OHCD_GlobalPool.ControlQuota; }

__inline
BOOLEAN
OHCD_PoolDebitControlTDQuota(
    IN USHORT Count
    )
{
    return
        (OHCD_GlobalPool.ControlQuotaRemaining < Count) ?
            FALSE :
            (OHCD_GlobalPool.ControlQuotaRemaining -= Count, TRUE);
}

__inline
VOID
OHCD_PoolCreditControlTDQuota(
    IN USHORT Count
    )
{
    OHCD_GlobalPool.ControlQuotaRemaining += Count;
}

__inline
USHORT
OHCD_PoolGetBulkQuota()
{ return OHCD_GlobalPool.BulkQuota; }

__inline
BOOLEAN
OHCD_PoolDebitBulkTDQuota(
    IN USHORT Count
    )
{
    return
        (OHCD_GlobalPool.BulkQuotaRemaining < Count) ?
            FALSE :
            (OHCD_GlobalPool.BulkQuotaRemaining -= Count, TRUE);
}

__inline
VOID
OHCD_PoolCreditBulkTDQuota(
    IN USHORT Count
    )
{
    OHCD_GlobalPool.BulkQuotaRemaining += Count;
}

#ifdef DVTSNOOPBUG
VOID OHCD_PoolCreateDoubleBufferPool();
VOID OHCD_PoolStartDoubleBufferTransfer(PURB Urb);
VOID OHCD_PoolEndDoubleBufferTransfer(PURB Urb);
#endif

//Isoch routines are conditionally compiled
#ifdef  OHCD_ISOCHRONOUS_SUPPORTED
__inline
ULONG_PTR
OHCD_IsochPoolAllocateEndpoint()
{
    ULONG_PTR retVal;
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    retVal = OHCD_GlobalPool.IsochFreeEndpoints;
    if(retVal)
    {
        OHCD_GlobalPool.IsochFreeEndpoints = *((PULONG_PTR)retVal);
    }
    ASSERT(retVal);
    return retVal;
}

__inline
VOID
OHCD_IsochPoolFreeEndpoint(ULONG_PTR IsochEndpoint)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    *((PULONG_PTR)IsochEndpoint) = OHCD_GlobalPool.IsochFreeEndpoints;
    OHCD_GlobalPool.IsochFreeEndpoints = IsochEndpoint;
}

__inline
ULONG OHCD_IsochPoolGetMaxBuffers()
{
    return OHCD_GlobalPool.IsochMaxBuffers;
}

#endif //OHCD_ISOCHRONOUS_SUPPORTED


#endif __OCHD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\roothub.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    RootHub.c

Abstract:
    
    This file implements the OpenHCI root hub support.  Rather than following the model
    of writing an emulation of a real hub that supports transfers, this module instead
    acts as a driver for the root-hub.  It detects and reports devices just as a hub driver
    would.  Since hub drivers do not in the XBOX world expose external interfaces, it
    is much simpler this way.

    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    02-10-00 created by Mitchell Dernis (mitchd)

--*/
//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


__inline UCHAR RootHubPortToPortNumber(UCHAR RootHubPort)
/*++
    Routine Description:
        The root hub internally uses ports 0 to 3.  However, this
        translates to ports 1 to 4 with a normal hub. 
--*/
{
    return RootHubPort+1;
}

__inline ULONG PortNumberToRootHubPort(ULONG PortNumber)
{
    return PortNumber-1;
}

//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


VOID
OHCD_RootHubResetDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    );

#pragma code_seg(".XPPCINIT")
VOID
FASTCALL
OHCD_RootHubInitialize(
    POHCD_DEVICE_EXTENSION      DeviceExtension
)
/*++

Routine Description:

    Reads basic info regarding the root-hub, and turns
    on the interrupts for the root-hub.

    1) Determine how many ports we have.
    2) Process initial connections.
    3) Turn on interrupts for hot-plug detection later

Arguments:

Return Value:
    
--*/               
{
    POHCI_OPERATIONAL_REGISTERS operationalRegisters = DeviceExtension->OperationalRegisters;
    POHCD_ROOT_HUB_OBJECT       rhObject = &DeviceExtension->RootHubObject;
#ifndef OHCD_XBOX_HARDWARE_ONLY
    HC_RH_DESCRIPTOR_A          rhDescriptorA;
    HC_RH_DESCRIPTOR_B          rhDescriptorB;
#endif //OHCD_XBOX_HARDWARE_ONLY    
    HC_RH_STATUS                rhStatus;
    HC_RH_PORT_STATUS           rhPortStatus;
    ULONG                       index;
    ULONG                       mask;
    OHCD_PORT_INFO              portInfo;
    KIRQL                       oldIrql;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_RootHubInitialize"));
    
    
    //
    //  Initialize the watchdog timer and related DPC,
    //  for catching failed resets.
    //
    KeInitializeTimer(&rhObject->ResetTimeoutTimer);
    KeInitializeDpc(
        &rhObject->ResetTimeoutDPC,
        OHCD_RootHubResetDpc,
        (PVOID)DeviceExtension
        );


#ifdef OHCD_XBOX_HARDWARE_ONLY
    #if (USB_HOST_CONTROLLER_CONFIGURATION==USB_SINGLE_HOST_CONTROLLER)
    rhObject->NumberOfPorts = 4;
    #else
    rhObject->NumberOfPorts = 2;
    #endif
    USB_DBG_TRACE_PRINT(("  NumberDownstreamPorts     : %d", (ULONG)rhObject->NumberOfPorts));
#else
    //
    //  Get Information on root-hub, store number of ports.
    //
    rhDescriptorA.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul);
    rhObject->NumberOfPorts = rhDescriptorA.NumberDownstreamPorts;
    if(rhDescriptorA.NoPowerSwitch)
    {
        USB_DBG_WARN_PRINT(("USB Card Doesn't support power switching!!"));
    } else
    {
    
        //
        //  Calculate the relative PowerOnToGoodTime in 100 ns.  The negative sign is
        //  so the KeDelayExecutionThread will treat it as a relative time.
        //
        rhObject->PowerOnToGoodTime.QuadPart = -rhDescriptorA.PowerOnToPowerGoodTime*2*10000;
    
        //
        //  Build changes to write back to descriptor A
        //
        if(!rhDescriptorA.PowerSwitchingMode || !rhDescriptorA.OverCurrentProtectionMode)
        {
            USB_DBG_TRACE_PRINT(("Switch to per-port power and overcurrent protection:"));
            rhDescriptorA.PowerSwitchingMode = 1;   //  Switch the PowerSwitchingMode to Per-port
            rhDescriptorA.OverCurrentProtectionMode = 1; // Per port overcurrent protection
            WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul, rhDescriptorA.ul);
        }

        //
        //  As a diagnostic make sure that our changes were accepted
        //  we only support per-port power.
        //
        #if DBG
        rhDescriptorA.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul);
        if(!rhDescriptorA.PowerSwitchingMode || !rhDescriptorA.OverCurrentProtectionMode)
        {
            USB_DBG_ERROR_PRINT(("Root Hub didn't accept ganged -> per-port changes.  Incompatible hardware!"));
        }
        #endif
    }    


#if DBG
    if(0xFF==rhDescriptorA.PowerOnToPowerGoodTime)
    {
        //
        //  In truth, there may be other cards that require this long delay.
        //  The Entrega with the CMD chip is just the one we are worried about.
        //
        USB_DBG_WARN_PRINT(("CMD USB CARD DETECTED(requires long power-on delay)!"));
    }
#endif 

    USB_DBG_TRACE_PRINT(("Root Hub's Descriptor A:"));
    USB_DBG_TRACE_PRINT(("  NumberDownstreamPorts     : %d", (ULONG)rhObject->NumberOfPorts));
    USB_DBG_TRACE_PRINT(("  NoPowerSwitching          : %s", rhDescriptorA.NoPowerSwitch ? "TRUE" : "FALSE"));
    USB_DBG_TRACE_PRINT(("  PowerSwitchingMode        : %s", rhDescriptorA.PowerSwitchingMode ? "Per-Port" : "Ganged"));
    USB_DBG_TRACE_PRINT(("  DeviceType                : %s", rhDescriptorA.DeviceType ? "Compound" : "Simple"));
    USB_DBG_TRACE_PRINT(("  OverCurrentProtectionMode : %s", rhDescriptorA.OverCurrentProtectionMode ? "Per-Port" : "Overall"));
    USB_DBG_TRACE_PRINT(("  NoOverCurrentProtection   : %s", rhDescriptorA.NoOverCurrentProtection ? "TRUE" : "FALSE"));
    USB_DBG_TRACE_PRINT(("  PowerOnToPowerGoodTime    : %d ms", (ULONG)rhDescriptorA.PowerOnToPowerGoodTime*2));
#endif //OHCD_XBOX_HARDWARE_ONLY   
    
    //
    //  Display info in Descriptor B
    //
#ifndef OHCD_XBOX_HARDWARE_ONLY
    rhDescriptorB.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul);
    if(!rhDescriptorA.NoPowerSwitch)
    {
        //
        //  Make sure the PortPowerControlMask is set so that every port is per-port power.
        //
        mask = (rhObject->NumberOfPorts << 2) - 2;
        if(mask != (rhDescriptorB.PortPowerControlMask & mask))
        {
            rhDescriptorB.PortPowerControlMask |= mask;
            WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul, rhDescriptorB.ul);
            //
            //  As a diagnostic read back the changes, and make sure that they took.
            //
            #if DBG
            rhDescriptorB.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul);
            if(mask != (rhDescriptorB.PortPowerControlMask & mask))
            {
                USB_DBG_ERROR_PRINT(("Root Hub didn't accept PortPowerControlMask changes.  Incompatible hardware!"));
            }
            #endif
        }

        #if DBG 
        USB_DBG_TRACE_PRINT(("Root Hub's Descriptor B:"));
        for(index = 1, mask = 2; index <= (int)rhObject->NumberOfPorts; index++, mask <<= 1)
        {
            USB_DBG_TRACE_PRINT(("  DeviceRemovable(%d)      : %s", index, 
                ((ULONG)rhDescriptorB.DeviceRemovable & mask)? "Not Removable" : "Removable" ));
            USB_DBG_TRACE_PRINT(("  PortPowerControlMask(%d) : %s", index, 
                ((ULONG)rhDescriptorB.PortPowerControlMask & mask)? "Per-port" : "Ganged" ));   
        }
        #endif

        //
        //  Power on ports
        //
        /*  Not necessary, everything is per-port.
        ASSERT(!rhDescriptorA.NoPowerSwitch); //We don't support cards that are always powered.
        rhStatus.HubStatus = HC_RH_STATUS_DeviceRemoteWakeupEnable; - we don't support remote wakeup.
        rhStatus.HubStatus = 0;
        rhStatus.HubStatusChange = HC_RH_STATUS_LocalPower;
        WRITE_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul, rhStatus.ul);
        */
    }
#endif //OHCD_XBOX_HARDWARE_ONLY
    //
    //  Get the hub status
    //
    rhStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul);
    USB_DBG_TRACE_PRINT(("Root Hub's Status:"));
    USB_DBG_TRACE_PRINT(("  LocalPowerStatus          : Not Readable"));
    USB_DBG_TRACE_PRINT(("  OverCurrentIndicator      : %s", 
                (rhStatus.HubStatus &  HC_RH_STATUS_OvercurrentIndicator )? "OverCurrent" : "OK"));
    USB_DBG_TRACE_PRINT(("  DeviceRemoteWakeupEnable  : %s",
                (rhStatus.HubStatus & HC_RH_STATUS_DeviceRemoteWakeupEnable) ? "ON" : "OFF"));
    //
    //  Clear the status change bits (so that we can get future notifications)
    //  You clear bits by writing a one to them.  Writing a one to the HubStatus
    //  actually changes settings which we don't want to.  So basically
    //  we clear the HubStatus back and write the status change bits back on themselves.
    //
    rhStatus.HubStatus = 0;
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul, rhStatus.ul);

#ifndef OHCD_XBOX_HARDWARE_ONLY    
    //
    //  Power on each port
    //
    if(!rhDescriptorA.NoPowerSwitch)
    {
        // 7 ms delay hack for some timing challenged cards
        LARGE_INTEGER   prePowerDelayHack;
        prePowerDelayHack.QuadPart = -7*10000;
        KeDelayExecutionThread(KernelMode, FALSE, &prePowerDelayHack);

        rhPortStatus.PortStatus = HC_RH_PORT_STATUS_SetPortPower;
        rhPortStatus.PortStatusChange = 0x0000;
        for(index=0; index < (int)rhObject->NumberOfPorts; index++)
        {
            WRITE_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul, rhPortStatus.ul);
        }
        //
        //  Wait the PowerOnToGoodTime
        //
        KeDelayExecutionThread(KernelMode, FALSE, &rhObject->PowerOnToGoodTime);
    }    
#endif //OHCD_XBOX_HARDWARE_ONLY

    //
    //  Retrieve the status of each port
    //
    RtlZeroMemory((PVOID)&portInfo, sizeof(OHCD_PORT_INFO));
    for(index=0, mask = 1; index < (int)rhObject->NumberOfPorts; index++, mask <<=1)
    {
        rhPortStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul);
    
        //
        //  Traceouts, so we can see what is happening
        //
        USB_DBG_TRACE_PRINT(("Status of Port %d:", index+1));
        USB_DBG_TRACE_PRINT(("  CurrentConnectStatus      : %s",  
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_CurrentConnectStatus) ? "Connected" : "Disconnected"));
        USB_DBG_TRACE_PRINT(("  PortEnableStatus          : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortEnableStatus) ? "Enabled" : "Disabled"));
        USB_DBG_TRACE_PRINT(("  PortSuspendStatus         : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortSuspendStatus) ? "Suspended" : "Not Suspended"));
        USB_DBG_TRACE_PRINT(("  PortOverCurrentIndicator  : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortOverCurrentIndicator) ? "OverCurrent" : "OK"));
        USB_DBG_TRACE_PRINT(("  PortResetStatus           : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortResetStatus) ? "Reset Signal Active" : "Reset Signal Not Active"));
        USB_DBG_TRACE_PRINT(("  PortPowerStatus           : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortPowerStatus) ? "Power On" : "Power Off"));
        USB_DBG_TRACE_PRINT(("  LowSpeedDeviceAttached    : %s\n",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_LowSpeedDeviceAttach) ? "LowSpeed" : "FullSpeed"));

        //
        //  We are looking just for connected status.
        //
        if(rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_CurrentConnectStatus)
        {
            portInfo.PortsConnected |= mask;
            portInfo.PortsConnectionChanged |= mask;
        }

        //
        //  Clear the status change bits
        //
        rhPortStatus.PortStatus = 0;
        WRITE_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul, rhPortStatus.ul);
    }

    //
    //  Start interrupt processing for root-hub.
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcInterruptEnable, HCINT_RootHubStatusChange);

    //
    //  Now we will call a common routine to process any devices we found.
    //  Since it is also called from the DPC for the ISR it expects to be 
    //  DISPATCH_LEVEL.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    OHCD_RootHubProcessHotPlug(DeviceExtension, &portInfo);
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_RootHubInitialize"));
}

#pragma code_seg(".XPPCODE")

VOID
FASTCALL
OHCD_RootHubProcessInterrupt(
    POHCD_DEVICE_EXTENSION      DeviceExtension
)
/*++

Routine Description:

    Process interrupts destined for the Root Hub.
    This routine is called LEVEL_DISPATCH from within
    the IsrDPC.
    
Arguments:

Return Value:
    
--*/          
{
    POHCI_OPERATIONAL_REGISTERS operationalRegisters = DeviceExtension->OperationalRegisters;
    HC_RH_STATUS                rhStatus;
    HC_RH_PORT_STATUS           rhPortStatus;
    ULONG                       index;
    ULONG                       mask;
    OHCD_PORT_INFO              portInfo;
    ULONG                       numPorts = DeviceExtension->RootHubObject.NumberOfPorts;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_RootHubProcessInterrupt"));

    //
    //  Check to see if we have an overcurrent on the hub.
    //  This is the only global (i.e. NOT per port) cause of a root hub interrupt.
    //
    rhStatus.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcRhPortStatus->ul);
    if(rhStatus.HubStatusChange & HC_RH_STATUS_OvercurrentIndicator)
    {
        USB_DBG_TRACE_PRINT(("The root-hub is indicating over-current!"));
    }
    //
    //  Now retrieve the status of each port
    //
    RtlZeroMemory((PVOID)&portInfo, sizeof(OHCD_PORT_INFO));
    for(index=0, mask = 1; index < numPorts; index++, mask <<=1)
    {
        rhPortStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul);
        //
        //  If reset status change
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_PortResetStatus)
        {
            
            PFNHCD_RESET_COMPLETE   CompleteProc = DeviceExtension->RootHubObject.ResetComplete;
            PVOID                   Context = DeviceExtension->RootHubObject.ResetContext;
            
            //
            //  If the complete proc has not been called (due to a timeout)
            //  then stop the watchdog and call it now.
            //
            if(CompleteProc)
            {
                
                //
                //  Stop the reset's watchdog timer
                //
                KeCancelTimer(&DeviceExtension->RootHubObject.ResetTimeoutTimer);
                USB_DBG_TRACE_PRINT(("ResetCompleted: Port = %d, Context = 0X%0.8x", index+1, Context));

                //
                //  Call the completion routine  (setting the status according to 
                //  low speed or not).
                //
                DeviceExtension->RootHubObject.ResetComplete = NULL;
                DeviceExtension->RootHubObject.ResetContext = 0;
                CompleteProc(
                    (rhPortStatus.PortStatus & HC_RH_PORT_STATUS_LowSpeedDeviceAttach) ? 
                    USBD_STATUS_LOWSPEED : USBD_STATUS_SUCCESS,
                    Context);
            }
        }

        //
        //  If the connect status changed, we need to process it.
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_CurrentConnectStatus)
        {
            //
            //  Set the connect change bit.
            //
            portInfo.PortsConnectionChanged |= mask;
            //
            //  If connected, set the connect bit.
            //
            if(rhPortStatus.PortStatus & HC_RH_PORT_STATUS_CurrentConnectStatus)
            {
                portInfo.PortsConnected |= mask;
            }
        }
        //
        //  Check for overcurrent indicators
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_PortOverCurrentIndicator)
        {
            //
            //  It appears that this can just be ignored, other things will happen (like the
            //  port being disabled) that we will deal with properly.
            //
            USB_DBG_WARN_PRINT(("Port %d of the root hub is indicating over-current!", index));
        }
        //
        //  Check for automatic disabling of a port
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_PortEnableStatus)
        {
            USB_DBG_TRACE_PRINT(("The root-hub disabled port %d!  Usually a remove. Usually it was removed.", index));
        }

        //
        //  Clear the status change bits, so we can get notifications of further changes
        //
        rhPortStatus.PortStatus = 0;
        WRITE_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul, rhPortStatus.ul);
    }

    //
    //  Notify USBD about hot-plug events.
    //
    OHCD_RootHubProcessHotPlug(DeviceExtension, &portInfo);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_RootHubProcessInterrupt"));
}


VOID
FASTCALL
OHCD_RootHubProcessHotPlug(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_PORT_INFO          PortInfo
)
/*++

Routine Description:

    Does the work of reporting connect and disconnect
    events to USBD and the higher driver layers.  It is
    called from two different contexts.

    1) Just a straight call from OHCD_RootHubInitialize
        to process the connected devices found initially.
    2) As a worker thread, from a work item queued by OHCD_RootProcessInterrupt
        which runs in the context of IsrDPC.

    This routine needs to operate at LEVEL_PASSIVE, because the higher level need to synchronously
    process each detected device, which may be time consuming.  The reason behind this is that a newly
    detected device reports at the default USB address (0).  Only one device reporting at address zero
    should be enabled at a time.  Once USBD sets the address, we can then move on to enabling the next
    device.

Arguments:

Return Value:
    
--*/          
{
    UCHAR portIndex = 0;
    UCHAR portMask = 1;
    USB_DBG_ENTRY_PRINT(("Entering OHCD_RootHubProcessHotPlug"));

    ASSERT_DISPATCH_LEVEL();

    //
    //  Keep walking through port indices as long as there is
    //  a change we haven't processed yet.
    //
    while(portIndex < DeviceExtension->RootHubObject.NumberOfPorts)
    {
        //
        //  If this port has change, notify USBD of the change.
        //
        if(PortInfo->PortsConnectionChanged&portMask)
        {
            //
            //  Handle new connect
            //
            if(PortInfo->PortsConnected&portMask)
            {
                //
                //  Check for rapid fire remove\add, in which
                //  case do a remove before the add.
                //
                if(DeviceExtension->RootHubObject.DeviceDetectedBitmap&portMask)
                {
                    USBD_DeviceDisconnected(
                        (PVOID)DeviceExtension,
                        RootHubPortToPortNumber(portIndex)
                        );
                    USB_DBG_WARN_PRINT(("Remove and Add in one interrupt."));
                } else
                {
                    DeviceExtension->RootHubObject.DeviceDetectedBitmap |= portMask; //record that this
                                                                                     //port has a device.
                }
                //
                //  Report the device to USBD.  That is all we must do.
                //  (USBD expects a base of 1 for port numbers)
                USBD_DeviceConnected( (PVOID)DeviceExtension, RootHubPortToPortNumber(portIndex));
            }
            else
            //
            //  Handle Disconnect
            //
            {
                //
                //  Check for rapid fire add\remove, only call device connected
                //  if we called device connected at some point.
                //
                if(DeviceExtension->RootHubObject.DeviceDetectedBitmap&portMask)
                {
                    //
                    //  Tell USBD, which will synchronously cleanup
                    //
                    //  (USBD expects a base of 1 for port numbers)
                    DeviceExtension->RootHubObject.DeviceDetectedBitmap &= ~portMask;
                    USBD_DeviceDisconnected(
                        (PVOID)DeviceExtension,
                        RootHubPortToPortNumber(portIndex)
                        );
                } else
                {
                    USB_DBG_TRACE_PRINT(("Add and Remove in one interrupt."));
                }
            }
        }
        //
        //  Move on to next port
        //
        portIndex++;
        portMask <<= 1;
    }
    
    USB_DBG_EXIT_PRINT(("Exiting OHCD_RootHubProcessHotPlug"));
}


VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdDeviceExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    )
/*++

Routine Description:

    Resets a port on the root hub.  Only one reset is allowed at a time.
    
Arguments:
    HcdDeviceExtension  - our device extension (must cast)
    PortNumber          - number of port to reset (0 based)
Return Value:
    
--*/
{
    POHCD_DEVICE_EXTENSION  deviceExtension = (POHCD_DEVICE_EXTENSION)HcdDeviceExtension;
    HC_RH_PORT_STATUS       rhPortStatus;
    LARGE_INTEGER           resetTimeOut;

    USB_DBG_TRACE_PRINT(("HCD_ResetRootHubPort: Port = %d, Context = 0X%0.8x", PortNumber, CompleteContext));
    //
    //  Convert port number to root hub port number
    //
    PortNumber=PortNumberToRootHubPort(PortNumber);

    //
    //  Validate Range
    //
    ASSERT(deviceExtension->RootHubObject.NumberOfPorts > PortNumber);
    
    //
    //  There should not be a reset currently pending.
    //
    ASSERT(NULL == deviceExtension->RootHubObject.ResetComplete);
    
    //
    //  Record the completion information.
    //
    deviceExtension->RootHubObject.ResetComplete = ResetCompleteProc;
    deviceExtension->RootHubObject.ResetContext = CompleteContext;
    
    //
    //  Reset the port
    //
    rhPortStatus.PortStatus = HC_RH_PORT_STATUS_SetPortReset;
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcRhPortStatus[PortNumber].ul,
        rhPortStatus.ul
        );

    //
    //  Set a watchdog timer.  Resets have been known to fail.
    //
    resetTimeOut.QuadPart = -10000 * 100; //allow 100 ms, it should take only 10 ms according to spec.
                                           //20 ms wasn't long enough for some cards.
    KeSetTimer(
        &deviceExtension->RootHubObject.ResetTimeoutTimer,
        resetTimeOut,
        &deviceExtension->RootHubObject.ResetTimeoutDPC
        );
}

VOID
HCD_DisableRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber
    )
{
    POHCD_DEVICE_EXTENSION deviceExtension = (POHCD_DEVICE_EXTENSION)HcdExtension;
    HC_RH_PORT_STATUS       rhPortStatus;
    //
    //  Convert port number to root hub port number
    //
    PortNumber=PortNumberToRootHubPort(PortNumber);
    //
    //  Validate Range
    //
    ASSERT(deviceExtension->RootHubObject.NumberOfPorts > PortNumber);
    //
    //  Disable the port
    //
    rhPortStatus.PortStatus = HC_RH_PORT_STATUS_ClearPortEnable;
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcRhPortStatus[PortNumber].ul,
        rhPortStatus.ul
        );
}


VOID
OHCD_RootHubResetDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    )
{
    POHCD_DEVICE_EXTENSION deviceExtension = (POHCD_DEVICE_EXTENSION) DeviceExtensionPtr;
    PFNHCD_RESET_COMPLETE   CompleteProc = deviceExtension->RootHubObject.ResetComplete;
    PVOID                   Context = deviceExtension->RootHubObject.ResetContext;

    if(CompleteProc)
    {
        //
        //  This is usually nothing, but a device that was removed during the reset.
        //
        //  It has been found in the past to be indicative of other serious problems, though.
        //  Like the host being locked up because of bad register values.
        //
        USB_DBG_WARN_PRINT(("A port reset timed out on the root hub!"));

        //
        //  Call the completion routine with the bad news,
        //  it is up to the caller to recover.
        //
        USB_DBG_WARN_PRINT(("Reset Timed Out: Context = 0X%0.8x",  Context));
        deviceExtension->RootHubObject.ResetComplete = NULL;
        deviceExtension->RootHubObject.ResetContext = NULL;
        CompleteProc(USBD_STATUS_REQUEST_FAILED, Context);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\transfer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    transfer.c

Abstract:
    
    Implementation of functions related to queueing and processing transfer.
    However, isochronous transfers support is not in this file, see isoch.c

    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-20-00 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
USHORT
FASTCALL
OHCD_fGetTDsRequired(
    PURB            Urb,
    POHCD_ENDPOINT  Endpoint
    );

USBD_STATUS
FASTCALL
OHCD_fQueueInterruptTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fQueueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fQueueControlTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

VOID
FASTCALL
OHCD_fProgramTransfer(
        POHCD_DEVICE_EXTENSION  DeviceExtension,
        POHCD_ENDPOINT          Endpoint,
        PURB                    Urb
    );

ULONG
FASTCALL
OHCD_fMapTransfer(
    IN OUT  PVOID   *CurrentVa,
    IN OUT  PULONG  BytesRemaining,
    OUT     PULONG  BytesMapped
    );

//----------------------------------------------------------------------------
// Implementation of function called from other modules:
//      OHCD_fQueueTransferRequest
//----------------------------------------------------------------------------
USBD_STATUS
FASTCALL
OHCD_fQueueTransferRequest(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    PURB                    Urb
    )
/*++

Routine Description:
    
    QueueTransferRequest is the first stage of processing an asynchronous
    transfer request.  Part of the TD conservation program requires
    different queueing depending on endpoint type.  In this routine,
    we:
        1) Calculate TDs required.
        2) Dispatch to proper endpoint type determined queue routine.

Arguments:
    
    DeviceExtension - Device extension for our OHCD instance.
    HcdUrb          - Transfer URB to queue.

Return Value:

    STATUS_SUCCESS.  Otherwise we will KeBugcheck before returning.

--*/
{
    POHCD_ENDPOINT              endpoint;
    USBD_STATUS                 status;
    KIRQL                       oldIrql;
            
    USB_DBG_ENTRY_PRINT(("Entering OHCD_fQueueTransferRequest"));

    //
    //  Get the endpoint.
    //
    endpoint = (POHCD_ENDPOINT)Urb->CommonTransfer.EndpointHandle;
        
    //
    //  Figure out how many TDs this transfer requires
    //
    Urb->CommonTransfer.Hca.HcdTDCount = OHCD_fGetTDsRequired(Urb, endpoint);
        
    //
    //  Synchronize access to queues
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Class driver should be smart enough not to submit transfers
    //  while an endpoint is being closed.
    //
    ASSERT(!(OHCD_ENDPOINT_FLAG_CLOSING&endpoint->Flags));

    //
    //  We assume that it going to get queue.  Since the various
    //  queue routines may actually get programmed before returning
    //  here, we want to increment before calling them.
    //  
    endpoint->QueuedUrbCount++;
    Urb->CommonTransfer.Hca.HcdUrbFlags = OHCD_URB_FLAG_QUEUED;
    Urb->CommonTransfer.Hca.HcdUrbLink = NULL;
            
    //
    //  Queue the URB.  Each type of endpoint has its own queue
    //
    switch(endpoint->EndpointType)
    {
        case USB_ENDPOINT_TYPE_INTERRUPT:
            ASSERT(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER==Urb->Header.Function);
            status = OHCD_fQueueInterruptTransfer(DeviceExtension, endpoint, Urb);
            break;
        case USB_ENDPOINT_TYPE_BULK:
            ASSERT(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER==Urb->Header.Function);
            status = OHCD_fQueueBulkTransfer(DeviceExtension, Urb);
            break;
        case USB_ENDPOINT_TYPE_CONTROL:
            ASSERT(URB_FUNCTION_CONTROL_TRANSFER==Urb->Header.Function);
            status = OHCD_fQueueControlTransfer(DeviceExtension, Urb);
            break;
        default:
            //ISOCH endpoint never expected here.
            USB_DBG_ERROR_PRINT(("Unrecognized endpoint type in OHCD_fQueueTransferRequest\nClass driver is probably at fault."));
            status = USBD_STATUS_REQUEST_FAILED;
    }

    //
    //  If it didn't actually get queued than, we want to decrease 
    //  queue count.
    //
    if(USBD_ERROR(status))
    {
        Urb->CommonTransfer.Hca.HcdUrbFlags = 0;
        endpoint->QueuedUrbCount--;
    }

    //
    //  Done with queues
    //
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_fQueueTransferRequest"));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fQueueInterruptTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint,
    IN PURB                     Urb
    )
{
    
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check that this transfer is a legal transfer
    //
    if( Urb->BulkOrInterruptTransfer.Hca.HcdTDCount > OHCD_INTERRUPT_TD_QUOTA)
    {
        return USBD_STATUS_TRANSFER_TOO_LONG;
    }
    
    //
    //  Add URB to endpoints pending queue
    //
    if(Endpoint->PendingUrbTailP)
    {
        Endpoint->PendingUrbTailP->CommonTransfer.Hca.HcdUrbLink = Urb;
    }else
    {
        Endpoint->PendingUrbHeadP = Urb;
    }
    Endpoint->PendingUrbTailP = Urb;

    //
    //  Try programming this transfer
    //
    OHCD_fProgramInterruptTransfer(DeviceExtension, Endpoint);

    return USBD_STATUS_PENDING;
}


VOID
FASTCALL
OHCD_fProgramInterruptTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    POHCD_ENDPOINT          Endpoint
    )   
/*++

Routine Description:
    
    This routine is called in two places:
        1) When a new URB is placed on the queue for endpoint.
        2) When an URB completes.
    
    Interrupt endpoints queue URBs on a per endpoint basis.  Each endpoint
    has a quota of OHCD_INTERRUPT_TD_QUOTA (aside from the dummy TD).
    This routine will program all pending URBs until OHCD_INTERRUPT_TD_QUOTA
    TDs are in use.

    If an URB is encountered that requires more than OHCD_INTERRUPT_TD_QUOTA
    it is failed immediately.

Arguments:

   Endpoint - Endpoint to process.

Return Value:

   None.

--*/
{
    PURB_BULK_OR_INTERRUPT_TRANSFER urb;
    
    USB_DBG_ENTRY_PRINT(("Entry OHCD_ProgramInterruptTransfer"));

    
    ASSERT_DISPATCH_LEVEL();

    //
    //  If there are URBs waiting
    //  try to program them.
    //
    while(Endpoint->PendingUrbHeadP)
    {
        urb = &Endpoint->PendingUrbHeadP->BulkOrInterruptTransfer;
        
        //
        //  If there are not enough TDs available than break from this loop.
        //
        if( (urb->Hca.HcdTDCount + Endpoint->TDInUseCount) > OHCD_INTERRUPT_TD_QUOTA)
        {
            break;
        }

        //*
        //* There are enough TDs to proceed to program this transfer.
        //*
        
        //
        //  Remove URB from queue
        //
        Endpoint->PendingUrbHeadP = urb->Hca.HcdUrbLink;
        if(NULL == Endpoint->PendingUrbHeadP) Endpoint->PendingUrbTailP = NULL;

        //
        //  Mark the TDs as in use
        //
        Endpoint->TDInUseCount += urb->Hca.HcdTDCount;
    
        //
        //  Delegate the actual programming process off
        //  to a routine common to all endpoint types.
        //
        OHCD_fProgramTransfer(DeviceExtension, Endpoint, (PURB)urb);
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramInterruptTransfer"));
}


USBD_STATUS
FASTCALL
OHCD_fQueueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check that this transfer is a legal transfer
    //
    if( Urb->BulkOrInterruptTransfer.Hca.HcdTDCount > OHCD_PoolGetBulkQuota())
    {
        return USBD_STATUS_TRANSFER_TOO_LONG;
    }

    //
    //  Add URB to endpoints pending queue (at the tail).
    //
    if(DeviceExtension->BulkUrbHeadP)
    {
        DeviceExtension->BulkUrbTailP->CommonTransfer.Hca.HcdUrbLink = Urb;
    }else
    {
        DeviceExtension->BulkUrbHeadP = Urb;
    }
    DeviceExtension->BulkUrbTailP = Urb;

    //
    //  Try programming this transfer
    //
    OHCD_fProgramBulkTransfer(DeviceExtension);

    return USBD_STATUS_PENDING;
}

VOID
FASTCALL
OHCD_fProgramBulkTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    )
{
    PURB_BULK_OR_INTERRUPT_TRANSFER urb;
        
    USB_DBG_ENTRY_PRINT(("Entry OHCD_ProgramBulkTransfer"));

    
    ASSERT_DISPATCH_LEVEL();

    //
    //  If there are URBs waiting
    //  try to program them.
    //
    while(DeviceExtension->BulkUrbHeadP)
    {
        urb = &DeviceExtension->BulkUrbHeadP->BulkOrInterruptTransfer;
        
        //
        //  Draw TDs from the Bulk Quota (this does nothing other than mark that
        //  we will allocate the TDs)
        if(!OHCD_PoolDebitBulkTDQuota(urb->Hca.HcdTDCount))
        {
            break;
        }

        //*
        //* There are enough TDs to proceed to program this transfer.
        //*
        
        //
        //  Remove URB from queue
        //
        DeviceExtension->BulkUrbHeadP = urb->Hca.HcdUrbLink;
        if(NULL == DeviceExtension->BulkUrbHeadP) DeviceExtension->BulkUrbTailP = NULL;

        //
        //  Delegate the actual programming process off
        //  to a routine common to all endpoint types.
        //
        OHCD_fProgramTransfer(DeviceExtension, (POHCD_ENDPOINT)urb->EndpointHandle, (PURB)urb);
    
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramBulkTransfer"));
}

USBD_STATUS
FASTCALL
OHCD_fQueueControlTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check that this transfer is a legal transfer
    //
    if( Urb->ControlTransfer.Hca.HcdTDCount > OHCD_PoolGetControlQuota())
    {
        return USBD_STATUS_TRANSFER_TOO_LONG;
    }

    //
    //  Add URB to endpoints pending queue (at the tail)
    //
    if(DeviceExtension->ControlUrbHeadP)
    {
        DeviceExtension->ControlUrbTailP->CommonTransfer.Hca.HcdUrbLink = Urb;
    }else
    {
        DeviceExtension->ControlUrbHeadP = Urb;
    }
    DeviceExtension->ControlUrbTailP = Urb;

    //
    //  Try programming this transfer
    //
    OHCD_fProgramControlTransfer(DeviceExtension);

    return USBD_STATUS_PENDING;
}

VOID
FASTCALL
OHCD_fProgramControlTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    )
{
    PURB_CONTROL_TRANSFER   urb;
        
    USB_DBG_ENTRY_PRINT(("Entry OHCD_ProgramControlTransfer"));

    
    ASSERT_DISPATCH_LEVEL();

    //
    //  If there are URBs waiting
    //  try to program them.
    //
    while(DeviceExtension->ControlUrbHeadP)
    {
        urb = &DeviceExtension->ControlUrbHeadP->ControlTransfer;
        
        //
        //  Draw TDs from the Bulk Quota (this does nothing other than mark that
        //  we will allocate the TDs)
        if(!OHCD_PoolDebitControlTDQuota(urb->Hca.HcdTDCount))
        {
            break;
        }

        //*
        //* There are enough TDs to proceed to program this transfer.
        //*
        
        //
        //  Remove URB from queue
        //
        DeviceExtension->ControlUrbHeadP = urb->Hca.HcdUrbLink;
        if(NULL == DeviceExtension->ControlUrbHeadP) DeviceExtension->ControlUrbTailP = NULL;

        //
        //  Delegate the actual programming process off
        //  to a routine common to all endpoint types.
        //
        OHCD_fProgramTransfer(DeviceExtension, (POHCD_ENDPOINT)urb->EndpointHandle, (PURB)urb);
    
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramControlTransfer"));
}

//----------------------------------------------------------------------------
// Implementation of locally declared utility functions:
//
//  OHCD_GetTDsRequired
//  OHCD_AdapterControl
//----------------------------------------------------------------------------


USHORT
FASTCALL
OHCD_fGetTDsRequired(
    PURB            Urb,
    POHCD_ENDPOINT  Endpoint
    )
/*++

Routine Description:

    Local utilitiy function to calculate number of TDs required
    to transmit the data.
Arguments:

    Urb - URB for which to calculate required number of TDs

Return Value:

   Number of TDs required.

--*/
{       
        //
        //  Initialize to zero.
        //
        USHORT  numTDsRequired = 0;
        USHORT  maxPacket = (USHORT)Endpoint->HcEndpointDescriptor.Control.MaximumPacketSize;
                
        //
        //  Zero length transfers should never happen, unless it is
        //  a command on a control pipe.
        //
        ASSERT(Urb->CommonTransfer.TransferBufferLength || (USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType));
        
        if(Urb->CommonTransfer.TransferBufferLength)
        {
            //
            //  How many TD's do we need.
            //
            numTDsRequired += (USHORT)(Urb->CommonTransfer.TransferBufferLength/maxPacket);
            //
            // If it wasn't evenly divisible we need to add one.
            //
            if(Urb->CommonTransfer.TransferBufferLength%maxPacket)
            {
                numTDsRequired++;
            }
        }
        //
        //  If it is a control endpoint, there is a setup packet
        //  and a status packet.  We need a TD for each, plus the
        //  setup and status data each take up 8 bytes. We just
        //  grab a descritpor block for this.  So we need three
        //  extra blocks.
        //
        if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
        {
            numTDsRequired += 3;
        }
        return numTDsRequired;
}

VOID
FASTCALL
OHCD_fProgramTransfer(
        POHCD_DEVICE_EXTENSION  DeviceExtension,
        POHCD_ENDPOINT          Endpoint,
        PURB                    Urb
    )
/*++

Routine Description:

    This routine performs the actual work for control, interrupt, and bulk
    endpoint.  For isochronous endpoints, this routine never gets called.

Algorithm Description:

    This routine takes the form of a loop within a loop.
    The outer loop calls IoMapTransfer, which will map from
    the start of the user buffer to the end of the page.
    However, the data that can be transmitted within a single
    packet is limited to MaxPacketSize(8,16,32, or 64) which 
    is device and endpoint dependent.

    The inner loop creates these TDs.  However, it is also
    possible for a single TD to cross a page boundary, so the
    loop take into account that the first TD of page may begin
    on a previous page.

    There are a couple of other little annoyances:
        1) If it is a control transfer, we need to
        generate a TD for the setup and status packets.
        2) At the end we make sure that the endpoint is in order
        and that all the flags are set correctly.

Arguments:  

    HcdUrb - URB for which to calculate required number of TDs

Return Value:

   Number of TDs required.

--*/

{
    ULONG   maxPacketSize           = Endpoint->HcEndpointDescriptor.Control.MaximumPacketSize;
    PVOID   currentVa;
    ULONG   bytesRemaining          = Urb->CommonTransfer.TransferBufferLength;
    ULONG   bytesMapped             = 0;
    ULONG   currentPa               = 0;
    UCHAR   dataToggle              = OHCI_TD_TOGGLE_FROM_ED;
    UCHAR   hostControllerNumber    = (UCHAR)DeviceExtension->HostControllerNumber;
    ULONG   prevPageResidualPa      = 0;
    ULONG   prevPageResidualBytes   = 0;

    
    POHCD_TRANSFER_DESCRIPTOR       firstTD;
    POHCD_TRANSFER_DESCRIPTOR       previousTD = NULL;
    POHCD_TRANSFER_DESCRIPTOR       currentTD;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_ProgramTransfer."));

    //
    //  Traceout some summary stats of the URB
    //
    USB_DBG_TRACE_PRINT(("Programming DMA for URB @0x%0.8x.", Urb));
    USB_DBG_TRACE_PRINT(("  TransferBuffer        @0x%0.8x", Urb->CommonTransfer.TransferBuffer ));
    USB_DBG_TRACE_PRINT(("  TransferBufferLength  %d bytes", Urb->CommonTransfer.TransferBufferLength ));
    USB_DBG_TRACE_PRINT(("  MaximumPacketSize     %d bytes", maxPacketSize));
    USB_DBG_TRACE_PRINT(("  TDs Required          %d", Urb->CommonTransfer.Hca.HcdTDCount));
    USB_DBG_TRACE_PRINT(("  Endpoint              @0x%0.8x", Endpoint));
    USB_DBG_TRACE_PRINT(("  Control Endpoint?     %s", 
        (USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType) ? "Yes" : "No"));
    
    //
    //  We are about to program a TD that was previously queued.
    //  Adjust the counts that are kept with the Endpoint.
    //
    Endpoint->QueuedUrbCount--;
    Endpoint->ProgrammedUrbCount++;
    Urb->CommonTransfer.Hca.HcdUrbFlags &= ~OHCD_URB_FLAG_QUEUED;
    Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_PROGRAMMED;

    //
    //  Setup the TD basics. Allocate the first TD.  However, in most cases we can
    //  recycle the dummy. Reuse the dummy at the tail for the first TD
    //
    if(Endpoint->HcEndpointDescriptor.TailP)
    {
        firstTD = 
        currentTD = OHCD_PoolTDFromPhysicalAddress(Endpoint->HcEndpointDescriptor.TailP);
    } else
    {
        //
        //  We need to allocate the head TD.
        //
        firstTD = 
        currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
        
        //
        //  Endpoint sure ought to be paused
        //
        ASSERT(1==Endpoint->HcEndpointDescriptor.Control.Skip);
        //
        //  Write this newly allocated TD to the head
        //
        WRITE_HEADP(&Endpoint->HcEndpointDescriptor, firstTD->PhysicalAddress)
    }
    
    //
    //  If we are a control interface, handle the setup packet
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        POHCD_SETUP_BUFFER SetupBuffer;
        //
        //  We need a descriptor block to hold the setup packet data
        //  and the status packet data.
        //  (we are not really using the TD as a TD, so don't stamp
        //  it with the hostControllerNumber)
        //
        SetupBuffer = (POHCD_SETUP_BUFFER) OHCD_PoolAllocateTD(0xFE-hostControllerNumber);

        //
        //  Copy over the setup bytes (8 of them).
        //  Normally I object to obfuscated code like this,
        //  but you cannot call RtlCopyMemory from DISPATCH_LEVEL, so I will
        //  use this trick I saw in the original Win2K driver.
        //
        *((PLONGLONG)SetupBuffer->Setup) = *((PLONGLONG)&Urb->ControlTransfer.SetupPacket);
        
        //
        //  We will use the firstTD for the setup packet, so allocate a new TD
        //  for the first data packet.
        //
        currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
        
        //
        //  Fill out the hardware mandated fields
        //
        firstTD->HcTransferDescriptor.BufferRounding = FALSE;
        firstTD->HcTransferDescriptor.Direction_PID = OHCI_TD_DIRECTION_PID_SETUP;
        firstTD->HcTransferDescriptor.DelayInterrupt = OHCI_TD_DELAY_INTERRUPT_NONE;
        firstTD->HcTransferDescriptor.DataToggle = dataToggle = OHCI_TD_TOGGLE_DATA0;
        firstTD->HcTransferDescriptor.ErrorCount = 0;
        firstTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED;
        firstTD->HcTransferDescriptor.CurrentBufferPointer = SetupBuffer->PhysicalAddress;
        firstTD->HcTransferDescriptor.NextTD = currentTD->PhysicalAddress;
        firstTD->HcTransferDescriptor.BufferEnd = SetupBuffer->PhysicalAddress + 7;
        //
        //  Now the software fields
        //
        firstTD->Endpoint = Endpoint;
        firstTD->Flags = 0;
        firstTD->Type = OHCD_TD_TYPE_SETUP;
        firstTD->Bytes = 0;
        firstTD->Urb = Urb;
    }
    
    //
    //  Lock the buffer pagesand get the initial value for currentVa,
    //  if and only if there is a data phase.
    //
    if(bytesRemaining)
    {
        #ifdef DVTSNOOPBUG
        OHCD_PoolStartDoubleBufferTransfer(Urb);
        #endif
        MmLockUnlockBufferPages(Urb->CommonTransfer.TransferBuffer, bytesRemaining, FALSE);
        currentVa = Urb->CommonTransfer.TransferBuffer;
    }else
    {
        //
        //  It is a dataless control transfer.  Set the direction so that
        //  the status stage will be an IN.  Status is always reverse of
        //  data, so we set the direction to OUT.
        //
        Urb->ControlTransfer.TransferDirection = OHCI_TD_DIRECTION_PID_OUT;
    }

    //
    //  Now loop until we map the whole user buffer.
    //
    while(bytesRemaining)
    {
        //
        //  Get a physical address
        //
        currentPa = OHCD_fMapTransfer(
            &currentVa,
            &bytesRemaining,
            &bytesMapped
            );

        //
        //  Loop as long as: 
        //      * We have enough buffer mapped to program a whole packet.
        //      * Or it is the last packet.
        //
        while( 
                ((bytesMapped + prevPageResidualBytes) >= maxPacketSize) || 
                ( (0 != bytesMapped) && (0 == bytesRemaining) )
        )
        {
            //
            //  Fill out TD's beginning and ending buffer
            //  physical pointers, and update currentPa and bytesMapped
            //  for next iteration.
            //
            //  The first case, handles a TD that crosses a page boundary
            //  for non-contiguous physical memory.
            //
            if(prevPageResidualBytes)
            {
                ULONG   bytesFromCurrentPage;
                //
                //  Record the start of the buffer (which is from the previousPage)
                //
                currentTD->HcTransferDescriptor.CurrentBufferPointer = prevPageResidualPa;
                        
                //
                //  Find BufferEnd which is on the current page
                //
                bytesFromCurrentPage = maxPacketSize - prevPageResidualBytes;
                if(bytesMapped < bytesFromCurrentPage) bytesFromCurrentPage = bytesMapped;
                currentPa += bytesFromCurrentPage;
                bytesMapped -= bytesFromCurrentPage;
                currentTD->Bytes = (UCHAR)(prevPageResidualBytes + bytesFromCurrentPage);
                prevPageResidualBytes = 0;
                
            }
            else
            {
                //
                //  Record the start of the buffer.
                //
                currentTD->HcTransferDescriptor.CurrentBufferPointer = currentPa;
                //
                //  Find BufferEnd
                //
                if(bytesMapped < maxPacketSize)
                {
                    currentPa += bytesMapped;
                    currentTD->Bytes = (UCHAR)bytesMapped;
                    bytesMapped = 0;
                }
                else
                {
                    currentTD->Bytes = (UCHAR)maxPacketSize;
                    currentPa += maxPacketSize;
                    bytesMapped -= maxPacketSize;
                }
            }
            //
            //  Record BufferEnd.
            //
            currentTD->HcTransferDescriptor.BufferEnd =  currentPa - 1;

            //
            //  Setup the rest of the TD
            //
            currentTD->Endpoint = Endpoint;
            currentTD->Flags = 0;
            currentTD->Type = OHCD_TD_TYPE_DATA;
            currentTD->HcTransferDescriptor.BufferRounding = FALSE;
            currentTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED;
            dataToggle ^= OHCI_TD_TOGGLE_DATA_MASK;
            currentTD->HcTransferDescriptor.DataToggle = dataToggle;
            currentTD->HcTransferDescriptor.DelayInterrupt = OHCI_TD_DELAY_INTERRUPT_NONE;
            currentTD->HcTransferDescriptor.Direction_PID = Urb->ControlTransfer.TransferDirection;
            currentTD->HcTransferDescriptor.ErrorCount = 0;
            currentTD->Urb = Urb;
            
            //
            //  To continue we need to allocate another TD and initialize the
            //  basic stuff.
            //
            previousTD = currentTD;
            currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
            
            //
            //  Link the new TD on to the end of the previous one
            //
            previousTD->HcTransferDescriptor.NextTD = currentTD->PhysicalAddress;

            USB_DBG_TRACE_PRINT(("Loop to assign another TD: bytesMapped(i.e. remaining from this page) = %d", bytesMapped));
        }
        //
        //  Set the previous page stuff for the next loop
        //
        prevPageResidualPa = currentPa;
        prevPageResidualBytes = bytesMapped;
    }

    //
    //  A short packet is OK on last data packet if thed
    //  caller (who submitted the URB) wants it to be OK.
    //  Notice above that the default is FALSE. Even if the caller
    //  allows short packets, the FailedTD routine must be called
    //  to handle short packets in the middle of a transfer, as the
    //  extra TD's must be cleaned from the schedule.
    //
    if(previousTD && Urb->CommonTransfer.ShortTransferOK)
    {
        previousTD->HcTransferDescriptor.BufferRounding = TRUE;
    } 

    //
    //  If it is a control endpoint,
    //  fill out the TD for the status packet.
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        //
        //  Fill out the Hardware mandated fields
        //
        currentTD->HcTransferDescriptor.BufferRounding = FALSE;
        //
        //  Status Packet must reverse the direction of the data packets.
        //
        currentTD->HcTransferDescriptor.Direction_PID = (OHCI_TD_DIRECTION_PID_IN == Urb->CommonTransfer.TransferDirection) ?
                                                                            OHCI_TD_DIRECTION_PID_OUT : OHCI_TD_DIRECTION_PID_IN;
        currentTD->HcTransferDescriptor.DelayInterrupt = Urb->CommonTransfer.InterruptDelay;
        currentTD->HcTransferDescriptor.DataToggle = OHCI_TD_TOGGLE_DATA1;
        currentTD->HcTransferDescriptor.ErrorCount = 0;
        currentTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED;
        currentTD->HcTransferDescriptor.CurrentBufferPointer = 0;
        currentTD->HcTransferDescriptor.BufferEnd = 0;
        //
        //  Now the software fields
        //
        currentTD->Endpoint = Endpoint;
        currentTD->Flags = OHCD_TD_FLAG_LAST_TD;
        currentTD->Type = OHCD_TD_TYPE_STATUS;
        currentTD->Urb = Urb;
        currentTD->Bytes = 0;
        //
        //  We need a TD for the dummy packet
        //
        previousTD = currentTD;
        currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
        previousTD->HcTransferDescriptor.NextTD = currentTD->PhysicalAddress;
    }
    else
    //
    //  Otherwise we need to signal an interrupt on the last data packet, and mark the
    //  packet as the last.
    //
    {
        previousTD->HcTransferDescriptor.DelayInterrupt = Urb->CommonTransfer.InterruptDelay;
        previousTD->Flags = OHCD_TD_FLAG_LAST_TD;
    }

    //
    //  Now fill out the dummy TD
    //
    currentTD->Type = OHCD_TD_TYPE_DUMMY;
    
    //
    //  Wipe out the transfer length, we will increment it as stuff completes
    //
    Urb->CommonTransfer.Hca.HcdOriginalLength = (USHORT)Urb->CommonTransfer.TransferBufferLength;
    Urb->CommonTransfer.TransferBufferLength = 0;

    //
    //  Update the tail pointer
    //
    Endpoint->HcEndpointDescriptor.TailP = currentTD->PhysicalAddress;
    
    //
    //  make sure that SKip bit is not set on the endpoint
    //  (unless it is supposed to be paused!)
    if(0==Endpoint->PendingPauseCount)
        Endpoint->HcEndpointDescriptor.Control.Skip = 0;
    
    //
    //  Now we need to tell the host controller that we added to the
    //  end of the TD queue if it is control or bulk
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        WRITE_REGISTER_ULONG((PULONG)&DeviceExtension->OperationalRegisters->HcCommandStatus, HCCS_ControlListFilled);
    }
    else if(USB_ENDPOINT_TYPE_BULK == Endpoint->EndpointType)
    {
        WRITE_REGISTER_ULONG((PULONG)&DeviceExtension->OperationalRegisters->HcCommandStatus, HCCS_BulkListFilled);
    }
    
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramTransfer."));
    return;
}


ULONG
FASTCALL
OHCD_fMapTransfer(
    IN OUT  PVOID   *CurrentVa,
    IN OUT  PULONG  BytesRemaining,
    OUT     PULONG  BytesMapped
    )
/*++
    This routine is used instead of IoMapTransfer.  It works directly on
    a buffer, returning one page at a time.
--*/
{
    ULONG   returnAddress;

    //
    //  Get Physical address, and figure out number
    //  of bytes to the end of the page.
    //
    returnAddress = MmGetPhysicalAddress(*CurrentVa);
    *BytesMapped = PAGE_SIZE - BYTE_OFFSET(*CurrentVa);
    //
    //  Fix up return values
    //
    if(*BytesMapped > *BytesRemaining)
    {
        *BytesMapped = *BytesRemaining;
    }
    *BytesRemaining -= *BytesMapped;
    *CurrentVa = (PVOID)((ULONG)*CurrentVa + *BytesMapped);
    
    return returnAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbd\tree.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tree.c

Abstract:

    This module contains the code to manage the device tree.
    
    The entry points to this module are:

        Called During DriverEntry:
            CDeviceTree::CDeviceTree

        Called by root-hubs to indicate devices hot-plug events:
            USBD_DeviceConnected
            USBD_DeviceDisconnected
        Called by hubs to indicate devices hot-plug events:
            IUsbDevice::DeviceConnected
            IUsbDevice::DeviceDisconnected
        Called by class drivers to indicate the end of initialization or cleanup:
            IUsbDevice::AddComplete
            IUsbDevice::RemoveComplete
    
Environment:

    kernel mode only

Notes:


Revision History:

    02-11-00 : create by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>

//
//  Pull in usbd headers
//
#include <usbd.h>

DEFINE_USB_DEBUG_FUNCTIONS("USBD");

//---------------------------------------------------------------------
// Forward declarations of routines defined and used only in this module
//---------------------------------------------------------------------
VOID USBD_DeviceEnumStage0();
VOID USBD_DeviceEnumStagePre1(USBD_STATUS UsbdStatus, PVOID Context);
VOID FASTCALL USBD_fDeviceEnumStage1(IUsbDevice  *Device);
VOID USBD_DeviceEnumStage2(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStage3(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStagePre4(PURB Urb, IUsbDevice *Device);
VOID FASTCALL USBD_fDeviceEnumStage4(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStage5(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStage6(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceAbortEnum(PURB Unreferenced, IUsbDevice *Device);
VOID FASTCALL USBD_fDeviceAbortEnum2(IUsbDevice  *Device);
VOID USBD_DeviceEnumNextPending(PURB Urb, IUsbDevice *Device);
VOID USBD_CompleteDeviceDisconnected(IUsbDevice *Device);
VOID USBD_SetEnumWatchDog();
VOID USBD_ClearEnumWatchDog();

VOID FASTCALL USBD_LoadClassDriver(IUsbDevice *Device, PNP_CLASS_ID ClassId);
UCHAR FASTCALL USBD_AllocateUsbAddress(PUSBD_HOST_CONTROLLER HostController);
VOID FASTCALL USBD_FreeUsbAddress(PUSBD_HOST_CONTROLLER HostController, UCHAR DeviceAddress);

//
//  We do not include the CRT, but we need new.
//  we declare it static, so we don't conflict on linking
//  with other modules overriding new.
//
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize){return RTL_ALLOCATE_HEAP(memSize);}
#pragma warning(default:4211)
//--------------------------------------------
// Declare device tree. (Don't worry about
// the parameter, we call the C'tor explicitely
// from driver entry with the correct value.)
//--------------------------------------------

// HACK: Call the fake default constructor to avoid having the real
//  : constructor being called twice.
//
CDeviceTree g_DeviceTree;

#pragma code_seg(".XPPCINIT")
void 
CDeviceTree::Init(ULONG NodeCount, ULONG MaxCompositeInterfaces)
/*++
Routine Description:

    All of the initialization is done in this init function, because the
    c'tor cannot be called reliably in all link environments.

Arguments:
    
    DeviceExtension - Pointer to USBD device extension.

Return Value:

    None

--*/
{
    m_InProgress = FALSE;
    m_FirstFree = 0;
    m_FirstPendingEnum = NULL;
    m_CurrentEnum = NULL;
    m_NodeCount = NodeCount;
    m_Devices = new IUsbDevice[m_NodeCount];
    m_MaxCompositeInterfaces = MaxCompositeInterfaces;

    for(char nodeIndex = 0; nodeIndex < (m_NodeCount-1); nodeIndex++)
    {
        m_Devices[nodeIndex].m_NextFree = nodeIndex+1;
    }

    KeInitializeDpc(&m_EnumDpc, USBD_DeviceEnumTimerProc, NULL);
    KeInitializeTimer(&m_EnumTimer);
}
#pragma code_seg(".XPPCODE")

VOID
USBD_DeviceConnected(
    IN  PVOID    HcdExtension,
    IN  UCHAR    PortNumber
    )
/*++
    Routine Description:
        Called by the root-hub code in the HCD.  We find
        the device for the root-hub by looking in the DeviceObject,
        and then call the IUsbDevice::DeviceConntected.
--*/
{
    //
    //  Start with a retry count of 5.
    //
    USBD_HostControllerFromHCDExtension(HcdExtension)->RootHub->DeviceConnected(PortNumber, 5);
}

VOID IUsbDevice::DeviceConnected(UCHAR PortNumber, UCHAR RetryCount)
/*++
Routine Description:

    Called by the hub driver or indirectly through USBD_DeviceConnected for the root-hub in the HCD.
    This routine should be called at DISPATCH_LEVEL.  To avoid blocking on device transfers this
    routine kicks off a cascade of routines that enumerate a device.

    1) IUsbDevice::DeviceConnected
        a) Allocate Device Node
        b) Acquire Enum Lock
            i) If not acquired, add node to enum pending list, and return.
        c) start 100ms timer, so that device can settle.
    2) USBD_DeviceEnumStage0
        a) reset port.
    3) USBD_DeviceEnumStage1
        a) open default endpoint
        b) get DeviceDescriptor (8 bytes)
    4) USBD_DeviceEnumStage2
        a) allocate address
        b) set address
    5) USBD_DeviceEnumStage3
        a) close default endpoint
    6) USBD_DeviceEnumStage4
        b) if device requires function driver
            i) load function driver
            ii) Class Driver calls IUsbDevice::AddComplete when it is done enumerating.
        c) if device requires interface driver(s)
            i) open default endpoint
            ii) get configuration descriptor
    7) USBD_DeviceEnumStage5
        a) Set the configuration
    8)  USBD_DeviceEnumStage6
        a) allocate nodes for each interfaces.
        b) load class driver for first interface found.
        c) Class Driver calls IUsbDevice::AddComplete when it is done enumerating.
    9) IUsbDevice::AddComplete
        a) if it is an interface and has more siblings, load a class driver for the next sibling.
            i) Class Driver calls IUsbDevice::AddComplete when it is done enumerating.
        b) Close the default endpoint when all the sibling drivers are loaded, cascading to USBD_DeviceEnumNextPending.
    10) USBD_DeviceEnumNextPending
        a) If there are devices pending enumeration, takes one off the pending list and goes vack to 3)

    Each of the routines ends by sending an asynchronous request down to the HCD.
    The completion routine is always the next routine in the cascade.

Arguments:
    
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)
    LowSpeed        - Set if a low speed device was detected.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
    
    
    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceConnected"));
    USB_DBG_TRACE_PRINT(("%s device detected in Port %d of Hub 0x%0.8x", (LowSpeed) ? "LowSpeed" : "FullSpeed", PortNumber, this));
    ASSERT((UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type));

    //
    //  Allocate a device.
    //
    IUsbDevice *newDevice = g_DeviceTree.AllocDevice();
    if(!newDevice)
    {
        USB_DBG_WARN_PRINT(("Number of Devices Attached, exceeds the limits of our tree!"));
        USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceConnected, tree full"));
        return;
    }

    //
    //  Initialize the couple of things we know
    //
    newDevice->m_Type = UDN_TYPE_PENDING_ENUM;
    newDevice->m_PortNumber = PortNumber;
    newDevice->m_ClassDriver = NULL;
	newDevice->m_HostController = m_HostController;
    //
    //  Plug the node into the tree.
    //
    InsertChild(newDevice);

    //
    //  Serialize Device Enumeration
    //
    if(g_DeviceTree.m_InProgress)
    {
        //*
        //* An enumeration is in progress, queue our new node
        //* onto the pending list.
        //*

        //
        //  Set the retry count in the node.
        //
        newDevice->m_RetryCount = RetryCount;
        //
        //  Record the earliest time that enumeration may start.
        //
        newDevice->m_EarliestEnumTime.QuadPart = KeQueryInterruptTime();  //Get a time stamp.
        newDevice->m_EarliestEnumTime.QuadPart += 100*1000;  //Add 100 ms for power up.

        //
        //  Add the new device to the end of the pending list.
        //
        newDevice->m_NextPending = NULL;
        if(!g_DeviceTree.m_FirstPendingEnum)
        {
            g_DeviceTree.m_FirstPendingEnum = newDevice;
        } else
        {
            IUsbDevice *lastPending = g_DeviceTree.m_FirstPendingEnum;
            while(lastPending->m_NextPending) lastPending = lastPending->m_NextPending;
            lastPending->m_NextPending = newDevice;
        }

        //
        //  It is queued, so we can do nothing more.
        //
        USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceConnected, queued pending enum node"));
        return;
    }

    //
    //  We are actually working on this node.
    //
    newDevice->m_Type = UDN_TYPE_ENUMERATING;
    //
    //  Mark the global enum block in progress.
    //  Store the node information we are working on.
    //  
    g_DeviceTree.m_InProgress = TRUE;
    g_DeviceTree.m_DeviceRemoved = FALSE;
    g_DeviceTree.m_CurrentEnum = newDevice;
    g_DeviceTree.m_RetryCount = RetryCount;
    g_DeviceTree.m_EnumStage = USBD_ENUM_DEVICE_CONNECTED;

    //
    //  Until we change it the address is 0
    //
    newDevice->m_Address = 0;

    //
    //  Give newly plugged device a change to settle, 100ms according to specification.
    //
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_STAGE0;
    LARGE_INTEGER           waitTime;
    waitTime.QuadPart = -100*10000; //100ms wait
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}

__inline void USBD_SetEnumWatchDog()
{
    LARGE_INTEGER           waitTime;
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_WATCHDOG;
    waitTime.QuadPart = -5000*(LONGLONG)10000; //5 seconds (long, but that is the USB 1.1 specification: section 9.2.6.4)
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}
__inline void USBD_ClearEnumWatchDog()
{
    KeCancelTimer(&g_DeviceTree.m_EnumTimer);
}
VOID   
USBD_DeviceEnumTimerProc(
    IN PKDPC Dpc,
    IN PVOID Unused1,
    IN PVOID Unused2,
    IN PVOID Unused3
    )
{
    switch(g_DeviceTree.m_TimerReason)
    {
        case USBD_TIMER_REASON_STAGE0:
            USBD_DeviceEnumStage0();
            break;
        case USBD_TIMER_REASON_WATCHDOG:
            USB_DBG_WARN_PRINT(("Enumeration Timed out"));
            HCD_CancelRequest(
                    USBD_GetHCDExtension(g_DeviceTree.m_CurrentEnum->m_HostController),
                    &g_DeviceTree.m_EnumUrb
                    );  //This should force the hung URB to complete.
            break;
        case USBD_TIMER_REASON_CONTINUE_STAGE1:
            USBD_fDeviceEnumStage1(g_DeviceTree.m_CurrentEnum);
            break;
        case USBD_TIMER_REASON_CONTINUE_STAGE4:
            USBD_fDeviceEnumStage4(&g_DeviceTree.m_EnumUrb,g_DeviceTree.m_CurrentEnum);
            break;
        
        default:
            // The reason should always be set before the timer.
            // So this is a bug in the code that set the timer if this case is hit.
            ASSERT(FALSE);
    }
}


void USBD_DeviceEnumStage0()
/*++
Routine Description:

    Zeroeth stage of device enumeration after IUsbDevice::DeviceConnected.  See IUsbDevice::DeviceConnected
    for explanation of stages.  In this routine we:
        - reset the port

Arguments:
    
    None    

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{    
    IUsbDevice  *device = g_DeviceTree.m_CurrentEnum;
    PVOID       hcdDeviceExtension = USBD_GetHCDExtension(device->m_HostController);
    
    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage0"));
    
    //
    //  Verify that the device was not removed while we were waiting.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 0 detects device removal."));
        USBD_DeviceAbortEnum(NULL, device);
        return;
    }
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_0;
    //
    //  Reset Port - Either we need to ask HCD to do it for the RootHub,
    //               or we need to ask the USBHUB (there had better be one
    //               and only one linked to us.
    //
    IUsbDevice *parent = device->GetParent();
    if(UDN_TYPE_ROOT_HUB == parent->m_Type)
    {
        HCD_ResetRootHubPort(
                hcdDeviceExtension,
                device->GetHubPort(),
                (PFNHCD_RESET_COMPLETE)USBD_DeviceEnumStagePre1,
                (PVOID)device
                );
    }
    else
    {
        //
        //  Otherwise ask our hub driver component to handle the port reset.
        //
        USBHUB_DisableResetPort(parent, device->GetHubPort(), (PVOID)device, FALSE);
    }
    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage0"));
}

void IUsbDevice::ResetComplete(USBD_STATUS UsbdStatus, PVOID Context)
/*++
*   Wraps USBD_DeviceEnumStage1 for Hub Class Driver.
*   
--*/
{
    USBD_DeviceEnumStagePre1(UsbdStatus, Context);
}

VOID    
USBD_DeviceEnumStagePre1(
            USBD_STATUS UsbdStatus,
            PVOID Context
    )
/*++
    Routine Description:
        Section 9.2.6.2 stipulates a 10 ms recovery
        time after the 10 ms RESET.  This
        routine sets a 10 ms timer.
--*/
{
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_PRE1;

    
     //
    //  Check that the reset port worked, and that the
    //  device has not been ripped out between
    //  enumeration stages.
    //
    if(USBD_ERROR(UsbdStatus))
    {
        USB_DBG_WARN_PRINT(("Pre Stage 1 detects failue: UsbdStatus = 0x%0.8x", UsbdStatus));
        USBD_DeviceAbortEnum(NULL, (IUsbDevice  *)Context);
        return;
    }

    //
    //  Set the speed here.
    //
    IUsbDevice  *device = (IUsbDevice  *)Context;
    if(USBD_STATUS_LOWSPEED == UsbdStatus)
    {
        device->m_PortNumber |= UDN_LOWSPEED_PORT;
    } else
    {
        ASSERT(!(device->m_PortNumber&UDN_LOWSPEED_PORT));
    }

    //
    //  A ten millisecond wait is required after reset.
    //
    LARGE_INTEGER           waitTime;
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_CONTINUE_STAGE1;
    waitTime.QuadPart = -10*10000; //10 ms wait
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}

void
FASTCALL
USBD_fDeviceEnumStage1(
    IUsbDevice  *Device
    )
/*++
Routine Description:

    First stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - open the default endpoint
        - get the DeviceDescriptor

Arguments:
    
    UsbdStatus - Status of reset port.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    PVOID  hcdDeviceExtension = USBD_GetHCDExtension(Device->m_HostController);
    
    ASSERT_DISPATCH_LEVEL();

    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage1"));
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_1;
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_WARN_PRINT(("Stage 1 detects device removal."));
        USBD_DeviceAbortEnum(NULL, Device);
        return;
    }

    //
    //  Fill out URB for opening an endpoint
    //
    USB_BUILD_OPEN_ENDPOINT(
                &g_DeviceTree.m_EnumUrb.OpenEndpoint,
                0,  //Address is 0 - default address
                USB_ENDPOINT_TYPE_CONTROL,
                USBD_DEFAULT_MAXPACKET0,
                0,  //Interval
                );
    g_DeviceTree.m_EnumUrb.OpenEndpoint.LowSpeed = Device->GetLowSpeed();
    g_DeviceTree.m_EnumUrb.OpenEndpoint.FunctionAddress = 0;

    //
    //  This URB is required to be synchronous and not allowed to fail
    //  according to specification.  Why?
    //      * Control endpoint, so no bandwidth problems
    //      * Open endpoint does not communicate over wire.
    //
    HCD_SubmitRequest(
        hcdDeviceExtension,
        &g_DeviceTree.m_EnumUrb
        );

    //
    //  Retrieve the handle from the URB
    //
    Device->m_DefaultEndpoint = g_DeviceTree.m_EnumUrb.OpenEndpoint.EndpointHandle;
    ASSERT(Device->m_DefaultEndpoint);  //Though it is not suppose to fail under any circumstance, check in debug!

    //
    //  Now issue an asynchronous request for
    //  the device descriptor.  This will also
    //  move us on to the next stage.
    
    //
    //  Don't use USB_BUILD_GET_DESCRIPTOR macro, because
    //  it was intended for class drivers, which don't know the
    //  EndpointHandle.
    //
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage2;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)Device;
    g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = Device->m_DefaultEndpoint;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = (PVOID)&g_DeviceTree.m_DeviceDescriptor;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = sizeof(USB_DEVICE_DESCRIPTOR8);
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
    g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = FALSE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_DEVICE_TO_HOST;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_GET_DESCRIPTOR;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = (USB_DEVICE_DESCRIPTOR_TYPE << 8);
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = sizeof(USB_DEVICE_DESCRIPTOR8);
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(
        hcdDeviceExtension,
        &g_DeviceTree.m_EnumUrb
        );
    
    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage1"));
    return;
}

VOID    
USBD_DeviceEnumStage2(
            PURB        Urb,
            IUsbDevice  *device
    )
/*++
Routine Description:

    Second stage of device enumeration fter IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - allocate address
        - set address
Arguments:
    
    Urb     - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device  - Device (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_2;
    //
    //  Check that the get device descriptor worked, and that the
    //  device has not been ripped out between
    //  enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) ||g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_WARN_PRINT(("Stage 2 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        //  USBD_DeviceEnumStage3 close the default endpoint.
        //  If it sees the error or DeviceRemoved
        //  it will redirect the enumeration sequence to abort.
        //
        USBD_DeviceEnumStage3(Urb, device);
        return;
    }

    //
    //  Do some sanity checks on the descriptor, and reject
    //  the device if they fail.
    //
    if(
        (Urb->ControlTransfer.TransferBufferLength < 8) ||
        (g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0 > 64) ||
        (USB_DEVICE_DESCRIPTOR_TYPE != g_DeviceTree.m_DeviceDescriptor.bDescriptorType) ||
        ((sizeof(USB_DEVICE_DESCRIPTOR8) != g_DeviceTree.m_DeviceDescriptor.bLength) &&
         (sizeof(USB_DEVICE_DESCRIPTOR) != g_DeviceTree.m_DeviceDescriptor.bLength))
    )
    {
        USB_DBG_WARN_PRINT(("A device returned a corrupt device descriptor.  Retries are allowed."));
        Urb->Header.Status = USBD_STATUS_REQUEST_FAILED;
        USBD_DeviceEnumStage3(Urb, device);
        return;
    }
    
    //
    //  Dump the device descriptor in debug builds
    //
    USB_DBG_TRACE_PRINT(("Device Descriptor:"));

    USB_DBG_TRACE_PRINT(("   bcdUSB             = 0x%0.4x",  g_DeviceTree.m_DeviceDescriptor.bcdUSB));
    USB_DBG_TRACE_PRINT(("   bDeviceClass       = %d", (long)g_DeviceTree.m_DeviceDescriptor.bDeviceClass));
    USB_DBG_TRACE_PRINT(("   bDeviceSubClass    = %d", (long)g_DeviceTree.m_DeviceDescriptor.bDeviceSubClass));
    USB_DBG_TRACE_PRINT(("   bDeviceProtocol    = %d", (long)g_DeviceTree.m_DeviceDescriptor.bDeviceProtocol));
    USB_DBG_TRACE_PRINT(("   bMaxPacketSize0    = %d", (long)g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0));

    //
    //  Record MaxPacket0 from device descriptor
    //
    device->m_MaxPacket0 = g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0;

    //
    //  Allocate an address 
    //
    device->m_Address = USBD_AllocateUsbAddress(device->m_HostController);

    //
    //  This should never happen, because our tree
    //  supports fewer devices than we have addresses.
    //  So if we hit this ASSERT it probably means
    //  that someone didn't free an address on removal.
    //
    ASSERT(device->m_Address);


    //
    //  Set the address - No Macro for this one, because
    //                    class drivers should never do it.
    //
    //  Items commented are either correct from last transfer, or not necessary.
    //
  //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
  //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage3;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)deviceNode;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = g_DeviceTree.m_EndpointHandle;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = NULL;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = 0;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = FALSE;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_HOST_TO_DEVICE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_SET_ADDRESS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = device->m_Address;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = 0;
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(USBD_GetHCDExtension(device->m_HostController), &g_DeviceTree.m_EnumUrb);

    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage2"));
    return;
}

VOID    
USBD_DeviceEnumStage3(
            PURB        Urb,
            IUsbDevice  *device
    )
/*++
Routine Description:

    Third stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - close default endpoint

    ***
    *** BECAUSE THIS STAGE CLOSES THE DEFAULT ENDPOINT WHETHER THE PREVIOUS
    *** OPERATION FAILED OR NOT, THIS STAGE IS CALLED BY OTHER STAGES
    *** TO ABORT ENUMERATION IF THE DEFAULT ENDPOINT IS OPEN.
    ***

Arguments:
    
    Urb     - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device  - Device (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage3"));
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_3;
    //
    //  Check if the address was set properly, and that the
    //  device has not been ripped out between
    //  enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) || g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 3 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        // Redirect the close the default endpoint normally done in this
        // stage, to abort enumeration instead.
        //
        g_DeviceTree.m_EnumUrb.Header.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceAbortEnum;
    }
    else
    {
        g_DeviceTree.m_EnumUrb.Header.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStagePre4;
    }
    g_DeviceTree.m_EnumUrb.Header.Length = sizeof(URB_CLOSE_ENDPOINT);
    g_DeviceTree.m_EnumUrb.Header.Function = URB_FUNCTION_CLOSE_ENDPOINT;
    //g_DeviceTree.m_EnumUrb.Header.CompleteContext = (PVOID)device;
    //g_DeviceTree.m_EnumUrb.CloseEndpoint.EndpointHandle = g_DeviceTree.m_EndpointHandle;
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //  A close cannot time out.
    //
    HCD_SubmitRequest(
        USBD_GetHCDExtension(device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );

    //
    //  We can just mark the default endpoint as closed right now.
    //
    device->m_DefaultEndpoint = NULL;
    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage3"));    
    return;
}

VOID    
USBD_DeviceEnumStagePre4(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
    Routine Description:
        A fine point of the specification is that a device may require
        2 ms after a SET_ADDRESS request before it has to repsond to
        the new address.  In stage 2 we set the address.  In stage 3,
        we closed the endpoint.  However, testing shows that this is
        not enough time.

        So this "pre4" stage is introduced to insert an explicit
        2 ms delay before stage 4.

        USBD_TIMER_REASON_CONTINUE_STAGE4 tells the timer routine
        that it should continue with stage 4 when this times out.
--*/
{
    //
    //  Set Address take two millseconds to settle, so we
    //  set a timer before proceding to stage 4
    //
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_PRE4;
    LARGE_INTEGER           waitTime;
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_CONTINUE_STAGE4;
    waitTime.QuadPart = -2*10000; //2ms wait
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}

VOID  
FASTCALL  
USBD_fDeviceEnumStage4(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    Fourth stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we have two possibilities:

        Device requires a function driver:
            - Load the class driver.
            - We will complete enumeration when the function Driver
              calls IUsbDevice::AddComplete

        Device is a composite device:
            - Reopen default endpoint - with correct address and bMaxPacket0.
            - Get the Configuration descriptor and go on to stage 5

Arguments:
    
    Urb       - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device    - Device (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    ASSERT_DISPATCH_LEVEL();

    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage4"));
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_4;
    //
    //  Closing an endpoint cannot fail.  So we don't need to check, but
    //  we do need to check to make sure the device has not been removed.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 4 detects device removal"));
        //
        //  The default endpoint is closed so just abort
        //
        USBD_DeviceAbortEnum(NULL, Device);
        return;
    }

    //
    //  This is a function driver
    //
    if(0 != g_DeviceTree.m_DeviceDescriptor.bDeviceClass)
    {
        //
        //  Change the node type (remembering that hubs are special)
        //
        if(USB_DEVICE_CLASS_HUB == g_DeviceTree.m_DeviceDescriptor.bDeviceClass)
        {
            Device->m_Type = UDN_TYPE_HUB;
        }
        else
        {
            Device->m_Type = UDN_TYPE_FUNCTION;
        }

        //
        // Load the class driver
        //
        PNP_CLASS_ID classId;
        classId.USB.bClass = g_DeviceTree.m_DeviceDescriptor.bDeviceClass;
        classId.USB.bSubClass = g_DeviceTree.m_DeviceDescriptor.bDeviceSubClass;
        classId.USB.bProtocol = g_DeviceTree.m_DeviceDescriptor.bDeviceProtocol;
        classId.USB.bClassSpecificType = PNP_DEVICE_LEVEL_CLASS;
        USBD_LoadClassDriver(Device, classId);
        return;
    }

    //
    //  OK, we are either a COMPOSITE_FUNCTION or INTERFACE_FUNCTION
    //  so we need to get the configuration descriptor and move on to the
    //  next stage.
    //
    
    //*
    //* Open the default endpoint, this time get the address
    //* and stuff correct.
    //*

    //
    //  Initialize the enum urb to reopen the endpoint with the correct address
    //  and the correct max packet
    USB_BUILD_OPEN_ENDPOINT(
            &g_DeviceTree.m_EnumUrb.OpenEndpoint,
            0,  //Endpoint Address is 0 - default endpoint
            USB_ENDPOINT_TYPE_CONTROL,
            g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0,
            0  //Interval
            );
    g_DeviceTree.m_EnumUrb.OpenEndpoint.LowSpeed = Device->GetLowSpeed();
    g_DeviceTree.m_EnumUrb.OpenEndpoint.FunctionAddress = Device->m_Address;

    //
    //  This URB is required to be synchronous and not allowed to fail
    //  according to specification.  Why?
    //      * Control endpoint, so no bandwidth problems
    //      * Open endpoint does not communicate over wire.
    //
    HCD_SubmitRequest(
        USBD_GetHCDExtension(Device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
    
    //
    //  We want the default endpoint to be available to the class driver
    //  in later stages.
    //
    Device->m_DefaultEndpoint = g_DeviceTree.m_EnumUrb.OpenEndpoint.EndpointHandle; 
    ASSERT(Device->m_DefaultEndpoint);  //Though it is not suppose to fail under any circumstance, check in debug!
    
    //
    //  Now get the configuration descriptor and go on to next stage
    //
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage5;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)Device;
    g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = Device->m_DefaultEndpoint;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = (PVOID)&g_DeviceTree.m_ConfigurationDescriptorBuffer;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = USBD_MAX_CONFIG_DESC_SIZE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
    g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = TRUE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_DEVICE_TO_HOST;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_GET_DESCRIPTOR;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE << 8);
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = USBD_MAX_CONFIG_DESC_SIZE;
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(
        USBD_GetHCDExtension(Device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
    return;
}

VOID    
USBD_DeviceEnumStage5(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    Fifth stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - set the configuration.

Arguments:
    
    Urb       - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device    - Device (passed as the context for complete procedure)   

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_5;
    //
    //  Check if we got the configuration descriptor, and that the
    //  device has not been ripped out between enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) || g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 5 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        //  USBD_DeviceEnumStage3 close the default endpoint.
        //  When it sees the error or DeviceRemoved,
        //  it will redirect the enumeration sequence to abort.
        //
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }
    
    //
    //  Set the configurationDescriptor.
    //
    configurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer;
    
    //
    //  Verify the the configurationDescriptor does not exceed the Xbox
    //  limit.
    //
    if(USBD_MAX_CONFIG_DESC_SIZE < configurationDescriptor->wTotalLength)
    {
        g_DeviceTree.m_RetryCount = 0; //Don't retry this
        USB_DBG_WARN_PRINT(("Unsupported Hardware: Configuration Descriptor Length exceeds Xbox limit(%d bytes), disabling device", USBD_MAX_CONFIG_DESC_SIZE));
        Urb->Header.Status = USBD_STATUS_UNSUPPORTED_DEVICE;
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }

    //
    //  Verify that the entire descriptor was sent.
    //
    if(configurationDescriptor->wTotalLength != Urb->ControlTransfer.TransferBufferLength)
    {
        USB_DBG_WARN_PRINT(("Device did not return entire configuration descriptor, reenumerating"));
        Urb->Header.Status = USBD_STATUS_ERROR;
        //Retries will be allowed.
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }
    
    //
    //  Now set the configuration and go on to next stage
    //
    //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
    //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage6;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)deviceNode;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = GLOBAL_USBD_EnumBlock.EndpointHandle;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = NULL;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = 0;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = TRUE;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_HOST_TO_DEVICE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_SET_CONFIGURATION;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = configurationDescriptor->bConfigurationValue;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = 0;
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(
        USBD_GetHCDExtension(Device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
    return;
}

VOID    
USBD_DeviceEnumStage6(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    Sixth stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we have either a INTERACE_FUNCTION or COMPOSITE FUNCTION.
    
    If it is a COMPOSITE_FUNCTION we 
        - Allocate additional nodes for each of the interfaces and plug them into the tree.
        - Begin notifying the interface drivers

    If it is an INTERFACE_FUNCTION we
        - Notify the interface driver

Arguments:
    
    Urb         - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    DeviceNode  - DeviceNode (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_6;
    //
    //  Check if we got the configuration descriptor, and that the
    //  device has not been ripped out between enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) || g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 6 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        //  USBD_DeviceEnumStage3 close the default endpoint.
        //  When it sees the error or DeviceRemoved,
        //  it will redirect the enumeration sequence to abort.
        //
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }
    //
    //  After a successful set configuration clear the data toggle bits.
    //
    Device->m_DataToggleBits = 0;

    //
    //  Begin parsing the configuration descriptor
    //
    PUCHAR currentParseLocation = g_DeviceTree.m_ConfigurationDescriptorBuffer;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer;

    //
    //  Find the first interface, this will be needed for both
    //  UDN_TYPE_INTERFACE_FUNCTION and UDN_TYPE_COMPOSITE_FUNCTION
    //
    do
    {
        currentParseLocation += ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength;
        //
        //  Check to make sure we haven't walked off the end of the conifugration descriptor,
        //  and that we are not in an endless loop.
        //
        if(
            (currentParseLocation >= (g_DeviceTree.m_ConfigurationDescriptorBuffer + USBD_MAX_CONFIG_DESC_SIZE)) ||
            (0 == ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength)
        ){
            USB_DBG_WARN_PRINT(("Corrupt Configuration Descriptor."));
            g_DeviceTree.m_RetryCount = 0; //Don't retry this
            Urb->Header.Status = USBD_STATUS_UNSUPPORTED_DEVICE;
            USBD_DeviceEnumStage3(Urb, Device);
            return;
        }
    }while(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE);
    g_DeviceTree.m_InterfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)currentParseLocation;

    //
    //  If it has only one interface than it is an UDN_TYPE_INTERFACE_FUNCTION
    //  
    if(1 == configurationDescriptor->bNumInterfaces || 0 == g_DeviceTree.m_MaxCompositeInterfaces)
    {
        //
        //  Fill out UDN_TYPE_INTERFACE_FUNCTION specific stuff
        //
        Device->m_Type = UDN_TYPE_INTERFACE_FUNCTION;
    }
    else
    {
        IUsbDevice *interfaceDevice;
        ULONG      interfaceIndex;
        
        //
        //  Change the main device node to UDN_TYPE_COMPOSITE_FUNCTION
        //
        Device->m_Type = UDN_TYPE_COMPOSITE_FUNCTION;
        Device->m_FirstChild = UDN_INVALID_NODE_INDEX;

        //
        //  Allocates device for all of the interfaces
        //
        //
        for(interfaceIndex = 0; interfaceIndex < configurationDescriptor->bNumInterfaces; interfaceIndex++)
        {
            //
            //  Refuse to enumerate more interfaces on a composite device
            //  then any of the drivers registered for
            if(g_DeviceTree.m_MaxCompositeInterfaces <= interfaceIndex)
            {
                break;
            }

            //
            //  Allocate a device on our tree
            //
            interfaceDevice = g_DeviceTree.AllocDevice();
            if(NULL == interfaceDevice)
            {
                USB_DBG_WARN_PRINT(("Number of Devices Attached, exceeds the limits of our tree!"));
                break;
            }
            //
            //  initialize basic information from the composite device
            //
            interfaceDevice->m_Type = UDN_TYPE_INTERFACE;
            interfaceDevice->m_PortNumber = (interfaceIndex+1) | (Device->m_PortNumber & UDN_LOWSPEED_PORT);
            interfaceDevice->m_Address = Device->m_Address;
            interfaceDevice->m_DefaultEndpoint = Device->m_DefaultEndpoint;
            interfaceDevice->m_HostController = Device->m_HostController;
            interfaceDevice->m_MaxPacket0 = Device->m_MaxPacket0;

            //
            //  Plug node into the tree as a child of the composite device
            //
            Device->InsertChild(interfaceDevice);
        }
        //
        //  The parents defaultendpoint has to appear closed, so
        //  right after a child interface is complete, it can
        //  immediately open the default endpoint.
        //
        Device->m_DefaultEndpoint = NULL;
        //
        //  We are done with the UDN_TYPE_COMPOSITE_FUNCTION
        //  move on to processing its first child.
        //  
        Device = Device->GetFirstChild();
    }
    //
    //  OK set the interface.
    //
    Device->m_bInterfaceNumber = g_DeviceTree.m_InterfaceDescriptor->bInterfaceNumber;
     
    //
    // Load the class driver
    //
    PNP_CLASS_ID classId;
    classId.USB.bClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceClass;
    classId.USB.bSubClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceSubClass;
    classId.USB.bProtocol = g_DeviceTree.m_InterfaceDescriptor->bInterfaceProtocol;
    classId.USB.bClassSpecificType = PNP_INTERFACE_LEVEL_CLASS;
    USBD_LoadClassDriver(Device, classId);
    return;
}

VOID
IUsbDevice::AddComplete(
    USBD_STATUS Status
    )
/*++
Routine Description:

    Last stage of enumeration after IUsbDevice::DeviceConnected. See IUsbDevice::DeviceConnected
    for explanation of stages.
    
    This routine is called a by a class driver to when it has completed the class specific enumeration
    steps.  This routine is necessary, because the class driver may have to make asynchronous requests
    in order to complete its initialization, and therefore USBD needs to be notified when the
    class driver is done.

    The different types of devices require some special handindling.

    1) For UDN_TYPE_INTERFACE devices if there is a sibling: it load the class driver for the sibling and return.  Control
    will come back to this routine when the class driver for the sibling has completed its enumeration steps.

    2) For the last UDN_TYPE_INTERFACE of a UDN_TYPE_COMPOSITE_FUNCTION, or for UDN_TYPE_INTERFACE_FUNCTION it closes
    the default endpoint.  This function cascades to USBD_DeviceEnumNextPending.

    3) For UDN_TYPE_FUNCTION it just calls USBD_DeviceEnumNextPending directly.

Arguments:
    
    Status - Status from the class driver.  Should be one of:
    
      USBD_STATUS_SUCCESS               - Device successfully initialized.
      USBD_STATUS_UNSUPPORTED_DEVICE    - Device not supported by the class driver.

	NotifylParam - lParam to send with Add and  Notifications.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_ADD_COMPLETE;
    //
    //  If the class driver rejected the device, than
    //  the there is no class driver.
    //
    if(USBD_STATUS_UNSUPPORTED_DEVICE == Status)
    {
        USB_DBG_WARN_PRINT(("Unsupported Device or Class Driver not present."));
        m_ClassDriver = NULL;
    } else
    {
        //
        //  Notify XAPI
        //
        if(0xFF != m_ClassSpecificType)
        {
            PXPP_DEVICE_TYPE deviceType = m_ClassDriver->DeviceTypes[m_ClassSpecificType];
            if(deviceType)
            {
                XdReportDeviceInsertionRemoval(deviceType, m_ExternalPort, TRUE);
            }
        }
    }
    //
    //  Check for UDN_TYPE_FUNCTION and call USBD_DeviceEnumNextPending
    //
    if(
        (m_Type == UDN_TYPE_FUNCTION) ||
        (m_Type == UDN_TYPE_HUB)
    )
    {
        //
        //  If the class driver failed it, then abort enumeration.
        //
        if(USBD_ERROR(Status))
        {
            if(!m_ClassDriver) g_DeviceTree.m_RetryCount = 0;
            USBD_DeviceAbortEnum(NULL, this);
            return;
        }
        //
        //  Functions are completely enumerated, nothing left to do,
        //  except move on to the next pending.
        //
        USBD_DeviceEnumNextPending(NULL, this);
        return;
    }

    //
    //  The composite device is the parent of theis device if of type UDN_TYPE_INTERFACE_FUNCTION,
    //  and this device's parent if UDN_TYPE_INTERFACE.  Assume it is this
    //  device for now, and the case below will change it if necessary.
    //
    IUsbDevice *compositeDevice = this;
    //
    //  Mark the default endpoint as closed, but cache the endpointhandle
    //  so we can really close it.  We do this here because it applies to
    //  the last sibling if UDN_TYPE_INTERFACE, and to UDN_TYPE_INTERFACE_FUNCTION.
    //  Normally, the UDN_TYPE_COMPOSITE node is non-NULL if any of its children
    //  are non-NULL, but during enumeration is an exception.  This is so that
    //  immediately after a ClassDriver calls AddComplete it can open the default
    //  endpoint, and there is no race condition w.r.t. its sibilings completing enumeration.
    //  So before loaded even the first interface of the composite, we set the UDN_TYPE_COMPOSITE's
    //  m_DefaultEndpoint to NULL, while setting m_DefaultEndpoint for all the children to 
    //  the same endpoint which was opened for enumeration purposes.  Now, if the first
    //  child calls AddComplete and is immediately opened before its siblings finish enumeration
    //  it can reopen the default endpoint (getting a different handle).  This code cannot step on that.
    //  So if AddComplete is called for UDN_TYPE_INTERFACE and it is the last sibling we close the
    //  handle in UDN_TYPE_INTERFACE, and totally ignore what is in its parent (which may be NULL,
    //  or may be a different endpoint handle).  Note below, that we don't get as far as closing the
    //  endpoint if this is not the last sibling. If it is called for UDN_TYPE_INTERFACE_FUNCTION
    //  then there is nothing subtle going on.
    //
    PVOID endpointHandle = m_DefaultEndpoint;
    m_DefaultEndpoint = NULL;

    //
    //  There is some difference of type UDN_TYPE_INTERFACE.
    //  a) There may be siblings that have not have drivers loaded yet.
    //  b) The compositeDevice (the one that really owns the default endpoint)
    //     is our parent, not us.
    //
    PURB_COMPLETE_PROC CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumNextPending;
    if(m_Type == UDN_TYPE_INTERFACE)
    {
        IUsbDevice *Sibling = GetSibling();
        //
        //  As long as this has siblings there must be more interfaces.
        //
        if(NULL != Sibling)
        {
            //
            //  Begin parsing the configuration descriptor
            //
            PUCHAR currentParseLocation = (PUCHAR)g_DeviceTree.m_InterfaceDescriptor;
            
            //
            //  Parse to the next interface
            //
            do
            {
                currentParseLocation += ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength;
                ASSERT(currentParseLocation < (g_DeviceTree.m_ConfigurationDescriptorBuffer + USBD_MAX_CONFIG_DESC_SIZE));
            }while(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE);
            g_DeviceTree.m_InterfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)currentParseLocation;
            //
            //  Now that we have the next interface set the siblings m_bInterfaceNumber.
            //
            Sibling->m_bInterfaceNumber = g_DeviceTree.m_InterfaceDescriptor->bInterfaceNumber;
            //
            //  Load a driver for the sibling,
            //  and return.
            //
            PNP_CLASS_ID classId;
            classId.USB.bClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceClass;
            classId.USB.bSubClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceSubClass;
            classId.USB.bProtocol = g_DeviceTree.m_InterfaceDescriptor->bInterfaceProtocol;
            classId.USB.bClassSpecificType = PNP_INTERFACE_LEVEL_CLASS;
            USBD_LoadClassDriver(Sibling, classId);
            return;
        }
        else
        {
            //
            //  The next have this routine needs to know the compositeDevice
            //  which is this device's parent.
            compositeDevice = GetParent();
        }
    } else
    {
        if(USBD_ERROR(Status))
        {
            if(!m_ClassDriver) g_DeviceTree.m_RetryCount = 0;
            CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceAbortEnum;
        }
    }

    //
    //  Close the temporary enumeration time default endpoint.
    //
    g_DeviceTree.m_EnumUrb.Header.Length = sizeof(URB_CLOSE_ENDPOINT);
    g_DeviceTree.m_EnumUrb.Header.Function = URB_FUNCTION_CLOSE_ENDPOINT;
    g_DeviceTree.m_EnumUrb.Header.CompleteProc = CompleteProc;
    g_DeviceTree.m_EnumUrb.Header.CompleteContext = (PVOID)compositeDevice;
    g_DeviceTree.m_EnumUrb.CloseEndpoint.EndpointHandle = endpointHandle;
    
    //
    //  Close endpoint is not allowed to fail.
    //
    HCD_SubmitRequest(
        USBD_GetHCDExtension(compositeDevice->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
}

VOID    
USBD_DeviceAbortEnum(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:
    If enumeration failed we need to stop enumerating and continue with the
    next pending device.  By the time we get to this routine, you
    can be sure that the device is closed.  We call 
--*/
{
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_ABORT1;
    if(!g_DeviceTree.m_DeviceRemoved)
    //
    //  If the device was not removed, but failed, we need to
    //  disable it before continuing.
    //
    {
        USB_DBG_WARN_PRINT(("Enumeration Failed"));
        //
        //  Disable the port before completing abort, otherwise
        //  we could have an address conflict.
        //
        IUsbDevice *parent = Device->GetParent();
        if(UDN_TYPE_ROOT_HUB == parent->m_Type)
        {
            HCD_DisableRootHubPort(USBD_GetHCDExtension(Device->m_HostController), Device->GetHubPort());
            Device->DisableComplete(USBD_STATUS_SUCCESS, (PVOID)Device);
        } else
        {
            USBHUB_DisableResetPort(parent, Device->GetHubPort(), (PVOID)Device, TRUE);
        }
        return;
    } else
    {
        //
        //  Don't retry if the device was removed.
        //
        g_DeviceTree.m_RetryCount = 0;
    }
    USBD_fDeviceAbortEnum2(Device);
}

void IUsbDevice::DisableComplete(USBD_STATUS UsbdStatus, PVOID Context)
/*++
*   Only gets called as part of abort.
*   
--*/
{
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_DISABLE_COMPLETE;
    IUsbDevice *device = (IUsbDevice *)Context;
    //
    //  If the disable failed and the device was not removed
    //  then we cannot free the address.  We fake out
    //  USBD_fDeviceAbortEnum2 by forgetting the address, this
    //  is an address leak;
    //
    if(USBD_ERROR(UsbdStatus) && !g_DeviceTree.m_DeviceRemoved)
    {
        //This is OK as long as it is extremely rare and difficult to induce.
        USB_DBG_WARN_PRINT(("Address %d is about to leak, a device failed enumeration, and then the port disable failed.", device->m_Address));
        device->m_Address = 0; //leak the address.
    }
    //
    //  Don't retry devices that have been removed.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        g_DeviceTree.m_RetryCount = 0;
    }
    USBD_fDeviceAbortEnum2(device);
}

VOID FASTCALL USBD_fDeviceAbortEnum2(IUsbDevice  *Device)
/*++
*   Finish up abort
*   
--*/
{
    UCHAR retryCount = 0;
    UCHAR retryPort = 0;
    IUsbDevice *parent = NULL;

    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_ABORT2;
    //
    //  If the device is not removed
    //
    if(!g_DeviceTree.m_DeviceRemoved)
    {
        parent = Device->GetParent();
        ASSERT(parent);
        //
        //  Now remove it from its parent's tree
        //
        parent->RemoveChild(Device);
        //
        //  Resubmit the device for enumeration if
        //  the retry count is non-zero.
        //
        if(g_DeviceTree.m_RetryCount)
        {
            retryCount = g_DeviceTree.m_RetryCount;
            retryPort = Device->GetHubPort();
        }
    }

    //
    //  If the address is non-zero free it.
    //
    if(Device->m_Address)
    {
        USBD_FreeUsbAddress(Device->m_HostController, Device->m_Address);
    }
    //
    //  Free the node
    //
    g_DeviceTree.FreeDevice(Device);

    //
    //  If we detected a need for a retry, fire it here
    //
    if(retryCount)
    {
        parent->DeviceConnected(retryPort, --retryCount);
    }

    //
    //  Continue enumeration.
    //
    g_DeviceTree.m_DeviceRemoved = FALSE;
    USBD_DeviceEnumNextPending(NULL, Device);
}

VOID    
USBD_DeviceEnumNextPending(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    After enumeration of a device is complete, this function is called to enumerate the next
    device pendning enumeration.  If there are none it clears the InProgress flag, so that
    when a device is detected it can be enumerated.
    
    This routine is cascaded to from AddComplete, so g_DeviceTree.m_CurrentEnum
    will equal Device.  This would prevent IUsbDevice::DeviceDisconnected from completing.
    So we should also make one last check to see if the device was removed.

Arguments:
    
      Urb       - Could be NULL.  So don't use it.
      Device    - Device which was just enumerated.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  One last check to make sure the device we were working on is not gone.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("USBD_DeviceEnumNextPending detects device removal"));
        //
        //  We are essentially in the running stage now, so just finish off the device disconnected
        //  operation.
        USBD_CompleteDeviceDisconnected(Device);
    }
    g_DeviceTree.m_DeviceRemoved = FALSE;
    
    //
    //  If nothing else is pending, clear the InProgress flag and
    //  we are done.
    //
    if(NULL == g_DeviceTree.m_FirstPendingEnum)
    {
        g_DeviceTree.m_CurrentEnum = NULL;
        g_DeviceTree.m_InProgress = FALSE;
        return;
    }
    
    //---------------------------------------------
    // One or more devices are pending enumeration
    //---------------------------------------------
    //
    //  Pop a device off the pending list, and into current enum.
    //
    g_DeviceTree.m_CurrentEnum = g_DeviceTree.m_FirstPendingEnum;
    g_DeviceTree.m_FirstPendingEnum = g_DeviceTree.m_CurrentEnum->m_NextPending;
    g_DeviceTree.m_RetryCount =  g_DeviceTree.m_CurrentEnum->m_RetryCount;
    g_DeviceTree.m_EnumStage = USBD_ENUM_DEVICE_CONNECTED;
    g_DeviceTree.m_CurrentEnum->m_Type = UDN_TYPE_ENUMERATING;
    g_DeviceTree.m_CurrentEnum->m_ClassDriver = NULL;
    g_DeviceTree.m_CurrentEnum->m_Address = 0;
    
    
    //
    //  If it is too early to enumerate than wait until
    //  it is time, otherwise start stage 0 now.
    LARGE_INTEGER currentTime;
    currentTime.QuadPart = KeQueryInterruptTime();
    if(currentTime.QuadPart > g_DeviceTree.m_CurrentEnum->m_EarliestEnumTime.QuadPart)
    {
        USBD_DeviceEnumStage0();
    }
    else
    {

        g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_STAGE0;
        KeSetTimer(&g_DeviceTree.m_EnumTimer, g_DeviceTree.m_CurrentEnum->m_EarliestEnumTime, &g_DeviceTree.m_EnumDpc);
        USB_DBG_TRACE_PRINT(("Current Tick = %d, Earliest Enum = %d", currentTime.LowPart, g_DeviceTree.m_CurrentEnum->m_EarliestEnumTime.LowPart));
    }
}


VOID
USBD_DeviceDisconnected(
    IN  PVOID HcdExtension,
    IN  UCHAR PortNumber
    )
/*++
    Routine Description:
        Called by the root-hub code in the HCD.  We find
        the device for the root-hub by looking in the DeviceObject,
        and then call the IUsbDevice::DeviceDisconntected.
--*/
{
    USBD_HostControllerFromHCDExtension(HcdExtension)->RootHub->DeviceDisconnected(PortNumber);
}

VOID IUsbDevice::DeviceDisconnected(UCHAR PortNumber)
/*++
Routine Description:

    Called by the hub driver or through USBD_DeviceDisconnected by the root-hub code in the HCD
    to report the disconnection of a USB device.  This routine must be called at DISPATCH_LEVEL.
    
    A device can be in one of three states when it is removed:
    
      1) Pending Enumeration - it is in the list of devices waiting to be enumerated.
      2) Enumerating - it is currently being enumerated.
      3) Functioning - it has completed enumeration and is being used.

    The handling depends on the state.
    
      1) Pending Enumeration:
            * Remove the device from its parents list of children.
            * Remove the device from the list of devices waiting enumeration
            * Put the device back on the free list.
            It is all done synchronously.
      2) Enumerating:
            *Remove the device from its parents list of children.
            *Mark the g_DeviceTree.m_DeviceRemoved.  The next time an enumeration stage is started it will:
                If the class driver has not been loaded:
                    * Close any open endpoints if necessary (shunting to stage 3).
                    * Call USBD_AbortEnumDevice which calls IUsbDevice::RemoveComplete.
                If the class driver(s) are loaded, it calls USBD_CompleteDeviceDisconnected
      3) Functioning:
            This routine:
                * Remove it from its parents list of children.
            USBD_CompleteDeviceDisconnected:
                * If it is a UDN_TYPE_HUB, UDN_TYPE_FUNCTION, UDN_TYPE_INTERFACE_FUNCTION, notify the class driver
                that it is gone.
                * For UDN_TYPE_COMPOSITE_FUNCTION we need to walk all of its children and notify each class driver that it
                is gone.
            Class Driver:
                * Close all endpoints.
                * The hub driver must call USBD_DeviceDisconnected (this routine) for each of its children.
                * Call IUsbDevice::RemoveComplete for the device.
                * It should notify its clients that the device is gone, and perform any additional cleanup it
                  needs to.
            IUsbDevice::RemoveComplete:
                * Finishes reclaiming the node.

Arguments:
    
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{

    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceDisconnected"));
    USB_DBG_TRACE_PRINT(("Device removed from Port %d of Hub 0x%0.8x", (ULONG)GetHubPort(), this));

    ASSERT_DISPATCH_LEVEL();
    ASSERT((UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type));

    //
    //  Find the node, among its parents children.
    //
    IUsbDevice *removedDevice = FindChild(PortNumber);
    if(NULL == removedDevice)
    {
        USB_DBG_TRACE_PRINT(("USBD_DeviceDisconnected called for a device which does not exist."));
        USB_DBG_TRACE_PRINT(("This will happen when an unsupported (or in some cases failed) device is removed."));
        USB_DBG_TRACE_PRINT(("It also may happen as a result of some device failures."));
        return;
    }
    //
    //  Remove the device from this hub's list of children.
    //
    RemoveChild(removedDevice);
    
    //  
    //  Handle disconnect if node is pending enumeration.
    //
    if(UDN_TYPE_PENDING_ENUM == removedDevice->m_Type)
    {
        //
        //  Remove the node from the pending list
        //  
        if(g_DeviceTree.m_FirstPendingEnum == removedDevice)
        {
            g_DeviceTree.m_FirstPendingEnum = removedDevice->m_NextPending;
        } else
        //
        //  Not the first one, so we need to walk the pending list until we find it.
        //
        {
            IUsbDevice *prevPending = g_DeviceTree.m_FirstPendingEnum;
            while(removedDevice != prevPending->m_NextPending)
            {
                prevPending = prevPending->m_NextPending;
                ASSERT(prevPending);
            }
            prevPending->m_NextPending = removedDevice->m_NextPending;
        }
        removedDevice->m_NextPending = NULL;
        //
        //  Return the node to the free list.
        //
        g_DeviceTree.FreeDevice(removedDevice);
        //
        //  The device is removed we are done
        //
        return;
    }
    
    //  
    //  Handle disconnect if node is enumerating.
    //
    if( 
        g_DeviceTree.m_InProgress &&
        (g_DeviceTree.m_CurrentEnum == removedDevice)
    )
    {
        //
        //  Just tell the enumeration code that the device
        //  it is working on is now gone.
        //
        g_DeviceTree.m_DeviceRemoved = TRUE;
        return;
    }
    
    //  
    //  Handle disconnect if node is functioning
    //
    USBD_CompleteDeviceDisconnected(removedDevice);

    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceDisonnected"));
}

VOID
USBD_CompleteDeviceDisconnected(
    IUsbDevice *Device
    )
/*++
Routine Description:
    Utility function to complete the last step of hte USBD_DeviceDisconnected routine:
    notifying the class drivers that the device has been removed.  This has been abstracted,
    because it is called in two places:
        1) End of IUsbDevice::DeviceDisconnected.
        2) From USBD_DeviceEnumNextPending.

    The latter cases arises if the device is physically removed and DeviceDeviceDisconnected is called for
    a device which has completed USBD_DeviceEnumStage6(for UDN_TYPE_COMPOSITE_FUNCTION, or UDN_TYPE_INTERFACE_FUNCTION) or
    USBD_DeviceEnumStage4(for UDN_TYPE_FUNCITON and UDN_TYPE_HUB), but the AddComplete has not yet been called
    by the class driver (or all the class drivers - in the case of UDN_TYPE_COMPOSITE_FUNCTION).
--*/
{
    if(UDN_TYPE_COMPOSITE_FUNCTION == Device->m_Type)
    {
        //
        //  Walk children (i.e. interface and notify each driver.  There is no need for serialization
        //  here so we just call them all.
        //
        IUsbDevice *child = Device->GetFirstChild();
        while(child)
        {
            //Cache the next child, because RemoveComplete,
            //removes it from the parent's list of children.
            IUsbDevice *nextChild = child->GetSibling(); 
            if(child->m_ClassDriver)
            {
                child->m_ClassDriver->RemoveDevice(child);
            } else
            {
                child->RemoveComplete();
            }
            child = nextChild;  //prepare for next interation
        }
    }
    else
    {
        if(Device->m_ClassDriver)
        {
            Device->m_ClassDriver->RemoveDevice(Device);
        } else
        {
            Device->RemoveComplete();
        }
    }
}


VOID IUsbDevice::RemoveComplete()
/*++
Routine Description:

    When a device is disconnected, USBD_DeviceDisconnected calls each of the class drivers to give
    them a chance to cleanup.  Since they may need to perform asynchronous operations to complete their
    cleanup (such as closing endpoints), completion of removal cannot proceed when the class driver returns
    from the notification.  Therefore class drivers must call this routine when they are done cleaning up.

    Likewise, if removal occurs during enumeration, enumeration eventually ends up here.  At this point, there are
    two tasks left: return the node to the free list, and free the USB address.
      
    However, UDN_TYPE_INTERFACE nodes have a little more work.  They are children of UDN_TYPE_COMPOSITE_FUNCTION.
    Since the parent UDN_TYPE_COMPOSITE_FUNCTION is needed for closing endpoints, it is still attached.  So this routine
    must remove the node from its parents' child list, and return the node to the free list.  Upon removing the
    last child, it should free the parent too.  The USB address should be freed with parent, not the children.
    
Arguments:
    
    DeviceObject    - DeviceObject of host controller for detecting hub
    DetectingHub    - Device Node for detecting hub
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)

Return Value:

    None.

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
	
   
    //
    //  Notify XAPI
    //
    if(0xFF != m_ClassSpecificType)
    {
        PXPP_DEVICE_TYPE deviceType = m_ClassDriver->DeviceTypes[m_ClassSpecificType];
        if(deviceType)
        {
            XdReportDeviceInsertionRemoval(deviceType, m_ExternalPort, FALSE);
        }
    }

    //
    //  For UDN_TYPE_INTERFACE, remove the node from its parents' child list,
    //  and free parent if no more children
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        //
        //  Remove the parents list of children
        //  and free parent if no more children
        IUsbDevice *parent = GetParent();
        if(FALSE == parent->RemoveChild(this))
        {
            //
            //  Free the USB address
            //
            USBD_FreeUsbAddress(parent->m_HostController, parent->m_Address);
            //
            //  Free the device.
            //
            g_DeviceTree.FreeDevice(parent);
        }
    }
    else
    {
        //
        //  For non-UDN_TYPE_INTERFACE nodes
        //
        if(m_Address)  //we have to check in case, we were aborted before a successful SET_ADDRESS
        {
            USBD_FreeUsbAddress(m_HostController, m_Address);
        }
    }
    //
    //  Free node.
    //
    g_DeviceTree.FreeDevice(this);
    return;
}

void IUsbDevice::DeviceNotResponding()
/*++
Routine Description:

    If a device stops responding for any reason, a class driver    
Arguments:
    
    DeviceObject    - DeviceObject of host controller for detecting hub
    DetectingHub    - Device Node for detecting hub
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)

Return Value:

    None.

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
    IUsbDevice *device;
    
    //
    //  If the device is UDN_TYPE_INTERFACE, then the
    //  real node is the parent
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        device = GetParent();
        ASSERT(device);
    } else
    {
        device = this;
    }
    

    //
    //  If it has a parent, it is not pending
    //  remove, so we should reenumerate it.
    //
    IUsbDevice *parent = device->GetParent();
    if(parent)
    {
        
        UCHAR   hubPort = device->GetHubPort();
        
        //
        //  Report the device as disconnected
        //
        parent->DeviceDisconnected(hubPort);

        //
        //  Report the device as connected.
        //
        parent->DeviceConnected(hubPort, 5);
    }
}

VOID
FASTCALL
USBD_LoadClassDriver(IUsbDevice *Device, PNP_CLASS_ID ClassId)
/*++
Routine Description:

    This routine is a helper function for device enumeration.  It is used three times
    so it is extracted.  It kicks off the Class Driver portion of enumeration.
    
    Given a class ID it calls the USBD_FindClassDriver.  If it finds one
    it calls the class drivers AddDevice.  Otherwise, it calls Device->AddComplete 
    with an error code.

Arguments:
    
    Device - The device for which to load a driver.
    ClassId = PnP Class ID for the driver to load.

Return Value:

    None.

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    //
    //  Sets up the external port number
    //
    Device->SetExternalPort();
    if(XDEVICE_ILLEGAL_PORT == Device->m_ExternalPort)
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    Device->m_ClassDriver = USBD_FindClassDriver(ClassId);

    //
    //  Call AddDevice if we found a class driver
    //
    if(Device->m_ClassDriver)
    {
        Device->m_ClassDriver->AddDevice(Device);
        //
        //  The class driver will call AddComplete, when it
        //  has completed its enumeration steps.
        //
    } else
    //
    //  We don't have a class driver, so call AddComplete
    //  with a failure code.
    //
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    }
    return;
}

UCHAR
FASTCALL
USBD_AllocateUsbAddress(
    IN PUSBD_HOST_CONTROLLER HostController
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    UCHAR   address     = 0;
    UCHAR   dwordIndex  = 0;
    ULONG   bitMask     = 1;
    
    //
    //  The AddressList consists of four DWORDS.
    //  Together they form a 128 bit bitfield.
    //  bits that are set, are address that are
    //  taken.
    //
        
    //
    //  Search for a free address
    //
    while(++address < 128)
    {
        //
        //  If the address is available, claim it and break
        //  out of loop.
        //
        if(!(HostController->AddressList[dwordIndex] & bitMask))
        {
            HostController->AddressList[dwordIndex] |= bitMask;
            break;
        }
        bitMask <<= 1;
        if(!bitMask)
        {
            dwordIndex++;
            bitMask = 1;
        }
    }
    //
    //  Handle case of out of addresses (we fell through the loop).
    //
    //  if(address == 128) address = 0;
    address &= 0x007F;  //This is more efficient than above.

    return address;
}

VOID
FASTCALL
USBD_FreeUsbAddress(
    IN PUSBD_HOST_CONTROLLER HostController,
    IN UCHAR DeviceAddress
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    UCHAR                   dwordIndex  = 0;

    //
    // Sanity check address range
    //
    ASSERT(DeviceAddress > 0 && DeviceAddress < 128);
    
    //
    //  Reduce the DeviceAddress to a dwordIndex and
    //  a bitIndex (DeviceAddress will be the bitIndex
    //  when we leave this loop.
    //
    DeviceAddress--;
    while(DeviceAddress > 31)
    {
        dwordIndex++;
        DeviceAddress -= 32;
    }
    
    //
    //  Now clear the bit
    //
    HostController->AddressList[dwordIndex] &= ~(1 << DeviceAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\ohcd\schedule.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    schedule.c

Abstract:
    
    Implementation of schedule manager.

    The code in this module maintains all of the endpoint lists associated
    with transfer schedule.  Basically scheduling is only involved when a
    new endpoint is opened or closed.

    The work to be done is very different for bulk and control versus
    isochronous and interrupt.

    For bulk and control the endpoint to be open is simply placed at the head
    of a linked list.

    For interrupt and isochronous a slot must be found in the schedule with
    sufficient bandwidth and the bandwidth tables must be updated.

    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-20-00 created by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


#define OHCD_GET_PARENT_INTERRUPT_INDEX(_index_)    ((_index_) >> 1)
#define OHCD_GET_CHILD1_INTERRUPT_INDEX(_index_)    ((_index_) << 1)
#define OHCD_GET_CHILD2_INTERRUPT_INDEX(_index_)    (((_index_) << 1) + 1)
#define OHCD_GET_SIBLING_INTERRUPT_INDEX(_index_)   ((_index_) ^ 1)

//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
VOID
FASTCALL
OHCD_HookNewEndpointToChildren(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    ULONG                   EndpointPhysicalAddress,
    UCHAR                   ParentNode
    );

ULONG 
FASTCALL
OHCD_ReverseBits(
    ULONG NumBits,
    ULONG Value
    );

//----------------------------------------------------------------------------
// Implementation of OHCD_ScheduleXXX routines:
//      OHCD_ScheduleInitialize
//      OHCD_ScheduleAddEndpointPeriodic
//      OHCD_ScheduleRemoveEndpointPeriodic
//      OHCD_ScheduleAddEndpointControlOrBulk
//      OHCD_ScheduleRemoveEndpointControlOrBulk
//----------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
VOID
FASTCALL
OHCD_ScheduleInitialize(
    POHCD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:
    
    Initializes the internal data structures, operational registers,
    and shared common buffer areas which set the OpenHCI USB packet
    schedule.
Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.

Return Value:

    None.

--*/
{
    ULONG                   periodicStart;
    ULONG                   hcLSThreshold;
    POHCD_ENDPOINT_SCHEDULE schedule = &DeviceExtension->Schedule;
    
    //
    //  The structure is more or less initialized by
    //  zeroing everything out.  The whole device extension
    //  should have been zeroed before this routine
    //  was called, so on MAX_DBG builds only just
    //  assert that the structure really is clean
#ifdef MAX_DBG
    for(i = 0; i < 64; i++)
    {
        //
        //  Verify that the NULL and 0 fields were wiped
        //  with the rest of the DeviceExtension
        //
        ASSERT(0 == schedule->InterruptSchedule[i].Bandwidth);
        ASSERT(0 == schedule->InterruptSchedule[i].BandwidthChildren);
        ASSERT(0 == schedule->InterruptSchedule[i].BandwidthParents);
        ASSERT(NULL == schedule->InterruptSchedule[i].EndpointHead);
        ASSERT(NULL == schedule->InterruptSchedule[i].EndpointTail);
        ASSERT(FALSE == schedule->InterruptSchedule[i].RegisterHead);
    }
    ASSERT(0 == Schedule->BulkHead);
    ASSERT(0 == Schedule->BulkTail);
    ASSERT(0 == Schedule->ControlHead);
    ASSERT(0 == Schedule->ControlTail);
#endif

    //
    //  No need to initialize the HCCA, because the initial values
    //  are all zero and that was done when the space was allocated
    //  as part of initializing DMA.
    //

    //
    //  Check the alignment requirments of HCCA
    //
    #ifndef OHCD_XBOX_HARDWARE_ONLY
    #if DBG
    {
        ULONG AlignmentCheck;
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcHCCA, 0xFFFFFFFF);
        AlignmentCheck = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcHCCA);
        if( (~AlignmentCheck)&((ULONG)(DeviceExtension->HCCA)) )
        {
            USB_DBG_ERROR_PRINT(("The 2nd USB host controller is not compatible with XSS as a second host controller.\
You can try swapping the USB cards.\n XSS will most likely crash if you see this message.\n"));
        }
    }
    #endif  //DBG
    #endif //OHCD_XBOX_HARDWARE_ONLY
    
    

    //
    //  Setup the schedule part of the
    //  Operational registers
    //
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcHCCA, OHCD_PoolGetPhysicalAddress(DeviceExtension->HCCA));
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcPeriodCurrentED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControlHeadED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControlCurrentED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcBulkHeadED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcBulkCurrentED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcDoneHead, 0);


    //
    //  save off the total bandwidth - i.e. total number of bits/frame
    //
    schedule->BandwidthTotal = (USHORT)OHCI_CLOCKS_TO_BITS(OHCI_DEFAULT_FRAME_INTERVAL);

    //
    //  Set the HcPeriodicStart to be roughly 90% of FrameInterval.
    //  A special note, HcPeriodicStart is the clocks remaining when we switch
    //  to isoch.  The silly OpenHCI specification says to set to 10%, but they mean
    //  10% gone.
    //
    periodicStart = (9*OHCI_DEFAULT_FRAME_INTERVAL + 5)/10;
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcPeriodicStart, periodicStart);
    
    //
    //  Calculate the bandwidth (bits\frame) for periodic transfers
    //
    ASSERT(0xFFFF >= periodicStart);
    schedule->BandwidthPeriodic = (USHORT)OHCI_CLOCKS_TO_BITS(periodicStart);

    //
    //  Low speed threshold is the time (in full speed clocks) of 8 byte transfer
    //  for the slowest type (interrupt) of endpoint on a low speed device.
    //
    hcLSThreshold = USBD_CalculateUsbBandwidth(8, USB_ENDPOINT_TYPE_INTERRUPT, TRUE);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcLSThreshold, hcLSThreshold);
}
#pragma code_seg(".XPPCODE")

USBD_STATUS
FASTCALL
OHCD_ScheduleAddEndpointPeriodic(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Adds a periodic (interrupt or isochronous) endpoint into the interrupt schedule.

    1) Determines the nodes in the schedule with the proper rate.
    2) Determines which of the nodes with proper will most balance
    the schedule of periodic transfers.
    3) Assure that the best node, has enough bandwidth.
    4) Recomputes the bandwidth entries in the InterruptSchedule.
    5) Insert the endpoint into the InterruptSchedule.
    6) Revises the pointers in the HCCA and the physical address pointers
    of the endpoint descriptors to reflect the schedule changes.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to add to schedule.

Return Value:

    None.

--*/
{
    POHCD_ENDPOINT_SCHEDULE schedule = &DeviceExtension->Schedule;
    UCHAR   node, nodeTemp, nodeMin, nodeMax, nodeBest;
    USHORT  bestBandwidth, nodeBandwidth;

    /*
    **  See the OpenHCI specification for a nice diagram of the schedule
    **  tree.  Note that the implementation here differs significantly
    **  then example code in the specification and from the win2k and
    **  win98 implementation.  In this those examples a static tree of
    **  endpoint descriptors is constructed that always have their skip
    **  bits set.
    **
    **  Here we have a static array of OHCD_INTERRUPT_SCHEDULE_NODE structures.
    **  Their purpose is two serve as a pointerless static binary tree
    **  for storing endpoint lists which are inserted at the same node in
    **  the schedule.  The array is static and it turns out that the tree
    **  can be traversed very easily and efficiently with bit manipulations.
    **  For example, given a pollin interval that is of a power of 2 (as
    **  more or less required by OpenHCI) it is easy to find the eligible
    **  nodes:  Node 0 is dedicated to isochronous endpoints.  Otherwise,
    **  the first eligible node index equals the polling interval.  There
    **  all nodes are eligible up to twice the polling interval minus.  i.e.
    **  if nodeMin = Polling Interval, than nodeMax = 2*nodeMin-1 or as in
    **  code you can shift left to perform the multiplication.
    **  The parent of a node (i.e. the level with shorter intervals) can be
    **  found by shifting the node index one bit to the right. The first child
    **  (i.e. longer polling intervals) requires shifting the node index one
    **  bit to the left.  The second child is one bit to the left plus one.
    **  Calculating these indices is easy and relieves a good deal of pointer
    **  storage overhead.
    **  
    **  Because we use an independent data structure rather than endpoint
    **  descriptors, we do not burden the endpoint descriptor with as
    **  much extra overhead.  Consequently, our transfer descriptors(TDs) and ED
    **  are 32 bytes long not 64.  The act of inserting an ED in the
    **  schedule is in two stages.  First we inset the Endpoint in a node
    **  in the InterruptSchedule.  Then we have to fix up the HCCA and ED 
    **  pointers to reflect the new change.
    **
    **  We treat the requested PollingInterval (from the USB Endpoint Desriptor -
    **  not to be confused with OpenHCI Endpoint Descriptor) as a maximum.
    **  Thus a requested interval of 10 ms, will end up in an 8 ms
    **  polling node.
    **/
    USB_DBG_ENTRY_PRINT(("Entering OHCD_ScheduleAddEndpointPeriodic"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    //  1) Finding the minimum node in the polling interval which is
    //  a power of 2 and less than the requested interval
    //

    if(USB_ENDPOINT_TYPE_INTERRUPT == Endpoint->EndpointType)
    //
    //  If it is interrupt we need to find the node with the most
    //  open bandwidth
    //
    {
        for(nodeMin = 32; nodeMin > Endpoint->PollingInterval; nodeMin >>= 1);
        USB_DBG_TRACE_PRINT(("Requested Polling Interval = %d, Actual Interval = %d.", Endpoint->PollingInterval, (ULONG)nodeMin));
        nodeMax = 2*nodeMin - 1;

    
        //
        //  2) Now check the bandwidth allocation for the worst case frame
        //  which intersects each eligible node.  Note the node with the
        //  least allocated (i.e. least used up) bandwidth.  The formula for this
        //  is to add up BandwidthChildren (already calculated to be
        //  the worst case frame), Bandwidth(i.e. of this node), and the
        //  BandwidthParents.  Each of these variables are maintained across
        //  the tree when an endpoint is inserted (later in this routine)
        //  or when an endpoint is removed from the schedule.
        //
        bestBandwidth = 12000;  //Certainly larger than the available bandwidth
        for(node = nodeMin; node <= nodeMax; node++)
        {
            nodeBandwidth = schedule->InterruptSchedule[node].BandwidthChildren +
                            schedule->InterruptSchedule[node].Bandwidth +
                            schedule->InterruptSchedule[node].BandwidthParents;
            if(nodeBandwidth < bestBandwidth)
            {
                bestBandwidth = nodeBandwidth;
                nodeBest = node;
                USB_DBG_TRACE_PRINT(("Found better node: bestBandwidth = %d, nodeBest = %d.", bestBandwidth , (ULONG)nodeBest));
            }
        }
    }
    else
    //
    //  If it isochronous we know that it is node zero and we either have
    //  the bandwidth or not.
    //
    {
        bestBandwidth = schedule->InterruptSchedule[0].BandwidthChildren +
                        schedule->InterruptSchedule[0].Bandwidth;
        nodeBest = 0;
    }

    //
    //  3) Is there room for this endpoint in the best node?
    //
    if( (bestBandwidth + Endpoint->Bandwidth) > schedule->BandwidthPeriodic )
    {
        USB_DBG_ERROR_PRINT((
            "INSUFFICIENT BANDIWDTH:\n Requested Bandwidth = %d bits/ms\nBest Node = %d\nBandwidth Available = %d bits/ms\n",
            (ULONG)Endpoint->Bandwidth,
            (ULONG)nodeBest,
            (ULONG)(schedule->BandwidthPeriodic - bestBandwidth)
            ));
        return USBD_STATUS_NO_BANDWIDTH;
    }
    Endpoint->ScheduleIndex = nodeBest;

    //
    //  4) Recalculate the bandwidth tables:
    //      a) Update the bandwidth of our node
    //      b) Propogate the change to the BandwidthParents
    //      variable to all of our children.
    //      c) Propogate the change to the Bandwidth Children
    //      to our parents as long as our branch is the worst
    //      case.

    //  a) ours
    schedule->InterruptSchedule[nodeBest].Bandwidth += Endpoint->Bandwidth;

    //  b) BandwidthParents of Childern
    //  We don't need a real recursion.  Since we are a regular binary tree.
    //  We just walk the side branches and iterate in between.
    //
    if(nodeBest == 0)
    {
        //
        //  Things are different for isochronous.
        //
        nodeMin = nodeMax = 1;
    }
    else
    {
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(nodeBest);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(nodeBest);
    }
    while(nodeMax <=64)
    {
        for(node = nodeMin; node <= nodeMax; node++)
        {
            schedule->InterruptSchedule[node].BandwidthParents += Endpoint->Bandwidth;
        }
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(nodeMin);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(nodeMax);
    }

    //  c) BandwidthChildren to parents
    node = nodeBest;
    while(node > 1)
    {

        //
        //  make nodeTemp point our sibiling
        //
        nodeTemp = OHCD_GET_SIBLING_INTERRUPT_INDEX(node);

        //
        //  If the sibling node and its children use
        //  more bandwidth than the path we are going
        //  down than we can stop, because nothing
        //  beneath needs to change.
        //
        if( 
            (schedule->InterruptSchedule[node].BandwidthChildren
            + schedule->InterruptSchedule[node].Bandwidth)
            <=
            (schedule->InterruptSchedule[nodeTemp].BandwidthChildren
            + schedule->InterruptSchedule[nodeTemp].Bandwidth)
        ) break;

        //
        //  make nodeTemp point to the parent
        //
        nodeTemp = OHCD_GET_PARENT_INTERRUPT_INDEX(node);

        //
        //  Fix parents bandwidth
        //
        schedule->InterruptSchedule[nodeTemp].BandwidthChildren =
            schedule->InterruptSchedule[node].BandwidthChildren +
            schedule->InterruptSchedule[node].Bandwidth;

        //
        //  Ready another iteration (parent becomes new node)
        //
        node = nodeTemp;
    }
    if(node == 1)
    {
        //
        //  if node = 1, it is possible that one was changed, so 
        //  we should update o (for isochronous) which we can
        //  do safely whether it needs updating or not.
        //
        schedule->InterruptSchedule[0].BandwidthChildren =
                schedule->InterruptSchedule[1].BandwidthChildren +
                schedule->InterruptSchedule[1].Bandwidth;
    }

    //
    //  5) Insert the endpoint into the InterruptSchedule.
    //
    
    if(NULL == schedule->InterruptSchedule[nodeBest].EndpointHead)
    {
        USB_DBG_TRACE_PRINT(("Node %d is empty", (ULONG)nodeBest));
        ASSERT(NULL == schedule->InterruptSchedule[nodeBest].EndpointTail);
    
        //
        //  6-a) Hook up new endpoint physical address
        //  to next endpoint, if there is one.
        node = OHCD_GET_PARENT_INTERRUPT_INDEX(nodeBest);
        while( !schedule->InterruptSchedule[node].EndpointHead && node)
        {
            node = OHCD_GET_PARENT_INTERRUPT_INDEX(node);
        }
        if(schedule->InterruptSchedule[node].EndpointHead)
        {
            ASSERT(NULL != schedule->InterruptSchedule[node].EndpointHead);
            USB_DBG_TRACE_PRINT(("Updating new endpoint to link to head of node %d", (ULONG)node));
            Endpoint->HcEndpointDescriptor.NextED = schedule->InterruptSchedule[node].EndpointHead->PhysicalAddress;
        } else
        {
            //
            //  The endpoint memory should have been zeroed when it was allocated.
            //
            ASSERT(0==Endpoint->HcEndpointDescriptor.NextED);
        }

        //
        //  This must be after the above block so isoch works,
        //  because Node 0 is its own parent.
        //
        schedule->InterruptSchedule[nodeBest].EndpointHead = Endpoint;
        schedule->InterruptSchedule[nodeBest].EndpointTail = Endpoint;
        Endpoint->Next = NULL;
    }
    else
    {
        
        ASSERT(NULL != schedule->InterruptSchedule[nodeBest].EndpointTail);
        Endpoint->Next = schedule->InterruptSchedule[nodeBest].EndpointHead;
        schedule->InterruptSchedule[nodeBest].EndpointHead = Endpoint;
        //
        //  6-a) Hook up new endpoint physical address
        //  to next endpoint.
        Endpoint->HcEndpointDescriptor.NextED = Endpoint->Next->PhysicalAddress;
    }
    //
    //  Walk down children and ensure that new endpoint physical address
    //  is in all chains.
    //
    OHCD_HookNewEndpointToChildren(DeviceExtension, Endpoint->PhysicalAddress, nodeBest);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_ScheduleAddEndpointPeriodic"));
    return USBD_STATUS_SUCCESS;
}

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointPeriodic(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Removes a periodic (interrupt or isochronous) endpoint from the interrupt schedule.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to remove

Return Value:

    None.

--*/
{
    POHCD_ENDPOINT_SCHEDULE schedule = &DeviceExtension->Schedule;
    UCHAR node = Endpoint->ScheduleIndex;
    UCHAR nodeMin, nodeMax, nodeTemp, nodeParent;
    POHCD_ENDPOINT previousEndpoint, currentEndpoint;
    ULONG nextPhysicalAddress;
    USHORT endpointBandwidth = Endpoint->Bandwidth;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_ScheduleRemoveEndpointPeriodic"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Find endpoint in node list and remove it
    //
    previousEndpoint = NULL;
    currentEndpoint = schedule->InterruptSchedule[node].EndpointHead;
    do
    {
        if(currentEndpoint == Endpoint) break;
        previousEndpoint = currentEndpoint;
        currentEndpoint = currentEndpoint->Next;
    } while(currentEndpoint);
    //
    //  If this assertion fails, than the endpoint 
    //  is not in the schedule.
    ASSERT(Endpoint == currentEndpoint);
    //
    //  If we were the tail, update the tail pointer.
    //
    if(NULL == currentEndpoint->Next)
    {
        schedule->InterruptSchedule[node].EndpointTail = previousEndpoint;
        //
        //  Find the physical address of the next endpoint, if there is one.
        //
        nextPhysicalAddress = 0;
        if(node)  // The tail of the node 0, never has an endpoint after it.
        {
            nodeTemp = OHCD_GET_PARENT_INTERRUPT_INDEX(node);
            while( !schedule->InterruptSchedule[nodeTemp].EndpointHead && nodeTemp)
            {
                nodeTemp = OHCD_GET_PARENT_INTERRUPT_INDEX(nodeTemp);
            }
            if(schedule->InterruptSchedule[nodeTemp].EndpointHead)
            {
                nextPhysicalAddress = schedule->InterruptSchedule[nodeTemp].EndpointHead->PhysicalAddress;
            }
        }
    } else
    {
        nextPhysicalAddress = currentEndpoint->Next->PhysicalAddress;
    }
    //
    //  If we were the head, update the pointer.
    //  
    if(NULL == previousEndpoint)
    {
        schedule->InterruptSchedule[node].EndpointHead = currentEndpoint->Next;
        //
        // recurse to update physical pointers
        //
        OHCD_HookNewEndpointToChildren(
                    DeviceExtension, 
                    nextPhysicalAddress,
                    node
                    );
    }
    else
    //
    //  We were not the head, so update the endpoint
    //  in front of us
    //
    {
        previousEndpoint->Next = currentEndpoint->Next;
        //
        //  Just update physical address of previous endpoint
        //
        previousEndpoint->HcEndpointDescriptor.NextED = nextPhysicalAddress;
    }
    
    //
    //  Recalculate the bandwidth tables:
    //      a) Update the bandwidth of our node
    //      b) Propogate the change to the BandwidthParents
    //      variable to all of our children.
    //      c) Propogate the change to the Bandwidth Children
    //      to our parents as long as our branch is the worst
    //      case.

    //  a) ours
    schedule->InterruptSchedule[node].Bandwidth -= endpointBandwidth;

    //  b) BandwidthParents of Childern
    //  We don't need a real recursion.  Since we are a regular binary tree.
    //  We just walk the side branches and iterate in between.
    //
    if(node == 0)
    {
        //
        //  Things are different for isochronous.
        //
        nodeMin = nodeMax = 1;
    }
    else
    {
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(node);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(node);
    }
    while(nodeMax <=64)
    {
        for(nodeTemp = nodeMin; nodeTemp <= nodeMax; nodeTemp++)
        {
            schedule->InterruptSchedule[nodeTemp].BandwidthParents -= Endpoint->Bandwidth;
        }
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(nodeMin);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(nodeMax);
    }

    //  c) BandwidthChildren to parents
    while(node > 1)
    {
        //
        //  make nodeTemp point to our sibiling
        //  make nodeParent point to our parent
        //
        nodeTemp = OHCD_GET_SIBLING_INTERRUPT_INDEX(node);
        nodeParent = OHCD_GET_PARENT_INTERRUPT_INDEX(node);

        //
        //  If the sibling node and its children use
        //  more bandwidth than the we can switch 
        //  to the sibling node.
        //
        if( 
            (schedule->InterruptSchedule[node].BandwidthChildren
            + schedule->InterruptSchedule[node].Bandwidth)
            <=
            (schedule->InterruptSchedule[nodeTemp].BandwidthChildren
            + schedule->InterruptSchedule[nodeTemp].Bandwidth)
        )
        {
            //
            //  If the sibling and its children's bandwidth is the same as recorded
            //  for the parent's child, then we can stop.
            //
            if(
                (schedule->InterruptSchedule[nodeTemp].BandwidthChildren + schedule->InterruptSchedule[nodeTemp].Bandwidth) 
                == schedule->InterruptSchedule[nodeParent].BandwidthChildren
            ) {
             break;
            } else
            //
            //  Otherwise, keep walking, but switch to using the sibilings bandwidth
            //
            {
                node = nodeTemp;
            }
        }

        //
        //  Fix parents bandwidth
        //
        schedule->InterruptSchedule[nodeParent].BandwidthChildren =
            schedule->InterruptSchedule[node].BandwidthChildren +
            schedule->InterruptSchedule[node].Bandwidth;
        //
        //  Ready another iteration (parent becomes new node)
        //
        node = nodeParent;
    }
    if(node == 1)
    {
        //
        //  if node = 1, it is possible that one was changed, so 
        //  we should update o (for isochronous) which we can
        //  do safely whether it needs updating or not.
        //
        schedule->InterruptSchedule[0].BandwidthChildren =
                schedule->InterruptSchedule[1].BandwidthChildren +
                schedule->InterruptSchedule[1].Bandwidth;
    }

    USB_DBG_EXIT_PRINT(("Exiting OHCD_ScheduleRemoveEndpointPeriodic"));
}

VOID
FASTCALL
OHCD_ScheduleAddEndpointControlOrBulk(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Adds a control or bulk endpoint to the schedule

Arguments:

    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to Add

Return Value:

    None.

--*/

{
    POHCD_ENDPOINT *listHead;
    PULONG          listHeadPhysical;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Control Pipe
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        listHead            = &DeviceExtension->Schedule.ControlHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcControlHeadED;
    }
    else
    //
    //  Bulk pipe
    //
    {
        listHead            = &DeviceExtension->Schedule.BulkHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcBulkHeadED;
    }
    //
    //  insert at head
    //
    Endpoint->Next = *listHead;
    *listHead = Endpoint;
    //
    //  Fixup physical pointers
    //
    if(NULL == Endpoint->Next)
    {
        Endpoint->HcEndpointDescriptor.NextED = 0;
    }
    else
    {
        Endpoint->HcEndpointDescriptor.NextED =
                    Endpoint->Next->PhysicalAddress;
    }
    *listHeadPhysical = Endpoint->PhysicalAddress;
}

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointControlOrBulk(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Removes a control or bulk endpoint from the schedule.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to remove

Return Value:

    None.

--*/
{
    POHCD_ENDPOINT *listHead;
    POHCD_ENDPOINT  previousEndpoint, currentEndpoint;
    PULONG          listHeadPhysical;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_ScheduleRemoveEndpointControlOrBulk"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Control Pipe
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        listHead            = &DeviceExtension->Schedule.ControlHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcControlHeadED;
    }
    else
    //
    //  Bulk pipe
    //
    {
        listHead            = &DeviceExtension->Schedule.BulkHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcBulkHeadED;
    }

    //
    // Find the Endpoint in the list
    //
    previousEndpoint = NULL;
    currentEndpoint = *listHead;
    do
    {
        //stop when we find it
        if(Endpoint == currentEndpoint) break;
        previousEndpoint = currentEndpoint;
        currentEndpoint = currentEndpoint->Next;
    } while( currentEndpoint);
    ASSERT( NULL != currentEndpoint);

    //
    //  Remove from list (virtual and physical).
    //  Notice carefully that we do not change
    //  currentEndpoint->EndpointDescriptor->HcEndpointDescriptor.NextED.
    //  This way if this endpoint is being processed, nothing breaks.
    //  If we wait a frame we can safely remove it.  We do not even
    //  need to pause the endpoint!
    //
    if(previousEndpoint)
    {
        previousEndpoint->Next = currentEndpoint->Next;
        previousEndpoint->HcEndpointDescriptor.NextED =
            currentEndpoint->HcEndpointDescriptor.NextED;
    }
    else
    {
        *listHead = currentEndpoint->Next;
        *listHeadPhysical = 
            currentEndpoint->HcEndpointDescriptor.NextED;
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ScheduleRemoveEndpointControlOrBulk"));
}


//----------------------------------------------------------------------------
// Implementation of local helper routines:
//      OHCD_HookNewEndpointToChildren
//      OHCD_ReverseBits
//----------------------------------------------------------------------------

VOID
FASTCALL
OHCD_HookNewEndpointToChildren(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    ULONG                   EndpointPhysicalAddress,
    UCHAR                   ParentNode
    )
/*++

Routine Description:

    Helper function to recurse children in the schedule
    table and insert a pointer to the new endpoint.  Used
    for both inserting an endpoint and removing one.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.

Return Value:

    None.

--*/
{
    //USB_DBG_ENTRY_PRINT(("Entering OHCD_HookEndpointToChildren: ParentNode = %d", ParentNode));
    if(ParentNode >= 32)
    //
    //  This node is at the top of the
    //  tree, just fix up HCCA and we are done.
    //  
    {
        POHCI_HCCA  hcca;
        hcca = DeviceExtension->HCCA;
        hcca->InterruptTable[OHCD_ReverseBits(5, ParentNode - 32)] = 
            EndpointPhysicalAddress;
    }
    else
    //
    // Not at the top of the tree, we have two children,
    // deal with one at a time
    //
    {
        UCHAR nodeChild;
        UCHAR index;
        POHCD_INTERRUPT_SCHEDULE_NODE interruptSchedule;
        interruptSchedule = &DeviceExtension->Schedule.InterruptSchedule[0];
        nodeChild = OHCD_GET_CHILD2_INTERRUPT_INDEX(ParentNode);
        for(index = 0; index < 2; index ++) 
        {
            if(NULL == interruptSchedule[nodeChild].EndpointHead)
            //
            //  If this node is empty, skip it and go on to its children
            //
            {
                ASSERT(NULL == interruptSchedule[nodeChild].EndpointTail);
                //USB_DBG_TRACE_PRINT(("Node %d is empty, recursing", nodeChild));
                OHCD_HookNewEndpointToChildren(
                                    DeviceExtension,
                                    EndpointPhysicalAddress,
                                    nodeChild
                                    );
            }
            else
            //
            //  We can fix up this child.
            //
            {
                ASSERT(NULL != interruptSchedule[nodeChild].EndpointTail);
                /*USB_DBG_WARN_PRINT(("Node %d has members: Head = 0x%0.8x; Tail = 0x%0.8x",
                                            nodeChild,
                                            interruptSchedule[nodeChild].EndpointHead,
                                            interruptSchedule[nodeChild].EndpointTail));*/
                interruptSchedule[nodeChild].EndpointTail->HcEndpointDescriptor.NextED = EndpointPhysicalAddress;
            }
            nodeChild = OHCD_GET_CHILD1_INTERRUPT_INDEX(ParentNode);
            //
            //  It is possible that this is the isochronous node,
            //  if so skip the second iteration.
            if(!nodeChild) break;
        }
    }
    //USB_DBG_EXIT_PRINT(("Exiting OHCD_HookEndpointToChildren: ParentNode = %d", ParentNode));
    return;
}

ULONG 
FASTCALL
OHCD_ReverseBits(
    ULONG NumBits,
    ULONG Value)
/*++

Routine Description:

    Helper function to reverse the NumBits
    least significant bits of value (Assume
    remaining bits are 0).

Arguments:
    
    NumBits - number of bits to reverse.
    Value   - value to reverse.

Return Value:

    None.

--*/
{
    ULONG result = 0;
    ULONG index;
    for(index = 0; index < NumBits; index++)
    {
        result <<= 1;
        result += Value&1;
        Value >>= 1;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbd\usbd.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usbd.c

Abstract:

    USBD System Driver Main Entry Points
    and Initialization

Environment:

    XBOX kernel mode only

Notes:

Revision History:

    12-28-99 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBD");


#pragma data_seg(".XPP$ClassA")
extern "C" DWORD USBD_BeginClassDescriptionTable = 0;
#pragma data_seg(".XPP$ClassZ")
extern "C" DWORD USBD_EndClassDescriptionTable = 0;
#pragma data_seg(".XPP$Data")

//  Tells the linker to merge the USB sections together
#pragma comment(linker, "/merge:.XPPCODE=XPP")
#pragma comment(linker, "/merge:.XPPRDATA=XPP")
#pragma comment(linker, "/merge:.XPPCINIT=XPP")
#pragma comment(linker, "/merge:.XPPRINIT=XPP")
#pragma comment(linker, "/merge:.XPP=XPP")
#pragma comment(linker, "/merge:.XPPDINIT=XPP")

// Tell the linker that the code section contains read/write data.
#pragma comment(linker, "/section:XPP,ERW")

//
//  Pull in usbd headers
//
#include <usbd.h>


//----------------------------------------------------------------------------------
// Globals - all of which must be initialized in DriverEntry
//----------------------------------------------------------------------------------
UCHAR  GLOBAL_HostControllerCount;

//----------------------------------------------------------------------------------------------
//  Just a simple inline new and matching delete that uses RTL_ALLOCATE_HEAP
//----------------------------------------------------------------------------------------------
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize){return RTL_ALLOCATE_HEAP(memSize);}
static __inline void __cdecl operator delete(void *buffer){RTL_FREE_HEAP(buffer);}
#pragma warning(default:4211)

//----------------------------------------------------------------------------------
//  Top level entry points called by the I\O Manager
//----------------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID USBD_Init(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes) 
/*++

Routine Description:
    
    Standard DriverEntry Routine - Let's libraries initialize globals,
    then fills out dispatch table and returns success.

Arguments:
    
    DriverObject - Pointer to DriverObject

    RegistryPath - Pointer to RegistryPath

Return Value:

    None.

--*/
{
    USB_DBG_ENTRY_PRINT(("Entering USBD_Init"));
    USB_DBG_TRACE_PRINT(("Built on %s @%s", __DATE__,__TIME__));

    IUsbInit *pUsbInit = new IUsbInit(NumDeviceTypes, DeviceTypes);

    //
    //  Walk the class drivers and call their init functions
    //
    PUSB_CLASS_DRIVER_DESCRIPTION *ppClassDriverDesc;
    ppClassDriverDesc = (PUSB_CLASS_DRIVER_DESCRIPTION *)((&USBD_BeginClassDescriptionTable)+1);
    while( (ULONG_PTR)ppClassDriverDesc < (ULONG_PTR)&USBD_EndClassDescriptionTable  )
    {
        if(*ppClassDriverDesc) (*ppClassDriverDesc)->Init(pUsbInit);
        ppClassDriverDesc++;
    }

    pUsbInit->Process();
    
    //
    //  Give the HCD a chance to initialize its globals.
    //
    HCD_DriverEntry(pUsbInit->GetHcdResourcePtr());

    //
    // Initialize the device tree
    // 
    g_DeviceTree.Init(pUsbInit->GetNodeCount(), pUsbInit->GetMaxCompositeInterfaces());

    //
    //  We are done with the IUsbInit object
    //
    delete pUsbInit;

    GLOBAL_HostControllerCount=0;
    //
    //  Call the HCD layer to enumerate the hardware.
    //
    HCD_EnumHardware();
    USB_DBG_EXIT_PRINT(("Exiting USBD_Init"));
}

VOID
USBD_NewHostController(
    IN PPCI_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG HcdDeviceExtensionSize
    )
/*++

Routine Description:
    
    Called by the HCD_EnumHardware for every host controller
    it finds.

    We do the following:

    a1. Create a device. (Actually, we need only the extensions not the device objects)
    2. Initialize the USBD portion of the of the device
    3. Call HCD_NewHostController to initialize the hardware portion.

Arguments:
    
    PciDevice - PCI descriptor to pass back to the hardware initialization later.
    HcdDeviceExtensionSize - Size of HCD portion of host controller context.
   
Return Value:

    None - what good does it do to annouce failure anyway.

--*/
{
    PUSBD_HOST_CONTROLLER  hostController;

    USB_DBG_ENTRY_PRINT(("Entering USBD_NewHostController"));

    //
    //  Allocate the Host Controller
    //
    hostController = (PUSBD_HOST_CONTROLLER)RTL_ALLOCATE_HEAP(sizeof(USBD_HOST_CONTROLLER) + HcdDeviceExtensionSize);
    
    if(hostController)
    {
        //
        //  Zero out the whole memory we just allocated.  We do this for our extension
        //  and for the HCD's.
        //
        RtlZeroMemory(hostController, sizeof(USBD_HOST_CONTROLLER) + HcdDeviceExtensionSize);

        //
        //  We need to number our controllers, so the game can distinguish
        //
        hostController->ControllerNumber = ++GLOBAL_HostControllerCount;

        USB_DBG_TRACE_PRINT(("Host Controller #%d Found:", hostController->ControllerNumber));
        USB_DBG_TRACE_PRINT(("HCD extension = 0x%0.8x:", USBD_GetHCDExtension(hostController)));
        
        //
        //  Add a RootHub device for this host controller.
        //
        hostController->RootHub = g_DeviceTree.AllocDevice();
        ASSERT(hostController->RootHub);
        hostController->RootHub->m_Type = UDN_TYPE_ROOT_HUB;
        hostController->RootHub->m_FirstChild = UDN_INVALID_NODE_INDEX;
        hostController->RootHub->m_Parent = UDN_INVALID_NODE_INDEX;
        hostController->RootHub->m_Sibling = UDN_INVALID_NODE_INDEX;
		hostController->RootHub->m_HostController = hostController;
        
        //
        //  Initialize the hardware
        //
        HCD_NewHostController(USBD_GetHCDExtension(hostController), hostController->ControllerNumber, PciDevice);
    }
    USB_DBG_EXIT_PRINT(("Exiting USBD_NewHostController"));
    return;
}
#pragma code_seg(".XPPCODE")

VOID
USBD_CompleteRequest(
    IN  PURB Urb
    )
/*++

Routine Description:

    Entry point called by HCD (and a few places in USBD) to complete an URB.
    Basically, it calls the completion routine if there is one.
    
Arguments:
    
    Urb - The URB that was just completed.

Return Value:

--*/
{
    //
    //  If there is a completion routine than call it.
    //
    if(Urb->Header.CompleteProc)
    {
        USB_DBG_TRACE_PRINT(("Calling the completion routine @0x%0.8x for URB @0x%0.8x.",
                    Urb->Header.CompleteProc, Urb));
        Urb->Header.CompleteProc(Urb, Urb->Header.CompleteContext);
    }
}


USHORT
USBD_CalculateUsbBandwidth(
    IN USHORT   MaxPacketSize,
    IN UCHAR    EndpointType,
    IN BOOLEAN  LowSpeed
    )
/*++

Routine Description:

Arguments:

Return Value:

    banwidth consumed in bits/ms, returns 0 for bulk
    and control endpoints

--*/
{
    USHORT bw;

    //
    // control, iso, bulk, interrupt
    //

    ULONG overhead[4] = {
            0,
            USB_ISO_OVERHEAD_BYTES,
            0,
            USB_INTERRUPT_OVERHEAD_BYTES
          };

    ASSERT(EndpointType<4);

    //
    // Calculate bandwidth for endpoint.  We will use the
    // approximation: (overhead bytes plus MaxPacket bytes)
    // times 8 bits/byte times worst case bitstuffing overhead.
    // This gives bit times, for low speed endpoints we multiply
    // by 8 again to convert to full speed bits.
    //

    //
    // Figure out how many bits are required for the transfer.
    // (multiply by 7/6 because, in the worst case you might
    // have a bit-stuff every six bits requiring 7 bit times to
    // transmit 6 bits of data.)
    //

    // overhead(bytes) * maxpacket(bytes/ms) * 8
    //      (bits/byte) * bitstuff(7/6) = bits/ms

    bw = (USHORT)(((overhead[EndpointType]+MaxPacketSize) * 8 * 7) / 6);

    // return zero for control or bulk
    if (!overhead[EndpointType]) {
        bw = 0;
    }

    if (LowSpeed) {
        bw *= 8;
    }

    return bw;
}

PUSB_CLASS_DRIVER_DESCRIPTION USBD_FindClassDriver(PNP_CLASS_ID ClassId)
{
	PUSB_CLASS_DRIVER_DESCRIPTION *ppMatch;

    //
	//	Match only the class and class specific type.
	//  The class specific type has a slightly different meaning here.
    //  In this context ir is whether the device is interface level or
    //  device level.  Later the class driver will set it to be something
    //  which is really class specific.
    //
	ppMatch = (PUSB_CLASS_DRIVER_DESCRIPTION *)((&USBD_BeginClassDescriptionTable)+1);
    while( (ULONG_PTR)ppMatch < (ULONG_PTR)&USBD_EndClassDescriptionTable)
	{
		if(
            *ppMatch && 
            (ClassId.USB.bClass == (*ppMatch)->ClassId.USB.bClass) &&
            (ClassId.USB.bClassSpecificType == (*ppMatch)->ClassId.USB.bClassSpecificType)
        )
        {
            goto found_match;
        }
		ppMatch++;
	}
    return NULL;

found_match:

    return (*ppMatch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbd\usbd.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usbd.h

    Generated from usb.x

Abstract:

    Private Header for USBD internal modules

Environment:

    Xbox
    C++ Only

--*/

#ifndef __USB_X__
#define __USB_X__

#ifndef __cplusplus
#error "usb.h may only be included by C++ modules"
#endif

#define EXTERNUSB extern "C"

//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")

#include <usb100.h>

//
// XBOX platform USB device classes
//

#define XBOX_DEVICE_CLASS_INPUT_DEVICE              0x58
#define XBOX_DEVICE_CLASS_XDCS                      0x59
#define XBOX_DEVICE_CLASS_AUDIO_DEVICE              0x78

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          10 - completed with error, endpoint not stalled
//          11 - completed with error, endpoint stalled
//
//
//      Code - is the status code
//

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)

//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)

//
//	Status returned by hub, when a reset completes successfully and the
//	device is low-speed.
//
#define USBD_STATUS_LOWSPEED				 ((USBD_STATUS)0x01000000L)

extern "C" {

//------------------------------------------------------------------------------------
// URB Function Codes   - High bit indicates that USBD (pre-)processes URB
//------------------------------------------------------------------------------------
//-- special bit in URB_FUNCTION codes -----------------
#define URB_FUNCTION_USBD_PROCESSED                 0x80    
#define URB_FUNCTION_ASYNCHRONOUS                   0x40
//------------------------------------------------------
#define URB_FUNCTION_CONTROL_TRANSFER               (0x00 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     (0x01 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_OPEN_ENDPOINT                  0x02
#define URB_FUNCTION_CLOSE_ENDPOINT                 (0x03 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_ENDPOINT_STATE             0x04
#define URB_FUNCTION_SET_ENDPOINT_STATE             0x05
#define URB_FUNCTION_ABORT_ENDPOINT                 (0x06 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_FRAME_NUMBER               0x07
#define URB_FUNCTION_OPEN_DEFAULT_ENDPOINT          (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_OPEN_ENDPOINT)
#define URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT         (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_CLOSE_ENDPOINT)
#define URB_FUNCTION_RESET_PORT                     (URB_FUNCTION_USBD_PROCESSED | 0x08)
#define URB_FUNCTION_ISOCH_OPEN_ENDPOINT            0x09
#define URB_FUNCTION_ISOCH_CLOSE_ENDPOINT           (0x0A | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_ISOCH_ATTACH_BUFFER            0x0B
#define URB_FUNCTION_ISOCH_START_TRANSFER           0x0C
#define URB_FUNCTION_ISOCH_STOP_TRANSFER            0x0D

//------------------------------------------------------------------------------------
//  Values for the transfer directions
//------------------------------------------------------------------------------------
#define USB_TRANSFER_DIRECTION_OUT              0x01
#define USB_TRANSFER_DIRECTION_IN               0x02

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_GET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_HALTED              	0x01    //Set on return if endpoint is halted.
#define USB_ENDPOINT_STATE_TRANSFERS_QUEUED     0x02    //Set on return if one or more transfers are queued to endpoint.

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_SET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_CLEAR_HALT		    0x00    //Clear endpoint halt.
#define USB_ENDPOINT_STATE_KEEP_HALT		    0x01    //Do not clear enddpoint halt
#define USB_ENDPOINT_STATE_DATA_TOGGLE_RESET    0x04    //Reset data toggle. (i.e. DATA0)
#define USB_ENDPOINT_STATE_DATA_TOGGLE_SET      0x08    //Set data toggle. (i.e. DATA1), provided for testing.
//There is no USB_ENDPOINT_STATE_SET_HALT, since only the hardware may set it.

//----------------------------------------------------------------------------------------------------------------------
// Macros for the InterruptDelay variable in transfer and attach buffer URBs - this is really an OpenHCI thing,
// but gives more control to class drivers.  These are the same as OHCI_TD_DELAY_INTERRUPT_XXX
// DUE TO BUG 9512 IT IS ONLY SAFE TO USE USBD_DELAY_INTERRUPT_0_MS.  OTHERWISE, YOU MAY EXPERIENCE PROBLEMS
// WHEN CLOSING THE ENDPOINT.  SEE BUG 9512 FOR MORE DETAILS.
//----------------------------------------------------------------------------------------------------------------------
#define USBD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define USBD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define USBD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 4 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 5 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_6_MS        6   // Interrupt within  frame of TD compeletion
#define USBD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD

//------------------------------------------------------------------------------------
// USBD Structures for class drivers
//------------------------------------------------------------------------------------
typedef union _URB *PURB;
typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

//
//  See approptate HCD header file for
//  for flags.
//
struct _URB_HCD_AREA
{
    union
    {
        USHORT  HcdTDCount;
        USHORT  HcdOriginalLength;  //While programed contains the original length
    
	};
    USHORT  HcdUrbFlags;
	PURB    HcdUrbLink;     //Used while the URB is pending
};

struct _URB_HEADER
{
    UCHAR               Length;
    UCHAR               Function;
    USBD_STATUS         Status;
    PURB_COMPLETE_PROC  CompleteProc;       // A completetion routine if the URB is not associated with an Irp
    PVOID               CompleteContext;    // Context to pass into the completion routine.
};

typedef struct _USB_CONTROL_SETUP_PACKET
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_CONTROL_SETUP_PACKET;

typedef struct _URB_CONTROL_TRANSFER
{
    struct _URB_HEADER          Hdr;                    
    PVOID                       EndpointHandle;
    ULONG                       TransferBufferLength;
    PVOID                       TransferBuffer;
    UCHAR                       TransferDirection;
    BOOLEAN                     ShortTransferOK;
    UCHAR                       InterruptDelay;
    UCHAR                       Padding;
    struct _URB_HCD_AREA        Hca;
    USB_CONTROL_SETUP_PACKET    SetupPacket;
} URB_CONTROL_TRANSFER, *PURB_CONTROL_TRANSFER;

typedef struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   TransferBufferLength;
    PVOID                   TransferBuffer;
    UCHAR                   TransferDirection;
    BOOLEAN                 ShortTransferOK;
    UCHAR                   InterruptDelay;
    UCHAR                   Padding;
    struct _URB_HCD_AREA    Hca;   // fields for HCD use
} URB_BULK_OR_INTERRUPT_TRANSFER, *PURB_BULK_OR_INTERRUPT_TRANSFER;


typedef struct _URB_OPEN_ENDPOINT
{
    struct _URB_HEADER          Hdr;
    PVOID                       EndpointHandle;
    UCHAR                       FunctionAddress;
    UCHAR                       EndpointAddress;
    UCHAR                       EndpointType;
    UCHAR                       Interval;
    PULONG                      DataToggleBits; // Filled out by USBD
    USHORT                      MaxPacketSize;
    BOOLEAN                     LowSpeed;   //Temporary - filled out by USBD
} URB_OPEN_ENDPOINT, *PURB_OPEN_ENDPOINT;

typedef struct _URB_CLOSE_ENDPOINT
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    PURB                   HcdNextClose;   // An extra pointer which Hcd can use to link pending closes.
    PULONG                 DataToggleBits; // Filled out by USBD
} URB_CLOSE_ENDPOINT, *PURB_CLOSE_ENDPOINT;

typedef struct _URB_GET_SET_ENDPOINT_STATE
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   EndpointState;
} URB_GET_SET_ENDPOINT_STATE, *PURB_GET_SET_ENDPOINT_STATE;

typedef struct _URB_ABORT_ENDPOINT
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    PURB                    HcdNextAbort;   // An extra pointer which Hcd can use to link pending aborts.
} URB_ABORT_ENDPOINT, *PURB_ABORT_ENDPOINT;

typedef struct _URB_RESET_PORT
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    UCHAR               PortNumber;
} URB_RESET_PORT, *PURB_RESET_PORT;

typedef struct _URB_GET_FRAME_NUMBER
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    ULONG               FrameNumber;
} URB_GET_FRAME_NUMBER, *PURB_GET_FRAME_NUMBER;


//------------------------------------------------
// Isoch related URBs and related structures
//------------------------------------------------
typedef struct _USBD_ISOCH_PACKET_STATUS_WORD
{
    USHORT BytesRead:12;
    USHORT ConditionCode:4;
} USBD_ISOCH_PACKET_STATUS_WORD, *PUSBD_ISOCH_PACKET_STATUS_WORD;

typedef struct _USBD_ISOCH_TRANSFER_STATUS
{
    USBD_STATUS                     Status;
    ULONG                           FrameCount;
    USBD_ISOCH_PACKET_STATUS_WORD   PacketStatus[8];
} USBD_ISOCH_TRANSFER_STATUS, *PUSBD_ISOCH_TRANSFER_STATUS;

typedef VOID (*PFNUSBD_ISOCH_TRANSFER_COMPLETE)(PUSBD_ISOCH_TRANSFER_STATUS Status, PVOID Context);

typedef struct _USBD_ISOCH_BUFFER_DESCRIPTOR
{
    ULONG                               FrameCount;
    PVOID                               TransferBuffer;
    USHORT                              Pattern[8];
    PFNUSBD_ISOCH_TRANSFER_COMPLETE     TransferComplete;
    PVOID                               Context;
} USBD_ISOCH_BUFFER_DESCRIPTOR, *PUSBD_ISOCH_BUFFER_DESCRIPTOR;

typedef struct _URB_ISOCH_ATTACH_BUFFER
{
    struct _URB_HEADER            Hdr;
    PVOID                         EndpointHandle;
    UCHAR                         InterruptDelay;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR BufferDescriptor;
} URB_ISOCH_ATTACH_BUFFER, *PURB_ISOCH_ATTACH_BUFFER;

typedef struct _URB_ISOCH_START_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    ULONG                  FrameNumber;
    ULONG                  Flags;
} URB_ISOCH_START_TRANSFER, *PURB_ISOCH_START_TRANSFER;
#define URB_FLAG_ISOCH_START_ASAP 0x0001
#define USBD_ISOCH_START_FRAME_RANGE 1024

typedef struct _URB_ISOCH_STOP_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
} URB_ISOCH_STOP_TRANSFER, *PURB_ISOCH_STOP_TRANSFER;

typedef struct _URB_ISOCH_OPEN_ENDPOINT
{
    struct _URB_HEADER              Hdr;
    PVOID                           EndpointHandle;
    UCHAR                           FunctionAddress;
    UCHAR                           EndpointAddress;
    USHORT                          MaxPacketSize;
    USHORT                          Flags;
    USHORT                          Pad;
} URB_ISOCH_OPEN_ENDPOINT, *PURB_ISOCH_OPEN_ENDPOINT;
#define URB_FLAG_ISOCH_CIRCULAR_DMA 0x0001

typedef struct _URB_CLOSE_ENDPOINT URB_ISOCH_CLOSE_ENDPOINT, *PURB_ISOCH_CLOSE_ENDPOINT;

//------------------------------------------------
// Union of all URBs
//------------------------------------------------
typedef union _URB
{
    struct _URB_HEADER              Header;
    URB_CONTROL_TRANSFER            ControlTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkOrInterruptTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  CommonTransfer;
    URB_OPEN_ENDPOINT               OpenEndpoint;
    URB_CLOSE_ENDPOINT              CloseEndpoint;
    URB_GET_SET_ENDPOINT_STATE      GetSetEndpointState;
    URB_ABORT_ENDPOINT              AbortEndpoint;
    URB_RESET_PORT                  ResetPort;
    URB_GET_FRAME_NUMBER            GetFrame;
    URB_ISOCH_ATTACH_BUFFER         IsochAttachBuffer;
    URB_ISOCH_START_TRANSFER        IsochStartTransfer;
    URB_ISOCH_STOP_TRANSFER         IsochStopTransfer;
    URB_ISOCH_OPEN_ENDPOINT         IsochOpenEndpoint;
    URB_ISOCH_CLOSE_ENDPOINT        IsochCloseEndpoint;
} URB;

//------------------------------------------------------------------------------------
// Macros to build USB Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CONTROL_TRANSFER(\
                        _UrbControlTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_,\
                        _bmRequestType_,\
                        _bRequest_,\
                        _wValue_,\
                        _wIndex_,\
                        _wLength_\
    )\
    {\
        (_UrbControlTransfer_)->Hdr.Length                  =   sizeof(URB_CONTROL_TRANSFER);\
        (_UrbControlTransfer_)->Hdr.Function                =   URB_FUNCTION_CONTROL_TRANSFER;\
        (_UrbControlTransfer_)->Hdr.CompleteProc            =   (_CompleteProc_);\
        (_UrbControlTransfer_)->Hdr.CompleteContext         =   (_CompleteContext_);\
        (_UrbControlTransfer_)->EndpointHandle              =   (_EndpointHandle_);\
        (_UrbControlTransfer_)->TransferBuffer              =   (_TransferBuffer_);\
        (_UrbControlTransfer_)->TransferBufferLength        =   (_TransferBufferLength_);\
        (_UrbControlTransfer_)->TransferDirection           =   (_TransferDirection_);\
        (_UrbControlTransfer_)->ShortTransferOK             =   (_ShortTransferOK_);\
        (_UrbControlTransfer_)->InterruptDelay              =   USBD_DELAY_INTERRUPT_0_MS;\
        (_UrbControlTransfer_)->SetupPacket.bmRequestType   =   (_bmRequestType_);\
        (_UrbControlTransfer_)->SetupPacket.bRequest        =   (_bRequest_);\
        (_UrbControlTransfer_)->SetupPacket.wValue          =   (_wValue_);\
        (_UrbControlTransfer_)->SetupPacket.wIndex          =   (_wIndex_);\
        (_UrbControlTransfer_)->SetupPacket.wLength         =   (_wLength_);\
    }


#define USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(\
                        _UrbBulkOrInterruptTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_\
    )\
    {\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Length          =   sizeof(URB_BULK_OR_INTERRUPT_TRANSFER);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Function        =   URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteProc    =   (_CompleteProc_);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteContext =   (_CompleteContext_);\
        (_UrbBulkOrInterruptTransfer_)->EndpointHandle      =   (_EndpointHandle_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBuffer      =   (_TransferBuffer_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBufferLength=   (_TransferBufferLength_);\
        (_UrbBulkOrInterruptTransfer_)->TransferDirection   =   (_TransferDirection_);\
        (_UrbBulkOrInterruptTransfer_)->ShortTransferOK     =   (_ShortTransferOK_);\
        (_UrbBulkOrInterruptTransfer_)->InterruptDelay      =   USBD_DELAY_INTERRUPT_0_MS;\
    }

//
// Isoch requests
//

#define USB_BUILD_ISOCH_OPEN_ENDPOINT(\
                        _UrbIsochOpenEndpoint_,\
                        _EndpointAddress_,\
                        _MaxPacketSize_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochOpenEndpoint_)->Hdr.Length         =   sizeof(URB_ISOCH_OPEN_ENDPOINT);\
        (_UrbIsochOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_ISOCH_OPEN_ENDPOINT;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteContext=   NULL;\
        (_UrbIsochOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbIsochOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
        (_UrbIsochOpenEndpoint_)->Flags              =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_CLOSE_ENDPOINT(\
                        _UrbIsochCloseEndpoint_,\
                        _EndpointHandle_,\
						_CompleteProc_,\
						_CompleteContext_\
    )\
    {\
        (_UrbIsochCloseEndpoint_)->Hdr.Length           =   sizeof(URB_ISOCH_CLOSE_ENDPOINT);\
        (_UrbIsochCloseEndpoint_)->Hdr.Function         =   URB_FUNCTION_ISOCH_CLOSE_ENDPOINT;\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteProc     =   (_CompleteProc_);\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteContext  =   (_CompleteContext_);\
        (_UrbIsochCloseEndpoint_)->EndpointHandle       =   (_EndpointHandle_);\
    }

#define USB_BUILD_ISOCH_START_TRANSFER(\
                        _UrbIsochStartTransfer_,\
                        _EndpointHandle_,\
                        _FrameNumber_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochStartTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_START_TRANSFER);\
        (_UrbIsochStartTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_START_TRANSFER;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStartTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochStartTransfer_)->FrameNumber          =   (_FrameNumber_);\
        (_UrbIsochStartTransfer_)->Flags                =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_STOP_TRANSFER(\
                        _UrbIsochStopTransfer_,\
                        _EndpointHandle_\
    )\
    {\
        (_UrbIsochStopTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_STOP_TRANSFER);\
        (_UrbIsochStopTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_STOP_TRANSFER;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStopTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
    }


#define USB_BUILD_ISOCH_ATTACH_BUFFER(\
                        _UrbIsochAttachBuffer_,\
                        _EndpointHandle_,\
                        _InterruptDelay_,\
                        _BufferDescriptor_\
    )\
    {\
        (_UrbIsochAttachBuffer_)->Hdr.Length            =   sizeof(URB_ISOCH_ATTACH_BUFFER);\
        (_UrbIsochAttachBuffer_)->Hdr.Function          =   URB_FUNCTION_ISOCH_ATTACH_BUFFER;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteProc      =   NULL;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteContext   =   NULL;\
        (_UrbIsochAttachBuffer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochAttachBuffer_)->InterruptDelay       =   (_InterruptDelay_);\
        (_UrbIsochAttachBuffer_)->BufferDescriptor     =   (_BufferDescriptor_);\
    }

//
// Bulk or Interrupt requests
//

#define USB_BUILD_OPEN_ENDPOINT(\
                        _UrbOpenEndpoint_,\
                        _EndpointAddress_,\
                        _EndpointType_,\
                        _MaxPacketSize_,\
                        _Interval_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbOpenEndpoint_)->EndpointType       =   (_EndpointType_);\
        (_UrbOpenEndpoint_)->Interval           =   (_Interval_);\
        (_UrbOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
    }

#define USB_BUILD_CLOSE_ENDPOINT(\
                        _UrbCloseEndpoint_,\
                        _EndpointHandle_,\
                        _CompleteProc_,\
                        _CompleteContext_\
    )\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
        (_UrbCloseEndpoint_)->EndpointHandle    =   (_EndpointHandle_);\
    }

#define USB_BUILD_OPEN_DEFAULT_ENDPOINT(\
                            _UrbOpenEndpoint_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_DEFAULT_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
    }

#define USB_BUILD_CLOSE_DEFAULT_ENDPOINT(_UrbCloseEndpoint_, _CompleteProc_, _CompleteContext_)\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
    }

#define USB_BUILD_GET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_GET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_SET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_, _StateFlags_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_SET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
    (_UrbGetSetEndpointState_)->EndpointState       =   (_StateFlags_);\
}

#define USB_BUILD_ABORT_ENDPOINT(_UrbAbortEndpoint_, _EndpointHandle_, _CompleteProc_, _CompleteContext_)\
{\
    (_UrbAbortEndpoint_)->Hdr.Length          =   sizeof(URB_ABORT_ENDPOINT);\
    (_UrbAbortEndpoint_)->Hdr.Function        =   URB_FUNCTION_ABORT_ENDPOINT;\
    (_UrbAbortEndpoint_)->Hdr.CompleteProc    =   (_CompleteProc_);\
	(_UrbAbortEndpoint_)->Hdr.CompleteContext =   (_CompleteContext_);\
    (_UrbAbortEndpoint_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_RESET_PORT(_UrbResetPort_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_RESET_PORT);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_RESET_PORT;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

#define USB_BUILD_GET_FRAME(_UrbGetFrame_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_GET_FRAME);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_GET_FRAME;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

//------------------------------------------------------------------------------------
// Macros to build standard USB Command Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CLEAR_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_CLEAR_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_SET_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_GET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Configuration_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_Configuration_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = TRUE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}

#define USB_BUILD_SET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_OUT;\
    (_UrbControlTransfer_)->ShortTransferOK             = FALSE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}


#define USB_BUILD_GET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_AlternateSetting_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_AlternateSetting_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_STATUS(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _Index_,\
                _Status_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Status_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|(_Recipient_));\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_STATUS;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

#define USB_BUILD_SYNC_FRAME(\
                _UrbControlTransfer_,\
                _Endpoint_,\
                _Frame_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Frame_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|USB_COMMAND_TO_ENDPOINT);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SYNC_FRAME;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Endpoint_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

//-------------------------------------------------------------------------------------------------------------
// Get the USB status code
//-------------------------------------------------------------------------------------------------------------
#define URB_STATUS(urb) ((urb)->Header.Status)
} //end of 'extern "C"'
//------------------------------------------------------------------------------------
// bmRequestType values for commands over control pipes, belongs in usb100.h
//------------------------------------------------------------------------------------

//  Data Direction
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

//  Type
#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

//  Recipient
#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//------------------------------------------------------------------------------------
// The enumerator only provides the first eight bytes of the device descriptor
//------------------------------------------------------------------------------------
typedef struct _USB_DEVICE_DESCRIPTOR8 {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
} USB_DEVICE_DESCRIPTOR8, *PUSB_DEVICE_DESCRIPTOR8;
//---------------------------------------------------------------------------------------------------------------
// USB_HOST_CONTROLLER - Host Controller Configuration Selection
//---------------------------------------------------------------------------------------------------------------
#define USB_SINGLE_HOST_CONTROLLER 1
#define USB_DUAL_HOST_CONTROLLER_XDK 2
//  Select which configuragtion to use.

#ifndef USB_HOST_CONTROLLER_CONFIGURATION
#ifdef SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_DUAL_HOST_CONTROLLER_XDK
#else  //!SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_SINGLE_HOST_CONTROLLER
#endif ////!SILVER
#endif  USB_HOST_CONTROLLER_CONFIGURATION


#
//------------------------------------------------------------------------------------
//  Forward declaration of classes
//------------------------------------------------------------------------------------
class IUsbDevice;
class CDeviceTree;

//---------------------------------------------------------------------------------------------------------------
// USBD_HOST_CONTROLLER - Context of USBD by host controller.  Instead of a DEVICE_OBJECT
//---------------------------------------------------------------------------------------------------------------
#pragma warning(disable : 4200) //Turn off zero length array warning
typedef struct _USBD_HOST_CONTROLLER
{
    ULONG           ControllerNumber;   //Number of this controller.
    IUsbDevice      *RootHub;           //Root Hub
    ULONG           AddressList[4];     //128 bit bitfield of used USB addresses.
    ULONG           HcdExtension[0];    //The Host controllers extension starts here.
} USBD_HOST_CONTROLLER, *PUSBD_HOST_CONTROLLER;
#pragma warning(default : 4200) //Turn zero length array warning back on

//
//  Stuff related to the Host Controller Driver, its endpoint size and its extension
//
extern ULONG GLOBAL_HostControllerExtensionSize;
#define USBD_GetHCDExtension(_UsbdHostController_) ((PVOID)(_UsbdHostController_->HcdExtension))
#define USBD_HostControllerFromHCDExtension(_HCDExtension_)  CONTAINING_RECORD(_HCDExtension_, USBD_HOST_CONTROLLER, HcdExtension)

//---------------------------------------------------------------------------------------------------------------
//  Types of USB Device Nodes.
//      UDN_TYPE_HUB                - represents a hub device.
//      UDN_TYPE_FUNCTION           - a USB function for which bDeviceClass != 0.
//      UDN_TYPE_INTERFACE_FUNCTION - a USB function where bDeviceClass is 0, but there is only one interface.
//      UDN_TYPE_COMPOSITE_FUNCTION - a USB function where bDeviceClass is 0, and there are multiple interfaces.
//                                    a COMPOSITE_FUNCTION always has one INTERFACE child be interface.   
//      UDN_TYPE_INTERFACE          - represents an INTERFACE on a COMPOSITE_FUNCTION.
//===============================================================================================================
//  Special types not signifying a device
//      UDN_TYPE_UNUSED             - Not currently representing a device.  Node should be on the free list.
//      UDN_TYPE_PENDING_ENUM       - Device has been detected, but is in the list of nodes awaiting enumeration.
//      UDN_TYPE_ENUMERATING        - Device is currently being enumerated, but has not reached a stage of enumeration
//                                    yet where the node type is known.
//---------------------------------------------------------------------------------------------------------------
#define UDN_TYPE_ROOT_HUB           0
#define UDN_TYPE_HUB                1
#define UDN_TYPE_FUNCTION           2
#define UDN_TYPE_INTERFACE_FUNCTION 3
#define UDN_TYPE_COMPOSITE_FUNCTION 4
#define UDN_TYPE_INTERFACE          5
#define UDN_TYPE_UNUSED             0xFF    
#define UDN_TYPE_PENDING_ENUM       0xFE
#define UDN_TYPE_ENUMERATING        0xFD

//---------------------------------------------------------------------------------------------------------------
//  Device node constants
//---------------------------------------------------------------------------------------------------------------
#define UDN_INVALID_NODE_INDEX      128   // Indicates that index does not point to a valid node.

#define UDN_LOWSPEED_PORT           0x80
#define UDN_NO_CLASS_DRIVER_SUPPORT 0xFF
#define UDN_HUB_TYPE_EXTERNAL       0x01

//--------------------------------------------------------------------------------
//  Resource structure shared between USBD and OHCD
//--------------------------------------------------------------------------------
extern "C" {
#define HCD_INTERRUPT_TD_QUOTA 3
typedef struct _HCD_RESOURCE_REQUIREMENTS
{
    ULONG EndpointCount;
    ULONG IsochEndpointCount;
    ULONG TDCount;
    UCHAR ControlTDQuota;
    UCHAR BulkTDQuota;
    UCHAR IsochMaxBuffers;
} HCD_RESOURCE_REQUIREMENTS, *PHCD_RESOURCE_REQUIREMENTS;

} //end 'extern "C"'

//--------------------------------------------------------------------------------------------------------------
// Resource Requirements Structure
//--------------------------------------------------------------------------------------------------------------
typedef struct _USB_RESOURCE_REQUIREMENTS
{
    UCHAR ConnectorType;
    UCHAR MaxDevices;
    UCHAR MaxCompositeInterfaces;
    UCHAR MaxControlEndpoints;
    UCHAR MaxBulkEndpoints;
    UCHAR MaxInterruptEndpoints;
    UCHAR MaxControlTDperTransfer;
    UCHAR MaxBulkTDperTransfer;
    //Isoch
    UCHAR MaxIsochEndpoints;
    UCHAR MaxIsochMaxBuffers;
} USB_RESOURCE_REQUIREMENTS, *PUSB_RESOURCE_REQUIREMENTS;
//-------------------------------------------------------------------------------------------------
// This class is used to assist initialization.
//-------------------------------------------------------------------------------------------------
class IUsbInit
{
  public:
    ULONG GetMaxDeviceTypeCount(PXPP_DEVICE_TYPE XppDeviceType);
    VOID  RegisterResources(PUSB_RESOURCE_REQUIREMENTS pResourceRequirements);
    BOOL  UseDefaultCount();
    //c'tor
    IUsbInit(ULONG NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes) :
      m_NumDeviceTypes(NumDeviceTypes), m_pDeviceTypes(DeviceTypes),
      m_NodeCount(0), m_MaxCompositeInterfaces(0)
      {
        RtlZeroMemory(m_Direct, sizeof(m_Direct));
        RtlZeroMemory(m_TopSlots, sizeof(m_TopSlots));
        RtlZeroMemory(m_BottomSlots, sizeof(m_BottomSlots));
        RtlZeroMemory(&m_HcdResources, sizeof(m_HcdResources));
      }

    //services for usbd to retrieve information
    void Process();
    inline UCHAR GetNodeCount() {return m_NodeCount;}
    inline UCHAR GetMaxCompositeInterfaces() {return m_MaxCompositeInterfaces;}
    inline PHCD_RESOURCE_REQUIREMENTS GetHcdResourcePtr() {return &m_HcdResources;}
  private:
    USB_RESOURCE_REQUIREMENTS m_Direct[5];
    USB_RESOURCE_REQUIREMENTS m_TopSlots[5];
    USB_RESOURCE_REQUIREMENTS m_BottomSlots[5];
    ULONG                     m_NumDeviceTypes;
    PXDEVICE_PREALLOC_TYPE    m_pDeviceTypes;
    // Fields valid after process
    UCHAR                     m_NodeCount;
    UCHAR                     m_MaxCompositeInterfaces;
    HCD_RESOURCE_REQUIREMENTS m_HcdResources;
};
//--------------------------------------------------------------------------------------------------------------
// Class Driver Static Registration 
//--------------------------------------------------------------------------------------------------------------
typedef union _PNP_CLASS_ID
{
    LONG AsLong;
    struct
    {
        UCHAR bClassSpecificType;
        UCHAR bClass;
        UCHAR bSubClass;
        UCHAR bProtocol;
    } USB;
} PNP_CLASS_ID, *PPNP_CLASS_ID;

// The high-bit of bClassSpecificType is set
// if the class driver has not indicated a class
// specific type.  Prior to calling AddDevice
// this is used to track whether this is a 
// device level or interface level class.
// 
// USB_CLASS_DRIVER_DECLARATION assumes PNP_INTERFACE_LEVEL_CLASS
// 
#define PNP_CLASS_SPECIFIC_TYPE_NOT_SET(bClassSpecificType) (bClassSpecificType&0x80)
#define PNP_DEVICE_LEVEL_CLASS    0x81
#define PNP_INTERFACE_LEVEL_CLASS 0x82

typedef
VOID
 (*PFNINIT_USB_DRIVER)(IUsbInit *UsbInit);

typedef
VOID
 (*PFNADD_USB_DEVICE)(
    IN IUsbDevice *Device
    );

typedef
VOID
 (*PFNREMOVE_USB_DEVICE)(
    IN IUsbDevice *Device
    );


typedef struct _USB_DEVICE_TYPE_DESCRIPTION
{
    PXPP_DEVICE_TYPE XppDeviceType;
} USB_DEVICE_TYPE_DESCRIPTION, *PUSB_DEVICE_TYPE_DESCRIPTION;

#define USB_CONNECTOR_TYPE_DIRECT     0  //Plugs directly into the front of xbox (or a hub port)
#define USB_CONNECTOR_TYPE_HIGH_POWER 1  //Plugs into a high power slot in gamepad
#define USB_CONNECTOR_TYPE_LOW_POWER  2  //Plugs into a high power or low power slot in gamepad

typedef struct _USB_CLASS_DRIVER_DESCRIPTION
{
    PNP_CLASS_ID                 ClassId;
    PFNINIT_USB_DRIVER           Init;
    PFNADD_USB_DEVICE            AddDevice;
    PFNREMOVE_USB_DEVICE         RemoveDevice;
    ULONG                        DeviceTypeCount;
    PXPP_DEVICE_TYPE             *DeviceTypes;
} USB_CLASS_DRIVER_DESCRIPTION, *PUSB_CLASS_DRIVER_DESCRIPTION;

#define DECLARE_XPP_TYPE(XppTypeName)\
EXTERNUSB XPP_DEVICE_TYPE XppTypeName##_TABLE = {0,0,0};

#define USB_DEVICE_TYPE_TABLE_BEGIN(ClassName)\
EXTERNUSB PXPP_DEVICE_TYPE ClassName##Types[]={

#define USB_DEVICE_TYPE_TABLE_ENTRY(XppDeviceType)\
                 (XppDeviceType)

#define USB_DEVICE_TYPE_TABLE_END() };

#define USB_CLASS_DRIVER_DECLARATION(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DUPLICATE(ClassName, DuplicateNumber, bClass, bSubClass, bProtocol)\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##DuplicateNumber##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_DEVICE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DECLARATION_POINTER(ClassName)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DescriptionPointer=&ClassName##Description;
#define USB_CLASS_DECLARATION_POINTER_DUPLICATE(ClassName, DuplicateNumber)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DuplicateNumber##DescriptionPointer=\
                &ClassName##DuplicateNumber##Description;

#define REFERENCE_CLASS(ClassName)\
    EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description;\
    static USB_CLASS_DRIVER_DESCRIPTION *classMU = &(ClassName##Description);

//---------------------------------------------------------------------------------------------------------------
//  IUsbDevice is the main interface to the core driver
//---------------------------------------------------------------------------------------------------------------
class IUsbDevice
{
    public:
    /*  IUsbDevice methods calleable at any time by class driver*/
    USBD_STATUS SubmitRequest(PURB Urb);
    USBD_STATUS CancelRequest(PURB Urb);
    BOOLEAN IsHardwareConnected() const;
    PVOID GetExtension() const;
    PVOID SetExtension(PVOID Extension);
    UCHAR GetInterfaceNumber() const;
	void SetClassSpecificType(UCHAR ClassSpecificType);
    ULONG GetPort() const;

    /*  IUsbDevice methods related to device enumeration*/
    void AddComplete(USBD_STATUS UsbdStatus);
    void RemoveComplete();
    void DeviceNotResponding();

    /*  IUsbDevice methods calleable only at enum time*/
    const USB_DEVICE_DESCRIPTOR8 *GetDeviceDescriptor() const;
    const USB_CONFIGURATION_DESCRIPTOR *GetConfigurationDescriptor() const;
    const USB_INTERFACE_DESCRIPTOR *GetInterfaceDescriptor() const;
    const USB_ENDPOINT_DESCRIPTOR *GetEndpointDescriptor(UCHAR EndpointType, BOOLEAN Direction, UCHAR Index) const;
    
	/*  IUsbDevice methods used only by hubs */
    void DeviceConnected(UCHAR PortNumber, UCHAR RetryCount);
    void DeviceDisconnected(UCHAR PortNumber);
    void ResetComplete(USBD_STATUS UsbdStatus, PVOID Context);
    void DisableComplete(USBD_STATUS UsbdStatus, PVOID Context);

    /* static IUsbDevice methods */
    static ULONG Win32FromUsbdStatus(USBD_STATUS UsbdStatus);
	static NTSTATUS NtStatusFromUsbdStatus(USBD_STATUS UsbdStatus);
    /*  c'tor */
    IUsbDevice::IUsbDevice() : 
        m_Type(UDN_TYPE_UNUSED), m_NextFree(UDN_INVALID_NODE_INDEX),
        m_FirstChild(UDN_INVALID_NODE_INDEX), m_Sibling(UDN_INVALID_NODE_INDEX){}

    /* IUsbDevice short and sweet methods used in USBD, these are inline, but defined below due to declaration order */
    UCHAR			GetIndex() const;
    BOOLEAN			GetLowSpeed() const;
    UCHAR			GetHubPort() const;
    IUsbDevice		*GetParent() const;
    IUsbDevice		*GetFirstChild() const;
    IUsbDevice		*GetSibling() const;
    IUsbDevice		*FindChild(UCHAR PortNumber) const;
    void			InsertChild(IUsbDevice *child);
    BOOLEAN			RemoveChild(IUsbDevice *child);
    BOOLEAN			IsEnumTime() const;
    PNP_CLASS_ID    GetClassId() const;
    /* public helper function*/
    void            SetExternalPort();
	#ifndef SILVER
	void            SetExternalPortWithHub(IUsbDevice **pParentArray, UINT DeviceIndex);
	void            SetExternalPortWithoutHub(IUsbDevice **pParentArray, UINT DeviceIndex);
	#endif

    //
    //  These are not declared private as most of the code is already coded in C
    //  and manipulates this class directly.
    //
    UCHAR   m_Type;
    union
    {
        UCHAR   m_Parent;
        UCHAR   m_NextFree;
    };
    union
    {
        UCHAR   m_FirstChild;
        UCHAR   m_bInterfaceNumber;
    };
    UCHAR           m_Sibling;

    UCHAR           m_PortNumber;
    union
    {
        UCHAR   m_Address;        
        UCHAR   m_RetryCount;
    };
    UCHAR           m_MaxPacket0;
    UCHAR           m_ClassSpecificType;

    PVOID           m_DefaultEndpoint;
    PUSBD_HOST_CONTROLLER m_HostController;

    union
    {
        PUSB_CLASS_DRIVER_DESCRIPTION   m_ClassDriver;
        IUsbDevice                      *m_NextPending;
    };
    LONG            m_ExternalPort;
    union
    {
        LARGE_INTEGER  m_EarliestEnumTime;
        struct
        {
            ULONG           m_DataToggleBits;
            PVOID			m_ClassDriverExtension;
        };
    };
    
    /* IUsbDevice helpers, these are only called internally so can be private */
    private:
    USBD_STATUS OpenDefaultEndpoint(PURB Urb);
    USBD_STATUS CloseDefaultEndpoint(PURB Urb);
};
//--------------------------------------------------------------------------------
//  Hub driver must implement this method
//--------------------------------------------------------------------------------
extern VOID USBHUB_DisableResetPort(
	                    IN IUsbDevice *HubDevice,
	                    IN UCHAR PortNumber,
	                    IN PVOID Context,
                        IN BOOLEAN Disable
	                    );
//--------------------------------------------------------------------------------
//  Enum Stages, mostly for debugging really
//--------------------------------------------------------------------------------
#define USBD_ENUM_DEVICE_CONNECTED 0x80
#define USBD_ENUM_STAGE_0 0
#define USBD_ENUM_STAGE_PRE1 0x81
#define USBD_ENUM_STAGE_1 1
#define USBD_ENUM_STAGE_2 2
#define USBD_ENUM_STAGE_3 3
#define USBD_ENUM_STAGE_PRE4 0x84
#define USBD_ENUM_STAGE_4 4
#define USBD_ENUM_STAGE_5 5
#define USBD_ENUM_STAGE_6 6
#define USBD_ENUM_STAGE_ADD_COMPLETE 7
#define USBD_ENUM_STAGE_ABORT1 8
#define USBD_ENUM_STAGE_DISABLE_COMPLETE 9
#define USBD_ENUM_STAGE_ABORT2 10

//--------------------------------------------------------------------------------
//  CDeviceTree keeps track of all the devices
//--------------------------------------------------------------------------------
#define USBD_MAX_CONFIG_DESC_SIZE     80
#define USBD_DEFAULT_MAXPACKET0       8
#define USBD_CONTROL_TD_QUOTA         (USBD_MAX_CONFIG_DESC_SIZE/USBD_DEFAULT_MAXPACKET0) + 3 //the three is for SETUP, SETUP's data and STATUS
#define USBD_BASE_NODES_PER_PORT      4

class CDeviceTree
{
    public:

    //
    //  There is no defined c'tor, because there is no way
    //  to make sure that it gets called.
    //

    void Init(ULONG NodeCount, ULONG MaxCompositeInterfaces);
    IUsbDevice *AllocDevice() { 
            UCHAR nodeIndex = m_FirstFree;
            ASSERT(UDN_INVALID_NODE_INDEX != nodeIndex);
            m_FirstFree = m_Devices[nodeIndex].m_NextFree;
            m_Devices[nodeIndex].m_Parent = UDN_INVALID_NODE_INDEX;
            m_Devices[nodeIndex].m_FirstChild = UDN_INVALID_NODE_INDEX;
            m_Devices[nodeIndex].m_Sibling = UDN_INVALID_NODE_INDEX;
            m_Devices[nodeIndex].m_ClassDriverExtension = NULL;
            m_Devices[nodeIndex].m_ClassSpecificType = 0xFF;
            return m_Devices + nodeIndex;
            }
    VOID FreeDevice(IUsbDevice *usbDevice) { 
            ASSERT(usbDevice >= m_Devices);
            UCHAR nodeIndex = usbDevice - m_Devices;
            ASSERT(UDN_INVALID_NODE_INDEX > nodeIndex);
            m_Devices[nodeIndex].m_Type = UDN_TYPE_UNUSED;
            m_Devices[nodeIndex].m_NextFree = m_FirstFree;
            m_FirstFree = nodeIndex;
            }
    
    BOOLEAN                     m_InProgress;
    BOOLEAN                     m_DeviceRemoved;
    BOOLEAN                     m_RetryCount;
    UCHAR                       m_EnumStage;
    URB                         m_EnumUrb;
    KDPC                        m_EnumDpc;
    KTIMER                      m_EnumTimer;
    UCHAR                       m_TimerReason;
    UCHAR                       m_FirstFree;
    UCHAR                       m_NodeCount;
    UCHAR                       m_MaxCompositeInterfaces;
    IUsbDevice                  *m_FirstPendingEnum;
    IUsbDevice                  *m_CurrentEnum;
    USB_DEVICE_DESCRIPTOR8      m_DeviceDescriptor;
    UCHAR                       m_ConfigurationDescriptorBuffer[USBD_MAX_CONFIG_DESC_SIZE];
    PUSB_INTERFACE_DESCRIPTOR   m_InterfaceDescriptor;
    IUsbDevice                  *m_Devices;
};
extern CDeviceTree g_DeviceTree;
#define USBD_TIMER_REASON_STAGE0            0
#define USBD_TIMER_REASON_WATCHDOG          1
#define USBD_TIMER_REASON_CONTINUE_STAGE1   2
#define USBD_TIMER_REASON_CONTINUE_STAGE4   3
/**************************************************
***  Implementation of IUsbDevice inline functions
*********/
inline UCHAR
IUsbDevice::GetIndex() const
/*++
    Gets the index of this device in the global static tree.
--*/
{return (UCHAR)(this - g_DeviceTree.m_Devices);}

inline BOOLEAN
IUsbDevice::GetLowSpeed() const
/*++
    Returns true if the device is lowspeed.
    THIS WILL BE REMOVED WHEN SUPPORT FOR LOWSPEED IS DROPPED.
--*/
{return m_PortNumber & UDN_LOWSPEED_PORT ? TRUE : FALSE;}

inline UCHAR
IUsbDevice::GetHubPort() const
/*++
    Get the portnumber regardless of lowspeed or not.
--*/
{return m_PortNumber & ~UDN_LOWSPEED_PORT;}

inline IUsbDevice *
IUsbDevice::GetParent() const
/*++
    Returns a pointer to the parent.  NULL if there is no parent.
--*/
{return (UDN_INVALID_NODE_INDEX != m_Parent) ? (g_DeviceTree.m_Devices + m_Parent) : NULL;}

inline IUsbDevice *
IUsbDevice::GetFirstChild() const
/*++
    Returns a pointer to the first child.  NULL if there are no children.
--*/
{return (UDN_INVALID_NODE_INDEX != m_FirstChild) ? (g_DeviceTree.m_Devices + m_FirstChild) : NULL;}

inline IUsbDevice *
IUsbDevice::GetSibling() const
/*++
    Returns a pointer to the next sibling.  NULL if this is the last sibling.
--*/
{return (UDN_INVALID_NODE_INDEX != m_Sibling) ? (g_DeviceTree.m_Devices + m_Sibling) : NULL;}
   
//------------------------------------------------------------------------
//  Methods used across modules
//------------------------------------------------------------------------
PUSB_CLASS_DRIVER_DESCRIPTION 
USBD_FindClassDriver(
	IN PNP_CLASS_ID ClassId
	);

//------------------------------------------------
//  Needed in ISBD_Init were we initialize the
//  the DPC for timing when to start enumeration.
//------------------------------------------------
void    
USBD_DeviceEnumTimerProc(
    IN PKDPC Dpc,
    IN PVOID Unused1,
    IN PVOID Unused2,
    IN PVOID Unused3
    );

//------------------------------------------------
//  Entry Point XAPI must call
//------------------------------------------------
EXTERNUSB VOID USBD_Init(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes);
//--------------------------------------------------------------------------------
//  Interface between the host controller driver and usbd
//--------------------------------------------------------------------------------
extern "C" {

//
// HCD specific URBs
//
#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002

//
// Common transfer request definition, all transfer
// requests passed to the HCD will be mapped to this
// format.  The HCD will can use this structure to
// reference fields that are common to all transfers
// as well as fields specific to isochronous and
// control transfers.

//
// bandwidth related definitions
//

// overhead in bytes/ms

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13

  
//-------------------------------------------------------------
// Utility procedures supported by USB System Driver
//-------------------------------------------------------------
VOID
USBD_CompleteRequest(
    IN  PURB Urb
    );

USHORT
USBD_CalculateUsbBandwidth(
    IN USHORT   MaxPacketSize,
    IN UCHAR    EndpointType,
    IN BOOLEAN  LowSpeed
    );

VOID
USBD_DeviceConnected(
    IN  PVOID    HcdExtension,
    IN  UCHAR    PortNumber
    );

VOID
USBD_DeviceDisconnected(
    IN  PVOID HcdExtension,
    IN  UCHAR PortNumber
    );

VOID
USBD_NewHostController(
    IN PPCI_DEVICE_DESCRIPTOR PciDevice,
	IN ULONG HcdDeviceExtensionSize
    );

//-------------------------------------------------------------
// Procedures which must be exported by Host Controller Driver
//-------------------------------------------------------------
VOID
HCD_DriverEntry(
    PHCD_RESOURCE_REQUIREMENTS ResourceRequirements
    );

VOID
HCD_EnumHardware();

NTSTATUS
HCD_NewHostController(
    IN PVOID  HcdExtension,
    IN UCHAR  HostControllerNumber,
    IN PPCI_DEVICE_DESCRIPTOR PciDevice
    );

USBD_STATUS
HCD_SubmitRequest(
    IN PVOID HcdExtension,
    IN PURB Urb
    );

USBD_STATUS
HCD_CancelRequest(
    IN PVOID HcdExtension,
    IN PURB  Urb
    );

typedef
VOID
(*PFNHCD_RESET_COMPLETE)(
    IN USBD_STATUS  Status,
    IN PVOID        Context
    );

VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    );

VOID
HCD_DisableRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber
    );

} //end 'extern "C"'

#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbhub\hub.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    hub.h

Abstract:

    Structures and functions used by the usbhub driver
	
Environment:

	Designed for XBOX.

Notes:

Revision History:

    02-22-00 created by Mitchell Dernis (mitchd)

--*/

#ifndef __HUB_H__
#define __HUB_H__


#define USB_HUB_DESCRIPTOR_TYPE		0x29

//
//	USB HUB SPECIFIC FEATURES
//
#define	USBHUB_FEATURE_C_HUB_LOCAL_POWER		0
#define	USBHUB_FEATURE_C_HUB_OVER_CURRENT		1
#define	USBHUB_FEATURE_PORT_CONNECTION			0
#define	USBHUB_FEATURE_PORT_ENABLE				1
#define	USBHUB_FEATURE_PORT_SUSPEND				2
#define	USBHUB_FEATURE_PORT_OVER_CURRENT		3
#define	USBHUB_FEATURE_PORT_RESET				4
#define	USBHUB_FEATURE_PORT_POWER				8
#define	USBHUB_FEATURE_C_PORT_CONNECTION		16
#define	USBHUB_FEATURE_C_PORT_ENABLE			17
#define	USBHUB_FEATURE_C_PORT_SUSPEND			18
#define	USBHUB_FEATURE_C_PORT_OVER_CURRENT		19
#define	USBHUB_FEATURE_C_PORT_RESET				20

//
//	Bit mask for checking the hub status
//
#define USBHUB_HUB_STATUS_LOCAL_POWER		0x0001
#define USBHUB_HUB_STATUS_OVER_CURRENT		0x0002

//
//	Bit mask for checking the hub status change
//
#define USBHUB_C_HUB_STATUS_LOCAL_POWER		0x0001
#define USBHUB_C_HUB_STATUS_OVER_CURRENT	0x0002

//
//	Bit mask for checking the port status
//	
#define USBHUB_PORT_STATUS_CONNECTION		0x0001
#define USBHUB_PORT_STATUS_ENABLE			0x0002
#define USBHUB_PORT_STATUS_SUSPEND			0x0004
#define USBHUB_PORT_STATUS_OVER_CURRENT		0x0008
#define USBHUB_PORT_STATUS_RESET			0x0010
#define USBHUB_PORT_STATUS_POWER			0x0100
#define USBHUB_PORT_STATUS_LOW_SPEED		0x0200


//
//	Bit mask for checking the port status change
//	
#define USBHUB_C_PORT_STATUS_CONNECTION		0x0001
#define USBHUB_C_PORT_STATUS_ENABLE			0x0002
#define USBHUB_C_PORT_STATUS_SUSPEND		0x0004
#define USBHUB_C_PORT_STATUS_OVER_CURRENT	0x0008
#define USBHUB_C_PORT_STATUS_RESET			0x0010

//
//	Device Node for a hub
//
typedef struct _USBHUB_DEVICE_NODE
{
	//
	//	First byte is various status bits.
	//
	UCHAR			InUse:1;
	UCHAR			RemovePending:1;
	UCHAR			PoweringPorts:1;
    UCHAR			NotResponding:1;
	UCHAR			Padding:4;
	UCHAR			InterruptEndpointAddress;
	UCHAR			PortCount;
	UCHAR			PortProcessIndex;		//Port currently being processed.
	UCHAR			PortStatusChangeBitmap; //Bitmap of ports whose status has changed
	UCHAR			PortConnectedBitmap;	//Bitmap of ports that are connected
    UCHAR           ErrorCount;
	UCHAR			InterruptEndpointMaxPacket;
	
	URB				Urb;
	
	//
	//	Memory buffer for the URB.  We use a union to format it.
	//
	union
	{
		UCHAR			RequestBuffer[4];
		struct {
			USHORT		Status;
			USHORT		StatusChange;
		}				PortStatus;
	};
	PVOID			InterruptEndpointHandle;
} USBHUB_DEVICE_NODE, *PUSBHUB_DEVICE_NODE;

#define USBHUB_MAXIMUM_HUB_COUNT 6 //Need an extra slop node, in case a reset is done

typedef	struct _USBHUB_INFO
{
	USHORT				NodeCount;
	USHORT				NodesInUse;
	USBHUB_DEVICE_NODE	Nodes[USBHUB_MAXIMUM_HUB_COUNT];
	PUCHAR				EndpointMemory;
} USBHUB_INFO, *PUSBHUB_INFO;

typedef struct _USBHUB_ENUM_BLOCK
{
	UCHAR						EnumBuffer[48];
	//
	//	Resets are not done by the enumeration routine in particular, but USBD guarantees
	//	the serialization of resets across all host controllers.  We are therefore safe
	//	sticking these variables in a global context.
	URB							ResetUrb;
	PVOID						ResetContext;
    KTIMER                      WatchdogTimer;
    KDPC                        WatchdogTimerDpc;
    ULONG                       WatchdogReason;
} USBHUB_ENUM_BLOCK, *PUSBHUB_ENUM_BLOCK;

#define USBHUB_WATCHDOG_REASON_ENUM         0
#define USBHUB_WATCHDOG_REASON_RESET_PORT   1
#define USBHUB_WATCHDOG_REASON_DISABLE_PORT 2

extern USBHUB_INFO			GLOBAL_HubInfo;
extern USBHUB_ENUM_BLOCK	GLOBAL_HubEnum;


//----------------------------------------------------------
//	Entry points from external modules
//----------------------------------------------------------
VOID
USBHUB_AddHub(
	IN IUsbDevice *HubDevice,
	IN PVOID Context
	);

VOID
USBHUB_RemoveHub(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_DisableResetPort(
	IN IUsbDevice *HubDevice,
	IN UCHAR	PortNumber,
	IN PVOID	Context,
    IN BOOLEAN  Disable
	);



//----------------------------------------------------------
//	Procedures implemented in hub.c
//----------------------------------------------------------

VOID
USBHUB_EnumHubStage1(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_EnumHubStage2(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_EnumHubComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_PoweringPorts(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ChangeNotifyComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ClearInterruptStallComplete(
    PURB	Urb,
	IUsbDevice	*HubDevice
	);

VOID
USBHUB_PortStatusChange1(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_PortStatusChange2(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_PortProcessChange(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_HubStatusChange(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ClearHubFeatureComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ClearPortFeatureComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_RemoveHubStage1(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_RemoveHubStage2(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_RemoveHubComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ResetComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_DisableComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_RelatchPortSpeed(
    IUsbDevice *HubDevice
    );

VOID
USBHUB_RelatchPortSpeedComplete(
    IN PURB    Urb,
    IUsbDevice *HubDevice
    );

#endif	//__HUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbd\usbinit.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved. 

Module Name:

    usbinit.cpp

Abstract:

    Implementation of IUsbInit.  This class is passed to class drivers to collect
    resource information during initialization.

Environment:

    XBOX kernel mode only

Notes:

Revision History:

    01-10-01 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBD");

//
//  Pull in usbd headers
//
#include <usbd.h>

#pragma code_seg(".XPPCINIT")
#pragma data_seg(".XPPDINIT")
#pragma const_seg(".XPPRINIT")


ULONG IUsbInit::GetMaxDeviceTypeCount(PXPP_DEVICE_TYPE XppDeviceType)
{
    ULONG ulIndex;
    
    //
    //  Return XGetPortCount(), if m_pDeviceTypes is NULL.
    //
    if(NULL == m_pDeviceTypes)
    {
        return 0;
    }
    //
    //  Otherwise, find the device type.
    //
    for(ulIndex = 0; ulIndex < m_NumDeviceTypes; ulIndex++)
    {
        if( m_pDeviceTypes[ulIndex].DeviceType == XppDeviceType)
        {
            ULONG ulResult = m_pDeviceTypes[ulIndex].dwPreallocCount;
            #if DBG
            if(0==ulResult)
            {
                XDebugPrint(XDBG_WARNING, "XInitDevices", "A device type was explictly listed requesting 0 open instances.\n\
This forces the linkage of the supporting driver library.  Ommitting the device\ntype from the list is always better practice.");
            }
            #endif
            return ulResult;
        }
    }
    //
    //  If the device type was not registered, then we support 0.
    //  (Don't spew here, this could happen because one device
    //  supported by a given driver is in the list, but others are not.)
    return 0;
}

BOOL IUsbInit::UseDefaultCount()
{
    return m_pDeviceTypes ? FALSE : TRUE;
}

//
//  It is inline, because we just want something more robust
//  than a MAX macro which has a number of problems.
//  It is static because we don't want code generated for it
//
inline static void SetToMax(UCHAR& dest, UCHAR src) {if(src > dest) dest = src;}

void IUsbInit::RegisterResources(PUSB_RESOURCE_REQUIREMENTS pResourceRequirements)
/*++
  Routine Description:  
    Called by each driver for each type of connector it supports.  It is up to each
    driver to figure the maximum number of devices it can support in each slot type.
    If a driver supports composite devices (such as audio) it should add the resources
    of the composites together and register once.

    If a driver supports multiple device types (not composites) it should register them separately.
    If the devices have the same connector type, the driver may choose to register only the worst
    case device.
--*/
{
    PUSB_RESOURCE_REQUIREMENTS pConnectorResourceList;
    ULONG ulMaxDevices = pResourceRequirements->MaxDevices;
    ULONG ulMaxPorts = XGetPortCount();
    //
    //  Choose which list to reserve resource from
    //
    switch(pResourceRequirements->ConnectorType)
    {
        case  USB_CONNECTOR_TYPE_DIRECT:
            // Direct 
            pConnectorResourceList = m_Direct;
            break;
        case  USB_CONNECTOR_TYPE_HIGH_POWER:
            pConnectorResourceList = m_TopSlots;
            break;
        case  USB_CONNECTOR_TYPE_LOW_POWER:
            //
            //  Low power devices have their resource allocated first against
            //  the bottom slots
            //
            pConnectorResourceList = m_BottomSlots;
            // Low Power can go in top slots two, see
            // below for way we use the 0th index.
            SetToMax(
                m_TopSlots[0].MaxCompositeInterfaces,
                pResourceRequirements->MaxCompositeInterfaces
                );
            //
            //  If the device count exceeds the bottom slots, apply the rest
            //  towards the top-slots.  The easiest way is to change the
            //  connector type to high-power and call ourselves.
            //
            if(pResourceRequirements->MaxDevices > ulMaxPorts)
            {
                pResourceRequirements->MaxDevices -= (UCHAR)ulMaxPorts;
                pResourceRequirements->ConnectorType = USB_CONNECTOR_TYPE_HIGH_POWER;
                RegisterResources(pResourceRequirements);
                pResourceRequirements->MaxDevices += (UCHAR)ulMaxPorts;
                pResourceRequirements->ConnectorType = USB_CONNECTOR_TYPE_LOW_POWER;
                ulMaxDevices -= ulMaxPorts;
            }
            break;
    }
    //
    //  Composite Interface require nodes whether or not the device is opened.
    //  So we just use the 0th slot of the given type to track it, we are
    //  going to multiply by the number of ports anyway during Process.
    //
    SetToMax(
        pConnectorResourceList[0].MaxCompositeInterfaces,
        pResourceRequirements->MaxCompositeInterfaces
        );

    ASSERT(ulMaxDevices <= ulMaxPorts);

    // Some variables for walk the resource table.
    ULONG ulTempSlotIndex;
    ULONG ulDeviceCount;
    ULONG ulSlotIndex;
    //
    //  Record Control Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxControlEndpoints > pResourceRequirements->MaxControlEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxControlEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxControlEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxControlEndpoints = pResourceRequirements->MaxControlEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }
    //
    //  Record Bulk Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxBulkEndpoints > pResourceRequirements->MaxBulkEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxBulkEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxBulkEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxBulkEndpoints = pResourceRequirements->MaxBulkEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }
    //
    //  Record Interrupt Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxInterruptEndpoints > pResourceRequirements->MaxInterruptEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxInterruptEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxInterruptEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxInterruptEndpoints = pResourceRequirements->MaxInterruptEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }
    //
    //  Record Isochronous Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxIsochEndpoints > pResourceRequirements->MaxIsochEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxIsochEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxIsochEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxIsochEndpoints = pResourceRequirements->MaxIsochEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }

    //
    //  These are max'd across all connector types and all slots.  Unlike the other fields
    //  that are later summed across the connector types and slots.
    SetToMax(m_HcdResources.ControlTDQuota, pResourceRequirements->MaxControlEndpoints);
    SetToMax(m_HcdResources.BulkTDQuota, pResourceRequirements->MaxBulkTDperTransfer);
    SetToMax(m_HcdResources.IsochMaxBuffers, pResourceRequirements->MaxIsochMaxBuffers);
    //We keep track MaxComposite Interfaces, both per slot, and the global
    
    return;
}

VOID
IUsbInit::Process()
/*
    This routine takes all the table information, and boils it down to the information
    that USBD needs.
*/
{
    ULONG ulMaxPorts = XGetPortCount();
    ULONG ulControlEndpoints = 0;
    ULONG ulBulkEndpoints = 0;
    ULONG ulInterruptEndpoints = 0;
    
    // The members should all be 0 from the c'tor:
    
    
    //
    //  Figure the base number of nodes based on how
    //  many devices may be pending enumeration at once.
    //  This number to USBD_BASE_NODES_PER_PORT per port.
    //  This is four, one for the hub, one for "direct connect"
    //  and one for each slot.  It assumes there are no composites
    //  composites are figured in below.
    //
    m_NodeCount = USBD_BASE_NODES_PER_PORT*ulMaxPorts;

    //  Add two nodes: one for a host controller and one for
    //  an internal hub.  Alternatively, on SILVER we support
    //  two host controllers but no internal hub.
    //
    //  Also add a slop node.  This is for when a device stops
    //  responding and needs to be reenumerated on a full bus.
    //  Due to timing constraints only one slop node should ever
    //  be needed.
    //
    m_NodeCount += 3;
    
    //
    //  Now add nodes for the number of composites that can be found
    //  while enumerating a devices that is potentially not support.
    //
    m_NodeCount += 
        (m_Direct[0].MaxCompositeInterfaces +
         m_BottomSlots[0].MaxCompositeInterfaces +
         m_TopSlots[0].MaxCompositeInterfaces) * ulMaxPorts;

    //
    //  We also need nodes for composite interfaces of unsupported
    //  devices while they are enumerated, but before they are rejected.
    //
    SetToMax(m_MaxCompositeInterfaces,m_Direct[0].MaxCompositeInterfaces);
    SetToMax(m_MaxCompositeInterfaces,m_BottomSlots[0].MaxCompositeInterfaces);
    SetToMax(m_MaxCompositeInterfaces,m_TopSlots[0].MaxCompositeInterfaces);
    m_NodeCount += m_MaxCompositeInterfaces;

    //
    //  Add up the info that gets add across connector types and slots
    //
    for(ULONG ulSlotIndex = 0;  ulSlotIndex < ulMaxPorts; ulSlotIndex++)
    {
        //
        //  Sum the Interrupt endpoints by type  
        //
        ulInterruptEndpoints += m_Direct[ulSlotIndex].MaxInterruptEndpoints;
        ulInterruptEndpoints += m_BottomSlots[ulSlotIndex].MaxInterruptEndpoints;
        ulInterruptEndpoints += m_TopSlots[ulSlotIndex].MaxInterruptEndpoints;

        //
        //  Sum the Control endpoints by type  
        //
        ulControlEndpoints += m_Direct[ulSlotIndex].MaxControlEndpoints;
        ulControlEndpoints += m_BottomSlots[ulSlotIndex].MaxControlEndpoints;
        ulControlEndpoints += m_TopSlots[ulSlotIndex].MaxControlEndpoints;

        //
        //  Sum the Bulk endpoints by type  
        //
        ulBulkEndpoints += m_Direct[ulSlotIndex].MaxBulkEndpoints;
        ulBulkEndpoints += m_BottomSlots[ulSlotIndex].MaxBulkEndpoints;
        ulBulkEndpoints += m_TopSlots[ulSlotIndex].MaxBulkEndpoints;

        //
        //  Sum the Isoch endpoints by type
        //
        m_HcdResources.IsochEndpointCount += m_Direct[ulSlotIndex].MaxIsochEndpoints;
        m_HcdResources.IsochEndpointCount += m_BottomSlots[ulSlotIndex].MaxIsochEndpoints;
        m_HcdResources.IsochEndpointCount += m_TopSlots[ulSlotIndex].MaxIsochEndpoints;
    }

    //
    //  The hub driver is a special case.  It would be a different slot type,
    //  but instead it does not register, we just hard code it's resources.
    //  (The control qouta is less than enumerations, so don't worry about it.)
    //
    ulInterruptEndpoints += ulMaxPorts+1; //1 Interrupt EP per hub, one hub per port, plus an internal hub
    ulControlEndpoints += ulMaxPorts+1; //1 Control EP per hub, one hub per port, plus an internal hub

    //
    //  An extra control endpoint is needed for enumeration
    //  USBD also has a control TD quota
    ulControlEndpoints += 1;
    SetToMax(m_HcdResources.ControlTDQuota, USBD_CONTROL_TD_QUOTA);

    //
    //  add the control and bulk endpoints,
    //  we will add in the interrupt below.
    //
    m_HcdResources.EndpointCount = ulControlEndpoints + ulBulkEndpoints;

    //
    //  TD Count is the control quota plus the bulk quota plus
    //  one for each control and bulk endpoint, and USBD_INTERRUPT_TD_QUOTA
    //  times the number of interrupt endpoints.
    //
    m_HcdResources.TDCount = m_HcdResources.ControlTDQuota + m_HcdResources.BulkTDQuota +
                             m_HcdResources.EndpointCount +
                             (HCD_INTERRUPT_TD_QUOTA * ulInterruptEndpoints);

    //
    //  Now add in the interrupt endpoint.  Note that the isoch endpoint
    //  count is not included, ever.  Isoch endpoints are allocated differently.
    //
    m_HcdResources.EndpointCount += ulInterruptEndpoints;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbsamp\usbsamp.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    usbsamp.cpp

Abstract:

    This module implements a sample USB class driver.

--*/

#define _NTOS_
#include <ntddk.h>
#include <xtl.h>
#include <usb.h>
#include "hiddefs.h"
#include "usbsamp.h"

//
// Declare the structure used by the USB enumeration code to internally track
// devices of this type.
//

DECLARE_XPP_TYPE(XDEVICE_TYPE_SAMPLE)

//
// Create the table of device types that this class driver supports.
//

USB_DEVICE_TYPE_TABLE_BEGIN(Sample)
    USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_SAMPLE)
USB_DEVICE_TYPE_TABLE_END()

//
// Create the structure that binds the USB class, subclass, and protocol codes
// to this class driver.
//

USB_CLASS_DRIVER_DECLARATION(Sample, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)

//
// Register the class driver with the USB core driver by placing a pointer to
// the above structure in the .XPP$Class section.
//

#pragma data_seg(".XPP$ClassSample")
USB_CLASS_DECLARATION_POINTER(Sample)
#pragma data_seg(".XPP$Data")

//
// During device enumeration, an URB may be required.  Because device
// enumeration is serialized, only one URB is required.  Allocate this as a
// global.
//

URB SampleEnumerationUrb;

//
// Stores all of the per-port instance data related to a device.  Allocate the
// maximum number of devices as a global.
//

typedef struct _SAMPLE_DEVICE_STATE {
    IUsbDevice *Device;
    BOOLEAN DeviceAttached : 1;
    BOOLEAN DeviceReady : 1;
    BOOLEAN DeviceOpened : 1;
    BOOLEAN DeviceRemoved : 1;
    BOOLEAN DefaultEndpointOpened : 1;
    BOOLEAN ClosingEndpoints : 1;
    BOOLEAN RemoveDevicePending : 1;
    BOOLEAN CloseDevicePending : 1;
    UCHAR InterruptEndpointAddress;
    UCHAR InterfaceNumber;
    PVOID InterruptEndpointHandle;
    URB CloseEndpointUrb;
    KEVENT CloseEndpointEvent;
    CRITICAL_SECTION CriticalSection;
} SAMPLE_DEVICE_STATE, *PSAMPLE_DEVICE_STATE;

SAMPLE_DEVICE_STATE SampleDeviceState[XGetPortCount()];

//
// Local support.
//

VOID
SampleSetProtocolComplete(
    PURB Urb,
    PVOID Context
    );

VOID
SampleCloseEndpointsAsync(
    PSAMPLE_DEVICE_STATE DeviceState
    );

VOID
SampleInit(
    IUsbInit *UsbInit
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver to initialize the class
    driver.  This routine can allocate resources for the expected number of
    devices (either statically known or dynamically determined from the values
    from XInitDevices) and register resource requirements with the core USB
    driver.

Arguments:

    UsbInit - Specifies a virtual table of functions that can be used to control
        the behavior of this class driver.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PSAMPLE_DEVICE_STATE DeviceState;

    DbgPrint("SAMPLE: SampleInit called.\n");

    for (dwPort = 0; dwPort < XGetPortCount(); dwPort++) {

        DeviceState = &SampleDeviceState[dwPort];

        //
        // Initialize the event used to synchronize the closing of endpoints.
        //

        KeInitializeEvent(&DeviceState->CloseEndpointEvent,
            NotificationEvent, FALSE);

        //
        // Initialize the critical section used to synchronize passive level API
        // code.
        //

        InitializeCriticalSection(&DeviceState->CriticalSection);
    }

}

VOID
SampleAddDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been added that is supported by this class driver.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PSAMPLE_DEVICE_STATE DeviceState;
    const USB_DEVICE_DESCRIPTOR8 *DeviceDescriptor;
    const USB_CONFIGURATION_DESCRIPTOR *ConfigurationDescriptor;
    const USB_INTERFACE_DESCRIPTOR *InterfaceDescriptor;
    const USB_ENDPOINT_DESCRIPTOR *EndpointDescriptor;

    DbgPrint("SAMPLE: SampleAddDevice called.\n");

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Verify that the device is attached to a legal port number.  Note that if
    // the device were plugged into the bottom slot of a hub, then the port
    // number will exceed XGetPortCount() and we'll ignore the device.
    //

    dwPort = Device->GetPort();

    if (dwPort >= XGetPortCount()) {
        DbgPrint("SAMPLE: Illegal port number.\n");
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    DeviceState = &SampleDeviceState[dwPort];

    //
    // Verify that we haven't already seen a device attached.
    //

    if (DeviceState->DeviceAttached) {
        DbgPrint("SAMPLE: Device already attached.\n");
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    ASSERT(!DeviceState->DeviceReady);

    //
    // Dump the contents of the device descriptor.
    //

    DeviceDescriptor = Device->GetDeviceDescriptor();

    DbgPrint("Device Descriptor\n");
    DbgPrint("\tbLength=%02x\n", DeviceDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", DeviceDescriptor->bDescriptorType);
    DbgPrint("\tbcdUSB=%04x\n", DeviceDescriptor->bcdUSB);
    DbgPrint("\tbDeviceClass=%02x\n", DeviceDescriptor->bDeviceClass);
    DbgPrint("\tbDeviceSubClass=%02x\n", DeviceDescriptor->bDeviceSubClass);
    DbgPrint("\tbDeviceProtocol=%02x\n", DeviceDescriptor->bDeviceProtocol);
    DbgPrint("\tbMaxPacketSize0=%02x\n", DeviceDescriptor->bMaxPacketSize0);
    DbgPrint("\n");

    //
    // Dump the contents of the configuration descriptor.
    //

    ConfigurationDescriptor = Device->GetConfigurationDescriptor();

    DbgPrint("Configuration Descriptor\n");
    DbgPrint("\tbLength=%02x\n", ConfigurationDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", ConfigurationDescriptor->bDescriptorType);
    DbgPrint("\twTotalLength=%04x\n", ConfigurationDescriptor->wTotalLength);
    DbgPrint("\tbNumInterfaces=%02x\n", ConfigurationDescriptor->bNumInterfaces);
    DbgPrint("\tbConfigurationValue=%02x\n", ConfigurationDescriptor->bConfigurationValue);
    DbgPrint("\tiConfiguration=%02x\n", ConfigurationDescriptor->iConfiguration);
    DbgPrint("\tbmAttributes=%02x\n", ConfigurationDescriptor->bmAttributes);
    DbgPrint("\tMaxPower=%02x\n", ConfigurationDescriptor->MaxPower);
    DbgPrint("\n");

    //
    // Dump the contents of the interface descriptor.
    //

    InterfaceDescriptor = Device->GetInterfaceDescriptor();

    DbgPrint("Interface Descriptor\n");
    DbgPrint("\tbLength=%02x\n", InterfaceDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", InterfaceDescriptor->bDescriptorType);
    DbgPrint("\tbInterfaceNumber=%02x\n", InterfaceDescriptor->bInterfaceNumber);
    DbgPrint("\tbAlternateSetting=%02x\n", InterfaceDescriptor->bAlternateSetting);
    DbgPrint("\tbNumEndpoints=%02x\n", InterfaceDescriptor->bNumEndpoints);
    DbgPrint("\tbInterfaceClass=%02x\n", InterfaceDescriptor->bInterfaceClass);
    DbgPrint("\tbInterfaceSubClass=%02x\n", InterfaceDescriptor->bInterfaceSubClass);
    DbgPrint("\tbInterfaceProtocol=%02x\n", InterfaceDescriptor->bInterfaceProtocol);
    DbgPrint("\tiInterface=%02x\n", InterfaceDescriptor->iInterface);
    DbgPrint("\n");

    //
    // Dump the contents of the endpoint descriptor.
    //

    EndpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT,
        TRUE, 0);

    if (EndpointDescriptor == NULL) {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    DbgPrint("Endpoint Descriptor\n");
    DbgPrint("\tbLength=%02x\n", EndpointDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", EndpointDescriptor->bDescriptorType);
    DbgPrint("\tbEndpointAddress=%02x\n", EndpointDescriptor->bEndpointAddress);
    DbgPrint("\tbmAttributes=%02x\n", EndpointDescriptor->bmAttributes);
    DbgPrint("\twMaxPacketSize=%02x\n", EndpointDescriptor->wMaxPacketSize);
    DbgPrint("\tbInterval=%02x\n", EndpointDescriptor->bInterval);
    DbgPrint("\n");

    //
    // Verify that the device supports the mouse boot protocol.
    //

    if ((InterfaceDescriptor->bInterfaceSubClass != HID_SUBCLASS_BOOT) ||
        (InterfaceDescriptor->bInterfaceProtocol != HID_PROTOCOL_MOUSE)) {
        DbgPrint("SAMPLE: Device is not a mouse.\n");
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Remember that a device is physically attached.
    //

    DeviceState->DeviceAttached = TRUE;

    //
    // Store information about the device in our globals.
    //

    DeviceState->Device = Device;
    DeviceState->InterfaceNumber = Device->GetInterfaceNumber();
    DeviceState->InterruptEndpointAddress =
        EndpointDescriptor->bEndpointAddress;

    //
    // The USB enumeration code has the default endpoint open for a class driver
    // to use until the AddComplete routine is invoked.  After AddComplete has
    // been called, then the class driver must open the default endpoint itself.
    //
    // For a mouse device, we need to switch to the boot protocol, so do that
    // now while the default endpoint is open.
    //

    USB_BUILD_CONTROL_TRANSFER(&SampleEnumerationUrb.ControlTransfer,
                               NULL,
                               NULL,
                               0,
                               0,
                               SampleSetProtocolComplete,
                               DeviceState,
                               TRUE,
                               USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                               HID_REQUEST_SET_PROTOCOL,
                               HID_SET_PROTOCOL_BOOT,
                               DeviceState->InterfaceNumber,
                               0);

    Device->SubmitRequest(&SampleEnumerationUrb);

    //
    // The USB enumeration code is blocked until we call AddComplete on our
    // device, but other processing will continue while the above request is in
    // progress.
    //
}

VOID
SampleSetProtocolComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after the URB has completed to set the protocol of
    the HID device.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to URB_BUILD_CONTROL_TRANSFER.

Return Value:

    None.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceState = (PSAMPLE_DEVICE_STATE)Context;

    //
    // Check if an error occurred while setting the protocol.  If so, fail to
    // attach the device and forward the error to the USB enumeration code.
    //

    if (USBD_ERROR(Urb->Header.Status)) {
        DeviceState->DeviceAttached = FALSE;
        DeviceState->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Remember that the device is now ready to be used.
    //

    DeviceState->DeviceReady = TRUE;

    //
    // Notify the USB enumeration code that we have successfully added the
    // device.
    //
    // Note that after this call has completed, the default endpoint is no
    // longer open and we must manually open it if required.
    //

    DeviceState->Device->AddComplete(USBD_STATUS_SUCCESS);
}

VOID
SampleRemoveDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been removed that had successfully been added before.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PSAMPLE_DEVICE_STATE DeviceState;

    DbgPrint("SAMPLE: SampleRemoveDevice called.\n");

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    dwPort = Device->GetPort();

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    ASSERT(DeviceState->DeviceAttached);
    ASSERT(DeviceState->Device == Device);

    //
    // Remember that we're in the middle of a device removal.
    //

    DeviceState->RemoveDevicePending = TRUE;

    //
    // Close all of the open endpoints.  When this operation completes, the
    // remove device process will be completed.
    //

    SampleCloseEndpointsAsync(DeviceState);
}

USBD_STATUS
SampleOpenEndpoints(
    PSAMPLE_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine opens all of the endpoints for the device.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be opened.

Return Value:

    USBD status code.

--*/
{
    URB OpenUrb;
    USBD_STATUS UsbdStatus;

    //
    // Open the default endpoint.
    //

    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&OpenUrb.OpenEndpoint);

    UsbdStatus = DeviceState->Device->SubmitRequest(&OpenUrb);

    if (USBD_SUCCESS(UsbdStatus)) {

        DeviceState->DefaultEndpointOpened = TRUE;

        //
        // Open the "interrupt in" endpoint.
        //

        USB_BUILD_OPEN_ENDPOINT(&OpenUrb.OpenEndpoint,
                                DeviceState->InterruptEndpointAddress,
                                USB_ENDPOINT_TYPE_INTERRUPT,
                                sizeof(HID_BOOT_MOUSE_REPORT),
                                10);

        UsbdStatus = DeviceState->Device->SubmitRequest(&OpenUrb);

        if (USBD_SUCCESS(UsbdStatus)) {
            DeviceState->InterruptEndpointHandle =
                OpenUrb.OpenEndpoint.EndpointHandle;
        }
    }

    return UsbdStatus;
}

VOID
SampleCloseEndpointsComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after the URB has completed to close an endpoint.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to URB_BUILD_CONTROL_TRANSFER.

Return Value:

    None.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceState = (PSAMPLE_DEVICE_STATE)Context;

    if (DeviceState->DefaultEndpointOpened) {

        //
        // Close the default endpoint.
        //

        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb->CloseEndpoint,
                                         SampleCloseEndpointsComplete,
                                         DeviceState);

        DeviceState->DefaultEndpointOpened = FALSE;

    } else if (DeviceState->InterruptEndpointHandle != NULL) {

        //
        // Close the "interrupt in" endpoint.
        //

        USB_BUILD_CLOSE_ENDPOINT(&Urb->CloseEndpoint,
                                 DeviceState->InterruptEndpointHandle,
                                 SampleCloseEndpointsComplete,
                                 DeviceState);

        DeviceState->InterruptEndpointHandle = NULL;

    } else {

        //
        // All endpoints are closed.  Signal the close endpoint event in case a
        // thread is waiting for the close endpoint to complete.
        //

        KeSetEvent(&DeviceState->CloseEndpointEvent, IO_NO_INCREMENT,
            FALSE);
        DeviceState->ClosingEndpoints = FALSE;

        //
        // If the device has been removed, then complete the device removal
        // process by notifying the USB enumeration code.
        //

        if (DeviceState->RemoveDevicePending) {

            DeviceState->RemoveDevicePending = FALSE;
            DeviceState->DeviceAttached = FALSE;
            DeviceState->DeviceReady = FALSE;
            DeviceState->DeviceRemoved = TRUE;

            DeviceState->Device->RemoveComplete();
        }

        return;
    }

    //
    // There's at least one endpoint still open.  If an endpoint is open, then
    // we must still think the device is logically attached and connected to
    // this device extension.
    //

    ASSERT(DeviceState->DeviceAttached);

    //
    // Submit the close request and wait for the USB driver to close the
    // endpoint.
    //

    DeviceState->Device->SubmitRequest(Urb);
}

VOID
SampleCloseEndpointsAsync(
    PSAMPLE_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine asynchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be closed.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we haven't already started closing endpoints, then kick off the
    // process.
    //

    if (!DeviceState->ClosingEndpoints) {

        //
        // Clear the close endpoint event used for synchronous close operations.
        //

        KeClearEvent(&DeviceState->CloseEndpointEvent);
        DeviceState->ClosingEndpoints = TRUE;

        //
        // Enter the close endpoints state machine.
        //

        SampleCloseEndpointsComplete(&DeviceState->CloseEndpointUrb,
            DeviceState);
    }
}

VOID
SampleCloseEndpoints(
    PSAMPLE_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine synchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be opened.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Asynchronously close all of the open endpoints.  When all of the
    // endpoints are closed, the close endpoint event is signaled.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    SampleCloseEndpointsAsync(DeviceState);

    KeLowerIrql(OldIrql);

    //
    // Block until the endpoints have been closed.
    //

    KeWaitForSingleObject(&DeviceState->CloseEndpointEvent, Executive,
        KernelMode, FALSE, NULL);
}

DWORD
SampleOpenDevice(
    DWORD dwPort
    )
/*++

Routine Description:

    This routine is invoked by application code to open a device that has been
    successfully enumerated (in particular, XGetDevices reports that the device
    is present).

Arguments:

    dwPort - Specifies the port number of the device to be opened.

Return Value:

    Status of operation.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;
    KIRQL OldIrql;
    USBD_STATUS UsbdStatus;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    //
    // Synchronize passive level access to this device's state.
    //

    EnterCriticalSection(&DeviceState->CriticalSection);

    //
    // If the device has already been opened, then bail out now.

    if (DeviceState->DeviceOpened) {
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return ERROR_SHARING_VIOLATION;
    }

    //
    // Synchronize access to our globals with the AddDevice and RemoveDevice
    // entrypoints by raising the IRQL to DPC level.  While running at this
    // raised IRQL, thread preemption is disabled.  Only interupt service
    // routines are allowed to run.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Reset the flag that indicates that the device has been removed while the
    // device was open or was in the process of opening.
    //

    DeviceState->DeviceRemoved = FALSE;

    //
    // If the device is not ready for use, then bail out now.
    //

    if (!DeviceState->DeviceReady) {
        KeLowerIrql(OldIrql);
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return ERROR_DEVICE_NOT_CONNECTED;
    }

    //
    // Open the device's endpoints.  Note that if this routine fails, some of
    // the endpoints may have been opened, so we need to close these endpoints.
    //

    UsbdStatus = SampleOpenEndpoints(DeviceState);

    if (!USBD_SUCCESS(UsbdStatus)) {
        KeLowerIrql(OldIrql);
        SampleCloseEndpoints(DeviceState);
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return IUsbDevice::Win32FromUsbdStatus(UsbdStatus);
    }

    //
    // Remember that the device is now open.
    //

    DeviceState->DeviceOpened = TRUE;

    KeLowerIrql(OldIrql);

    LeaveCriticalSection(&DeviceState->CriticalSection);

    return ERROR_SUCCESS;
}

VOID
SampleSignalEventComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after a generic URB has completed.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to the URB builder macro.

Return Value:

    None.

--*/
{
    //
    // Wake up the thread waiting for the URB to complete.
    //

    KeSetEvent((PKEVENT)Context, EVENT_INCREMENT, FALSE);
}

DWORD
SampleReadButtons(
    DWORD dwPort,
    LPBYTE lpbButtons
    )
/*++

Routine Description:

    This routine is invoked by application code to read the button state.

Arguments:

    dwPort - Specifies the port number of the device to be read from.

    lpbButtons - Specifies the location to receive the button state.

Return Value:

    Status of operation.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;
    KIRQL OldIrql;
    KEVENT Event;
    URB Urb;
    HID_BOOT_MOUSE_REPORT BootMouseReport;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // If the device hasn't been opened, if the device is in the process of
    // being removed, or if the device has already been removed, then fail the
    // request.
    //

    if (!DeviceState->DeviceOpened || DeviceState->RemoveDevicePending ||
        DeviceState->DeviceRemoved) {
        KeLowerIrql(OldIrql);
        return ERROR_DEVICE_NOT_CONNECTED;
    }

    //
    // Initialize the event used to wait for the below URB to complete.
    //

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Build an URB to do a control transfer from the default endpoint.  Read
    // the input report from the mouse interface.
    //

    USB_BUILD_CONTROL_TRANSFER(&Urb.ControlTransfer,
                               NULL,
                               &BootMouseReport,
                               sizeof(HID_BOOT_MOUSE_REPORT),
                               USB_TRANSFER_DIRECTION_IN,
                               SampleSignalEventComplete,
                               &Event,
                               TRUE,
                               USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                               HID_REQUEST_GET_REPORT,
                               MAKEWORD(0, 1),
                               DeviceState->InterfaceNumber,
                               sizeof(HID_BOOT_MOUSE_REPORT));

    DeviceState->Device->SubmitRequest(&Urb);

    //
    // Wait for the URB to complete.  This must be done at lowered IRQL.
    //

    KeLowerIrql(OldIrql);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

    //
    // Check the URB for any errors.
    //

    if (USBD_ERROR(Urb.Header.Status)) {
        return IUsbDevice::Win32FromUsbdStatus(Urb.Header.Status);
    }

    //
    // The input report was successfullly read from the mouse, so return the
    // button state to the caller.
    //

    *lpbButtons = BootMouseReport.Buttons;

    return ERROR_SUCCESS;
}

VOID
SampleCloseDevice(
    DWORD dwPort
    )
/*++

Routine Description:

    This routine is invoked by application code to close a device that had been
    successfully opened.

Arguments:

    dwPort - Specifies the port number of the device to be closed.

Return Value:

    None.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;
    KIRQL OldIrql;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    //
    // Synchronize passive level access to this device's state.
    //

    EnterCriticalSection(&DeviceState->CriticalSection);

    //
    // If the device hasn't been opened, then bail out now.
    //

    if (!DeviceState->DeviceOpened) {
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return;
    }

    //
    // Close the device's endpoints.
    //

    SampleCloseEndpoints(DeviceState);

    //
    // Synchronize access to our globals with the AddDevice and RemoveDevice
    // entrypoints by raising the IRQL to DPC level.  While running at this
    // raised IRQL, thread preemption is disabled.  Only interupt service
    // routines are allowed to run.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Remember that the device is now closed.
    //

    DeviceState->DeviceOpened = FALSE;

    KeLowerIrql(OldIrql);

    LeaveCriticalSection(&DeviceState->CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbsamp\usbsamp.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    usbsamp.h

Abstract:

    This module contains the public interface for a sample USB class driver.

--*/

#ifndef _USBSAMP_
#define _USBSAMP_

#ifdef __cplusplus
extern "C" {
#endif

extern XPP_DEVICE_TYPE XDEVICE_TYPE_SAMPLE_TABLE;
#define XDEVICE_TYPE_SAMPLE (&XDEVICE_TYPE_SAMPLE_TABLE)

DWORD
WINAPI
SampleOpenDevice(
    DWORD dwPort
    );

DWORD
WINAPI
SampleReadButtons(
    DWORD dwPort,
    LPBYTE lpbButtons
    );

VOID
WINAPI
SampleCloseDevice(
    DWORD dwPort
    );

#ifdef __cplusplus
}
#endif

#endif  // USBSAMP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbsamp\hiddefs.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    hiddefs.h

Abstract:

    This module contains the definitions and structures for interfacing with
    Human Interface Devices (HID).

--*/

#ifndef _HIDDEFS_
#define _HIDDEFS_

#include <pshpack1.h>

//
// HID interface subclass codes.
//

#define HID_SUBCLASS_NONE                           0x00
#define HID_SUBCLASS_BOOT                           0x01

//
// HID interface protocol codes.
//

#define HID_PROTOCOL_NONE                           0x00
#define HID_PROTOCOL_KEYBOARD                       0x01
#define HID_PROTOCOL_MOUSE                          0x02

//
// HID class specific request codes.
//

#define HID_REQUEST_GET_REPORT                      0x01
#define HID_REQUEST_GET_IDLE                        0x02
#define HID_REQUEST_GET_PROTOCOL                    0x03
#define HID_REQUEST_SET_REPORT                      0x09
#define HID_REQUEST_SET_IDLE                        0x0A
#define HID_REQUEST_SET_PROTOCOL                    0x0B

//
// HID_REQUEST_SET_PROTOCOL request codes.
//

#define HID_SET_PROTOCOL_BOOT                       0x00
#define HID_SET_PROTOCOL_REPORT                     0x01

//
// Structure for a report generated by a mouse in boot protocol mode.
//

typedef struct _HID_BOOT_MOUSE_REPORT {
    union {
        struct {
            UCHAR Button1 : 1;
            UCHAR Button2 : 1;
            UCHAR Button3 : 1;
            UCHAR DeviceSpecific1 : 5;
        };
        UCHAR Buttons;
    };
    UCHAR DisplacementX;
    UCHAR DisplacementY;
    UCHAR DeviceSpecific2[5];
} HID_BOOT_MOUSE_REPORT, *PHID_BOOT_MOUSE_REPORT;

#include <poppack.h>

#endif  // HIDDEFS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbd\usbdev.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usbdev.cpp

Abstract:

    This module contains the implementation of IUsbDevice
    except for the routine involved with device enumeration.
    
Environment:

    XBOX kernel.

Notes:
  

Revision History:
    
    03-24-00: Create (mitchd)
    06-12-00: renamed to usbdev and changed to implement in c++.

--*/

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>
//#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBD");


//
//  Pull in remaining usb headers
//
#include <usbd.h>

VOID
USBD_SubmitSynchronousRequestComplete(
    IN PURB     Urb,
    IN PKEVENT  Event
    )
/*++
Routine Description:

    Completion routine used by USBD_STATUS IUsbDevice::SubmitRequest,
    when blocking on an asynchronous request.

 Arguments:

    Urb     - URB that completed.
    Event   - Pointer to event that caller is blocking on.

Return Value:

    USBD_STATUS_SUCCESS - Or wide variety of possible errors.
    The possible errors for each URB can be found where the URB
    functions are defined.

--*/
{
    UNREFERENCED_PARAMETER(Urb);
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return;
}


USBD_STATUS IUsbDevice::SubmitRequest(PURB Urb)
/*++
Routine Description:

    Class drivers call this function to submit URBs to the HCD.
    This routine picks off the URBs that it handles or preprocesses
    and then passes the URBs down to the HCD if necessary.

Arguments:

  Urb             -   URB to handle

Return Value:

    USBD_STATUS_SUCCESS - Or wide variety of possible errors.
    The possible errors for each URB can be found where the URB
    functions are defined.

--*/
{
    BOOLEAN block = FALSE;
    USBD_STATUS usbdStatus;
    KEVENT SyncEvent;
    BOOLEAN submitRequestHere = TRUE;
    //
    //  Check if this is an aynschrnous request and we need
    //  to block until done.
    //
    if(
        (Urb->Header.Function&URB_FUNCTION_ASYNCHRONOUS) &&
        (NULL == Urb->Header.CompleteProc)
    )
    {
        block = TRUE;
        ASSERT_LESS_THAN_DISPATCH_LEVEL();
        //
        //  Initialize an event, and setup completion
        //  routine that will set the event.
        //
        
        KeInitializeEvent(&SyncEvent, NotificationEvent, FALSE);
        Urb->Header.CompleteProc = (PURB_COMPLETE_PROC)USBD_SubmitSynchronousRequestComplete;
        Urb->Header.CompleteContext = (PVOID)&SyncEvent;
    }
    //
    //  There are couple of URBs we need to preprocess
    //
    switch(Urb->Header.Function)
    {
        case URB_FUNCTION_OPEN_DEFAULT_ENDPOINT:
            submitRequestHere = FALSE;
            usbdStatus = OpenDefaultEndpoint(Urb);
            break;
        case URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT:
            submitRequestHere = FALSE;
            usbdStatus = CloseDefaultEndpoint(Urb);
            break;
        case URB_FUNCTION_OPEN_ENDPOINT:
            Urb->OpenEndpoint.FunctionAddress = m_Address;
            Urb->OpenEndpoint.DataToggleBits = &m_DataToggleBits;
            Urb->OpenEndpoint.LowSpeed = GetLowSpeed();
            break;
        case URB_FUNCTION_CLOSE_ENDPOINT:
            Urb->CloseEndpoint.DataToggleBits = &m_DataToggleBits;
            break;
        case URB_FUNCTION_ISOCH_OPEN_ENDPOINT:
            Urb->IsochOpenEndpoint.FunctionAddress = m_Address;
            break;
        //case URB_FUNCTION_RESET_PORT:
        case URB_FUNCTION_CONTROL_TRANSFER:
            //
            //  Resolve the endpoint handle for the default endpoint.
            //
            if(NULL == Urb->ControlTransfer.EndpointHandle)
            {
                ASSERT(m_DefaultEndpoint);
                Urb->ControlTransfer.EndpointHandle = m_DefaultEndpoint;
            }
            //
            //  If this is a set configuration, clear the cached toggle
            //  bits.
            //
            if(USB_REQUEST_SET_CONFIGURATION == Urb->ControlTransfer.SetupPacket.bRequest)
            {
                m_DataToggleBits = 0;
            }
            break;
    }
    //
    //  Pass URB on to HCD  (Open and close default endpoint, do it
    //  before getting here).
    if(submitRequestHere)
    {
        usbdStatus = HCD_SubmitRequest(USBD_GetHCDExtension(m_HostController), Urb);

    }
    //
    //  Check if we need to wait.
    //
    if(block)
    {
        if(USBD_PENDING(usbdStatus))
        {
            KeWaitForSingleObject(&SyncEvent, Executive, KernelMode, FALSE, NULL);
            usbdStatus = Urb->Header.Status;
        }
        Urb->Header.CompleteProc = NULL;
        Urb->Header.CompleteContext = NULL;
    }
    return usbdStatus;
}

USBD_STATUS IUsbDevice::CancelRequest(PURB Urb)
{
    return HCD_CancelRequest(USBD_GetHCDExtension(m_HostController), Urb);
}


PVOID IUsbDevice::GetExtension() const
/*++
Routine Description:
    Retrieves the value of a the class driver defined
    extension.
Return Value:
    Previously set class driver extension.
--*/
{
    return m_ClassDriverExtension;
}
PVOID IUsbDevice::SetExtension(PVOID Extension)
/*++
Routine Description:
    Allows a the class driver to set an extension.
Return Value:
    Previous value for class driver extension.
--*/
{
    PVOID temp = m_ClassDriverExtension;
    m_ClassDriverExtension = Extension;
    return temp;
}

BOOLEAN IUsbDevice::IsHardwareConnected() const
/*++
Routine Description:

    Retrieves whether the hardware is still connected.
    
    The implmentation depends on the fact that the very first
    step when getting DeviceDisconnected call from the HUB
    is to orphan the device node.

Return Value:

    Previously set class driver extension.

--*/
{
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        return (GetParent()->GetParent()) ? TRUE : FALSE;
    } else
    {
        return GetParent() ? TRUE : FALSE;
    }
}

UCHAR IUsbDevice::GetInterfaceNumber() const
/*++
Routine Description:
    Returns the interface number for a device
Return Value:
    The interface number that was originally
    in the interface descriptor.
--*/
{
    ASSERT((UDN_TYPE_INTERFACE == m_Type) || (UDN_TYPE_INTERFACE_FUNCTION == m_Type));
    return this->m_bInterfaceNumber;
}

void IUsbDevice::SetClassSpecificType(UCHAR ClassSpecificType)
/*++
Routine Description:
	Class driver calls this to set the class specific byte in the USB_DEVICE_TYPE
	returned for this device.
Return Value:
    none.
--*/
{
	m_ClassSpecificType = ClassSpecificType;
}

ULONG IUsbDevice::Win32FromUsbdStatus(USBD_STATUS UsbdStatus)
/*++
Routine Description:
    Returns a Win32 error code (NOT NT_STATUS) given a USBD_STATUS code.
Comment:
    This makes good sense because XID exposes an API directly,
    we may need to provide a separate function to convert to NT_STATUS
    for class drivers with layers above them.
--*/
{
    switch(UsbdStatus)
    {
        case USBD_STATUS_SUCCESS:
            return ERROR_SUCCESS;
        case USBD_STATUS_PENDING:
            return ERROR_IO_PENDING;
        case USBD_STATUS_ERROR:
        case USBD_STATUS_HALTED:
        case USBD_STATUS_CRC:
        case USBD_STATUS_BTSTUFF:
        case USBD_STATUS_DATA_TOGGLE_MISMATCH:
        case USBD_STATUS_STALL_PID:
        case USBD_STATUS_DEV_NOT_RESPONDING:
        case USBD_STATUS_PID_CHECK_FAILURE:
        case USBD_STATUS_UNEXPECTED_PID:
        case USBD_STATUS_DATA_OVERRUN:
        case USBD_STATUS_DATA_UNDERRUN:
        case USBD_STATUS_RESERVED1:
        case USBD_STATUS_RESERVED2:
        case USBD_STATUS_BUFFER_OVERRUN:
        case USBD_STATUS_BUFFER_UNDERRUN:
        case USBD_STATUS_NOT_ACCESSED:
        case USBD_STATUS_FIFO:
            return ERROR_IO_DEVICE;
        case USBD_STATUS_NO_MEMORY:
            return ERROR_OUTOFMEMORY;
        case USBD_STATUS_NO_BANDWIDTH:
            return ERROR_NO_SYSTEM_RESOURCES;
        case USBD_STATUS_CANCELED:
            return ERROR_CANCELLED;
        default:
            return ERROR_GEN_FAILURE;
    }
}

NTSTATUS IUsbDevice::NtStatusFromUsbdStatus(USBD_STATUS UsbdStatus)
/*++
Routine Description:
    Returns a NTSTATUS error code given a USBD_STATUS code.
Comment:
--*/
{
    switch(UsbdStatus)
    {
        case USBD_STATUS_SUCCESS:
            return STATUS_SUCCESS;
        case USBD_STATUS_PENDING:
            return STATUS_PENDING;
        case USBD_STATUS_ERROR:
        case USBD_STATUS_HALTED:
        case USBD_STATUS_CRC:
        case USBD_STATUS_BTSTUFF:
        case USBD_STATUS_DATA_TOGGLE_MISMATCH:
        case USBD_STATUS_STALL_PID:
        case USBD_STATUS_DEV_NOT_RESPONDING:
        case USBD_STATUS_PID_CHECK_FAILURE:
        case USBD_STATUS_UNEXPECTED_PID:
        case USBD_STATUS_DATA_OVERRUN:
        case USBD_STATUS_DATA_UNDERRUN:
        case USBD_STATUS_RESERVED1:
        case USBD_STATUS_RESERVED2:
        case USBD_STATUS_BUFFER_OVERRUN:
        case USBD_STATUS_BUFFER_UNDERRUN:
        case USBD_STATUS_NOT_ACCESSED:
        case USBD_STATUS_FIFO:
            return STATUS_IO_DEVICE_ERROR;
        case USBD_STATUS_NO_BANDWIDTH:
        case USBD_STATUS_NO_MEMORY:
            return STATUS_INSUFFICIENT_RESOURCES;
        case USBD_STATUS_CANCELED:
            return STATUS_CANCELLED;
        default:
            return STATUS_UNSUCCESSFUL;
    }
}

const USB_DEVICE_DESCRIPTOR8 *IUsbDevice::GetDeviceDescriptor() const
/*++
Routine Description:
    Provides Class Driver with access to first eight bytes of device descriptor.
--*/
{
    ASSERT(IsEnumTime());
    return &g_DeviceTree.m_DeviceDescriptor;
}

const USB_CONFIGURATION_DESCRIPTOR *IUsbDevice::GetConfigurationDescriptor() const
/*++
Routine Description:
    Provides Class Driver with access to Configuration descriptor.
    Only available to Interface Class Drivers at enum time.
--*/
{
    ASSERT(IsEnumTime());
    ASSERT((UDN_TYPE_INTERFACE == m_Type)||(UDN_TYPE_INTERFACE_FUNCTION == m_Type));
    return (PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer;
}

const USB_INTERFACE_DESCRIPTOR *IUsbDevice::GetInterfaceDescriptor() const
/*++
Routine Description:
    Provides Class Driver with access to Configuration descriptor.
    Only available to Interface Class Drivers at enum time.
--*/
{
    ASSERT(IsEnumTime());
    ASSERT((UDN_TYPE_INTERFACE == m_Type)||(UDN_TYPE_INTERFACE_FUNCTION == m_Type));
    return g_DeviceTree.m_InterfaceDescriptor;
}


const USB_ENDPOINT_DESCRIPTOR *IUsbDevice::GetEndpointDescriptor(UCHAR EndpointType, BOOLEAN InDirection, UCHAR Index) const
/*++
Routine Description:
    Searches the class drivers interface for an endpoint.
    Only available to Interface Class Drivers at enum time.
Arguments:
    EndpointType - from usb100.h one of:
                    USB_ENDPOINT_TYPE_CONTROL
                    USB_ENDPOINT_TYPE_ISOCHRONOUS
                    USB_ENDPOINT_TYPE_BULK
                    USB_ENDPOINT_TYPE_INTERRUPT
    Direction - True if the endpoint direction is in.  Ignored for USB_ENDPOINT_TYPE_CONTROL.
    Index - Zero based index to endpoint of that type and direction.
    e.g. Find the first bulk-out endpoint: GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, FALSE, 0).
         Find the second bulk-out endpoint: GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, FALSE, 1).
Return Value:
    Pointer to endpoint descriptor for matching endpoint.
    NULL if endpoint not found.
--*/
{
    ASSERT(IsEnumTime());
    ASSERT((UDN_TYPE_INTERFACE == m_Type)||(UDN_TYPE_INTERFACE_FUNCTION == m_Type));

    PUCHAR currentParseLocation = (PUCHAR)g_DeviceTree.m_InterfaceDescriptor;
    PUCHAR endOfCongifuration = g_DeviceTree.m_ConfigurationDescriptorBuffer + 
            ((PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer)->wTotalLength;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor = NULL;
    do
    {
        if(0==((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength) break;
        currentParseLocation += ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength;
        if(currentParseLocation >= endOfCongifuration) break;
        
        if(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE)
        {
            PUSB_ENDPOINT_DESCRIPTOR temp = (PUSB_ENDPOINT_DESCRIPTOR)currentParseLocation;
            if((temp->bmAttributes&USB_ENDPOINT_TYPE_MASK) == EndpointType)
            {
                if( 
                    (EndpointType != USB_ENDPOINT_TYPE_CONTROL) &&
					//When comparing BOOLEANs, compare their logical NOT's
                    (!USB_ENDPOINT_DIRECTION_IN(temp->bEndpointAddress) == !InDirection) 
                ){
                    if(0 == Index--)
                    {
                        endpointDescriptor = temp;
                        break;
                    }
                }
            }
        }   
    } while(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE);
    return endpointDescriptor;
}

ULONG IUsbDevice::GetPort() const
{
    return m_ExternalPort;
}

USBD_STATUS IUsbDevice::OpenDefaultEndpoint(PURB Urb)
/*++
Routine Description:

    Default endpoints are owned by USBD not by the class
    drivers.  However, USBD only uses the default endpoint
    during enumeration and then closes it.  If a class driver
    needs to send commands over the default endpoint is must
    send an URB_FUNCTION_OPEN_DEFAULT_ENDPOINT, which ends
    up in this routine.

    For UDN_TYPE_INTERFACE, there is one default endpoint
    shared between multiple interfaces (i.e. class drivers).
    The default endpoint may be open for the parent ofd type
    UDN_TYPE_COMPOSITE_FUNCTION, and therefore for at least one
    of the siblings.  In this case, we can handle the URB competely
    here.  If it is not open for the parent we need to open the
    default endpoint for the parent first.

    For UDN_TYPE_INTERFACE_FUNCTION, UDN_TYPE_FUNCTION, and
    UDN_TYPE_HUB the default endpoint is not shared.  We just
    need to copy some info out of the node into the URB before
    passing it down.

    Fortunately, OpenDefaultEndpoint is inherently synchronous so
    we can do post-processing without blocking.

    This routine does not use preallocating, because it
    should never be called during enumeration.
    
Arguments:
    
    Urb             -   URB to handle

Return Value:

    USBD_STATUS_SUCCESS
    USBD_STATUS_NO_MEMORY - If there is not enough memory for the endpoint.

--*/
{
    USBD_STATUS status;
    IUsbDevice *parent=NULL;
    //
    //  If this assertion is hit, someone is trying to open
    //  a default endpoint that is already open.
    //
    ASSERT(NULL == m_DefaultEndpoint);

    //
    //  Handle UDN_TYPE_INTERFACE.
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        parent = GetParent();
        ASSERT(parent);
        if(parent->m_DefaultEndpoint)
        {
            //
            //  The parent was open just copy the endpoint handle.
            //
            m_DefaultEndpoint = parent->m_DefaultEndpoint;
            USB_DBG_TRACE_PRINT(("Open Default endpoint for UDN_TYPE_INTERFACE already open using parent's"));
            //
            //  Even inherently synchronous URBs need completion
            //
            Urb->Header.Status = USBD_STATUS_SUCCESS;
            USBD_CompleteRequest(Urb);
            return USBD_STATUS_SUCCESS;
        }
    }

    //
    //  We actually need to open an endpoint, which means we need
    //  to finish filling out the URB with stuff from the node.
    //
    Urb->OpenEndpoint.FunctionAddress = m_Address;
    Urb->OpenEndpoint.EndpointAddress = 0;
    Urb->OpenEndpoint.EndpointType = USB_ENDPOINT_TYPE_CONTROL;
    Urb->OpenEndpoint.MaxPacketSize = m_MaxPacket0;
    Urb->OpenEndpoint.LowSpeed = GetLowSpeed();
    Urb->OpenEndpoint.Hdr.Function = URB_FUNCTION_OPEN_ENDPOINT;
    Urb->OpenEndpoint.DataToggleBits = NULL;

    //
    //  Pass URB on to HCD
    //
    status = HCD_SubmitRequest(USBD_GetHCDExtension(m_HostController), Urb);
    
    //
    //  If the endpoint successfully opened, store away the handle.
    //
    if(USBD_SUCCESS(status))
    {
        m_DefaultEndpoint = Urb->OpenEndpoint.EndpointHandle;
        if(parent)
        {
             parent->m_DefaultEndpoint = Urb->OpenEndpoint.EndpointHandle;
        }
        ASSERT(m_DefaultEndpoint);
    } else
    {
        ASSERT(FALSE);
    }

    //
    //  Don't show caller default endpoint.
    //
    Urb->OpenEndpoint.EndpointHandle = NULL;
    //
    //  HCD completed the URB so we shouldn't.
    //
    return status;
}


USBD_STATUS IUsbDevice::CloseDefaultEndpoint(PURB Urb)
/*++
Routine Description:

    This routine is called in response to URB_CLOSE_DEFAULT_ENDPOINT and it
    undoes IUsbDevice::OpenDefaultEndpoint.
    
Arguments:
    
    Urb             -   URB to handle

Return Value:

    USBD_STATUS_SUCCESS or USBD_STATUS_PENDING

--*/
{
    //
    //  Mark the default endpoint close, but cache the handle
    //  in a local variable.
    //
    PVOID endpoint = m_DefaultEndpoint;
    m_DefaultEndpoint = NULL;
    //
    //  Handle UDN_TYPE_INTERFACE.
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        IUsbDevice *sibling;
        //
        //  Now see if any of the siblings still have the endpoint open.
        //  If even one has it open, we can complete the URB
        //  and exit.
        //
        sibling = GetParent()->GetFirstChild();
        while(sibling)
        {
            //
            //  We don't check for NULL.  Why?  Look at the note in IUsbDevice::AddComplete.
            //
            if(sibling->m_DefaultEndpoint == endpoint)
            {
                Urb->Header.Status = USBD_STATUS_SUCCESS;
                USBD_CompleteRequest(Urb);
                return USBD_STATUS_SUCCESS;
            }
            //
            //  Try next sibling
            //
            sibling = sibling->GetSibling();
        }
        //
        // If we made it through the loop then close
        // endpoint for real
        //
        GetParent()->m_DefaultEndpoint = NULL;
    }

    //
    //  Munge URB and pass on to HCD
    //
    Urb->CloseEndpoint.Hdr.Function = URB_FUNCTION_CLOSE_ENDPOINT;
    Urb->CloseEndpoint.EndpointHandle = endpoint;
    Urb->OpenEndpoint.DataToggleBits = NULL;
    return HCD_SubmitRequest(USBD_GetHCDExtension(m_HostController), Urb);
}

IUsbDevice *IUsbDevice::FindChild(UCHAR PortNumber) const
/*++
    Returns a pointer to a child device given its port number.  NULL if not found.
--*/
{
    
    //  This should only be called for hubs, root_hubs and composite devices.
    ASSERT( (UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type) || (UDN_TYPE_COMPOSITE_FUNCTION == m_Type));

    IUsbDevice *device = GetFirstChild();
    while( device && (device->m_PortNumber & ~UDN_LOWSPEED_PORT) != (PortNumber & ~UDN_LOWSPEED_PORT))
    {
        device = device->GetSibling();
    }
    return device;
}

void IUsbDevice::InsertChild(IUsbDevice *child)
/*++
    Inserts a device as a child of this device.
    It is important to make it the last child,
    because FindChild finds the first matching
    child.  If there is a remove and a reinsert
    between enumeration stages, there could be
    two matching children, one pending removal.
    So it is imporant to add from the opposite end
    as removal (i.e. finding , since we remove
    what we find).
--*/
{
    //  This should only be called for hubs, root_hubs and composite devices.
    ASSERT( (UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type) || (UDN_TYPE_COMPOSITE_FUNCTION == m_Type));
    ASSERT(child >= g_DeviceTree.m_Devices);
    //
    //  Get the nodeIndex and debug assert that it is valid
    //
    UCHAR nodeIndex = child - g_DeviceTree.m_Devices;
    ASSERT(UDN_INVALID_NODE_INDEX > nodeIndex);

    //
    // We know the childs parent and sibling now, so fill it in.
    //
    child->m_Sibling = UDN_INVALID_NODE_INDEX;
    child->m_Parent = this - g_DeviceTree.m_Devices;
	

    IUsbDevice *existingChild = GetFirstChild();
    
	if(!existingChild)
    //
    //  If there are no children, then it is the first.
    //
    {
        m_FirstChild = nodeIndex;
    } else
    //
    //  Otherwise, we need to insert at the end
    //
    {
        //
        //	Make sure we are not inserting the child twice
        //
        ASSERT(existingChild!=child);
        
        //
        //  walk to the end.
        //
        while(UDN_INVALID_NODE_INDEX != existingChild->m_Sibling)
        {
            existingChild = existingChild->GetSibling();
            //
            //	Make sure we are not inserting the child twice
            //
            ASSERT(existingChild!=child);
        }
        //
        //  attach to the end
        //
        existingChild->m_Sibling = nodeIndex;
    }
}


BOOLEAN IUsbDevice::RemoveChild(IUsbDevice *child)
/*++
    Removes a device from the list of children.
    Returns TRUE if the are still more children.
--*/
{
    //  This should only be called for hubs, root_hubs and composite devices.
    ASSERT( (UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type) || (UDN_TYPE_COMPOSITE_FUNCTION == m_Type));

    IUsbDevice *prevChild = GetFirstChild();
    BOOLEAN moreChildren = TRUE;
    if(prevChild == child)
    {
        m_FirstChild = child->m_Sibling;
        if(m_FirstChild == UDN_INVALID_NODE_INDEX) moreChildren = FALSE;
    } else
    {
        
        while(prevChild && (prevChild->GetSibling() != child))
        {                                   
            prevChild = prevChild->GetSibling();
        }
        ASSERT(prevChild);
        if(prevChild)
        {
            prevChild->m_Sibling = child->m_Sibling;
        }
    }
    child->m_Sibling = UDN_INVALID_NODE_INDEX;
    child->m_Parent = UDN_INVALID_NODE_INDEX;
    return moreChildren;
}
 
PNP_CLASS_ID IUsbDevice::GetClassId() const
{
	PNP_CLASS_ID classId;
	if(0xFF != m_ClassSpecificType)
	{
		classId.AsLong = m_ClassDriver->ClassId.AsLong;
		classId.USB.bClassSpecificType = m_ClassSpecificType;
	} else {
		classId.AsLong = -1;
	}
	return classId;
}


BOOLEAN IUsbDevice::IsEnumTime() const
/*++
    Test to see if this device is currently being enumerated.
    This routine gets called in DEBUG mode for lots of calls
    to IUsbDevice from the ClassDriver.  It is also used
    in the retail build to decide whether or not to use a pre-allocated
    an endpoint on open.
--*/
{
    //
    //  If you are not at DISPATCH_LEVEL you could
    //  leave EnumTime whenever, so effectively it
    //  is not EnumTime.
    //
    if(DISPATCH_LEVEL != KeGetCurrentIrql()) return FALSE;
    //
    // If nobody is being enumerated than we are not
    // being enumerated.
    //
    if(!g_DeviceTree.m_InProgress) return FALSE;
    
    //
    //  If we are UDN_TYPE_INTERFACE, then really it
    //  is our parent being enumerated.  We are than at enum
    //  time if:
    //  a) Our default endpoint non-NULL and different from
    //     our parents.
    //  b) Our previous sibling default endpoint is NULL or the same
    //      same as our parents.
    //  This condition implies that our parent is g_DeviceTree.m_CurrentEnum
    //  we will double check this in debug builds only.
    //
    //  We will decline to check b), because it is tough, and it would
    //  imply that a class driver got a handle to us prior to receiving
    //  AddDevice.  This driver doesn't call IsEnumTime for its own
    //  purposes anyway.
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        ASSERT(GetParent()); //Serious error for UDN_TYPE_INTERFACE not to have a parent.
        if( 
            (NULL == m_DefaultEndpoint) ||
            (GetParent()->m_DefaultEndpoint == m_DefaultEndpoint)
        ) return FALSE;
        ASSERT(g_DeviceTree.m_CurrentEnum == GetParent());
        return TRUE;
    }

    //
    //  So we are not of type UDN_TYPE_INTERFACE, which means
    //  that we are at EnumTime iff we are g_DeviceTree.m_CurrentEnum.
    //
    if(g_DeviceTree.m_CurrentEnum != this) return FALSE;
    return TRUE;
}


#ifndef SILVER  //SetExternalPort for BLACK builds

#define MAX_TREE_INDEX 5
void IUsbDevice::SetExternalPort()
/*++
  This routine calculates the external port number which includes
  the slot.

  0-3 is for a direct connect device or a top slot, and 16-19 if for a device
  that connects through the bottom slot.
--*/
{
    //
    //  Build Parent Device Array
    //
    IUsbDevice *pParentArrayBuffer[MAX_TREE_INDEX+1];
    IUsbDevice **pParentArray;
    UINT parentIndex = MAX_TREE_INDEX;
    UINT deviceIndex;
    pParentArrayBuffer[MAX_TREE_INDEX] = this;
    do
    {
        parentIndex--;
        ASSERT(parentIndex >= 0);
        pParentArrayBuffer[parentIndex] = pParentArrayBuffer[parentIndex+1]->GetParent();
    } while(UDN_TYPE_ROOT_HUB != pParentArrayBuffer[parentIndex]->m_Type);
    
    //
    //  Adjust pParentArray so that index 0 is the root hub
    //  and deviceIndex is the device itself.
    //
    pParentArray = pParentArrayBuffer + parentIndex;
    deviceIndex = MAX_TREE_INDEX - parentIndex;

    // This should not be possible
    ASSERT(0!=deviceIndex);

    //
    //  Call the appropriate configuration routine
    //
    if(XBOX_HW_FLAG_INTERNAL_USB_HUB & XboxHardwareInfo->Flags)
    {
        SetExternalPortWithHub(pParentArray, deviceIndex);
    } else
    {
        SetExternalPortWithoutHub(pParentArray, deviceIndex);
    }
}    


void IUsbDevice::SetExternalPortWithHub(IUsbDevice **pParentArray, UINT DeviceIndex)
{
    
    //
    //  We expect the device at index 1 to be a hub.
    //  Otherwise, someone is screwing with the configuration.
    //
    if(UDN_TYPE_HUB!=pParentArray[1]->m_Type)
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }

    //
    //  That first hub must be plugged into port 1 of the 
    //  root hub.
    //
    if(1!=pParentArray[1]->GetHubPort())
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }

    //If this is the internal hub we are done,
    if(1==DeviceIndex)
    {
        m_ExternalPort = 0;
        return;
    }

    //
    //  Otherwise, we can call the SetExternalPortWithoutHub
    //  after splicing the internal hub out of the topology.
    //
    pParentArray[1] = pParentArray[0];
    SetExternalPortWithoutHub(pParentArray+1, DeviceIndex-1);
}

void IUsbDevice::SetExternalPortWithoutHub(IUsbDevice **pParentArray, UINT DeviceIndex)
{
    //
    //  In general the port is the hub port that the device at index 1
    //  is plugged into. 
    //
    m_ExternalPort = (pParentArray[1]->GetHubPort()-1);
    if(m_ExternalPort >= XGetPortCount())
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }
    // A board layout problem on the motherboard (and on the daughter
    // hub to work around a USB drive level issue on the MCP rev B01)
    // requires us to swap ports 0 and 1 with ports 2 and 3. We can
    // do this by XOR with 2.  This assumes that there is no port 5.
    //
    m_ExternalPort ^= 2;

    //
    //  If the device is a hub, its parent must be the root hub.
    //
    if(UDN_TYPE_HUB==pParentArray[DeviceIndex]->m_Type)
    {
        if(1 == DeviceIndex) return;
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }

    //
    //  If the device index is not plugged directly into the box
    //  (equivalent to the DeviceIndex being greater than 1)
    //  then the slot is determined by the HubPort that the device at
    //  DeviceIndex 2 is inserted into.  Port 1 is direct connect, port 2
    //  is top slot and port 3 is bottom slot.  Only port 3 changes m_ExternalPort
    //  (We need to reject anything plugged into another slot.)
    //
    if(DeviceIndex>1)
    {
        ULONG SlotPort = (pParentArray[2]->GetHubPort())-1;
        //
        //  Adjust m_ExternalPort with the slot information
        //
        if(SlotPort > 3)
        {
            m_ExternalPort = XDEVICE_ILLEGAL_PORT;    
        } else if(SlotPort == 2)
        {
            m_ExternalPort += 16;
        }
    }
    return;
}

#else  //SetExternalPort for SILVER builds
void IUsbDevice::SetExternalPort() 
/*++
   This routine calculates the external port number.  The external
   port number is 0-3 for devices that plug directly in to XBOX.
   This corresponds to the labels 1 through 4 on the outside of
   the box.  If the device is in the bottom slot of a game controller
   16 is added to the external port number.

   This code supports three configuration based on #define's
   
   USB_HOST_CONTROLLER_CONFIGURATION is to one of four
   values.

   USB_SINGLE_HOST_CONTROLLER
        Ports one to four on thre root host, become external ports 0-3.
        If externa; port four check for external hub, thus the external
        port could be greater.

   USB_DUAL_HOST_CONTROLLER_XDK
        The first Host Controllers' ports one and two, become external ports
        0 and 1.  The second Host Controllers' ports one and two
        become external ports 2 and 3.

        If external port three check for external hub, thus
        external port could be greater.

--*/
{
    //
    //  Build list of device.
    //
    IUsbDevice *pParentArrayBuffer[5];
    IUsbDevice **pParentArray;
    int parentIndex = 4;
    pParentArrayBuffer[4] = this;
    do
    {
        parentIndex--;
        ASSERT(parentIndex >= 0);
        pParentArrayBuffer[parentIndex] = pParentArrayBuffer[parentIndex+1]->GetParent();
    } while(UDN_TYPE_ROOT_HUB != pParentArrayBuffer[parentIndex]->m_Type);
    
    //
    //  Adjust pParentArray so that index 0, is the Root Hub
    //

    //pParentArray = &pParentArrayBuffer[parentIndex];
    pParentArray = pParentArrayBuffer + parentIndex;
    int maxIndex = 4 - parentIndex;
    
    //
    //  If the index is less than two, this is
    //  a hub, or some strange configuration
    //

    if(maxIndex < 1) return;
    
    //
    //  USB_SINGLE_HOST_CONTROLLER
    //

    #if (USB_HOST_CONTROLLER_CONFIGURATION==USB_SINGLE_HOST_CONTROLLER)
    ASSERT(1==pParentArray[0]->m_HostController->ControllerNumber); //It should always be host controller 1
    m_ExternalPort = pParentArray[1]->GetHubPort()-1;
    #endif //(USB_HOST_CONTROLLER_CONFIGURATION = USB_SINGLE_HOST_CONTROLLER)

    //
    //  USB_DUAL_HOST_CONTROLLER_XDK
    //

    #if (USB_HOST_CONTROLLER_CONFIGURATION==USB_DUAL_HOST_CONTROLLER_XDK)
    m_ExternalPort = pParentArray[1]->GetHubPort()-1;
    if(2==pParentArray[0]->m_HostController->ControllerNumber)
    {
        m_ExternalPort += 2;
    }
    #endif //(USBD_HOST_CONTROLLER_CONFIGURATION = USB_DUAL_HOST_CONTROLLER_XDK)

    int functionIndex = 2;

    //
    //  At this point the external port should be 0-3, (or 4 if it is a dual
    //  host controller for DVT) if not it is in an illegal port.
    //
    if(m_ExternalPort > 3)
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }
    
    //
    //  Deal with the possiblity of an external hub
    //
    if(
        (UDN_TYPE_HUB == pParentArray[1]->m_Type) &&
        (UDN_HUB_TYPE_EXTERNAL == pParentArray[1]->m_ClassSpecificType)
    )
    {
        if(3 == m_ExternalPort)
        {
            //
            //  If there are no more nodes, we are being
            //  called on the external hub, we are done.
            //

            if(maxIndex < 2)  return;
            m_ExternalPort = pParentArray[2]->GetHubPort()+2;
            functionIndex = 3;
        } else
        {
            m_ExternalPort = XDEVICE_ILLEGAL_PORT;
            return;
        }
    }
    
    //
    //  Exclude functions directly
    //  connected to the box.
    //
    #ifndef USB_ENABLE_DIRECT_CONNECT
    if(UDN_TYPE_ROOT_HUB == pParentArray[functionIndex-1]->m_Type)
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }
    if(UDN_TYPE_COMPOSITE_FUNCTION == pParentArray[functionIndex-1]->m_Type)
    {
        if(UDN_TYPE_ROOT_HUB == pParentArray[functionIndex-2]->m_Type)
        {
            m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        }
        return;
    }
    #endif

    //
    //  We may be evaluating the parent of 
    //  a function, or a device plugged
    //  directly into the box.
    //

    if(functionIndex > maxIndex)
    {
        return;
    }
    
    //
    //  Check for bottom slot (or illegal slot)
    //
    BOOLEAN fBottomSlot = FALSE;
    //
    //  If the parent is a hub, then the slot is our port number
    //  1 or 2 = top, 3 = bottom, > 3 is illegal.
    if(UDN_TYPE_HUB == pParentArray[functionIndex-1]->m_Type)
    {
        if(pParentArray[functionIndex]->GetHubPort() == 3)
        {
            fBottomSlot = TRUE;
        } else if(pParentArray[functionIndex]->GetHubPort() > 3)
        {
           m_ExternalPort = XDEVICE_ILLEGAL_PORT;
           return;
        }
    }

    //
    //  If the parent is a composite, e.g. Hawk, then the slot
    //  is based on our parent port.
    //
    else if(UDN_TYPE_COMPOSITE_FUNCTION == pParentArray[functionIndex-1]->m_Type)
    {
        if(UDN_TYPE_HUB == pParentArray[functionIndex-2]->m_Type)
        {
            if(pParentArray[functionIndex-1]->GetHubPort() == 3)
            {
                fBottomSlot = TRUE;
            } else if(pParentArray[functionIndex-1]->GetHubPort() > 3)
            {
                m_ExternalPort = XDEVICE_ILLEGAL_PORT;
                return;
            }
        }
    }

    if(fBottomSlot)
    {
        m_ExternalPort += 16;
    }
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbhub\hub.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    hub.cpp

Abstract:
	
	Basic entry point implementation of the USB HUB driver.
    
	
Environment:

	Designed for XBOX.

Notes:

Revision History:

    03-02-00 created by Mitchell Dernis (mitchd)

--*/


//
//	Pull in OS headers
//
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <usb.h>
#include <xdbg.h>

//
//	Setup the debug information for this file (see ..\inc\debug.h)
//
//#define PROMOTE_TRACE_TO_WARN //define this to get more spew in this module only

#define	MODULE_POOL_TAG			 'HBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBHUB");

//
//	Pull in public usb headers
//
#include <usb.h>
//
//	Pull in hub headers
//
#include "hub.h"


//------------------------------------------------------------------------------
//  Declare USBHUB types and class.
//------------------------------------------------------------------------------
USB_DEVICE_TYPE_TABLE_BEGIN(USBHUB_)
USB_DEVICE_TYPE_TABLE_ENTRY(NULL)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(USBHUB_, USB_DEVICE_CLASS_HUB, 0, 0)
#pragma data_seg(".XPP$ClassHub")
USB_CLASS_DECLARATION_POINTER(USBHUB_)
#pragma data_seg(".XPP$Data")

USBHUB_INFO						 GLOBAL_HubInfo;
USBHUB_ENUM_BLOCK				 GLOBAL_HubEnum;

#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID USBHUB_Init(IUsbInit *)
{
	
	//
	//	Initialize global structures
	//
	GLOBAL_HubInfo.NodeCount = USBHUB_MAXIMUM_HUB_COUNT;
	GLOBAL_HubInfo.NodesInUse = 0;
	KeInitializeTimer(&GLOBAL_HubEnum.WatchdogTimer);
}
#pragma code_seg(".XPPCODE")

VOID
USBHUB_WatchdogTimerProc(PKDPC Dpc, PVOID pvHubDevice, PVOID, PVOID)
{
    USB_DBG_WARN_PRINT(("Watchdog timer proc hit."));
    IUsbDevice *hubDevice = (IUsbDevice *)pvHubDevice;
    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)hubDevice->GetExtension();
    switch(GLOBAL_HubEnum.WatchdogReason)
    {
        case USBHUB_WATCHDOG_REASON_ENUM:
            hubDevice->CancelRequest(&hubNode->Urb);
            break;
        case USBHUB_WATCHDOG_REASON_RESET_PORT:
            hubDevice->ResetComplete(USBD_STATUS_REQUEST_FAILED, GLOBAL_HubEnum.ResetContext);
            break;
        case USBHUB_WATCHDOG_REASON_DISABLE_PORT:
            hubDevice->DisableComplete(USBD_STATUS_REQUEST_FAILED, GLOBAL_HubEnum.ResetContext);
            break;
    }
    
}
__inline void USBHUB_SetEnumWatchdog(DWORD dwReason)
{
    LARGE_INTEGER wait;
    if(USBHUB_WATCHDOG_REASON_ENUM == dwReason)
    {
        wait.QuadPart = -5000*10000; //5 seconds for most commands
    } else
    {
        wait.QuadPart = -500*10000; //500 ms for disabling or reseting a port 
    }
    GLOBAL_HubEnum.WatchdogReason = dwReason;
    KeSetTimer(&GLOBAL_HubEnum.WatchdogTimer, wait, &GLOBAL_HubEnum.WatchdogTimerDpc);
}
__inline void USBHUB_ClearEnumWatchdog()
{
    KeCancelTimer(&GLOBAL_HubEnum.WatchdogTimer);
}

EXTERNUSB VOID
USBHUB_AddDevice(
	IN IUsbDevice *HubDevice
	)
{
	ULONG						nodeIndex = 0;
	PUSBHUB_DEVICE_NODE			hubNode;
	if(GLOBAL_HubInfo.NodesInUse < GLOBAL_HubInfo.NodeCount)
	{
		//
		//	Find a free node, and claim it.
		//
		while(GLOBAL_HubInfo.Nodes[nodeIndex].InUse) nodeIndex++;
		GLOBAL_HubInfo.NodesInUse++;
		hubNode = &GLOBAL_HubInfo.Nodes[nodeIndex];
		//
		//	Attach the node to our hubDevice
		//
		HubDevice->SetExtension((PVOID)hubNode);

		//
		//	Initialize what we can about the device.
		//
		hubNode->InUse = TRUE;
        hubNode->NotResponding = FALSE;
		hubNode->RemovePending = FALSE;
		hubNode->PortConnectedBitmap = 0;
        hubNode->ErrorCount = 0;

		//
		//	Open the default endpoint, this cannot fail, because we
		//	are at enum time.
		//
		USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&hubNode->Urb);
		HubDevice->SubmitRequest(&hubNode->Urb);
				
		//
		//	Now get the configuration descriptor. We are guaranteed to get 
		//	only one enumeration request at a time, so we can just assume
		//	that all of our shared enumeration resources are available.
		//
		USB_BUILD_GET_DESCRIPTOR(
				(PURB_CONTROL_TRANSFER)&hubNode->Urb,
				USB_CONFIGURATION_DESCRIPTOR_TYPE,
				0,
				0,
				GLOBAL_HubEnum.EnumBuffer,
				sizeof(GLOBAL_HubEnum.EnumBuffer),
				(PURB_COMPLETE_PROC)USBHUB_EnumHubStage1,
				(PVOID)HubDevice
				);
        KeInitializeDpc(&GLOBAL_HubEnum.WatchdogTimerDpc, USBHUB_WatchdogTimerProc, HubDevice);

        USBHUB_SetEnumWatchdog(USBHUB_WATCHDOG_REASON_ENUM);
  		HubDevice->SubmitRequest(&hubNode->Urb);
	}
	else
	{
        ASSERT(FALSE);
		//
		//	Out of nodes so we cannot support the device
		//  (allow a retry though)
        //
		HubDevice->AddComplete(USBD_STATUS_NO_MEMORY);
	}
}

VOID
USBHUB_EnumHubStage1(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	USBD_STATUS status;
	PUSBHUB_DEVICE_NODE	 hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USBHUB_ClearEnumWatchdog();
	//
	//	It is possible that get configuration descriptor failed.
	//
	if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_RemoveHubStage2(Urb, HubDevice);
        return;
	}
	//
	//	We need the following descriptors from the configuration:
	//		Endpoint Descriptor for Status Change Endpoint:
	//
	//
	PUSB_COMMON_DESCRIPTOR		commonDescriptor = (PUSB_COMMON_DESCRIPTOR)(GLOBAL_HubEnum.EnumBuffer);
	PUSB_ENDPOINT_DESCRIPTOR	endpointDescriptor;
	ULONG						enumBufferOffset = 0;
	do
	{
		enumBufferOffset += commonDescriptor->bLength;
		ASSERT(enumBufferOffset < sizeof(GLOBAL_HubEnum.EnumBuffer));
		commonDescriptor = (PUSB_COMMON_DESCRIPTOR)(GLOBAL_HubEnum.EnumBuffer + enumBufferOffset);
	}while(commonDescriptor->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE);
	endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)commonDescriptor;
	
	if(endpointDescriptor->wMaxPacketSize <= 4)
	{
		hubNode->InterruptEndpointMaxPacket = (UCHAR) endpointDescriptor->wMaxPacketSize;
	} else
	{
		hubNode->InterruptEndpointMaxPacket = 4;
	}
    
    hubNode->InterruptEndpointAddress = endpointDescriptor->bEndpointAddress;
	
    //
	//	Now try to open the interrupt endpoint
	//	(this could fail due to limited bandwidth)
	//
	USB_BUILD_OPEN_ENDPOINT(
		(PURB_OPEN_ENDPOINT)Urb,
		endpointDescriptor->bEndpointAddress,
		endpointDescriptor->bmAttributes&USB_ENDPOINT_TYPE_MASK,
		hubNode->InterruptEndpointMaxPacket,
		//endpointDescriptor->bInterval
		(UCHAR)16
		);
	status = HubDevice->SubmitRequest(Urb);
	//
	//	If the open failed abort the enumeration, we cannot support the hub.
	//
	if(USBD_ERROR(status))
	{
		USBHUB_RemoveHubStage2(Urb, HubDevice);
	}
	else
	{
		//
		//	Save the interrupt handle
		//
		hubNode->InterruptEndpointHandle = Urb->OpenEndpoint.EndpointHandle;
        ASSERT(hubNode->InterruptEndpointHandle);
		//
		//	Configure the device.
		//
		USB_BUILD_SET_CONFIGURATION(
				(PURB_CONTROL_TRANSFER)Urb,
				1,
				(PURB_COMPLETE_PROC)USBHUB_EnumHubStage2,
				(PVOID)HubDevice
				);

        USBHUB_SetEnumWatchdog(USBHUB_WATCHDOG_REASON_ENUM);
		HubDevice->SubmitRequest(Urb);
	}
	return;
}

VOID
USBHUB_EnumHubStage2(
	PURB    Urb,
	IUsbDevice	*HubDevice
	)
{
	USBHUB_ClearEnumWatchdog();
    if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_RemoveHubStage1(HubDevice);
        return;
	}
	
	//
	//	Get the Hub descriptor
	//
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)Urb,
		NULL,
		GLOBAL_HubEnum.EnumBuffer,				//The middle was initialized in stage 1
		sizeof(USB_HUB_DESCRIPTOR),
		USB_TRANSFER_DIRECTION_IN,
		(PURB_COMPLETE_PROC)USBHUB_EnumHubComplete,
		(PVOID)HubDevice,
		TRUE,
		USB_DEVICE_TO_HOST | USB_CLASS_COMMAND,
		USB_REQUEST_GET_DESCRIPTOR,
		USB_HUB_DESCRIPTOR_TYPE << 8,
		0,
		sizeof(USB_HUB_DESCRIPTOR)
		);

    USBHUB_SetEnumWatchdog(USBHUB_WATCHDOG_REASON_ENUM);

	HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_EnumHubComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	 hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	PUSB_HUB_DESCRIPTOR  hubDescriptor;

    USBHUB_ClearEnumWatchdog();
	if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_RemoveHubStage1(HubDevice);
        return;
	}
	//
	//	Strip the info we need out of the hub descriptor.
	//
	hubDescriptor = (PUSB_HUB_DESCRIPTOR)GLOBAL_HubEnum.EnumBuffer;
	hubNode->PortCount = hubDescriptor->bNumberOfPorts;
	//
	//	Assert that the hub does not have too many ports.
	//
	ASSERT(7 >= hubNode->PortCount);
	//
	//	We support only 7 ports on a hub!
	//
	if(hubNode->PortCount > 7) hubNode->PortCount = 7;
	USB_DBG_TRACE_PRINT(("Detected Hub with %d ports", hubNode->PortCount));
	//
	//	AddComplete.  What does this mean?
	//	1) That we are done with EnumArgs passed into us at USBHUB_AddHub.
	//	2) That we are done with our global enumeration resources, and thus
	//	   are ready to accept enumeration requests for additional hubs.
	//	3) We are ready to accept remove requests for this device.
	//
	HubDevice->AddComplete(USBD_STATUS_SUCCESS);

	//
	//	However, we still need to power on the ports
	//	and detect any devices that may be attached.
	//	Our normal port status change code will handle this.
	//	Basically we just indicate that the status of all the
	//	ports have changed and go out and enumerate.
	//
	hubNode->PortProcessIndex = 1;
	USB_DBG_TRACE_PRINT(("Powering port 1"));
	USB_BUILD_CONTROL_TRANSFER(
				(PURB_CONTROL_TRANSFER)&hubNode->Urb,
				NULL,
				NULL,
				0,
				0,
				(PURB_COMPLETE_PROC)USBHUB_PoweringPorts,
				(PVOID)HubDevice,
				FALSE,
				USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
				USB_REQUEST_SET_FEATURE,
				USBHUB_FEATURE_PORT_POWER,
				hubNode->PortProcessIndex,
				0
				);
	HubDevice->SubmitRequest(&hubNode->Urb);
}	

VOID
USBHUB_PoweringPorts(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	 hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	
	if(USBD_ERROR(Urb->Header.Status))
	{
		USB_DBG_WARN_PRINT(("Error Powering Port."));
		//
		//	Move on to next port.
		//
	}
	
	if(hubNode->PortProcessIndex == hubNode->PortCount)
	{
		USB_DBG_TRACE_PRINT(("Done powering ports, submit change notification request."));
		//
		//	All ports are powered, submit a change notification
		//	Urb, that should kick everything off.
		//
		hubNode->PortProcessIndex = 0;
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
				(PURB_BULK_OR_INTERRUPT_TRANSFER)&hubNode->Urb,
				hubNode->InterruptEndpointHandle,
				hubNode->RequestBuffer,
				hubNode->InterruptEndpointMaxPacket,
				USB_TRANSFER_DIRECTION_IN,
				(PURB_COMPLETE_PROC)USBHUB_ChangeNotifyComplete,
				(PVOID)HubDevice,
				TRUE
				);
	} else
	//
	//	Update the port number and re-submit the URB to power the next port
	//
	{
		USB_DBG_TRACE_PRINT(("Powering port %d", hubNode->PortProcessIndex+1));
		Urb->ControlTransfer.SetupPacket.wIndex = ++hubNode->PortProcessIndex;
	}
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_ChangeNotifyComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
/*++
Routine Description:
	This is the completion routine for transfers over the
	interrupt endpoint.  USB Hubs uses the interrupt endpoint
	to notify the driver that either the status of the hub or
	one of its hosts has changed.  The number of valid bits
	depends on the number of ports.  See Figure 11-14 in USB
	Specification Revision 1.1 for details.

	Here we copy the valid bits (we only support up to 7 ports)
	into PortStatusChangeBitmap before starting the kicking
	off the processing of changes.
Parameters:
	Urb			- URB that was just completed.
	HubNode		- HubNode of hub we are handling.
--*/
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
	//
	//	If the URB is successful we need to start
	//	processing whatever happened.
	//
	if(USBD_SUCCESS(Urb->Header.Status))
	{
		hubNode->ErrorCount = 0;
        UCHAR Mask = (1 << (hubNode->PortCount+1))-1;
		hubNode->PortStatusChangeBitmap = hubNode->RequestBuffer[0]&Mask;
		USBHUB_PortStatusChange1(HubDevice);
		return;
    }

	//
	//	Increment the error count.
	//  With three failures in a row
    //  we report the device as not resonding.
    //
    if(3 < ++hubNode->ErrorCount)
    {
        hubNode->NotResponding = TRUE;
        HubDevice->DeviceNotResponding();
        return;
    }

    //
    //  Clear the endpoint halt
    // 
    USB_BUILD_CLEAR_FEATURE(
        (PURB_CONTROL_TRANSFER)Urb,
        USB_COMMAND_TO_ENDPOINT,
        USB_FEATURE_ENDPOINT_STALL,
        hubNode->InterruptEndpointAddress,
        (PURB_COMPLETE_PROC)USBHUB_ClearInterruptStallComplete,
        HubDevice
        );
    HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_ClearInterruptStallComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
/*++
    After a notification fails on the interrupt endpoint (via a stall)
    the stall must be cleared before it can be retried.  The first
    step sending a (CLEAR_FEATURE(STALL)) is an asynchronous wire
    transfer this is the completion routine.

    We then instruct the USB core stack to clear the halt, and
    resubmitt the interrupt request.
--*/
{
    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
 
    //
    //  If we cannot clear the halt, then just
    //  report the device as not responding.
    //
    if(USBD_ERROR(Urb->Header.Status))
    {
        hubNode->NotResponding = TRUE;
        HubDevice->DeviceNotResponding();
        return;
    }
	
    //
    //  Build and submit URB to reset the endpoint state
    //  (This synchronous and cannot fail with valid parameters).
    //
    USB_BUILD_SET_ENDPOINT_STATE( 
        (PURB_GET_SET_ENDPOINT_STATE)Urb,
        hubNode->InterruptEndpointHandle,
        USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
        );
    HubDevice->SubmitRequest(Urb);
    
    //
    //  Resubmit the interrupt request
    //

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
		&Urb->BulkOrInterruptTransfer,
		hubNode->InterruptEndpointHandle,
		hubNode->RequestBuffer,
		hubNode->InterruptEndpointMaxPacket,
		USB_TRANSFER_DIRECTION_IN,
		(PURB_COMPLETE_PROC)USBHUB_ChangeNotifyComplete,
		(PVOID)HubDevice,
		TRUE
		);
    HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_PortStatusChange1(
		IUsbDevice	*HubDevice
	)
/*++

Routine Description:
	This is the first in a series of routines that process
	status changes to hub or its ports.  The processing is a 
	loop (we can only handle one port at a time).  In this stage,
	we isolate one of the changed elements (either the hub itself,
	or a port on the hub) and start the processing.  After
	we are done processing that change we come back here to get
	status for the next one.
Arguments:
	HubNode - The node for the hub we need to process.

--*/
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	UCHAR mask = 1;
	//
	//	Find the the first bit set in 
	//	PortStatusChangeBitmap, note bit 0 means the hub status
	//	has changed.  This is why there are portcount + 1, valid bits.
	//
	USB_DBG_TRACE_PRINT(("Looking for ports with changed status"));
	for(
		hubNode->PortProcessIndex=0;
		hubNode->PortProcessIndex <= hubNode->PortCount;
		hubNode->PortProcessIndex++, mask <<= 1
	)
	{
		if(hubNode->PortStatusChangeBitmap & mask)
		{
			USB_DBG_TRACE_PRINT(("Port %d has changed status", hubNode->PortProcessIndex));
			//
			//	Clear the bit and break.
			//
			hubNode->PortStatusChangeBitmap &= ~mask;
			break;
		}
	}

	//*
	//*	Three cases follow:
	//*		1) PortProcessIndex is greater than port count: all changes
	//*			are processed, so we build the URB as a request for
	//*			change notification on the interrupt-in endpoint.
	//*
	//*		2) PortProcessIndex is 0:  the status of the hub itself
	//*			has changed.  We build a request to get the
	//*			status of the hub.
	//*
	//*		3) PortProcessIndex is between 1 and the port count, inclusive. (Basically,
	//*			not case 1 or 2.)  We build a request to get the status of the
	//*			port.
	//*
	//*		In all three cases we have build an URB.  We then submit it, and return.

	//
	//	1) No more changes
	//
	if(hubNode->PortProcessIndex > hubNode->PortCount)
	{
		USB_DBG_TRACE_PRINT(("All port changes are processed, submitting URB on change notification endpoint"));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
				(PURB_BULK_OR_INTERRUPT_TRANSFER)&hubNode->Urb,
				hubNode->InterruptEndpointHandle,
				hubNode->RequestBuffer,
				hubNode->InterruptEndpointMaxPacket,
				USB_TRANSFER_DIRECTION_IN,
				(PURB_COMPLETE_PROC)USBHUB_ChangeNotifyComplete,
				(PVOID)HubDevice,
				TRUE
				);
	
	}
	//
	//	2) Hub status changed
	//
	else if(0==hubNode->PortProcessIndex)
	{
		USB_DBG_TRACE_PRINT(("Hub status has changed.  Querying for hub status."));
		USB_BUILD_CONTROL_TRANSFER(
			(PURB_CONTROL_TRANSFER)&hubNode->Urb,
			NULL,
			hubNode->RequestBuffer,
			4,
			USB_TRANSFER_DIRECTION_IN,
			(PURB_COMPLETE_PROC)USBHUB_HubStatusChange,
			(PVOID)HubDevice,
			FALSE,
			USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_DEVICE,
			USB_REQUEST_GET_STATUS,
			0,
			0,
			4
			);	
		
	} 
	//
	//	2) Port status changed
	//
	else
	{
		USB_DBG_TRACE_PRINT(("Port %d status has changed.  Querying for port status.", hubNode->PortProcessIndex));
		USB_BUILD_CONTROL_TRANSFER(
			(PURB_CONTROL_TRANSFER)&hubNode->Urb,
			NULL,
			hubNode->RequestBuffer,
			4,
			USB_TRANSFER_DIRECTION_IN,
			(PURB_COMPLETE_PROC)USBHUB_PortStatusChange2,
			(PVOID)HubDevice,
			FALSE,
			USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
			USB_REQUEST_GET_STATUS,
			0,
			hubNode->PortProcessIndex,
			4
			);
	}
	
	//
	//	Submit the request that we have built
	//
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_PortStatusChange2(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
/*++

Routine Description:
	Stage two of processing a change to a hub.  The Urb to get
	the status of the port should now have completed.
Arguments:
	Urb		- URB that was submitted to get status.
	HubNode - The node for the hub we need to process.
--*/
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
	//
	//	If the URB is successful we need to start
	//	processing whatever happened.
	//
	if(USBD_SUCCESS(Urb->Header.Status))
	{
        hubNode->ErrorCount = 0;
		//
		//	One or more flags are set
		//
		USBHUB_PortProcessChange(HubDevice);
	}else
	{
		//
		//	Deal with the error case.
		//
        if(3 < ++hubNode->ErrorCount)
        {
            hubNode->NotResponding = TRUE;
            HubDevice->DeviceNotResponding();
        } else
        {
            //
            //  Resubmit the request.
            //
            Urb->ControlTransfer.TransferBufferLength = 4;
            HubDevice->SubmitRequest(Urb);
        }
	}
}

VOID
USBHUB_HubStatusChange(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USHORT FeatureToClear;
	
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}

    //
    //	Deal with the error case.
	//
    if(USBD_ERROR(Urb->Header.Status))
    {
        if(3 < ++hubNode->ErrorCount)
        {
            hubNode->NotResponding = TRUE;
            HubDevice->DeviceNotResponding();
    
        } else
        {
            //
            //  Resubmit the request.
            //
            Urb->ControlTransfer.TransferBufferLength = 4;
            HubDevice->SubmitRequest(Urb);
        }
        return;
    } 
    
    hubNode->ErrorCount = 0;

	//
	//	The status of the whole hub changed
	//
	if(hubNode->PortStatus.StatusChange&USBHUB_C_HUB_STATUS_LOCAL_POWER)
	{
		FeatureToClear = USBHUB_FEATURE_C_HUB_LOCAL_POWER;
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_HUB_STATUS_LOCAL_POWER;
	} else if(hubNode->PortStatus.StatusChange&USBHUB_C_HUB_STATUS_OVER_CURRENT)
	{
		FeatureToClear = USBHUB_FEATURE_C_HUB_OVER_CURRENT;
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_HUB_STATUS_OVER_CURRENT;
	} else
	{
		USB_DBG_WARN_PRINT(("HubStatusChange called when there was none."));
		USBHUB_PortStatusChange1(HubDevice);
		return;
	}
	//
	//	Build the clear feature request, and send it
	//
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_ClearHubFeatureComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_DEVICE,
		USB_REQUEST_CLEAR_FEATURE,
		FeatureToClear,
		0,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_ClearHubFeatureComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
    
    //
    //	Deal with the error case.
	//
    if(USBD_ERROR(Urb->Header.Status))
    {
        if(3 < ++hubNode->ErrorCount)
        {
            hubNode->NotResponding = TRUE;
            HubDevice->DeviceNotResponding();
    
        } else
        {
            //
            //  Resubmit the request.
            //
            Urb->ControlTransfer.TransferBufferLength = 4;
            HubDevice->SubmitRequest(Urb);
        }
        return;
    } 
    hubNode->ErrorCount = 0;

	USBHUB_PortStatusChange1(HubDevice);
}

VOID
USBHUB_PortProcessChange(
	IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USHORT FeatureToClear;
	//
	//	Check for a reset port that completed.
	//
	if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_RESET)
	{
		USB_DBG_TRACE_PRINT(("Port reset completed"));
		//
		//	We can signal that the reset is completed
		//	successfully.
		//
        if(
            (USBHUB_WATCHDOG_REASON_RESET_PORT == GLOBAL_HubEnum.WatchdogReason) &&
            (GLOBAL_HubEnum.ResetContext)
        )
        {
            USBD_STATUS status = USBD_STATUS_SUCCESS;
            USBHUB_ClearEnumWatchdog();
            //
            //  Under exterme hot-plug conditions, the
            //  port can be disabled even before we
            //  realise that the reset was complete.
            //  Just say that the reset failed.
            //
            if(
                !(hubNode->PortStatus.Status & USBHUB_PORT_STATUS_ENABLE) ||
                (hubNode->PortStatus.Status & USBHUB_PORT_STATUS_RESET)
            )
            {
				USB_DBG_WARN_PRINT(("Reset Completed, but port not enabled, failing port reset!"));
                status = USBD_STATUS_REQUEST_FAILED;
            } else
            {
                //
                //  Check for low-speed
                //
                if(hubNode->PortStatus.Status&USBHUB_PORT_STATUS_LOW_SPEED)
                {
                    status = USBD_STATUS_LOWSPEED;
                }
            }
            PVOID Context = GLOBAL_HubEnum.ResetContext;
            GLOBAL_HubEnum.ResetContext = NULL;
            HubDevice->ResetComplete(status, Context);
            USB_DBG_TRACE_PRINT(("Returned from notifying port reset"));
        }
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_RESET;
		FeatureToClear = USBHUB_FEATURE_C_PORT_RESET;
	}
	//
	//	Check for a change in the connection status
	//
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_CONNECTION)
	{
		UCHAR PortNumber = hubNode->PortProcessIndex;
		UCHAR PortMask = 1 << (PortNumber-1);
		//
		//	Is it a connect or a disconnect?
		//
		if(hubNode->PortStatus.Status&USBHUB_PORT_STATUS_CONNECTION)
		{
            
            if(hubNode->PortConnectedBitmap&PortMask)
		    {
			   USB_DBG_WARN_PRINT(("Remove and Add in One Notification."));
               HubDevice->DeviceDisconnected(PortNumber);
		    }
            //
            //  We used to just report DeviceConnected here.
            //  Now do this RelatchPortSpeed thing which works
            //  around a bug in the TI chipset.  It keeps the
            //  state machine going, so we just return afterwards.
            //
            USBHUB_RelatchPortSpeed(HubDevice);
            return;
		}else
		{
			if(hubNode->PortConnectedBitmap&PortMask)
			{
				hubNode->PortConnectedBitmap &= ~PortMask;
    			HubDevice->DeviceDisconnected(PortNumber);
			}
		}
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_CONNECTION;
		FeatureToClear = USBHUB_FEATURE_C_PORT_CONNECTION;
	}
	//
	//	Check for a change in the enable status
	//
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_ENABLE)
	{
        //
        //  Nothing to do.
        //
		
        //
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_ENABLE;
		FeatureToClear = USBHUB_FEATURE_C_PORT_ENABLE;
	}
	//
	//	Check for a change in the suspend status
	//
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_SUSPEND)
	{
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_SUSPEND;
		FeatureToClear = USBHUB_FEATURE_C_PORT_SUSPEND;
		USB_DBG_WARN_PRINT(("Unexpected changed in suspend status, Xbox does not suspend devices."));
	}
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_OVER_CURRENT)
	{
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_OVER_CURRENT;
		FeatureToClear = USBHUB_FEATURE_C_PORT_OVER_CURRENT;
		USB_DBG_WARN_PRINT(("Overcurrent detected on port %d", hubNode->PortProcessIndex));
	} else
	{
		USB_DBG_WARN_PRINT(("Port change bitmask not recognized (0x%0.8x)  Ignoring it.", hubNode->PortStatus.StatusChange));
		hubNode->PortStatus.StatusChange = 0;  //NULL this out so we don't get called back.
		USBHUB_ClearPortFeatureComplete(&hubNode->Urb, HubDevice);
		return;
	}

	//
	//	Build the clear feature request
	//
	
	USB_DBG_TRACE_PRINT(("Clearing the feature %d.", FeatureToClear));
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_ClearPortFeatureComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		USB_REQUEST_CLEAR_FEATURE,
		FeatureToClear,
		hubNode->PortProcessIndex,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_ClearPortFeatureComplete(
	PURB	Urb,
	IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
	//
	//	Other changes to process on this port?
	//
	if(hubNode->PortStatus.StatusChange)
	{
		USB_DBG_TRACE_PRINT(("Other status bits on this port changed."));
		USBHUB_PortProcessChange(HubDevice);
	} else
	//
	//	Loop back and process other ports that may have changed.
	//
	{
		USB_DBG_TRACE_PRINT(("Done with this port, check others."));
		USBHUB_PortStatusChange1(HubDevice);
	}
}

EXTERNUSB VOID
USBHUB_RemoveDevice(
	IN IUsbDevice *HubDevice
	)
{
	ULONG				portBit;
	UCHAR				portIndex;
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	
	ASSERT_DISPATCH_LEVEL();
	
	
	ASSERT(hubNode);
		
	//
	//	Mark the removed flag.
	//
	hubNode->RemovePending = TRUE;
	
	//
	//	Report any devices that were connected
	//	to the hub, as disconnected.
	//
	portBit = 1;
	portIndex = 1;
	do
	{
		if(hubNode->PortConnectedBitmap & portBit)
		{
			HubDevice->DeviceDisconnected(portIndex);
			hubNode->PortConnectedBitmap &= ~portBit;
		}
		portBit <<= 1;
	}while( ++portIndex <= hubNode->PortCount );

    //
    //  If the hub was reported as not responding, then
    //  we there is no outstanding I/O.  We can just start the
    //  close procedure.
    //
    if(hubNode->NotResponding)
    {
        USBHUB_RemoveHubStage1(HubDevice);
    }
}


VOID
USBHUB_RemoveHubStage1(
	IN IUsbDevice *HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USB_DBG_ENTRY_PRINT(("Entering USBHUB_RemoveHubStage1"));
	ASSERT_DISPATCH_LEVEL();
	//
	//	Close the interrupt endpoint
	//
	USB_BUILD_CLOSE_ENDPOINT(
					(PURB_CLOSE_ENDPOINT)&hubNode->Urb,
					hubNode->InterruptEndpointHandle,
					(PURB_COMPLETE_PROC)USBHUB_RemoveHubStage2,
					(PVOID)HubDevice
					);
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_RemoveHubStage2(
	PURB	Urb,
	IUsbDevice	*HubDevice
	)
{
	USB_DBG_ENTRY_PRINT(("Entering USBHUB_RemoveHubStage2"));
	ASSERT_DISPATCH_LEVEL();
	//
	//	Close the default endpoint
	//
	USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
							(PURB_CLOSE_ENDPOINT)Urb,
							(PURB_COMPLETE_PROC)USBHUB_RemoveHubComplete,
							(PVOID)HubDevice
							);
	HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_RemoveHubComplete(
	PURB	Urb,
	IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	ASSERT_DISPATCH_LEVEL();
	USB_DBG_ENTRY_PRINT(("Entering USBHUB_RemoveHubComplete"));
	//
	//	Free the hubNode
	//
	HubDevice->SetExtension(NULL);
	hubNode->InUse = FALSE;
	GLOBAL_HubInfo.NodesInUse--;
	//
	//	Notify our bus driver that we are done processing
	//	remove, or that we have aborted an Add.
	//
	if(hubNode->RemovePending)
	{
		HubDevice->RemoveComplete();
	}else
	{
        //
        //  Fail, but allow retry. (Remove ASSERT)
        //
        USB_DBG_WARN_PRINT(("Abort Enumeration, allow retry."));
        HubDevice->AddComplete(USBD_STATUS_NO_MEMORY);
	}
}

	
VOID
USBHUB_DisableResetPort(
	IN IUsbDevice *HubDevice,
	IN UCHAR	PortNumber,
	IN PVOID	Context,
    IN BOOLEAN  Disable
	)
{
	PUSBHUB_DEVICE_NODE hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
    UCHAR bRequest = USB_REQUEST_SET_FEATURE;
    USHORT wValue = USBHUB_FEATURE_PORT_RESET;
    DWORD dwReason = USBHUB_WATCHDOG_REASON_RESET_PORT;
    PURB_COMPLETE_PROC CompleteProc = (PURB_COMPLETE_PROC)USBHUB_ResetComplete;
	
	//
	//	If we didn't find the hub, or if the port number is invalid
	//	call the complete routine with an error, then return.
	//
	
	if( !hubNode || (hubNode->PortCount < PortNumber) )
	{
		USB_DBG_ERROR_PRINT(("Reset failed due to invalid parameter.", hubNode));
		HubDevice->ResetComplete(USBD_STATUS_INVALID_PARAMETER, Context);
		return;
	}

	//
	//	Save of the completion information.
	// (We can only handle one reset or disable at a time)
	GLOBAL_HubEnum.ResetContext = Context;

	//
	//	Build and send an URB for reseting a port.
	//
    if(Disable)
    {
        bRequest = USB_REQUEST_CLEAR_FEATURE;
        wValue = USBHUB_FEATURE_PORT_ENABLE;
        CompleteProc = (PURB_COMPLETE_PROC)USBHUB_DisableComplete;
        dwReason = USBHUB_WATCHDOG_REASON_DISABLE_PORT;
        USB_DBG_TRACE_PRINT(("Disabling Port %d.", PortNumber));
    }   
    else
    {
        USB_DBG_TRACE_PRINT(("Reseting Port %d.", PortNumber));
    }
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&GLOBAL_HubEnum.ResetUrb,
		NULL,
		NULL,
		0,
		0,
		CompleteProc,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		bRequest,
		wValue,
		PortNumber,
		0
		);
    
    //
    //  Set the watchdog so that disable and\or reset don't
    //  hang.  This could happen if the hub is removed.
    //
    USBHUB_SetEnumWatchdog(dwReason);
	HubDevice->SubmitRequest(&GLOBAL_HubEnum.ResetUrb);
}

VOID
USBHUB_ResetComplete(
	IN PURB    Urb,
	IN IUsbDevice *HubDevice
	)
{
	//
	//	If the set feature reset transmission failed, notify
	//	completion procedure.
	//
	if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_ClearEnumWatchdog();
        USB_DBG_TRACE_PRINT(("Port %d Reset failed.", Urb->ControlTransfer.SetupPacket.wIndex));
		HubDevice->ResetComplete(Urb->Header.Status, GLOBAL_HubEnum.ResetContext);
	}
	//
	//	Otherwise we are waiting for the port status to change.
	//	Nothing to do.
}

VOID
USBHUB_DisableComplete(
	IN PURB    Urb,
	IN IUsbDevice *HubDevice
	)
{
    //
    //  Pass the status to disable
    //
    USBHUB_ClearEnumWatchdog();
	HubDevice->DisableComplete(Urb->Header.Status, GLOBAL_HubEnum.ResetContext);
}


//
// HACK: For TI hub, but we apply it to all hubs, since it does no harm.
//
VOID
USBHUB_RelatchPortSpeed(
    IUsbDevice *HubDevice
    )
/*++
 Routine Description:
   Sends a CLEAR_PORT_FEATURE(FEATURE_PORT_ENABLE) to "disable" the hub when a
   new device is connected.  This is a very strange thing to do, but works
   around a bug in the TI hub chip.  In short, the TI hub debounces the full-speed
   \low-speed of a newly inserted device poorly.  It will (often enough) latch in
   low-speed when a full-speed device is connected.  TI claims that sending a disable
   command will cause the speed bit to relatch, and that fixes the problem.

   This is better than the previous work-around at it only introduces an extra
   millisecond delay (as opposed to a 120 ms retry) and should prevent any
   wierd errors.  We don't know what 3rd party devices will do if someone speaks
   low-speed to them.
--*/
{
    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
    USB_BUILD_CONTROL_TRANSFER(
	    (PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_RelatchPortSpeedComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		USB_REQUEST_CLEAR_FEATURE,
		USBHUB_FEATURE_PORT_ENABLE,
		hubNode->PortProcessIndex,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}


VOID
USBHUB_RelatchPortSpeedComplete(
    IN PURB    Urb,
    IUsbDevice *HubDevice
    )
/*++
  Routine Description:
   Completion routine for USBHUB_RelatchPortSpeed.

   Actually, tells USBD about the new device.
--*/
{

    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
    hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_CONNECTION;
    UCHAR ucPortMask = 1 << (hubNode->PortProcessIndex-1);

    HubDevice->DeviceConnected(hubNode->PortProcessIndex, 5);
    hubNode->PortConnectedBitmap |= ucPortMask;
    
    USB_DBG_TRACE_PRINT(("Clearing the feature %d.", FeatureToClear));
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_ClearPortFeatureComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		USB_REQUEST_CLEAR_FEATURE,
		USBHUB_FEATURE_C_PORT_CONNECTION,
		hubNode->PortProcessIndex,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbtest\hubtest.cpp ===
#include <usbtest.h>
extern "C" 
{
#include "ohcd.h"
}
#include "hub.h"


BOOL IsDeviceAttached(IUsbDevice *pHub, UCHAR uHubPort)
{
    UCHAR ucConnectedPorts;
    if(UDN_TYPE_ROOT_HUB==pHub->m_Type)
    {
        POHCD_DEVICE_EXTENSION deviceExtension;
        deviceExtension = (POHCD_DEVICE_EXTENSION)
                           USBD_GetHCDExtension(pHub->m_HostController);
        ucConnectedPorts = deviceExtension->RootHubObject.DeviceDetectedBitmap;
    } else
    {
        ASSERT(UDN_TYPE_HUB==pHub->m_Type);
        PUSBHUB_DEVICE_NODE pUsbHub;
        pUsbHub = (PUSBHUB_DEVICE_NODE)pHub->GetExtension();
        ucConnectedPorts = pUsbHub->PortConnectedBitmap;
    }
    if(ucConnectedPorts&(1<<(uHubPort-1)))
    {
        return TRUE;
    }
    return FALSE;
}


VOID
DisableHubPortSync(
	IN IUsbDevice *pHub,
	IN UCHAR	PortNumber
	)
{
    if(UDN_TYPE_ROOT_HUB==pHub->m_Type)
    {
        POHCD_DEVICE_EXTENSION deviceExtension = (POHCD_DEVICE_EXTENSION)
                                                 USBD_GetHCDExtension(pHub->m_HostController);
        HCD_DisableRootHubPort(
            USBD_GetHCDExtension(pHub->m_HostController),
            PortNumber
            );
    } else
    {
        URB Urb;
        USB_BUILD_CONTROL_TRANSFER(
		    &Urb.ControlTransfer,
		    NULL,
		    NULL,
		    0,
		    0,
		    NULL, //Make the call synchronously
		    NULL,
		    FALSE,
		    USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		    USB_REQUEST_CLEAR_FEATURE,
		    USBHUB_FEATURE_PORT_ENABLE,
		    PortNumber,
		    0
		    );
        pHub->SubmitRequest(&Urb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbtest\usbtest.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    USBTEST.H

Abstract:

    USBTEST.LIB

    Header file for USB Test Utility Methods

    This header declares all the methods exported
    from USBTEST.LIB

Environment:

    kernel mode

Revision History:

    05-04-2001 : mitchd
    

--*/

//*****************************************************************************
// Includes
//*****************************************************************************
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xdbg.h>
#include <usbd.h>


IUsbDevice *GetXidDeviceInterface(PXPP_DEVICE_TYPE XppDeviceType, DWORD dwPort, DWORD dwSlot);
/*
    Walks a XID handle to get the underlying IUsbDevice.
    If the XID device is not connected (stranded handle)
    then it return NULL.
*/

IUsbDevice *GetParentInterface(IUsbDevice *pUsbDevice);
/*
    Gets the parent of a USB device.  Returns parent of
    device.  
*/

UCHAR GetHubPort(IUsbDevice *pUsbDevice);
/*
    Gets the hub port from an IUsbDevice, so that
    IsDeviceAttached can be called.
*/

BOOL IsDeviceAttached(IUsbDevice *pHub, UCHAR uHubPort);
/*
    Returns TRUE if the hub thinks a device is attached to 
    the port.   This is the real port of the hub.
*/

VOID
DisableHubPortSync(
	IN IUsbDevice *pHub,
	IN UCHAR	PortNumber
	);
/*++
  Routine Description:
   Disables a port on hub.  Transparently handles root hub
   versus real hub.  This does not use the hub driver.
   This routine is not safe in an actual hot-plug situation.
   It is good for forcing the reenumeration of devices.

   On like reset device is doesn't suffer from the address
   recycling problem, so you can hit multiple devices
   at once with it.

   Additionally, it tests the ability of class drivers to
   detect and recover from devices that stop responding.
--*/

void ResetDevice(IUsbDevice *Device, UCHAR MaxRetries);
/*++
  Routine Description:
    Resets a device forcing a reenumeration, just like
    DeviceNotResponding, but allows retries to be set.
--*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbtest\usbtest.cpp ===
#include <usbtest.h>


IUsbDevice *
GetParentInterface(
    IUsbDevice *pUsbDevice
    )
/*++
  Routine Description:
    Gets the parent of a USB device.  Returns parent of
    device.  
--*/
{
    IUsbDevice *pParent;
    pParent = &g_DeviceTree.m_Devices[pUsbDevice->m_Parent];
    return pParent;
}

UCHAR 
GetHubPort(
    IUsbDevice *pUsbDevice
    )
/*++
  Routine Description:
    Gets the hub port in the parent.
--*/
{
    return pUsbDevice->m_PortNumber;
}

void ResetDevice(IUsbDevice *Device, UCHAR MaxRetries)
/*++
  Routine Description:
    Resets a device forcing a reenumeration, just like
    DeviceNotResponding, but allows retries to be set.
--*/
{
    IUsbDevice *device;
    
    //
    //  If the device is UDN_TYPE_INTERFACE, then the
    //  real node is the parent
    //
    if(UDN_TYPE_INTERFACE == Device->m_Type)
    {
        device = Device->GetParent();
        ASSERT(device);
    } else
    {
        device = Device;
    }

    //
    //  If it has a parent, it is not pending
    //  remove, so we should reenumerate it.
    //
    IUsbDevice *parent = device->GetParent();
    if(parent)
    {
        
        UCHAR   hubPort = device->GetHubPort();
        
        //
        //  Report the device as disconnected
        //
        parent->DeviceDisconnected(hubPort);

        //
        //  Report the device as connected.
        //
        parent->DeviceConnected(hubPort, MaxRetries);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\usbtest\xidtest.cpp ===
#include <usbtest.h>
#include "xid.h"

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN PXID_TYPE_INFORMATION TypeInformation,
    IN ULONG  Port
    );


IUsbDevice *GetXidDeviceInterface(PXPP_DEVICE_TYPE XppDeviceType, DWORD dwPort, DWORD dwSlot)
{
    UCHAR xidType;
    PXID_TYPE_INFORMATION xidTypeInformation;

    xidTypeInformation = GetTypeInformation(XppDeviceType);

    if(xidTypeInformation)
    {
        xidType = XID_DEVTYPE_GAMECONTROLLER;
        PXID_DEVICE_NODE xidNode = XID_fFindNode(xidTypeInformation, (dwSlot != XDEVICE_BOTTOM_SLOT) ? dwPort : dwPort +16);
        if(xidNode)
        {
            return xidNode->Device;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xdcs\xdcs_old.h ===
#ifndef __XDCS_H__
#define __XDCS_H__
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCS.H

Abstract:

    Header file exposed to the private clients of the XDCS device.

    Client API:

      XGetDvdPlaybackLibraryInfo

Usage:

    Sometime after calling XInitDevices (you do not need to specify the XDCS device
    in the list of required devcies), call XGetDvdLibraryInfoPointer to get a pointer
    to the global XDCS_DVD_LIBRARY_INFORMATION.  This information is updated asynchronously
    by the driver.  Since DWORD read\writes are atomic, the client may poll dwStatus.
    
    When dwStatus is XDCS_STATUS_ACCEPTED the dwVersion and szName fields can be considered valid.

    Rather than polling, the client may wait on hStatusChangeEvent.  This event is set
    whenever the status changes.  This way other threads will run more efficiently while
    waiting for an accepted or rejected status.  It is an auto reset event.

    szName and dwVersion are only valid when dwStatus is XDCS_STATUS_ACCEPTED.  The file returned
    is the uncompressed version (there will be a compressed version stored somwhere too.)

    dwPercentComplete and dwTimeRemaining can be polled to display a progress bar, while the status
    is XDCS_STATUS_VERIFYING or XDCS_DOWNLOADING.

    The status will return to XDCS_STATUS_NO_DONGLE whenever the device is removed.  The filename
    may or may not change, if and when another device is inserted.  The filename will probably
    be a derivative of the library version.  I expect to probably maintain up to three different
    versions on the harddisk at a time.

    If there is more than one device present, it will always use the first one found, which is kind of
    random.

Library:
    
    You must explictly link XDCS.LIB to use this library.
    
Environment:

    Xbox

Revision History:
    
    02-22-01 : Mitchell Dernis(mitchd) - created

--*/

#define XDCS_STATUS_INIT         0
#define XDCS_STATUS_NO_DONGLE    1
#define XDCS_STATUS_VERIFYING    2
#define XDCS_STATUS_DOWNLOADING  3 // (including the decompress time)
#define XDCS_STATUS_ACCEPTED     4
#define XDCS_STATUS_REJECTED     5

typedef struct _XDCS_DVD_LIBRARY_INFORMATION
{
    DWORD   dwStatus;              //status of the DVD library
    DWORD   dwPercentComplete;     //percent complete if dwStatus is XDCS_STATUS_VERIFYING or XDCS_STATUS_DOWNLOADING
    DWORD   dwTimeRemaining;       //time remaining (ms) for verify or download (guess)
    HANDLE  hStatusChangeEvent;    //handle to event which is signaled whenever dwStatus is updated.
    DWORD   dwCodeLength;          //length of the code stored in ROM   
    WORD    bcdVersion;            //msb = major version, lsb = minor version each byte is bcd. 0x0110 = version 01.10
    CHAR    szName[MAX_PATH];      //filename of code library
} XDCS_DVD_LIBRARY_INFORMATION, *PXDCS_DVD_LIBRARY_INFORMATION;

PXDCS_DVD_LIBRARY_INFORMATION XGetDvdLibraryInfoPointer();


#endif //__XDCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xdcs\xdcs.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCS2.CPP 

Abstract:

    CHANGED THE API COMPLETELY FROM THE ORIGINAL XDCS

    This source file implements the major entry points to the Xbox DVD Code Server
    driver (XDCS).  XDCS is a USB interface based device that contains the DVD playback
    code library.  The code resides in ROM on the device.
   

    The entire implementation is in this file.

    Client API:

      XDCSGetInformation     - Gets information about the code on the device
      XDCSDownloadCode       - Downloads the code synchronously
      XDCSDownloadCodeAsync  - Downloads the code asynchronously

    Entries required by the USB core stack:

      XDCS_Init
      XDCS_AddDevice
      XDCS_RemoveDevice

Environment:

    Xbox USB class driver.

Revision History:
    
    03-30-01 : Mitchell Dernis(mitchd) - created

Implementation and Use Overview:
    
    Totally different API from the original XDCS
   
--*/

//*****************************************************************************
// Headers
//*****************************************************************************

// Xbox Kernel Service Headers
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>

// Xbox System Software Headers
#include <xtl.h>
#include <xboxp.h>

// Useful Debug definitions
#define MODULE_POOL_TAG  'SCDX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XDCS");

// Xbox USB Class driver header
#include <usb.h>

// XDCS specific header



//*****************************************************************************
// XDCS constants and structures from the XDCS specification
//*****************************************************************************
#define XDCS_REQUEST_GET_ROM_FILE_INFO  1
#define XDCS_REQUEST_GET_ROM_FILE_BLOCK 2
#define XDCS_BLOCK_LENGTH               1024       //1k blocks
#define XDCS_BLOCK_SHIFT                10         //bit shift to divide by 1k
#define XDCS_CONTROL_TD_QUOTA     (2*(3+1024/64))  //2 1k transfers with 64 byte fifo
#define XDCS_MAX_PORTS            4                //The maximum number of ports supported
#define XDCS_REQUEST_TIMEOUT        (-10000*200)   //200 ms timeout
#define XDCS_MAX_TRIES                  4

//*****************************************************************************
//  Declare XDCS types and class.
//*****************************************************************************
DECLARE_XPP_TYPE(XDEVICE_TYPE_DVD_CODE_SERVER)
USB_DEVICE_TYPE_TABLE_BEGIN(XDCS_)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_DVD_CODE_SERVER)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(XDCS_, XBOX_DEVICE_CLASS_XDCS, 0, 0)
#pragma data_seg(".XPP$ClassXdcs")
USB_CLASS_DECLARATION_POINTER(XDCS_)
#pragma data_seg(".XPP$Data")

//*****************************************************************************
// Declare Local Structures
//*****************************************************************************

typedef struct _XDCS_DEVICE
{
    UCHAR                       bFlags;
    UCHAR                       bInterfaceNumber;
    USHORT                      usInstance;         //Update whenever a device is removed
    IUsbDevice                  *Device;
    XDCS_DVD_CODE_INFORMATION   CodeInformation;
} XDCS_DEVICE, *PXDCS_DEVICE;

#define XDCS_DEVICE_FLAG_CONNECTED    0x01
#define XDCS_DEVICE_FLAG_INUSE        0x02
#define XDCS_DEVICE_FLAG_ENUMERATING  0x04

#define MAKE_DWORD_INSTANCE(usInstance, dwPort) (((usInstance) << 16)|(dwPort))
#define PORT_FROM_DWORD_INSTANCE(dwInstance) (0x0000FFFF&(dwInstance))
#define USHORT_INSTANCE_FROM_DWORD_INSTANCE(dwInstance) ((USHORT)(((dwInstance)&0xFFFF0000)>>16))

typedef struct _XDCS_GLOBALS
{
    // Single set of resources for data transfer
    ULONG                        ulGlobalFlags;
    ULONG                        Urb1LastLength;  //*** DO NOT REORDER
    URB                          Urb1;            //*** SEE 
    ULONG                        Urb2LastLength;  //*** #define XDCS_URB_LAST_LEN
    URB                          Urb2;            //*** BELOW
    URB                          UrbEnum;
    ULONG                        BytesSubmitted;
    ULONG                        RetryCount;
    USBD_STATUS                  UsbdStatus;                        
    KTIMER                       WatchDogTimer;
    KDPC                         WatchDogTimerDpc;
    PXDCS_ASYNC_DOWNLOAD_REQUEST CurrentDownloadRequest;
    // Track attached devices
    XDCS_DEVICE   Devices[XDCS_MAX_PORTS];
} XDCS_GLOBALS, *PXDCS_GLOBALS;

#define XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS       0x00000001
#define XDCS_GLOBAL_FLAG_URB1_OUTSTANDING           0x00000002
#define XDCS_GLOBAL_FLAG_URB2_OUTSTANDING           0x00000004
#define XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING       0x00000008
#define XDCS_GLOBAL_FLAG_DOWNLOAD_URBS_OUTSTANDING  (XDCS_GLOBAL_FLAG_URB1_OUTSTANDING|\
                                                     XDCS_GLOBAL_FLAG_URB2_OUTSTANDING)
#define XDCS_GLOBAL_FLAG_URBS_OUTSTANDING           (XDCS_GLOBAL_FLAG_URB1_OUTSTANDING|\
                                                     XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING|\
                                                     XDCS_GLOBAL_FLAG_URB2_OUTSTANDING)
#define XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING           0x00000010

//
//  Takes advantage that Urb1LastLength is stored
//  right before Urb1 and Urb2LastLength is stored
//  right before Urb2.
//
#define XDCS_URB_LAST_LEN(Urb) (*((PULONG)(Urb)-1))

//****************************************
// Internally useful macros
//****************************************
#define SET_FLAG(variable, flag)  ((variable) |= (flag))
#define CLEAR_FLAG(variable, flag)  ((variable) &= ~(flag))
#define TEST_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ANY_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ALL_FLAGS(variable, flag)  ((flag)==((variable)&(flag)))

//*****************************************************************************
// Really cool inline template function for walking buffers.
//*****************************************************************************
template <class T>
inline T *AdvancePtr(T *pT, ULONG cb)
{
    return (T *)(((ULONG)pT) + cb);
}


//*****************************************************************************
// Declare Globals
//*****************************************************************************
USB_RESOURCE_REQUIREMENTS XDCS_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 1, 2, 1, 0, 0, XDCS_CONTROL_TD_QUOTA, 0, 0, 0};
XDCS_GLOBALS XDCS_Globals = {0};

//*****************************************************************************
// Forward Declaration of Local Functions
//*****************************************************************************
#if DBG
#define LOCALFUNC
#else
//Compiler may be able to optimize static functions better.
#define LOCALFUNC static
#endif 
LOCALFUNC VOID XDCS_AddComplete(PURB Urb, PXDCS_DEVICE XdcsDevice);
LOCALFUNC VOID XDCS_DownloadStateMachine(PURB Urb, PXDCS_DEVICE XdcsDevice);
LOCALFUNC BOOL XDCS_BuildAndSubmitDownloadRequest(PURB Urb,PXDCS_DEVICE XdcsDevice);
LOCALFUNC VOID XDCS_CompleteDownload(PURB Urb, PXDCS_DEVICE XdcsDevice);
LOCALFUNC VOID XDCS_WatchDogTimeout (PKDPC Dpc,PVOID,PVOID,PVOID);
LOCALFUNC VOID XDCS_StartExtendWatchdog();
LOCALFUNC VOID XDCS_StopWatchdog();    

//*****************************************************************************
// Implementation of USB Required Entry Points:
//  XDCS_Init,
//  XDCS_AddDevice,
//  XDCS_RemoveDevice
//*****************************************************************************
#pragma code_seg(".XPPCINIT")

EXTERNUSB VOID XDCS_Init(IUsbInit *pUsbInit)
/*++
    Routine Description:

        Called by the USB core stack when XDCS is linked in to the application.
        Initialize our globals, register our driver resource requirements.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XDCS_Init"));

    //Init the timer and timer dpc
    KeInitializeDpc(&XDCS_Globals.WatchDogTimerDpc, XDCS_WatchDogTimeout, NULL);
    KeInitializeTimer(&XDCS_Globals.WatchDogTimer);

    // register resources
    pUsbInit->RegisterResources(&XDCS_gResourceRequirements);

    USB_DBG_EXIT_PRINT(("Exiting XDCS_Init"));
    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID XDCS_AddDevice(IN IUsbDevice *Device)
/*++

    Routine Description:
    
      1) Records that the device is present and relevant info that
         it may need later.
      2) Gets the ROM info

    Arguments:
        Device - Interface to USB core stack for device.

    Notes:
        AddDevice routines are always called at DPC level.
--*/
{
    PXDCS_DEVICE xdcsDevice;
    ULONG ulPort;

    USB_DBG_ENTRY_PRINT(("XDCS_AddDevice(Device=0x%0.8x)", Device));
    
    //Get and check the port. (It should only work direct connect).
    ulPort = Device->GetPort();
    if(ulPort >= XDCS_MAX_PORTS)
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }
    
    xdcsDevice = &XDCS_Globals.Devices[ulPort];
    
    //This device should not already be marked as connected
    ASSERT(!TEST_FLAG(xdcsDevice->bFlags,XDCS_DEVICE_FLAG_CONNECTED));
    xdcsDevice->bInterfaceNumber = Device->GetInterfaceNumber();
    Device->SetExtension((PVOID)xdcsDevice);
    xdcsDevice->Device = Device;
    SET_FLAG(xdcsDevice->bFlags, XDCS_DEVICE_FLAG_ENUMERATING);

    //  Build and submit the XDCS_REQUEST_GET_ROM_FILE_INFO request
    USB_BUILD_CONTROL_TRANSFER(
        &XDCS_Globals.UrbEnum.ControlTransfer,
        NULL,
        (PVOID)&xdcsDevice->CodeInformation,         //right into the user's buffer
        sizeof(XDCS_DVD_CODE_INFORMATION),
        USB_TRANSFER_DIRECTION_IN,
        (PURB_COMPLETE_PROC)XDCS_AddComplete,
        (PVOID)xdcsDevice,
        FALSE,
        USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
        XDCS_REQUEST_GET_ROM_FILE_INFO,
        0,
        xdcsDevice->bInterfaceNumber,
        sizeof(XDCS_DVD_CODE_INFORMATION)
        );

    SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING);
    XDCS_StartExtendWatchdog();

    //Don't worry about errors the completion routine will handle.
    xdcsDevice->Device->SubmitRequest(&XDCS_Globals.UrbEnum);
    
    USB_DBG_EXIT_PRINT(("ExitingXDCS_AddDevice"));
    return;
}

LOCALFUNC VOID XDCS_AddComplete(PURB Urb, PXDCS_DEVICE XdcsDevice)
{

    CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING);
    CLEAR_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_ENUMERATING);
    XDCS_StopWatchdog();

    if(USBD_SUCCESS(Urb->Header.Status))
    {
        //Mark the device as connected
        SET_FLAG(XdcsDevice->bFlags,XDCS_DEVICE_FLAG_CONNECTED);
        //Complete the Add.
        XdcsDevice->Device->SetClassSpecificType(0);
        XdcsDevice->Device->AddComplete(USBD_STATUS_SUCCESS);
    } else
    {
        XdcsDevice->Device->AddComplete(Urb->Header.Status);
    }
}


EXTERNUSB VOID
XDCS_RemoveDevice (
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
       
      1) Records the removal.
      2) If the device is not in use, it and completes the remove.

    Arguments:
        Device - Interface to USB core stack for device that is to be
                 removed.
    Notes:
        RemoveDevice routines are always called at DPC level.
--*/
{
    USB_DBG_ENTRY_PRINT(("XDCS_RemoveDevice(Device=0x%0.8x)", Device));
    PXDCS_DEVICE xdcsDevice = (PXDCS_DEVICE) Device->GetExtension();

    //Mark the device as not connected.
    CLEAR_FLAG(xdcsDevice->bFlags,XDCS_DEVICE_FLAG_CONNECTED);
    
    //Increment the instance counter - so when it is
    //plugged back in it is different.
    xdcsDevice->usInstance++;

    //If the device is not in use, complete the removal.
    //Otherwise, who ever is using it will complete the removal
    //after they clean up.
    if(!TEST_FLAG(xdcsDevice->bFlags,XDCS_DEVICE_FLAG_INUSE))
    {
       xdcsDevice->Device = NULL;
       Device->SetExtension(NULL);
       Device->RemoveComplete();
    }

    USB_DBG_EXIT_PRINT(("exiting XDCS_RemoveDevice"));
    return;
}

DWORD
WINAPI
XDCSGetInformation(
    IN  DWORD dwPort,
    OUT PDWORD pdwDeviceInstance,
    OUT PXDCS_DVD_CODE_INFORMATION pDvdCodeInformation
    )
{

    PXDCS_DEVICE xdcsDevice;
    KIRQL oldIrql;
    DWORD dwError = ERROR_SUCCESS;

    // Validate parameters
    RIP_ON_NOT_TRUE("XDCSGetInformation", (dwPort < XDCS_MAX_PORTS));
    RIP_ON_NOT_TRUE("XDCSGetInformation", (NULL != pdwDeviceInstance));
    RIP_ON_NOT_TRUE("XDCSGetInformation", (NULL != pDvdCodeInformation));
    
    //Get the requested device.
    xdcsDevice = &XDCS_Globals.Devices[dwPort];
    
    //Synchronize access
    oldIrql = KeRaiseIrqlToDpcLevel();

    // Make sure the device is connected
    if(!TEST_FLAG(xdcsDevice->bFlags, XDCS_DEVICE_FLAG_CONNECTED))
    {
        dwError = ERROR_DEVICE_NOT_CONNECTED;
    }
    else
    {
        RtlCopyMemory(pDvdCodeInformation, &xdcsDevice->CodeInformation, sizeof(XDCS_DVD_CODE_INFORMATION));
        *pdwDeviceInstance = MAKE_DWORD_INSTANCE(xdcsDevice->usInstance, dwPort);
    }
    
    //Done synchronizing
    KeLowerIrql(oldIrql);

    return dwError;

}

DWORD
WINAPI
XDCSDownloadCode(
    DWORD   dwDeviceInstance,
    PVOID   pvBuffer,
    ULONG   ulOffset,
    ULONG   ulLength,
    PULONG  pulBytesRead
    )
{
    XDCS_ASYNC_DOWNLOAD_REQUEST asyncRequest;

    //
    //  Need an event to signal when done
    //
    asyncRequest.hCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(NULL == asyncRequest.hCompleteEvent)
    {
        return GetLastError();
    }

    //
    //  Fill out rest of async request
    //
    asyncRequest.dwDeviceInstance = dwDeviceInstance;
    asyncRequest.pvBuffer = pvBuffer;
    asyncRequest.ulOffset = ulOffset;
    asyncRequest.ulLength = ulLength;
    
    //
    //  Submit async request
    //
    XDCSDownloadCodeAsync(&asyncRequest);
    
    //
    //  Wait for the request to complete
    //
    WaitForSingleObject(asyncRequest.hCompleteEvent, INFINITE);

    //
    //  Copy byte read
    //
    *pulBytesRead = asyncRequest.ulBytesRead;

    //
    //  Return the status
    //
    return asyncRequest.ulStatus;
}

__inline BOOL SleepIfBusy(DWORD dwError)
{
    if(ERROR_BUSY == dwError)
    {
        Sleep(10);
        return TRUE;
    }
    return FALSE;
}

DWORD
WINAPI
XDCSDownloadCodeAsync(
    IN OUT PXDCS_ASYNC_DOWNLOAD_REQUEST pXDCSDownloadRequest
    )
{
    DWORD dwPort = PORT_FROM_DWORD_INSTANCE(pXDCSDownloadRequest->dwDeviceInstance);
    PXDCS_DEVICE xdcsDevice = &XDCS_Globals.Devices[dwPort];
    DWORD dwError;
    KIRQL oldIrql;
    
    
    //
    //  Loop until we managed to get capture the 
    //  transfer resources, poor man's mutex, but
    //  there should not be any contention for this.
    do
    {
        dwError = ERROR_SUCCESS;
        
        //Synchronize access
        oldIrql = KeRaiseIrqlToDpcLevel();
    
        //
        //  Check instance to make sure that the caller is getting
        //  what it thinks it is getting.  As long as the client
        //  got the instance from us, this is sufficient to check that
        //  the device is actually connected, unless the device has been
        //  added and removed 65536 times since they called us last.
        //
        if( xdcsDevice->usInstance != USHORT_INSTANCE_FROM_DWORD_INSTANCE(pXDCSDownloadRequest->dwDeviceInstance))
        {
            dwError = ERROR_DEVICE_NOT_CONNECTED;
        } else if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS))
        {
            dwError = ERROR_BUSY;
#if DBG        
        } else if(pXDCSDownloadRequest->ulOffset%XDCS_BLOCK_LENGTH)
        {
            KeLowerIrql(oldIrql);
            RIP("XDCSDownloadCode\\XDCSDownloadCodeAsync, Offset must be 1 kbyte aligned.");
            oldIrql = KeRaiseIrqlToDpcLevel();
        } else if(
            (pXDCSDownloadRequest->ulOffset+pXDCSDownloadRequest->ulLength) > 
            xdcsDevice->CodeInformation.dwCodeLength
          )
        {
            KeLowerIrql(oldIrql);
            RIP("XDCSDownloadCode\\XDCSDownloadCodeAsync, Transfer request is beyond data length");
            oldIrql = KeRaiseIrqlToDpcLevel();
#endif
        } else
        {
            //
            //  Claim the transfer resources
            //
            SET_FLAG(xdcsDevice->bFlags, XDCS_DEVICE_FLAG_INUSE);
            SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS);
            XDCS_Globals.CurrentDownloadRequest = pXDCSDownloadRequest;
            
            //
            //  Open the default endpoint
            //
            USB_BUILD_OPEN_DEFAULT_ENDPOINT(&XDCS_Globals.Urb1.OpenEndpoint);
            xdcsDevice->Device->SubmitRequest(&XDCS_Globals.Urb1);
        
            //
            //  Start Download
            //
            XDCS_DownloadStateMachine(NULL, xdcsDevice);
            dwError = ERROR_IO_PENDING;
        }
        KeLowerIrql(oldIrql);

    }while (SleepIfBusy(dwError));
    
    return dwError;
}

LOCALFUNC
VOID
XDCS_DownloadStateMachine(
    PURB Urb,
    PXDCS_DEVICE XdcsDevice
    )
{
    //
    //  Check if this is the first call.
    //
    if(NULL==Urb)
    {
        XDCS_Globals.UsbdStatus = USBD_STATUS_SUCCESS;
        XDCS_Globals.BytesSubmitted = 0;
        XDCS_Globals.CurrentDownloadRequest->ulStatus = ERROR_IO_PENDING;
        XDCS_Globals.CurrentDownloadRequest->ulBytesRead = 0;
        XDCS_Globals.RetryCount = 0;
        SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_DOWNLOAD_URBS_OUTSTANDING);
        XDCS_BuildAndSubmitDownloadRequest(&XDCS_Globals.Urb1, XdcsDevice);
        XDCS_BuildAndSubmitDownloadRequest(&XDCS_Globals.Urb2, XdcsDevice);
    } else
    //
    //  This is an URB completing
    //
    {
        BOOL fDone = FALSE;
        if(USBD_SUCCESS(Urb->Header.Status))
        {
            XDCS_Globals.RetryCount = 0;
            XDCS_Globals.CurrentDownloadRequest->ulBytesRead += Urb->ControlTransfer.TransferBufferLength;
            //
            // Resubmit the URB if there is more to transfer
            //
            fDone = XDCS_BuildAndSubmitDownloadRequest(Urb, XdcsDevice);
        }else if( (XDCS_Globals.RetryCount++ < XDCS_MAX_TRIES) && TEST_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_CONNECTED) )
        //
        //  Check the retry count and make sure the device is still connected.
        //  If we have retries left, just resubmit, but remember to reset
        //  the length, this is an IN\OUT parameter.
        //
        {
          XDCS_StartExtendWatchdog(); //Pet watchdog
          Urb->CommonTransfer.TransferBufferLength = XDCS_URB_LAST_LEN(Urb);
          XdcsDevice->Device->SubmitRequest(Urb);
        } else
        //
        //  Failed and the device is not connected or the retry count is exceeded.
        //
        {
            //
            //  Record the error if it is the first
            //
            if(USBD_SUCCESS(XDCS_Globals.UsbdStatus))
            {
              XDCS_Globals.UsbdStatus = Urb->Header.Status;
            }
            //
            //  If the twin URB is outstanding, cancel it.  If it is not oustanding
            //  mark that we are done.
            //
            if( &XDCS_Globals.Urb1 == Urb)
            {
                CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING);
                if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING))
                {
                    XdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb2);
                } else
                {
                    fDone = TRUE;
                }
            } else
            {
                CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING);
                if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING))
                {
                    XdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb1);
                } else
                {
                    fDone = TRUE;
                }
            }
        }
        //
        //  If the transfer is done, close down the endpoint.
        //
        if(fDone)
        {
            XDCS_StopWatchdog();
            USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
                &XDCS_Globals.Urb1.CloseEndpoint,
                (PURB_COMPLETE_PROC)XDCS_CompleteDownload,
                (PVOID)XdcsDevice
                );
            XdcsDevice->Device->SubmitRequest(&XDCS_Globals.Urb1);
        }
    }
}

LOCALFUNC
BOOL
XDCS_BuildAndSubmitDownloadRequest(
    PURB Urb,
    PXDCS_DEVICE XdcsDevice
    )
{
    //
    //  If there are more byte to submit, do it.
    //
    if(XDCS_Globals.BytesSubmitted < XDCS_Globals.CurrentDownloadRequest->ulLength)
    {
        //Calculate the transfer length for this command
        ULONG ulTransferSize = XDCS_Globals.CurrentDownloadRequest->ulLength - XDCS_Globals.BytesSubmitted;
        if(ulTransferSize > XDCS_BLOCK_LENGTH) ulTransferSize = XDCS_BLOCK_LENGTH;
        
        //
        //  Store the length in case we need to retry
        //
        XDCS_URB_LAST_LEN(Urb) = ulTransferSize;

        USBD_STATUS usbdStatus;
        USB_BUILD_CONTROL_TRANSFER(
                &Urb->ControlTransfer,
                NULL,
                AdvancePtr(XDCS_Globals.CurrentDownloadRequest->pvBuffer, XDCS_Globals.BytesSubmitted),
                ulTransferSize,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XDCS_DownloadStateMachine,
                (PVOID)XdcsDevice,
                FALSE,
                USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
                XDCS_REQUEST_GET_ROM_FILE_BLOCK,
                (WORD)((XDCS_Globals.CurrentDownloadRequest->ulOffset + XDCS_Globals.BytesSubmitted)>>XDCS_BLOCK_SHIFT),
                (WORD)XdcsDevice->bInterfaceNumber,
                (WORD)ulTransferSize
                );
        XDCS_Globals.BytesSubmitted += ulTransferSize;
        XDCS_StartExtendWatchdog();
        usbdStatus = XdcsDevice->Device->SubmitRequest(Urb);
        return FALSE;
    }

    //
    //  If there are no more requests to submit then clear the appropriate
    //  XDCS_GLOBAL_FLAG_URB?_OUTSTANDING flag.
    //
    if( &XDCS_Globals.Urb1 == Urb)
    {
        CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING);
    } else
    {
        CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING);
    }

    return 
      TEST_ANY_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_DOWNLOAD_URBS_OUTSTANDING) ?
      FALSE : TRUE;

}

LOCALFUNC
VOID 
XDCS_CompleteDownload(
    PURB Urb,
    PXDCS_DEVICE XdcsDevice
    )
{
    //
    //  Set the status and signal the hEvent.
    //
    XDCS_Globals.CurrentDownloadRequest->ulStatus = IUsbDevice::Win32FromUsbdStatus(XDCS_Globals.UsbdStatus);
    if(XDCS_Globals.CurrentDownloadRequest->hCompleteEvent)
        SetEvent(XDCS_Globals.CurrentDownloadRequest->hCompleteEvent);

    //
    //  Release the shared resources
    //
    XDCS_Globals.CurrentDownloadRequest = NULL;
    CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS);

    //
    //  Clear the in use flag
    //
    CLEAR_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_INUSE);
    //
    //  Check if the device was removed while we were using it.  If it was
    //  need to complete the remove.
    //
    if(!TEST_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_CONNECTED))
    {
       XdcsDevice->Device->SetExtension(NULL);
       XdcsDevice->Device->RemoveComplete();
       XdcsDevice->Device = NULL;
    }
}


LOCALFUNC
VOID
XDCS_WatchDogTimeout (
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
    Routine Description:
        
        This is the DPC routine for the XDCS watchdog timer.  It protects
        against hung requests, NAK forever.
        
        Whenever it fires it cancels all outstanding URBs.

--*/
{

    USB_DBG_WARN_PRINT(("XDCS timed out."));

    CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING);
    
    PXDCS_DEVICE xdcsDevice = NULL;
    if(XDCS_Globals.CurrentDownloadRequest)
    {
        xdcsDevice = &XDCS_Globals.Devices[
                        PORT_FROM_DWORD_INSTANCE(XDCS_Globals.CurrentDownloadRequest->dwDeviceInstance)
                        ];

        if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING))
        {
            xdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb1);
        }
        if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING))
        {
            xdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb2);
        }
    }

    if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING))
    {
        for(DWORD dwPort=0; dwPort<XDCS_MAX_PORTS; dwPort++)
        {
            if( TEST_FLAG(XDCS_Globals.Devices[dwPort].bFlags, XDCS_DEVICE_FLAG_ENUMERATING) )
            {
                XDCS_Globals.Devices[dwPort].Device->CancelRequest(&XDCS_Globals.UrbEnum);
                break;
            }
        }
    }
        
}

LOCALFUNC 
VOID 
XDCS_StartExtendWatchdog()
{
    LARGE_INTEGER timeout;
    timeout.QuadPart = XDCS_REQUEST_TIMEOUT;
    SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING);
    KeSetTimer(&XDCS_Globals.WatchDogTimer, timeout, &XDCS_Globals.WatchDogTimerDpc);
}

LOCALFUNC VOID XDCS_StopWatchdog()
{
    if(!TEST_ANY_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URBS_OUTSTANDING))
    {
        KeCancelTimer(&XDCS_Globals.WatchDogTimer);
        CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xdcs\xdcspold.h ===
#ifndef __XDCSP_H__
#define __XDCSP_H__
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCSP.H

Abstract:

    Private Header file XDCS device driver.
   
Environment:

    Xbox

Revision History:
    
    02-23-01 : Mitchell Dernis(mitchd) - created

--*/

#include <xdcs.h>

//***************************************
// XDCS constants and structures from the
// XDCS specification
//***************************************
#define USB_DEVICE_CLASS_XDCS 0x59

#define XDCS_REQUEST_GET_ROM_FILE_INFO  1
#define XDCS_REQUEST_GET_ROM_FILE_BLOCK 2
#define XDCS_BLOCK_LENGTH               1024 //1k blocks

#include <pshpack1.h>
typedef struct _XDCS_ROM_INFORMATION
{
    USHORT bcdCodeVersion;
    ULONG  dwCodeLength;
} XDCS_ROM_INFORMATION, *PXDCS_ROM_INFORMATION;
#include <poppack.h>

//****************************************
// Internally useful constants
//****************************************
#define XDCS_NUM_BLOCKS_TO_VERIFY 3           //Number of blocks to verify against
                                              //against a dongle
#define XDCS_CONTROL_TD_QUOTA     (3+1024/64) //1k transfer with 64 byte fifo
#define XDCS_MAX_PORTS            4           //The maximum number of ports supported
#define XDCS_FLAG_CONNECTED       0x01        //set if the device is conneceted
#define XDCS_FLAG_IN_USE          0x02        //set if the device is currently being
                                              //accessed by the 
#define XDCS_MAX_TRIES            3           //number of times we try an XDCS before
                                              //reporting it as not responding

#define XDCS_DVD_LIB_NAME         "t:\\testdvdlib.cab"
//****************************************
// Definitions for the buffers
//****************************************
#define XDCS_BUFFER_COUNT   3
#define XDCS_BUFFER_START   0
#define XDCS_BUFFER_FILE    1
#define XDCS_BUFFER_DEVICE  2
#define XDCS_BUFFER_DONE    3
#define DEFAULT_URB XDCS_Globals.Buffers[0].Urb

//****************************************
// Internally useful macros
//****************************************
#define SET_FLAG(variable, flag)  ((variable) |= (flag))
#define CLEAR_FLAG(variable, flag)  ((variable) &= ~(flag))
#define TEST_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ANY_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ALL_FLAGS(variable, flag)  ((flag)==((variable)&(flag)))

//****************************************
// Internal data structures
//****************************************

/*++
    XDCS_DEVICE - Represents the state of
    one of the device ports and the device
    plugged into if, any.
--*/
typedef struct _XDCS_DEVICE
{
    UCHAR       bFlags;
    UCHAR       bInterfaceNumber;
    USHORT      Pad;
    IUsbDevice *Device;
} XDCS_DEVICE, *PXDCS_DEVICE;

/*++
    XDCS_DOWNLOAD_BUFFER - During download of the code
    this structure is ping-ponged between reading the code
    from the device and writing it to file.

    There are XDCS_BUFFER_COUNT of these in the globals structure
    so that multiple requests can be outstanding at a time.

    Members of some of the instance of this structure are borrowed
    in a few places, just to be careful about using memory.
--*/
typedef struct _XDCS_DOWNLOAD_BUFFER
{
    DWORD  dwStage;
    union
    {
        URB        Urb;
        OVERLAPPED Overlapped;
    };
    CHAR  buffer[XDCS_BLOCK_LENGTH]; //For download
    
} XDCS_DOWNLOAD_BUFFER, *PXDCS_DOWNLOAD_BUFFER;

/*++
    XDCS_GLOBALS - this structure binds all the globals into
    a single structure.
--*/
typedef struct _XDCS_GLOBALS
{
    //LibrayInfo is the portion that the client can read at will
    XDCS_DVD_LIBRARY_INFORMATION LibraryInfo;

    //Additional information about the library, which is useful to 
    //cache, but the client doesn't need to see it
    DWORD                        dwLastBlockLength;
    DWORD                        dwBlockCount;

    //Keep track of devices, and which one (if any has been used
    //to verify the library)
    PXDCS_DEVICE                 CurrentDevice;
    XDCS_DEVICE                  Devices[XDCS_MAX_PORTS];

    //Event to waken worker thread
    KEVENT                       ThreadEvent;

    //Utility memory for doing the download
    HANDLE                       BufferEvents[XDCS_BUFFER_COUNT];
    XDCS_DOWNLOAD_BUFFER         Buffers[XDCS_BUFFER_COUNT];
} XDCS_GLOBALS, *PXDCS_GLOBALS;

#endif //__XDCSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xid\typeinfo.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Tables with information concerning the currently supported
    set of XID devices.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    08-01-00 created by Mitchell Dernis (mitchd)

--*/
//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIH'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");


//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"


//----------------------------------------------
//  Game Controller Reports
//----------------------------------------------
#define XID_DEFAULT_MAX_GAMEPAD        4
XINPUT_GAMEPAD       GamepadDefaults ={0, //All the digital buttons (including DPAD) up.
                                       0,0,0,0,0,0,0,0,   //All the analog buttons up
                                       0,0,       //The Left Thumbstick centered
                                       0,0        //The Right Thumbstick centered
                                       };
XID_REPORT_TYPE_INFO GameInputReportInfoList[1] = {sizeof(XINPUT_GAMEPAD),(PVOID)&GamepadDefaults};
XINPUT_RUMBLE        RumbleDefaults = {0};  //The motors are off by default
XID_REPORT_TYPE_INFO GameOutputReportInfoList[1] = {sizeof(XINPUT_RUMBLE),(PVOID)&RumbleDefaults};
XINPUT_POLLING_PARAMETERS GameDefaultPolling = {TRUE,FALSE,0,8,0,0}; //AutoPoll On, control-OUT,
                                                                     //8 ms Input Poll Interval,
                                                                     

//----------------------------------------------
//  Keyboard Reports
//----------------------------------------------
#define XID_DEFAULT_MAX_KEYBOARD          1
XINPUT_KEYBOARD      KeyboardDefaults ={0, //All modified keys up
                                       0, //Reserved byte is zero
                                       0,0,0,0,0,0 //No keys down
                                       };
XID_REPORT_TYPE_INFO KeyboardReportInfoList[1] = {sizeof(XINPUT_KEYBOARD),(PVOID)&KeyboardDefaults};
XINPUT_KEYBOARD_LEDS KeyboardLEDDefaults = {0};  //All light off by default
XID_REPORT_TYPE_INFO KeyboardLEDReportInfoList[1] = {sizeof(XINPUT_KEYBOARD_LEDS),(PVOID)&KeyboardLEDDefaults};
XINPUT_POLLING_PARAMETERS KeyboardDefaultPolling = {TRUE,FALSE,0,16,0,0}; //AutoPoll On, SET_REPORT for out,
                                                                          //16 ms Input Poll Interval,

//----------------------------------------------
//  IR Remote Reports
//----------------------------------------------
#define XID_DEFAULT_MAX_IRREMOTE          1
XINPUT_IR_REMOTE     IrRemoteDefaults = {0,0};
XID_REPORT_TYPE_INFO IrRemoteReportInfoList[1] = {sizeof(XINPUT_IR_REMOTE),(PVOID)&IrRemoteDefaults};
XINPUT_POLLING_PARAMETERS IrRemoteDefaultPolling = {TRUE,FALSE,0,16,0,0};  //AutoPoll On, Interrupt-OUT,
                                                                           //16 ms Input Poll Interval

//----------------------------------------------
// Type information list
//----------------------------------------------
XID_TYPE_INFORMATION XID_TypeInformationList[XID_DEVTYPE_COUNT] = {
    // Game Controllers
    {XID_DEFAULT_MAX_GAMEPAD, XID_DEVSUBTYPE_MAX_GAME, XID_INPUT_REPORT_ID_MAX_GAME, XID_OUTPUT_REPORT_ID_MAX_GAME,
    GameInputReportInfoList, GameOutputReportInfoList, &GameDefaultPolling, XID_ProcessGamepadData, 0}
    //Keyboard
    ,{XID_DEFAULT_MAX_KEYBOARD, XID_DEVSUBTYPE_MAX_KEYBOARD, XID_INPUT_REPORT_ID_MAX_KEYBOARD, XID_OUTPUT_REPORT_ID_MAX_KEYBOARD,
    KeyboardReportInfoList, KeyboardLEDReportInfoList, &KeyboardDefaultPolling, XID_ProcessNewKeyboardData,
    XID_BSF_NO_CAPABILITIES|XID_BSF_NO_OUTPUT_HEADER}
    // IR Remote
    ,{XID_DEFAULT_MAX_IRREMOTE, XID_DEVSUBTYPE_MAX_IRREMOTE, XID_INPUT_REPORT_ID_MAX_IRREMOTE, XID_OUTPUT_REPORT_ID_MAX_IRREMOTE,
    IrRemoteReportInfoList, NULL, &IrRemoteDefaultPolling, XID_ProcessIRRemoteData, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xdcs\xdcs_old.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCS.CPP

Abstract:

    This source file implements the major entry points to the Xbox DVD Code Server
    driver (XDCS).  XDCS is a USB interface based device that contains the DVD playback
    code library.  The code resides in ROM on the device.
    
    Basically, this driver maintains the current version of the library, including: downloading
    the library and saving it to a file, verifying the presence of the dongle, and providing the
    validated library file and version info to the client.  This driver is currently private and
    the only intended client is the XDash application.


    The entire implementation is in this file.

    Client API:

      XGetDvdLibraryInfoPointer

    Entries required by the USB core stack:

      XDCS_Init
      XDCS_AddDevice
      XDCS_RemoveDevice

Environment:

    Xbox USB class driver.

Revision History:
    
    02-22-01 : Mitchell Dernis(mitchd) - created

Implementation and Use Overview:

    1) The driver must be linked explicitly as it is not a publically support device.

    2) XDCS devices are not enumerable by clients.  There is no public device type name.  
    
    3) The first XDCS device to be enumerated (i.e. XDCS_AddDevice is called) is the device used.

    4) During XInitDevices, a configuration file is read from the harddisk (or created if not present)
       with information about the DVD library currently on the harddisk, including: version number, and
       the filename, and length.  This information is read into a global data structure.  Other fields
       indicate whether or not the library has been verified against the device, and the status of
       enumeration, download and verification, etc.

    5) Calling XGetDvdPlaybackLibraryInfo returns a pointer (to be consider read only by the client)
       to the global library information structure.

    6) When ever the persistant fields of the library info change, the file is updated.

    7) The library status goes the through the following stages:
        a) XDCS_STATUS_INIT        - stays in the state for up to 2 seconds after XInitDevices.
        b) XDCS_STATUS_NO_DONGLE   - there is no dongle present.  The user should insert one.
        c) XDCS_STATUS_VERIFYING   - dongle found and the library on the harddisk is being verified against
                                     the code on the device.
        d) XDCS_STATUS_DOWNLOADING - dongle found and is being downloaded (either there is no code on the
                                     harddisk or the version is different).
        e) XDCS_STATUS_ACCEPTED   - dongle found and the code has been verified against the code on the dongle
                                     or it has been newly downloaded.
        f) XDCS_STATUS_REJECTED    - dongle found, BUT the code did not match the code on the harddisk despite
                                     being the same version, and the code could not be successfully downloaded.

    8) There are two progress fields:  percent complete and time remaining.  The percent complete is increments of 
        1%.  The timing remaing is a guess in milliseconds.  Initially the guess is based on the original dongle,
        but it dynamically updates taking into account how much has already been transfered, and how long it has taken.

    9) There is a status change event.  It is has an automatic reset property.  The event is set every time the status
       field is changed.  It is optional.

    10) The filename and code version are used internally at all times, the client should only consider these fields valid
        when the status is XDCS_STATUS_ACCEPTED.

--*/

//*****************************************************************************
// Headers
//*****************************************************************************

// Xbox Kernel Service Headers
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>

// Xbox System Software Headers
#include <xtl.h>

// Useful Debug definitions
#define MODULE_POOL_TAG  'SCDX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XDCS");

// Xbox USB Class driver header
#include <usb.h>

// XDCS specific header
#include "xdcsp.h"


//*****************************************************************************
// For debugging the download code
//*****************************************************************************
#if DBG
    struct XDCS_STAGE_LOG
    {
        DWORD  dwStage;
        DWORD  dwBufferIndex;
    };
    
    DWORD XDCS_StageLogEntries;
    XDCS_STAGE_LOG XDCS_StageLog[100];
#define XDCS_INIT_STAGE_LOG() (XDCS_StageLogEntries = 0)
#define XDCS_LOG(dwBufferIndex)\
    {\
    XDCS_StageLog[XDCS_StageLogEntries].dwStage = XDCS_Globals.Buffers[dwBufferIndex].dwStage;\
    XDCS_StageLog[XDCS_StageLogEntries].dwBufferIndex = dwBufferIndex;\
    XDCS_StageLogEntries++;\
    }
#else 
    #define XDCS_INIT_STAGE_LOG()
    #define XDCS_LOG(dwBufferIndex)
#endif

//*****************************************************************************
//  Declare XDCS types and class.
//*****************************************************************************
USB_DEVICE_TYPE_TABLE_BEGIN(XDCS_)
USB_DEVICE_TYPE_TABLE_ENTRY(NULL)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(XDCS_, USB_DEVICE_CLASS_XDCS, 0, 0)
#pragma data_seg(".XPP$ClassXdcs")
USB_CLASS_DECLARATION_POINTER(XDCS_)
#pragma data_seg(".XPP$Data")

//*****************************************************************************
// Declare Globals
//*****************************************************************************
USB_RESOURCE_REQUIREMENTS XDCS_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 1, 2, 1, 0, 0, XDCS_CONTROL_TD_QUOTA, 0, 0, 0};

XDCS_GLOBALS XDCS_Globals = {0};

// LOCALFUNC is a useful tag so that functions defined at file scope can be
// declared static in release builds (conserves global namespace, and perhaps
// allows better optimization), but non-static in debug for ease of debugging.
#if DBG
#define LOCALFUNC
#else 
#define LOCALFUNC static
#endif

//*****************************************************************************
// Declare Locally Used and Defined methods
//*****************************************************************************
__inline VOID XDCS_ChangeStatus(DWORD dwStatus);
LOCALFUNC VOID FASTCALL XDCS_fCompleteRemove(PXDCS_DEVICE XdcsDevice);
DWORD WINAPI XDCS_WorkThread(LPVOID);
LOCALFUNC BOOL FASTCALL XDCS_fVerifyFile();
LOCALFUNC BOOL FASTCALL XDCS_fDownloadFile();
VOID XDCS_SignalComplete(PURB, PVOID pEvent);
LOCALFUNC VOID FASTCALL XDCS_fCreateBufferEvents();
LOCALFUNC DWORD FASTCALL XDCS_fRandomBlock(DWORD BlockCount);


//*****************************************************************************
// Implementation of API
//*****************************************************************************
PXDCS_DVD_LIBRARY_INFORMATION XGetDvdLibraryInfoPointer()
{
    return &XDCS_Globals.LibraryInfo;
}

//*****************************************************************************
// Implementation of USB Required Entry Points:
//  XDCS_Init,
//  XDCS_AddDevice,
//  XDCS_RemoveDevice
//*****************************************************************************
#pragma code_seg(".XPPCINIT")

EXTERNUSB VOID XDCS_Init(IUsbInit *pUsbInit)
/*++
    Routine Description:

        Called by the USB core stack when XDCS is linked in to the application.
        Initialize our globals, register our driver resource requirements, set
        a timer guess when we first detect devices.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XDCS_Init"));
    
    XDCS_Globals.LibraryInfo.dwStatus = XDCS_STATUS_INIT;
    XDCS_Globals.CurrentDevice = NULL;
    
    //Setup event handle
    XDCS_Globals.LibraryInfo.hStatusChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(XDCS_Globals.LibraryInfo.hStatusChangeEvent);

    //Initialize the event to signal our thread.
    KeInitializeEvent(&XDCS_Globals.ThreadEvent, SynchronizationEvent, FALSE);
    
    //Create buffer events
    XDCS_fCreateBufferEvents();

    //CreateThread, we need this to the File I/O work
#if DBG
    HANDLE thread = 
#endif
    CreateThread(NULL, 65536, XDCS_WorkThread, NULL, 0, NULL);
    ASSERT(thread);

    // register resources
    pUsbInit->RegisterResources(&XDCS_gResourceRequirements);

    USB_DBG_EXIT_PRINT(("Exiting XDCS_Init"));
    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID XDCS_AddDevice(IN IUsbDevice *Device)
/*++

    Routine Description:
    
      Records that the device is present and relevant info that
      it may need later.  Then completes the add.

      If there is currently no device in use (i.e. backing a
      library that was downloaded from the device or checked
      against the device), then we download the code library or
      check a library already on the harddisk.

    Arguments:
        Device - Interface to USB core stack for device.

    Notes:
        AddDevice routines are always called at DPC level.
--*/
{
    PXDCS_DEVICE xdcsDevice;
    ULONG ulPort;

    USB_DBG_ENTRY_PRINT(("XDCS_AddDevice(Device=0x%0.8x)", Device));
    
    //Get and check the port. (It should only work direct connect).
    ulPort = Device->GetPort();
    if(ulPort >= XDCS_MAX_PORTS)
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }
    
    xdcsDevice = &XDCS_Globals.Devices[ulPort];
    
    //This device should not already be marked as connected
    ASSERT(!TEST_FLAG(xdcsDevice->bFlags,XDCS_FLAG_CONNECTED));

    //Mark the device as connected
    SET_FLAG(xdcsDevice->bFlags,XDCS_FLAG_CONNECTED);
    xdcsDevice->bInterfaceNumber = Device->GetInterfaceNumber();
    Device->SetExtension((PVOID)xdcsDevice);
    xdcsDevice->Device = Device;
    
    //Complete the Add - this allows enumeration to continue, it
    //also has a couple of implications.
    // 1) The default endpoint is no longer opened when this returns
    // 2) A remove call can come for this device, as soon as we
    //    return from this routine.  (Not before, as we are at DPC
    //    the whole time.)
    Device->AddComplete(USBD_STATUS_SUCCESS);

    // 
    // If there is not currently a current device, make this
    // the current device.
    //
    if(!XDCS_Globals.CurrentDevice)
    {
        XDCS_Globals.CurrentDevice = xdcsDevice;
        KeSetEvent(&XDCS_Globals.ThreadEvent, IO_NO_INCREMENT, FALSE);
    }

    USB_DBG_EXIT_PRINT(("ExitingXDCS_AddDevice"));
    return;
}

EXTERNUSB VOID
XDCS_RemoveDevice (
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
       
      Records the removal, and completes the remove.
      
      If the status of the DVD code is XDCS_STATUS_ACCEPTED and the device that was removed, is the device
      the code was verified against then the status is changed to XDCS_STATUS_NO_DEVICE.  If other devices
      are present, then verification may take place against another device.

    Arguments:
        Device - Interface to USB core stack for device that is to be
                 removed.
    Notes:
        RemoveDevice routines are always called at DPC level.
--*/
{
    USB_DBG_ENTRY_PRINT(("XDCS_RemoveDevice(Device=0x%0.8x)", Device));
    PXDCS_DEVICE xdcsDevice = (PXDCS_DEVICE) Device->GetExtension();

    //Mark the device as not connected.
    CLEAR_FLAG(xdcsDevice->bFlags,XDCS_FLAG_CONNECTED);

    //If the device is not in use (i.e. currently be accessed by our
    //worker thread, then we are done.  The worker thread will see
    //that the connected flag has been cleared, and will finish the removal.
    if(!TEST_FLAG(xdcsDevice->bFlags,XDCS_FLAG_IN_USE))
    {
       XDCS_fCompleteRemove(xdcsDevice);
    }

    USB_DBG_EXIT_PRINT(("exiting XDCS_RemoveDevice"));
    return;
}


//*****************************************************************************
// Implementation of Local Methods:
//  XDCS_ChangeStatus,
//*****************************************************************************

__inline VOID XDCS_ChangeStatus(DWORD dwStatus)
/*++
  Routine Description:
    Utility function that ensures that the status change event is signaled
    whenever the status is changed.
--*/
{
    XDCS_Globals.LibraryInfo.dwStatus = dwStatus;
    SetEvent(XDCS_Globals.LibraryInfo.hStatusChangeEvent);
}


LOCALFUNC
VOID
FASTCALL
XDCS_fCompleteRemove(
    PXDCS_DEVICE XdcsDevice
    )
/*++
    Routine Description:

      Calls IUsbDevice::RemoveComplete for the device.  All endpoints
      have to be closed (and there can be no outstanding traffic), so
      this routine is called either from XDCS_RemoveDevice (if the
      device was not being used when it was removed_, or it is called
      from the worker thread, when it is done trying to talk to the device.

      After calling remove complete, it checks to see if the removed device
      was the current device (i.e. the code library was downloaded or verified
      from this device).  If it was the current device, the status is changed
      to XDCS_STATUS_NO_DONGLE and a search is done for a new current device.

--*/
{
    //
    // We can complete the removal
    //
    XdcsDevice->Device->SetExtension(NULL);
    XdcsDevice->Device->RemoveComplete();
    XdcsDevice->Device = NULL;
    
    //
    // If the device just removed was the one backing
    // the DVD code library, we must change the status to not connected
    // then we can search for another and try and validate
    // the code library against it (or download a new one from another
    // device).
    //
    if(XDCS_Globals.CurrentDevice == XdcsDevice)
    {
        XDCS_Globals.CurrentDevice = NULL;
        XDCS_ChangeStatus(XDCS_STATUS_NO_DONGLE);
        //
        //Search for a connected XDCS, and reestablish a code library
        //
        for(ULONG index = 0; index < XDCS_MAX_PORTS; index++)
        {
            if(TEST_FLAG(XDCS_Globals.Devices[index].bFlags,XDCS_FLAG_CONNECTED))
            {
                //
                //  We found one, set it as the current device and signal
                //  the thread event to awaken our worker.
                //
                XDCS_Globals.CurrentDevice = &XDCS_Globals.Devices[index];
                KeSetEvent(&XDCS_Globals.ThreadEvent, IO_NO_INCREMENT, FALSE);
              
            }
        }
    }
}

DWORD 
WINAPI
XDCS_WorkThread(LPVOID)
/*++

  Routine Description:

    This routine is a worker thread for the XDCS driver.
    It sleeps until signalled, by XDCS_AddDevice (or in
    some circumstance as a result of XDCS_RemoveDevice).

    When woken up it looks XDCS_Globals.CurrentDevice and
    finds and verifies a Dvd playback code library against
    the ROM, or if necessary downloads the code
    XDCS_Globals.CurrentDevice.  When it is done, it goes
    back to sleep.

--*/
{
    
    XDCS_ROM_INFORMATION      romInfo;
    DWORD                     dwReason;
    LARGE_INTEGER             liWait;
    PLARGE_INTEGER            pInitialWait = &liWait;
    USBD_STATUS               usbdStatus;
    KIRQL                     oldIrql;
    BOOL                      fSuccess;
    ULONG                     ulRetry=0;

    USB_DBG_ENTRY_PRINT(("Entering XDCS_WorkThread"));
    //leave up to 2 seconds in XDCS_STATUS_INIT
    liWait.QuadPart = -10000*1000*2;

    // Thread loops forever and cannot be terminated
    while(1)
    {
        //
        // Wait until signaled to process XDCS device
        //
        dwReason = KeWaitForSingleObject(
                        &XDCS_Globals.ThreadEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        pInitialWait
                        );
        //
        //  The first time through, we may timeout
        //  at which time the library status must
        //  be changed from XDCS_STATUS_INIT to 
        //  XDCS_STATUS_NO_DONGLE
        //
        pInitialWait = NULL;
        if(WAIT_TIMEOUT==dwReason)
        {
          XDCS_ChangeStatus(XDCS_STATUS_NO_DONGLE);
          continue;
        }

        //
        //  Synchronize with XDCS_AddDevice and
        //  XDCS_RemoveDevice
        //
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  If the current device is still connected mark it in use, so that
        //  it doesn't get removed while we are mucking with it.
        //
        if(TEST_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_CONNECTED))
        {
            SET_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_IN_USE);
        } else
        {
            XDCS_fCompleteRemove(XDCS_Globals.CurrentDevice);
            KeLowerIrql(oldIrql);
            continue;
        }

        //
        //  Open the default endpoint
        //  Open is not allowed to fail, we don't even check
        //
        USB_BUILD_OPEN_DEFAULT_ENDPOINT(&DEFAULT_URB.OpenEndpoint);
        XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);
        
        //
        //  Build the XDCS_REQUEST_GET_ROM_FILE_INFO request
        //  (notice that this is synchronous)
        //
        USB_BUILD_CONTROL_TRANSFER(
            &DEFAULT_URB.ControlTransfer,
            NULL,
            (PVOID)&romInfo,
            sizeof(XDCS_ROM_INFORMATION),
            USB_TRANSFER_DIRECTION_IN,
            NULL,
            NULL,
            FALSE,
            USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
            XDCS_REQUEST_GET_ROM_FILE_INFO,
            0,
            XDCS_Globals.CurrentDevice->bInterfaceNumber,
            sizeof(XDCS_ROM_INFORMATION)
            );

        //
        //  Submit it (must be done at passive level), and the check for errors.
        //
        KeLowerIrql(oldIrql);
        usbdStatus = XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);
        if(USBD_SUCCESS(usbdStatus))
        {
            //
            //  Set the version and filename based on the rom version
            //
            XDCS_Globals.LibraryInfo.bcdVersion = romInfo.bcdCodeVersion;
            XDCS_Globals.LibraryInfo.dwCodeLength = romInfo.dwCodeLength;
            
            
            /*
             * Don't do this!  As per Chris's request we will use only one filename for all versions.
             * This way files don't accumulate when you start plugging in dongles of different versions.
             *
            
            wsprintfA(
                XDCS_Globals.LibraryInfo.szName,
                "y:\\DvdLib_v%x.%0.2x.cab", 
                (ULONG)((romInfo.bcdCodeVersion&0xff00)>>8),
                (ULONG)(romInfo.bcdCodeVersion&0x00ff)
                );
             *
             * If this does get put back, we have to make sure that there is some code, to 
             * manage this files and make sure that not more or two or three ever accumulate.
             *
             */
            RtlZeroMemory(&XDCS_Globals.LibraryInfo.szName, sizeof(XDCS_Globals.LibraryInfo.szName));
            wsprintfA(XDCS_Globals.LibraryInfo.szName, XDCS_DVD_LIB_NAME);

            //
            //  Calculate the blockCount, and the length of the last block.
            //
            XDCS_Globals.dwBlockCount = XDCS_Globals.LibraryInfo.dwCodeLength/XDCS_BLOCK_LENGTH;
            XDCS_Globals.dwLastBlockLength = XDCS_Globals.LibraryInfo.dwCodeLength%XDCS_BLOCK_LENGTH;
            if(XDCS_Globals.dwLastBlockLength)
            {
                XDCS_Globals.dwBlockCount++;
            } else
            {
                XDCS_Globals.dwLastBlockLength = XDCS_BLOCK_LENGTH;
            }

            //
            //  Try to the verify the file (whether or not the file
            //  is there).
            //
            fSuccess = XDCS_fVerifyFile();
            if(!fSuccess)
            {
                //
                //  Since we couldn't verify the file
                //  just try to download it.
                //
                fSuccess = XDCS_fDownloadFile();
            }
        } else
        {
            fSuccess = FALSE;
        }
        //
        //  Build and Submit the close URB
        //
        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
            &DEFAULT_URB.CloseEndpoint,
            NULL,
            NULL
            )
        XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);

        //
        // Synchronize with XDCS_AddDevice and XDCS_RemoveDevice
        // again.
        //
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Turn off the in use flag
        //
        //
        CLEAR_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_IN_USE);
        //Check to see if the device is still connected
        if(TEST_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_CONNECTED))
        {
            //
            // The device is connected, but it failed, we need a remedy
            // the simplest thing is to try again.
            //
            if(!fSuccess)
            {
                //
                // If exceeded the try count, report the device as not responding.
                // When the device is removed, prior to being reset, an attempt
                // will be made to try another device if present.
                //
                if(++ulRetry > XDCS_MAX_TRIES)
                {
                    XDCS_Globals.CurrentDevice->Device->DeviceNotResponding();
                    ulRetry = 0;
                } else
                //
                //  The reset was not exceeded, so just set our thread event
                //  so we don't stop at the wait when it loops through again.
                //
                {
                    //Set the event, and going through the loop will 
                    KeSetEvent(&XDCS_Globals.ThreadEvent, IO_NO_INCREMENT, FALSE);
                }
            } else
            {
                //We succeeded, so just 0 out the retry count.
                ulRetry = 0;
            }
        } else
        {
            //
            // The device was removed, while we were try to process it.
            // Whether it succeeded or not remove complete, will handle it.
            //
            XDCS_fCompleteRemove(XDCS_Globals.CurrentDevice);
        }
        KeLowerIrql(oldIrql);
    }
    return 0;
}

LOCALFUNC BOOL FASTCALL XDCS_fVerifyFile()
{
    
    HANDLE hFile;
    BOOL   fResult;
    //
    //  Trying opening the file
    //
    hFile = CreateFile(
        XDCS_Globals.LibraryInfo.szName,    
        GENERIC_READ,                       
        0,                                  
        NULL,                              
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    
    //
    //  If the file doesn't exist, then we fail
    //  (We sure hope it didn't fail for other reasons.)
    if(INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }
    
    //
    //  Get the size of the file, and check it against
    //  the size we are expecting.
    //
    if(XDCS_Globals.LibraryInfo.dwCodeLength != GetFileSize(hFile, NULL))
    {
        CloseHandle(hFile);
        return FALSE;
    }

    //From here on, assume success, until we fail
    fResult = TRUE;

    //
    //  Switch the status to verifying
    //  
    XDCS_Globals.LibraryInfo.dwPercentComplete = 0;
    XDCS_ChangeStatus(XDCS_STATUS_VERIFYING);

    //
    //  Now go through and check a few random blocks.
    //
    DWORD dwBlockIndex;
    DWORD dwOffset;
    DWORD dwSize, dwBytesRead;

    int  loop;
    for(loop=0; loop<XDCS_NUM_BLOCKS_TO_VERIFY; loop++)
    {
        // Choose a random block
        dwBlockIndex = XDCS_fRandomBlock(XDCS_Globals.dwBlockCount);
        
        //Figure out the offset and size
        dwOffset = dwBlockIndex * XDCS_BLOCK_LENGTH;
        dwSize = (dwBlockIndex == XDCS_Globals.dwBlockCount-1) ?
                                XDCS_Globals.dwLastBlockLength : XDCS_BLOCK_LENGTH;

        //Zero the buffers, so there is no memory of what was read in the past
        RtlZeroMemory(XDCS_Globals.Buffers[0].buffer, dwSize);
        RtlZeroMemory(XDCS_Globals.Buffers[1].buffer, dwSize);

        // Read the file into the first buffer
        SetFilePointer(hFile, dwOffset, NULL, FILE_BEGIN);
        if(ReadFile(hFile, XDCS_Globals.Buffers[0].buffer, dwSize, &dwBytesRead, NULL))
        {
            USBD_STATUS usbdStatus;
            //Read from the ROM into the second buffer.
            USB_BUILD_CONTROL_TRANSFER(
                &DEFAULT_URB.ControlTransfer,
                NULL,
                (PVOID)XDCS_Globals.Buffers[1].buffer,
                dwSize,
                USB_TRANSFER_DIRECTION_IN,
                NULL, //synchronous
                NULL,
                FALSE,
                USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
                XDCS_REQUEST_GET_ROM_FILE_BLOCK,
                (WORD)dwBlockIndex,
                (WORD)XDCS_Globals.CurrentDevice->bInterfaceNumber,
                (WORD)dwSize
                );
            usbdStatus = XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);
            //
            //  If the device read failed, break the loop
            //
            if(USBD_ERROR(usbdStatus))
            {
                fResult = FALSE;
                break;
            }
            //
            //  If a byte compare fails, mark it and break the loop.
            //
            if(dwSize != RtlCompareMemory(XDCS_Globals.Buffers[0].buffer, XDCS_Globals.Buffers[1].buffer, dwSize))
            {
                fResult = FALSE;
                break;
            }
        } else
        //
        //  If the read file failed, just break the loop
        //
        {
            fResult = FALSE;
            break;
        }
        //
        //  Update the percent complete
        //
        XDCS_Globals.LibraryInfo.dwPercentComplete = ((loop+1)*100)/XDCS_NUM_BLOCKS_TO_VERIFY;
    }
    
    //
    //  If we made it this far, we at least managed to open
    //  the file,  so close it now, before we do anything.
    //
    CloseHandle(hFile);
    
    //
    //  If we made to here and fResult is TRUE, then the device is OK,
    //  otherwise it failed somehwere.
    //
    if(fResult)
    {
        XDCS_ChangeStatus(XDCS_STATUS_ACCEPTED);
    } else
    {
        XDCS_ChangeStatus(XDCS_STATUS_REJECTED);
    }

    return fResult;
}

LOCALFUNC BOOL FASTCALL XDCS_fDownloadFile()
/*++
  Routine Description:

    Reads from the device and writes to disk.
--*/
{
    DWORD dwBufferIndex = 0;
    DWORD dwNextBlock = 0;
    DWORD dwWriteBytesCompleted = 0;
    DWORD dwReason;
    HANDLE hFile;
    PXDCS_DOWNLOAD_BUFFER pBuffer;
    BOOL  fDone = FALSE;
    BOOL  fSuccess = TRUE; //assume success, until failure
    DWORD dwOffset;
    DWORD dwSize;
    
    //  Open the file to write
    hFile = CreateFile( 
              XDCS_Globals.LibraryInfo.szName,
              GENERIC_WRITE,
              0,
              NULL,
              CREATE_ALWAYS,
              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN,
              NULL);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        XDCS_ChangeStatus(XDCS_STATUS_REJECTED);
        return FALSE;
    }

    // Use SetFilePointer and SetEndOfFile to presize the file
    SetFilePointer(hFile, XDCS_Globals.LibraryInfo.dwCodeLength, NULL, FILE_BEGIN);
    SetEndOfFile(hFile);
    
    //
    //  Place every buffer in the start state, and signal
    //  all the events.
    //
    for(dwBufferIndex=0; dwBufferIndex < XDCS_BUFFER_COUNT; dwBufferIndex++)
    {
        XDCS_Globals.Buffers[dwBufferIndex].dwStage = XDCS_BUFFER_START;
        SetEvent(XDCS_Globals.BufferEvents[dwBufferIndex]);
    }

    XDCS_INIT_STAGE_LOG();

    //
    //  Switch the status to verifying
    //  
    XDCS_Globals.LibraryInfo.dwPercentComplete = 0;
    XDCS_ChangeStatus(XDCS_STATUS_DOWNLOADING);

    //
    //  Loop until done
    //
    while(!fDone)
    {
        //Wait for any of the buffer events to fire
        dwReason = WaitForMultipleObjects(
                        XDCS_BUFFER_COUNT,
                        XDCS_Globals.BufferEvents,
                        FALSE,
                        200);

        //Check for a timeout error condition
        if(WAIT_TIMEOUT == dwReason)
        {
            USB_DBG_ERROR_PRINT(("XDCS_fDownloadFile: Timeout, suggests a device hang."));
            fSuccess = FALSE;
            break; //break out of the while loop
        }

        //Otherwise it must be one of the events, set the dwBufferIndex
        //based on which event fired.
        dwBufferIndex = dwReason - WAIT_OBJECT_0;
        ASSERT(dwBufferIndex < XDCS_BUFFER_COUNT);
        pBuffer = &XDCS_Globals.Buffers[dwBufferIndex];
        XDCS_LOG(dwBufferIndex);

        // How we handle the event condition depends on which
        // stage the buffer was at, so switch on the stage
        switch(pBuffer->dwStage)
        {
            default:
                ASSERT(FALSE);
                fSuccess = FALSE; //assume something failed
                fDone = TRUE; //break out of the while loop
                break; //break out of the switch
            case XDCS_BUFFER_FILE:
            // We just finished writing to file
              {
                DWORD dwBytesTransferred;
                fSuccess = GetOverlappedResult(
                               hFile,
                               &pBuffer->Overlapped,
                               &dwBytesTransferred,
                               TRUE);
                if(!fSuccess)
                {
                    USB_DBG_ERROR_PRINT(("XDCS_fDownloadFile: GetOverlappedResult failed with %d.", GetLastError()));
                    fDone = TRUE; //leave the while loop
                    break; //leave the switch statement
                }
                
                //
                //  Update bytes written and progress
                //
                dwWriteBytesCompleted += dwBytesTransferred;
                XDCS_Globals.LibraryInfo.dwPercentComplete = 
                    (100*dwWriteBytesCompleted)/XDCS_Globals.LibraryInfo.dwCodeLength;
                //if done, then break out of the switch statement
                if(dwWriteBytesCompleted == XDCS_Globals.LibraryInfo.dwCodeLength)
                {
                    fDone = TRUE;
                    break;
                }
              }
              //fall through to next case by design
            case XDCS_BUFFER_START:
              //Have not started using the buffer yet(this case), or
              //a file write completed and the buffer is free agains
              //(the case above fell through)

              // if there are remaining blocks to
              // process, build the URB and submit it
              if(dwNextBlock < XDCS_Globals.dwBlockCount)
              {
                
                USB_BUILD_CONTROL_TRANSFER(
                    &pBuffer->Urb.ControlTransfer,
                    NULL,
                    pBuffer->buffer,
                    XDCS_BLOCK_LENGTH,
                    USB_TRANSFER_DIRECTION_IN,
                    XDCS_SignalComplete, 
                    (PVOID)XDCS_Globals.BufferEvents[dwBufferIndex],
                    FALSE,
                    USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
                    XDCS_REQUEST_GET_ROM_FILE_BLOCK,
                    (WORD)dwNextBlock,
                    (WORD)XDCS_Globals.CurrentDevice->bInterfaceNumber,
                    (WORD)XDCS_BLOCK_LENGTH
                    );
                dwNextBlock++;
                pBuffer->dwStage = XDCS_BUFFER_DEVICE;
                XDCS_Globals.CurrentDevice->Device->SubmitRequest(&pBuffer->Urb);
              } else
              {
                pBuffer->dwStage = XDCS_BUFFER_DONE;
              }
              break;
            case XDCS_BUFFER_DEVICE:
              //Just completed reading into a buffer, let's write it out
              {
                //Calculate the offset (pulling it out of the original setup packet.
                dwOffset = pBuffer->Urb.ControlTransfer.SetupPacket.wValue * XDCS_BLOCK_LENGTH;
                //Pull the size out of the number of bytes actually read
                dwSize = pBuffer->Urb.ControlTransfer.TransferBufferLength;
                
                //Check the status of the URB
                if(USBD_ERROR(pBuffer->Urb.Header.Status))
                {
                    USB_DBG_ERROR_PRINT(("XDCS_fDownloadFile: Device read failed, with USBD_STATUS 0x%0.8x.",
                            pBuffer->Urb.Header.Status));
                    fSuccess= FALSE;
                    fDone = TRUE;
                    break;
                }
                //Now we are going to write to the OVERLAPPED structure, which effectively
                //destroys the URB.
                pBuffer->Overlapped.Offset = dwOffset;
                pBuffer->Overlapped.OffsetHigh = 0;
                pBuffer->Overlapped.hEvent = XDCS_Globals.BufferEvents[dwBufferIndex];
                pBuffer->dwStage = XDCS_BUFFER_FILE;
                if(!WriteFile(hFile, pBuffer->buffer, dwSize, NULL, &pBuffer->Overlapped))
                {
                    USB_DBG_WARN_PRINT(("XDCS_fDownloadFile: WriteFile failed with error %d.", GetLastError()));
                    fDone = TRUE;
                }
              }
              break;
        };
    }
    // Close the file handle
    CloseHandle(hFile);


    if(fSuccess)
    {
        XDCS_ChangeStatus(XDCS_STATUS_ACCEPTED);
    } else
    {
        XDCS_ChangeStatus(XDCS_STATUS_REJECTED);
    }
    return fSuccess;
}

VOID XDCS_SignalComplete(PURB, PVOID pEvent)
{
    HANDLE hEvent = (HANDLE)pEvent;
    SetEvent(hEvent);
}

LOCALFUNC VOID FASTCALL XDCS_fCreateBufferEvents()
{
    DWORD dwBufferIndex;
    //
    //  Initialize the buffers into their starting state.
    //
    for(dwBufferIndex=0; dwBufferIndex < XDCS_BUFFER_COUNT; dwBufferIndex++)
    {
        XDCS_Globals.BufferEvents[dwBufferIndex] = CreateEvent(NULL, FALSE, FALSE, NULL);
        ASSERT(XDCS_Globals.BufferEvents);
    }
}

LOCALFUNC DWORD FASTCALL XDCS_fRandomBlock(DWORD BlockCount)
/*++
  Routine Description:
    This is a specialized random number generater.  It uses the system time
    as a seed to get a random block number.  It is used by XDCS_fVerifyFile
    to choose the blocks to compare.
--*/
{
    LARGE_INTEGER systemTime;
    static ULONG seed = 0;

    //Get a seed if we do not already have one
    if(0==seed)
    {
        //Start with the system time.  The units are 100's of nanoseconds
        //since some published date.  However, it is only updated on timer
        //ticks that occur about every millisecond.
        KeQuerySystemTime(&systemTime);

        //Divide by 10000 (converting to milliseconds, means every digit is
        //significant.  Casting to long effectively takes the date mod about
        //a month.
        seed = (ULONG)(systemTime.QuadPart/10000); 
    }
    
    //The linear equation below, was copied out of some other code, copied
    //out of a book, etc.  It purportely takes a pretty good random seed
    //and can turn it into a pretty good random sequence.
    seed = 1664525 * seed + 1013904223;
    
    //Taking the mod ought to be OK since the range of our number is 
    //very small compared to the whole range (about 1 millionth)
    return (seed%BlockCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xid\xid.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.cpp

Abstract:
    
    Basic entry point implementation of the XID driver.
    
    
Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    02-21-00 created by Mitchell Dernis (mitchd)

--*/
#define XID_IMPLEMENTATION

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XID");

//
//  Pull in public usb headers
//
#include <usb.h>
//
//  Pull in xid headers
//
#include "xid.h"

//------------------------------------------------------------------------------
//  Declare XID's global variables.
//------------------------------------------------------------------------------
XID_GLOBALS XID_Globals;

//------------------------------------------------------------------------------
//  Forward declaration of locally defined functions
//------------------------------------------------------------------------------
VOID
XID_WatchdogTimerProc(
    PKDPC,
    PVOID,
    PVOID,
    PVOID
    );

VOID
XID_EnumStage1(
    PURB Urb,
    PXID_DEVICE_NODE XidNode
    );

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    );

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN UCHAR  Type,
    IN ULONG  Port
    );

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    );

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    );

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    );

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID XID_EnumLegacy1(PURB Urb, PXID_DEVICE_NODE XidNode);
//VOID XID_EnumLegacy2(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboard(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboardComplete(PURB Urb, PXID_DEVICE_NODE XidNode);
PXID_KEYBOARD_SERVICES XID_pKeyboardServices = NULL;

//------------------------------------------------------------------------------
//  Declare XID types and class.
//------------------------------------------------------------------------------
DECLARE_XPP_TYPE(XDEVICE_TYPE_GAMEPAD)
DECLARE_XPP_TYPE(XDEVICE_TYPE_DEBUG_KEYBOARD)
DECLARE_XPP_TYPE(XDEVICE_TYPE_IR_REMOTE)

#ifndef XDEVICE_TYPE_DEBUG_KEYBOARD
#define XDEVICE_TYPE_DEBUG_KEYBOARD (&XDEVICE_TYPE_DEBUG_KEYBOARD_TABLE)
#endif

USB_DEVICE_TYPE_TABLE_BEGIN(XID_)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_GAMEPAD),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_DEBUG_KEYBOARD),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_IR_REMOTE)
USB_DEVICE_TYPE_TABLE_END()

USB_CLASS_DRIVER_DECLARATION(XID_, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(XID_, 1, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)

#pragma data_seg(".XPP$ClassXID")
USB_CLASS_DECLARATION_POINTER(XID_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(XID_, 1)
#pragma data_seg(".XPP$Data")


USB_RESOURCE_REQUIREMENTS XID_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 0, 0, 1, 0, 2, 10, 0, 0, 0};

#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID XID_Init(IUsbInit *UsbInit)
/*++
    Routine Description:
        Called at boot.  Registers with usbpnp.sys.  Intializes
        globals.
--*/
{
    ULONG handleCount;
    ULONG index;
    //
    //  Verify that XOUTPUT_SIZE_OF_INTERNAL_HEADER is defined correctly
    //  in input.h
    //
    C_ASSERT(sizeof(XINPUT_FEEDBACK_HEADER_INTERNAL) == XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE);

    //Sentry to protect against double init.  This happens because we support XID and HID
    //class as the interface class.  This support is here to stay.
    static BOOL fInitialized = FALSE;
    if(fInitialized) return;
    fInitialized = TRUE;

    //
    //  Figure out how many nodes we need
    //
    XID_Globals.DeviceNodeCount = XGetPortCount()*XID_MAX_DEVICE_PER_PORT;

    //
    //  Based on the user's registration figure out how many handles we need.
    //
    
    if(!UsbInit->UseDefaultCount())
    {
        handleCount = XID_TypeInformationList[XID_DEVTYPE_GAMECONTROLLER].bRemainingHandles = 
                            UsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_GAMEPAD);
        
        RIP_ON_NOT_TRUE_WITH_MESSAGE(handleCount <= XGetPortCount(), "XInitDevices: requested more XDEVICE_TYPE_GAMEPAD than available ports.");

        handleCount +=
            XID_TypeInformationList[XID_DEVTYPE_KEYBOARD].bRemainingHandles = 
                UsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_DEBUG_KEYBOARD);
        RIP_ON_NOT_TRUE_WITH_MESSAGE(XID_TypeInformationList[XID_DEVTYPE_KEYBOARD].bRemainingHandles <= XGetPortCount(), 
                                                "XInitDevices: requested more XDEVICE_TYPE_DEBUG_KEYBOARD than available ports.");
        handleCount +=
            XID_TypeInformationList[XID_DEVTYPE_IRREMOTE].bRemainingHandles = 
                UsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_IR_REMOTE);
        RIP_ON_NOT_TRUE_WITH_MESSAGE(XID_TypeInformationList[XID_DEVTYPE_IRREMOTE].bRemainingHandles <= XGetPortCount(), 
                                                "XInitDevices: requested more XDEVICE_TYPE_IR_REMOTE than available ports.");
    } else
    {
        handleCount = XID_TypeInformationList[XID_DEVTYPE_GAMECONTROLLER].bRemainingHandles;
        handleCount += XID_TypeInformationList[XID_DEVTYPE_KEYBOARD].bRemainingHandles;
        handleCount += XID_TypeInformationList[XID_DEVTYPE_IRREMOTE].bRemainingHandles;
    }

    //
    //  This could happen, because some device types could be mutually
    //  exclusive, occupying the same slot.
    //
    if(handleCount > XID_Globals.DeviceNodeCount)
    {
        handleCount = XID_Globals.DeviceNodeCount;
    }

    //
    //  Allocate a block for device nodes and handles
    //  
    ULONG allocSize = sizeof(XID_DEVICE_NODE)*XID_Globals.DeviceNodeCount + sizeof(XID_OPEN_DEVICE)*handleCount;
    ULONG_PTR memory = (ULONG_PTR) RTL_ALLOCATE_HEAP(allocSize);
    ASSERT(memory);
    
    //
    //  Create a free list of handles
    //
    XID_Globals.DeviceHandles = NULL;
    PXID_OPEN_DEVICE openDevices = (PXID_OPEN_DEVICE) memory;
    for(index=0; index < handleCount; index++)
    {
        XID_FreeHandle(openDevices++);
    }

    //
    //  Initialize the open device nodes
    //
    XID_Globals.DeviceNodes = (PXID_DEVICE_NODE)openDevices;
    XID_Globals.DeviceNodeInUseCount = 0;
    for(index = 0; index < XID_Globals.DeviceNodeCount; index++)
    {
        XID_Globals.DeviceNodes[index].InUse = FALSE;
    }

    //
    //  Register our resources
    //
    XID_gResourceRequirements.MaxDevices = handleCount;
    UsbInit->RegisterResources(&XID_gResourceRequirements);

    //
    //  Initialize other globals.
    //
    KeInitializeTimer(&XID_Globals.EnumWatchdogTimer);
	return;
}
#pragma code_seg(".XPPCODE")

__inline void XID_SetEnumWatchdog()
/*++
    Routine Description:
        Called to start a 5 second watchdog timer on transfers
        during device enumeration.
--*/
{
    LARGE_INTEGER wait;
    wait.QuadPart = -50000000;
    KeSetTimer(&XID_Globals.EnumWatchdogTimer,wait,&XID_Globals.EnumWatchdogTimerDpc);
}

__inline void XID_ClearEnumWatchdog()
/*++
    Routine Description:
        Called to cancel a 5 second watchdog timer when a transfer during
        enumeration completes.
--*/
{
    KeCancelTimer(&XID_Globals.EnumWatchdogTimer);
}

VOID XID_WatchdogTimerProc(PKDPC, PVOID pvDevice, PVOID, PVOID)
/*++
    Routine Description:
        DPC routine called if a 5 second watchdog timer expires protecting
        asynchronous transfers during enumeration.  The routine forces completion
        of the URB by canceling it.  This will cause enumeration to fail,
        but avoids hanging USB device enumeration system wide.
--*/
{
    IUsbDevice *device = (IUsbDevice *)pvDevice;
    USB_DBG_ERROR_PRINT(("Enumeration Watchdog Timer has expired.\n"));
    device->CancelRequest(&XID_Globals.EnumUrb);
}

EXTERNUSB VOID
XID_AddDevice(
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
        This routine is registered as the AddDevice routine for new XID devices.
        It performs the following tasks:
            1) Allocates a XidNode from the static pool of nodes.
            2) Begins the XID enumeration provcess.
        Enumeration is continued in XID_EnumStage1.
--*/
{
    UCHAR                          nodeIndex = 0;
    PXID_DEVICE_NODE               xidNode;
    const USB_ENDPOINT_DESCRIPTOR *endpointDescriptor;
	        
    USB_DBG_ENTRY_PRINT(("Entering XID_AddDevice.\n"));
    if(XID_Globals.DeviceNodeInUseCount < XID_Globals.DeviceNodeCount)
    {
        //
        //  Find a free node, and claim it.
        //
        while(XID_Globals.DeviceNodes[nodeIndex].InUse) nodeIndex++;
        XID_Globals.DeviceNodeInUseCount++;
        XID_Globals.EnumNode = nodeIndex;
        xidNode = XID_Globals.DeviceNodes + nodeIndex;
		Device->SetExtension((PVOID)xidNode);
		xidNode->Device = Device;

        //
        //  Initialize what we can about the device.
        //
        xidNode->InUse = TRUE;
        xidNode->Ready = FALSE;
        xidNode->PendingRemove = FALSE;
        xidNode->Opened = FALSE;
        xidNode->InterfaceNumber = Device->GetInterfaceNumber();
        xidNode->OpenDevice = NULL;
        
    	//
		//	Get the interrupt-in endpoint descriptor  (NOT OPTIONAL).
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, TRUE, 0);
		ASSERT(endpointDescriptor);
        xidNode->EndpointAddressIn = endpointDescriptor->bEndpointAddress;
        xidNode->MaxPacketIn = (UCHAR)endpointDescriptor->wMaxPacketSize;
		
		//
		//	Get the interrupt-out endpoint (OPTIONAL)
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, FALSE, 0);
		if(endpointDescriptor)
		{
			xidNode->EndpointAddressOut = endpointDescriptor->bEndpointAddress;
			xidNode->MaxPacketOut = (UCHAR)endpointDescriptor->wMaxPacketSize;
		} else
		{
            xidNode->EndpointAddressOut = 0;
			xidNode->MaxPacketOut = 0;
		}
        //
        //  Get XID Descriptor
        //
        USB_BUILD_CONTROL_TRANSFER(
            (PURB_CONTROL_TRANSFER)&XID_Globals.EnumUrb,
            NULL, //Default endpoint
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(XID_DESCRIPTOR),
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_EnumStage1,
            (PVOID)xidNode,
            TRUE,
            (USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE),
            USB_REQUEST_GET_DESCRIPTOR,
            XID_DESCRIPTOR_TYPE,
            xidNode->InterfaceNumber,
            sizeof(XID_DESCRIPTOR)
            );
        //
        //  Reinitialize the watchdog DPC, so that the context is our device
        //
        KeInitializeDpc(&XID_Globals.EnumWatchdogTimerDpc, XID_WatchdogTimerProc, (PVOID)Device);
        XID_SetEnumWatchdog();
        Device->SubmitRequest(&XID_Globals.EnumUrb);
    }
    else
    {
        //
        //  Out of nodes so we cannot support the device
        //  (allow retry)
        //
        ASSERT(FALSE);
        Device->AddComplete(USBD_STATUS_NO_MEMORY);
    }
    USB_DBG_EXIT_PRINT(("Exiting XID_AddDevice.\n"));
}

VOID
XID_EnumStage1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
    Routine Description:
        Completion routine for obtaining the XID descriptor started
        in AddDevice.
        
        If retriving the XID_DESCRIPTOR failed,
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Getting the XID Descriptor may have failed.  This probably
    //  means it is a legacy device.
    //
    if(USBD_ERROR(Urb->Header.Status))
    {
        USB_DBG_EXIT_PRINT(("Couldn't get XID descriptor, could be a HID keyboard.\n"));
        XID_EnumLegacy1(Urb, XidNode);
        return;
    }

    //
    //  Copy the necessary info out of the Xid Descriptor
    //
    XidNode->Type = XID_Globals.EnumXidDescriptor.bType-1;
    XidNode->SubType = XID_Globals.EnumXidDescriptor.bSubType;
    XidNode->bMaxInputReportSize = XID_Globals.EnumXidDescriptor.bMaxInputReportSize;
    XidNode->bMaxOutputReportSize = XID_Globals.EnumXidDescriptor.bMaxOutputReportSize;
    
    //
    //  Check a number of items to determine if we can support the device.
    //      1) The type must be one known at compile time
    //      2) The report size must be at least as large as the XID_REPORT_HEADER.
    //      3) The maximum report size must not be larger than our buffer (XID_MAXIMUM_REPORT_SIZE)
    //         this is a limit on the extensibility of XID.
    //      4) For performance and resource management reasons we enforce that
    //         the entire report fit in a single interrupt-IN packet (there is
    //         no such requirement on the control pipe).
    //      5) Same for output, but only if interrupt OUT is supported.
    //
    if(
        (XID_DEVTYPE_COUNT <= XidNode->Type) ||
        (XID_REPORT_HEADER > XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XID_MAXIMUM_REPORT_SIZE < XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XidNode->bMaxInputReportSize > XidNode->MaxPacketIn) ||
        (XidNode->EndpointAddressOut && (XidNode->bMaxOutputReportSize > XidNode->MaxPacketOut))
    )
    {
        USB_DBG_WARN_PRINT(("Unsupported XID Device"));
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    	XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }

    //
    //  Set the class specific type and call AddComplete.
    //

    XidNode->Device->SetClassSpecificType(XidNode->Type);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}

EXTERNUSB VOID
XID_RemoveDevice(
    IUsbDevice *Device
    )
/*++
    Routine Description:
        Called by usbd when a device is removed.  It kicks off out
        remove sequence.
--*/
{
    PXID_DEVICE_NODE xidNode = (PXID_DEVICE_NODE)Device->GetExtension();
    ASSERT(NULL != xidNode);
    
	ASSERT_DISPATCH_LEVEL();
    //
    //  Mark the Node remove pending.
    //
    xidNode->PendingRemove = TRUE;
    //
    //  If there is an open handle
    //  kick off a close.
    //
    if(xidNode->OpenDevice)
    {
        //
        // Notify keyboard services of device removal.
        //
        #ifdef DEBUG_KEYBOARD
        if((XID_DEVTYPE_KEYBOARD==xidNode->Type) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnRemove(xidNode->OpenDevice);
        }
        #endif DEBUG_KEYBOARD
        XID_fCloseEndpoints(xidNode->OpenDevice);
    } else
    //
    //  Otherwise, we can wrap up the remove.
    //
    {
        XID_fRemoveDeviceComplete(xidNode);        
    }
}

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    )
/*++
    Routine Description:
        This routine is called by XID_DereferenceNode, when
        the reference count on a XID node goes to zero.
        At that time, it is certain that all open endpoints
        are closed, and all outstanding I/O is complete.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    //
    //  We are really done
    //
    USB_DBG_TRACE_PRINT(("Freeing node(0x%0.8x) nodeIndex = %d\n", XidNode, XidNode - XID_Globals.DeviceNodes));
    ASSERT(XidNode->PendingRemove);
	XidNode->Device->SetExtension(NULL);
	XidNode->Device->RemoveComplete();
	XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
    return;
}

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN UCHAR  Type,
    IN ULONG  Port
    )
/*++
    Routine Description:
        Finds a XID node that corresponds to the type and port (port includes port and slot).
        Will only return nodes that are ready to be open.
    Return Value:
        If a suitable node is found, it is returned.  Otherwise, NULL is returned.
    Environement:
        Assumes DISPATCH_LEVEL.
--*/
{
    UCHAR xidNodeIndex;
    PXID_DEVICE_NODE xidNode = NULL;
    //
    //  Brute force search of all the nodes.
    //
    for(xidNodeIndex = 0; xidNodeIndex < XID_Globals.DeviceNodeCount; xidNodeIndex++)
    {
        if(
            XID_Globals.DeviceNodes[xidNodeIndex].InUse &&
            (XID_Globals.DeviceNodes[xidNodeIndex].Device->GetPort() == Port) &&
            (XID_Globals.DeviceNodes[xidNodeIndex].Type == Type) &&
            XID_Globals.DeviceNodes[xidNodeIndex].Ready &&
            !XID_Globals.DeviceNodes[xidNodeIndex].PendingRemove
        ){
            xidNode =  XID_Globals.DeviceNodes + xidNodeIndex;
        }
    }
    return xidNode;
}

DWORD
FASTCALL
XID_fOpenDevice(
    UCHAR            XidType,
    ULONG            Port,
    PXID_OPEN_DEVICE *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Given a XidTy creates an OpenDevice,
    initializes the OpenDevice and opens
    the endpoints so the device can be used.
--*/
{
    
    USBD_STATUS         status;
    PXID_OPEN_DEVICE    openDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql;
    DWORD               errorCode = ERROR_SUCCESS;
    BOOL                partiallyOpen = FALSE;

    //
    // By default we want to return NULL.
    //
    *OpenDevice = NULL;

    //
    //  Must be done at high Irql
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Find the node
    //
    xidNode = XID_fFindNode(XidType, Port);
    if(!xidNode)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_open_device;
    }

    //
    //  Make sure that it is not already open
    //
    if(xidNode->OpenDevice)
    {
        errorCode = ERROR_SHARING_VIOLATION;
        goto exit_open_device;
    }

    
    if(0==XID_TypeInformationList[XidType].bRemainingHandles)
    {
        errorCode = ERROR_OUTOFMEMORY;
        goto exit_open_device;        
    }
    
    //
    //  Allocate memory for the device handle
    //
    
    XID_TypeInformationList[XidType].bRemainingHandles--;
    openDevice = XID_AllocateHandle();
    
    //
    //  Initialize the basic stuff
    //
    RtlZeroMemory(openDevice, sizeof(XID_OPEN_DEVICE));
    openDevice->XidNode = xidNode;
    openDevice->Type = XidType;
    openDevice->AutoPoll = PollingParameters->fAutoPoll ? TRUE : FALSE;
    
    //
    //  Tie the xidNode to our handle.
    //
    xidNode->OpenDevice = openDevice;

    //
    //  Any failure after here, requires closing the device.
    //
    partiallyOpen = TRUE;

    //
    //  Open the endpoints
    //

    status = XID_fOpenEndpoints(openDevice, PollingParameters);

    //
    //  If the endpoints were successfully opened
    //  then setup the initial state.
    //
    if(USBD_SUCCESS(status))
    {
        //
        //  Initialize the Report and the Report for URB
        //  with the default values;
        //
        RtlCopyMemory(
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            XID_TypeInformationList[xidNode->Type].pInputReportInfoList[0].pDefaultValues,
            XID_TypeInformationList[xidNode->Type].pInputReportInfoList[0].bCurrentSize
            );
        RtlCopyMemory(
            (PVOID)openDevice->Report,
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            sizeof(openDevice->Report)
            );

        //
        //  Initialize an event for synchronization
        //
        KEVENT   event;
        KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    
        //
        //  Build a control transfer
        //
        WORD wReportTypeAndId = 0x0100;
        ULONG ulBufferSize = xidNode->bMaxInputReportSize;
        USB_BUILD_CONTROL_TRANSFER(
            &openDevice->Urb.ControlTransfer,
            NULL, //Default endpoint
            openDevice->ReportForUrb,
            ulBufferSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_SyncComplete, //do it synchronously
            &event,  //the context is the event.
            TRUE,
            (USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_GET_REPORT,
            wReportTypeAndId, //Input report 0
            xidNode->InterfaceNumber,
            ulBufferSize
            );

        //
        //  Submit the request
        //
        xidNode->Device->SubmitRequest(&openDevice->Urb);
    
        //
        //  Lower IRQL, and wait for transfer to complete.
        //  Then restore Irql to DPC level
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  During the transfer the device may have been removed,
        //  if so we should check to make sure that the device is
        //  still with us.  There are two cases here: the device is
        //  totally gone, the device is still pending remove.
        //
    
        if(NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_open_device;
        } 

        //
        //  Process the GET_REPORT results, if it succeeded
        //
        if(USBD_SUCCESS(openDevice->Urb.Header.Status))
        {
            XID_TypeInformationList[xidNode->Type].pfnProcessNewData(openDevice);
        } 
#if DBG
        else
        //
        // Issue warning if GET_REPORT failed.
        //
	    { 
           if(USBD_STATUS_STALL_PID == openDevice->Urb.Header.Status)
           {
		       USB_DBG_WARN_PRINT(("Device in port %d (0 based) does not support GET_REPORT\n", Port));
           }
        }
#endif

        //
        // Notify keyboard services of new open device.
        //
        if((XID_DEVTYPE_KEYBOARD==openDevice->Type) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnOpen(openDevice);
        }

        //
        //  Prepare the URB for the interrupt-in endpoint.
        //
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)&openDevice->Urb,
            openDevice->InterruptInEndpointHandle,
            openDevice->ReportForUrb,
            xidNode->bMaxInputReportSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_NewInterruptData,
            (PVOID)openDevice,
            TRUE
            );

        //
        //  If autopoll is set, start polling
        //
        if(openDevice->AutoPoll)
        {
          xidNode->Device->SubmitRequest(&openDevice->Urb);
        }

        
        //
        //  If we are here, the device was successfully opened.
        //  copy the handle, and mark partiallyOpen as FALSE
        //  as we are now fully open.
        //
        *OpenDevice = openDevice;
        partiallyOpen = FALSE;
    }  else
    {
        errorCode = IUsbDevice::Win32FromUsbdStatus(status);
    }

exit_open_device:
    
    //
    //  Done with synchronization
    //
    KeLowerIrql(oldIrql);
    
    //
    //  Partially opened devices
    //  should be closed.
    //
    if(partiallyOpen)
    {
        XID_fCloseDevice(openDevice);
    }

    return errorCode;
}

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    IN PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Routine Description:
        Called from XID_OpenDevice to open the endpoints associated with the
        device.  Opening the endpoints references the XidNode until the endpoints
        are closed.
--*/
{
    
    USBD_STATUS status = USBD_STATUS_SUCCESS;
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  Open the control endpoint
    //
    
    USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&OpenDevice->Urb);
    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    
    //
    //  If the control endpoint is open,
    //  open the interrupt in endpoint.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->ControlEndpointOpen = TRUE;
        USB_BUILD_OPEN_ENDPOINT(
        (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
        xidNode->EndpointAddressIn,
        USB_ENDPOINT_TYPE_INTERRUPT,
        (USHORT)XID_MAXIMUM_REPORT_SIZE,
        PollingParameters->bInputInterval
        );
        status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    }

    //
    //  If interrupt-IN endpoint opened, save the handle
    //  and try to open the interrupt out, if there is
    //  one.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->InterruptInEndpointHandle = OpenDevice->Urb.OpenEndpoint.EndpointHandle;
        ASSERT(OpenDevice->InterruptInEndpointHandle);
        if(PollingParameters->fInterruptOut && xidNode->EndpointAddressOut)
        {
            USB_BUILD_OPEN_ENDPOINT(
                (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
                xidNode->EndpointAddressOut,
                USB_ENDPOINT_TYPE_INTERRUPT,
                (USHORT)XID_MAXIMUM_REPORT_SIZE,
                PollingParameters->bOutputInterval
                );
		    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
        
            if(USBD_SUCCESS(status))
            {
                OpenDevice->InterruptOutEndpointHandle = 
                        OpenDevice->Urb.OpenEndpoint.EndpointHandle;
                ASSERT(OpenDevice->InterruptOutEndpointHandle);
            }
        }
    }

    //
    //  return the status
    //
    return status;
}


VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    )
/*++
   Routine Description:
        Closes an open or paritally open device.
        Always does the right thing.

        This routine assumes that OpenDevice is valid.
--*/
{
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  If we are still attached to 
    //  a xidnode, then we need to close the
    //  endpoints.
    //
    if(OpenDevice->XidNode)
    {
        //
        // Notify keyboard services of device closing.
        //
        #ifdef DEBUG_KEYBOARD
        if((XID_DEVTYPE_KEYBOARD==OpenDevice->Type) && XID_pKeyboardServices)
        {
           XID_pKeyboardServices->pfnClose(OpenDevice);
        }
        #endif DEBUG_KEYBOARD

        //
        //  Setup event to synchronize close
        //
        KEVENT event;
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        OpenDevice->CloseEvent = &event;
        
        //
        //  Mark close pending as true
        //
        OpenDevice->ClosePending = TRUE;

        //
        //  Kick off close endpoint state
        //  machine.
        //
        XID_fCloseEndpoints(OpenDevice);

        //
        //  Wait for close endpoint state machine
        //  to do its job.
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    } else
    {
        KeLowerIrql(oldIrql);
    }

    //
    //  Everything is cleaned up, just free the memory.
    //
    XID_TypeInformationList[OpenDevice->Type].bRemainingHandles++;
    XID_FreeHandle(OpenDevice);
}


VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
    Routine Description:
        This routine closes the endpoints associated with an OpenDevice handle.
--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Guard against rentry
    //
    if(OpenDevice->EndpointsPendingClose)
    {
        return; 
    }

    // kill the Alamo DPC timer, if it is running
    #ifdef  ALAMO_RAW_DATA_HACK
    if(OpenDevice->XidNode->AlamoHack) KeCancelTimer(&OpenDevice->AlamoPollTimer);
    #endif  //ALAMO_RAW_DATA_HACK


    OpenDevice->EndpointsPendingClose = TRUE;

    //
    //  Start endpoint state machine.
    //

    XID_CloseEndpointStateMachine(&OpenDevice->CloseUrb, OpenDevice);
}

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    )
{
    
    IUsbDevice *device = OpenDevice->XidNode->Device;

    //
    // If the control endpoint is open
    // build an URB to close it.
    //
    if(OpenDevice->ControlEndpointOpen)
    {
        //
        //  Close the default endpoint
        //
        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
                        CloseUrb,
                        (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
                        (PVOID)OpenDevice
                        );
        OpenDevice->ControlEndpointOpen = FALSE;
    } else if(OpenDevice->InterruptInEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptInEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptInEndpointHandle = NULL;
    } else if(OpenDevice->InterruptOutEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptOutEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptOutEndpointHandle = NULL;
    } else
    //
    //  Everything is closed, handle the reason
    //  we close the endpoints (either pending close
    //  or pending remove).
    //
    {
        PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;
        //
        //  We should only be here if either a close pending
        //  or if a remove is pending.
        //
        ASSERT(OpenDevice->ClosePending || xidNode->PendingRemove);

        //
        //  In either case, we need to sever the xidNode
        //  and the openDevice.
        //
        xidNode->OpenDevice = NULL;
        OpenDevice->XidNode = NULL;

        //
        //  If there is a pending remove,
        //  we need to call remove complete.
        //
        if(xidNode->PendingRemove)
        {
            XID_fRemoveDeviceComplete(xidNode);
        }

        //
        //  If there is a pending close,
        //  signal the close event.
        //
        if(OpenDevice->ClosePending)
        {
            //
            //  Signal the close event
            //
            ASSERT(OpenDevice->CloseEvent);
            KeSetEvent(OpenDevice->CloseEvent, IO_NO_INCREMENT, FALSE);
        }

        return;
    }
   
    //
    //  submit the next request
    //
    device->SubmitRequest((PURB)CloseUrb);
}
   

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for new input data.

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        So we can safely process the I/O.  However,
        before resubmitting any I/O requests, we
        should verify that a close or remove is not
        pending.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  If the device has been closed or is pending
    //  remove, there is nothing to do.
    //
    if(OpenDevice->ClosePending || xidNode->PendingRemove)
    {
        return;  
    }

    //
    //  If the URB was completed successfully, then
    //  process the data.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
        //
        //  Debug only check that the device is not returning short packets
        //
        #if DBG
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength < xidNode->bMaxInputReportSize)
        {
            USB_DBG_TRACE_PRINT(("An input device returned a short packet(expected %d, received %d).",
                xidNode->bMaxInputReportSize,
                Urb->BulkOrInterruptTransfer.TransferBufferLength
                ));
        }
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength > xidNode->bMaxInputReportSize)
        {
            USB_DBG_ERROR_PRINT(("Packet came back larger than maximum allowed."));
            Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        }
        #endif

        //
        //  Process the new data
        //
        XID_TypeInformationList[xidNode->Type].pfnProcessNewData(OpenDevice);
        
        OpenDevice->PacketNumber++;
        OpenDevice->OutstandingPoll = 0;
        
        //
        //  Resubmit the URB if autopoll, reset the transfer
        //  length, in case the last transfer came up short.
        //
        Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        
        //
        //  If this is not an auto-poll device, we are done
        //
        if(!OpenDevice->AutoPoll)
        {
            return;
        }
    } else
    {
        //
        //  Print out the error.
        //
        #if DBG
        if(
            (USBD_STATUS_CANCELED != Urb->Header.Status) &&
            (USBD_ISOCH_STATUS_DEV_NOT_RESPONDING != Urb->Header.Status) //99% of the time indicates device is gone
        )
        {
            USB_DBG_WARN_PRINT(("An input device poll failed. Status = 0x%0.8x\n", Urb->Header.Status));
        }
        #endif
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
                (PURB_CONTROL_TRANSFER)Urb,
                USB_COMMAND_TO_ENDPOINT,
                USB_FEATURE_ENDPOINT_STALL,
                xidNode->EndpointAddressIn,
                (PURB_COMPLETE_PROC)XID_ClearInputStallComplete,
                OpenDevice
                );
    }
    
    //
    //  Resubmit the URB
    //
    xidNode->Device->SubmitRequest(Urb);
}

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    USBD_STATUS         status;
    
    //
    //  Don't do anything if a remove or close is pending.
    //
    if(xidNode->PendingRemove || OpenDevice->ClosePending)
    {
        return;
    }
    //
    //  If the CLEAR_FEATURE succeeded,
    //  reset the endpoint state, and try to resubmit
    //  the I/O.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
	    //
        //  Build URB to reset the endpoint state
        //
        USB_BUILD_SET_ENDPOINT_STATE( 
            (PURB_GET_SET_ENDPOINT_STATE)Urb,
            OpenDevice->InterruptInEndpointHandle,
            USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
            );
	    status = xidNode->Device->SubmitRequest(Urb);
        ASSERT(USBD_SUCCESS(status));

        USB_DBG_WARN_PRINT(("Reset endpoint, resume polling.\n"));
	    //
        //  Build URB to resume polling
        //
        #ifdef ALAMO_RAW_DATA_HACK
        if(xidNode->AlamoHack) XID_AlamoStartPoll(OpenDevice);
        else {
        #endif

        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                    (PURB_BULK_OR_INTERRUPT_TRANSFER)&OpenDevice->Urb,
                    OpenDevice->InterruptInEndpointHandle,
                    OpenDevice->ReportForUrb,
                    xidNode->bMaxInputReportSize,
                    USB_TRANSFER_DIRECTION_IN,
                    (PURB_COMPLETE_PROC)XID_NewInterruptData,
                    (PVOID)OpenDevice,
                    TRUE
                    );
	    xidNode->Device->SubmitRequest(Urb);
        #ifdef ALAMO_RAW_DATA_HACK
        }
        #endif

    }  else
    {
        USB_DBG_WARN_PRINT(("Failed to clear halt. Report device as not responding.  Status = 0x%0.8x\n", Urb->Header.Status));
        xidNode->Device->DeviceNotResponding();
    }
}

void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Processing of gamepad data.  Basically, it copies the data
   from the buffer that is ping-ponged to the hardware, to the one
   that is always available for copying from XInputGetState.

   Then it checks to see if anything changes and hits XAutoPowerDownResetTimer
--*/
{
    XINPUT_GAMEPAD *pGamePad = (XINPUT_GAMEPAD *)OpenDevice->Report;
    if(OpenDevice->Urb.CommonTransfer.TransferBufferLength >= XID_REPORT_HEADER)
    {
        RtlCopyMemory(
          (PVOID)pGamePad,
          (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
          OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
          );

        //
        //  XAutoPowerDownResetTimer if necessary, too much jitter the thumbsticks
        //  means we check all the other controls to see if any of them are pressed.
        //
        if(
            pGamePad->wButtons& (XINPUT_GAMEPAD_DPAD_UP|XINPUT_GAMEPAD_DPAD_DOWN|XINPUT_GAMEPAD_DPAD_LEFT|
                                 XINPUT_GAMEPAD_DPAD_RIGHT|XINPUT_GAMEPAD_START|XINPUT_GAMEPAD_BACK)
          )
        {
            XAutoPowerDownResetTimer();
        } else
        {
            for(int i = XINPUT_GAMEPAD_A; i <= XINPUT_GAMEPAD_RIGHT_TRIGGER; i++)
            {
                if(pGamePad->bAnalogButtons[i])
                {
                  XAutoPowerDownResetTimer();
                  break;
                }
            }
        }

    }
}

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   IRREM XID processing of new data.  Copies the data
   from the buffer that is ping-ponged to the hardware, 
   then it hits XAutoPowerDownResetTimer.
--*/
{
    RtlCopyMemory(
        (PVOID)OpenDevice->Report,
        (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
        OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
        );
    XAutoPowerDownResetTimer();
}

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Keyboard processing is slightly different.  It doesn't have a XID_REPORT_HEADER
--*/
{
  RtlCopyMemory(OpenDevice->Report, OpenDevice->ReportForUrb, sizeof(XINPUT_KEYBOARD));
  if(XID_pKeyboardServices)
  {
    XID_pKeyboardServices->pfnNewData((PVOID)OpenDevice, (PXINPUT_KEYBOARD)OpenDevice->Report);
    XAutoPowerDownResetTimer();
  }
}

DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL  OutputReport
        )
{
    PVOID               rawOutputBuffer;
    USBD_STATUS         usbStatus;
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Check to make sure the device has not been removed
    //
    if(NULL==xidNode || xidNode->PendingRemove)
    {
        OutputReport->dwStatus = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_send_device_report;
    }
    //
    //  If bMaxOutputReportSize is zero, the device doesn't support output.
    //
    if(0 == xidNode->bMaxOutputReportSize)
    {
        OutputReport->dwStatus = ERROR_NOT_SUPPORTED;
        goto exit_send_device_report;
    }

    //
    //  Increase the reference count on the completion event
    //  if there is one.
    //
    if(OutputReport->hEvent)
    {
        NTSTATUS status = ObReferenceObjectByHandle(
                            OutputReport->hEvent,
                            ExEventObjectType,
                            (PHANDLE)&OutputReport->Internal.CompletionEvent
                            );
        //
        //  If the following assertion fails the event handle is invalid.
        //  This does not prevent the I/O, but we cannot set the event.
        //  We assert, and NULL out both the hEvent and the pointer
        //  we would have obtained from ObReferenceObjectByHandle
        //
        //ASSERT(NT_SUCCESS(status));
        if(!NT_SUCCESS(status))
        {
            USB_DBG_ERROR_PRINT(("ERROR: pFeedback->Header.hEvent (0x%0.8x) is invalid.\n"
                                 "hEvent should be NULL or a valid Event handle.\n"
                                 "Event cannot be signaled at completion.\n", OutputReport->hEvent));
            OutputReport->hEvent = NULL;
            OutputReport->Internal.CompletionEvent = NULL;    
        }
    } else
    {
        OutputReport->Internal.CompletionEvent = NULL;
    }

    //
    //  Constrain the size if needed.
    //
    if(xidNode->bMaxOutputReportSize < OutputReport->Internal.bSize)
    {
        OutputReport->Internal.bSize = xidNode->bMaxOutputReportSize;
    }

    //
    //  Legacy devices (notably keyboard) does not have a XID_REPORT_HEADER.
    //
    if(XID_TypeInformationList[xidNode->Type].ulFlags&XID_BSF_NO_OUTPUT_HEADER)
    {
        rawOutputBuffer = (PVOID)(&OutputReport->Internal.bReportId + XID_REPORT_HEADER);
    } else
    //
    //  Otherwise rawBuffer starts at the bReportId of the internal header
    //
    {
        rawOutputBuffer = (PVOID)&OutputReport->Internal.bReportId;
    }

    //
    //  Build the URB  (use the interrupt Out pipe if there is
    //  one, otherwise use the default pipe with SET_REPORT).
    //
    if(OpenDevice->InterruptOutEndpointHandle)
    {
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                &OutputReport->Internal.Urb.BulkOrInterruptTransfer,
                OpenDevice->InterruptOutEndpointHandle,
                rawOutputBuffer,
                OutputReport->Internal.bSize,
                USB_TRANSFER_DIRECTION_OUT,
                (PURB_COMPLETE_PROC)XID_OutputComplete,
                (PVOID)OutputReport,
                FALSE
                );
    } else
    {
        USB_BUILD_CONTROL_TRANSFER(
            &OutputReport->Internal.Urb.ControlTransfer,
            NULL,
            rawOutputBuffer,
            OutputReport->Internal.bSize,
            USB_TRANSFER_DIRECTION_OUT,
            (PURB_COMPLETE_PROC)XID_OutputComplete,
            (PVOID)OutputReport,
            FALSE,
            (USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_SET_REPORT,
            0x0200 | OutputReport->Internal.bReportId,
            xidNode->InterfaceNumber,
            (WORD)OutputReport->Internal.bSize
            );
    }

    //
    //  Submit the request
    //
    OutputReport->Internal.OpenDevice = OpenDevice;
    usbStatus = xidNode->Device->SubmitRequest(&OutputReport->Internal.Urb);
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(usbStatus);

exit_send_device_report:
    
    KeLowerIrql(oldIrql);
    return OutputReport->dwStatus;
}

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check to see if the device has been removed
    //
    PXID_OPEN_DEVICE openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE xidNode = openDevice->XidNode;

    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    }
    
    //
    //  If the interrupt-Out endpoint is stalled we have to clear the stall,
    //  prior to copying the status and signalling an event.
    //
    if(
        (Urb->Header.Status == USBD_STATUS_STALL_PID) &&
        (Urb->Header.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
        )
    {
        //
        //  Print out the error.
        //
        USB_DBG_WARN_PRINT(("The interrupt-Out endpoint stalled, reseting.\n", Urb->Header.Status));
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
            (PURB_CONTROL_TRANSFER)Urb,
            USB_COMMAND_TO_ENDPOINT,
            USB_FEATURE_ENDPOINT_STALL,
            xidNode->EndpointAddressOut,
            (PURB_COMPLETE_PROC)XID_ClearOutputStallComplete,
            OutputReport
            );
        //
        //  Submit the request to clean the stall.
        //
        xidNode->Device->SubmitRequest(Urb);
    } else
    //
    //  If the endpoint is not stalled (or it was a control endpoint which does not need clearing)
    //  go ahead and complete the output.
    //
    {
        XID_fOutputComplete1(Urb, OutputReport);
    }
}

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
{
    PKEVENT event = OutputReport->Internal.CompletionEvent;

    //
    //  Copy and convert the status.
    //
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(Urb->Header.Status);

    //
    //  If the call provided a completion event, set it
    //  and then dereference it.
    //  
    if(event)
    {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
        ObDereferenceObject(event);
    }
}


VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_OPEN_DEVICE    openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE    xidNode = openDevice->XidNode;
    USBD_STATUS         status = Urb->Header.Status;
    
    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    } else 
    {
        if(USBD_SUCCESS(status))
        {
            //
            //  Build and submit URB to reset the endpoint state
            //
            USB_BUILD_SET_ENDPOINT_STATE( 
                (PURB_GET_SET_ENDPOINT_STATE)Urb,
                openDevice->InterruptOutEndpointHandle,
                USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
                );
	        xidNode->Device->SubmitRequest(Urb);
        } else
        {
            USB_DBG_ERROR_PRINT(("Attempt to clear endpoint stall result in status: 0x%0.8x.\n", status));
        }
        Urb->Header.Status = USBD_STATUS_STALL_PID;
    }    
   
    XID_fOutputComplete1(Urb, OutputReport);
}

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    )
//
//  Used to make an asyncronous call, synchronous.
//
{
    KeSetEvent(SyncEvent, IO_NO_INCREMENT, FALSE);
}


//****
//****  Legacy Hardware Enumeration (right now the 
//****  Microsoft Natrual Keyboard Pro is the only supported
//****  legacy device).  Use of this device is limited for
//****  use as a development aid.  However, this is a policy
//****  decision, not a technical one.  Basically, we
//****  will always enumerate  a Natural Keyboard Pro,
//****  however several required methods for using it
//****  require lining xdbg.lib, which is not allowed for
//****  shipping titles.
//****  

#define VID_MICROSOFT               0x045E
#define PID_NATURAL_KEYBOARD_PRO    0x001D

VOID
XID_EnumLegacy1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Gets the full device descriptor.  The gives us access to the
    VID and PID so we can support a particular device.

  Comment:
    The commented out code below allows the support of any known
    protocol device (i.e. any boot keyboard).  This was scratched
    and replaced with VID\PID detection of the Microsoft
    Natural Keyboard Pro just for support reasons.  The other code
    should work on a wide variety of keyboards.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy1.\n"));
    
    //
    //  First see if it is a known protocol device. (a.k.a. keyboard or
    //  mouse, but we don't support mouse at this point)
    //
    const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
    interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
    if(
        (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
        (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
    )
    {   
        //
        //  Switch to the boot protcol
        //
        
        USB_BUILD_CONTROL_TRANSFER(
            &XID_Globals.EnumUrb.ControlTransfer,
            NULL,
            NULL,
            0,
            0,
            (PURB_COMPLETE_PROC)XID_EnumKeyboard,
            (PVOID)XidNode,
            TRUE,
            USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
            HID_SET_PROTOCOL,
            HID_BOOT_PROTOCOL,
            XidNode->InterfaceNumber,
            0);

    }
#if NEVER
    //
    //  Check for legacy devices that we support via the VID\PID\FW,
    //  currently there are none, so this if #if NEVER.
    else
    {
        //
        //  Get the full device descriptor.
        //  The core driver never bothers to get
        //  more than the first 8 bytes.
        //
        USB_BUILD_GET_DESCRIPTOR(
            &XID_Globals.EnumUrb.ControlTransfer,
            USB_DEVICE_DESCRIPTOR_TYPE,
            0,
            0,
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(USB_DEVICE_DESCRIPTOR),
            (PURB_COMPLETE_PROC)XID_EnumLegacy2,
            (PVOID)XidNode
            );
    }
#else
    else
    {
        //
        //  The device is not supported, free the node.
        //
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }
#endif

    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

#if NEVER
//
//  This routine process enumeration of devices based on VID\PID, currently
//  we have none, so the routine is #if NEVER
//
VOID
XID_EnumLegacy2(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Completion routine for XID_EnumLegacy1.  At this point we can check the
    VID PID and decide whether or not to support the device.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy2.\n"));
    XID_ClearEnumWatchdog();
    
    //
    //  Check for legacy devices that we support
    //

    //
    //  Natural Keyboard Pro Support (NOT NEEDED, it is a standard boot keyboard)
    //  left as an example of what to do.
    //
    if(
        (VID_MICROSOFT == XID_Globals.EnumDeviceDescriptor.idVendor) &&
        (PID_NATURAL_KEYBOARD_PRO == XID_Globals.EnumDeviceDescriptor.idProduct)
    )
    {
        const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
        interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
        //
        //  Only the keyboard interface of this is device is supported
        //  (it has more than one interface)
        if(
            (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
            (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
        )
        {
            //
            //  Switch to the boot protcol
            //
            USB_BUILD_CONTROL_TRANSFER(
                &Urb->ControlTransfer,
                NULL,
                NULL,
                0,
                0,
                (PURB_COMPLETE_PROC)XID_EnumKeyboard,
                (PVOID)XidNode,
                TRUE,
                USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                HID_SET_PROTOCOL,
                HID_BOOT_PROTOCOL,
                XidNode->InterfaceNumber,
                0);
                XID_SetEnumWatchdog();
	            XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
            //
            //  Keyboard has more enum steps
            //
            return;
        }
    }

    //
    //  IF the device is not supported, free the node.
    //
    XidNode->Device->SetExtension(NULL);
    XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
}
#endif

VOID
XID_EnumKeyboard(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    After a keyboard is found there are still more steps.  In particular,
    we must switch to the boot protocol.  XID_EnumLegacy2 did that, and this
    is the completion routine.

    Now we must set the idle rate to infinite.  Infinite should be the default
    for boot protocol keyboards, but this is for good measure.
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Switch the idle rate to infinite
    //
    USB_BUILD_CONTROL_TRANSFER(
        &XID_Globals.EnumUrb.ControlTransfer,
        NULL,
        NULL,
        0,
        0,
        (PURB_COMPLETE_PROC)XID_EnumKeyboardComplete,
        (PVOID)XidNode,
        TRUE,
        USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
        HID_SET_IDLE,
        HID_IDLE_INFINITE,
        XidNode->InterfaceNumber,
        0);
    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

VOID
XID_EnumKeyboardComplete(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    We are done with enumeration steps for enumerating a keyboard
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumKeyboardComplete.\n"));
    XID_ClearEnumWatchdog();
    XidNode->Type = XID_DEVTYPE_KEYBOARD;
    XidNode->SubType = XINPUT_DEVSUBTYPE_KBD_STANDARD;
    XidNode->bMaxInputReportSize = sizeof(XINPUT_KEYBOARD);
    XidNode->bMaxOutputReportSize = sizeof(XINPUT_KEYBOARD_LEDS);
    XidNode->Device->SetClassSpecificType(XidNode->Type);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xid\xid.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.h

Abstract:

    Structures and functions used through the XID driver.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    02-22-00 created by Mitchell Dernis (mitchd)

--*/

#ifndef __XID_H__
#define __XID_H__

//-----------------------------------------------
// Byte align all the structures
//-----------------------------------------------
#include <PSHPACK1.H>

//------------------------------------------------------------
// Define pointers to the various types declared in this file.
// This breaks some declaration order dependencies.
//------------------------------------------------------------
typedef struct _XID_TYPE_INFORMATION    *PXID_TYPE_INFORMATION;
typedef struct _XID_DESCRIPTOR          *PXID_DESCRIPTOR;
typedef struct _XID_DEVICE_NODE         *PXID_DEVICE_NODE;
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL *PXINPUT_FEEDBACK_HEADER_INTERNAL;
typedef struct _XINPUT_FEEDBACK_INTERNAL *PXINPUT_FEEDBACK_INTERNAL;
typedef struct _XID_OPEN_DEVICE         *PXID_OPEN_DEVICE;
typedef struct _XID_GLOBALS             *PXID_GLOBALS;

//-----------------------------------------------
// Constants for legacy devices - keyboards
//-----------------------------------------------
#define HID_KEYBOARD_PROTOCOL 0x01
#define HID_SET_PROTOCOL      0x0B
#define HID_BOOT_PROTOCOL     0x00
#define HID_SET_IDLE          0x0A
#define HID_IDLE_INFINITE     0x00

//--------------------------------------------------
//  XINPUT_KEYBOARD is not defined in public headers
//  since we ripped out low-level support
//--------------------------------------------------
typedef struct _XINPUT_KEYBOARD
{
    BYTE Modifiers;
    BYTE Reserved;
    BYTE Keys[6];
} XINPUT_KEYBOARD, *PXINPUT_KEYBOARD;
typedef struct _XINPUT_KEYBOARD_LEDS
{
    BYTE LedStates;
} XINPUT_KEYBOARD_LEDS, *PXINPUT_KEYBOARD_LEDS;

//-----------------------------------------------
// Constants defined in the XID specification
//-----------------------------------------------
#define XID_COMMAND_GET_CAPABILITIES    0x01
#define XID_COMMAND_GET_REPORT          0x01
#define XID_COMMAND_SET_REPORT          0x09
#define XID_MAXIMUM_REPORT_SIZE         32
#define XID_DESCRIPTOR_TYPE             0x4200
#define XID_REPORT_TYPE_INPUT           0x01
#define XID_REPORT_TYPE_OUTPUT          0x02
#define XID_IS_INPUT_REPORT(wReportId)  ((wReportId >> 8) == XID_REPORT_TYPE_INPUT)
#define XID_GET_REPORT_ID(wReportId)    (wReportId&0xFF)
#define XID_REPORT_HEADER               0x02 //The Report ID and Size is the header.

//------------------------------------------------
// Private constants related to device types and
// and subtypes.
//------------------------------------------------
#define  XID_DEVTYPE_COUNT                3

//Game Controllers
#define  XID_DEVTYPE_GAMECONTROLLER        0
#define  XID_DEVSUBTYPE_MAX_GAME           1
#define  XID_INPUT_REPORT_ID_MAX_GAME      0
#define  XID_OUTPUT_REPORT_ID_MAX_GAME     0

//Keyboard
#define  XID_DEVTYPE_KEYBOARD              1
#define  XID_DEVSUBTYPE_MAX_KEYBOARD       1
#define  XID_INPUT_REPORT_ID_MAX_KEYBOARD  0
#define  XID_OUTPUT_REPORT_ID_MAX_KEYBOARD 0

//IR Remote
#define  XID_DEVTYPE_IRREMOTE              2
#define  XID_DEVSUBTYPE_MAX_IRREMOTE       1
#define  XID_INPUT_REPORT_ID_MAX_IRREMOTE  0
#define  XID_OUTPUT_REPORT_ID_MAX_IRREMOTE 0

//  Right now we have a device that plugs directly into the box,
//  So it is only physically possible to have two devices per port.
//  If we add a high power device, this should be two.
//  If we add a low power device, this should be three.
//
#define XID_MAX_DEVICE_PER_PORT           1

//-----------------------------------------------------------------------
// Structures for the device information table
//-----------------------------------------------------------------------
typedef void (FASTCALL *PFN_PROCESS_NEWDATA)(PXID_OPEN_DEVICE OpenDevice);

typedef struct _XID_REPORT_TYPE_INFO
{
    BYTE    bCurrentSize;   //Not including bReportId and bSize
    PVOID   pDefaultValues;
} XID_REPORT_TYPE_INFO, *PXID_REPORT_TYPE_INFO;

typedef struct _XID_TYPE_INFORMATION
{
    BYTE                       bRemainingHandles;
    BYTE                       bMaxSubType;
    BYTE                       bMaxInputReportId;
    BYTE                       bMaxOutputReportId;
    PXID_REPORT_TYPE_INFO      pInputReportInfoList;
    PXID_REPORT_TYPE_INFO      pOutputReportInfoList;
    PXINPUT_POLLING_PARAMETERS DefaultPollingParameters;
    PFN_PROCESS_NEWDATA        pfnProcessNewData;
    ULONG                      ulFlags;
} XID_TYPE_INFORMATION;
#define XID_BSF_NO_CAPABILITIES  0x00000001
#define XID_BSF_NO_OUTPUT_HEADER 0x00000002

//----------------------------------------------------------------------
//  Declare the table for the type information.
//----------------------------------------------------------------------
extern XID_TYPE_INFORMATION XID_TypeInformationList[XID_DEVTYPE_COUNT];

//----------------------------------------------------------------------
//  This the XID Descriptor has defined in the XID Specification
//----------------------------------------------------------------------
typedef struct _XID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdXid;
    UCHAR   bType;
    UCHAR   bSubType;
    UCHAR   bMaxInputReportSize;
    UCHAR   bMaxOutputReportSize;
    USHORT  wAlternateProductIds[4];
} XID_DESCRIPTOR; 

//----------------------------------------------------------------------
//  Service Table For Extended Keyboard API
//    In order to separate the extended keyboard API from the core
//    Xbox API, the extended API registers itself with a pointer to
//    this Service Table.
//----------------------------------------------------------------------
typedef void (*PFNKEYBOARD_OPENED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_CLOSED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_REMOVED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_NEWDATA)(HANDLE hDevice, XINPUT_KEYBOARD *pPacket);
typedef struct _XID_KEYBOARD_SERVICES
{
    PFNKEYBOARD_OPENED   pfnOpen;
    PFNKEYBOARD_CLOSED   pfnClose;
    PFNKEYBOARD_REMOVED  pfnRemove;
    PFNKEYBOARD_NEWDATA  pfnNewData;
} XID_KEYBOARD_SERVICES, *PXID_KEYBOARD_SERVICES;
extern PXID_KEYBOARD_SERVICES XID_pKeyboardServices;

//----------------------------------------------------------------------
//  This structure represents a device node.
//----------------------------------------------------------------------
typedef struct _XID_DEVICE_NODE
{
    IUsbDevice              *Device;
       
    UCHAR                   InUse:1;
    UCHAR                   PendingRemove:1;
    UCHAR                   Opened:1;
    UCHAR                   Ready:1;
    UCHAR                   Padding:4;
    UCHAR                   InterfaceNumber;
    UCHAR                   MaxPacketIn;        //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   MaxPacketOut;       //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   EndpointAddressIn;
    UCHAR                   EndpointAddressOut;
    UCHAR                   Type;
    UCHAR                   SubType;
    UCHAR                   bMaxInputReportSize;
    UCHAR                   bMaxOutputReportSize;
    PXID_OPEN_DEVICE        OpenDevice;
} XID_DEVICE_NODE;
#define XID_INVALID_NODE_INDEX  0xFF

//----------------------------------------------------------------------
//  Structures for output.  These are the internal equivalent
//  of XOUTPUT_HEADER and XOUTPUT_REPORT.
//----------------------------------------------------------------------
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL
{
    PXID_OPEN_DEVICE        OpenDevice;
    PKEVENT                 CompletionEvent;        
    URB                     Urb;
    BYTE                    bReportId;
    BYTE                    bSize;
} XINPUT_FEEDBACK_HEADER_INTERNAL;

typedef struct _XINPUT_FEEDBACK_INTERNAL
{
    DWORD                   dwStatus;
    HANDLE                  hEvent;
    XINPUT_FEEDBACK_HEADER_INTERNAL Internal;
} XINPUT_FEEDBACK_INTERNAL;

typedef struct _XID_OPEN_DEVICE
{
    PXID_DEVICE_NODE    XidNode;
    LONG                OutstandingPoll;
    ULONG               PacketNumber;
    PVOID               InterruptInEndpointHandle;
    PVOID               InterruptOutEndpointHandle;
    UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
    UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
    URB                 Urb;
    URB_CLOSE_ENDPOINT  CloseUrb;
    PKEVENT             CloseEvent;
    UCHAR               ClosePending:1;
    UCHAR               ControlEndpointOpen:1;
    UCHAR               EndpointsPendingClose:1;
    UCHAR               AutoPoll:1;
    UCHAR               Pad:4;
    UCHAR               Type;
    PXID_OPEN_DEVICE    NextOpenDevice;
} XID_OPEN_DEVICE;
#include <POPPACK.H>

//------------------------------------------------------------
//  A structure for the global variables.
//  The only exceptions are a few data tables.
//------------------------------------------------------------
typedef struct _XID_GLOBALS
{
    USHORT                  DeviceNodeCount;
    USHORT                  DeviceNodeInUseCount;
    PXID_DEVICE_NODE        DeviceNodes;
    PXID_OPEN_DEVICE        DeviceHandles;
    //
    //  Data used for enumeration
    //
    union
    {
        XID_DESCRIPTOR          EnumXidDescriptor;
        USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    };
    URB                         EnumUrb;
    UCHAR                       EnumNode;
    KTIMER                      EnumWatchdogTimer;
    KDPC                        EnumWatchdogTimerDpc;
} XID_GLOBALS;
extern XID_GLOBALS XID_Globals;

//--------------------------------------------------------------------------------------
//  Functions called from input.cpp
//--------------------------------------------------------------------------------------
DWORD
FASTCALL
XID_fOpenDevice(
    UCHAR            XidType,
    ULONG            Port,
    PXID_OPEN_DEVICE *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    );


DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL   OutputReport
        );

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    );

__inline 
PXID_OPEN_DEVICE 
XID_AllocateHandle()
{
    PXID_OPEN_DEVICE retVal = XID_Globals.DeviceHandles;
    ASSERT(retVal); //if hit we under allocated somehow.
    XID_Globals.DeviceHandles = retVal->NextOpenDevice;
    return retVal;
}

__inline 
VOID
XID_FreeHandle(PXID_OPEN_DEVICE DeviceHandle)
{
    DeviceHandle->NextOpenDevice = XID_Globals.DeviceHandles;
    XID_Globals.DeviceHandles = DeviceHandle;
}

//--------------------------------------------------------------------------------------
//  Type Specific Functions
//--------------------------------------------------------------------------------------
void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    );

#endif  //__XID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xidex\typeinfo.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Tables with information concerning the currently supported
    set of XID devices.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    08-01-00 created by Mitchell Dernis (mitchd)

--*/
//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIH'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");

//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"

//This will create a table of subtypes that we can find to walk
#pragma data_seg(".XID$A")
extern "C" DWORD XID_BeginTypeDescriptionTable = 0;
#pragma data_seg(".XID$ZZZ")
extern "C" DWORD XID_EndTypeDescriptionTable = 0;
#pragma data_seg(".XPP$Data")
#pragma code_seg(".XPPCODE")

//  Tells the linker to merge the USB sections together
#pragma comment(linker, "/merge:.XID=.XPP")

//----------------------------------------------
// Functions to walk the type tables.
//----------------------------------------------

PXID_TYPE_INFORMATION FASTCALL GetTypeInformation(UCHAR XidType, UCHAR *TypeIndex)
{
    *TypeIndex = 0;
    UCHAR ucTypeIndex = 0;
    PXID_TYPE_INFORMATION *ppTypeInformation;
    ppTypeInformation = (PXID_TYPE_INFORMATION *)((&XID_BeginTypeDescriptionTable)+1);
    while( (ULONG_PTR)ppTypeInformation < (ULONG_PTR)&XID_EndTypeDescriptionTable )
    {
        if(*ppTypeInformation)
        {
            if((*ppTypeInformation)->ucType == XidType)
            {
                *TypeIndex = ucTypeIndex;
                return *ppTypeInformation;
            }
            ucTypeIndex++;
        }
        ppTypeInformation++;
    }
    return NULL;
}

PXID_TYPE_INFORMATION FASTCALL GetTypeInformation(PXPP_DEVICE_TYPE XppType)
{
    PXID_TYPE_INFORMATION *ppTypeInformation;
    ppTypeInformation = (PXID_TYPE_INFORMATION *)((&XID_BeginTypeDescriptionTable)+1);
    while( (ULONG_PTR)ppTypeInformation < (ULONG_PTR)&XID_EndTypeDescriptionTable )
    {
        if(*ppTypeInformation && ((*ppTypeInformation)->XppType == XppType))
        {
            return *ppTypeInformation;
        }
        ppTypeInformation++;
    }
    return NULL;
}

/****
*****   Type Table Entries for the standard types.
****/

//----------------------------------------------
//  Game Controller Reports
//----------------------------------------------
//#define  XID_DEVTYPE_GAMECONTROLLER      1 - defined in xid.h
#define  XID_DEVSUBTYPE_MAX_GAME           1
#define  XID_INPUT_REPORT_ID_MAX_GAME      0
#define  XID_OUTPUT_REPORT_ID_MAX_GAME     0
#define XID_DEFAULT_MAX_GAMEPAD        4

DECLARE_XPP_TYPE(XDEVICE_TYPE_GAMEPAD)
XINPUT_GAMEPAD       GamepadDefaults ={0, //All the digital buttons (including DPAD) up.
                                       0,0,0,0,0,0,0,0,   //All the analog buttons up
                                       0,0,       //The Left Thumbstick centered
                                       0,0        //The Right Thumbstick centered
                                       };

XID_REPORT_TYPE_INFO GameInputReportInfoList[1] = {sizeof(XINPUT_GAMEPAD),(PVOID)&GamepadDefaults};
XINPUT_RUMBLE        RumbleDefaults = {0};  //The motors are off by default
XID_REPORT_TYPE_INFO GameOutputReportInfoList[1] = {sizeof(XINPUT_RUMBLE),(PVOID)&RumbleDefaults};
XINPUT_POLLING_PARAMETERS GameDefaultPolling = {TRUE,FALSE,0,8,0,0}; //AutoPoll On, control-OUT,

XID_TYPE_INFORMATION  GamepadTypeInfo = 
 {XID_DEVTYPE_GAMECONTROLLER, XID_DEFAULT_MAX_GAMEPAD, XID_INPUT_REPORT_ID_MAX_GAME, XID_OUTPUT_REPORT_ID_MAX_GAME,
 XDEVICE_TYPE_GAMEPAD, GameInputReportInfoList, GameOutputReportInfoList, &GameDefaultPolling, XID_ProcessGamepadData, 0};
     
#pragma data_seg(".XID$Gamepad")
extern "C" ULONG_PTR GamepadTypeInfoENTRY = (ULONG_PTR)&GamepadTypeInfo;
#pragma data_seg(".XPP$Data")

//----------------------------------------------
//  Keyboard Reports
//----------------------------------------------
//#define  XID_DEVTYPE_KEYBOARD            2 - defined in xid.h
#define  XID_DEVSUBTYPE_MAX_KEYBOARD       1
#define  XID_INPUT_REPORT_ID_MAX_KEYBOARD  0
#define  XID_OUTPUT_REPORT_ID_MAX_KEYBOARD 0
#define  XID_DEFAULT_MAX_KEYBOARD          1

DECLARE_XPP_TYPE(XDEVICE_TYPE_DEBUG_KEYBOARD)
XINPUT_KEYBOARD      KeyboardDefaults ={0, //All modified keys up
                                       0, //Reserved byte is zero
                                       0,0,0,0,0,0 //No keys down
                                       };

XID_REPORT_TYPE_INFO KeyboardReportInfoList[1] = {sizeof(XINPUT_KEYBOARD),(PVOID)&KeyboardDefaults};
XINPUT_KEYBOARD_LEDS KeyboardLEDDefaults = {0};  //All light off by default
XID_REPORT_TYPE_INFO KeyboardLEDReportInfoList[1] = {sizeof(XINPUT_KEYBOARD_LEDS),(PVOID)&KeyboardLEDDefaults};
XINPUT_POLLING_PARAMETERS KeyboardDefaultPolling = {TRUE,FALSE,0,16,0,0}; //AutoPoll On, SET_REPORT for out,

XID_TYPE_INFORMATION  KeyboardTypeInfo = 
 {XID_DEVTYPE_KEYBOARD, XID_DEFAULT_MAX_KEYBOARD, XID_INPUT_REPORT_ID_MAX_KEYBOARD, XID_OUTPUT_REPORT_ID_MAX_KEYBOARD,
 XDEVICE_TYPE_DEBUG_KEYBOARD, KeyboardReportInfoList, KeyboardLEDReportInfoList, &KeyboardDefaultPolling, XID_ProcessNewKeyboardData,
 XID_BSF_NO_CAPABILITIES|XID_BSF_NO_OUTPUT_HEADER};

#pragma data_seg(".XID$Keyboard")
extern "C" ULONG_PTR KeyboardTypeInfoENTRY = (ULONG_PTR)&KeyboardTypeInfo;
#pragma data_seg(".XPP$Data")

//----------------------------------------------
//  IR Remote Reports
//----------------------------------------------
#define  XID_DEVTYPE_IRREMOTE              3
#define  XID_DEVSUBTYPE_MAX_IRREMOTE       1
#define  XID_INPUT_REPORT_ID_MAX_IRREMOTE  0
#define  XID_OUTPUT_REPORT_ID_MAX_IRREMOTE 0
#define XID_DEFAULT_MAX_IRREMOTE           1

DECLARE_XPP_TYPE(XDEVICE_TYPE_IR_REMOTE)
XINPUT_IR_REMOTE     IrRemoteDefaults = {0,0};
XID_REPORT_TYPE_INFO IrRemoteReportInfoList[1] = {sizeof(XINPUT_IR_REMOTE),(PVOID)&IrRemoteDefaults};
XINPUT_POLLING_PARAMETERS IrRemoteDefaultPolling = {TRUE,FALSE,0,16,0,0};  //AutoPoll On, Interrupt-OUT, 16 ms Input Poll Interval

XID_TYPE_INFORMATION  IrRemoteTypeInfo =
 {XID_DEVTYPE_IRREMOTE, XID_DEFAULT_MAX_IRREMOTE, XID_INPUT_REPORT_ID_MAX_IRREMOTE, XID_OUTPUT_REPORT_ID_MAX_IRREMOTE,
 XDEVICE_TYPE_IR_REMOTE, IrRemoteReportInfoList, NULL, &IrRemoteDefaultPolling, XID_ProcessIRRemoteData, 0};

#pragma data_seg(".XID$IrRemote")
extern "C" ULONG_PTR IrRemoteTypeInfoENTRY = (ULONG_PTR)&IrRemoteTypeInfo;
#pragma data_seg(".XPP$Data")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xkbd\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xidex\xid.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.cpp

Abstract:
    
    Basic entry point implementation of the XID driver.
    
    
Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    02-21-00 created by Mitchell Dernis (mitchd)

--*/
#define XID_IMPLEMENTATION

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XID");

//
//  Pull in public usb headers
//
#include <usb.h>
//
//  Pull in xid headers
//
#include "xid.h"

//------------------------------------------------------------------------------
//  Declare XID's global variables.
//------------------------------------------------------------------------------
XID_GLOBALS XID_Globals;

//------------------------------------------------------------------------------
//  Forward declaration of locally defined functions
//------------------------------------------------------------------------------
VOID
XID_WatchdogTimerProc(
    PKDPC,
    PVOID,
    PVOID,
    PVOID
    );

VOID
XID_EnumStage1(
    PURB Urb,
    PXID_DEVICE_NODE XidNode
    );

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    );

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN PXID_TYPE_INFORMATION TypeInformation,
    IN ULONG  Port
    );

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    );

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    );

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    );

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID XID_EnumLegacy1(PURB Urb, PXID_DEVICE_NODE XidNode);
//VOID XID_EnumLegacy2(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboard(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboardComplete(PURB Urb, PXID_DEVICE_NODE XidNode);
PXID_KEYBOARD_SERVICES XID_pKeyboardServices = NULL;

//------------------------------------------------------------------------------
//  Declare XID types and class.
//------------------------------------------------------------------------------

// Normally you would use macros for the device type table.
// However, our types are dynamic, so we just want no types,
// during init, we can enumerate our types and then update the tables.
// USBD won't touch this entry until the first device is AddComplete.
#define XID_Types NULL
USB_CLASS_DRIVER_DECLARATION(XID_, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(XID_, 1, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
#undef XID_Types

#pragma data_seg(".XPP$ClassXID")
USB_CLASS_DECLARATION_POINTER(XID_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(XID_, 1)
#pragma data_seg(".XPP$Data")

USB_RESOURCE_REQUIREMENTS XID_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 0, 0, 1, 0, 2, 10, 0, 0, 0};

#define DEVICE_TYPE_STACK_SIZE 20
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID XID_Init(IUsbInit *UsbInit)
/*++
    Routine Description:
        Called at boot.  Registers with usbpnp.sys.  Intializes
        globals.
--*/
{
    ULONG handleCount = 0;
    ULONG index;
    
    PXPP_DEVICE_TYPE  devicesTypes[DEVICE_TYPE_STACK_SIZE];
    BOOL fUseDefaultCount;
    PXID_TYPE_INFORMATION *ppTypeInformation;
    DWORD dwTypeIndex = 0;
    
    //
    //  Verify that XOUTPUT_SIZE_OF_INTERNAL_HEADER is defined correctly
    //  in input.h
    //
    C_ASSERT(sizeof(XINPUT_FEEDBACK_HEADER_INTERNAL) == XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE);

    //Sentry to protect against double init.  This happens because we support XID and HID
    //class as the interface class.  This support is here to stay.
    static BOOL fInitialized = FALSE;
    if(fInitialized) return;
    fInitialized = TRUE;

    //
    //  Figure out how many nodes we need
    //
    XID_Globals.DeviceNodeCount = XGetPortCount()*XID_MAX_DEVICE_PER_PORT;

    //
    //  Walk the Device Type Table (and properly register each type)
    //
    fUseDefaultCount = UsbInit->UseDefaultCount();
    ppTypeInformation = (PXID_TYPE_INFORMATION *)((&XID_BeginTypeDescriptionTable)+1);
    while( (ULONG_PTR)ppTypeInformation < (ULONG_PTR)&XID_EndTypeDescriptionTable )
    {
        if(*ppTypeInformation)
        {
            // Recorder the XPP type in the temporary table.
            ASSERT(dwTypeIndex < DEVICE_TYPE_STACK_SIZE);
            devicesTypes[dwTypeIndex++] = (*ppTypeInformation)->XppType;

            // Count how many  handles we need, and record the user's
            // XInitDevices choice for count
            if(!fUseDefaultCount)
            {
                (*ppTypeInformation)->bRemainingHandles = 
                    UsbInit->GetMaxDeviceTypeCount((*ppTypeInformation)->XppType);
                RIP_ON_NOT_TRUE_WITH_MESSAGE(
                    (*ppTypeInformation)->bRemainingHandles <= XGetPortCount(),
                    "XInitDevices: requested more XDEVICE_TYPE_GAMEPAD than available ports.");
            }
            handleCount += (*ppTypeInformation)->bRemainingHandles;
        }
        ppTypeInformation++;
    }
    
    //
    //  In any case, we don't need more handles than we have device nodes.
    //
    if(handleCount > XID_Globals.DeviceNodeCount)
    {
        handleCount = XID_Globals.DeviceNodeCount;
    }

    //
    //  Allocate a block for the device type table, device nodes and handles
    //  
    ULONG allocSize = sizeof(PXPP_DEVICE_TYPE)*dwTypeIndex +
                      sizeof(XID_DEVICE_NODE)*XID_Globals.DeviceNodeCount +
                      sizeof(XID_OPEN_DEVICE)*handleCount;
    ULONG_PTR memory = (ULONG_PTR) RTL_ALLOCATE_HEAP(allocSize);
    ASSERT(memory);

    //
    //  Fix our device type table
    //
    XID_Description.DeviceTypeCount = dwTypeIndex;
    XID_Description.DeviceTypes = (PXPP_DEVICE_TYPE *)memory;
    XID_1Description.DeviceTypeCount = dwTypeIndex;  //The duplicate entry, for HID
    XID_1Description.DeviceTypes = (PXPP_DEVICE_TYPE *)memory;
    memory += (sizeof(PXPP_DEVICE_TYPE)*dwTypeIndex);
    memcpy(XID_Description.DeviceTypes, devicesTypes, sizeof(PXPP_DEVICE_TYPE)*dwTypeIndex);
    
    
    //
    //  Create a free list of handles
    //
    XID_Globals.DeviceHandles = NULL;
    PXID_OPEN_DEVICE openDevices = (PXID_OPEN_DEVICE) memory;
    for(index=0; index < handleCount; index++)
    {
        XID_FreeHandle(openDevices++);
    }

    //
    //  Initialize the open device nodes
    //
    XID_Globals.DeviceNodes = (PXID_DEVICE_NODE)openDevices;
    XID_Globals.DeviceNodeInUseCount = 0;
    for(index = 0; index < XID_Globals.DeviceNodeCount; index++)
    {
        XID_Globals.DeviceNodes[index].InUse = FALSE;
    }

    //
    //  Register our resources
    //
    XID_gResourceRequirements.MaxDevices = handleCount;
    UsbInit->RegisterResources(&XID_gResourceRequirements);

    //
    //  Initialize other globals.
    //
    KeInitializeTimer(&XID_Globals.EnumWatchdogTimer);
	return;
}
#pragma code_seg(".XPPCODE")

__inline void XID_SetEnumWatchdog()
/*++
    Routine Description:
        Called to start a 5 second watchdog timer on transfers
        during device enumeration.
--*/
{
    LARGE_INTEGER wait;
    wait.QuadPart = -50000000;
    KeSetTimer(&XID_Globals.EnumWatchdogTimer,wait,&XID_Globals.EnumWatchdogTimerDpc);
}

__inline void XID_ClearEnumWatchdog()
/*++
    Routine Description:
        Called to cancel a 5 second watchdog timer when a transfer during
        enumeration completes.
--*/
{
    KeCancelTimer(&XID_Globals.EnumWatchdogTimer);
}

VOID XID_WatchdogTimerProc(PKDPC, PVOID pvDevice, PVOID, PVOID)
/*++
    Routine Description:
        DPC routine called if a 5 second watchdog timer expires protecting
        asynchronous transfers during enumeration.  The routine forces completion
        of the URB by canceling it.  This will cause enumeration to fail,
        but avoids hanging USB device enumeration system wide.
--*/
{
    IUsbDevice *device = (IUsbDevice *)pvDevice;
    USB_DBG_ERROR_PRINT(("Enumeration Watchdog Timer has expired.\n"));
    device->CancelRequest(&XID_Globals.EnumUrb);
}

EXTERNUSB VOID
XID_AddDevice(
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
        This routine is registered as the AddDevice routine for new XID devices.
        It performs the following tasks:
            1) Allocates a XidNode from the static pool of nodes.
            2) Begins the XID enumeration provcess.
        Enumeration is continued in XID_EnumStage1.
--*/
{
    UCHAR                          nodeIndex = 0;
    PXID_DEVICE_NODE               xidNode;
    const USB_ENDPOINT_DESCRIPTOR *endpointDescriptor;
	        
    USB_DBG_ENTRY_PRINT(("Entering XID_AddDevice.\n"));
    if(XID_Globals.DeviceNodeInUseCount < XID_Globals.DeviceNodeCount)
    {
        //
        //  Find a free node, and claim it.
        //
        while(XID_Globals.DeviceNodes[nodeIndex].InUse) nodeIndex++;
        XID_Globals.DeviceNodeInUseCount++;
        XID_Globals.EnumNode = nodeIndex;
        xidNode = XID_Globals.DeviceNodes + nodeIndex;
		Device->SetExtension((PVOID)xidNode);
		xidNode->Device = Device;

        //
        //  Initialize what we can about the device.
        //
        xidNode->InUse = TRUE;
        xidNode->Ready = FALSE;
        xidNode->PendingRemove = FALSE;
        xidNode->Opened = FALSE;
        xidNode->InterfaceNumber = Device->GetInterfaceNumber();
        xidNode->OpenDevice = NULL;
        
    	//
		//	Get the interrupt-in endpoint descriptor  (NOT OPTIONAL).
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, TRUE, 0);
		ASSERT(endpointDescriptor);
        xidNode->EndpointAddressIn = endpointDescriptor->bEndpointAddress;
        xidNode->MaxPacketIn = (UCHAR)endpointDescriptor->wMaxPacketSize;
		
		//
		//	Get the interrupt-out endpoint (OPTIONAL)
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, FALSE, 0);
		if(endpointDescriptor)
		{
			xidNode->EndpointAddressOut = endpointDescriptor->bEndpointAddress;
			xidNode->MaxPacketOut = (UCHAR)endpointDescriptor->wMaxPacketSize;
		} else
		{
            xidNode->EndpointAddressOut = 0;
			xidNode->MaxPacketOut = 0;
		}
        //
        //  Get XID Descriptor
        //
        USB_BUILD_CONTROL_TRANSFER(
            (PURB_CONTROL_TRANSFER)&XID_Globals.EnumUrb,
            NULL, //Default endpoint
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(XID_DESCRIPTOR),
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_EnumStage1,
            (PVOID)xidNode,
            TRUE,
            (USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE),
            USB_REQUEST_GET_DESCRIPTOR,
            XID_DESCRIPTOR_TYPE,
            xidNode->InterfaceNumber,
            sizeof(XID_DESCRIPTOR)
            );
        //
        //  Reinitialize the watchdog DPC, so that the context is our device
        //
        KeInitializeDpc(&XID_Globals.EnumWatchdogTimerDpc, XID_WatchdogTimerProc, (PVOID)Device);
        XID_SetEnumWatchdog();
        Device->SubmitRequest(&XID_Globals.EnumUrb);
    }
    else
    {
        //
        //  Out of nodes so we cannot support the device
        //  (allow retry)
        //
        ASSERT(FALSE);
        Device->AddComplete(USBD_STATUS_NO_MEMORY);
    }
    USB_DBG_EXIT_PRINT(("Exiting XID_AddDevice.\n"));
}

VOID
XID_EnumStage1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
    Routine Description:
        Completion routine for obtaining the XID descriptor started
        in AddDevice.
        
        If retriving the XID_DESCRIPTOR failed,
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Getting the XID Descriptor may have failed.  This probably
    //  means it is a legacy device.
    //
    if(USBD_ERROR(Urb->Header.Status))
    {
        USB_DBG_EXIT_PRINT(("Couldn't get XID descriptor, could be a HID keyboard.\n"));
        XID_EnumLegacy1(Urb, XidNode);
        return;
    }

    //
    //  Copy the necessary info out of the Xid Descriptor
    //
    XidNode->TypeInformation = GetTypeInformation(XID_Globals.EnumXidDescriptor.bType, &XidNode->TypeIndex);
    XidNode->SubType = XID_Globals.EnumXidDescriptor.bSubType;
    XidNode->bMaxInputReportSize = XID_Globals.EnumXidDescriptor.bMaxInputReportSize;
    XidNode->bMaxOutputReportSize = XID_Globals.EnumXidDescriptor.bMaxOutputReportSize;
    
    //
    //  Check a number of items to determine if we can support the device.
    //      1) The type must be one known at compile time
    //      2) The report size must be at least as large as the XID_REPORT_HEADER.
    //      3) The maximum report size must not be larger than our buffer (XID_MAXIMUM_REPORT_SIZE)
    //         this is a limit on the extensibility of XID.
    //      4) For performance and resource management reasons we enforce that
    //         the entire report fit in a single interrupt-IN packet (there is
    //         no such requirement on the control pipe).
    //      5) Same for output, but only if interrupt OUT is supported.
    //
    if(
        (!XidNode->TypeInformation) ||
        (XID_REPORT_HEADER > XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XID_MAXIMUM_REPORT_SIZE < XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XidNode->bMaxInputReportSize > XidNode->MaxPacketIn) ||
        (XidNode->EndpointAddressOut && (XidNode->bMaxOutputReportSize > XidNode->MaxPacketOut))
    )
    {
        USB_DBG_WARN_PRINT(("Unsupported XID Device"));
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    	XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }

    //
    //  Set the class specific type and call AddComplete.
    //

    XidNode->Device->SetClassSpecificType(XidNode->TypeIndex);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}

EXTERNUSB VOID
XID_RemoveDevice(
    IUsbDevice *Device
    )
/*++
    Routine Description:
        Called by usbd when a device is removed.  It kicks off out
        remove sequence.
--*/
{
    PXID_DEVICE_NODE xidNode = (PXID_DEVICE_NODE)Device->GetExtension();
    ASSERT(NULL != xidNode);
    
	ASSERT_DISPATCH_LEVEL();
    //
    //  Mark the Node remove pending.
    //
    xidNode->PendingRemove = TRUE;
    //
    //  If there is an open handle
    //  kick off a close.
    //
    if(xidNode->OpenDevice)
    {
        //
        // Notify keyboard services of device removal.
        //
        #ifdef DEBUG_KEYBOARD
        if((XDEVICE_TYPE_DEBUG_KEYBOARD==xidNode->TypeInformation->XppType) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnRemove(xidNode->OpenDevice);
        }
        #endif DEBUG_KEYBOARD
        XID_fCloseEndpoints(xidNode->OpenDevice);
    } else
    //
    //  Otherwise, we can wrap up the remove.
    //
    {
        XID_fRemoveDeviceComplete(xidNode);        
    }
}

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    )
/*++
    Routine Description:
        This routine is called by XID_DereferenceNode, when
        the reference count on a XID node goes to zero.
        At that time, it is certain that all open endpoints
        are closed, and all outstanding I/O is complete.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    //
    //  We are really done
    //
    USB_DBG_TRACE_PRINT(("Freeing node(0x%0.8x) nodeIndex = %d\n", XidNode, XidNode - XID_Globals.DeviceNodes));
    ASSERT(XidNode->PendingRemove);
	XidNode->Device->SetExtension(NULL);
	XidNode->Device->RemoveComplete();
	XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
    return;
}

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN PXID_TYPE_INFORMATION TypeInformation,
    IN ULONG  Port
    )
/*++
    Routine Description:
        Finds a XID node that corresponds to the type and port (port includes port and slot).
        Will only return nodes that are ready to be open.
    Return Value:
        If a suitable node is found, it is returned.  Otherwise, NULL is returned.
    Environement:
        Assumes DISPATCH_LEVEL.
--*/
{
    UCHAR xidNodeIndex;
    PXID_DEVICE_NODE xidNode = NULL;
    //
    //  Brute force search of all the nodes.
    //
    for(xidNodeIndex = 0; xidNodeIndex < XID_Globals.DeviceNodeCount; xidNodeIndex++)
    {
        if(
            XID_Globals.DeviceNodes[xidNodeIndex].InUse &&
            (XID_Globals.DeviceNodes[xidNodeIndex].Device->GetPort() == Port) &&
            (XID_Globals.DeviceNodes[xidNodeIndex].TypeInformation == TypeInformation) &&
            XID_Globals.DeviceNodes[xidNodeIndex].Ready &&
            !XID_Globals.DeviceNodes[xidNodeIndex].PendingRemove
        ){
            xidNode =  XID_Globals.DeviceNodes + xidNodeIndex;
        }
    }
    return xidNode;
}

DWORD
FASTCALL
XID_fOpenDevice(
    PXID_TYPE_INFORMATION TypeInformation,
    ULONG                 Port,
    PXID_OPEN_DEVICE      *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Given a XidTy creates an OpenDevice,
    initializes the OpenDevice and opens
    the endpoints so the device can be used.
--*/
{
    
    USBD_STATUS         status;
    PXID_OPEN_DEVICE    openDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql;
    DWORD               errorCode = ERROR_SUCCESS;
    BOOL                partiallyOpen = FALSE;

    //
    // By default we want to return NULL.
    //
    *OpenDevice = NULL;

    //
    //  Must be done at high Irql
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Find the node
    //
    xidNode = XID_fFindNode(TypeInformation, Port);
    if(!xidNode)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_open_device;
    }

    //
    //  Make sure that it is not already open
    //
    if(xidNode->OpenDevice)
    {
        errorCode = ERROR_SHARING_VIOLATION;
        goto exit_open_device;
    }

    
    if(0==TypeInformation->bRemainingHandles)
    {
        errorCode = ERROR_OUTOFMEMORY;
        goto exit_open_device;        
    }
    
    //
    //  Allocate memory for the device handle
    //
    
    TypeInformation->bRemainingHandles--;
    openDevice = XID_AllocateHandle();
    
    //
    //  Initialize the basic stuff
    //
    RtlZeroMemory(openDevice, sizeof(XID_OPEN_DEVICE));
    openDevice->XidNode = xidNode;
    openDevice->TypeInformation = TypeInformation;
    openDevice->AutoPoll = PollingParameters->fAutoPoll ? TRUE : FALSE;
    
    //
    //  Tie the xidNode to our handle.
    //
    xidNode->OpenDevice = openDevice;

    //
    //  Any failure after here, requires closing the device.
    //
    partiallyOpen = TRUE;

    //
    //  Open the endpoints
    //

    status = XID_fOpenEndpoints(openDevice, PollingParameters);

    //
    //  If the endpoints were successfully opened
    //  then setup the initial state.
    //
    if(USBD_SUCCESS(status))
    {
        //
        //  Initialize the Report and the Report for URB
        //  with the default values;
        //
        RtlCopyMemory(
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            TypeInformation->pInputReportInfoList[0].pDefaultValues,
            TypeInformation->pInputReportInfoList[0].bCurrentSize
            );
        RtlCopyMemory(
            (PVOID)openDevice->Report,
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            sizeof(openDevice->Report)
            );

        //
        //  Initialize an event for synchronization
        //
        KEVENT   event;
        KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    
        //
        //  Build a control transfer
        //
        WORD wReportTypeAndId = 0x0100;
        ULONG ulBufferSize = xidNode->bMaxInputReportSize;
        USB_BUILD_CONTROL_TRANSFER(
            &openDevice->Urb.ControlTransfer,
            NULL, //Default endpoint
            openDevice->ReportForUrb,
            ulBufferSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_SyncComplete, //do it synchronously
            &event,  //the context is the event.
            TRUE,
            (USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_GET_REPORT,
            wReportTypeAndId, //Input report 0
            xidNode->InterfaceNumber,
            ulBufferSize
            );

        //
        //  Submit the request
        //
        xidNode->Device->SubmitRequest(&openDevice->Urb);
    
        //
        //  Lower IRQL, and wait for transfer to complete.
        //  Then restore Irql to DPC level
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  During the transfer the device may have been removed,
        //  if so we should check to make sure that the device is
        //  still with us.  There are two cases here: the device is
        //  totally gone, the device is still pending remove.
        //
    
        if(NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_open_device;
        } 

        //
        //  Process the GET_REPORT results, if it succeeded
        //
        if(USBD_SUCCESS(openDevice->Urb.Header.Status))
        {
            TypeInformation->pfnProcessNewData(openDevice);
        } 
#if DBG
        else
        //
        // Issue warning if GET_REPORT failed.
        //
	    { 
           if(USBD_STATUS_STALL_PID == openDevice->Urb.Header.Status)
           {
		       USB_DBG_WARN_PRINT(("Device in port %d (0 based) does not support GET_REPORT\n", Port));
           }
        }
#endif

        //
        // Notify keyboard services of new open device.
        //
        if((XDEVICE_TYPE_DEBUG_KEYBOARD==TypeInformation->XppType) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnOpen(openDevice);
        }

        //
        //  Prepare the URB for the interrupt-in endpoint.
        //
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)&openDevice->Urb,
            openDevice->InterruptInEndpointHandle,
            openDevice->ReportForUrb,
            xidNode->bMaxInputReportSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_NewInterruptData,
            (PVOID)openDevice,
            TRUE
            );

        //
        //  If autopoll is set, start polling
        //
        if(openDevice->AutoPoll)
        {
          xidNode->Device->SubmitRequest(&openDevice->Urb);
        }

        
        //
        //  If we are here, the device was successfully opened.
        //  copy the handle, and mark partiallyOpen as FALSE
        //  as we are now fully open.
        //
        *OpenDevice = openDevice;
        partiallyOpen = FALSE;
    }  else
    {
        errorCode = IUsbDevice::Win32FromUsbdStatus(status);
    }

exit_open_device:
    
    //
    //  Done with synchronization
    //
    KeLowerIrql(oldIrql);
    
    //
    //  Partially opened devices
    //  should be closed.
    //
    if(partiallyOpen)
    {
        XID_fCloseDevice(openDevice);
    }

    return errorCode;
}

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    IN PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Routine Description:
        Called from XID_OpenDevice to open the endpoints associated with the
        device.  Opening the endpoints references the XidNode until the endpoints
        are closed.
--*/
{
    
    USBD_STATUS status = USBD_STATUS_SUCCESS;
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  Open the control endpoint
    //
    
    USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&OpenDevice->Urb);
    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    
    //
    //  If the control endpoint is open,
    //  open the interrupt in endpoint.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->ControlEndpointOpen = TRUE;
        USB_BUILD_OPEN_ENDPOINT(
        (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
        xidNode->EndpointAddressIn,
        USB_ENDPOINT_TYPE_INTERRUPT,
        (USHORT)XID_MAXIMUM_REPORT_SIZE,
        PollingParameters->bInputInterval
        );
        status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    }

    //
    //  If interrupt-IN endpoint opened, save the handle
    //  and try to open the interrupt out, if there is
    //  one.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->InterruptInEndpointHandle = OpenDevice->Urb.OpenEndpoint.EndpointHandle;
        ASSERT(OpenDevice->InterruptInEndpointHandle);
        if(PollingParameters->fInterruptOut && xidNode->EndpointAddressOut)
        {
            USB_BUILD_OPEN_ENDPOINT(
                (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
                xidNode->EndpointAddressOut,
                USB_ENDPOINT_TYPE_INTERRUPT,
                (USHORT)XID_MAXIMUM_REPORT_SIZE,
                PollingParameters->bOutputInterval
                );
		    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
        
            if(USBD_SUCCESS(status))
            {
                OpenDevice->InterruptOutEndpointHandle = 
                        OpenDevice->Urb.OpenEndpoint.EndpointHandle;
                ASSERT(OpenDevice->InterruptOutEndpointHandle);
            }
        }
    }

    //
    //  return the status
    //
    return status;
}


VOID
FASTCALL
