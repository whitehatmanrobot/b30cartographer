                              NULL,
                                                &defused )) == 0) ||
                 (defused) )
            {
                errno = EILSEQ;
                return (size_t)-1;
            }

            return count - 1;
        }
    }

}

extern "C" size_t __cdecl _wcstombs_l (
        char * s,
        const wchar_t * pwcs,
        size_t n,
        _locale_t plocinfo
        )
{
    return _wcstombs_l_helper(s, pwcs, n, plocinfo);
}

extern "C" size_t __cdecl wcstombs (
        char * s,
        const wchar_t * pwcs,
        size_t n
        )
{
    return _wcstombs_l_helper(s, pwcs, n, NULL);
}

/***
*errno_t wcstombs_s() - Convert wide char string to multibyte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string,
*       according to the LC_CTYPE category of the current locale.
*
*       The destination string is always null terminated.
*
*Entry:
*       size_t *pConvertedChars = Number of bytes modified including the terminating NULL
*                                 This pointer can be NULL.
*       char *dst = pointer to destination multibyte char string
*       size_t sizeInBytes = size of the destination buffer
*       const wchar_t *src = pointer to source wide character string
*       size_t n = maximum number of bytes to store in s (not including the terminating NULL)
*
*Exit:
*       The error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" errno_t __cdecl _wcstombs_s_l (
        size_t *pConvertedChars,
        char * dst,
        size_t sizeInBytes,
        const wchar_t * src,
        size_t n,
        _locale_t plocinfo
        )
{
    size_t retsize;
    errno_t retvalue = 0;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE((dst != NULL && sizeInBytes > 0) || (dst == NULL && sizeInBytes == 0), EINVAL);
    if (dst != NULL)
    {
        _RESET_STRING(dst, sizeInBytes);
    }

    if (pConvertedChars != NULL)
    {
        *pConvertedChars = 0;
    }

    size_t bufferSize = n > sizeInBytes ? sizeInBytes : n;
    _VALIDATE_RETURN_ERRCODE(bufferSize <= INT_MAX, EINVAL);

    retsize = _wcstombs_l_helper(dst, src, bufferSize, plocinfo);

    if (retsize == (size_t)-1)
    {
        if (dst != NULL)
        {
            _RESET_STRING(dst, sizeInBytes);
        }
        return errno;
    }

    /* count the null terminator */
    retsize++;

    if (dst != NULL)
    {
        /* return error if the string does not fit, unless n == _TRUNCATE */
        if (retsize > sizeInBytes)
        {
            if (n != _TRUNCATE)
            {
                _RESET_STRING(dst, sizeInBytes);
                _VALIDATE_RETURN_ERRCODE(sizeInBytes > retsize, ERANGE);
            }
            retsize = sizeInBytes;
            retvalue = STRUNCATE;
        }

        /* ensure the string is null terminated */
        dst[retsize - 1] = '\0';
    }

    if (pConvertedChars != NULL)
    {
        *pConvertedChars = retsize;
    }

    return retvalue;
}

extern "C" errno_t __cdecl wcstombs_s (
        size_t *pConvertedChars,
        char * dst,
        size_t sizeInBytes,
        const wchar_t * src,
        size_t n
        )
{
    return _wcstombs_s_l(pConvertedChars, dst, sizeInBytes, src, n, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wcsupr.c ===
/***
*wcsupr.c - routine to map lower-case characters in a wchar_t string
*       to upper-case
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the lower case characters in a wchar_t string
*       to upper case, in place.
*
*******************************************************************************/


#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <ctype.h>
#include <awint.h>
#include <dbgint.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*wchar_t *_wcsupr(string) - map lower-case characters in a string to upper-case
*
*Purpose:
*       wcsupr converts lower-case characters in a null-terminated wchar_t
*       string to their upper-case equivalents.  The result may be longer or
*       shorter than the original string.  Assumes enough space in string
*       to hold the result.
*
*Entry:
*       wchar_t *wsrc - wchar_t string to change to upper case
*
*Exit:
*       input string address
*
*Exceptions:
*       on an error, the original string is unaltered, and errno is set
*
*******************************************************************************/

extern "C" wchar_t * __cdecl _wcsupr_l (
        wchar_t * wsrc,
        _locale_t plocinfo
        )
{
    _wcsupr_s_l(wsrc, (size_t)(-1), plocinfo);
    return wsrc;
}

extern "C" wchar_t * __cdecl _wcsupr (
        wchar_t * wsrc
        )
{
    if (__locale_changed == 0)
    {
    wchar_t * p;

    /* validation section */
    _VALIDATE_RETURN(wsrc != NULL, EINVAL, NULL);

    for (p=wsrc; *p; ++p)
    {
            if (L'a' <= *p && *p <= L'z')
                    *p += (wchar_t)(L'A' - L'a');
    }

        return wsrc;
    }
    else
    {
        _wcsupr_s_l(wsrc, (size_t)-1, NULL);
        return wsrc;
    }
}

/***
*errno_t _wcsupr_s(string, size_t) - map lower-case characters in a string to upper-case
*
*Purpose:
*       wcsupr converts lower-case characters in a null-terminated wchar_t
*       string to their upper-case equivalents.  The result may be longer or
*       shorter than the original string.
*
*Entry:
*       wchar_t *wsrc - wchar_t string to change to upper case
*       size_t sizeInWords - size of the destination buffer
*
*Exit:
*       the error code
*
*Exceptions:
*       on an error, the original string is unaltered, and errno is set
*
*******************************************************************************/

static errno_t __cdecl _wcsupr_s_l_stat (
        wchar_t * wsrc,
        size_t sizeInWords,
        _locale_t plocinfo
        )
{

    wchar_t *p;             /* traverses string for C locale conversion */
    wchar_t *wdst;          /* wide version of string in alternate case */
    int dstsize;            /* size in wide chars of wdst string buffer (include null) */
    errno_t e = 0;
    size_t stringlen;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(wsrc != NULL, EINVAL);
    stringlen = wcsnlen(wsrc, sizeInWords);
    if (stringlen >= sizeInWords)
    {
        _RESET_STRING(wsrc, sizeInWords);
        _RETURN_DEST_NOT_NULL_TERMINATED(wsrc, sizeInWords);
    }
    _FILL_STRING(wsrc, sizeInWords, stringlen + 1);

    if ( plocinfo->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
    {
        for ( p = wsrc ; *p ; p++ )
        {
            if ( (*p >= (wchar_t)L'a') && (*p <= (wchar_t)L'z') )
                *p = *p - (L'a' - L'A');
        }
        return 0;
    }   /* C locale */


    /* Inquire size of wdst string */
    if ( (dstsize = __crtLCMapStringW(
                    plocinfo->locinfo->lc_handle[LC_CTYPE],
                    LCMAP_UPPERCASE,
                    wsrc,
                    -1,
                    NULL,
                    0 )) == 0 )
    {
        errno = EILSEQ;
        return errno;
    }

    if (sizeInWords < (size_t)dstsize)
    {
        _RESET_STRING(wsrc, sizeInWords);
        _RETURN_BUFFER_TOO_SMALL(wsrc, sizeInWords);
    }

    /* Allocate space for wdst */
    wdst = (wchar_t *)_calloca(dstsize, sizeof(wchar_t));
    if (wdst == NULL)
    {
        errno = ENOMEM;
        return errno;
    }

    /* Map wrc string to wide-character wdst string in alternate case */
    if (__crtLCMapStringW(
                plocinfo->locinfo->lc_handle[LC_CTYPE],
                LCMAP_UPPERCASE,
                wsrc,
                -1,
                wdst,
                dstsize ) != 0)
    {
        /* Copy wdst string to user string */
        e = wcscpy_s(wsrc, sizeInWords, wdst);
    }
    else
    {
        e = errno = EILSEQ;
    }

    _freea(wdst);

    return e;
}

extern "C" errno_t __cdecl _wcsupr_s_l (
        wchar_t * wsrc,
        size_t sizeInWords,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _wcsupr_s_l_stat(wsrc, sizeInWords, _loc_update.GetLocaleT());
}


extern "C" errno_t __cdecl _wcsupr_s (
        wchar_t * wsrc,
        size_t sizeInWords
        )
{
    return _wcsupr_s_l(wsrc, sizeInWords, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wcstoq.c ===
/***
*wcstoq.c - Contains C runtimes wcstoi64 and wcstoui64
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wcstoi64 - convert ascii string to signed __int64 integer
*       wcstoui64- convert ascii string to unsigned __int64 integer
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <internal.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

extern "C" int _wchartodigit(wchar_t ch);

/***
*wcstoq, wcstouq(nptr,endptr,ibase) - Convert ascii string to un/signed __int64.
*
*Purpose:
*       Convert an ascii string to a 64-bit __int64 value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First wchar_t = '0', second wchar_t = 'x' or 'X',
*                   use base 16.
*               (b) First wchar_t = '0', use base 8
*               (c) First wchar_t in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstoq/wcstouq places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               wcstoq -- _I64_MAX or _I64_MIN
*               wcstouq -- _UI64_MAX
*               wcstoq/wcstouq -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstouq called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl wcstoxq (
        _locale_t plocinfo,
        const wchar_t *nptr,
        const wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned __int64 number;
        unsigned digval;
        unsigned __int64 maxval;
    _LocaleUpdate _loc_update(plocinfo);


    /* validation section */
    if (endptr != NULL)
    {
        /* store beginning of string in endptr */
        *endptr = nptr;
    }
    _VALIDATE_RETURN(nptr != NULL, EINVAL, 0L);
    _VALIDATE_RETURN(ibase == 0 || (2 <= ibase && ibase <= 36), EINVAL, 0L);

    p = nptr;                   /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read wchar_t */

    while ( iswspace(c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (_wchartodigit(c) != 0)
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
        if (_wchartodigit(c) == 0 && (*p == L'x' || *p == L'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = _UI64_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( (digval = _wchartodigit(c)) != -1 )
                        ;
                else if ( __ascii_iswalpha(c) )
                        digval = __ascii_towupper(c) - L'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned __int64)digval <= _UI64_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                        if (endptr == NULL) {
                                /* no need to keep on parsing if we
                                   don't have to return the endptr. */
                                break;
                        }
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
    else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
    {
        /* overflow or signed overflow occurred */
        errno = ERANGE;
        if ( flags & FL_UNSIGNED )
            number = _UI64_MAX;
        else if ( flags & FL_NEG )
            number = (_I64_MIN);
        else
            number = _I64_MAX;
    }

        if (endptr != NULL)
                /* store pointer to wchar_t that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned __int64)(-(__int64)number);

        return number;                  /* done. */
}


extern "C" __int64 _CRTIMP __cdecl _wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    )
{
    if (__locale_changed == 0)
    {
        return (__int64) wcstoxq(&__initiallocalestructinfo, nptr, (const wchar_t **)endptr, ibase, 0);
}
    else
    {
        return (__int64) wcstoxq(NULL, nptr, (const wchar_t **)endptr, ibase, 0);
    }
}
extern "C" __int64 _CRTIMP __cdecl _wcstoi64_l(
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase,
        _locale_t plocinfo
        )
{
    return (__int64) wcstoxq(plocinfo, nptr, (const wchar_t **)endptr, ibase, 0);
}

extern "C" unsigned __int64 _CRTIMP __cdecl _wcstoui64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
    if (__locale_changed == 0)
    {
        return wcstoxq(&__initiallocalestructinfo, nptr, (const wchar_t **)endptr, ibase, FL_UNSIGNED);
    }
    else
    {
        return wcstoxq(NULL, nptr, (const wchar_t **)endptr, ibase, FL_UNSIGNED);
    }
}

extern "C" unsigned __int64 _CRTIMP __cdecl _wcstoui64_l (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase,
        _locale_t plocinfo
        )
{
    return wcstoxq(plocinfo, nptr, (const wchar_t **)endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wcsxfrm.c ===
/***
*wcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <stdlib.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*size_t wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _count wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = result string
*       const wchar_t *_string2 = source string
*       size_t _count           = max wide chars to move
*
*       [If _count is 0, _string1 is permitted to be NULL.]
*
*Exit:
*       Length of the transformed string (not including the terminating
*       null).  If the value returned is >= _count, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" size_t __cdecl _wcsxfrm_l (
        wchar_t *_string1,
        const wchar_t *_string2,
        size_t _count,
        _locale_t plocinfo
        )
{
    int size = INT_MAX;

    /* validation section */
    _VALIDATE_RETURN(_count <= INT_MAX, EINVAL, INT_MAX);
    _VALIDATE_RETURN(_string1 != NULL || _count == 0, EINVAL, INT_MAX);
    _VALIDATE_RETURN(_string2 != NULL, EINVAL, INT_MAX);

    _LocaleUpdate _loc_update(plocinfo);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
    {
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        wcsncpy(_string1, _string2, _count);
_END_SECURE_CRT_DEPRECATION_DISABLE
        return wcslen(_string2);
    }

    if ( 0 == (size = __crtLCMapStringW(
                    _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE],
                    LCMAP_SORTKEY,
                    _string2,
                    -1,
                    NULL,
                    0 )) )
    {
        errno = EILSEQ;
        size = INT_MAX;
    } else
    {
        if ( size <= (int)_count)
        {
            if ( 0 == (size = __crtLCMapStringW(
                            _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE],
                            LCMAP_SORTKEY,
                            _string2,
                            -1,
                            (wchar_t *)_string1,
                            (int)_count )) )
            {
                errno = EILSEQ;
                size = INT_MAX; /* default error */
            } else
            {
                // Note that the size that LCMapStringW returns for
                // LCMAP_SORTKEY is number of bytes needed. That's why it
                // is safe to convert the buffer to wide char from end.
                _count = size--;
                for (;_count-- > 0;)
                {
                    _string1[_count] = (wchar_t)((unsigned char *)_string1)[_count];
                }
            }
        }
        else
        {
            if (_string1 != NULL && _count > 0)
            {
                *_string1 = '\0';
                errno = ERANGE;
            }
            size--;
        }
    }

    return (size_t)size;
}

extern "C" size_t __cdecl wcsxfrm (
        wchar_t *_string1,
        const wchar_t *_string2,
        size_t _count
        )
{

    return _wcsxfrm_l(_string1, _string2, _count, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wctime.c ===
/***
*wctime.c - convert time argument into ASCII string (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _wctime() - convert time value to wide ASCII string
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "ctime.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wctime64.c ===
/***
*wctime64.c - convert time argument into a string (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _wctime64() - convert time value to wide char string
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "ctime64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#pragma once

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#include <crtdefs.h>

#pragma pack(push,_CRT_PACKING)

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(CRTDLL2)
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */
#ifndef _CRT_CTYPEDATA_DEFINED
#define _CRT_CTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS
#ifndef _INTERNAL_IFSTRIP_
extern const unsigned short __newctype[];
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */

#ifndef __PCTYPE_FUNC
#if defined(_CRT_DISABLE_PERFCRIT_LOCKS) && !defined(_DLL)
#define __PCTYPE_FUNC  _pctype
#else
#define __PCTYPE_FUNC   __pctype_func()
#endif  
#endif  /* __PCTYPE_FUNC */

_CRTIMP const unsigned short * __cdecl __pctype_func(void);
#if !defined(_M_CEE_PURE)
_CRTIMP extern const unsigned short *_pctype;
#else
#define _pctype (__pctype_func())
#endif /* !defined(_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif

#ifndef _CRT_WCTYPEDATA_DEFINED
#define _CRT_WCTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS
#if !defined(_M_CEE_PURE)
_CRTIMP extern const unsigned short _wctype[];
#endif /* !defined(_M_CEE_PURE) */
#ifndef _INTERNAL_IFSTRIP_
extern const unsigned short __newctype[];
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const wctype_t ** __cdecl __p__pwctype(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */

_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
#if !defined(_M_CEE_PURE)
_CRTIMP extern const wctype_t *_pwctype;
#else
#define _pwctype (__pwctype_func())
#endif /* !defined(_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif



/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wint_t __cdecl towupper(wint_t);
_CRTIMP wint_t __cdecl towlower(wint_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

_CRTIMP int __cdecl __iswcsymf(wint_t);
_CRTIMP int __cdecl __iswcsym(wint_t);

_CRT_OBSOLETE(iswctype) _CRTIMP int __cdecl is_wctype(wint_t, wctype_t);

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#if !defined(__cplusplus) || defined(_M_CEE_PURE) || defined(MRTDLL)
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (__pctype_func()[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_MRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_MRTIMP2 wctrans_t __cdecl wctrans(const char *);
_MRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#pragma pack(pop)

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wctomb.c ===
/***
*wctomb.c - Convert wide character to multibyte character.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <errno.h>
#include <locale.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*errno_t wctomb_s() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       int *retvalue = pointer to a useful return value:
*           if s == NULL && sizeInBytes == 0: number of bytes needed for the conversion
*           if s == NULL && sizeInBytes > 0: the state information
*           if s != NULL : number of bytes used for the conversion
*           The pointer can be null.
*       char *s = pointer to multibyte character
*       size_t sizeInBytes = size of the destination buffer
*       wchar_t wchar = source wide character
*
*Exit:
*       The error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _wctomb_s_l (
        int *pRetValue,
        char *dst,
        size_t sizeInBytes,
        wchar_t wchar,
        _locale_t plocinfo
        )
{
    if (dst == NULL && sizeInBytes > 0)
    {
        /* indicate do not have state-dependent encodings */
        if (pRetValue != NULL)
        {
            *pRetValue = 0;
        }
        return 0;
    }

    if (pRetValue != NULL)
    {
        *pRetValue = -1;
    }

    /* validation section */
    /* we need to cast sizeInBytes to int, so we make sure we are not going to truncate sizeInBytes */
    _VALIDATE_RETURN_ERRCODE(sizeInBytes <= INT_MAX, EINVAL);


    _LocaleUpdate _loc_update(plocinfo);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
    {
        if ( wchar > 255 )  /* validate high byte */
        {
            if (dst != NULL && sizeInBytes > 0)
            {
                memset(dst, 0, sizeInBytes);
            }
            errno = EILSEQ;
            return errno;
        }

        if (dst != NULL)
        {
            _VALIDATE_RETURN_ERRCODE(sizeInBytes > 0, ERANGE);
            *dst = (char) wchar;
        }
        if (pRetValue != NULL)
        {
            *pRetValue = 1;
        }
        return 0;
    }
    else
    {
        int size;
        BOOL defused = 0;

        if ( ((size = WideCharToMultiByte( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                           0,
                                           &wchar,
                                           1,
                                           dst,
                                           (int)sizeInBytes,
                                           NULL,
                                           &defused) ) == 0) ||
             (defused) )
        {
            if (size == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (dst != NULL && sizeInBytes > 0)
                {
                    memset(dst, 0, sizeInBytes);
                }
                _VALIDATE_RETURN_ERRCODE(("Buffer too small", 0), ERANGE);
            }
            errno = EILSEQ;
            return errno;
        }

        if (pRetValue != NULL)
        {
            *pRetValue = size;
        }
        return 0;
    }

}

extern "C" errno_t __cdecl wctomb_s (
        int *pRetValue,
        char *dst,
        size_t sizeInBytes,
        wchar_t wchar
        )
{
        return _wctomb_s_l(pRetValue, dst, sizeInBytes, wchar, NULL);
}

/***
*int wctomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s          = pointer to multibyte character
*       wchar_t wchar        = source wide character
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:
*                   -1 (if error) or number of bytes comprising
*                   converted mbc
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _wctomb_l (
        char *s,
        wchar_t wchar,
        _locale_t plocinfo
        )
{
    int retval = -1;
    errno_t e;
    _LocaleUpdate _loc_update(plocinfo);

    e = _wctomb_s_l(&retval, s, _loc_update.GetLocaleT()->locinfo->mb_cur_max, wchar, _loc_update.GetLocaleT());
    return (e == 0 ? retval : -1);
}

extern "C" int __cdecl wctomb (
        char *s,
        wchar_t wchar
        )
{
    int retval = -1;
    errno_t e;

    e = _wctomb_s_l(&retval, s, MB_CUR_MAX, wchar, NULL);
    return (e == 0 ? retval : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wctrans.c ===
/* towctrans/wctrans functions for Microsoft */
#include <string.h>
#include <ctype.h>
#include <wctype.h>
#ifndef _YVALS
#include <yvals.h>
#endif

 #pragma warning(disable:4244)

 #ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
 #endif

typedef wchar_t wctrans_t;

_C_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"tolower", 2},
	{"toupper", 1},
	{(const char *)0, 0}};

_MRTIMP2 wint_t (__cdecl towctrans)(wint_t c, wctrans_t val)
	{	/* translate wide character */
	return (val == 1 ? towupper(c) : towlower(c));
	}

_MRTIMP2 wctrans_t (__cdecl wctrans)(const char *name)
	{	/* find translation for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wdospawn.c ===
/***
*wdospawn.c - spawn a child process (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wdospawn - spawn a child process and pass wide environment
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "dospawn.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wdll_av.c ===
/***
*wdll_av.c - __wsetargv() routine for use with C Run-Time as a DLL (CRTDLL)
*            (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object is part of the start-up code for EXE's linked with
*       CRTDLL.LIB/MSVCRT.LIB.  This object will be linked into the user
*       EXE if and only if the user explicitly links with WSETARGV.OBJ.
*       The code in this object sets the flag that is passed to the
*       C Run-Time DLL to enable wildcard expansion of the argv[] vector.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "dll_argv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wctype.c ===
/***
*wctype.c - wctype function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
****/

#include <string.h>
#include <wctype.h>
#ifndef _YVALS
#include <yvals.h>
#endif  /* _YVALS */

_C_STD_BEGIN

static const struct wctab {
        const char *s;
        wctype_t val;
        } tab[] = {
        {"alnum", _ALPHA|_DIGIT},
        {"alpha", _ALPHA},
        {"cntrl", _CONTROL},
        {"digit", _DIGIT},
        {"graph", _PUNCT|_ALPHA|_DIGIT},
        {"lower", _LOWER},
        {"print", _BLANK|_PUNCT|_ALPHA|_DIGIT},
        {"punct", _PUNCT},
        {"space", _SPACE},
        {"upper", _UPPER},
        {"xdigit", _HEX},
        {(const char *)0, 0}};

#pragma warning(disable:4273)   /* inconsistent with Microsoft header */
_MRTIMP2 wctype_t (__cdecl wctype)(const char *name)
        {       /* find classification for wide character */
        int n;

        for (n = 0; tab[n].s != 0; ++n)
                if (strcmp(tab[n].s, name) == 0)
                        return (tab[n].val);
        return (0);
        }
#pragma warning(default:4273)
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wdllargv.c ===
/***
*wdllargv.c - Dummy _wsetargv() routine for use with C Run-Time as a DLL (CRTDLL)
*             (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object goes into CRTDLL.LIB, which is linked with user programs
*       to use CRTDLL.DLL for C run-time library functions.  If the user
*       program links explicitly with WSETARGV.OBJ, this object will not be
*       linked in, and the _wsetargv() that does get called with set the flag
*       that will enable wildcard expansion.  If WSETARGV.OBJ is not linked
*       into the EXE, this object will get called by the CRT start-up stub
*       and the flag to enable wildcard expansion will not be set.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "dllargv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexecl.c ===
/***
*wexecl.c - execute a file with a list of arguments (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexecl() - execute a file with a list of arguments
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execl.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexecle.c ===
/***
*wexecle.c - execute a file with arg list and environment (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexecle() - execute a file
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execle.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexeclpe.c ===
/***
*wexeclpe.c - execute a file (search along PATH) (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexeclpe() - execute a file and search along PATH
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execlpe.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexeclp.c ===
/***
*wexeclp.c - execute a file (search along PATH) (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexeclp() - execute a file and search along PATH
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execlp.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexecv.c ===
/***
*wexecv.c - execute a file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexecv() - execute a file
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexecve.c ===
/***
*wexecve.c - execute a file with a given environment (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexecve() - execute a file
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#define EXECVE
#include "spawnve.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexecvp.c ===
/***
*wexecvp.c - execute a file and search along PATH (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexecvp() - execute a file and search along PATH
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execvp.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wexecvpe.c ===
/***
*wexecvpe.c - execute a file with given environ; search along PATH (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wexecvpe() - execute a file with given environ
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "execvpe.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfndfi32.c ===
/***
*wfndfi32.c - C find file functions (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wfindfirst64i32() and _wfindnext64i32().
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE
#define _UNICODE    1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE     1
#endif  /* UNICODE */

#undef  _MBCS        /* UNICODE not _MBCS */

#define _USE_INT64  0

#include "findf64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfndfi64.c ===
/***
*wfndfi64.c - C find file functions (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wfindfirsti64() and _wfindnexti64().
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE
#define _UNICODE    1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE     1
#endif  /* UNICODE */

#undef _MBCS        /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfdopen.c ===
/***
*wfdopen.c - open a file descriptor as stream (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wfdopen() - opens a file descriptor as a stream, thus allowing
*       buffering, etc.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "fdopen.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfopen.c ===
/***
*wfopen.c - open a file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wfopen() and _wfsopen() - open a file as a stream and open a file
*       with a specified sharing mode as a stream
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "fopen.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfndf64.c ===
/***
*wfndf64.c - C find file functions (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wfindfirst64() and _wfindnext64().
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE
#define _UNICODE    1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE     1
#endif  /* UNICODE */

#undef  _MBCS        /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "findf64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfindfil.c ===
/***
*wfindfile.c - C find file functions (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wfindfirst(), _wfindnext(), and _wfindclose().
*
*******************************************************************************/

#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfreopen.c ===
/***
*wfreope.c - close a stream and assign it to a new file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wfreopen() - close and reopen file, typically used to redirect
*       stdin/out/err/prn/aux.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "freopen.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wfullpat.c ===
/***
*wfullpath.c - (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose: contains the function _wfullpath which makes an absolute path out
*       of a relative path. i.e.  ..\pop\..\main.c => c:\src\main.c if the
*       current directory is c:\src\src
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "fullpath.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wgetcwd.c ===
/***
*wgetcwd.c - get current working directory (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       contains functions _getcwd, _getdcwd and _getcdrv for getting the
*       current working directory.  getcwd gets the c.w.d. for the default disk
*       drive, whereas _getdcwd allows one to get the c.w.d. for whatever disk
*       drive is specified. _getcdrv gets the current drive.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "getcwd.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wgetenv.c ===
/***
*wgetenv.c - get the value of an environment variable (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wgetenv() - searches the environment for a string variable
*       and returns the value of it.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "getenv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wgetpath.c ===
/***
*wgetpath.c - extract a pathname from an environment variable (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Extract pathnames from a string of semicolon delimited pathnames
*       (generally the value of an environment variable such as PATH).
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "getpath.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wildcard.c ===
/***
*wildcard.c - define the CRT internal variable _dowildcard
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This variable is not public to users but is defined outside the
*       start-up code (CRTEXE.C) to reduce duplicate definitions.
*
*******************************************************************************/

#if (defined (CRTDLL) || defined (MRTDLL))

#ifdef CRTDLL
#undef CRTDLL
#endif  /* CRTDLL */

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <internal.h>

int _dowildcard = 0;    /* should be in <internal.h> */

#endif  /* (defined (CRTDLL) || defined (MRTDLL)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wincrt0.c ===
/***
*wincrt0.c - C runtime Windows EXE start-up routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps.  It calls the
*       user's main routine WinMain() after performing C Run-Time Library
*       initialization.
*
*******************************************************************************/


#define _WINMAIN_
#include "crt0.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wincmdln.c ===
/***
*wincmdln.c - process command line for WinMain
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prepare command line to be passed to [w]WinMain.
*
*******************************************************************************/

#include <internal.h>
#include <windows.h>
#include <tchar.h>

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

/***
*_[w]wincmdln
*
*Purpose:
*       Extract the command line tail to be passed to WinMain.
*
*       Be warned! This code was originally implemented by the NT group and
*       has remained pretty much unchanged since 12-91. It should be changed
*       only with extreme care since there are undoubtedly many apps which
*       depend on its historical behavior.
*
*Entry:
*       The global variable _[a|w]cmdln is set to point at the complete
*       command line.
*
*Exit:
*       Returns a pointer to the command line tail.
*
*Exceptions:
*
*******************************************************************************/

_TUCHAR * __cdecl
#ifdef WPRFLAG
_wwincmdln(
#else  /* WPRFLAG */
_wincmdln(
#endif  /* WPRFLAG */
        void
        )
{
        _TUCHAR *lpszCommandLine;
        BOOL inDoubleQuote=FALSE;

#ifdef _MBCS
        /*
         * If necessary, initialize the multibyte ctype table
         */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif  /* _MBCS */

        /*
         * Skip past program name (first token in command line).
         * Check for and handle quoted program name.
         */
#ifdef WPRFLAG
        lpszCommandLine = _wcmdln == NULL ? L"" : (wchar_t *)_wcmdln;
#else  /* WPRFLAG */
        lpszCommandLine = _acmdln == NULL ? "" : (unsigned char *)_acmdln;
#endif  /* WPRFLAG */

        while (*lpszCommandLine > SPACECHAR ||
               (*lpszCommandLine&&inDoubleQuote)) {
            /*
             * Flip the inDoubleQuote if current character is DOUBLEQUOTE
             */
            if (*lpszCommandLine==DQUOTECHAR) inDoubleQuote=!inDoubleQuote;
#ifdef _MBCS
            if (_ismbblead(*lpszCommandLine))
                if (lpszCommandLine)
                    lpszCommandLine++;
#endif  /* _MBCS */
            ++lpszCommandLine;
        }

        /*
         * Skip past any white space preceeding the second token.
         */
        while (*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
            lpszCommandLine++;

        return lpszCommandLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wild.c ===
/***
*wild.c - wildcard expander
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*        expands wildcards in argv
*
*        handles '*' (none or more of any char) and '?' (exactly one char)
*
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>
#include <limits.h>

#ifdef _MBCS
#include <mbdata.h>
#include <mbstring.h>
#endif  /* _MBCS */
#include <dbgint.h>

/*
** these are the data structures
**
**     __argv
**     -------     ------
**     |     |---->|    |---->"arg0"
**     -------     ------
**                 |    |---->"arg1"
**                 ------
**                  ....
**                 ------
**                 |    |---->"argn"
**                 ------
**                 |NULL|
**                 ------
**                                       argend
**                                       -------
**     -------                           |     |
**     |     | __argc                    -------
**     -------                              |
**                                          |
**  arghead                                 V
**  ------     ---------                ----------
**  |    |---->|   |   |----> .... ---->|   |NULL|
**  ------     ---------                ----------
**               |                        |
**               V                        V
**            "narg0"                  "nargn"
*/

/* local function tchars */
#ifdef WPRFLAG
#define tmatch  wmatch
#define tadd    wadd
#define tsort   wsort
#define tfind   wfind
#else  /* WPRFLAG */
#define tmatch  match
#define tadd    add
#define tsort   sort
#define tfind   find
#endif  /* WPRFLAG */

#define SLASHCHAR       _T('\\')
#define FWDSLASHCHAR    _T('/')
#define COLONCHAR       _T(':')
#define QUOTECHAR       _T('"')

#define SLASH           _T("\\")
#define FWDSLASH        _T("/")
#define STAR            _T("*.*")
#define DOT             _T(".")
#define DOTDOT          _T("..")

#define WILDSTRING      _T("*?")

struct argnode {
    _TSCHAR *argptr;
    struct argnode *nextnode;
};

static struct argnode *arghead;
static struct argnode *argend;

#ifdef WPRFLAG
static int __cdecl wmatch(wchar_t *, wchar_t *);
static int __cdecl wadd(wchar_t *);
static void __cdecl wsort(struct argnode *);
static wchar_t * __cdecl wfind (wchar_t *pattern);
#else  /* WPRFLAG */
static int __cdecl match(char *, char *);
static int __cdecl add(char *);
static void __cdecl sort(struct argnode *);
static char * __cdecl find (char *pattern);
#endif  /* WPRFLAG */

/***
*int _cwild() - wildcard expander
*
*Purpose:
*       expands wildcard in file specs in argv
*
*       handles '*' (none or more of any char), '?' (exactly one char), and
*       '[string]' (chars which match string chars or between n1 and n2
*       if 'n1-n2' in string inclusive)
*
*Entry:
*
*Exit:
*       returns 0 if successful, -1 if any malloc() calls fail
*       if problems with malloc, the old argc and argv are not touched
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wcwild (
#else  /* WPRFLAG */
int __cdecl _cwild (
#endif  /* WPRFLAG */
        void
        )
{
#ifdef WPRFLAG
        REG1 wchar_t **argv = __wargv;
#else  /* WPRFLAG */
        REG1 char **argv = __argv;
#endif  /* WPRFLAG */
        REG2 struct argnode *nodeptr;
        REG3 int argc;
        REG4 _TSCHAR **tmp;
        _TSCHAR *wchar;

        arghead = argend = NULL;

#ifdef WPRFLAG
        for (argv = __wargv; *argv; argv++) /* for each arg... */
#else  /* WPRFLAG */
        for (argv = __argv; *argv; argv++)  /* for each arg... */
#endif  /* WPRFLAG */
        {
            *(*argv)++; // the first character of the argument is dropped
            /*
               - native case: all the arguments that were not within quotes
               in the command line have their first character duplicated.
               - native/managed case: all the arguments that were within quotes
               in the command line "arrive" here without the ending quote.
               - managed case: all the arguments that were not within quotes
               in the command line "arrive" here with a starting quote.
               The algorithm was initially designed not to expand the arguments
               within quotes and this is the reason for the first added character
               (to check if an expansion is desired and to be removed after that).
               In future this character will not be added anymore, but until there
               will be decided so, it must still be removed.
            */

            // if wild required --> expand, else only add.
                if (wchar = _tcspbrk( *argv, WILDSTRING)) {
                if (tmatch( *argv, wchar )) return (-1);
                }
            else {
                if (tadd(*argv)) return (-1);
            }
        }
        /* count the args */
        for (argc = 0, nodeptr = arghead; nodeptr;
                nodeptr = nodeptr->nextnode, argc++)
            ;

        /* try to get new arg vector */
        if (!(tmp = (_TSCHAR **)_calloc_crt(sizeof(_TSCHAR *),(argc+1))))
            return(-1);

        /* the new arg vector... */
#ifdef WPRFLAG
        __wargv = tmp;
#else  /* WPRFLAG */
        __argv = tmp;
#endif  /* WPRFLAG */

        /* the new arg count... */
        __argc = argc;

        /* install the new args */
        for (nodeptr = arghead; nodeptr; nodeptr = nodeptr->nextnode)
            *tmp++ = nodeptr->argptr;

        /* the terminal NULL */
        *tmp = NULL;

        /* free up local data */
        for (nodeptr = arghead; nodeptr; nodeptr = arghead) {
            arghead = arghead->nextnode;
            _free_crt(nodeptr);
        }

        /* return success */
        return(0);
}


/***
*match(arg, ptr) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wmatch (
#else  /* WPRFLAG */
static int __cdecl match (
#endif  /* WPRFLAG */
        REG4 _TSCHAR *arg,
        REG1 _TSCHAR *ptr
        )
{
        REG2 _TSCHAR *new;
        REG3 int length = 0;
        _TSCHAR *all;
        REG5 struct argnode *first;
        REG6 int gotone = 0;

        if(!ptr)
        {
                return -1;
        }

        while (ptr != arg && *ptr != SLASHCHAR && *ptr != FWDSLASHCHAR
            && *ptr != COLONCHAR) {
            /* find first slash or ':' before wildcard */
#ifdef _MBCS
            if (--ptr > arg)
                ptr = _mbsdec(arg,ptr+1);
#else  /* _MBCS */
            ptr--;
#endif  /* _MBCS */
        }

        if (*ptr == COLONCHAR && ptr != arg+1) /* weird name, just add it as is */
            return(tadd(arg));

        if (*ptr == SLASHCHAR || *ptr == FWDSLASHCHAR
            || *ptr == COLONCHAR) /* pathname */
            length = (int)(ptrdiff_t)(ptr - arg + 1); /* length of dir prefix */

        if (new = tfind(arg)) { /* get the first file name */
            first = argend;

            do  { /* got a file name */
                if (_tcscmp(new, DOT) && _tcscmp(new, DOTDOT)) {
                    if (*ptr != SLASHCHAR && *ptr != COLONCHAR
                        && *ptr != FWDSLASHCHAR ) {
                        /* current directory; don't need path */
#ifdef _DEBUG
                        size_t arg_size = _tcslen(new) + 1;
                        if (!(arg=_calloc_crt(arg_size,sizeof(_TSCHAR))))
                        {
                            return -1;
                        }
                        _ERRCHECK(_tcscpy_s(arg, arg_size, new));
                        if (tadd(arg))
                        {
                            return -1;
                        }
#else  /* _DEBUG */
                        if (!(arg = _tcsdup(new)) || tadd(arg))
                            return(-1);
#endif  /* _DEBUG */
                    }
                    else
                    {
                        /* add full pathname */
                        size_t all_size = length + _tcslen(new) + 1;
                        if (length < 0 ||
                            all_size >= (SIZE_MAX / sizeof(_TSCHAR)) ||
                            all_size < (size_t)length ||
                            (all = _calloc_crt(all_size, sizeof(_TSCHAR))) == NULL)
                        {
                            return -1;
                        }
                        _ERRCHECK(_tcsncpy_s(all, all_size, arg, length));
                        _ERRCHECK(_tcscpy_s(all + length, all_size - length, new));
                        if (tadd(all))
                        {
                            return -1;
                        }
                    }

                    gotone++;
                }

            }
            while (new = tfind(NULL));  /* get following files */

            if (gotone) {
                tsort(first ? first->nextnode : arghead);
                return(0);
            }
        }

        return(tadd(arg)); /* no match */
}

/***
*add(arg) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wadd (
#else  /* WPRFLAG */
static int __cdecl add (
#endif  /* WPRFLAG */
    _TSCHAR *arg
    )
{
        REG1 struct argnode *nodeptr;

        if (!(nodeptr = (struct argnode *)_malloc_crt(sizeof(struct argnode))))
            return(-1);

        nodeptr->argptr = arg;
        nodeptr->nextnode = NULL;

        if (arghead)
            argend->nextnode = nodeptr;
        else
            arghead = nodeptr;

        argend = nodeptr;
        return(0);
}


/***
*sort(first) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static void __cdecl wsort (
#else  /* WPRFLAG */
static void __cdecl sort (
#endif  /* WPRFLAG */
        REG2 struct argnode *first
        )
{
        REG1 struct argnode *nodeptr;
        REG3 _TSCHAR *temp;

        if (first) /* something to sort */
            while (nodeptr = first->nextnode) {
                do  {
                    if (_tcsicmp(nodeptr->argptr, first->argptr) < 0) {
                        temp = first->argptr;
                        first->argptr = nodeptr->argptr;
                        nodeptr->argptr = temp;
                    }
                }
                while (nodeptr = nodeptr->nextnode);

                first = first->nextnode;
            }
}


/***
*find(pattern) - find matching filename
*
*Purpose:
*       if argument is non-null, do a DOSFINDFIRST on that pattern
*       otherwise do a DOSFINDNEXT call.  Return matching filename
*       or NULL if no more matches.
*
*Entry:
*       pattern = pointer to pattern or NULL
*           (NULL means find next matching filename)
*
*Exit:
*       returns pointer to matching file name
*           or NULL if no more matches.
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static wchar_t * __cdecl wfind (
#else  /* WPRFLAG */
static char * __cdecl find (
#endif  /* WPRFLAG */
    _TSCHAR *pattern
    )
{
        _TSCHAR *retval;

        static HANDLE _WildFindHandle;
        static LPWIN32_FIND_DATA findbuf;

        if (pattern) {
            if (findbuf == NULL)
                if ((findbuf = (LPWIN32_FIND_DATA)_malloc_crt(MAX_PATH + sizeof(*findbuf))) == NULL)
                    return NULL;

            if (_WildFindHandle != NULL) {
                (void)FindClose( _WildFindHandle );
                _WildFindHandle = NULL;
            }

            _WildFindHandle = FindFirstFileEx(pattern, FindExInfoStandard, findbuf, FindExSearchNameMatch, NULL, 0);
            if (_WildFindHandle == INVALID_HANDLE_VALUE)
                return NULL;
        }
        else if (!FindNextFile( _WildFindHandle, findbuf )) {
            (void)FindClose( _WildFindHandle );
            _WildFindHandle = NULL;
            return NULL;
        }

        retval = findbuf->cFileName;

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\winsig.c ===
/***
*winsig.c - C signal support
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines signal(), raise() and supporting functions.
*
*******************************************************************************/


#include <cruntime.h>
#include <errno.h>
#include <float.h>
#include <malloc.h>
#include <mtdll.h>
#include <oscalls.h>
#include <signal.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <dbgint.h>
#include <internal.h>

/*
 * look up the first entry in the exception-action table corresponding to
 * the given signal
 */
static struct _XCPT_ACTION * __cdecl siglookup(int, struct _XCPT_ACTION *);

/*
 * variables holding action codes (and code pointers) for SIGINT, SIGBRK,
 * SIGABRT and SIGTERM.
 *
 * note that the disposition (i.e., action to be taken upon receipt) of
 * these signals is defined on a per-process basis (not per-thread)!!
 */

static _PHNDLR ctrlc_action       = SIG_DFL;    /* SIGINT   */
static _PHNDLR ctrlbreak_action   = SIG_DFL;    /* SIGBREAK */
static _PHNDLR abort_action       = SIG_DFL;    /* SIGABRT  */
static _PHNDLR term_action        = SIG_DFL;    /* SIGTERM  */

/*
 * flag indicated whether or not a handler has been installed to capture
 * ^C and ^Break events.
 */
static int ConsoleCtrlHandler_Installed = 0;

#define _SIGHUP_IGNORE 1
#define _SIGQUIT_IGNORE 3
#define _SIGPIPE_IGNORE 13
#define _SIGIOINT_IGNORE 16
#define _SIGSTOP_IGNORE 17

void __cdecl _initp_misc_winsig(void* enull)
{
    ctrlc_action       = (_PHNDLR) enull;    /* SIGINT   */
    ctrlbreak_action   = (_PHNDLR) enull;    /* SIGBREAK */
    abort_action       = (_PHNDLR) enull;    /* SIGABRT  */
    term_action        = (_PHNDLR) enull;    /* SIGTERM  */
}

/***
*static BOOL WINAPI ctrlevent_capture(DWORD CtrlType) - capture ^C and ^Break events
*
*Purpose:
*       Capture ^C and ^Break events from the console and dispose of them
*       according the values in ctrlc_action and ctrlbreak_action, resp.
*       This is the routine that evokes the user-defined action for SIGINT
*       (^C) or SIGBREAK (^Break) installed by a call to signal().
*
*Entry:
*       DWORD CtrlType  - indicates type of event, two values:
*                               CTRL_C_EVENT
*                               CTRL_BREAK_EVENT
*
*Exit:
*       Returns TRUE to indicate the event (signal) has been handled.
*       Otherwise, returns FALSE.
*
*Exceptions:
*
*******************************************************************************/

static BOOL WINAPI ctrlevent_capture (
        DWORD CtrlType
        )
{
        _PHNDLR ctrl_action;
        _PHNDLR *pctrl_action;
        int sigcode;

        _mlock(_SIGNAL_LOCK);
        __try {
        /*
         * Identify the type of event and fetch the corresponding action
         * description.
         */

        if ( CtrlType == CTRL_C_EVENT ) {
                pctrl_action = &ctrlc_action;
                ctrl_action = (_PHNDLR) DecodePointer(*pctrl_action);
                sigcode = SIGINT;
        }
        else {
                pctrl_action = &ctrlbreak_action;
                ctrl_action = (_PHNDLR) DecodePointer(*pctrl_action);
                sigcode = SIGBREAK;
        }

        if ( !(ctrl_action == SIG_DFL) && !(ctrl_action == SIG_IGN) )
                /*
                 * Reset the action to be SIG_DFL
                 */
                *pctrl_action = (_PHNDLR) _encoded_null();

        }
        __finally {
                _munlock(_SIGNAL_LOCK);
        }

        if ( ctrl_action == SIG_DFL )
                /*
                 * return FALSE, indicating the event has NOT been handled
                 */
                return FALSE;

        if ( ctrl_action != SIG_IGN ) {
                (*ctrl_action)(sigcode);
        }

        /*
         * Return TRUE, indicating the event has been handled (which may
         * mean it's being ignored)
         */
        return TRUE;
}



/***
*_PHNDLR signal(signum, sigact) - Define a signal handler
*
*Purpose:
*       The signal routine allows the user to define what action should
*       be taken when various signals occur. The Win32/Dosx32 implementation
*       supports seven signals, divided up into three general groups
*
*       1. Signals corresponding to OS exceptions. These are:
*                       SIGFPE
*                       SIGILL
*                       SIGSEGV
*          Signal actions for these signals are installed by altering the
*          XcptAction and SigAction fields for the appropriate entry in the
*          exception-action table (XcptActTab[]).
*
*       2. Signals corresponding to ^C and ^Break. These are:
*                       SIGINT
*                       SIGBREAK
*          Signal actions for these signals are installed by altering the
*          _ctrlc_action and _ctrlbreak_action variables.
*
*       3. Signals which are implemented only in the runtime. That is, they
*          occur only as the result of a call to raise().
*                       SIGABRT
*                       SIGTERM
*
*
*Entry:
*       int signum      signal type. recognized signal types are:
*
*                       SIGABRT         (ANSI)
*                       SIGBREAK
*                       SIGFPE          (ANSI)
*                       SIGILL          (ANSI)
*                       SIGINT          (ANSI)
*                       SIGSEGV         (ANSI)
*                       SIGTERM         (ANSI)
*                       SIGABRT_COMPAT
*
*       _PHNDLR sigact  signal handling function or action code. the action
*                       codes are:
*
*                       SIG_DFL - take the default action, whatever that may
*                       be, upon receipt of this type type of signal.
*
*                       SIG_DIE - *** ILLEGAL ***
*                       special code used in the XcptAction field of an
*                       XcptActTab[] entry to indicate that the runtime is
*                       to terminate the process upon receipt of the exception.
*                       not accepted as a value for sigact.
*
*                       SIG_IGN - ignore this type of signal
*
*                       [function address] - transfer control to this address
*                       when a signal of this type occurs.
*
*Exit:
*       Good return:
*       Signal returns the previous value of the signal handling function
*       (e.g., SIG_DFL, SIG_IGN, etc., or [function address]). This value is
*       returned in DX:AX.
*
*       Error return:
*       Signal returns -1 and errno is set to EINVAL. The error return is
*       generally taken if the user submits bogus input values.
*
*Exceptions:
*       None.
*
*******************************************************************************/

_PHNDLR __cdecl signal(
        int signum,
        _PHNDLR sigact
        )
{
        struct _XCPT_ACTION *pxcptact;
        _PHNDLR oldsigact;
        int Error=0;
        _ptiddata ptd;
        BOOL SetConsoleCtrlError = FALSE;

        /*
         * Check for values of sigact supported on other platforms but not
         * on this one. Also, make sure sigact is not SIG_DIE
         */
        if ( (sigact == SIG_ACK) || (sigact == SIG_SGE) )
                goto sigreterror;

        /*
         * Take care of all signals which do not correspond to exceptions
         * in the host OS. Those are:
         *
         *                      SIGINT
         *                      SIGBREAK
         *                      SIGABRT
         *                      SIGTERM
         *
         */
        if ( (signum == SIGINT) || (signum == SIGBREAK) || (signum == SIGABRT)
            || (signum == SIGABRT_COMPAT) || (signum == SIGTERM) ) {

                _mlock( _SIGNAL_LOCK );
                __try {

                /*
                 * if SIGINT or SIGBREAK, make sure the handler is installed
                 * to capture ^C and ^Break events.
                 */
                if ( ((signum == SIGINT) || (signum == SIGBREAK)) &&
                    !ConsoleCtrlHandler_Installed )
                                {
                        if ( SetConsoleCtrlHandler(ctrlevent_capture, TRUE)
                            == TRUE )
                                                {
                                ConsoleCtrlHandler_Installed = TRUE;
                                                }
                        else
                                                {
                                _doserrno = GetLastError();
                                                                SetConsoleCtrlError=TRUE;
                        }
                                }

                switch (signum) {

                        case SIGINT:
                                oldsigact = (_PHNDLR) DecodePointer(ctrlc_action);
                                if(sigact!=SIG_GET)
                                {
                                    ctrlc_action = (_PHNDLR) EncodePointer(sigact);
                                }
                                break;

                        case SIGBREAK:
                                oldsigact = (_PHNDLR) DecodePointer(ctrlbreak_action);
                                if(sigact!=SIG_GET)
                                {
                                    ctrlbreak_action = (_PHNDLR) EncodePointer(sigact);
                                }
                                break;

                        case SIGABRT:
                        case SIGABRT_COMPAT:
                                oldsigact = (_PHNDLR) DecodePointer(abort_action);
                                if(sigact!=SIG_GET)
                                {
                                    abort_action = (_PHNDLR) EncodePointer(sigact);
                                }
                                break;

                        case SIGTERM:
                                oldsigact = (_PHNDLR) DecodePointer(term_action);
                                if(sigact!=SIG_GET)
                                {
                                    term_action = (_PHNDLR) EncodePointer(sigact);
                                }
                                break;
                }

                }
                __finally {
                        _munlock( _SIGNAL_LOCK );
                }

                if (SetConsoleCtrlError) {
                    goto sigreterror;
                }
                goto sigretok;
        }

        /*
         * If we reach here, signum is supposed to be one the signals which
         * correspond to exceptions in the host OS. Those are:
         *
         *                      SIGFPE
         *                      SIGILL
         *                      SIGSEGV
         */

        /*
         * Make sure signum is one of the remaining supported signals.
         */
        if ( (signum != SIGFPE) && (signum != SIGILL) && (signum != SIGSEGV) )
                goto sigreterror;


        /*
         * Fetch the tid data table entry for this thread
         */
        ptd = _getptd_noexit();
        if (!ptd)
            goto sigreterror;

        /*
         * Check that there a per-thread instance of the exception-action
         * table for this thread. if there isn't, create one.
         */
        if ( ptd->_pxcptacttab == _XcptActTab )
                /*
                 * allocate space for an exception-action table
                 */
                if ( (ptd->_pxcptacttab = _malloc_crt(_XcptActTabSize)) != NULL )
                        /*
                         * initialize the table by copying over the contents
                         * of _XcptActTab[]
                         */
                        (void) memcpy(ptd->_pxcptacttab, _XcptActTab,
                            _XcptActTabSize);
                else
                        /*
                         * cannot create exception-action table, return
                         * error to caller
                         */
                        goto sigreterror;

        /*
         * look up the proper entry in the exception-action table. note that
         * if several exceptions are mapped to the same signal, this returns
         * the pointer to first such entry in the exception action table. it
         * is assumed that the other entries immediately follow this one.
         */
        if ( (pxcptact = siglookup(signum, ptd->_pxcptacttab)) == NULL )
                goto sigreterror;

        /*
         * SIGSEGV, SIGILL and SIGFPE all have more than one exception mapped
         * to them. the code below depends on the exceptions corresponding to
         * the same signal being grouped together in the exception-action
         * table.
         */

        /*
         * store old signal action code for return value
         */
        oldsigact = pxcptact->XcptAction;

        if(sigact!=SIG_GET)
        {
            /*
            * loop through all entries corresponding to the
            * given signal and update the SigAction and XcptAction
            * fields as appropriate
            */

            while ( pxcptact->SigNum == signum ) {
                    /*
                    * take care of the SIG_IGN and SIG_DFL action
                    * codes
                    */
                    pxcptact->XcptAction = sigact;

                    /*
                    * make sure we don't run off the end of the table
                    */
                    if ( ++pxcptact >= ((struct _XCPT_ACTION *)(ptd->_pxcptacttab)
                                       + _XcptActTabCount) )
                        break;
            }
        }

sigretok:
        return(oldsigact);

sigreterror:
        switch(signum)
        {
        case _SIGHUP_IGNORE:
        case _SIGQUIT_IGNORE:
        case _SIGPIPE_IGNORE:
        case _SIGIOINT_IGNORE:
        case _SIGSTOP_IGNORE:
            return SIG_ERR;
        default:
            _VALIDATE_RETURN(("Invalid signal or error", 0), EINVAL, SIG_ERR);
            /* should never happen, but compiler can't tell */
            return SIG_ERR;
        }
}

/***
*int raise(signum) - Raise a signal
*
*Purpose:
*       This routine raises a signal (i.e., performs the action currently
*       defined for this signal). The action associated with the signal is
*       evoked directly without going through intermediate dispatching or
*       handling.
*
*Entry:
*       int signum - signal type (e.g., SIGINT)
*
*Exit:
*       returns 0 on good return, -1 on bad return.
*
*Exceptions:
*       May not return.  Raise has no control over the action
*       routines defined for the various signals.  Those routines may
*       abort, terminate, etc.  In particular, the default actions for
*       certain signals will terminate the program.
*
*******************************************************************************/


int __cdecl raise (
        int signum
        )
{
        _PHNDLR sigact;
        _PHNDLR *psigact;
        PEXCEPTION_POINTERS oldpxcptinfoptrs;
        int oldfpecode;
        int indx;

        int siglock = 0;
        _ptiddata ptd=NULL;

        switch (signum) {

                case SIGINT:
                        sigact = *(psigact = &ctrlc_action);
                        siglock++;
                        break;

                case SIGBREAK:
                        sigact = *(psigact = &ctrlbreak_action);
                        siglock++;
                        break;

                case SIGABRT:
                case SIGABRT_COMPAT:
                        sigact = *(psigact = &abort_action);
                        siglock++;
                        break;

                case SIGTERM:
                        sigact = *(psigact = &term_action);
                        siglock++;
                        break;

                case SIGFPE:
                case SIGILL:
                case SIGSEGV:
                        ptd = _getptd_noexit();
                        if (!ptd)
                            return (-1);
                        sigact = *(psigact = &(siglookup( signum,
                            ptd->_pxcptacttab )->XcptAction));
                        goto decode_done;
                        break;

                default:
                        /*
                         * unsupported signal, return an error
                         */
                        _VALIDATE_RETURN(("Invalid signal or error", 0), EINVAL, -1);
        }
        sigact = (_PHNDLR) DecodePointer(sigact);

decode_done:

        /*
         * If the current action is SIG_IGN, just return
         */
        if ( sigact == SIG_IGN )
                return(0);

        /*
         * If the current action is SIG_DFL, take the default action
         */
        if ( sigact == SIG_DFL ) {
                /*
                 * The current default action for all of the supported
                 * signals is to terminate with an exit code of 3.
                 */
                _exit(3);
        }

        /*
         * if signum is one of the 'process-wide' signals (i.e., SIGINT,
         * SIGBREAK, SIGABRT or SIGTERM), assert _SIGNAL_LOCK.
         */
        if ( siglock )
                _mlock(_SIGNAL_LOCK);

        __try {
        /*
         * From here on, sigact is assumed to be a pointer to a user-supplied
         * handler.
         */

        /*
         * For signals which correspond to exceptions, set the pointer
         * to the EXCEPTION_POINTERS structure to NULL
         */
        if ( (signum == SIGFPE) || (signum == SIGSEGV) ||
            (signum == SIGILL) ) {
                oldpxcptinfoptrs = ptd->_tpxcptinfoptrs;
                ptd->_tpxcptinfoptrs = NULL;

                 /*
                  * If signum is SIGFPE, also set _fpecode to
                  * _FPE_EXPLICITGEN
                  */
                if ( signum == SIGFPE ) {
                        oldfpecode = ptd->_tfpecode;
                        ptd->_tfpecode = _FPE_EXPLICITGEN;
                }
        }

        /*
         * Reset the action to SIG_DFL and call the user specified handler
         * routine.
         */
        if ( signum == SIGFPE )
                /*
                 * for SIGFPE, must reset the action for all of the floating
                 * point exceptions
                 */
                for ( indx = _First_FPE_Indx ;
                      indx < _First_FPE_Indx + _Num_FPE ;
                      indx++ )
                {
                        ( (struct _XCPT_ACTION *)(ptd->_pxcptacttab) +
                          indx )->XcptAction = SIG_DFL;
                }
        else
                *psigact = (_PHNDLR) _encoded_null();

        }
        __finally {
                if ( siglock )
                        _munlock(_SIGNAL_LOCK);
        }

        if ( signum == SIGFPE )
                /*
                 * Special code to support old SIGFPE handlers which
                 * expect the value of _fpecode as the second argument.
                 */
                (*(void (__cdecl *)(int,int))sigact)(SIGFPE,
                    ptd->_tfpecode);
        else
                (*sigact)(signum);

        /*
         * For signals which correspond to exceptions, restore the pointer
         * to the EXCEPTION_POINTERS structure.
         */
        if ( (signum == SIGFPE) || (signum == SIGSEGV) ||
            (signum == SIGILL) ) {
                ptd->_tpxcptinfoptrs = oldpxcptinfoptrs;

                 /*
                  * If signum is SIGFPE, also restore _fpecode
                  */
                if ( signum == SIGFPE )
                        ptd->_tfpecode = oldfpecode;
        }

        return(0);
}


/***
*struct _XCPT_ACTION *siglookup(int signum) - look up exception-action table
*       entry for signal.
*
*Purpose:
*       Find the first entry int _XcptActTab[] whose SigNum field is signum.
*
*Entry:
*       int signum - C signal type (e.g., SIGINT)
*
*Exit:
*       If successful, pointer to the table entry. If no such entry, NULL is
*       returned.
*
*Exceptions:
*
*******************************************************************************/

static struct _XCPT_ACTION * __cdecl siglookup (
        int signum,
        struct _XCPT_ACTION *pxcptacttab
        )
{
        struct _XCPT_ACTION *pxcptact = pxcptacttab;
        /*
         * walk thru the _xcptactab table looking for the proper entry. note
         * that in the case where more than one exception corresponds to the
         * same signal, the first such instance in the table is the one
         * returned.
         */

        while ( (pxcptact->SigNum != signum) &&
                (++pxcptact < pxcptacttab + _XcptActTabCount) ) ;

        if ( (pxcptact < (pxcptacttab + _XcptActTabCount)) &&
             (pxcptact->SigNum == signum) )
                /*
                 * found a table entry corresponding to the signal
                 */
                return(pxcptact);
        else
                /*
                 * found no table entry corresponding to the signal
                 */
                return(NULL);
}


/***
*_PHNDLR __cdecl __get_sigabrt(void) - return the SIGABRT signal handling function
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_PHNDLR __cdecl __get_sigabrt(void)
{
    return (_PHNDLR) DecodePointer(abort_action);
}



/***
*int *__fpecode(void) - return pointer to _fpecode field of the tidtable entry
*       for the current thread
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int * __cdecl __fpecode (
        void
        )
{
        return( &(_getptd()->_tfpecode) );
}


/***
*void **__pxcptinfoptrs(void) - return pointer to _pxcptinfoptrs field of the
*       tidtable entry for the current thread
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void ** __cdecl __pxcptinfoptrs (
        void
        )
{
        return( &(_getptd()->_tpxcptinfoptrs) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\winputs.c ===
/***
*winputs.c - wscanf style input from a FILE with size
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#define _SECURE_SCANF
#include "input.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\winput.c ===
/***
*winput.c - wscanf style input from a FILE (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the symbol UNICODE and then #includes the file
*       "input.c" in order to implement _winput(), the helper for the
*       wide character versions of the *wscanf() family of functions.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "input.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\winheap.h ===
/***
*winheap.h - Private include file for winheap directory.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains information needed by the C library heap code.
*
*       [Internal]
*
****/

#pragma once

#ifndef _INC_WINHEAP
#define _INC_WINHEAP

#include <crtdefs.h>

#pragma pack(push,_CRT_PACKING)

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#include <sal.h>
#include <windows.h>


#define BYTES_PER_PARA      16
#define PARAS_PER_PAGE      256     /*  tunable value */
#define BYTES_PER_PAGE      (BYTES_PER_PARA * PARAS_PER_PAGE)

extern  HANDLE _crtheap;

_Check_return_  _Ret_opt_bytecap_(_Size) void * __cdecl _nh_malloc(_In_ size_t _Size, _In_ int _NhFlag);
_Check_return_  _Ret_opt_bytecap_(_Size) void * __cdecl _heap_alloc(_In_ size_t _Size);

extern int     __cdecl _heap_init(void);
extern void    __cdecl _heap_term(void);

_Check_return_ _Ret_opt_bytecap_(_Size) extern _CRTIMP void *  __cdecl _malloc_base(_In_ size_t _Size);

extern _CRTIMP void    __cdecl _free_base(_Post_ptr_invalid_ void * _Memory);
_Success_(return!=0)
_Check_return_ _Ret_opt_bytecap_(_NewSize) extern void *  __cdecl _realloc_base(_Post_ptr_invalid_  void * _Memory, _In_ size_t _NewSize);
_Success_(return!=0)
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) extern void *  __cdecl _recalloc_base(_Post_ptr_invalid_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size);

_Check_return_ _Ret_opt_bytecap_(_NewSize) extern void *  __cdecl _expand_base(_Pre_notnull_ void * _Memory, _In_ size_t _NewSize);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) extern void *  __cdecl _calloc_base(_In_ size_t _Count, _In_ size_t _Size);

_Check_return_ extern size_t  __cdecl _msize_base(_Pre_notnull_ void * _Memory);
_Check_return_ extern size_t  __cdecl _aligned_msize_base(_Pre_notnull_ void * _Memory, _In_ size_t _Alignment, _In_ size_t _Offset);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#pragma pack(pop)

#endif  /* _INC_WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wiostrea.cpp ===
// wiostream -- _Winit members, dummy for Microsoft
#include <iostream>
_STD_BEGIN

		// OBJECT DECLARATIONS
__PURE_APPDOMAIN_GLOBAL int _Winit::_Init_cnt = -1;

_CRTIMP2_PURE __thiscall _Winit::_Winit()
	{	// initialize standard wide streams first time
	if (0 <= _Init_cnt)
		++_Init_cnt;
	else
		_Init_cnt = 1;
	}

_CRTIMP2_PURE __thiscall _Winit::~_Winit()
	{	// flush standard wide streams last time
	if (--_Init_cnt == 0)
		{	// flush standard wide streams
		if (_Ptr_wcout != 0)
			_Ptr_wcout->flush();
		if (_Ptr_wcerr != 0)
			_Ptr_wcerr->flush();
		if (_Ptr_wclog != 0)
			_Ptr_wclog->flush();
		}
_STD_END
	}

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\winxfltr.c ===
/***
*winxfltr.c - startup exception filter
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _XcptFilter(), the function called by the exception filter
*       expression in the startup code.
*
*******************************************************************************/


#include <cruntime.h>
#include <float.h>
#include <mtdll.h>
#include <oscalls.h>
#include <signal.h>
#include <stddef.h>
#include <internal.h>


/*
 * special code denoting no signal.
 */
#define NOSIG   -1


const struct _XCPT_ACTION _XcptActTab[] = {

/*
 * Exceptions corresponding to the same signal (e.g., SIGFPE) must be grouped
 * together.
 *
 * If any XcptAction field is changed in this table, that field must be
 * initialized with an encoded function pointer at CRT initialization time.
 *
 *        XcptNum                                        SigNum    XcptAction
 *        -------------------------------------------------------------------
 */
        { (unsigned long)STATUS_ACCESS_VIOLATION,         SIGSEGV, SIG_DFL },

        { (unsigned long)STATUS_ILLEGAL_INSTRUCTION,      SIGILL,  SIG_DFL },

        { (unsigned long)STATUS_PRIVILEGED_INSTRUCTION,   SIGILL,  SIG_DFL },

/*      { (unsigned long)STATUS_NONCONTINUABLE_EXCEPTION, NOSIG,   SIG_DIE },
 */
/*      { (unsigned long)STATUS_INVALID_DISPOSITION,      NOSIG,   SIG_DIE },
 */
        { (unsigned long)STATUS_FLOAT_DENORMAL_OPERAND,   SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_DIVIDE_BY_ZERO,     SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_INEXACT_RESULT,     SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_INVALID_OPERATION,  SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_OVERFLOW,           SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_STACK_CHECK,        SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_UNDERFLOW,          SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_MULTIPLE_FAULTS,    SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_MULTIPLE_TRAPS,     SIGFPE,  SIG_DFL },

/*      { (unsigned long)STATUS_INTEGER_DIVIDE_BY_ZERO,   NOSIG,   SIG_DIE },
 */
/*      { (unsigned long)STATUS_STACK_OVERFLOW,           NOSIG,   SIG_DIE }
 */
};

/*
 * WARNING!!!! The definition below amounts to defining that:
 *
 *                  XcptActTab[ _First_FPE_Indx ]
 *
 * is the very FIRST entry in the table corresponding to a floating point
 * exception. Whenever the definition of the XcptActTab[] table is changed,
 * this #define must be review to ensure correctness.
 */
const int _First_FPE_Indx = 3;

/*
 * There are _Num_FPE (currently, 9) entries in XcptActTab corresponding to
 * floating point exceptions.
 */
const int _Num_FPE = 9;

/*
 * size of the exception-action table (in bytes)
 */
const int _XcptActTabSize = sizeof _XcptActTab;

/*
 * number of entries in the exception-action table
 */
const int _XcptActTabCount = (sizeof _XcptActTab)/sizeof(_XcptActTab[0]);


/*
 * the FPECODE and PXCPTINFOPTRS macros are intended to simplify some of
 * single vs multi-thread code in the filter function. basically, each macro
 * is conditionally defined to be a global variable or the corresponding
 * field in the per-thread data structure. NOTE THE ASSUMPTION THAT THE
 * _ptiddata VARIABLE IS ALWAYS NAMED ptd!!!!
 */

#define FPECODE         ptd->_tfpecode

#define PXCPTINFOPTRS   ptd->_tpxcptinfoptrs

/*
 * function to look up the exception action table (_XcptActTab[]) corresponding
 * to the given exception
 */

static struct _XCPT_ACTION * __cdecl xcptlookup(
        unsigned long,
        struct _XCPT_ACTION *
        );

/***
*int _CppXcptFilter(xcptnum, pxcptptrs) - Wrapper over _XcptFilter so that
*       _XcptFilter only gets called for C++ Exceptions.
*
*******************************************************************************/

int __cdecl __CppXcptFilter (
    unsigned long xcptnum,
    PEXCEPTION_POINTERS pxcptinfoptrs
    )
{
    if (xcptnum==('msc'|0xE0000000)) {
        return _XcptFilter(xcptnum,pxcptinfoptrs);
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

/***
*int _XcptFilter(xcptnum, pxcptptrs) - Identify exception and the action to
*       be taken with it
*
*Purpose:
*       _XcptFilter() is called by the exception filter expression of the
*       _try - _except statement, in the startup code, which guards the call
*       to the user's main(). _XcptFilter() consults the _XcptActTab[] table
*       to identify the exception and determine its disposition. The
*       is disposition of an exception corresponding to a C signal may be
*       modified by a call to signal(). There are three broad cases:
*
*       (1) Unrecognized exceptions and exceptions for which the XcptAction
*           value is SIG_DFL.
*
*           In both of these cases, EXCEPTION_CONTINUE_SEARCH is returned to
*           cause the OS exception dispatcher to pass the exception onto the
*           next exception handler in the chain (usually a system default
*           handler).
*
*       (2) Exceptions corresponding to C signals with an XcptAction value
*           NOT equal to SIG_DFL.
*
*           These are the C signals whose disposition has been affected by a
*           call to signal() or whose default semantics differ slightly from
*           from the corresponding OS exception. In all cases, the appropriate
*           disposition of the C signal is made by the function (e.g., calling
*           a user-specified signal handler). Then, EXCEPTION_CONTINUE_EXECU-
*           TION is returned to cause the OS exception dispatcher to dismiss
*           the exception and resume execution at the point where the
*           exception occurred.
*
*       (3) Exceptions for which the XcptAction value is SIG_DIE.
*
*           These are the exceptions corresponding to fatal C runtime errors.
*           _XCPT_HANDLE is returned to cause control to pass into the
*           _except-block of the _try - _except statement. There, the runtime
*           error is identified, an appropriate error message is printed out
*           and the program is terminated.
*
*Entry:
*
*Exit:
*
*Exceptions:
*       That's what it's all about!
*
*******************************************************************************/

int __cdecl _XcptFilter (
        unsigned long xcptnum,
        PEXCEPTION_POINTERS pxcptinfoptrs
        )
{
        struct _XCPT_ACTION * pxcptact;
        _PHNDLR phandler;
        void *oldpxcptinfoptrs;
        int oldfpecode;
        int indx;

        _ptiddata ptd = _getptd_noexit();
        if (!ptd) {
            // we can't deal with it - pass it on.
            return(EXCEPTION_CONTINUE_SEARCH);
        }

        pxcptact = xcptlookup(xcptnum, ptd->_pxcptacttab);

        if (pxcptact == NULL)
        {
            phandler = SIG_DFL;
        }
        else
        {
            phandler = pxcptact->XcptAction;
        }

        /*
         * first, take care of all unrecognized exceptions and exceptions with
         * XcptAction values of SIG_DFL.
         */
        if ( phandler == SIG_DFL )
                return(EXCEPTION_CONTINUE_SEARCH);



        /*
         * next, weed out all of the exceptions that need to be handled by
         * dying, perhaps with a runtime error message
         */
        if ( phandler == SIG_DIE ) {
                /*
                 * reset XcptAction (in case of recursion) and drop into the
                 * except-clause.
                 */
                pxcptact->XcptAction = SIG_DFL;
                return(EXCEPTION_EXECUTE_HANDLER);
        }

        /*
         * next, weed out all of the exceptions that are simply ignored
         */
        if ( phandler == SIG_IGN )
                /*
                 * resume execution
                 */
                return(EXCEPTION_CONTINUE_EXECUTION);

        /*
         * the remaining exceptions all correspond to C signals which have
         * signal handlers associated with them. for some, special setup
         * is required before the signal handler is called. in all cases,
         * if the signal handler returns, -1 is returned by this function
         * to resume execution at the point where the exception occurred.
         */

        /*
         * save the old value of _pxcptinfoptrs (in case this is a nested
         * exception/signal) and store the current one.
         */
        oldpxcptinfoptrs = PXCPTINFOPTRS;
        PXCPTINFOPTRS = pxcptinfoptrs;

        /*
         * call the user-supplied signal handler
         *
         * floating point exceptions must be handled specially since, from
         * the C point-of-view, there is only one signal. the exact identity
         * of the exception is passed in the global variable _fpecode.
         */
        if ( pxcptact->SigNum == SIGFPE ) {

                /*
                 * reset the XcptAction field to the default for all entries
                 * corresponding to SIGFPE.
                 */
                for ( indx = _First_FPE_Indx ;
                      indx < _First_FPE_Indx + _Num_FPE ;
                      indx++ )
                {
                        ( (struct _XCPT_ACTION *)(ptd->_pxcptacttab) +
                          indx )->XcptAction = SIG_DFL;
                }

                /*
                 * Save the current _fpecode in case it is a nested floating
                 * point exception (not clear that we need to support this,
                 * but it's easy).
                 */
                oldfpecode = FPECODE;

                /*
                 * there are no exceptions corresponding to
                 * following _FPE_xxx codes:
                 *
                 *      _FPE_UNEMULATED
                 *      _FPE_SQRTNEG
                 *
                 * futhermore, STATUS_FLOATING_STACK_CHECK is
                 * raised for both floating point stack under-
                 * flow and overflow. thus, the exception does
                 * not distinguish between _FPE_STACKOVERLOW
                 * and _FPE_STACKUNDERFLOW. arbitrarily, _fpecode
                 * is set to the former value.
                 *
                 * the following should be a switch statement but, alas, the
                 * compiler doesn't like switching on unsigned longs...
                 */
                if ( pxcptact->XcptNum == STATUS_FLOAT_DIVIDE_BY_ZERO )

                        FPECODE = _FPE_ZERODIVIDE;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_INVALID_OPERATION )

                        FPECODE = _FPE_INVALID;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_OVERFLOW )

                        FPECODE = _FPE_OVERFLOW;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_UNDERFLOW )

                        FPECODE = _FPE_UNDERFLOW;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_DENORMAL_OPERAND )

                        FPECODE = _FPE_DENORMAL;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_INEXACT_RESULT )

                        FPECODE = _FPE_INEXACT;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_STACK_CHECK )

                        FPECODE = _FPE_STACKOVERFLOW;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_MULTIPLE_TRAPS )

                        FPECODE = _FPE_MULTIPLE_TRAPS;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_MULTIPLE_FAULTS )

                        FPECODE = _FPE_MULTIPLE_FAULTS;

                /*
                 * call the SIGFPE handler. note the special code to support
                 * old MS-C programs whose SIGFPE handlers expect two args.
                 *
                 * NOTE: THE CAST AND CALL BELOW DEPEND ON __cdecl BEING
                 * CALLER CLEANUP!
                 */
                (*(void (__cdecl *)(int, int))phandler)(SIGFPE, FPECODE);

                /*
                 * restore the old value of _fpecode
                 */
                FPECODE = oldfpecode;
        }
        else {
                /*
                 * reset the XcptAction field to the default, then call the
                 * user-supplied handler
                 */
                pxcptact->XcptAction = SIG_DFL;
                (*phandler)(pxcptact->SigNum);
        }

        /*
         * restore the old value of _pxcptinfoptrs
         */
        PXCPTINFOPTRS = oldpxcptinfoptrs;

        return(EXCEPTION_CONTINUE_EXECUTION);

}


/***
*struct _XCPT_ACTION * xcptlookup(xcptnum, pxcptrec) - look up exception-action
*       table entry for xcptnum
*
*Purpose:
*       Find the in _XcptActTab[] whose Xcptnum field is xcptnum.
*
*Entry:
*       unsigned long xcptnum            - exception type
*
*       _PEXCEPTIONREPORTRECORD pxcptrec - pointer to exception report record
*       (used only to distinguish different types of XCPT_SIGNAL)
*
*Exit:
*       If successful, pointer to the table entry. If no such entry, NULL is
*       returned.
*
*Exceptions:
*
*******************************************************************************/

static struct _XCPT_ACTION * __cdecl xcptlookup (
        unsigned long xcptnum,
        struct _XCPT_ACTION * pxcptacttab
        )

{
        struct _XCPT_ACTION *pxcptact = pxcptacttab;

        /*
         * walk thru the _xcptactab table looking for the proper entry
         */

        while ( (pxcptact->XcptNum != xcptnum) &&
                (++pxcptact < pxcptacttab + _XcptActTabCount) ) ;

        /*
         * if no table entry was found corresponding to xcptnum, return NULL
         */
        if ( (pxcptact >= pxcptacttab + _XcptActTabCount) ||
             (pxcptact->XcptNum != xcptnum) )
                return(NULL);

        return(pxcptact);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmakepat.c ===
/***
*wmakepth.c - create path name from components (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To provide support for creation of full path names from components
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "makepath.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmakepath_s.c ===
/***
*wmakepath_s.c - create path name from components
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   To provide support for creation of full path names from components
*
*******************************************************************************/

#include <stdlib.h>
#include <mbstring.h>
#include <internal_securecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _wmakepath_s
#define _CHAR wchar_t
#define _DEST _Dst
#define _SIZE _SizeInWords
#define _T(_Character) L##_Character
#define _MBS_SUPPORT 0

#include <tmakepath_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmkdir.c ===
/***
*wmkdir.c - make directory (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function _wmkdir() - make a directory
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "mkdir.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmemcpy_s.c ===
/***
*wmemcpy_s.c - contains memcpy_s routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wmemcpy_s() copies a source memory buffer to a destination buffer in units of wchar_ts.
*       Overlapping buffers are not treated specially, so propagation may occur.
*
*******************************************************************************/

#include <cruntime.h>
#include <wchar.h>
#include <internal.h>

/***
*wmemcpy_s - Copy source buffer to destination buffer
*
*Purpose:
*       wmemcpy_s() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propagation.
*
*       For cases where propagation must be avoided, wmemmove_s() must be used.
*
*Entry:
*       wchar_t *dst = pointer to destination buffer
*       size_t sizeInWchar_ts = size in wchar_ts of the destination buffer
*       const wchar_t *src = pointer to source buffer
*       size_t count = number of wchar_ts to copy
*
*Exit:
*       Returns 0 if everything is ok, else return the error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*       On error, the error code is returned and the destination buffer is zeroed.
*
*******************************************************************************/

errno_t __cdecl wmemcpy_s(
    wchar_t * dst,
    size_t sizeInWchar_ts,
    const wchar_t * src,
    size_t count
)
{
    if (count == 0)
    {
        /* nothing to do */
        return 0;
    }

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(dst != NULL, EINVAL);
    if (src == NULL || sizeInWchar_ts < count)
    {
        /* zeroes the destination buffer */
        wmemset(dst, 0, sizeInWchar_ts);

        _VALIDATE_RETURN_ERRCODE(src != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInWchar_ts >= count, ERANGE);
        /* useless, but prefast is confused */
        return EINVAL;
    }

    wmemcpy(dst, src, count);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wlocale.cpp ===
// wlocale -- class locale wide member functions
#include <istream>
#include <locale>
_STD_BEGIN

 #pragma warning(disable: 4786)
 #pragma warning(disable: 4074)
 #pragma init_seg(compiler)


typedef char_traits<wchar_t> _Wtraits;
typedef istreambuf_iterator<wchar_t, _Wtraits> _Winiter;
typedef ostreambuf_iterator<wchar_t, _Wtraits> _Woutiter;

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

// moved from locale to ease subsetting
typedef ctype<wchar_t> _Tw1;
typedef num_get<wchar_t, _Winiter> _Tw2;
typedef num_put<wchar_t, _Woutiter> _Tw3;
typedef numpunct<wchar_t> _Tw4;
typedef collate<wchar_t> _Tw5;
typedef messages<wchar_t> _Tw6;
typedef money_get<wchar_t, _Winiter> _Tw7;
typedef money_put<wchar_t, _Woutiter> _Tw9;
typedef moneypunct<wchar_t, false> _Tw11;
typedef moneypunct<wchar_t, true> _Tw12;
typedef time_get<wchar_t, _Winiter> _Tw13;
typedef time_put<wchar_t, _Woutiter> _Tw14;
//....
typedef codecvt<wchar_t, char, _Mbstatet> _Twc1;
__PURE_APPDOMAIN_GLOBAL locale::id time_put<wchar_t, _Woutiter>::id(0);


void __CLRCALL_OR_CDECL locale::_Locimp::_Makewloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup wide part of a new locale
	ADDFAC(_Tw1, cat, ptrimp, ptrloc);
	ADDFAC(_Tw2, cat, ptrimp, ptrloc);
	ADDFAC(_Tw3, cat, ptrimp, ptrloc);
	ADDFAC(_Tw4, cat, ptrimp, ptrloc);
	ADDFAC(_Tw5, cat, ptrimp, ptrloc);
	ADDFAC(_Tw6, cat, ptrimp, ptrloc);
	ADDFAC(_Tw7, cat, ptrimp, ptrloc);
	ADDFAC(_Tw9, cat, ptrimp, ptrloc);
	ADDFAC(_Tw11, cat, ptrimp, ptrloc);
	ADDFAC(_Tw12, cat, ptrimp, ptrloc);
	ADDFAC(_Tw13, cat, ptrimp, ptrloc);
	ADDFAC(_Tw14, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Twc1, cat, ptrimp, ptrloc);
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
typedef char_traits<unsigned short> _UShtraits;
typedef istreambuf_iterator<unsigned short, _UShtraits> _UShiniter;
typedef ostreambuf_iterator<unsigned short, _UShtraits> _UShoutiter;

// moved from locale to ease subsetting
typedef ctype<unsigned short> _Tush1;
typedef num_get<unsigned short, _UShiniter> _Tush2;
typedef num_put<unsigned short, _UShoutiter> _Tush3;
typedef numpunct<unsigned short> _Tush4;
typedef collate<unsigned short> _Tush5;
typedef messages<unsigned short> _Tush6;
typedef money_get<unsigned short, _UShiniter> _Tush7;
typedef money_put<unsigned short, _UShoutiter> _Tush9;
typedef moneypunct<unsigned short, false> _Tush11;
typedef moneypunct<unsigned short, true> _Tush12;
typedef time_get<unsigned short, _UShiniter> _Tush13;
typedef time_put<unsigned short, _UShoutiter> _Tush14;
//....
typedef codecvt<unsigned short, char, _Mbstatet> _Tushc1;

void __CLRCALL_OR_CDECL locale::_Locimp::_Makeushloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup wide part of a new locale
	ADDFAC(_Tush1, cat, ptrimp, ptrloc);
	ADDFAC(_Tush2, cat, ptrimp, ptrloc);
	ADDFAC(_Tush3, cat, ptrimp, ptrloc);
	ADDFAC(_Tush4, cat, ptrimp, ptrloc);
	ADDFAC(_Tush5, cat, ptrimp, ptrloc);
	ADDFAC(_Tush6, cat, ptrimp, ptrloc);
	ADDFAC(_Tush7, cat, ptrimp, ptrloc);
	ADDFAC(_Tush9, cat, ptrimp, ptrloc);
	ADDFAC(_Tush11, cat, ptrimp, ptrloc);
	ADDFAC(_Tush12, cat, ptrimp, ptrloc);
	ADDFAC(_Tush13, cat, ptrimp, ptrloc);
	ADDFAC(_Tush14, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Tushc1, cat, ptrimp, ptrloc);
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmemmove_s.c ===
/***
*wmemmove_s.c - contains wmemmove_s routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wmemmove_s() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are treated specially, to avoid propagation.
*
*******************************************************************************/

#include <cruntime.h>
#include <wchar.h>
#include <internal.h>

/***
*wmemmove - Copy source buffer to destination buffer in units of wchar_t
*
*Purpose:
*       wmemmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propagation.
*
*       For cases where propagation is not a problem, wmemcpy_s() can be used.
*
*Entry:
*       wchar_t *dst = pointer to destination buffer
*       size_t sizeInWchar_ts = size in wchar_ts of the destination buffer
*       const wchar_t *src = pointer to source buffer
*       size_t count = number of wchar_ts to copy
*
*Exit:
*       Returns 0 if everything is ok, else return the error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*       On error, the error code is returned. Nothing is written to the destination buffer.
*
*******************************************************************************/

errno_t __cdecl wmemmove_s(
    wchar_t * dst,
    size_t sizeInWchar_ts,
    const wchar_t * src,
    size_t count
)
{
    if (count == 0)
    {
        /* nothing to do */
        return 0;
    }

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(dst != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(src != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sizeInWchar_ts >= count, ERANGE);

    wmemmove(dst, src, count);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmktemp.c ===
/***
*wmktemp.c - create a unique file name (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wmktemp() - create a unique file name
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS

#include "mktemp.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wopen.c ===
/***
*wopen.c - file open for (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wopen() and _wsopen() - open or create a file
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "open.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\WorkQueue.cpp ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// workqueue.cpp
//
// Work stealing queues pair implementation.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#include "concrtinternal.h"

namespace Concurrency
{
namespace details
{
    /// <summary>
    ///     Constructs a new work queue.
    /// </summary>
    WorkQueue::WorkQueue()
        : m_structuredQueue(&m_lock),
        m_unstructuredQueue(&m_lock),
        m_pOwningContext(NULL),
        m_detachmentState(QUEUE_ATTACHED)
    {
        m_detachment.m_listArrayIndex = 0;
        m_detachment.m_pObject = this;
        m_id = SchedulerBase::GetNewWorkQueueId();
    }

    /// <summary>
    ///     Steal a chore from the work stealing queue for unrealized parallelism.
    /// </summary>
    _UnrealizedChore *WorkQueue::UnlockedSteal()
    {
        if (IsEmpty())
            return NULL;

        //
        // Make certain we do not steal from a canceled context.  The exception handling will properly unwind this.  This avoids a degree on infighting
        // on cancellation.  When a subtree which has stolen chores is canceled, the stealing threads are canceled, unwind, and immediately become available
        // for stealing.  They can easily pick up a region of the tree where exception handling has not unwound to the cancellation point and the exception
        // handlers wind up in a little battle with the stealing threads (the exception handlers shooting down contexts and the contexts stealing different
        // pieces of the tree, wash, rinse, repeat).  In order to avoid *some* of the contention, we simply will refuse to steal from any context which was 
        // shot down as part of a subtree cancellation.
        //
        // Further, as an optimization, we do temporarily suspend stealing from a context which has an inflight cancellation -- even if the stealing happens
        // in a different piece of the subtree than being canceled.  This allows us to avoid yet more infighting during a cancellation.  It should be a rare
        // enough event that the suspension of stealing from that context during the in flight cancel shouldn't hurt performance.  Note that this is the difference
        // between the pCheckContext->IsCanceled() and a pCheckContext->IsCanceledContext() below.  The latter would only check fully canceled contexts.  The
        // former does the suspension on contexts with in flight cancellations.
        //

        _UnrealizedChore *pResult = NULL; 
        ContextBase *pOwningContext = m_pOwningContext;
        if (pOwningContext != NULL && pOwningContext->IsCanceled())
        {
            //
            // There is a scenario that we need to be extraordinarily careful of here.  Normally, we could just ignore the steal.  Unfortunately,
            // it's entirely possible that a detached queue was reused on a context (A) and then A became cancelled while we waited on a task
            // collection that had chores in the detached region.  This would lead to deadlock.  We need to allow stealing from the region of
            // the WSQ which was detached.  
            //
            // m_unstructuredQueue may contains tasks from task collections that are not being canceled.  However, we cannot quickly detect the difference.
            // Thus before arbitrary stealing from m_unstructuredQueue, we need to finish cancelation of the task collections that need to be canceled, which is why
            // pOwningContext->IsCanceled() is true.  Cancellation is over when pOwningContext->IsCanceled() is false and then uninhibited stealing from m_unstructuredQueue
            // may occur again.  However, in the meantime, stealing threads may go idle because no work can be found and if m_pOwningContext exits w/o waiting,
            // there may be work left to execute, but all vprocs are idle.  This 'deadlock' is prevented by calling NotifyWorkSkipped() that assures an associated vproc will 
            // not go idle without verifying there is no work left by executing this function again.
            //
            if (m_unstructuredQueue.MarkedForDetachment())
                pResult = (_UnrealizedChore *) m_unstructuredQueue.UnlockedSteal(true);
            if (pResult != NULL)
                pResult->_SetDetached(true);
            else
                static_cast<InternalContextBase *>(SchedulerBase::FastCurrentContext())->NotifyWorkSkipped();
        }
        else
        {
            pResult = (_UnrealizedChore *) m_structuredQueue.UnlockedSteal();

            //
            // Structured does not need to deal with detachment and cancellation references, simply return the value.
            //
            if (pResult != NULL)
                return pResult;

            pResult = (_UnrealizedChore *) m_unstructuredQueue.UnlockedSteal(false);

            //
            // If we stole and there is an owning context and it's not a detached steal (which always goes on the task collection list), keep the owning context
            // alive until the wrapper can add the task to the appropriate cancellation list.
            //  NOTE:  pResult is unstructured.
            //
            if (pResult != NULL)
            {
                if (m_pOwningContext != NULL 
                    && reinterpret_cast <ContextBase *> (pResult->_OwningCollection()->_OwningContext()) == m_pOwningContext)
                {
                    m_pOwningContext->ReferenceForCancellation();
                    pResult->_SetDetached(false);
                } else
                    pResult->_SetDetached(true);
            }
        }

        return pResult;
    }

    /// <summary>
    ///     Attempts to steal an unrealized chore from the unstructured work stealing queue.
    /// </summary>
    /// <param name="fSuccessfullyAcquiredLock">
    ///     The try lock was successfully acquired.
    /// </param>
    /// <returns>
    ///     An unrealized chore stolen from the work stealing queues or NULL if no such chore can be stolen
    /// </returns>
    _UnrealizedChore *WorkQueue::TryToSteal(bool& fSuccessfullyAcquiredLock)
    {
        _UnrealizedChore *pResult = NULL;
        if (m_lock._TryAcquire())
        {
            __try
            {
                pResult = UnlockedSteal();
            }
            __finally
            {
                m_lock._Release();
            }
            fSuccessfullyAcquiredLock = true;
        }
        else
            fSuccessfullyAcquiredLock = false;
        
        return pResult;
    }

    /// <summary>
    ///     Steal a chore from both work stealing queues.
    /// </summary>
    _UnrealizedChore* WorkQueue::Steal()
    {
        _CriticalNonReentrantLock::_Scoped_lock lockHolder(m_lock);
        return UnlockedSteal();
    }

    /// <summary>
    ///     Sweeps the unstructured work stealing queue for items matching a predicate and potentially removes them
    ///     based on the result of a callback.
    /// </summary>
    /// <param name="pPredicate">
    ///     The predicate for things to call pSweepFn on.
    /// </param>
    /// <param name="pData">
    ///     The data for the predicate callback
    /// </param>
    /// <param name="pSweepFn">
    ///     The sweep function
    /// </param>
    void WorkQueue::SweepUnstructured(WorkStealingQueue<_UnrealizedChore>::SweepPredicate pPredicate,
                                      void *pData,
                                      WorkStealingQueue<_UnrealizedChore>::SweepFunction pSweepFn
                                      )
    {
        m_unstructuredQueue.Sweep(pPredicate, pData, pSweepFn);
    }

    /// <summary>
    ///     Causes a detached work queue to release its reference on the inpassed schedule group and remove itself from that schedule group's
    ///     list of work queues at the next available safe point.
    /// </summary>
    void WorkQueue::RetireAtSafePoint(ScheduleGroupBase *pScheduleGroup)
    {
        m_pDetachedScheduleGroup = pScheduleGroup;
        m_detachmentSafePoint.InvokeAtNextSafePoint(reinterpret_cast<SafePointInvocation::InvocationFunction>(&WorkQueue::StaticRetire),
                                                    this,
                                                    pScheduleGroup->GetScheduler());
    }

    /// <summary>
    ///     Causes a detached work queue to redetach due to roll-back of retirement at the next available safe point.
    /// </summary>
    void WorkQueue::RedetachFromScheduleGroupAtSafePoint(ScheduleGroupBase *pScheduleGroup)
    {
        m_pDetachedScheduleGroup = pScheduleGroup;
        m_detachmentSafePoint.InvokeAtNextSafePoint(reinterpret_cast<SafePointInvocation::InvocationFunction>(&WorkQueue::StaticRedetachFromScheduleGroup),
                                                    this,
                                                    pScheduleGroup->GetScheduler());
    }

    /// <summary>
    ///     Retires the detached work queue.
    /// </summary>
    void WorkQueue::StaticRetire(WorkQueue *pQueue)
    {
        pQueue->m_pDetachedScheduleGroup->RetireDetachedQueue(pQueue);
    }

    /// <summary>
    ///     Places the work queue back in a detached state on roll back.
    /// </summary>
    void WorkQueue::StaticRedetachFromScheduleGroup(WorkQueue *pQueue)
    {
        pQueue->m_pDetachedScheduleGroup->RedetachQueue(pQueue);
    }

} // namespace details
} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\woutput.c ===
/***
*woutput.c - wprintf style output to a FILE (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the symbol UNICODE and then #includes the file
*       "output.c" in order to implement _woutput(), the helper for the
*       wide character versions of *wprintf() family of functions.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wmmintrin.h ===
/***
*** Copyright (C) 1985-2008 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
****/

/*
 * wmmintrin.h
 *
 * Principal header file for Intel(R) AES and PCLMULQDQ intrinsics.
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_WMM
#define _INCLUDED_WMM

#if defined (_M_CEE_PURE)
        #error ERROR: EMM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <nmmintrin.h>


#if __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * Performs 1 round of AES decryption of the first m128i using
 * the second m128i as a round key.
 */
extern __m128i _mm_aesdec_si128(__m128i v, __m128i rkey);

/*
 * Performs the last round of AES decryption of the first m128i
 * using the second m128i as a round key.
 */
extern __m128i _mm_aesdeclast_si128(__m128i v, __m128i rkey);

/*
 * Performs 1 round of AES encryption of the first m128i using
 * the second m128i as a round key.
 */
extern __m128i _mm_aesenc_si128(__m128i v, __m128i rkey);

/*
 * Performs the last round of AES encryption of the first m128i
 * using the second m128i as a round key.
 */
extern __m128i _mm_aesenclast_si128(__m128i v, __m128i rkey);

/*
 * Performs the InverseMixColumn operation on the source m128i
 * and stores the result into m128i destination.
 */
extern __m128i _mm_aesimc_si128(__m128i v);

/*
 * Generates a m128i round key for the input m128i
 * AES cipher key and byte round constant.
 * The second parameter must be a compile time constant.
 */
extern __m128i _mm_aeskeygenassist_si128(__m128i ckey, const int rcon);

/*
 * Performs carry-less integer multiplication of 64-bit halves
 * of 128-bit input operands.
 * The third parameter inducates which 64-bit haves of the input parameters
 * v1 and v2 should be used. It must be a compile time constant.
 */
extern __m128i _mm_clmulepi64_si128(__m128i v1, __m128i v2,
                                            const int imm8);




#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INCLUDED_WMM */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\woutputp.c ===
/***
*woutputp.c - Positional version of wprintf & the wprintf family
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This has format validations & positional parameters as compared to wprintf
*
*******************************************************************************/



#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#define POSITIONAL_PARAMETERS 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\workqueue.h ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// workqueue.h
//
// Work stealing queues pair implementation.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

namespace Concurrency
{
namespace details
{
#define QUEUE_ATTACHED 0
#define QUEUE_DETACHED 1

    /// <summary>
    ///     The work queue is a pair of bound work stealing queues, one structured and one unstructured, that
    ///     can be associated with a context.
    /// </summary>
    class WorkQueue
    {
    public:

        /// <summary>
        ///     Constructs a new work queue.
        /// </summary>
        WorkQueue();

        //
        // Queue Reuse:
        //

        /// <summary>
        ///     Informs the WSQ what context it's attached to in a synchronized manner.
        /// </summary>
        void LockedSetOwningContext(ContextBase *pOwningContext)
        {
            m_lock._Acquire();
            m_pOwningContext = pOwningContext;
            m_lock._Release();
        }

        /// <summary>
        ///     Informs the WSQ what context it's attached to.
        /// </summary>
        void SetOwningContext(ContextBase *pOwningContext)
        {
            m_pOwningContext = pOwningContext;
        }

        //
        // Structured Parallelism:
        //

        /// <summary>
        ///     Pushes an unrealized chore onto the work stealing queue for structured parallelism.
        /// </summary>
        /// <param name="pChore">
        ///     The chore to push onto the structured work stealing queue
        /// </param>
        void PushStructured(_UnrealizedChore *pChore)
        {
            m_structuredQueue.Push(pChore);
        }

        /// <summary>
        ///     Pops the topmost chore from the work stealing queue for unstructured parallelism.  Failure
        ///     to pop typically indicates stealing.
        /// </summary>
        /// <returns>
        ///     An unrealized chore from the structured work stealing queue or NULL if none is present
        /// </returns>
        _UnrealizedChore* PopStructured()
        {
            return m_structuredQueue.Pop();
        }

        /// <summary>
        ///     Attempts to steal an unrealized chore from the structured work stealing queue.
        /// </summary>
        /// <returns>
        ///     An unrealized chore stolen from the work stealing queues or NULL if no such chore can be 
        ///     stolen
        /// </returns>
        _UnrealizedChore *UnlockedStealStructured()
        {
            return m_structuredQueue.UnlockedSteal();
        }

        /// <summary>
        ///     Returns whether the structured work stealing queue is empty.
        /// </summary>
        bool IsStructuredEmpty() const
        {
            return m_structuredQueue.Empty();
        }

        //
        // Unstructured Parallelism:
        //

        /// <summary>
        ///     Pushes an unrealized chore onto the work stealing queue for unstructured parallelism.  The returned
        ///     value is a cookie which can be used in a call to TryPopUnstructured.
        /// </summary>
        /// <param name="pChore">
        ///     The chore to push onto the unstructured work stealing queue
        /// </param>
        /// <returns>
        ///     A cookie which can be used to identify the chore for a later TryPopUnstructured call
        /// </returns>
        int PushUnstructured(_UnrealizedChore *pChore)
        {
            return m_unstructuredQueue.Push(pChore);
        }

        /// <summary>
        ///     Attempts to pop the chore specified by a cookie value from the unstructured work stealing queue.  Failure
        ///     to pop typically indicates stealing.
        /// </summary>
        /// <param name="cookie">
        ///     A cookie returned from PushUnstructured indicating the chore to attempt to pop from
        ///     the unstructured work stealing queue
        /// </param>
        /// <returns>
        ///     The specified unrealized chore (as indicated by cookie) or NULL if it could not be popped from
        ///     the work stealing queue
        /// </returns>
        _UnrealizedChore *TryPopUnstructured(int cookie)
        {
            return m_unstructuredQueue.TryPop(cookie);
        }

        /// <summary>
        ///     Attempts to steal an unrealized chore from the unstructured work stealing queue.
        /// </summary>
        /// <returns>
        ///     An unrealized chore stolen from the work stealing queues or NULL if no such chore can be stolen
        /// </returns>
        _UnrealizedChore *Steal();

        /// <summary>
        ///     Attempts to steal an unrealized chore from the unstructured work stealing queue.
        /// </summary>
        /// <param name="fSuccessfullyAcquiredLock">
        ///     The try lock was successfully acquired.
        /// </param>
        /// <returns>
        ///     An unrealized chore stolen from the work stealing queues or NULL if no such chore can be stolen
        /// </returns>
        _UnrealizedChore *TryToSteal(bool& fSuccessfullyAcquiredLock);

        /// <summary>
        ///     Returns whether the unstructured work stealing queue is empty.
        /// </summary>
        bool IsUnstructuredEmpty() const
        {
            return m_unstructuredQueue.Empty();
        }

        /// <summary>
        ///     Sweeps the unstructured work stealing queue for items matching a predicate and potentially removes them
        /// based on the result of a callback.
        /// </summary>
        /// <param name="pPredicate">
        ///     The predicate for things to call pSweepFn on.
        /// </param>
        /// <param name="pData">
        ///     The data for the predicate and sweep callback
        /// </param>
        /// <param name="pSweepFn">
        ///     The sweep function
        /// </param>
        void SweepUnstructured(WorkStealingQueue<_UnrealizedChore>::SweepPredicate pPredicate,
                               void *pData,
                               WorkStealingQueue<_UnrealizedChore>::SweepFunction pSweepFn);

        /// <summary>
        ///     Called in order to mark this work queue as detached so that we know how far it's legal to steal up the work
        ///     queue should it become reattached to context with active cancellation.
        /// </summary>
        void MarkDetachment()
        {
            //
            // We only detach unstructured queues.
            //
            m_unstructuredQueue.MarkDetachment();
        }

        //
        // Both:
        //

        /// <summary>
        ///     Returns the id of the work queue.
        /// </summary>
        unsigned int Id() const { return m_id; }

        /// <summary>
        ///     Returns whether the both work stealing queues are empty.  
        /// </summary>
        bool IsEmpty() const
        {
            return m_structuredQueue.Empty() &&  m_unstructuredQueue.Empty();
        }

        /// <summary>
        ///     Sets the queue to a detached state.
        /// </summary>
        void SetDetached(bool fDetached)
        {
            if (fDetached)
                MarkDetachment();

            InterlockedExchange(&m_detachmentState, fDetached ? QUEUE_DETACHED : QUEUE_ATTACHED);
        }

        /// <summary>
        ///     Queries whether the queue is detached.
        /// </summary>
        bool IsDetached() const
        {
            return (m_detachmentState == QUEUE_DETACHED);
        }

        /// <summary>
        ///     Causes a detached work queue to release its reference on the inpassed schedule group and remove itself from that schedule group's
        ///     list of work queues at the next available safe point.
        /// </summary>
        void RetireAtSafePoint(ScheduleGroupBase *pScheduleGroup);

        /// <summary>
        ///     Causes a detached work queue to redetach due to roll-back of retirement at the next available safe point.
        /// </summary>
        void RedetachFromScheduleGroupAtSafePoint(ScheduleGroupBase *pScheduleGroup);

        /// <summary>
        ///     Indicates whether the steal lock is held.
        /// </summary>
        bool IsLockHeld() const
        {
            return m_lock._IsLockHeld();
        }

    private:
        friend class ContextBase;
        friend class ScheduleGroupBase;
        template <class T> friend class ListArray;
        template<class T> friend void _InternalDeleteHelper(T*);

        // structured work stealing
        StructuredWorkStealingQueue<_UnrealizedChore, _CriticalNonReentrantLock> m_structuredQueue; 

        // Intrusive links for list array.
        SLIST_ENTRY m_listArrayFreeLink;    

        // The safe point invocation which will perform a release of schedule group held by a detached WSQ.
        SafePointInvocation m_detachmentSafePoint;

        // Tracking for detachment
        ListArrayInlineLink<WorkQueue> m_detachment;
        volatile long m_detachmentState;
        ScheduleGroupBase *m_pDetachedScheduleGroup;

        // The unique identifier for the work queue.  This is the final level of binding between a task pool and a work queue.
        unsigned int m_id;

        // The index this workqueue appears at in its list array
        int m_listArrayIndex;               

        // The context which owns the WSQ.  NOTE: Any utilization of this must be capture/use as it will change outside the scope
        // of the WSQ list lock.
        ContextBase *m_pOwningContext;     

        // Unstructured work stealing
        WorkStealingQueue<_UnrealizedChore, _CriticalNonReentrantLock> m_unstructuredQueue; 

        // External lock for unstructured work stealing
        _CriticalNonReentrantLock m_lock;                              

        // Reinitialize a work queue pulled from a free pool
        void Reinitialize()
        {
            // Grab steal locks, this will prevent other readers from grabbing this work 
            // queue while we are reinitializing (h=t=0 is non-atomic, is it worth it to fix?)
            m_lock._Acquire();
            // Reinitialize the reused workqueue
            m_structuredQueue.Reinitialize();
            m_unstructuredQueue.Reinitialize();
            m_detachmentState = QUEUE_ATTACHED;
            m_pOwningContext = NULL;
            // Release the work queue locks
            m_lock._Release();
        }

        // steal helper
        _UnrealizedChore *UnlockedSteal();

        /// <summary>
        ///     Retires the detached work queue.
        /// </summary>
        static void StaticRetire(WorkQueue *pQueue);

        /// <summary>
        ///     Places the work queue back in a detached state on roll back.
        /// </summary>
        static void StaticRedetachFromScheduleGroup(WorkQueue *pQueue);

        void * operator new(size_t _Size)
        {
            return ::operator new(_Size);
        }

        void operator delete(void * _Ptr)
        {
            ::operator delete(_Ptr);
        }
    };
} // namespace details
} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\WorkStealingQueue.h ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// WorkStealingQueue.h
//
// Header file containing the core implementation of the work stealing data structures and algorithms.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#pragma once

namespace Concurrency
{
namespace details
{
    /// <summary>
    ///     A WorkStealingQueue is a wait-free, lock-free structure associated with a single
    ///     thread that can Push and Pop elements. Other threads can do Steal operations
    ///     on the other end of the WorkStealingQueue with little contention.
    /// </summary>
    template <typename T, typename LOCK=_NonReentrantLock>
    class WorkStealingQueue
    {
        // A 'WorkStealingQueue' always runs its code in a single OS thread. We call this the
        // 'bound' thread. Only the code in the Steal operation can be executed by
        // other 'foreign' threads that try to steal work.
        //
        // The queue is implemented as an array. The m_head and m_tail index this
        // array. To avoid copying elements, the m_head and m_tail index the array modulo
        // the size of the array. By making this a power of two, we can use a cheap
        // bit-and operation to take the modulus. The "m_mask" is always equal to the
        // size of the task array minus one (where the size is a power of two).
        //
        // The m_head and m_tail are volatile as they can be updated from different OS threads.
        // The "m_head" is only updated by foreign threads as they Steal a task from
        // this queue. By putting a lock in Steal, there is at most one foreign thread
        // changing m_head at a time. The m_tail is only updated by the bound thread.
        //
        // invariants:
        //   tasks.length is a power of 2
        //   m_mask == tasks.length-1
        //   m_head is only written to by foreign threads
        //   m_tail is only written to by the bound thread
        //   At most one foreign thread can do a Steal
        //   All methods except Steal are executed from a single bound thread
        //   m_tail points to the first unused location
        //
        // This work stealing implementation also supports the notion of out-of-order waiting
        // and out-of-order removal from the bound thread given that it is initialized to do so.
        // There is additional cost to performing this.
        //

    public:

        /// <summary>
        ///     The callback for a sweep of the workstealing queue.  This will be called under the stealing lock on the owning thread
        ///     for every chore matching a predefined predicate.  If true is returned, the item is pulled from the WSQ.  If false is returned,
        ///     the item stays in the WSQ.
        /// </summary>
        typedef bool (*SweepFunction)(T *pObject, void *pData);

        /// <summary>
        ///     A predicate for a WSQ sweep.
        /// </summary>
        typedef bool (*SweepPredicate)(T *pObject, void *pData);


        /// <summary>
        ///     Constructs a new work stealing queue
        /// </summary>
        WorkStealingQueue(LOCK *pLock)
            : m_pLock(pLock)
        {      
            ASSERT(m_pLock != NULL);
            ASSERT(s_initialSize > 1);
            Reinitialize();
            m_mask = s_initialSize - 1;
            m_pTasks = new T*[s_initialSize];
        }

        /// <summary>
        ///     Reinitializes a workqueue to the state just after construction.  This is used when recycling a work
        ///     queue from its ListArray
        /// </summary>
        void Reinitialize()
        {
            m_head = 0;
            m_tail = 0;
            m_detachmentTail = 0;
            m_fMarkedForDetachment = false;
            m_cookieBase = 0;
        }

        /// <summary>
        ///     Unlocked count
        /// </summary>
        int Count() const 
        {
            return (m_tail - m_head);
        }

        /// <summary>
        ///     Unlocked check if empty
        /// </summary>
        bool Empty() const 
        {
            return (m_tail <= m_head);
        }

        /// <summary>
        ///     Check whether to skip the steal
        /// </summary>
        bool MarkedForDetachment() const
        {
            return m_fMarkedForDetachment;
        }

        //
        // Push/Pop and Steal can be executed interleaved. In particular:
        // 1) A steal and pop should be careful when there is just one element
        //    in the queue. This is done by first incrementing the m_head/decrementing the m_tail
        //    and than checking if it interleaved (m_head > m_tail).
        // 2) A push and steal can interleave in the sense that a push can overwrite the
        //    value that is just stolen. To account for this, we check conservatively in
        //    the push to assume that the size is one less than it actually is.
        //

        /// <summary>
        ///     Attempts to steal the oldest element in the queue.  This handles potential interleaving with both
        ///     a Pop and TryPop operation.
        /// </summary>
        T* UnlockedSteal(bool fOnlyDetached = false)
        {
            T* pResult = NULL;

            for (;;)
            {
                //
                // increment the m_head. Save in local h for efficiency
                //
                int h = m_head;
                InterlockedExchange((volatile LONG*)&m_head, h + 1);

                //
                // insert a memory fence here -- memory may not be sequentially consistent
                //

                if (h < m_tail) 
                {
                    //
                    // If the queue is detached and we've crossed the point of detachment, end the detachment marker.
                    //
                    if (m_fMarkedForDetachment && m_head >= m_detachmentTail)
                        m_fMarkedForDetachment = false;

                    //
                    // == (h+1 <= m_tail) == (m_head <= m_tail)
                    //
                    // When we allow out-of-order waits, it's entirely possible that a TryPop
                    // executing on the bound thread will grab this out from underneath us.  Not
                    // only do we need guards against interleave with ordered pop, but we also
                    // need a guard against an out-of-order trypop.
                    //
                    pResult = reinterpret_cast<T*> (InterlockedExchangePointer(
                        reinterpret_cast<PVOID volatile *>( &(m_pTasks[h & m_mask])),
                        (PVOID) NULL
                        ));
                    if (pResult != NULL) 
                        break;
                }
                else 
                {
                    //
                    // failure: either empty or single element interleaving with pop
                    //
                    m_head = h;              // restore the m_head
                    break;
                }
            }

            return pResult;
        }

        // only used in a test
        T* Steal()
        {
            LOCK::_Scoped_lock lockHolder(*m_pLock);
            return UnlockedSteal();
        }

        /// <summary>
        ///     Attempts to pop the newest element on the work stealing queue.  It may return NULL if there is no such
        ///     item (either unbalanced push/pop, a chore stolen)
        /// </summary>
        T* Pop()
        {
            for(;;)
            {
                //
                // decrement the m_tail. Use local t for efficiency.
                //
                int t = m_tail - 1;
                InterlockedExchange((volatile LONG*)&m_tail, t);
    
                //
                // insert a memory fence here (InterlockedExchange does the job) -- 
                // memory may not be sequentially consistent
                //
    
                if (m_head <= t)
                {
                    //
                    // == (m_head <= m_tail)
                    //
                    T* pResult = m_pTasks[t & m_mask];
 
                    //
                    // Out of order TryPops on the bound thread will set this without
                    // the need for a fence.
                    //
                    if (pResult == NULL) continue;
                    return pResult;
                }
                else
                {
                    //
                    // failure: either empty or single element interleaving with steal
                    //
                    m_tail = t + 1;     // restore the m_tail 
                    return SyncPop();   // do a single-threaded pop
                }
            }
        }

        /// <summary>
        ///     Tries to pop a previously pushed element from the work stealing queue.  Note that this executes
        ///     a potentially out-of-order wait.
        /// </summary>
        /// <param name="cookie">
        ///     The value returned from a Push() call for the work in question
        /// </param>
        T* TryPop(int cookie)
        {
            cookie = (cookie - m_cookieBase);

            //
            // TryPop() has Pop() semantics if we try the topmost element.  We only need to do something
            // "special" in the out of order case.
            //
            if (cookie == m_tail - 1) return Pop();

            if (cookie >= m_tail || cookie < m_head) return NULL;

            T* pResult = reinterpret_cast<T*> (InterlockedExchangePointer(
                reinterpret_cast<PVOID volatile *>( &(m_pTasks[cookie & m_mask])),
                (PVOID) NULL
                ));

            return pResult;

        }

        /// <summary>
        ///     Pushes an element onto the work stealing queue.  The returned cookie can be utilized to identify
        ///     the work item for a future TryPop() call.  Note that the returned cookie is only valid until a Pop()
        ///     or TryPop() call removes the work in question. 
        /// </summary>
        int Push(T* elem)
        {
            int t = m_tail;
            //
            // Careful here since we might interleave with Steal.
            // This is no problem since we just conservatively check if there is
            // enough space left (t < m_head + size). However, Steal might just have
            // incremented m_head and we could potentially overwrite the old m_head
            // entry, so we always leave at least one extra 'buffer' element and
            // check (m_tail < m_head + size - 1). This also plays nicely with our
            // initial m_mask of 0, where size is 2^0 == 1, but the tasks array is
            // still null.
            //
            if (t < m_head + m_mask)  // == t < m_head + size - 1
            {
                m_pTasks[t & m_mask] = elem;
                m_tail = t + 1;       // only increment once we have initialized the task entry.
                return t + m_cookieBase;
            }
            else
            {
                //
                // failure: we need to resize or re-index
                //
                return SyncPush(elem);
            }
        }

        /// <summary>
        ///     Only called from the bound thread, this sweeps the work stealing queue under the steal lock for any chores matching the
        ///     specified predicate.
        /// </summary>
        void Sweep(SweepPredicate pPredicate, void *pData, SweepFunction pSweepFn)
        {
            LOCK::_Scoped_lock lockHolder(*m_pLock);

            int nt = m_tail;
            int t = m_tail - 1;

            while (t >= m_head)
            {
                T* pResult = m_pTasks[t & m_mask];
                if (pResult != NULL)
                {
                    if (pPredicate(pResult, pData))
                    {
                        if (pSweepFn(pResult, pData))
                        {
                            //
                            // If it's atop the WSQ, just decrement the tail (nt == new tail); otherwise, 
                            // make sure to NULL out the entry to indicate an out-of-order rip.
                            //
                            if (t + 1 == nt)
                                nt--;
                            else
                                m_pTasks[t & m_mask] = NULL;
                        }
                    }
                }
                
                t--;
            }

            InterlockedExchange((volatile LONG *)&m_tail, nt);
        }

        /// <summary>
        ///     Marks the work stealing queue as detached.  The current head pointer marks the end point of detachment.  Note
        ///     that this should only be called when there is a guarantee of no concurrent pushes or pops from the owning thread.
        /// </summary>
        void MarkDetachment()
        {
            LOCK::_Scoped_lock lockHolder(*m_pLock);
            m_fMarkedForDetachment = true;
            m_detachmentTail = m_tail;
        }

        /// <summary>
        ///     Destroys a work stealing queue.
        /// </summary>
        ~WorkStealingQueue()
        {      
            delete [] m_pTasks;
        }

    private:

        // The m_head and m_tail are volatile as they can be updated from different OS threads.
        // The "m_head" is only updated by foreign threads as they Steal a task from
        // this queue. By putting a lock in Steal, there is at most one foreign thread
        // changing m_head at a time. The m_tail is only updated by the bound thread.
        //
        // invariants:
        //   tasks.length is a power of 2
        //   m_mask == tasks.length-1
        //   m_head is only written to by foreign threads
        //   m_tail is only written to by the bound thread
        //   At most one foreign thread can do a Steal
        //   All methods except Steal are executed from a single bound thread
        //   m_tail points to the first unused location
        //

        static const int s_initialSize = 64;  // must be a power of 2
        volatile int m_head;                  // only updated by Steal 
        volatile int m_tail;                  // only updated by Push and Pop 
        
        int m_mask;                           // the m_mask for taking modulus 
        int m_cookieBase;                     // the base cookie index

        LOCK *m_pLock;                        // the lock that guards stealing from push/pops

        bool m_fMarkedForDetachment;          // Indicates whether or not the work stealing queue is marked for detachment
        int m_detachmentTail;                 // The tail pointer for detachment.  When the head crosses this, the mark ends

        T**  m_pTasks;                        // the array of tasks 

        /// <summary>
        ///     Pushes an element onto the work stealing queue under the queue lock.  This guarantees that no steal
        ///     interleaves and guarantees the ability to reallocate the physical store.  The returned value is a cookie
        ///     per Push().
        /// </summary>
        int SyncPush(T* elem)
        {
            //
            // Because WorkStealingQueue is used for LRC and LRC needs to be searched in a SFW from a UMS primary, the lock here is a hyper
            // lock and no memory allocations can happen inside its scope.  Preallocate everything up front!
            //
            // Keep in mind that the only thing that's going to happen without the lock held is a steal.  No one else will try to resize,
            // pop, push, etc...
            //
            //
            // == (count >= size-1)
            //
            int oldsize = m_mask + 1;
            int newsize = 2 * oldsize; // highly unlikely, but throw out-of-memory if this overflows
            int count = m_tail - m_head;

            //
            // Yes -- it's entirely possible that we allocate and DON'T need to in rare circumstances - steal just opened up a slot.  In that particular
            // case, we will just do the resizing since it's almost full.
            //
            T** pNewTasks = new T*[newsize];
            //
            // Again, for reasons of UMS, we cannot delete the old array until after we release the hyper lock.  Stash it away
            // and defer the deletion.
            //
            T** pOldTasks = m_pTasks;

            {
                //
                // ensure that no Steal interleaves here
                //
                LOCK::_Scoped_lock lockHolder(*m_pLock);

                //
                // cache m_head, and calculate number of tasks
                //
                int h = m_head;
                count = m_tail - h;

                //
                // normalize indices
                //
                h = h & m_mask;           // normalize m_head
                m_cookieBase += m_tail - (h + count);
                m_head = h;
                m_tail = h + count;

#pragma warning(disable:26010)

                // we get here the first time we've overflowed,
                // so as long as m_mask >= 1, which is asserted in the ctor, there's plenty of room
                CORE_ASSERT(count < newsize);
                CORE_ASSERT(pNewTasks != NULL);
                for (int i = 0; i < count; ++i)
                    pNewTasks[i] = m_pTasks[(h + i) & m_mask];

                m_pTasks = pNewTasks;

#pragma warning(default:26010)

                //
                // Rebase the cookie index.  We can't hand out duplicate cookies due to this.
                //
                m_cookieBase += m_head;

                //
                // Rebase the detachment point if necessary.
                //
                if (m_fMarkedForDetachment)
                {
                    CORE_ASSERT(m_detachmentTail >= m_head);
                    m_detachmentTail -= m_head;
                }

                m_mask = newsize - 1;
                m_head = 0;
                m_tail = count;

                CORE_ASSERT(count < m_mask);

                //
                // push the element
                //
                int t = m_tail;
                m_pTasks[t & m_mask] = elem;
                m_tail = t + 1;

            }

            delete[] pOldTasks;
            return m_tail - 1 + m_cookieBase;
        }

        /// <summary>
        ///     Synchronously pops an element from the work stealing queue.  Note that this is called in the case where
        ///     a Pop() call and a Steal() call interleave.
        /// </summary>
        T* SyncPop()
        {
            //
            // ensure that no Steal interleaves with this pop
            //
            LOCK::_Scoped_lock lockHolder(*m_pLock);

            T* pResult = NULL;
            int t = m_tail - 1;
            m_tail = t;
            if (m_head <= t)
            {
                //
                // == (m_head <= m_tail)
                //
                pResult = m_pTasks[t & m_mask];

                //
                // Because this was a single element / interleave with steal, there is nothing
                // below this in the WSQ in the event of a NULL return.  Hence, we do not need
                // to perform an explicit skip as in Pop().
                //
            }
            else
            {
                m_tail = t + 1;       // restore m_tail
            }
            if (m_head >= t)
            {
                //
                // Rebase the cookie index so we guarantee that currently handed out cookie values are
                // still valid until they are trypop()'d.
                //
                m_cookieBase += m_head;

                //
                // queue is empty: reset m_head and m_tail
                //
                m_head = 0;
                m_tail = 0;
                m_detachmentTail = 0;
                m_fMarkedForDetachment = false;
            }

            return pResult;
        }

    };
} // namespace details
} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\woutputs.c ===
/***
*woutputs.c - Secure version of wprintf & the wprintf family
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This has format validations as compared to wprintf
*
*******************************************************************************/



#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#define FORMAT_VALIDATIONS 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wpopen.c ===
/***
*wpopen.c - initiate a pipe and a child command (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wpopen().
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "popen.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wrmdir.c ===
/***
*wrmdir.c - remove directory (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wrmdir() - remove a directory
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "rmdir.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wperror.c ===
/***
*wperror.c - print system error message (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wperror() - print wide system error message
*       System error message are indexed by errno.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syserr.h>
#include <mtdll.h>
#include <io.h>
#include <dbgint.h>
#include <limits.h>
#include <internal.h>

/***
*void _wperror(wmessage) - print system error message
*
*Purpose:
*       prints user's error message, then follows it with ": ", then the system
*       error message, then a newline.  All output goes to stderr.  If user's
*       message is NULL or a null string, only the system error message is
*       printer.  If errno is weird, prints "Unknown error".
*
*Entry:
*       const wchar_t *wmessage - users message to prefix system error message
*
*Exit:
*       Prints message; no return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _wperror (
        const wchar_t *wmessage
        )
{
        int fh = 2;
        size_t size = 0;
        char *amessage;
        const char *sysmessage;

        /* convert WCS string into ASCII string */

        if ( wmessage && *wmessage )
        {
            _ERRCHECK_EINVAL_ERANGE(wcstombs_s( &size, NULL, 0, wmessage, INT_MAX));

            if ( size==0 || (amessage = (char *)_calloc_crt(size, sizeof(char))) == NULL )
                return;

            if ( _ERRCHECK_EINVAL_ERANGE(wcstombs_s(NULL, amessage, size, wmessage, _TRUNCATE)) != 0)
            {
                _free_crt(amessage);
                return;
            }
        }
        else
            amessage = NULL;

        _lock_fh( fh );         /* acquire file handle lock */
        __try {
                        if ( amessage )
                        {
                                        _write_nolock(fh,(char *)amessage,(unsigned)strlen(amessage));
                                        _write_nolock(fh,": ",2);
                        }

                        _free_crt(amessage);    /* note: freeing NULL is legal and benign */

                        sysmessage = _get_sys_err_msg( errno );
                        _write_nolock(fh, sysmessage,(unsigned)strlen(sysmessage));
                        _write_nolock(fh,"\n",1);
        }
        __finally {
            _unlock_fh( fh );   /* release file handle lock */
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\write.c ===
/***
*write.c - write to a file handle
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _write() - write to a file handle
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <ctype.h>
#include <io.h>
#include <errno.h>
#include <msdos.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <internal.h>
#include <setlocal.h>
#include <locale.h>
#include <wchar.h>

#define BUF_SIZE    5*1024    /* size of LF translation buffer */
                              /* default buffer is 4K, plus extra for LFs */

/***
*int _write(fh, buf, cnt) - write bytes to a file handle
*
*Purpose:
*       Writes count bytes from the buffer to the handle specified.
*       If the file was opened in text mode, each LF is translated to
*       CR-LF.  This does not affect the return value.  In text
*       mode ^Z indicates end of file.
*
*       Multi-thread notes:
*       (1) _write() - Locks/unlocks file handle
*           _write_nolock() - Does NOT lock/unlock file handle
*
*Entry:
*       int fh - file handle to write to
*       char *buf - buffer to write from
*       unsigned int cnt - number of bytes to write
*
*Exit:
*       returns number of bytes actually written.
*       This may be less than cnt, for example, if out of disk space.
*       returns -1 (and set errno) if fails.
*
*Exceptions:
*
*******************************************************************************/

/* define normal version that locks/unlocks, validates fh */
int __cdecl _write (
        int fh,
        const void *buf,
        unsigned cnt
        )
{
        int r;                          /* return value */


        /* validate handle */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        _lock_fh(fh);                   /* lock file */

        __try {
                if ( _osfile(fh) & FOPEN )
                        r = _write_nolock(fh, buf, cnt);    /* write bytes */
                else {
                        errno = EBADF;
                        _doserrno = 0;  /* not o.s. error */
                        r = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(fh);         /* unlock file */
        }

        return r;
}

/* now define version that doesn't lock/unlock, validate fh */
int __cdecl _write_nolock (
        int fh,
        const void *buf,
        unsigned cnt
        )
{
        int lfcount;            /* count of line feeds */
        int charcount;          /* count of chars written so far */
        int written;            /* count of chars written on this write */
        ULONG dosretval;        /* o.s. return value */
        char tmode ;            /* textmode - ANSI or UTF-16 */
        BOOL toConsole = 0;     /* true when writing to console */
        BOOL isCLocale = 0;     /* true when locale handle is C locale */

        lfcount = charcount = 0;        /* nothing written yet */

        if (cnt == 0)
                return 0;               /* nothing to do */

        _VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1 );

        tmode = _textmode(fh);

        if(tmode == __IOINFO_TM_UTF16LE ||
                tmode == __IOINFO_TM_UTF8)
        {
            /* For a UTF-16 file, the count must always be an even number */
            _VALIDATE_CLEAR_OSSERR_RETURN(((cnt & 1) == 0), EINVAL, -1);
        }

        if (_osfile(fh) & FAPPEND) {
                /* appending - seek to end of file; ignore error, because maybe
                   file doesn't allow seeking */
                (void)_lseeki64_nolock(fh, 0, FILE_END);
        }

        /* check for text mode with LF's in the buffer */

        /*
         * Note that in case the handle belongs to Console, write file will
         * generate garbage output. For user to print these characters
         * correctly, we will need to print ANSI.
         *
         * Also note that in case of printing to Console, we still have to
         * convert the characters to console codepage.
         */

        if (_isatty(fh) && (_osfile(fh) & FTEXT))
        {
            DWORD dwMode;
            _ptiddata ptd = _getptd();
            isCLocale = (ptd->ptlocinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE);
            toConsole = GetConsoleMode((HANDLE)_osfhnd(fh), &dwMode);
        }

        /* don't need double conversion if it's ANSI mode C locale */
        if (toConsole && !(isCLocale && (tmode == __IOINFO_TM_ANSI))) {
            UINT consoleCP = GetConsoleCP();
            char mboutbuf[MB_LEN_MAX];
            wchar_t tmpchar;
            int size = 0;
            int written = 0;
            char *pch;

            for (pch = (char *)buf; (unsigned)(pch - (char *)buf) < cnt; ) {
                BOOL bCR;

                if (tmode == __IOINFO_TM_ANSI) {
                    bCR = *pch == LF;
                    /*
                     * Here we need to do double convert. i.e. convert from
                     * multibyte to unicode and then from unicode to multibyte in
                     * Console codepage.
                     */

                    /*
                     * Here, we have take into account that _write() might be called
                     * byte by byte, so when we see a lead byte without a trail byte,
                     * we have to store it and return no error.
                     */
                    if ( _dbcsBufferUsed(fh) ) {
                        /*
                         * we got something buffered, join it with the lead byte
                         * and convert
                         */
                        _ASSERTE(isleadbyte(_dbcsBuffer(fh)));
                        mboutbuf[0]=_dbcsBuffer(fh);
                        mboutbuf[1] = *pch;
                        /* reseting the flag */
                        _dbcsBufferUsed(fh) = FALSE;

                        if (mbtowc(&tmpchar, mboutbuf, 2) == -1) {
                            break;
                        }
                    } else {
                        if (isleadbyte(*pch)) {
                            if ((cnt - (pch - (char*)buf)) > 1) {
                                // and we have more bytes to read, just convert
                                if (mbtowc(&tmpchar, pch, 2) == -1) {
                                    break;
                                }
                                /*
                                 * Increment pch to accomodate DBCS character.
                                 */
                                ++pch;
                            } else {
                                /* and we ran out of bytes to read, buffer the lead byte */
                                _dbcsBuffer(fh) = *pch;
                                _dbcsBufferUsed(fh) = TRUE;

                                /* lying that we actually wrote the last character,
                                 * so it doesn't error
                                 */
                                charcount++;
                                break;
                            }
                        } else {
                            // single char conversion
                            if (mbtowc(&tmpchar, pch, 1) == -1) {
                                break;
                            }
                        }
                    }
                    ++pch;
                } else if (tmode == __IOINFO_TM_UTF8 || tmode == __IOINFO_TM_UTF16LE) {
                    /*
                     * Note that bCR set above is not valid in case of UNICODE
                     * stream. We need to set it using unicode character.
                     */
                    tmpchar = *(wchar_t *)pch;
                    bCR = tmpchar == LF;
                    pch += 2;
                }

                if (tmode == __IOINFO_TM_ANSI)
                {
                    if( (size = WideCharToMultiByte(consoleCP,
                                                    0,
                                                    &tmpchar,
                                                    1,
                                                    mboutbuf,
                                                    sizeof(mboutbuf),
                                                    NULL,
                                                    NULL)) == 0) {
                        break;
                    } else {
                        if ( WriteFile( (HANDLE)_osfhnd(fh),
                                        mboutbuf,
                                        size,
                                        (LPDWORD)&written,
                                        NULL) ) {
                            /* When we are converting, some convertion can result in
                             * 2 mbcs char -> 1 wchar -> 1 mbcs
                             * (ie. printing out Japanese characters in English ConsoleCP,
                             * the Japanese char will be converted to a single question mark)
                             * Therefore, we want to use how many bytes we converted + lfcount
                             * instead of how many bytes we actually wrote
                             */
                            charcount = lfcount + (int)(pch - (char*) buf);
                            if (written < size)
                                break;
                        } else {
                            dosretval = GetLastError();
                            break;
                        }
                    }

                    if (bCR) {
                        size = 1;
                        mboutbuf[0] = CR;
                        if (WriteFile((HANDLE)_osfhnd(fh),
                                      mboutbuf,
                                      size,
                                      (LPDWORD)&written,
                                      NULL) ) {
                            if (written < size)
                                break;
                            lfcount ++;
                            charcount++;
                        } else {
                            dosretval = GetLastError();
                            break;
                        }
                    }
                }
                else if ( tmode == __IOINFO_TM_UTF8 || tmode == __IOINFO_TM_UTF16LE)
                {
                    if ( _putwch_nolock(tmpchar) == tmpchar )
                    {
                        charcount+=2;
                    }
                    else
                    {
                        dosretval = GetLastError();
                        break;
                    }
                    if (bCR) /* emit carriage return */
                    {
                        size = 1;
                        tmpchar = CR;
                        if ( _putwch_nolock(tmpchar) == tmpchar )
                        {
                            charcount++;
                            lfcount++;
                        }
                        else
                        {
                            dosretval = GetLastError();
                            break;
                        }
                    }
                }
            }
        } else if ( _osfile(fh) & FTEXT ) {
            /* text mode, translate LF's to CR/LF's on output */

            dosretval = 0;          /* no OS error yet */

            if(tmode == __IOINFO_TM_ANSI) {
                char ch;                    /* current character */
                char *p = NULL, *q = NULL;  /* pointers into buf and lfbuf resp. */
                char lfbuf[BUF_SIZE];
                p = (char *)buf;        /* start at beginning of buffer */
                while ( (unsigned)(p - (char *)buf) < cnt ) {
                    q = lfbuf;      /* start at beginning of lfbuf */

                    /* fill the lf buf, except maybe last char */
                    while ( q - lfbuf < sizeof(lfbuf) - 1 &&
                            (unsigned)(p - (char *)buf) < cnt ) {
                        ch = *p++;
                        if ( ch == LF ) {
                            ++lfcount;
                            *q++ = CR;
                        }
                        *q++ = ch;
                    }

                    /* write the lf buf and update total */
                    if ( WriteFile( (HANDLE)_osfhnd(fh),
                                lfbuf,
                                (int)(q - lfbuf),
                                (LPDWORD)&written,
                                NULL) )
                    {
                        charcount += written;
                        if (written < q - lfbuf)
                            break;
                    }
                    else {
                        dosretval = GetLastError();
                        break;
                    }
                }
            } else if ( tmode == __IOINFO_TM_UTF16LE ){
                char lfbuf[BUF_SIZE];
                wchar_t wch;            /* current wide char */
                wchar_t *pu = (wchar_t *)buf;
                wchar_t *qu = NULL;

                while ( (unsigned)((char *)pu - (char *)buf) < cnt ) {
                    qu = (wchar_t *)lfbuf; /* start at beginning of lfbuf */

                    /* fill the lf buf, except maybe last wchar_t */
                    while ( (((char *)qu - lfbuf) < (sizeof(lfbuf) - 2)) &&
                            ((unsigned)((char *)pu - (char *)buf) < cnt )) {
                        wch = *pu++;
                        if ( wch == LF ) {
                            lfcount+=2;
                            *qu++ = CR;
                        }
                        *qu++ = wch;
                    }

                    /* write the lf buf and update total */
                    if ( WriteFile( (HANDLE)_osfhnd(fh),
                                lfbuf,
                                (int)((char*)qu - lfbuf),
                                (LPDWORD)&written,
                                NULL) )
                    {
                        charcount += written;
                        if (written < ((char *)qu - lfbuf))
                            break;
                    }
                    else {
                        dosretval = GetLastError();
                        break;
                    }
                }
            } else {
                /*
                 * Let's divide the lfbuf in 1:2 wher 1 is for storing
                 * widecharacters and 2 if for converting it to UTF8.  This takes
                 * into account the worst case scenario where all the UTF8
                 * characters are 4 byte long.
                 */
                char utf8_buf[(BUF_SIZE*2)/3];
                wchar_t utf16_buf[BUF_SIZE/6];

                wchar_t wch;            /* current wide char */
                wchar_t *pu = (wchar_t *)buf;
                wchar_t *qu = NULL;

                pu = (wchar_t *)buf;
                while ((unsigned)((char *)pu - (char *)buf) < cnt) {
                    int bytes_converted = 0;
                    qu = utf16_buf; /* start at beginning of lfbuf */

                    while ( (((char *)qu - (char *)utf16_buf) <
                             (sizeof(utf16_buf) - 2)) &&
                            ((unsigned)((char *)pu - (char *)buf) < cnt )) {
                        wch = *pu++;
                        if ( wch == LF ) {
                            /* no need to count the linefeeds here: we calculate the written chars in another way */
                            *qu++ = CR;
                        }
                        *qu++ = wch;
                    }

                    bytes_converted = WideCharToMultiByte(
                            CP_UTF8,
                            0,
                            utf16_buf,
                            ((int)((char *)qu - (char *)utf16_buf))/2,
                            utf8_buf,
                            sizeof(utf8_buf),
                            NULL,
                            NULL);

                    if (bytes_converted == 0) {
                        dosretval = GetLastError();
                        break;
                    } else {
                        /*
                         * Here we need to make every attempt to write all the
                         * converted characters. The resaon behind this is,
                         * incase half the bytes of a UTF8 character is
                         * written, it may currupt whole of the stream or file.
                         *
                         * The loop below will make sure we exit only if all
                         * the bytes converted are written (which makes sure no
                         * partial MBCS is written) or there was some error in
                         * the stream.
                         */
                        int bytes_written = 0;
                        do {
                            if (WriteFile(
                                        (HANDLE)_osfhnd(fh),
                                        utf8_buf + bytes_written,
                                        bytes_converted - bytes_written,
                                        &written,
                                        NULL)) {
                                bytes_written += written;
                            } else {
                                dosretval = GetLastError();
                                break;
                            }
                        } while ( bytes_converted > bytes_written);

                        /*
                         * Only way the condition below could be true is if
                         * there was en error. In case of error we need to
                         * break this loop as well.
                         */
                        if (bytes_converted > bytes_written) {
                            break;
                        }
                        /* if this chunk has been committed successfully, update charcount */
                        charcount = (int)((char *)pu - (char *)buf);
                    }
                }
            }
        }
        else {
                /* binary mode, no translation */
                if ( WriteFile( (HANDLE)_osfhnd(fh),
                                (LPVOID)buf,
                                cnt,
                               (LPDWORD)&written,
                                NULL) )
                {
                        dosretval = 0;
                        charcount = written;
                }
                else
                        dosretval = GetLastError();
        }

        if (charcount == 0) {
                /* If nothing was written, first check if an o.s. error,
                   otherwise we return -1 and set errno to ENOSPC,
                   unless a device and first char was CTRL-Z */
                if (dosretval != 0) {
                        /* o.s. error happened, map error */
                        if (dosretval == ERROR_ACCESS_DENIED) {
                            /* wrong read/write mode should return EBADF, not
                               EACCES */
                                errno = EBADF;
                                _doserrno = dosretval;
                        }
                        else
                                _dosmaperr(dosretval);
                        return -1;
                }
                else if ((_osfile(fh) & FDEV) && *(char *)buf == CTRLZ)
                        return 0;
                else {
                        errno = ENOSPC;
                        _doserrno = 0;  /* no o.s. error */
                        return -1;
                }
        }
        else
                /* return adjusted bytes written */
                return charcount - lfcount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wrename.c ===
/***
*wrename.c - rename file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines wrename() - rename a file
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "rename.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wputenv.c ===
/***
*wputenv.c - put an environment variable into the environment (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wputenv() - adds a new variable to environment; does not
*       change global environment, only the process' environment.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "putenv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wprintf.c ===
/***
*wprintf.c - print formatted
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wprintf() - print formatted data
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <stddef.h>

/***
*int wprintf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on stdout using the format string to
*       format data and getting as many arguments as called for
*       Uses temporary buffering to improve efficiency.
*       _output does the real work here
*
*Entry:
*       wchar_t *format - format string to control data format/number of arguments
*       followed by list of arguments, number and type controlled by
*       format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wprintf (
        const wchar_t *format,
        ...
        )
/*
 * stdout 'W'char_t 'PRINT', 'F'ormatted
 */
{
        va_list arglist;
        int buffing;
        int retval;

        _VALIDATE_RETURN( (format != NULL), EINVAL, -1);

        va_start(arglist, format);

        _lock_str2(1, stdout);
        __try {
        buffing = _stbuf(stdout);

        retval = _woutput_l(stdout,format,NULL,arglist);

        _ftbuf(buffing, stdout);
        }
        __finally {
            _unlock_str2(1, stdout);
        }

        return(retval);
}

errno_t __cdecl _wprintf_l (
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vwprintf_l(format, plocinfo, arglist);
}

errno_t __cdecl _wprintf_s_l (
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vwprintf_s_l(format, plocinfo, arglist);
}

errno_t __cdecl wprintf_s (
        const wchar_t *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vwprintf_s_l(format, NULL, arglist);
}

errno_t __cdecl _wprintf_p_l (
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vwprintf_p_l(format, plocinfo, arglist);
}

errno_t __cdecl _wprintf_p (
        const wchar_t *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vwprintf_p_l(format, NULL, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wscanf.c ===
/***
*wscanf.c - read formatted data from stdin
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wscanf() - reads formatted data from stdin
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vwscanf(format, ...)
*
*Purpose:
*       This is a helper function to be called from wscanf & wscanf_s
*
*Entry:
*       char *format - format string
*       va_list arglist - arglist of output pointers
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vwscanf (
        WINPUTFN winputfn,
        const wchar_t *format,
        _locale_t plocinfo,
        va_list arglist
        )
/*
 * stdin 'W'char_t 'SCAN', 'F'ormatted
 */
{
        int retval;

        _VALIDATE_RETURN( (format != NULL), EINVAL, EOF);

        _lock_str2(0, stdin);
        __try {
            retval = (winputfn(stdin, format, plocinfo, arglist));
        }
        __finally {
            _unlock_str2(0, stdin);
        }

        return(retval);
}

/***
*int wscanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       Reads formatted data from stdin into arguments.  _input does the real
*       work here.
*
*Entry:
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
int __cdecl wscanf (
        const wchar_t *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vwscanf(_winput_l, format, NULL, arglist);
}

int __cdecl _wscanf_l (
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vwscanf(_winput_l, format, plocinfo, arglist);
}

/***
*int wscanf_s(format, ...)
*
*   Same as wscanf above except that it calls _input_s to do the real work.
*   _input_s has a size check for array parameters.
*
*******************************************************************************/
int __cdecl wscanf_s (
        const wchar_t *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vwscanf(_winput_s_l, format, NULL, arglist);
}

int __cdecl _wscanf_s_l (
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vwscanf(_winput_s_l, format, plocinfo, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wrt2err.c ===
/***
*wrt2err.c - write an LSTRING to stderr (Win32 version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains a routine __wrt2err that writes an LSTRING
*       (one byte length followed by the several bytes of the string)
*       to the standard error handle (2).  This is a helper routine used
*       for MATH error messages (and also FORTRAN error messages).
*
*******************************************************************************/


#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>

/***
*__wrt2err(msg) - write an LSTRING to stderr
*
*Purpose:
*       Takes a pointer to an LSTRING which is to be written to standard error.
*       An LSTRING is a one-byte length followed by that many bytes for the
*       character string (as opposed to a null-terminated string).
*
*Entry:
*       char *msg = pointer to LSTRING to write to standard error.
*
*Exit:
*       Nothing returned.
*
*Exceptions:
*       None handled.
*
*******************************************************************************/

void __cdecl __wrt2err (
        char *msg
        )
{
        unsigned long length;           /* length of string to write */
        unsigned long numwritten;       /* number of bytes written */

        length = *msg++;                /* 1st byte is length */

        /* write the message to stderr */

        WriteFile((HANDLE)_osfhnd(2), msg, length, &numwritten, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsetenv.c ===
/***
*setenv.c -set an environment variable in the environment (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __crtwsetenv() - adds a new variable to environment.
*       Internal use only.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "setenv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsearche.c ===
/***
*wsearche.c - find a file using paths from an environment variable (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       to search a set a directories specified by an environment variable
*       for a specified file name.  If found the full path name is returned.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "searchen.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspawnl.c ===
/***
*wspawnl.c - spawn a child process (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnl() - spawn a child process
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnl.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsetloca.c ===
/***
*wsetlocal.c - Contains the setlocale function (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the _wsetlocale() function.
*
*******************************************************************************/


#include <wchar.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <dbgint.h>
#include <mtdll.h>
#include <internal.h>
#include <malloc.h>

#define MAXSIZE ((MAX_LC_LEN+1) * (LC_MAX-LC_MIN+1) + CATNAMES_LEN)

wchar_t * __cdecl _wsetlocale (
        int _category,
        const wchar_t *_wlocale
        )
{
        size_t size = 0;
        char *inlocale = NULL;
        char *outlocale;
        pthreadlocinfo ptloci;
        int *refcount = NULL;
        wchar_t *outwlocale = NULL;
        _locale_tstruct locale;
        _ptiddata ptd;

        /* convert WCS string into ASCII string */

        if (_wlocale)
        {
            _ERRCHECK_EINVAL_ERANGE(wcstombs_s(&size, NULL, 0, _wlocale, INT_MAX));
            if (size==0 || (inlocale = (char *)_calloc_crt(size, sizeof(char))) == NULL)
                return NULL;
            if (_ERRCHECK_EINVAL_ERANGE(wcstombs_s(NULL, inlocale, size, _wlocale, _TRUNCATE)) != 0)
            {
                _free_crt (inlocale);
                return NULL;
            }
        }

        /* set the locale and get ASCII return string */

        outlocale = setlocale(_category, inlocale);
        _free_crt (inlocale);
        if (NULL == outlocale)
            return NULL;

        // We now have a locale string, but the global locale can be changed by
        // another thread. If we allow this thread's locale to be updated before we're done
        // with this string, it might be freed from under us.
        // Call versions of the MB-to-wide-char conversions that do not update the current thread's
        // locale.

        ptd = _getptd();
        locale.locinfo = ptd->ptlocinfo;
        locale.mbcinfo = ptd->ptmbcinfo;

        /* get space for WCS return value, first call only */

        size = 0;
        if (_ERRCHECK_EINVAL_ERANGE(_mbstowcs_s_l(&size, NULL, 0, outlocale, 0, &locale)) != 0)
            return NULL;

        /* ensure that (size * num) does not overflow */
        if(((_HEAP_MAXREQ-sizeof(int)) / sizeof(wchar_t)) < size)
        {
            return NULL;
        }
        refcount = (int *)_malloc_crt(size * sizeof(wchar_t) + sizeof(int));
        if (!refcount)
            return NULL;
        outwlocale = (wchar_t *)&refcount[1];

        /* convert return value to WCS */

        if ( _ERRCHECK_EINVAL_ERANGE(_mbstowcs_s_l(NULL, outwlocale, size, outlocale, _TRUNCATE, &locale)) != 0)
        {
            _free_crt(refcount);
            return NULL;
        }

        ptloci = locale.locinfo;
        _mlock(_SETLOCALE_LOCK);
        __try {
            _ASSERTE(((ptloci->lc_category[_category].wlocale != NULL) && (ptloci->lc_category[_category].wrefcount != NULL)) ||
                     ((ptloci->lc_category[_category].wlocale == NULL) && (ptloci->lc_category[_category].wrefcount == NULL)));
            if (ptloci->lc_category[_category].wrefcount != NULL &&
                InterlockedDecrement(ptloci->lc_category[_category].wrefcount) == 0) {
                _free_crt(ptloci->lc_category[_category].wrefcount);
            }

            if (!(ptd->_ownlocale & _PER_THREAD_LOCALE_BIT) &&
                        !(__globallocalestatus & _GLOBAL_LOCALE_BIT)) {
                if (ptloci->lc_category[_category].wrefcount != NULL &&
                    InterlockedDecrement(ptloci->lc_category[_category].wrefcount) == 0) {
                    _free_crt(ptloci->lc_category[_category].wrefcount);
                }
            }

            /*
             * Note that we are using a risky trick here.  We are adding this
             * wlocale to an existing threadlocinfo struct, and thus starting
             * the wlocale's wrefcount with the same value as the whole struct.
             * That means all code which modifies both threadlocinfo::refcount
             * and threadlocinfo::lc_category[]::wrefcount in structs that are
             * potentially shared across threads must make those modifications
             * under _SETLOCALE_LOCK.  Otherwise, there's a race condition
             * for some other thread modifying threadlocinfo::refcount after
             * we load it but before we store it to wrefcount.
             */
            *refcount = ptloci->refcount;
            ptloci->lc_category[_category].wrefcount = refcount;
            ptloci->lc_category[_category].wlocale = outwlocale;
        }
        __finally {
            _munlock(_SETLOCALE_LOCK);
        }

        return outwlocale;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsetargv.c ===
/***
*wsetargv.c - generic _wsetargv routine (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Linking in this module replaces the normal wsetargv with the
*       wildcard wsetargv.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>

/***
*_wsetargv - sets wargv by calling __wsetargv
*
*Purpose:
*       Routine directly transfers to __wsetargv.
*
*Entry:
*       See __wsetargv.
*
*Exit:
*       See __wsetargv.
*
*Exceptions:
*       See __wsetargv.
*
*******************************************************************************/

int __CRTDECL  _wsetargv (
        void
        )
{
        return __wsetargv();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspawnv.c ===
/***
*wspawnv.c - spawn a child process (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnv() - spawn a child process
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspawnle.c ===
/***
*wspawnle.c - spawn a child process with given environment (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnle() - spawn a child process with given environ
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnle.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspawnlp.c ===
/***
*wspawnlp.c - spawn a file; search along PATH (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnlp() - spawn a file with search along PATH
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnlp.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsplitpa.c ===
/***
*wsplitpt.c - break down path name into components (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To provide support for accessing the individual components of an
*       arbitrary path name
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "splitpat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspawnvp.c ===
/***
*wspawnvp.c - spawn a child process; search along PATH (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnvp() - spawn a child process; search along PATH
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnvp.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsplitpath_s.c ===
/***
*wsplitpath_s.c - break down path name into components
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   To provide support for accessing the individual components of an
*   arbitrary path name
*
*******************************************************************************/

#include <stdlib.h>
#include <mbstring.h>
#include <internal_securecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _wsplitpath_s
#define _CHAR wchar_t
#define _TCSNCPY_S wcsncpy_s
#define _T(_Character) L##_Character
#define _MBS_SUPPORT 0

#include <tsplitpath_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspawnve.c ===
/***
*wspawnve.c - Low level routine eventually called by all _wspawnXX routines
*       also contains all code for _wexecve, called by _wexecXX routines
*       (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       This is the low level routine which is eventually invoked by all the
*       _wspawnXX routines.
*
*       This is also the low-level routine which is eventually invoked by
*       all of the _wexecXX routines.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnve.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspwnvpe.c ===
/***
*wspwnvpe.c - spawn a child process with given environ (search PATH) (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnvpe() - spawn a child process with given environ (search
*       PATH)
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnvpe.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wspwnlpe.c ===
/***
*wspwnlpe.c - spawn a child process with environ and search along PATH (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wspawnlpe() - spawn a child process with environ/PATH search
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnlpe.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstat.c ===
/***
*wstat.c - get file status (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wstat() - get file status
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstat64.c ===
/***
*wstat64.c - get file status (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wstat64() - get file status
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef  _MBCS       /* UNICODE not _MBCS */

#include "stat64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstdargv.c ===
/***
*wstdargv.c - standard & wildcard _setargv routine (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line, with or without wildcard expansion
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "stdargv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstati64.c ===
/***
*wstati64.c - get file status (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wstati64() - get file status
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE
#define _UNICODE    1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE     1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstati32.c ===
/***
*wstati32.c - get file status (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wstat64i32() - get file status
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef  _MBCS       /* UNICODE not _MBCS */

#define _USE_INT64 0

#include "stat64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstdenvp.c ===
/***
*wstdenvp.c - standard _setenvp routine (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module is called by the C start-up routine to set up "_wenviron".
*       Its sets up an array of pointers to strings in the environment.
*       The global symbol "_wenviron" is set to point to this array.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "stdenvp.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstrdate.c ===
/***
*wstrdate.c - contains the function "_wstrdate()" (wchar_t version)
*             and "_wstrdate_s" (wchar_t secure version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the function _wstrdate() and _wstrdate_s
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "strdate.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wstrtime.c ===
/***
*wstrtime.c - contains the function "_wstrtime()"
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the function _wstrtime()
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "strtime.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wsystem.c ===
/***
*wsystem.c - pass a command line to the shell (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wsystem() - passes a command to the shell
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "system.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wtmpfile.c ===
/***
*wtmpfile.c - create unique file name or file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wtmpnam().
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "tmpfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wtime.inl ===
/***
*wtime.inl - inline definitions for wctime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of wctime().
*
*       [Public]
*
****/

#pragma once

#if !defined (__CRTDECL)
#if defined (_M_CEE_PURE)
#define __CRTDECL
#else  /* defined (_M_CEE_PURE) */
#define __CRTDECL   __cdecl
#endif  /* defined (_M_CEE_PURE) */
#endif  /* !defined (__CRTDECL) */

#ifndef _INC_WTIME_INL
#define _INC_WTIME_INL
#ifndef RC_INVOKED

#pragma warning(push)
#pragma warning(disable:4996)

#ifdef _USE_32BIT_TIME_T
static __inline wchar_t * __CRTDECL _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime32(_Time);
#pragma warning( pop )
}

static __inline errno_t __CRTDECL _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime32_s(_Buffer, _SizeInWords, _Time);
}
#else  /* _USE_32BIT_TIME_T */
static __inline wchar_t * __CRTDECL _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __CRTDECL _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#endif  /* _USE_32BIT_TIME_T */

#pragma warning(pop)

#endif  /* RC_INVOKED */
#endif  /* _INC_WTIME_INL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wtempnam.c ===
/***
*wtempnam.c - generate unique file name (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "tempnam.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wtof.c ===
/***
*wtof.c - convert wchar_t string to floating point number
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into a floating point number.
*
*******************************************************************************/

#ifndef _UNICODE
#define _UNICODE
#endif  /* _UNICODE */

#include <stdlib.h>
#include <math.h>
#include <cruntime.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*double _wtof(ptr) - convert wide char string to floating point number
*
*Purpose:
*       _wtof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       ptr - pointer to wide char string to convert
*
*Exit:
*       returns floating point value of wide character representation
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
double __cdecl _wtof_l(
        REG1 const wchar_t *nptr,
        _locale_t plocinfo
        )
{
        struct _flt fltstruct;      /* temporary structure */
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(nptr != NULL, EINVAL, 0.0);

        /* scan past leading space/tab characters */
        while ( iswspace(*nptr) )
                nptr++;

        /* let _fltin routine do the rest of the work */
        return( *(double *)&(_wfltin2( &fltstruct, nptr, _loc_update.GetLocaleT() )->dval) );
}

double __cdecl _wtof
(
    REG1 const wchar_t *nptr
)
{
    return _wtof_l(nptr, NULL);
}

unsigned int __wstrgtold12
(
    _LDBL12 *pld12,
    const wchar_t * *p_end_ptr,
    const wchar_t * str,
    int mult12,
    int scale,
    int decpt,
    int implicit_E
)
{
        _LocaleUpdate _loc_update(NULL);

        return __wstrgtold12_l(pld12, p_end_ptr, str, mult12, scale, decpt, implicit_E, _loc_update.GetLocaleT());
}

unsigned __WSTRINGTOLD
(
        _LDOUBLE *pld,
        const wchar_t  * *p_end_ptr,
        const wchar_t  *str,
        int mult12
)
{
        _LocaleUpdate _loc_update(NULL);

        return __WSTRINGTOLD_L(pld, p_end_ptr, str, mult12, _loc_update.GetLocaleT());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wunlink.c ===
/***
*wunlink.c - unlink a file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wunlink() - unlink a file
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "unlink.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wtox.c ===
/***
*wtox.c - _wtoi and _wtol conversion
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into an int or long.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE
#endif  /* _UNICODE */

#include <wchar.h>
#include "atox.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wtombenv.c ===
/***
*wtombenv.c - convert wide environment block to multibyte
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __wtomb_environ(). Create a multibyte equivalent of
*       an existing wide character environment block.
*
*******************************************************************************/


#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <dbgint.h>

/***
*__wtomb_environ - copy wide environment block to multibyte environment block
*
*Purpose:
*       Create a multibyte equivalent of an existing wide character
*       environment block.
*
*Entry:
*       Assume _wenviron (global pointer) points to existing wide
*       environment block.
*
*Exit:
*       If success, every wide environment variable has been added to
*       the multibyte environment block and returns 0.
*       If failure, returns -1.
*
*Exceptions:
*       If space cannot be allocated, returns -1.
*
*******************************************************************************/

int __cdecl __wtomb_environ (
        void
        )
{
        char *envp=NULL;
        wchar_t **wenvp = _wenviron;

        /*
         * For every environment variable in the multibyte environment,
         * convert it and add it to the wide environment.
         */

        while (*wenvp)
        {
            int size;

            /* find out how much space is needed */
            if ((size = WideCharToMultiByte(CP_ACP, 0, *wenvp, -1, NULL, 0, NULL, NULL)) == 0)
                return -1;

            /* allocate space for variable */
            if ((envp = (char *) _calloc_crt(size, sizeof(char))) == NULL)
                return -1;

            /* convert it */
            if (WideCharToMultiByte(CP_ACP, 0, *wenvp, -1, envp, size, NULL, NULL) == 0)
            {
                _free_crt(envp);
                return -1;
            }

            /* set it - this is not primary call, so set primary == 0 */
            if(__crtsetenv(&envp, 0)<0)
            {
                if(envp)
                {
                    _free_crt(envp);
                    envp=NULL;
                }
            }

            wenvp++;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wutime64.c ===
/***
*wutime64.c - set modification time for a file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "utime64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wwncmdln.c ===
/***
*wwncmdln.c - process command line for wWinMain
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prepare command line to be passed to wWinMain.
*
*******************************************************************************/


#define WPRFLAG     1

#ifndef _UNICODE
#define _UNICODE    1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE     1
#endif  /* UNICODE */

#undef  _MBCS       /* UNICODE not _MBCS */

#include "wincmdln.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wwild.c ===
/***
*wwild.c - wildcard expander (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*        expands wildcards in argv
*
*        handles L'*' (none or more of any char) and L'?' (exactly one char)
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "wild.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wutime.c ===
/***
*wutime.c - set modification time for a file (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "utime.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\wwincrt0.c ===
/***
*wwincrt0.c - C runtime Windows EXE start-up routine, wchar_t version
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps using wide
*       characters.  It calls the user's main routine wWinMain() after
*       performing C Run-Time Library initialization.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#define _WINMAIN_
#include "crt0.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\w_cmp.c ===
/***
*w_cmp.c - W versions of CompareString.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Wrapper for CompareStringW.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <dbgint.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <mtdll.h>
#include <setlocal.h>
#include <string.h>

/***
*int __cdecl __crtCompareStringW - Get type information about a wide string.
*
*Purpose:
*  Internal support function. Assumes info in wide string format.
*
*Entry:
*  LCID     Locale      - locale context for the comparison.
*  DWORD    dwCmpFlags  - see NT\Chicago docs
*  LPCWSTR  lpStringn   - wide string to be compared
*  int      cchCountn   - wide char (word) count (NOT including NULL)
*                       (-1 if NULL terminated)
*
*Exit:
*  Success: 1 - if lpString1 <  lpString2
*           2 - if lpString1 == lpString2
*           3 - if lpString1 >  lpString2
*  Failure: 0
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl __crtCompareStringW(
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCWSTR  lpString1,
        int      cchCount1,
        LPCWSTR  lpString2,
        int      cchCount2
        )
{
    /*
     * CompareString will compare past NULL. Must find NULL if in string
     * before cchCountn wide characters.
     */

    if (cchCount1 > 0)
        cchCount1= (int) wcsnlen(lpString1, cchCount1);
    if (cchCount2 > 0)
        cchCount2= (int) wcsnlen(lpString2, cchCount2);

    if (!cchCount1 || !cchCount2)
        return (cchCount1 - cchCount2 == 0) ? 2 :
               (cchCount1 - cchCount2 < 0) ? 1 : 3;

    return CompareStringW( Locale,
                           dwCmpFlags,
                           lpString1,
                           cchCount1,
                           lpString2,
                           cchCount2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\w_map.c ===
/***
*w_map.c - W version of LCMapString.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Wrapper for LCMapStringW.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <mtdll.h>
#include <setlocal.h>
#include <string.h>

/***
*int __cdecl __crtLCMapStringW - Get type information about a wide string.
*
*Purpose:
*       Internal support function. Assumes info in wide string format.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       DWORD    dwMapFlags  - see NT\Chicago docs
*       LPCWSTR  lpSrcStr    - pointer to string to be mapped
*       int      cchSrc      - wide char (word) count of input string
*                              (including NULL if any)
*                              (-1 if NULL terminated)
*       LPWSTR   lpDestStr   - pointer to memory to store mapping
*       int      cchDest     - wide char (word) count of buffer (including NULL)
*
*       NOTE:    if LCMAP_SORTKEY is specified, then cchDest refers to number
*                of BYTES, not number of wide chars. The return string will be
*                a series of bytes with a NULL byte terminator.
*
*Exit:
*       Success: if LCMAP_SORKEY:
*                   number of bytes written to lpDestStr (including NULL byte
*                   terminator)
*               else
*                   number of wide characters written to lpDestStr (including
*                   NULL)
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtLCMapStringW(
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCWSTR  lpSrcStr,
        int      cchSrc,
        LPWSTR   lpDestStr,
        int      cchDest
        )
{
    /*
     * LCMapString will map past NULL. Must find NULL if in string
     * before cchSrc wide characters.
     */
    if (cchSrc > 0)
        cchSrc = (int) wcsnlen(lpSrcStr, cchSrc);

    return LCMapStringW( Locale, dwMapFlags, lpSrcStr, cchSrc,
                         lpDestStr, cchDest );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xcosh.c ===
/* _Cosh function */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Cosh(double x, double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_Dtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1.0, -1);
			return (y * (x + 0.25 / x));
			}
		switch (_Exp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\w_env.c ===
/***
*w_env.c - W version of GetEnvironmentStrings.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Wrapper for GetEnvironmentStringsW.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

/***
*LPVOID __cdecl __crtGetEnvironmentStringsW - Get wide environment.
*
*Purpose:
*       Internal support function.
*
*Entry:
*       VOID
*
*Exit:
*       LPVOID - pointer to environment block
*
*Exceptions:
*
*******************************************************************************/

LPVOID __cdecl __crtGetEnvironmentStringsW(
        VOID
        )
{
    void *penv;
    wchar_t *pwch;
    wchar_t *wbuffer;
    int total_size;

    if ( NULL == (penv = GetEnvironmentStringsW()) )
        return NULL;

    /* find out how big a buffer is needed */

    pwch = penv;
    while ( *pwch != L'\0' ) {
        if ( *++pwch == L'\0' )
            pwch++;
    }

    total_size = (int)((char *)pwch - (char *)penv) +
                 (int)sizeof( wchar_t );

    /* allocate the buffer */

    if ( NULL == (wbuffer = _malloc_crt( total_size )) ) {
        FreeEnvironmentStringsW( penv );
        return NULL;
    }

    /* copy environment strings to buffer */

    memcpy( wbuffer, penv, total_size );

    FreeEnvironmentStringsW( penv );

    return (LPVOID)wbuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xdebug.cpp ===
// new and delete operators for debug CRT heap use by C++ Library

 #if defined(_DEBUG)
  #include <xdebug>
  #include <crtdbg.h>

void * __CRTDECL operator new(size_t sz, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW_BAD_ALLOC
	{	// allocate storage with debugging information
	void *p = _malloc_dbg(sz, tag._Type, file, line);
	if (p == 0)
		{	// report out of memory
		static const std::bad_alloc nomem;
		_RAISE(nomem);
		}
	return (p);
	}

void * __CRTDECL operator new[](size_t sz, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW_BAD_ALLOC
	{	// allocate array storage with debugging information
	return (operator new(sz, tag, file, line));
	}

void  __CRTDECL operator delete(void *p, const std::_DebugHeapTag_t &tag, char *, int)
	_THROW0()
	{	// free storage
	_free_dbg(p, tag._Type);
	}

void  __CRTDECL operator delete[](void *p, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW0()
	{	// free array storage
	operator delete(p, tag, file, line);
	}

_STD_BEGIN
const _DebugHeapTag_t _DebugHeapTag = {_CRT_BLOCK};
_MRTIMP2 const _DebugHeapTag_t& __cdecl _DebugHeapTag_func()
{
    return _DebugHeapTag;
}
_STD_END

#pragma comment(linker, "/disallowlib:libc.lib")
#pragma comment(linker, "/disallowlib:libcmt.lib")

 #endif /* defined(_DEBUG) */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xdscale.c ===
/* _Dscale function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dscale(double *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)(char *)px;
	short xchar = (short)((ps[_D0] & _DMASK) >> _DOFF);

	if (xchar == _DMAX)
		return ((short)((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? _NANCODE : _INFCODE));
	else if (xchar == 0 && 0 < (xchar = _Dnorm(ps)))
		return (0);

	if (0 < lexp && _DMAX - xchar <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_D0] & _DSIGN ? -_Inf._Double : _Inf._Double;
		return (_INFCODE);
		}
	else if (-xchar < lexp)
		{	/* finite result, repack */
		ps[_D0] = (unsigned short)(ps[_D0] & ~_DMASK
			| (lexp + xchar) << _DOFF);
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = (unsigned short)(ps[_D0] & _DSIGN);

		ps[_D0] = (unsigned short)(1 << _DOFF | ps[_D0] & _DFRAC);
		lexp += xchar - 1;
		if (lexp < -(48 + 1 + _DOFF) || 0 <= lexp)
			{	/* certain underflow, return +/-0 */
			ps[_D0] = sign;
			ps[_D1] = 0;
			ps[_D2] = 0;
			ps[_D3] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			unsigned short psx = 0;

			for (; xexp <= -16; xexp += 16)
				{	/* scale by words */
				psx = ps[_D3] | (psx != 0 ? 1 : 0);
				ps[_D3] = ps[_D2];
				ps[_D2] = ps[_D1];
				ps[_D1] = ps[_D0];
				ps[_D0] = 0;
				}
			if ((xexp = (short)-xexp) != 0)
				{	/* scale by bits */
				psx = (ps[_D3] << (16 - xexp)) | (psx != 0 ? 1 : 0);
				ps[_D3] = (unsigned short)(ps[_D3] >> xexp
					| ps[_D2] << (16 - xexp));
				ps[_D2] = (unsigned short)(ps[_D2] >> xexp
					| ps[_D1] << (16 - xexp));
				ps[_D1] = (unsigned short)(ps[_D1] >> xexp
					| ps[_D0] << (16 - xexp));
				ps[_D0] >>= xexp;
				}

			ps[_D0] |= sign;
			if ((0x8000 < psx || 0x8000 == psx && (ps[_D3] & 0x0001) != 0)
				&& (++ps[_D3] & 0xffff) == 0
				&& (++ps[_D2] & 0xffff) == 0
				&& (++ps[_D1] & 0xffff) == 0)
				++ps[_D0];	/* round up */
			else if (ps[_D0] == sign && ps[_D1] == 0
				&& ps[_D2] == 0 && ps[_D3] == 0)
				return (0);
			return (_FINITE);
			}
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xalloc.cpp ===
// MINITHREADS
#include <stdexcept>
#include <windows.h>

namespace stdext {
    namespace threads {
        _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Mtx_new(void *& _Ptr) {
            _Ptr = new CRITICAL_SECTION;

            InitializeCriticalSection(static_cast<CRITICAL_SECTION *>(_Ptr));
        }

        _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Mtx_delete(void * _Ptr) {
             DeleteCriticalSection(static_cast<CRITICAL_SECTION *>(_Ptr));

             delete static_cast<CRITICAL_SECTION *>(_Ptr);
        }

        _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Mtx_lock(void * _Ptr) {
            EnterCriticalSection(static_cast<CRITICAL_SECTION *>(_Ptr));
        }

        _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Mtx_unlock(void * _Ptr) {
            LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(_Ptr));
        }
    } // namespace threads
} // namespace stdext

/*
 * Copyright (c) 1995-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.20:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xdateord.cpp ===
// xdateord -- look up date ordering for Microsoft
#include <cruntime.h>
#include <locale>
#include <mtdll.h>
#include <setlocal.h>

_C_STD_BEGIN
#ifndef MRTDLL
extern "C"
#endif
int __CLRCALL_PURE_OR_CDECL _Getdateorder()
	{	// return date order for current locale
	wchar_t buf[2] = {0};
	GetLocaleInfoW(___lc_handle_func()[LC_TIME], LOCALE_ILDATE,
		buf, sizeof (buf) / sizeof (buf[0]));
	return (buf[0] == L'0' ? std::time_base::mdy
		: buf[0] == L'1' ? std::time_base::dmy
		: buf[0] == L'2' ? std::time_base::ymd
		: std::time_base::no_order);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.20:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xdnorm.c ===
/* _Dnorm function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dnorm(unsigned short *ps)
	{	/* normalize double fraction */
	short xchar;
	unsigned short sign = (unsigned short)(ps[_D0] & _DSIGN);

	xchar = 1;
	if ((ps[_D0] &= _DFRAC) != 0 || ps[_D1]
		|| ps[_D2] || ps[_D3])
		{	/* nonzero, scale */
		for (; ps[_D0] == 0; xchar -= 16)
			{	/* shift left by 16 */
			ps[_D0] = ps[_D1], ps[_D1] = ps[_D2];
			ps[_D2] = ps[_D3], ps[_D3] = 0;
			}
		for (; ps[_D0] < 1 << _DOFF; --xchar)
			{	/* shift left by 1 */
			ps[_D0] = (unsigned short)(ps[_D0] << 1 | ps[_D1] >> 15);
			ps[_D1] = (unsigned short)(ps[_D1] << 1 | ps[_D2] >> 15);
			ps[_D2] = (unsigned short)(ps[_D2] << 1 | ps[_D3] >> 15);
			ps[_D3] <<= 1;
			}
		for (; 1 << (_DOFF + 1) <= ps[_D0]; ++xchar)
			{	/* shift right by 1 */
			ps[_D3] = (unsigned short)(ps[_D3] >> 1 | ps[_D2] << 15);
			ps[_D2] = (unsigned short)(ps[_D2] >> 1 | ps[_D1] << 15);
			ps[_D1] = (unsigned short)(ps[_D1] >> 1 | ps[_D0] << 15);
			ps[_D0] >>= 1;
			}
		ps[_D0] &= _DFRAC;
		}
	ps[_D0] |= sign;
	return (xchar);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xdtest.c ===
/* _Dtest function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dtest(double *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)(char *)px;

	if ((ps[_D0] & _DMASK) == _DMAX << _DOFF)
		return ((short)((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? _NANCODE : _INFCODE));
	else if ((ps[_D0] & ~_DSIGN) != 0 || ps[_D1] != 0
		|| ps[_D2] != 0 || ps[_D3] != 0)
		return ((ps[_D0] & _DMASK) == 0 ? _DENORM : _FINITE);
	else
		return (0);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfcosh.c ===
/* _FCosh function */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FCosh(float x, float y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_FDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1.0F, -1);
			return (y * (x + 0.25F / x));
			}
		switch (_FExp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xexp.c ===
/* _Exp function */
#include "xmath.h"
_C_STD_BEGIN

/* coefficients */
static const double p[] = {	/* courtesy Dr. Tim Prince */
	1.0,
	420.30235984910635,
	15132.70094680474802};
static const double q[] = {	/* courtesy Dr. Tim Prince */
	30.01511290683317,
	3362.72154416553028,
	30265.40189360949691};
static const double c1 = 22713.0 / 32768.0;
static const double c2 = 1.4286068203094172321214581765680755e-6;
static const double hugexp = HUGE_EXP;
static const double invln2 = 1.4426950408889634073599246810018921;

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Exp(double *px, double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0)
		{	/* certain underflow */
		*px = 0.0;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _Inf._Double;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		double g = *px * invln2;
		short xexp = (short)(g + (g < 0.0 ? - 0.5 : + 0.5));

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_Eps._Double < g && g < _Eps._Double)
			*px = y;
		else
			{	/* g*g worth computing */
			const double z = g * g;
			const double w = (q[0] * z + q[1]) * z + q[2];

			g *= (z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2.0 * y;
			--xexp;
			}
		return (_Dscale(px, (long)xexp + eoff));
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfdnorm.c ===
/* _FDnorm function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDnorm(unsigned short *ps)
	{	/* normalize float fraction */
	short xchar;
	unsigned short sign = (unsigned short)(ps[_F0] & _FSIGN);

	xchar = 1;
	if ((ps[_F0] &= _FFRAC) != 0 || ps[_F1])
		{	/* nonzero, scale */
		if (ps[_F0] == 0)
			ps[_F0] = ps[_F1], ps[_F1] = 0, xchar -= 16;
		for (; ps[_F0] < 1 << _FOFF; --xchar)
			{	/* shift left by 1 */
			ps[_F0] = (unsigned short)(ps[_F0] << 1 | ps[_F1] >> 15);
			ps[_F1] <<= 1;
			}
		for (; 1 << (_FOFF + 1) <= ps[_F0]; ++xchar)
			{	/* shift right by 1 */
			ps[_F1] = (unsigned short)(ps[_F1] >> 1 | ps[_F0] << 15);
			ps[_F0] >>= 1;
			}
		ps[_F0] &= _FFRAC;
		}
	ps[_F0] |= sign;
	return (xchar);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfdscale.c ===
/* _FDscale function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDscale(float *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)(char *)px;
	short xchar = (short)((ps[_F0] & _FMASK) >> _FOFF);

	if (xchar == _FMAX)
		return ((short)((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? _NANCODE : _INFCODE));
	else if (xchar == 0 && 0 < (xchar = _FDnorm(ps)))
		return (0);

	if (0 < lexp && _FMAX - xchar <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_F0] & _FSIGN ? -_FInf._Float : _FInf._Float;
		return (_INFCODE);
		}
	else if (-xchar < lexp)
		{	/* finite result, repack */
		ps[_F0] = (unsigned short)(ps[_F0] & ~_FMASK
			| (lexp + xchar) << _FOFF);
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = (unsigned short)(ps[_F0] & _FSIGN);

		ps[_F0] = (unsigned short)(1 << _FOFF | ps[_F0] & _FFRAC);
		lexp += xchar - 1;
		if (lexp < -(16 + 1 + _FOFF) || 0 <= lexp)
			{	/* underflow, return +/-0 */
			ps[_F0] = sign;
			ps[_F1] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			unsigned short psx = 0;

			if (xexp <= -16)
				{	/* scale by words */
				psx = ps[_F1] | (psx != 0 ? 1 : 0);
				ps[_F1] = ps[_F0];
				ps[_F0] = 0;
				xexp += 16;
				}
			if ((xexp = (short)-xexp) != 0)
				{	/* scale by bits */
				psx = (ps[_F1] << (16 - xexp)) | (psx != 0 ? 1 : 0);
				ps[_F1] = (unsigned short)(ps[_F1] >> xexp
					| ps[_F0] << (16 - xexp));
				ps[_F0] >>= xexp;
				}

			ps[_F0] |= sign;
			if ((0x8000 < psx || 0x8000 == psx && (ps[_F1] & 0x0001) != 0)
				&& (++ps[_F1] & 0xffff) == 0)
				++ps[_F0];	/* round up */
			else if (ps[_F0] == sign && ps[_F1] == 0)
				return (0);
			return (_FINITE);
			}
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xferaise.c ===
/* _Feraise function */
#include <yvals.h>
#include <errno.h>
#include <ymath.h>
_C_STD_BEGIN

#ifdef _Feraise
#undef _Feraise
#endif
void __CLRCALL_PURE_OR_CDECL _Feraise(int except)
	{	/* report floating-point exception */
	if ((except & (_FE_DIVBYZERO | _FE_INVALID)) != 0)
		errno = EDOM;
	else if ((except & (_FE_UNDERFLOW | _FE_OVERFLOW)) != 0)
		errno = ERANGE;
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfdtest.c ===
/* _FDtest function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDtest(float *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)(char *)px;

	if ((ps[_F0] & _FMASK) == _FMAX << _FOFF)
		return ((short)((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? _NANCODE : _INFCODE));
	else if ((ps[_F0] & ~_FSIGN) != 0 || ps[_F1] != 0)
		return ((ps[_F0] & _FMASK) == 0 ? _DENORM : _FINITE);
	else
		return (0);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfpostox.cpp ===
// xfpos -- _Postype_to_fpos_t and _Postype_to_mbstate_t conversions
#include <iosfwd>

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfexp.c ===
/* _FExp function */
#include "xmath.h"
_C_STD_BEGIN

static const float p[] = {	/* courtesy Dr. Tim Prince */
	1.0F,
	60.09114349F};
static const float q[] = {	/* courtesy Dr. Tim Prince */
	12.01517514F,
	120.18228722F};
static const float c1 = (22713.0F / 32768.0F);
static const float c2 = 1.4286068203094172321214581765680755e-6F;
static const float hugexp = FHUGE_EXP;
static const float invln2 = 1.4426950408889634073599246810018921F;

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FExp(float *px, float y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0F)
		{	/* certain underflow */
		*px = 0.0F;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _FInf._Float;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		float g = *px * invln2;
		short xexp = (short)(g + (g < 0.0F ? - 0.5F : + 0.5F));

		g = xexp;
		g = (float)((*px - g * c1) - g * c2);
		if (-_FEps._Float < g && g < _FEps._Float)
			*px = y;
		else
			{	/* g*g worth computing */
			const float z = g * g;
			const float w = q[0] * z + q[1];

			g *= z + p[1];
			*px = (w + g) / (w - g) * 2.0F * y;
			--xexp;
			}
		return (_FDscale(px, (long)xexp + eoff));
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfsinh.c ===
/* _FSinh function */
#include "xmath.h"
_C_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const float p[] = {	/* courtesy Dr. Tim Prince */
	0.00020400F,
	0.00832983F,
	0.16666737F,
	0.99999998F};

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FSinh(float x, float y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_FDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0F ? x : FSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0F)
			return (x < 0.0F ? -y : y);
		if (x < 0.0F)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _FRteps._Float)
			x *= y;	/* x tiny */
		else if (x < 1.0F)
			{
			float w = x * x;

			x += ((p[0] * w + p[1]) * w + p[2]) * w * x;
			x *= y;
			}
		else if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1.0F, -1);
			x = y * (x - 0.25F / x);
			}
		else
			switch (_FExp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
#undef NP
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xfvalues.c ===
/* values used by math functions -- IEEE 754 float version */
#if defined(_M_CEE_PURE)
#if defined(MRTDLL)
#undef MRTDLL
#endif
#if defined(MRTDLL)
#undef CRTDLL
#endif
#endif

#include "xmath.h"
_C_STD_BEGIN

		/* macros */
#define NBITS	(16 + _FOFF)

 #if _D0 == 0
  #define INIT(w0)		{w0, 0}
  #define INIT2(w0, w1)	{w0, w1}

 #else /* _D0 == 0 */
  #define INIT(w0)		{0, w0}
  #define INIT2(w0, w1)	{w1, w0}
 #endif /* _D0 == 0 */

		/* static data */
extern /* const */ _Dconst _FDenorm = {INIT2(0, 1)};
extern /* const */ _Dconst _FEps = {
	INIT((_FBIAS - NBITS - 1) << _FOFF)};
extern /* const */ _Dconst _FInf = {INIT(_FMAX << _FOFF)};
extern /* const */ _Dconst _FNan = {INIT((_FMAX << _FOFF)
	| (1 << (_FOFF - 1)))};
extern /* const */ _Dconst _FSnan = {INIT2(_FMAX << _FOFF, 1)};
extern /* const */ _Dconst _FRteps = {
	INIT((_FBIAS - NBITS / 2) << _FOFF)};

extern /* const */ float _FXbig = (NBITS + 1) * 347L / 1000;
extern /* const */ float _FZero = 0.0F;
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xkeycheck.h ===
// xkeycheck internal header
#pragma once
#ifndef _XKEYCHECK
#define _XKEYCHECK
#ifndef RC_INVOKED

 #if !defined(__cplusplus)

  #if defined(auto)	/* check C keywords */  \
	|| defined(break) \
	|| defined(case) \
	|| defined(char) \
	|| defined(const) \
	|| defined(continue) \
	|| defined(default) \
	|| defined(do) \
	|| defined(double) \
	|| defined(else) \
	|| defined(enum) \
	|| defined(extern) \
	|| defined(float) \
	|| defined(for) \
	|| defined(goto) \
	|| defined(if) \
	|| defined(inline) \
	|| defined(int) \
	|| defined(long) \
	|| defined(register) \
	|| defined(restrict) \
	|| defined(return) \
	|| defined(short) \
	|| defined(signed) \
	|| defined(sizeof) \
	|| defined(static) \
	|| defined(struct) \
	|| defined(switch) \
	|| defined(typedef) \
	|| defined(union) \
	|| defined(unsigned) \
	|| defined(using) \
	|| defined(void) \
	|| defined(volatile) \
	|| defined(while) \
	|| defined(_Bool) \
	|| defined(_Complex) \
	|| defined(_Imaginary)
   #error keyword defined before including C standard header
  #endif /* defined... */

 #else 	/* __cplusplus is defined */

  #if defined(alignas)	/* check C++ keywords */ \
	|| defined(alignof) \
	|| defined(asm) \
	|| defined(auto) \
	|| defined(bool) \
	|| defined(break) \
	|| defined(case) \
	|| defined(catch) \
	|| defined(char) \
	|| defined(char16_t) \
	|| defined(char32_t) \
	|| defined(class) \
	|| defined(const) \
	|| defined(constexpr) \
	|| defined(const_cast) \
	|| defined(continue) \
	|| defined(decltype) \
	|| defined(default) \
	|| defined(delete) \
	|| defined(do) \
	|| defined(double) \
	|| defined(dynamic_cast) \
	|| defined(else) \
	|| defined(enum) \
	|| defined(explicit) \
	|| defined(export) \
	|| defined(extern) \
	|| defined(false) \
	|| defined(float) \
	|| defined(for) \
	|| defined(friend) \
	|| defined(goto) \
	|| defined(if) \
	|| defined(inline) \
	|| defined(int) \
	|| defined(long) \
	|| defined(mutable) \
	|| defined(namespace) \
	|| defined(new) \
	|| defined(nullptr) \
	|| defined(operator) \
	|| defined(private) \
	|| defined(protected) \
	|| defined(public) \
	|| defined(register) \
	|| defined(reinterpret_cast) \
	|| defined(return) \
	|| defined(short) \
	|| defined(signed) \
	|| defined(sizeof) \
	|| defined(static_assert) \
	|| defined(static_cast) \
	|| defined(static) \
	|| defined(struct) \
	|| defined(switch) \
	|| defined(template) \
	|| defined(this) \
	|| defined(throw) \
	|| defined(true) \
	|| defined(try) \
	|| defined(typedef) \
	|| defined(typeid) \
	|| defined(typename) \
	|| defined(union) \
	|| defined(unsigned) \
	|| defined(using) \
	|| defined(virtual) \
	|| defined(void) \
	|| defined(volatile) \
	|| defined(wchar_t) \
	|| defined(while)
   #error keyword defined before including C++ standard header
  #endif /* defined... */

 #endif /* defined(__cplusplus) */
#endif /* RC_INVOKED */
#endif /* _XKEYCHECK */

/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.20:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xgetwctype.c ===
/* _Getwctype -- return character classification flags for wide character */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <yvals.h>

_C_STD_BEGIN
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* return character classification flags for _Ch */
	short _Mask;
	return ((short)(GetStringTypeW(CT_CTYPE1, &_Ch, 1,
		(LPWORD)&_Mask) == 0
		? 0 : _Mask));
	}

_CRTIMP2_PURE const wchar_t * __CLRCALL_PURE_OR_CDECL _Getwctypes(
	const wchar_t *_First, const wchar_t *_Last,
		short *_Dest, const _Ctypevec *_Ctype)
	{	/* get mask sequence for elements in [_First, _Last) */
	GetStringTypeW(CT_CTYPE1, _First, (int)(_Last - _First),
		(LPWORD)_Dest);
	return (_Last);
	}

#ifdef MRTDLL
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(unsigned short _Ch,
	const _Ctypevec *_Ctype)
    {
    return _Getwctype((wchar_t) _Ch, _Ctype);
    }

_CRTIMP2_PURE const unsigned short * __CLRCALL_PURE_OR_CDECL _Getwctypes(
	const unsigned short *_First, const unsigned short *_Last,
		short *_Dest, const _Ctypevec *_Ctype)
    {
    return (const unsigned short *)_Getwctypes((wchar_t *)_First, (wchar_t *) _Last,
                       _Dest, _Ctype);
    }
#endif

_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xldtest.c ===
/* _LDtest function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

 #if _DLONG == 0
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDtest(long double *px)
	{	/* categorize *px -- 64-bit */
	return (_Dtest((double *)px));
	}

 #elif _DLONG == 1
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDtest(long double *px)
	{	/* categorize *px -- 80-bit */
	unsigned short *ps = (unsigned short *)(char *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? _NANCODE : _INFCODE);
	else if (0 < xchar || ps[_L1] != 0 || ps[_L2] || ps[_L3]
		|| ps[_L4])
		return (ps[_L1] < 0x8000 ? _DENORM : _FINITE);
	else
		return (0);
	}

 #else	/* 1 < _DLONG */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDtest(long double *px)
	{	/* categorize *px -- 128-bit SPARC */
	unsigned short *ps = (unsigned short *)(char *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? _NANCODE : _INFCODE);
	else if (0 < xchar || ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
		|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0 || ps[_L7] != 0)
		return (xchar == 0 ? _DENORM : _FINITE);
	else
		return (0);
	}
 #endif /* _DLONG */

_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlcosh.c ===
/* _LCosh function */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LCosh(long double x, long double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_LDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0L)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1.0L, -1);
			return (y * (x + 0.25L / x));
			}
		switch (_LExp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xldnorm.c ===
/* _LDnorm function -- IEEE 754 version */
#include "xmath.h"
_C_STD_BEGIN

 #if _DLONG == 0
	/* not needed -- 64-bit */

 #elif _DLONG == 1
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- 80-bit */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 0;
	for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
		xchar -= 16)
		{	/* shift left by 16 */
		ps[_L0] = ps[_L1];
		ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
		ps[_L3] = ps[_L4], ps[_L4] = 0;
		}
	if (ps[_L0] == 0)
		for (; ps[_L1] < (1U << _LOFF); --xchar)
			{	/* shift left by 1 */
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] <<= 1;
			}
	for (; ps[_L0] != 0; ++xchar)
		{	/* shift right by 1 */
		ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
		ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
		ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
		ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
		ps[_L0] >>= 1;
		}
	ps[_L0] = sign;
	return (xchar);
	}

 #else	/* 1 < _DLONG */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- 128-bit SPARC */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 1;
	if (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
		|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
		|| ps[_L7] != 0)
		{	/* nonzero, scale */
		for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
			xchar -= 16)
			{	/* shift left by 16 */
			ps[_L0] = ps[_L1];
			ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
			ps[_L3] = ps[_L4], ps[_L4] = ps[_L5];
			ps[_L5] = ps[_L6], ps[_L6] = ps[_L7];
			ps[_L7] = 0;
			}
		for (; ps[_L0] == 0; --xchar)
			{	/* shift left by 1 */
			ps[_L0] = ps[_L0] << 1 | ps[_L1] >> 15;
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] = ps[_L4] << 1 | ps[_L5] >> 15;
			ps[_L5] = ps[_L5] << 1 | ps[_L6] >> 15;
			ps[_L6] = ps[_L6] << 1 | ps[_L7] >> 15;
			ps[_L7] <<= 1;
			}
		for (; 1 < ps[_L0]; ++xchar)
			{	/* shift right by 1 */
			ps[_L7] = ps[_L7] >> 1 | ps[_L6] << 15;
			ps[_L6] = ps[_L6] >> 1 | ps[_L5] << 15;
			ps[_L5] = ps[_L5] >> 1 | ps[_L4] << 15;
			ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
			ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
			ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
			ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
			ps[_L0] >>= 1;
			}
		}
	ps[_L0] = sign;
	return (xchar);
	}
 #endif /* _DLONG */

_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xldscale.c ===
/* _LDscale function -- IEEE 754 version */
#include "xmath.h"

#pragma warning(disable:4439)	// C4439: function with a managed parameter must have a __clrcall calling convention

_C_STD_BEGIN

 #if _DLONG == 0
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 64-bit */
	return (_Dscale((double *)px, lexp));
	}

 #elif _DLONG == 1
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 80-bit */
	unsigned short *ps = (unsigned short *)(char *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? _NANCODE : _INFCODE);
	else if (ps[_L1] == 0 && ps[_L2] == 0
		&& ps[_L3] == 0 && ps[_L4] == 0)
		{	/* zero fraction, clear any exponent */
		ps[_L0] &= _LSIGN;
		return (0);
		}

	if (xchar == 0)
		xchar = 1;	/* correct denormalized exponent */
	xchar += _LDnorm(ps);
	if (0 < lexp && _LMAX - xchar <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._Long_double
			: _LInf._Long_double;
		return (_INFCODE);
		}
	else if (-xchar < lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (lexp + xchar);
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		ps[_L0] &= _LSIGN;
		lexp += xchar - 1;
		if (lexp <= -(64 + 1) || 0 <= lexp)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0;
			ps[_L2] = 0;
			ps[_L3] = 0;
			ps[_L4] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			unsigned short psx = 0;

			for (; xexp <= -16; xexp += 16)
				{	/* scale by words */
				psx = ps[_L4] | (psx != 0 ? 1 : 0);
				ps[_L4] = ps[_L3];
				ps[_L3] = ps[_L2];
				ps[_L2] = ps[_L1];
				ps[_L1] = 0;
				}
			if ((xexp = (short)-xexp) != 0)
				{	/* scale by bits */
				psx = (ps[_L4] << (16 - xexp)) | (psx != 0 ? 1 : 0);
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] >>= xexp;
				}

			if ((0x8000 < psx || 0x8000 == psx && (ps[_L4] & 0x0001) != 0)
				&& (++ps[_L4] & 0xffff) == 0
				&& (++ps[_L3] & 0xffff) == 0
				&& (++ps[_L2] & 0xffff) == 0
				&& (++ps[_L1] & 0xffff) == 0x8000)
				++ps[_L0];	/* round up */
			else if (ps[_L1] == 0 && ps[_L2] == 0
				&& ps[_L3] == 0 && ps[_L4] == 0)
				return (0);
			return (_FINITE);
			}
		}
	}

 #else	/* 1 < _DLONG */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 128-bit SPARC */
	unsigned short *ps = (unsigned short *)(char *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _LDnorm(ps)))
		return (0);

	if (0 < lexp && _LMAX - xchar <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._Long_double
			: _LInf._Long_double;
		return (_INFCODE);
		}
	else if (-xchar <  lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (lexp + xchar);
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_L0] & _LSIGN;

		ps[_L0] = 1;
		lexp += xchar - 1;
		if (lexp <= -113 || 0 <= lexp)
			{	/* underflow, return +/-0 */
			ps[_L7] = 0;
			ps[_L6] = 0;
			ps[_L5] = 0;
			ps[_L4] = 0;
			ps[_L3] = 0;
			ps[_L2] = 0;
			ps[_L1] = 0;
			ps[_L0] = sign;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			unsigned short psx = 0;

			for (; xexp <= -16; xexp += 16)
				{	/* scale by words */
				psx = ps[_L7] | (psx != 0 ? 1 : 0);
				ps[_L7] = ps[_L6];
				ps[_L6] = ps[_L5];
				ps[_L5] = ps[_L4];
				ps[_L4] = ps[_L3];
				ps[_L3] = ps[_L2];
				ps[_L2] = ps[_L1];
				ps[_L1] = ps[_L0];
				ps[_L0] = 0;
				}
			if ((xexp = (short)-xexp) != 0)
				{	/* scale by bits */
				psx = (ps[_L7] << (16 - xexp)) | (psx != 0 ? 1 : 0);
				ps[_L7] = ps[_L7] >> xexp
					| ps[_L6] << 16 - xexp;
				ps[_L6] = ps[_L6] >> xexp
					| ps[_L5] << 16 - xexp;
				ps[_L5] = ps[_L5] >> xexp
					| ps[_L4] << 16 - xexp;
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] = ps[_L1] >> xexp
					| ps[_L0] << 16 - xexp;
				ps[_L0] = 0;
				}

			ps[_L0] = sign;
			if ((0x8000 < psx || 0x8000 == psx && (ps[_L7] & 0x0001) != 0)
				&& (++ps[_L7] & 0xffff) == 0
				&& (++ps[_L6] & 0xffff) == 0
				&& (++ps[_L5] & 0xffff) == 0
				&& (++ps[_L4] & 0xffff) == 0
				&& (++ps[_L3] & 0xffff) == 0
				&& (++ps[_L2] & 0xffff) == 0
				&& (++ps[_L1] & 0xffff) == 0)
				++ps[_L0];	/* round up */
			else if (ps[_L1] == 0 && ps[_L2] == 0
				&& ps[_L3] == 0 && ps[_L4] == 0
				&& ps[_L5] == 0 && ps[_L6] == 0
				&& ps[_L7] == 0)
				return (0);
			return (_FINITE);
			}
		}
	}
 #endif /* _DLONG */

_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlpoly.c ===
/* _LPoly function */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LPoly(long double x,
	const long double *tab, int n)
	{	/* compute polynomial */
	long double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlock.cpp ===
// xlock.cpp -- global lock for locales, etc.
#include <stdlib.h>
#include <yvals.h>

 #if _MULTI_THREAD
  #include "xmtx.h"
_STD_BEGIN

  #define MAX_LOCK	4	/* must be power of two */

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

static _Rmtx mtx[MAX_LOCK];
static long init = -1;

#if !defined(MRTDLL)

__thiscall _Init_locks::_Init_locks()
	{	// initialize locks
	if (InterlockedIncrement(&init) == 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxinit(&mtx[count]);
	}

__thiscall _Init_locks::~_Init_locks()
	{	// clean up locks
	if (InterlockedDecrement(&init) < 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxdst(&mtx[count]);
	}

#endif

_MRTIMP2_NPURE void __cdecl _Init_locks::_Init_locks_ctor(_Init_locks * _This)
	{	// initialize locks
	if (InterlockedIncrement(&init) == 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxinit(&mtx[count]);
	}

_MRTIMP2_NPURE void __cdecl _Init_locks::_Init_locks_dtor(_Init_locks * _This)
	{	// clean up locks
	if (InterlockedDecrement(&init) < 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxdst(&mtx[count]);
	}

static _Init_locks initlocks;
 
#if !defined(MRTDLL)

__thiscall _Lockit::_Lockit()
	: _Locktype(0)

	{	// lock default mutex
	_Mtxlock(&mtx[0]);
	}

__thiscall _Lockit::_Lockit(int kind)
	: _Locktype(kind)
	{	// lock the mutex
	if (_Locktype < MAX_LOCK)
		_Mtxlock(&mtx[_Locktype]);
	}

__thiscall _Lockit::~_Lockit()
	{	// unlock the mutex
	if (_Locktype < MAX_LOCK)
		_Mtxunlock(&mtx[_Locktype]);
	}

#endif

_MRTIMP2_NPURE void __cdecl _Lockit::_Lockit_ctor(_Lockit * _This)
	{	// lock default mutex
	_Mtxlock(&mtx[0]);
	}

_MRTIMP2_NPURE void __cdecl _Lockit::_Lockit_ctor(_Lockit * _This, int kind)
	{	// lock the mutex
     _This->_Locktype = kind & (MAX_LOCK - 1);
	_Mtxlock(&mtx[_This->_Locktype]);
	}

_MRTIMP2_NPURE void __cdecl _Lockit::_Lockit_dtor(_Lockit * _This)
	{	// unlock the mutex
	_Mtxunlock(&mtx[_This->_Locktype]);
	}

_RELIABILITY_CONTRACT
_MRTIMP2_NPURE void __cdecl _Lockit::_Lockit_ctor(int kind)
	{	// lock the mutex
	_Mtxlock(&mtx[kind & (MAX_LOCK - 1)]);
	}

_RELIABILITY_CONTRACT
_MRTIMP2_NPURE void __cdecl _Lockit::_Lockit_dtor(int kind)
	{	// unlock the mutex
	_Mtxunlock(&mtx[kind & (MAX_LOCK - 1)]);
	}

_STD_END
 #endif	// _MULTI_THREAD

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlgamma.cpp ===
// xlgamma: moderately accurate lgamma function for TR1 random
#include <cmath>

 #if _HAS_TR1
//  #include <random>
_STD_BEGIN
	namespace tr1 {	// TR1 additions

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _XLgamma(float);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _XLgamma(double);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _XLgamma(long double);

float __CLRCALL_PURE_OR_CDECL _XLgamma(float x)
	{	// moderately accurate log gamma
	static float coeff[6] =
		{ 76.18009172947146F,
		  -86.50532032941677F,
		  24.01409824083091F,
		  -1.23173972450155F,
		  0.1208650973866179E-2F,
		  -0.5395239384953E-5F};

	float val0 = x + 5.5F;
	val0 -= (x + 0.5F) * _STD log(val0);
	float val1 = 1.000000000190015F;
	float y = x + 1.0F;

	for (int i = 0; i < 6; ++i, y += 1.0)
		val1 += coeff[i] / y;
	return (-val0 + _STD log(2.5066282746310005F * val1 / x));
	}

double __CLRCALL_PURE_OR_CDECL _XLgamma(double x)
	{	// moderately accurate log gamma
	static double coeff[6] =
		{ 76.18009172947146,
		  -86.50532032941677,
		  24.01409824083091,
		  -1.23173972450155,
		  0.1208650973866179E-2,
		  -0.5395239384953E-5};

	double val0 = x + 5.5;
	val0 -= (x + 0.5) * _STD log(val0);
	double val1 = 1.000000000190015;
	double y = x + 1;

	for (int i = 0; i < 6; ++i, y += 1.0)
		val1 += coeff[i] / y;
	return (-val0 + _STD log(2.5066282746310005 * val1 / x));
	}

long double __CLRCALL_PURE_OR_CDECL _XLgamma(long double x)
	{	// moderately accurate log gamma
	static long double coeff[6] =
		{ 76.18009172947146,
		  -86.50532032941677,
		  24.01409824083091,
		  -1.23173972450155,
		  0.1208650973866179E-2,
		  -0.5395239384953E-5};

	long double val0 = x + 5.5;
	val0 -= (x + 0.5) * _STD log(val0);
	long double val1 = 1.000000000190015;
	long double y = x + 1;

	for (int i = 0; i < 6; ++i, y += 1.0)
		val1 += coeff[i] / y;
	return (-val0 + _STD log(2.5066282746310005 * val1 / x));
	}

	}	// namespace tr1
_STD_END
 #endif /* _HAS_TR1 */

/*
 * Copyright (c) 1992-2008 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.05:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlocale.cpp ===
// xlocale -- class locale exotic char member functions
#include <istream>
#include <locale>
#include <xdebug>
_STD_BEGIN

 #pragma warning(disable: 4786)

 #pragma warning(disable: 4074)
 #pragma init_seg(compiler)

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

// moved from locale to ease subsetting
typedef collate<char> _T5;
typedef messages<char> _T6;
typedef money_get<char, _Initer> _T7;
typedef money_put<char, _Outiter> _T9;
typedef moneypunct<char, false> _T11;
typedef moneypunct<char, true> _T12;
typedef time_get<char, _Initer> _T13;
typedef time_put<char, _Outiter> _T14;


void __CLRCALL_OR_CDECL locale::_Locimp::_Makexloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup exotic char part of a new locale
	ADDFAC(_T5, cat, ptrimp, ptrloc);
	ADDFAC(_T6, cat, ptrimp, ptrloc);
	ADDFAC(_T7, cat, ptrimp, ptrloc);
	ADDFAC(_T9, cat, ptrimp, ptrloc);
	ADDFAC(_T11, cat, ptrimp, ptrloc);
	ADDFAC(_T12, cat, ptrimp, ptrloc);
	ADDFAC(_T13, cat, ptrimp, ptrloc);
	ADDFAC(_T14, cat, ptrimp, ptrloc);
	}
_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlexp.c ===
/* _LExp function */
#include "xmath.h"
_C_STD_BEGIN

	/* coefficients */

 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	42.038913947607355L,
	10096.353102778762831L,
	333228.767219512631062L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	1.0L,
	841.167880526530790L,
	75730.834075476293976L,
	666457.534439025262146L};

 #else	/* assume IEEE 754 16 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	2.9807566520819951922553427799e-12L,
	1.77137207816625148450390487465e-8L,
	1.5047926518149448268177793026372e-5L,
	3.611828913847589925056132680618007e-3L,
	2.3684088648142335389097476188945590e-1L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	3.279723985560247033712687707263e-10L,
	6.1415060072086450089090888123384e-7L,
	2.708775201978218837374512615596512e-4L,
	3.5087109907378343612154047611394786e-2L};
 #endif

static const long double c1 = (22713.0L / 32768.0L);
static const long double c2 = 1.4286068203094172321214581765680755e-6L;
static const long double hugexp = LHUGE_EXP;
static const long double invln2 = 1.4426950408889634073599246810018921L;

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LExp(long double *px, long double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0L)
		{	/* certain underflow */
		*px = 0.0L;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _LInf._Long_double;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		long double g = *px * invln2;
		short xexp = (short)(g + (g < 0 ? - 0.5L : + 0.5L));

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_LEps._Long_double < g && g < _LEps._Long_double)
			*px = y;
		else
			{	/* g*g worth computing */

 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
			const long double z = g * g;
			const long double w = ((z + q[1]) * z + q[2]) * z + q[3];

			g *= (p[0] * z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2.0L * y;
			--xexp;

 #else	/* assume IEEE 754 16 byte */
			const long double z = g * g;
			const long double w = ((q[0] * z + q[1]) * z + q[2]) * z + q[3];
			const long double v = (((p[0] * z + p[1]) * z + p[2])
				* z + p[3]) * z + p[4];
			const long double u = g * w - v;

			*px = g * (g + z * (w + w + u)) / (2.0L - (g + z * u)) + g + 1.0;
			*px *= y;
 #endif

			}
		return (_LDscale(px, (long)xexp + eoff));
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlsinh.c ===
/* _LSinh function */
#include "xmath.h"
_C_STD_BEGIN

	/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)

 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000000000028486835L,
	0.0000000000007646464279L,
	0.0000000001605905091647L,
	0.0000000250521083436962L,
	0.0000027557319224130455L,
	0.0001984126984126956009L,
	0.0083333333333333336073L,
	0.1666666666666666666564L,
	1.0000000000000000000001L};

 #else	/* assume IEEE 754 16 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.00000000000000000000000006506911776L,
	0.00000000000000000000003867997525529L,
	0.00000000000000000001957294395545097L,
	0.00000000000000000822063524350084984L,
	0.00000000000000281145725434779709982L,
	0.00000000000076471637318198050919003L,
	0.00000000016059043836821614638343470L,
	0.00000002505210838544171877496283537L,
	0.00000275573192239858906525574505191L,
	0.00019841269841269841269841269726379L,
	0.00833333333333333333333333333338555L,
	0.16666666666666666666666666666666573L,
	1.0L};
 #endif

_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LSinh(long double x, long double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_LDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0L ? x : LSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0L)
			return (x < 0.0L ? -y : y);
		if (x < 0.0L)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _LRteps._Long_double)
			x *= y;	/* x tiny */
		else if (x < 1.0L)
			{
			long double w = x * x;

			x += x * w * _LPoly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1.0L, -1);
			x = y * (x - 0.25L / x);
			}
		else
			switch (_LExp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

#pragma pack(push,_CRT_PACKING)

_C_STD_BEGIN
#ifndef MRTDLL
#ifndef _M_CEE_PURE
_C_LIB_DECL
#endif
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX
#define _X_MESSAGES		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGES	_CATMASK(_X_MESSAGES)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_CRTIMP2_PURE _Collvec __CLRCALL_PURE_OR_CDECL _Getcoll();
_CRTIMP2_PURE _Ctypevec __CLRCALL_PURE_OR_CDECL _Getctype();

_CRTIMP2_PURE _Cvtvec __CLRCALL_PURE_OR_CDECL _Getcvt();

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Getdateorder();

#ifdef _M_CEE_PURE
[System::Runtime::InteropServices::DllImport(_CRT_MSVCP_CURRENT, EntryPoint = "_Mbrtowc", CallingConvention=System::Runtime::InteropServices::CallingConvention::Cdecl)]
extern "C" int _Mbrtowc(_Out_opt_ wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
#else
_MRTIMP2 int __cdecl _Mbrtowc(_Out_opt_ wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
#endif

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _Stof(const char *, _Out_opt_ _Deref_post_opt_valid_ char **, long);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stod(const char *, _Out_opt_ _Deref_post_opt_valid_ char **, long);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _Stold(const char *, _Out_opt_ _Deref_post_opt_valid_ char **, 
  long);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm(
  _Out_cap_x_(_End1-_String1) _Post_count_( return) char * _String1, 
  _In_z_ char * _End1, const char *, const char *, const _Collvec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Tolower(int, const _Ctypevec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Toupper(int, const _Ctypevec *);

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcrtomb(_Out_ char *, wchar_t, mbstate_t *, const _Cvtvec *);

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(
  _Out_cap_x_(_End1-_String1) _Post_count_( return) wchar_t *_String1, 
  _In_z_ wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2_PURE const wchar_t * __CLRCALL_PURE_OR_CDECL _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towupper(wchar_t, const _Ctypevec *);
#ifndef MRTDLL
#ifndef _M_CEE_PURE
_END_C_LIB_DECL
#endif
#endif
_C_STD_END

_C_LIB_DECL
_CRTIMP void *__cdecl _Gettnames();
_CRTIMP char *__cdecl _Getdays();
_CRTIMP char *__cdecl _Getmonths();
_CRTIMP size_t __cdecl _Strftime(
  _Out_cap_(_Maxsize) char *, _In_ size_t _Maxsize, 
  _In_z_ __format_string const char *, _In_ const struct tm *, void *);
_END_C_LIB_DECL

#ifdef _M_CEE_PURE
[System::Runtime::InteropServices::DllImport(_CRT_MSVCP_CURRENT , EntryPoint = "_GetLocaleForCP", CallingConvention=System::Runtime::InteropServices::CallingConvention::Cdecl)]
extern "C" _locale_t _GetLocaleForCP(unsigned int);
#else
_MRTIMP2 _locale_t __cdecl _GetLocaleForCP(unsigned int);
#endif

#pragma pack(pop)

#endif /* _XLOCINFO */

/*
 * Copyright (c) 1992-2006 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.02:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xmtx.c ===
/*	xmtx.c -- mutex support for VC++ */
#include "xmtx.h"


 #if !_MULTI_THREAD

 #else /* !_MULTI_THREAD */
/* Win32 critical sections are recursive, but
   Win32 does not have once-function */

void  __CLRCALL_PURE_OR_CDECL _Once(_Once_t *_Cntrl, void (*_Func)(void))
	{	/* execute _Func exactly one time */
	_Once_t old;
	if (*_Cntrl == 2)
		;
	else if ((old = InterlockedExchange(_Cntrl, 1)) == 0)
		{	/* execute _Func, mark as executed */
		_Func();
		*_Cntrl = 2;
		}
	else if (old == 2)
		*_Cntrl = 2;
	else
		while (*_Cntrl != 2)
			Sleep(1);
	}

void  __CLRCALL_PURE_OR_CDECL _Mtxinit(_Rmtx *_Mtx)
	{	/* initialize mutex */
	InitializeCriticalSection(_Mtx);
	}

void  __CLRCALL_PURE_OR_CDECL _Mtxdst(_Rmtx *_Mtx)
	{	/* delete mutex */
	DeleteCriticalSection(_Mtx);
	}

_RELIABILITY_CONTRACT
void  __CLRCALL_PURE_OR_CDECL _Mtxlock(_Rmtx *_Mtx)
	{	/* lock mutex */
#ifdef _M_CEE
	System::Threading::Thread::BeginThreadAffinity();
#endif
	EnterCriticalSection(_Mtx);
	}

_RELIABILITY_CONTRACT
void  __CLRCALL_PURE_OR_CDECL _Mtxunlock(_Rmtx *_Mtx)
	{	/* unlock mutex */
	LeaveCriticalSection(_Mtx);
#ifdef _M_CEE
	System::Threading::Thread::EndThreadAffinity();
#endif
	}
 #endif /* !_MULTI_THREAD */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif

_C_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

#ifndef MRTDLL
#ifndef _M_CEE_PURE
_C_LIB_DECL
#endif
#endif

		/* double declarations */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dnorm(unsigned short *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dscale(double *, long);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Poly(double, const double *, int);

extern _CRTIMP2_PURE /* const */ _Dconst _Eps, _Rteps;
extern _CRTIMP2_PURE /* const */ double _Xbig;

		/* float declarations */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDnorm(unsigned short *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDscale(float *, long);

extern _CRTIMP2_PURE /* const */ _Dconst _FEps, _FRteps;
extern _CRTIMP2_PURE /* const */ float _FXbig;

		/* long double functions */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDnorm(unsigned short *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDscale(long double *, long);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LPoly(long double, const long double *, int);

extern _CRTIMP2_PURE /* const */ _Dconst _LEps, _LRteps;
extern _CRTIMP2_PURE /* const */ long double _LXbig;
#ifndef MRTDLL
#ifndef _M_CEE_PURE
_END_C_LIB_DECL
#endif
#endif
_C_STD_END
#endif /* _XMATH */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xmbtowc.c ===
/***
*xmbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <limits.h>              /* for INT_MAX */
#include <stdio.h>               /* for EOF */
#include <xlocinfo.h>            /* for _Cvtvec, _Mbrtowc */
#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#include <mbctype.h>             /* for _ismbblead_l */
#include <sect_attribs.h>
#include <rterr.h>

/***
*int _Mbrtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*       mbstate_t *pst      = pointer to state
*       const _Cvtvec *     = pointer to locale info
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

int _MRTIMP2 __cdecl _Mbrtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        if ( !s || n == 0 )
            /* indicate do not have state-dependent encodings,
               handle zero length string */
            return 0;

        if ( !*s )
        {
            /* handle NULL char */
            if (pwc)
                *pwc = 0;
            return 0;
        }

        {   /* perform locale-dependent parse */
            LCID handle;
            UINT codepage;
            _locale_t locale;
            BOOL islead;

            if (ploc == 0)
            {
                handle = ___lc_handle_func()[LC_CTYPE];
                codepage = ___lc_codepage_func();
            }
            else
            {
                handle = ploc->_Hand;
                codepage = ploc->_Page;
            }

            if ( handle == _CLOCALEHANDLE )
            {
                if (pwc)
                    *pwc = (wchar_t)(unsigned char)*s;
                return sizeof(char);
            }

            locale = _GetLocaleForCP(codepage);

            _ASSERTE (___mb_cur_max_l_func(locale) == 1 ||
                      ___mb_cur_max_l_func(locale) == 2);

            if (*pst != 0)
            {   /* complete two-byte multibyte character */
                ((char *)pst)[1] = *s;
                if (___mb_cur_max_l_func(locale) <= 1 ||
                    (MultiByteToWideChar(codepage,
                                         MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                                         (char *)pst,
                                         2,
                                         pwc,
                                         (pwc) ? 1 : 0) == 0))
                {   /* translation failed */
                    *pst = 0;
                    errno = EILSEQ;
                    return -1;
                }
                *pst = 0;
                return ___mb_cur_max_l_func(locale);
            }

            islead = (locale == NULL) ? _cpp_isleadbyte((unsigned char)*s)
                                      : _ismbblead_l((unsigned char)*s, locale);
            if ( islead )
            {
                /* multi-byte char */
                if (n < (size_t)___mb_cur_max_l_func(locale))
                {   /* save partial multibyte character */
                    ((char *)pst)[0] = *s;
                    return (-2);
                }
                else if ( ___mb_cur_max_l_func(locale) <= 1 ||
                          (MultiByteToWideChar( codepage,
                                                MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS,
                                                s,
                                                ___mb_cur_max_l_func(locale),
                                                pwc,
                                                (pwc) ? 1 : 0) == 0) )
                {
                    /* validate high byte of mbcs char */
                    if (!*(s+1))
                    {
                        *pst = 0;
                        errno = EILSEQ;
                        return -1;
                    }
/*                  else translation failed with no complaint? [pjp] */
                }
                return ___mb_cur_max_l_func(locale);
            }
            else {
                /* single byte char */

                if ( MultiByteToWideChar( codepage,
                                          MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                                          s,
                                          1,
                                          pwc,
                                          (pwc) ? 1 : 0) == 0 )
                {
                    errno = EILSEQ;
                    return -1;
                }

                return sizeof(char);
            }
        }
}

#ifdef MRTDLL
int _MRTIMP2 __cdecl _Mbrtowc(
        unsigned short* pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
    {
    return _Mbrtowc((wchar_t *)pwc, s, n, pst, ploc);
    }
#endif  /* MRTDLL */


#pragma managed(push, off)

/*
 * Define a codepage-to-locale mapping hashtable to be used by _Mbrtowc et al.
 * The hash length is chosen to distribute the ~90 valid codepages so that a
 * minimal number of buckets (~3) have more than 1 codepage less than 10,000.
 */

typedef struct _CPLocEntry {
    struct _CPLocEntry *next;
    UINT                codepage;
    _locale_t           locale;
} _CPLocEntry;

#define CPHASHLEN   62

static _CPLocEntry *volatile _CPLocHash[CPHASHLEN];

static int __cdecl _InitCPLocHash(void);

_CRTALLOC(".CRT$XID") static _PIFV pinit = _InitCPLocHash;

/***
* _locale_t _CreateLocForCP() - Return the locale ".<codepage>"
*
* Purpose:
*      Call _create_locale for the given codepage.  This is split out of
*      _GetLocaleForCP for performance reasons, since it almost never gets
*      run, but it triggers buffer overrun checking.
* Entry:
*      UINT codepage = codepage to convert to a _locale_t
* Exit:
*      Returns the corresponding _locale_t, or NULL if an error occurs.
******************************************************************************/

static __declspec(noinline)
_locale_t __cdecl _CreateLocForCP(
    UINT codepage
    )
{
    char locale_name[32];

    locale_name[0] = '.';
    _ui64toa_s(codepage, locale_name + 1, sizeof(locale_name) - 1, 10);
    return _create_locale(LC_ALL, locale_name);
}

/***
* _locale_t _GetLocaleForCP() - retrieve the _locale_t for a codepage.
*
* Purpose:
*      Return the _locale_t for a given codepage.  Use a hashtable of all
*      previously-used codepages to avoid the expensive locale recreation.
* Entry:
*      UINT codepage = codepage to retrieve
* Exit:
*      Returns the _locale_t corresponding to the locale ".<codepage>", or
*      NULL if the codepage isn't valid, or we hit any other error.
******************************************************************************/

_locale_t _MRTIMP2 __cdecl _GetLocaleForCP(
    UINT codepage
    )
{
    _CPLocEntry *volatile *pBucket;
    _CPLocEntry *pHead;
    _CPLocEntry *pLink;
    _CPLocEntry *pNewEntry;

    /*
     * Get hash bucket with linked list to search for existing codepage entry.
     */
    pBucket = _CPLocHash + (codepage % CPHASHLEN);

    /*
     * Loop until we find the codepage, successfully add a new entry for the
     * codepage, or hit an error.  If a search for the codepage fails, we
     * allocate a new entry and try to push it on the head of the list.  But
     * if the list has been modified in the meantime, then we need to restart
     * the search.
     */
    pNewEntry = NULL;
    for (;;)
    {
        /*
         * Look for the codepage in the linked list, remembering the original
         * list head.
         */
        pHead = *pBucket;
        for (pLink = pHead; pLink != NULL; pLink = pLink->next)
        {
            if (pLink->codepage == codepage)
            {
                /*
                 * The search was successful.  If this was a rescan of the
                 * list, then free the redundant entry we failed to push onto
                 * the list on the previous loop.
                 */
                if (pNewEntry != NULL)
                {
                    _free_locale(pNewEntry->locale);
                    _free_crt(pNewEntry);
                }
                return pLink->locale;
            }
        }

        /*
         * The codepage wasn't found.  If this is the first time through the
         * loop, create the corresponding _locale_t and allocate the new list
         * entry.  If that fails, return NULL as the mapping has failed.
         */
        if (pNewEntry == NULL)
        {
            pNewEntry = (_CPLocEntry *)_malloc_crt(sizeof(_CPLocEntry));
            if (pNewEntry == NULL)
            {
                return NULL;
            }

                        pNewEntry->locale = _CreateLocForCP(codepage);
            if (pNewEntry->locale == NULL)
            {
                                _free_crt(pNewEntry);
                return NULL;
            }

            pNewEntry->codepage = codepage;
        }

        /*
         * Try to push the new entry on the head of the list.  If successful,
         * return the newly-created locale.  Otherwise, the list head has
         * changed since we started this loop, and we'll have to retry the
         * search.
         */
        pNewEntry->next = pHead;
        if (InterlockedCompareExchangePointer(
                (volatile PVOID *)pBucket,
                pNewEntry,
                pHead) == pHead)
        {
            return pNewEntry->locale;
        }
    }
}

/***
* void _ReleaseCPLocHash() - free the codepage-to-locale hashtable
*
* Purpose:
*      Release all resources held by the codepage-to-locale hashtable.
*      Called on CRT shutdown.
******************************************************************************/

/*
 * Problems in the PSDK header definitions of InterlockedExchangePointer
 * force us to disable some warnings.
 */
#pragma warning(push)
#pragma warning(disable: 4311 4312)

static void __cdecl _ReleaseCPLocHash(
    void
    )
{
    int i;
    _CPLocEntry *pLink;
    _CPLocEntry *pNext;

    for (i = 0; i < CPHASHLEN; ++i)
    {
        /*
         * No other threads should be active.  But just in case, use a locked
         * exchange to clear the hash bucket and retrieve the old value at the
         * same time, preventing other threads from seeing the linked list
         * being freed.  This doesn't help if other threads are already
         * traversing that list.
         */
        pLink = (_CPLocEntry *)InterlockedExchangePointer(
                                    (volatile PVOID *)&_CPLocHash[i],
                                    NULL);
        while (pLink != NULL)
        {
            pNext = pLink->next;
            _free_locale(pLink->locale);
            _free_crt(pLink);
            pLink = pNext;
        }
    }
}

#pragma warning(pop)

/***
* void _InitCPLocHash() - Register cleanup of codepage-to-locale hashtable
*
* Purpose:
*      Set up to release the codepage-to-locale hashtable on CRT shutdown.
******************************************************************************/

static int __cdecl _InitCPLocHash(
    void
    )
{
    int ret = atexit(_ReleaseCPLocHash);
    return ret == 0 ? 0 : _RT_ONEXIT;
}

#pragma managed(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xmmintrin.h ===
/***
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
****/

/*
 * xmmintrin.h
 *
 * Principal header file for Streaming SIMD Extensions intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _MM_FUNCTIONALITY is defined; if it is, the C/x87 implementation
 * will be used (the "faux intrinsics").
 *
 *
 * Note that the m128 datatype provided using _MM2_FUNCTIONALITY mode is
 *   implemented as struct, will not be 128b aligned, will be passed
 *   via the stack, etc.  MM_FUNCTIONALITY mode is not intended for
 *   performance, just semantics.
 *
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_MM2
#define _INCLUDED_MM2

#if defined (_M_CEE_PURE)
        #error ERROR: XMM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

/*
 * the m64 type is required for the integer Streaming SIMD Extensions intrinsics
 */
#ifndef _MMINTRIN_H_INCLUDED
#include <mmintrin.h>
#endif  /* _MMINTRIN_H_INCLUDED */

#ifdef _MM2_FUNCTIONALITY
/* support old notation */
#ifndef _MM_FUNCTIONALITY
#define _MM_FUNCTIONALITY
#endif  /* _MM_FUNCTIONALITY */
#endif  /* _MM2_FUNCTIONALITY */

#ifdef __ICL
#ifdef _MM_FUNCTIONALITY
#include "xmm_func.h"
#else  /* _MM_FUNCTIONALITY */
/* using real intrinsics */
typedef long long __m128;
#endif  /* _MM_FUNCTIONALITY */
#else  /* __ICL */

typedef union __declspec(intrin_type) _CRT_ALIGN(16) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;

#ifndef _INC_MALLOC
/* pick up _mm_malloc() and _mm_free() */
#include <malloc.h>
#endif  /* _INC_MALLOC */
#endif  /* __ICL */

 /*******************************************************/
 /* MACRO for shuffle parameter for _mm_shuffle_ps().   */
 /* Argument fp3 is a digit[0123] that represents the fp*/
 /* from argument "b" of mm_shuffle_ps that will be     */
 /* placed in fp3 of result. fp2 is the same for fp2 in */
 /* result. fp1 is a digit[0123] that represents the fp */
 /* from argument "a" of mm_shuffle_ps that will be     */
 /* places in fp1 of result. fp0 is the same for fp0 of */
 /* result                                              */
 /*******************************************************/
#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) (((fp3) << 6) | ((fp2) << 4) | \
                                     ((fp1) << 2) | ((fp0)))


 /*******************************************************/
 /* MACRO for performing the transpose of a 4x4 matrix  */
 /* of single precision floating point values.          */
 /* Arguments row0, row1, row2, and row3 are __m128     */
 /* values whose elements form the corresponding rows   */
 /* of a 4x4 matrix.  The matrix transpose is returned  */
 /* in arguments row0, row1, row2, and row3 where row0  */
 /* now holds column 0 of the original matrix, row1 now */
 /* holds column 1 of the original matrix, etc.         */
 /*******************************************************/
#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) {                 \
            __m128 tmp3, tmp2, tmp1, tmp0;                          \
                                                                    \
            tmp0   = _mm_shuffle_ps((row0), (row1), 0x44);          \
            tmp2   = _mm_shuffle_ps((row0), (row1), 0xEE);          \
            tmp1   = _mm_shuffle_ps((row2), (row3), 0x44);          \
            tmp3   = _mm_shuffle_ps((row2), (row3), 0xEE);          \
                                                                    \
            (row0) = _mm_shuffle_ps(tmp0, tmp1, 0x88);              \
            (row1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD);              \
            (row2) = _mm_shuffle_ps(tmp2, tmp3, 0x88);              \
            (row3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD);              \
        }


/* constants for use with _mm_prefetch */
#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

/* (this declspec not supported with 0.A or 0.B) */
#define _MM_ALIGN16 _CRT_ALIGN(16)

/* MACRO functions for setting and reading the MXCSR */
#define _MM_EXCEPT_MASK       0x003f
#define _MM_EXCEPT_INVALID    0x0001
#define _MM_EXCEPT_DENORM     0x0002
#define _MM_EXCEPT_DIV_ZERO   0x0004
#define _MM_EXCEPT_OVERFLOW   0x0008
#define _MM_EXCEPT_UNDERFLOW  0x0010
#define _MM_EXCEPT_INEXACT    0x0020

#define _MM_MASK_MASK         0x1f80
#define _MM_MASK_INVALID      0x0080
#define _MM_MASK_DENORM       0x0100
#define _MM_MASK_DIV_ZERO     0x0200
#define _MM_MASK_OVERFLOW     0x0400
#define _MM_MASK_UNDERFLOW    0x0800
#define _MM_MASK_INEXACT      0x1000

#define _MM_ROUND_MASK        0x6000
#define _MM_ROUND_NEAREST     0x0000
#define _MM_ROUND_DOWN        0x2000
#define _MM_ROUND_UP          0x4000
#define _MM_ROUND_TOWARD_ZERO 0x6000

#define _MM_FLUSH_ZERO_MASK   0x8000
#define _MM_FLUSH_ZERO_ON     0x8000
#define _MM_FLUSH_ZERO_OFF    0x0000

#define _MM_SET_EXCEPTION_STATE(mask)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (mask))
#define _MM_GET_EXCEPTION_STATE()                                   \
            (_mm_getcsr() & _MM_EXCEPT_MASK)

#define _MM_SET_EXCEPTION_MASK(mask)                                \
            _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (mask))
#define _MM_GET_EXCEPTION_MASK()                                    \
            (_mm_getcsr() & _MM_MASK_MASK)

#define _MM_SET_ROUNDING_MODE(mode)                                 \
            _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (mode))
#define _MM_GET_ROUNDING_MODE()                                     \
            (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_FLUSH_ZERO_MODE(mode)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (mode))
#define _MM_GET_FLUSH_ZERO_MODE(mode)                               \
            (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)

 /*****************************************************/
 /*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
 /*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif  /* defined __cplusplus */

/*
 * FP, arithmetic
 */

extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);

/*
 * FP, logical
 */

extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);

/*
 * FP, comparison
 */

extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);

/*
 * FP, conversions
 */

extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);

/*
 * Support for 64-bit extension intrinsics
 */
#if defined (_M_AMD64)
extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#endif  /* defined (_M_AMD64) */

/*
 * FP, misc
 */

extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);


/*
 * Integer extensions
 */
extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);

/*
 * memory & initialization
 */

extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);

#ifdef __ICL
extern void* __cdecl _mm_malloc(size_t _Siz, size_t _Al);
extern void __cdecl _mm_free(void *_P);
#endif  /* __ICL */

/* Alternate intrinsic names definition */
#define _mm_cvtss_si32    _mm_cvt_ss2si
#define _mm_cvtps_pi32    _mm_cvt_ps2pi
#define _mm_cvttss_si32   _mm_cvtt_ss2si
#define _mm_cvttps_pi32   _mm_cvtt_ps2pi
#define _mm_cvtsi32_ss    _mm_cvt_si2ss
#define _mm_cvtpi32_ps    _mm_cvt_pi2ps
#define _mm_extract_pi16  _m_pextrw
#define _mm_insert_pi16   _m_pinsrw
#define _mm_max_pi16      _m_pmaxsw
#define _mm_max_pu8       _m_pmaxub
#define _mm_min_pi16      _m_pminsw
#define _mm_min_pu8       _m_pminub
#define _mm_movemask_pi8  _m_pmovmskb
#define _mm_mulhi_pu16    _m_pmulhuw
#define _mm_shuffle_pi16  _m_pshufw
#define _mm_maskmove_si64 _m_maskmovq
#define _mm_avg_pu8       _m_pavgb
#define _mm_avg_pu16      _m_pavgw
#define _mm_sad_pu8       _m_psadbw
#define _mm_set1_ps       _mm_set_ps1
#define _mm_load1_ps      _mm_load_ps1
#define _mm_store1_ps     _mm_store_ps1

 /******************************************************/
 /* UTILITY INTRINSICS FUNCTION DEFINITIONS START HERE */
 /******************************************************/

 /*********************************************************/
 /*  NAME : _mm_cvtpi16_ps                                */
 /*  DESCRIPTION : Convert 4 16-bit signed integer values */
 /*                to 4 single-precision float values     */
 /*  IN : __m64 a                                         */
 /*  OUT : none                                           */
 /*  RETURN : __m128 : (float)a                           */
 /*********************************************************/
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_cmpgt_pi16(_mm_setzero_si64(), a);

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp),
                        _mm_unpacklo_pi16(a, ext_val)));
}


 /***********************************************************/
 /*  NAME : _mm_cvtpu16_ps                                  */
 /*  DESCRIPTION : Convert 4 16-bit unsigned integer values */
 /*                to 4 single-precision float values       */
 /*  IN : __m64 a                                           */
 /*  OUT : none                                             */
 /*  RETURN : __m128 : (float)a                             */
 /***********************************************************/
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp),
                        _mm_unpacklo_pi16(a, ext_val)));
}


 /******************************************************/
 /*  NAME : _mm_cvtps_pi16                             */
 /*  DESCRIPTION : Convert 4 single-precision float    */
 /*                values to 4 16-bit integer values   */
 /*  IN : __m128 a                                     */
 /*  OUT : none                                        */
 /*  RETURN : __m64 : (short)a                         */
 /******************************************************/
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _mm_packs_pi32(_mm_cvtps_pi32(a),
                        _mm_cvtps_pi32(_mm_movehl_ps(a, a)));
}


 /******************************************************/
 /*  NAME : _mm_cvtpi8_ps                              */
 /*  DESCRIPTION : Convert 4 8-bit integer values to 4 */
 /*                single-precision float values       */
 /*  IN : __m64 a                                      */
 /*  OUT : none                                        */
 /*  RETURN : __m128 : (float)a                        */
 /******************************************************/
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _mm_cmpgt_pi8(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_mm_unpacklo_pi8(a, ext_val));
}


 /******************************************************/
 /*  NAME : _mm_cvtpu8_ps                              */
 /*  DESCRIPTION : Convert 4 8-bit unsigned integer    */
 /*                values to 4 single-precision float  */
 /*                values                              */
 /*  IN : __m64 a                                      */
 /*  OUT : none                                        */
 /*  RETURN : __m128 : (float)a                        */
 /******************************************************/
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_mm_unpacklo_pi8(a, _mm_setzero_si64()));
}


 /******************************************************/
 /*  NAME : _mm_cvtps_pi8                              */
 /*  DESCRIPTION : Convert 4 single-precision float    */
 /*                values to 4 8-bit integer values    */
 /*  IN : __m128 a                                     */
 /*  OUT : none                                        */
 /*  RETURN : __m64 : (char)a                          */
 /******************************************************/
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _mm_packs_pi16(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


 /******************************************************/
 /*  NAME : _mm_cvtpi32x2_ps                           */
 /*  DESCRIPTION : Convert 4 32-bit integer values     */
 /*                to 4 single-precision float values  */
 /*  IN : __m64 a : operand 1                          */
 /*       __m64 b : operand 2                          */
 /*  OUT : none                                        */
 /*  RETURN : __m128 : (float)a,(float)b               */
 /******************************************************/
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b));
}


#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INCLUDED_MM2 */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xlvalues.c ===
/* values used by math functions -- IEEE 754 long version */
#if defined(_M_CEE_PURE)
#if defined(MRTDLL)
#undef MRTDLL
#endif
#if defined(MRTDLL)
#undef CRTDLL
#endif
#endif

#include "xmath.h"
_C_STD_BEGIN

 #if _DLONG == 0
		/* macros -- 64-bit */
  #define NBITS	(48 + _DOFF)

  #if _D0 == 0
   #define INIT(w0)		{w0, 0, 0, 0}
   #define INIT2(w0, w1)	{w0, 0, 0, w1}

  #else /* _DLONG == 0 */
   #define INIT(w0)		{0, 0, 0, w0}
   #define INIT2(w0, w1)	{w1, 0, 0, w0}
  #endif /* _DLONG == 0 */

		/* static data */
extern /* const */ _Dconst _LDenorm = {INIT2(0, 1)};
extern /* const */ _Dconst _LEps = {
	INIT((_DBIAS - NBITS - 1) << _DOFF)};
extern /* const */ _Dconst _LInf = {INIT(_DMAX << _DOFF)};
extern /* const */ _Dconst _LNan = {INIT((_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
extern /* const */ _Dconst _LSnan = {INIT2(_DMAX << _DOFF, 1)};
extern /* const */ _Dconst _LRteps = {
	INIT((_DBIAS - NBITS / 2) << _DOFF)};

 #elif _DLONG == 1
		/* macros -- 80-bit */
  #define NBITS	64

  #if _D0 == 0
   #define INIT(w0, w1)		{w0, w1, 0, 0, 0}
   #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, wn}

  #else /* _D0 == 0 */
   #define INIT(w0, w1)		{0, 0, 0, w1, w0}
   #define INIT3(w0, w1, wn)	{wn, 0, 0, w1, w0}
  #endif /* _D0 == 0 */

		/* static data */
extern /* const */ _Dconst _LDenorm = {INIT3(0, 0, 1)};
extern /* const */ _Dconst _LEps = {
	INIT(_LBIAS - NBITS - 1, 0x8000)};
extern /* const */ _Dconst _LInf = {INIT(_LMAX, 0x8000)};
extern /* const */ _Dconst _LNan = {INIT(_LMAX, 0xc000)};
extern /* const */ _Dconst _LSnan = {INIT3(_LMAX, 0x8000, 1)};
extern /* const */ _Dconst _LRteps = {
	INIT(_LBIAS - NBITS / 2, 0x8000)};

 #else /* 1 < _DLONG */
		/* macros -- 128-bit SPARC */
  #define NBITS	128

  #if _D0 == 0
   #define INIT(w0, w1)		{w0, w1, 0, 0, 0, 0, 0, 0}
   #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, 0, 0, 0, wn}

  #else /* _D0 == 0 */
   #define INIT(w0, w1)		{0, 0, 0, 0, 0, 0, w1, w0}
   #define INIT3(w0, w1, wn)	{wn, 0, 0, 0, 0, 0, w1, w0}
  #endif /* _D0 == 0 */

		/* static data */
extern /* const */ _Dconst _LDenorm = {INIT3(0, 0, 1)};
extern /* const */ _Dconst _LEps = {
	INIT(_LBIAS - NBITS - 1, 0x8000)};
extern /* const */ _Dconst _LInf = {INIT(_LMAX, 0)};
extern /* const */ _Dconst _LNan = {INIT(_LMAX, 0x8000)};
extern /* const */ _Dconst _LSnan = {INIT3(_LMAX, 0, 1)};
extern /* const */ _Dconst _LRteps = {
	INIT(_LBIAS - NBITS / 2, 0x8000)};
 #endif /* _DLONG */

extern /* const */ long double _LXbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2_PURE extern /* const */ long double _LZero = 0.0L;
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xmutex.cpp ===
//	xmutex.cpp -- implement mutex lock for iostreams
#include <xdebug>
#include <yvals.h>

 #if _MULTI_THREAD && _IOSTREAM_OP_LOCKS
  #include "xmtx.h"
_STD_BEGIN

#if !defined(MRTDLL)
__thiscall _Mutex::_Mutex()
	: _Mtx(_NEW_CRT _Rmtx)
	{	// initialize recursive mutex object
	_Mtxinit((_Rmtx*)_Mtx);
	}

__thiscall _Mutex::~_Mutex()
	{	// release resources allocated to mutex object
	_Mtxdst((_Rmtx*)_Mtx);
	_DELETE_CRT((_Rmtx*)_Mtx);
	}

void __thiscall _Mutex::_Lock()
	{	// lock mutex
	_Mtxlock((_Rmtx*)_Mtx);
	}

void __thiscall _Mutex::_Unlock()
	{	// unlock mutex
	_Mtxunlock((_Rmtx*)_Mtx);
	}
#endif // !defined(MRTDLL)

_MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex::_Mutex_ctor(_Mutex * _This)
	{	// initialize recursive mutex object
    _This->_Mtx = _NEW_CRT _Rmtx;
	_Mtxinit((_Rmtx*)_This->_Mtx);
	}

_MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex::_Mutex_dtor(_Mutex * _This)
	{	// release resources allocated to mutex object
	_Mtxdst((_Rmtx*)_This->_Mtx);
	_DELETE_CRT((_Rmtx*)_This->_Mtx);
	}

_MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex::_Mutex_Lock(_Mutex * _This)
	{	// lock mutex
	_Mtxlock((_Rmtx*)_This->_Mtx);
	}

_MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex::_Mutex_Unlock(_Mutex * _This)
	{	// unlock mutex
	_Mtxunlock((_Rmtx*)_This->_Mtx);
	}
_STD_END
 #endif	/* _MULTI_THREAD */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xrngabort.cpp ===
// xrngabort: abort on precondition failure in TR1 random number generators
#include <yvals.h>

 #if _HAS_TR1
  #include <stdlib.h>
  #include <stdio.h>
//  #include <random>
_STD_BEGIN
	namespace tr1 {	// TR1 additions

_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL
	_Rng_abort(_In_z_ const char *_Msg);

void __CLRCALL_PURE_OR_CDECL
	_Rng_abort(const char *msg)
	{	/* abort on precondition failure */
	fputs(msg, stderr);
	fputc('\n', stderr);
	abort();
	}

	}	// namespace tr1
_STD_END
 #endif /* _HAS_TR1 */

/*
 * Copyright (c) 1992-2008 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.05:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xmtx.h ===
/* xmtx.h internal header */
#pragma once
#ifndef _XMTX
#define _XMTX
#include <stdlib.h>
#ifndef _YVALS
 #include <yvals.h>
#endif /* _YVALS */

#ifndef MRTDLL
#ifndef _M_CEE_PURE
_C_LIB_DECL
#endif
#endif

#ifdef MRTDLL
/* We want to declare Enter/LeaveCriticalSection as p/invoke */
#define EnterCriticalSection _undefined_EnterCriticalSection
#define LeaveCriticalSection _undefined_LeaveCriticalSection
#endif

#include <windows.h>

#ifdef MRTDLL
#undef EnterCriticalSection
#undef LeaveCriticalSection

_RELIABILITY_CONTRACT
[System::Security::SuppressUnmanagedCodeSecurity]
[System::Runtime::InteropServices::DllImport("kernel32.dll")]
void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

_RELIABILITY_CONTRACT
[System::Security::SuppressUnmanagedCodeSecurity]
[System::Runtime::InteropServices::DllImport("kernel32.dll")]
void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

#endif

typedef CRITICAL_SECTION _Rmtx;

#ifdef _M_CEE_PURE
void __clrcall _Mtxinit(_Rmtx *);
void __clrcall _Mtxdst(_Rmtx *);
void __clrcall _Mtxlock(_Rmtx *);
void __clrcall _Mtxunlock(_Rmtx *);
#else
_MRTIMP2 void __cdecl _Mtxinit(_Rmtx *);
_MRTIMP2 void __cdecl _Mtxdst(_Rmtx *);
_MRTIMP2 void __cdecl _Mtxlock(_Rmtx *);
_MRTIMP2 void __cdecl _Mtxunlock(_Rmtx *);
#endif

 #if !_MULTI_THREAD
  #define _Mtxinit(mtx)
  #define _Mtxdst(mtx)
  #define _Mtxlock(mtx)
  #define _Mtxunlock(mtx)

typedef char _Once_t;

  #define _Once(cntrl, func)	if (*(cntrl) == 0) (func)(), *(cntrl) = 2
  #define _ONCE_T_INIT	0

 #elif _WIN32_C_LIB
typedef long _Once_t;

#ifdef _M_CEE_PURE
void __clrcall _Once(_Once_t *, void (__cdecl *)(void));
#else
_MRTIMP2 void __cdecl _Once(_Once_t *, void (__cdecl *)(void));
#endif
 #define _ONCE_T_INIT	0

 #endif /* _MULTI_THREAD */
#ifndef MRTDLL
#ifndef _M_CEE_PURE
_END_C_LIB_DECL
#endif
#endif
#endif /* _XMTX */

/*
 * Copyright (c) 1992-2006 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.02:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xrngdev.cpp ===
// xrngdev: random device for TR1 random number generators
#define _CRT_RAND_S
#include <stdexcept>

 #if _HAS_TR1
//  #include <random>
_STD_BEGIN
	namespace tr1 {	// TR1 additions

_CRTIMP2_PURE unsigned int __CLRCALL_PURE_OR_CDECL _Random_device();

unsigned int __CLRCALL_PURE_OR_CDECL _Random_device()
	{	// return a random value
	unsigned int ans;
	if (::rand_s(&ans) != 0)
		_THROW_NCEE(out_of_range, "invalid random_device value");
	return (ans);
	}

	}	// namespace tr1
_STD_END
 #endif /* _HAS_TR1 */

/*
 * Copyright (c) 1992-2008 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.05:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xncommod.c ===
/***
*xncommode.c - set global file commit mode flag to nocommit
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to nocommit.  This is the default.
*
*       This is a special version for the DLL model.  This object goes into
*       MSVCRT.LIB (and therefore into the client EXE) and not into the
*       CRTL in a DLL (MSVCRTXX.DLL).  It is identical to ncommode.obj
*       except that the latter has a DLL export definition in the DLL model.
*
*******************************************************************************/

#define SPECIAL_CRTEXE  /* turn off _CRTIMP for decl. of _commode */
#if !defined (_DLL)
#define _DLL            /* also necessary to turn off _CRTIMP */
#endif  /* !defined (_DLL) */

#ifdef CRTDLL
#undef CRTDLL
#endif  /* CRTDLL */

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <cruntime.h>
#include <internal.h>

/* set default file commit mode to nocommit */
int _commode = 0;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstod.c ===
/* _Stod function */
#include <stdlib.h>
#include "xmath.h"
#include "xxcctype.h"
#include "xxdftype.h"

_C_STD_BEGIN

#if defined(__cplusplus) && !defined(MRTDLL)
extern "C"
#endif

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stodx(const char *s, char **endptr, long pten, int *perr)
	{	/* convert string to double */
	int err = errno;
	double x = 0.0;

	errno = 0;
	x = strtod(s, endptr);
	*perr = errno;
	errno = err;

	for (; 0 < pten; --pten)
		x *= 10.0;
	for (; pten < 0; ++pten)
		x /= 10.0;
	return (x);
	}

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stod(const char *s, char **endptr, long pten)
	{	/* convert string, discard error code */
	int err = 0;
	return _Stodx(s, endptr, pten, &err);
	}

_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xsinh.c ===
/* _Sinh function */
#include "xmath.h"
_C_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000001632881,
	0.0000000250483893,
	0.0000027557344615,
	0.0001984126975233,
	0.0083333333334816,
	0.1666666666666574,
	1.0000000000000001};

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Sinh(double x, double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_Dtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0 ? x : DSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0)
			return (x < 0.0 ? -y : y);
		if (x < 0.0)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _Rteps._Double)
			x *= y;	/* x tiny */
		else if (x < 1.0)
			{
			double w = x * x;

			x += x * w * _Poly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1.0, -1);
			x = y * (x - 0.25 / x);
			}
		else
			switch (_Exp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xpoly.c ===
/* _Poly function */
#include "xmath.h"
_C_STD_BEGIN

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Poly(double x, const double *tab, int n)
	{	/* compute polynomial */
	double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstol.c ===
/* _Stolx function */
#include <yvals.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include "xmath.h"
_C_STD_BEGIN

#if defined(__cplusplus) && !defined(MRTDLL)
extern "C"
#endif
_CRTIMP2_PURE unsigned long __CLRCALL_PURE_OR_CDECL _Stoulx(const char *, char **, int, int *);

#if defined(__cplusplus) && !defined(MRTDLL)
extern "C"
#endif
_CRTIMP2_PURE long __CLRCALL_PURE_OR_CDECL _Stolx(const char * s, char ** endptr,
	int base, int *perr)
	{	/* convert string to long, with checking */
	const char *sc;
	char *se, sign;
	unsigned long x;

	if (endptr == 0)
		endptr = &se;
	for (sc = s; isspace((unsigned char)*sc); ++sc)
		;
	sign = *sc == '-' || *sc == '+' ? *sc++ : '+';
	x = _Stoulx(sc, endptr, base, perr);
	if (sc == *endptr)
		*endptr = (char *)s;
	if (s == *endptr && x != 0 || sign == '+' && LONG_MAX < x
		|| sign == '-' && 0 - (unsigned long)LONG_MIN < x)
		{	/* overflow */
		errno = ERANGE;
		if (perr != 0)
			*perr = 1;
		return (sign == '-' ? LONG_MIN : LONG_MAX);
		}
	else
		return ((long)(sign == '-' ? 0 - x : x));
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstold.c ===
/* _Stold function */
#include <stdlib.h>
#include "xmath.h"
#include "xxcctype.h"
#include "xxlftype.h"
_C_STD_BEGIN

#if defined(__cplusplus) && !defined(MRTDLL)
extern "C"
{
#endif
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stodx(const char *s, char **endptr, long pten, int *perr);

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stod(const char *s, char **endptr, long pten);

_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _Stoldx(const char *s, char **endptr, long pten, int *perr)
	{	/* convert string to long double */
	return ((long double)_Stodx(s, endptr, pten, perr));
	}

_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _Stold(const char *s, char **endptr, long pten, int *perr)
	{	/* convert string to long double, discard error code */
	return ((long double)_Stod(s, endptr, pten));
	}

#if defined(__cplusplus) && !defined(MRTDLL)
}
#endif

_C_STD_END

/*
 * Copyright (c) 1992-2004 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V4.04:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstof.c ===
/* _Stof function */
#include <stdlib.h>
#include "xmath.h"
#include "xxcctype.h"
#include "xxfftype.h"
_C_STD_BEGIN

#if defined(__cplusplus) && !defined(MRTDLL)
extern "C"
{
#endif
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stodx(const char *s, char **endptr, long pten, int *perr);

_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stod(const char *s, char **endptr, long pten);

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _Stofx(const char *s, char **endptr, long pten, int *perr)
	{	/* convert string to float */
	return ((float)_Stodx(s, endptr, pten, perr));
	}

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _Stof(const char *s, char **endptr, long pten, int *perr)
	{	/* convert string to float, discard error code */
	return ((float)_Stod(s, endptr, pten));
	}

#if defined(__cplusplus) && !defined(MRTDLL)
}
#endif

_C_STD_END

/*
 * Copyright (c) 1992-2004 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V4.04:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstoll.c ===
/* _Stoll function */
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include "xmath.h"
_C_STD_BEGIN

#define MYMIN	(-_LLONG_MAX - _C2)	/* LLONG_MIN */
#define MYMAX	_LLONG_MAX	/* LLONG_MAX */

_CRTIMP2_PURE _ULonglong __CLRCALL_PURE_OR_CDECL _Stoullx(const char *, char **, int, int *);

_CRTIMP2_PURE _Longlong __CLRCALL_PURE_OR_CDECL _Stollx(const char * s, char ** endptr,
	int base, int *perr)
	{	/* convert string to long long, with checking */
	const char *sc;
	char *se, sign;
	_ULonglong x;

	if (endptr == 0)
		endptr = &se;
	for (sc = s; isspace((unsigned char)*sc); ++sc)
		;
	sign = (char)(*sc == '-' || *sc == '+' ? *sc++ : '+');
	x = _Stoullx(sc, endptr, base, perr);
	if (sc == *endptr)
		*endptr = (char *)s;
	if (s == *endptr && x != 0 || sign == '+' && MYMAX < x
		|| sign == '-' && 0 - (_ULonglong)MYMIN < x)
		{	/* overflow */
		errno = ERANGE;
		if (perr != 0)
			*perr = 1;
		return (sign == '-' ? MYMIN : MYMAX);
		}
	else
		return ((_Longlong)(sign == '-' ? 0 - x : x));
	}

_CRTIMP2_PURE _Longlong (__CLRCALL_PURE_OR_CDECL _Stoll)(const char * s, char ** endptr, int base)
	{	/* convert string, discard error code */
	return (_Stollx(s, endptr, base, 0));
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstrxfrm.c ===
/***
*xstrxfrm.c - Transform a string using locale information
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a string using the locale information as set by
*       LC_COLLATE.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec */
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <awint.h>

/***
*size_t _Strxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the string pointer to by _string2 and place the
*       resulting string into the array pointer to by _string1.
*       No more than _end1 - _string1 characters are place into the
*       resulting string (including the null).
*
*       The transformation is such that if strcmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of strcoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*       [ANSI]
*
*       The value of the following expression is the size of the array
*       needed to hold the transformation of the source string:
*
*               1 + strxfrm(NULL,string,0)
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*       Thus, _Strxfrm() simply resolves to strncpy()/strlen().
*
*Entry:
*       char *_string1       = pointer to beginning of result string
*       char *_end1          = pointer past end of result string
*       const char *_string2 = pointer to beginning of source string
*       const char *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm (
        char *_string1,
        char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        int dstlen;
        size_t retval = (size_t)-1;   /* NON-ANSI: default if OM or API error */
        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_COLLATE];
            codepage = ___lc_collate_cp_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ((handle == _CLOCALEHANDLE) &&
            (codepage == _CLOCALECP))
        {
            if (_n2 <= _n1)
            {
                memcpy(_string1, _string2, _n2);
            }
            retval=_n2;
        }
        else
        {
            /* Inquire size of dst string in BYTES */
            if (0 != (dstlen = __crtLCMapStringA(NULL,
                                                 handle,
                                                 LCMAP_SORTKEY,
                                                 _string2,
                                                 (int)_n2,
                                                 NULL,
                                                 0,
                                                 codepage,
                                                 TRUE)))
            {
                retval = dstlen;

                /* if not enough room, return amount needed */
                if (dstlen <= (int)(_n1))
                {
                    /* Map src string to dst string */
                    __crtLCMapStringA(NULL,
                                      handle,
                                      LCMAP_SORTKEY,
                                      _string2,
                                      (int)_n2,
                                      _string1,
                                      (int)_n1,
                                      codepage,
                                      TRUE);
                }
            }
        }

        return (size_t)retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstoul.c ===
/* _Stoul function */
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stddef.h>
#include <string.h>
#include "xmath.h"
 #pragma warning(disable: 4701)

 #if (ULONG_MAX >> 16) >> 16 != 0xffffffff && ULONG_MAX != 0xffffffff
  #error LONGS TOO LARGE FOR _Stoul
 #endif /* longs too large */

_C_STD_BEGIN

		/* macros */
#define BASE_MAX	36	/* largest valid base */

		/* static data */
static const char digits[] = 	/* valid digits */
	"0123456789abcdefghijklmnopqrstuvwxyz";

 #if (ULONG_MAX >> 16) >> 16 == 0xffffffff
static const char ndigs[BASE_MAX + 1] = {	/* 64-bits! */
	0, 0, 65, 41, 33, 28, 25, 23, 22, 21,
	20, 19, 18, 18, 17, 17, 17, 16, 16, 16,
	15, 15, 15, 15, 14, 14, 14, 14, 14, 14,
	14, 13, 13, 13, 13, 13, 13,};

 #else /* (ULONG_MAX >> 16) >> 16 == 0xffffffff */
static const char ndigs[BASE_MAX+1] = {	/* 32-bits! */
	0, 0, 33, 21, 17, 14, 13, 12, 11, 11,
	10, 10, 9, 9, 9, 9, 9, 8, 8, 8,
	8, 8, 8, 8, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7,};
 #endif /* (ULONG_MAX >> 16) >> 16 == 0xffffffff */

#if defined(__cplusplus) && !defined(MRTDLL)
extern "C"
#endif
_CRTIMP2_PURE unsigned long __CLRCALL_PURE_OR_CDECL _Stoulx(const char *s, char **endptr,
	int base, int *perr)
	{	/* convert string to unsigned long, with checking */
	const char *sc, *sd;
	const char *s1, *s2;
	char dig, sign;
	ptrdiff_t n;
	unsigned long x, y;

	if (perr != 0)
		*perr = 0;
	for (sc = s; isspace((unsigned char)*sc); ++sc)
		;
	sign = *sc == '-' || *sc == '+' ? *sc++ : '+';
	if (base < 0 || base == 1 || BASE_MAX < base)
		{	/* silly base */
		if (endptr != 0)
			*endptr = (char *)s;
		return (0);
		}
	else if (0 < base)
		{	/* strip 0x or 0X */
		if (base == 16 && *sc == '0'
			&& (sc[1] == 'x' || sc[1] == 'X'))
			sc += 2;
		}
	else if (*sc != '0')
		base = 10;
	else if (sc[1] == 'x' || sc[1] == 'X')
		base = 16, sc += 2;
	else
		base = 8;
	for (s1 = sc; *sc == '0'; ++sc)
		;	/* skip leading zeros */
	x = 0;
	for (s2 = sc, y = 0; (sd = (char *)memchr(&digits[0],
		tolower(*sc), base)) != 0; ++sc)
		{	/* accumulate digits */
		y = x;
		dig = (char)(sd - digits);	/* for overflow checking */
		x = x * base + dig;
		}
	if (s1 == sc)
		{	/* check string validity */
		if (endptr != 0)
			*endptr = (char *)s;
		return (0);
		}
	n = sc - s2 - ndigs[base];
	if (n < 0)
		;
	else if (0 < n || x < x - dig || (x - dig) / base != y)
		{	/* overflow */
		errno = ERANGE;
		if (perr != 0)
			*perr = 1;
		x = ULONG_MAX, sign = '+';
		}
	if (sign == '-')	/* get final value */
		x = 0 - x;
	if (endptr != 0)
		*endptr = (char *)sc;
	return (x);
	}

_CRTIMP2_PURE unsigned long __CLRCALL_PURE_OR_CDECL _Stoul(const char *s, char **endptr, int base)
	{	/* convert string, discard error code */
	return (_Stoulx(s, endptr, base, 0));
	}
_C_STD_END

/*
 * Copyright (c) 1992-2006 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.02:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstoull.c ===
/* _Stoull function */
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stddef.h>
#include <string.h>
#include "xmath.h"

#define MYMAX	_ULLONG_MAX	/* ULLONG_MAX */

 #if (MYMAX >> 16) >> 16 != 0xffffffff && MYMAX != 0xffffffff
  #error LONG LONGS TOO LARGE FOR _Stoull
 #endif /* long longs too large */

 #define BIG_TABLE	(MYMAX >> 16) >> 16 == 0xffffffff

_C_STD_BEGIN

		/* macros */
#define BASE_MAX	36	/* largest valid base */

		/* static data */
static const char digits[] = 	/* valid digits */
	"0123456789abcdefghijklmnopqrstuvwxyz";

 #if BIG_TABLE
static const char ndigs[BASE_MAX + 1] = {	/* 64-bits! */
	0, 0, 65, 41, 33, 28, 25, 23, 22, 21,
	20, 19, 18, 18, 17, 17, 17, 16, 16, 16,
	15, 15, 15, 15, 14, 14, 14, 14, 14, 14,
	14, 13, 13, 13, 13, 13, 13,};

 #else /* BIG_TABLE */
static const char ndigs[BASE_MAX+1] = {	/* 32-bits! */
	0, 0, 33, 21, 17, 14, 13, 12, 11, 11,
	10, 10, 9, 9, 9, 9, 9, 8, 8, 8,
	8, 8, 8, 8, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7,};
 #endif /* BIG_TABLE */

_CRTIMP2_PURE _ULonglong __CLRCALL_PURE_OR_CDECL _Stoullx(const char *s, char **endptr,
	int base, int *perr)
	{	/* convert string to unsigned long long, with checking */
	const char *sc, *sd;
	const char *s1, *s2;
	char dig, sign;
	ptrdiff_t n;
	_ULonglong x, y;

	if (perr != 0)
		*perr = 0;
	for (sc = s; isspace((unsigned char)*sc); ++sc)
		;
	sign = (char)(*sc == '-' || *sc == '+' ? *sc++ : '+');
	if (base < 0 || base == 1 || BASE_MAX < base)
		{	/* silly base */
		if (endptr != 0)
			*endptr = (char *)s;
		return (0);
		}
	else if (0 < base)
		{	/* strip 0x or 0X */
		if (base == 16 && *sc == '0'
			&& (sc[1] == 'x' || sc[1] == 'X'))
			sc += 2;
		}
	else if (*sc != '0')
		base = 10;
	else if (sc[1] == 'x' || sc[1] == 'X')
		base = 16, sc += 2;
	else
		base = 8;
	for (s1 = sc; *sc == '0'; ++sc)
		;	/* skip leading zeros */
	x = 0;
	for (s2 = sc, y = 0, dig = 0; (sd = (char *)memchr(&digits[0],
		tolower(*sc), base)) != 0; ++sc)
		{	/* accumulate digits */
		y = x;
		dig = (char)(sd - digits);	/* for overflow checking */
		x = x * base + dig;
		}
	if (s1 == sc)
		{	/* check string validity */
		if (endptr != 0)
			*endptr = (char *)s;
		return (0);
		}
	n = sc - s2 - ndigs[base];
	if (n < 0)
		;
	else if (0 < n || x < x - dig || (x - dig) / base != y)
		{	/* overflow */
		errno = ERANGE;
		if (perr != 0)
			*perr = 1;
		x = MYMAX, sign = '+';
		}
	if (sign == '-')	/* get final value */
		x = 0 - x;
	if (endptr != 0)
		*endptr = (char *)sc;
	return (x);
	}

_CRTIMP2_PURE _ULonglong __CLRCALL_PURE_OR_CDECL _Stoull(const char *s, char **endptr, int base)
	{	/* convert string, discard error code */
	return (_Stoullx(s, endptr, base, 0));
	}
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xstrcoll.c ===
/***
*xstrcoll.c - Collate locale strings
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strcoll */
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <errno.h>
#include <awint.h>

/***
*int _Strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1b = pointer to beginning of the first string
*       const char *s1e = pointer past end of the first string
*       const char *s2b = pointer to beginning of the second string
*       const char *s1e = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Strcoll (
        const char *_string1,
        const char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        int ret=0;
        LCID handle;
        UINT codepage;
        int n1 = (int)(_end1 - _string1);
        int n2 = (int)(_end2 - _string2);

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_COLLATE];
            codepage = ___lc_collate_cp_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE) {
            int ans;
            ans = memcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            ret=(ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1);
        }
        else
        {
            if ( 0 == (ret = __crtCompareStringA( NULL,
                                                  handle,
                                                  SORT_STRINGSORT,
                                                  _string1,
                                                  n1,
                                                  _string2,
                                                  n2,
                                                  codepage )) )
            {
                errno=EINVAL;
                ret=_NLSCMPERROR;
            }
            else
            {
                ret-=2;
            }
        }

        return ret;
}


/***
*_Collvec _Getcoll() - get collation info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2_PURE _Collvec __CLRCALL_PURE_OR_CDECL _Getcoll()
{
        _Collvec coll;

        coll._Hand = ___lc_handle_func()[LC_COLLATE];
        coll._Page = ___lc_collate_cp_func();

        return (coll);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xthdloc.c ===
/***
*xthdloc.c - sets the __globallocalestatus flag to disable per thread locale
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the __globallocalestatus flag to enable per thread locale.
*       Link with this obj to enable per thread locale.
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

int __globallocalestatus = (~_GLOBAL_LOCALE_BIT) ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtoas.c ===
/***
*xtoas.c - Secure Version of xtoa.c
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module is split from xtoa to avoid xtoa.obj pulling in startup code
*
*******************************************************************************/

#define _SECURE_ITOA
#include "xtoa.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtow.c ===
/***
*xtow.c - convert integers/longs to wide char string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The module has code to convert integers/longs to wide char strings.
*
*******************************************************************************/

#define _UNICODE
#include "xtoa.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtoa.c ===
/***
*xtoa.c - convert integers/longs to ASCII string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The module has code to convert integers/longs to ASCII strings.  See
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <tchar.h>
#include <internal.h>
#include <internal_securecrt.h>

#ifdef _UNICODE
#define xtox_s     xtow_s
#define _itox_s    _itow_s
#define _ltox_s    _ltow_s
#define _ultox_s   _ultow_s
#define x64tox_s   x64tow_s
#define _i64tox_s  _i64tow_s
#define _ui64tox_s _ui64tow_s
#define xtox       xtow
#define _itox      _itow
#define _ltox      _ltow
#define _ultox     _ultow
#define x64tox     x64tow
#define _i64tox    _i64tow
#define _ui64tox   _ui64tow
#else  /* _UNICODE */
#define xtox_s     xtoa_s
#define _itox_s    _itoa_s
#define _ltox_s    _ltoa_s
#define _ultox_s   _ultoa_s
#define x64tox_s   x64toa_s
#define _i64tox_s  _i64toa_s
#define _ui64tox_s _ui64toa_s
#define xtox       xtoa
#define _itox      _itoa
#define _ltox      _ltoa
#define _ultox     _ultoa
#define x64tox     x64toa
#define _i64tox    _i64toa
#define _ui64tox   _ui64toa
#endif  /* _UNICODE */

/***
*char *_itoa_s, *_ltoa_s, *_ultoa_s(val, buf, sizeInTChars, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       char *buf - ptr to buffer to place result
*       size_t sizeInTChars - size of the destination buffer
*       int radix - base to convert into
*
*Exit:
*       Fills in space pointed to by buf with string result.
*       Returns the errno_t: err != 0 means that something went wrong, and
*       an empty string (buf[0] = 0) is returned.
*
*Exceptions:
*           Input parameters and buffer length are validated.
*       Refer to the validation section of the function.
*
*******************************************************************************/

/* helper routine that does the main job. */
#ifdef _SECURE_ITOA
static errno_t __stdcall xtox_s
        (
        unsigned long val,
        TCHAR *buf,
        size_t sizeInTChars,
        unsigned radix,
        int is_neg
        )
#else  /* _SECURE_ITOA */
static void __stdcall xtox
        (
        unsigned long val,
        TCHAR *buf,
        unsigned radix,
        int is_neg
        )
#endif  /* _SECURE_ITOA */
{
        TCHAR *p;                /* pointer to traverse string */
        TCHAR *firstdig;         /* pointer to first digit */
        TCHAR temp;              /* temp char */
        unsigned digval;         /* value of digit */
#ifdef _SECURE_ITOA
        size_t length;           /* current length of the string */

        /* validation section */
        _VALIDATE_RETURN_ERRCODE(buf != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInTChars > 0, EINVAL);
        _RESET_STRING(buf, sizeInTChars);
        _VALIDATE_RETURN_ERRCODE(sizeInTChars > (size_t)(is_neg ? 2 : 1), ERANGE);
        _VALIDATE_RETURN_ERRCODE(2 <= radix && radix <= 36, EINVAL);
        length = 0;

#endif  /* _SECURE_ITOA */
        p = buf;

        if (is_neg) {
            /* negative, so output '-' and negate */
            *p++ = _T('-');
#ifdef _SECURE_ITOA
            length++;
#endif  /* _SECURE_ITOA */
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (TCHAR) (digval - 10 + _T('a'));  /* a letter */
            else
                *p++ = (TCHAR) (digval + _T('0'));       /* a digit */
#ifndef _SECURE_ITOA
        } while (val > 0);
#else  /* _SECURE_ITOA */
            length++;
        } while (val > 0 && length < sizeInTChars);

        /* Check for buffer overrun */
        if (length >= sizeInTChars)
        {
            buf[0] = '\0';
            _VALIDATE_RETURN_ERRCODE(length < sizeInTChars, ERANGE);
        }
#endif  /* _SECURE_ITOA */
        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = _T('\0');            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
#ifdef _SECURE_ITOA
        return 0;
#endif  /* _SECURE_ITOA */
}

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

#ifdef _SECURE_ITOA
errno_t __cdecl _itox_s (
        int val,
        TCHAR *buf,
        size_t sizeInTChars,
        int radix
        )
{
        errno_t e = 0;

        if (radix == 10 && val < 0)
            e = xtox_s((unsigned long)val, buf, sizeInTChars, radix, 1);
        else
            e = xtox_s((unsigned long)(unsigned int)val, buf, sizeInTChars, radix, 0);

        return e;
}

errno_t __cdecl _ltox_s (
        long val,
        TCHAR *buf,
        size_t sizeInTChars,
        int radix
        )
{
        return xtox_s((unsigned long)val, buf, sizeInTChars, radix, (radix == 10 && val < 0));
}

errno_t __cdecl _ultox_s (
        unsigned long val,
        TCHAR *buf,
        size_t sizeInTChars,
        int radix
        )
{
        return xtox_s(val, buf, sizeInTChars, radix, 0);
}

#else  /* _SECURE_ITOA */

/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*           Input parameters are validated. The buffer is assumed to be big enough to
*       contain the string. Refer to the validation section of the function.
*
*******************************************************************************/

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

TCHAR * __cdecl _itox (
        int val,
        TCHAR *buf,
        int radix
        )
{
        if (radix == 10 && val < 0)
            xtox((unsigned long)val, buf, radix, 1);
        else
            xtox((unsigned long)(unsigned int)val, buf, radix, 0);
        return buf;
}

TCHAR * __cdecl _ltox (
        long val,
        TCHAR *buf,
        int radix
        )
{
        xtox((unsigned long)val, buf, radix, (radix == 10 && val < 0));
        return buf;
}

TCHAR * __cdecl _ultox (
        unsigned long val,
        TCHAR *buf,
        int radix
        )
{
        xtox(val, buf, radix, 0);
        return buf;
}

#endif  /* _SECURE_ITOA */

#ifndef _NO_INT64

/***
*char *_i64toa_s(val, buf, sizeInTChars, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int64 to a character string.
*
*Entry:
*       val - number to be converted
*       char *buf - ptr to buffer to place result
*       size_t sizeInTChars - size of the destination buffer
*       int radix - base to convert into
*
*Exit:
*       Fills in space pointed to by buf with string result.
*       Returns the errno_t: err != 0 means that something went wrong, and
*       an empty string (buf[0] = 0) is returned.
*
*Exceptions:
*       Input parameters and buffer length are validated.
*       Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef _SECURE_ITOA
static errno_t __fastcall x64tox_s
        (/* stdcall is faster and smaller... Might as well use it for the helper. */
        unsigned __int64 val,
        TCHAR *buf,
        size_t sizeInTChars,
        unsigned radix,
        int is_neg
        )
#else  /* _SECURE_ITOA */
static void __fastcall x64tox
        (/* stdcall is faster and smaller... Might as well use it for the helper. */
        unsigned __int64 val,
        TCHAR *buf,
        unsigned radix,
        int is_neg
        )
#endif  /* _SECURE_ITOA */
{
        TCHAR *p;                /* pointer to traverse string */
        TCHAR *firstdig;         /* pointer to first digit */
        TCHAR temp;              /* temp char */
        unsigned digval;         /* value of digit */
#ifdef _SECURE_ITOA
        size_t length;           /* current length of the string */

        /* validation section */
        _VALIDATE_RETURN_ERRCODE(buf != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInTChars > 0, EINVAL);
        _RESET_STRING(buf, sizeInTChars);
        _VALIDATE_RETURN_ERRCODE(sizeInTChars > (size_t)(is_neg ? 2 : 1), ERANGE);
        _VALIDATE_RETURN_ERRCODE(2 <= radix && radix <= 36, EINVAL);
        length = 0;
#endif  /* _SECURE_ITOA */
        p = buf;

        if ( is_neg )
        {
            *p++ = _T('-');         /* negative, so output '-' and negate */
#ifdef _SECURE_ITOA
            length++;
#endif  /* _SECURE_ITOA */
            val = (unsigned __int64)(-(__int64)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (TCHAR) (digval - 10 + _T('a'));  /* a letter */
            else
                *p++ = (TCHAR) (digval + _T('0'));       /* a digit */

#ifndef _SECURE_ITOA
        } while (val > 0);
#else  /* _SECURE_ITOA */
            length++;
        } while (val > 0 && length < sizeInTChars);

        /* Check for buffer overrun */
        if (length >= sizeInTChars)
        {
            buf[0] = '\0';
            _VALIDATE_RETURN_ERRCODE(length < sizeInTChars, ERANGE);
        }
#endif  /* _SECURE_ITOA */
        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = _T('\0');            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */

#ifdef _SECURE_ITOA
        return 0;
#endif  /* _SECURE_ITOA */
}

#ifdef _SECURE_ITOA

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

errno_t __cdecl _i64tox_s (
        __int64 val,
        TCHAR *buf,
        size_t sizeInTChars,
        int radix
        )
{
        return x64tox_s((unsigned __int64)val, buf, sizeInTChars, radix, (radix == 10 && val < 0));
}

errno_t __cdecl _ui64tox_s (
        unsigned __int64 val,
        TCHAR *buf,
        size_t sizeInTChars,
        int radix
        )
{
        return x64tox_s(val, buf, sizeInTChars, radix, 0);
}

#else  /* _SECURE_ITOA */

/***
*char *_i64toa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int64 to a character string.
*
*Entry:
*       val - number to be converted
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*           Input parameters are validated. The buffer is assumed to be big enough to
*       contain the string. Refer to the validation section of the function.
*
*******************************************************************************/

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

TCHAR * __cdecl _i64tox (
        __int64 val,
        TCHAR *buf,
        int radix
        )
{
        x64tox((unsigned __int64)val, buf, radix, (radix == 10 && val < 0));
        return buf;
}

TCHAR * __cdecl _ui64tox (
        unsigned __int64 val,
        TCHAR *buf,
        int radix
        )
{
        x64tox(val, buf, radix, 0);
        return buf;
}

#endif  /* _SECURE_ITOA */

#endif  /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtowlower.c ===
/* _Towlower -- convert wchar_t to lower case for Microsoft */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

_C_STD_BEGIN
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towlower(wchar_t _Ch, const _Ctypevec *_Ctype)
	{	/* convert element to lower case */
	wchar_t _Res = _Ch;

	if (_Ch == WEOF)
		;
	else if (_Ctype->_Hand == _CLOCALEHANDLE && _Ch < 256)
		{	/* handle ASCII character in C locale */
		if (L'A' <= _Ch && _Ch <= L'Z')
			_Res = (wchar_t)(_Ch - L'A' + L'a');
		}
	else if (__crtLCMapStringW(_Ctype->_Hand, LCMAP_LOWERCASE,
			&_Ch, 1, &_Res, 1) == 0)
		_Res = _Ch;
	return (_Res);
	}

#ifdef MRTDLL
_CRTIMP2_PURE unsigned short __CLRCALL_PURE_OR_CDECL _Towlower(unsigned short _Ch, const _Ctypevec *_Ctype)
    {
    return _Towlower((wchar_t) _Ch, _Ctype);
    }
#endif
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xthrow.cpp ===
// exception handling support functions
#include <stdexcept>

_STD_BEGIN

_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char * _Message)
	{ // report an invalid_argument error
	_THROW_NCEE(invalid_argument, _Message);
	}

_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char * _Message)
	{ // report a length_error
	_THROW_NCEE(length_error, _Message);
	}

_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char * _Message)
	{ // report an out_of_range error
	_THROW_NCEE(out_of_range, _Message);
	}

_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char * _Message)
	{ // report an overflow_error
	_THROW_NCEE(overflow_error, _Message);
	}

_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char * _Message)
	{ // report a runtime_error
	_THROW_NCEE(runtime_error, _Message);
	}

_STD_END

/*
 * Copyright (c) 1995-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.20:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtows.c ===
/***
*xtows.c - Secure Version of xtow.c
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module is split from xtow to avoid xtow.obj pulling in startup code
*
*******************************************************************************/

#define _SECURE_ITOA
#define _UNICODE
#include "xtoa.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtxtmode.c ===
/***
*xtxtmode.c - set global text mode flag
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file mode to text.  This is the default.
*
*       This is a special version for the DLL model.  This object goes into
*       MSVCRT.LIB (and therefore into the client EXE) and not into the
*       CRTL in a DLL (MSVCRTXX.DLL).  It is identical to txtmode.obj
*       except that the latter has a DLL export definition in the DLL model.
*
*******************************************************************************/

#define SPECIAL_CRTEXE  /* turn off _CRTIMP for decl. of _fmode */

#include <cruntime.h>
#include <stdlib.h>

int _fmode = 0;                 /* set text mode */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xtowupper.c ===
/* _Towupper -- convert wchar_t to upper case for Microsoft */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

_C_STD_BEGIN
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towupper(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* convert element to upper case */
	wchar_t _Res = _Ch;

	if (_Ch == WEOF)
		;
	else if (_Ctype->_Hand == _CLOCALEHANDLE && _Ch < 256)
		{	/* handle ASCII character in C locale */
		if (L'a' <= _Ch && _Ch <= L'z')
			_Res = (wchar_t)(_Ch - L'a' + L'A');
		}
	else if (__crtLCMapStringW(_Ctype->_Hand, LCMAP_UPPERCASE,
			&_Ch, 1, &_Res, 1) == 0)
		_Res = _Ch;
	return (_Res);
	}
#ifdef MRTDLL
_CRTIMP2_PURE unsigned short __CLRCALL_PURE_OR_CDECL _Towupper(unsigned short _Ch,
	const _Ctypevec *_Ctype)
    {
    return _Towupper((wchar_t) _Ch, _Ctype);
    }
#endif
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xxcctype.h ===
/* xxcctype.h -- parameters for char character type */

#define CTYPE	char
#define CNAME(fun)	_##fun

/*
 * Copyright (c) 1992-2004 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V4.04:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xxdftype.h ===
/* xxdftype.h -- parameters for double floating-point type */
#include <yvals.h>
#include <float.h>

#define FTYPE	double
#define FCTYPE	_Dcomplex
#define FBITS	DBL_MANT_DIG
#define FEPS	DBL_EPSILON
#define FMAXEXP	DBL_MAX_EXP
#define FFUN(fun)	fun
#define FMACRO(x)	x
#define FNAME(fun)	_##fun
#define FCONST(obj)	_##obj._Double
#define FLIT(lit)	lit
#define FISNEG(exp)	DSIGN(exp)
#define FCPTYPE	complex<double>

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xwctomb.c ===
/***
*xwctomb.c - Convert wide character to multibyte character, with locale.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <limits.h>             /* for MB_LEN_MAX */
#include <string.h>             /* for memcpy */
#include <stdio.h>              /* for EOF */
#include <xlocinfo.h>           /* for _Cvtvec, _Wcrtomb */
#include <locale.h>
#include <setlocal.h>
#include <internal.h>

/***
*int _Wcrtomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s             = pointer to multibyte character
*       wchar_t wchar       = source wide character
*       mbstate_t *pst      = pointer to state (not used)
*       const _Cvtvec *ploc = pointer to locale info
*
*Exit:
*       Returns:
*      -1 (if error) or number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

/* Retained for backward compatibility of DLL exports only */
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL __Wcrtomb_lk
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        return _Wcrtomb(s, wchar, pst, ploc);
}

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcrtomb
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ( handle == _CLOCALEHANDLE )
        {
            if ( wchar > 255 )  /* validate high byte */
            {
                errno = EILSEQ;
                return -1;
            }

            *s = (char) wchar;
            return sizeof(char);
        } else {
            int size;
            BOOL defused = 0;
            _locale_t locale = _GetLocaleForCP(codepage);

            if ( ((size = WideCharToMultiByte(codepage,
                                              0,
                                              &wchar,
                                              1,
                                              s,
                                              ___mb_cur_max_l_func(locale),
                                              NULL,
                                              &defused)) == 0) ||
                 (defused) )
            {
                errno = EILSEQ;
                return -1;
            }

            return size;
        }
}

#ifdef MRTDLL
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcrtomb
        (
        char *s,
        unsigned short wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
    {
    return _Wcrtomb(s,(wchar_t) wchar, pst, ploc);
    }
#endif  /* MRTDLL */

/***
*_Cvtvec _Getcvt() - get conversion info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2_PURE _Cvtvec __CLRCALL_PURE_OR_CDECL _Getcvt()
{
        _Cvtvec cvt;

        cvt._Hand = ___lc_handle_func()[LC_CTYPE];
        cvt._Page = ___lc_codepage_func();

        return (cvt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xwcscoll.c ===
/***
*xwcscoll.c - Collate wide-character locale strings
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcscoll */

/***
*static int _Wmemcmp(s1, s2, n) - compare wchar_t s1[n], s2[n]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static int __CLRCALL_PURE_OR_CDECL _Wmemcmp(
        const wchar_t *s1,
        const wchar_t *s2,
        int n
        )
{
        for (; 0 < n; ++s1, ++s2, --n)
             if (*s1 != *s2)
               return (*s1 < *s2 ? -1 : +1);
        return (0);
}

/***
*int _Wcscoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       In the C locale, wcscmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *_string1 = pointer to beginning of the first string
*       const wchar_t *_end1    = pointer past end of the first string
*       const wchar_t *_string2 = pointer to beginning of the second string
*       const wchar_t *_end2    = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll (
        const wchar_t *_string1,
        const wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{
        int n1 = (int)(_end1 - _string1);
        int n2 = (int)(_end2 - _string2);
        int ret=0;
        LCID handle;

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            ans = _Wmemcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            ret=(ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1);
        }
        else
        {
            if (0 == (ret = __crtCompareStringW(handle,
                                                SORT_STRINGSORT,
                                                _string1,
                                                n1,
                                                _string2,
                                                n2)))
            {
                errno = EINVAL;
                ret=_NLSCMPERROR;
            }
            else
            {
                ret-=2;
            }
        }

        return ret;
}

#ifdef MRTDLL
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll (
        const unsigned short *_string1,
        const unsigned short *_end1,
        const unsigned short *_string2,
        const unsigned short *_end2,
        const _Collvec *ploc
        )
    {
    return _Wcscoll(
            (const wchar_t *)_string1,
            (const wchar_t *)_end1,
            (const wchar_t *)_string2,
            (const wchar_t *)_end2,
            ploc);
    }
#endif  /* MRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xxfftype.h ===
/* xxfftype.h -- parameters for float floating-point type */
#include <yvals.h>
#include <float.h>

#define FTYPE	float
#define FCTYPE	_Fcomplex
#define FBITS	FLT_MANT_DIG
#define FEPS	FLT_EPSILON
#define FMAXEXP	FLT_MAX_EXP
#define FFUN(fun)	fun##f
#define FMACRO(x)	F##x
#define FNAME(fun)	_F##fun
#define FCONST(obj)	_F##obj._Float
#define FLIT(lit)	lit##F
#define FISNEG(exp)	FSIGN(exp)
#define FCPTYPE	complex<float>

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xxlftype.h ===
/* xxlftype.h -- parameters for long double floating-point type */
#include <yvals.h>
#include <float.h>

#define FTYPE	long double
#define FCTYPE	_Lcomplex
#define FBITS	LDBL_MANT_DIG
#define FEPS	LDBL_EPSILON
#define FMAXEXP	LDBL_MAX_EXP
#define FFUN(fun)	fun##l
#define FMACRO(x)	L##x
#define FNAME(fun)	_L##fun
#define FCONST(obj)	_L##obj._Long_double
#define FLIT(lit)	lit##L
#define FISNEG(exp)	LSIGN(exp)
#define FCPTYPE	complex<long double>

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xvalues.c ===
/* values used by math functions -- IEEE 754 version */
#if defined(_M_CEE_PURE)
#if defined(MRTDLL)
#undef MRTDLL
#endif
#if defined(MRTDLL)
#undef CRTDLL
#endif
#endif

#include "xmath.h"
_C_STD_BEGIN

		/* macros */
#define NBITS	(48 + _DOFF)

 #if _D0 == 0
  #define INIT(w0)		{w0, 0, 0, 0}
  #define INIT2(w0, w1)	{w0, 0, 0, w1}

 #else /* _D0 == 0 */
  #define INIT(w0)		{0, 0, 0, w0}
  #define INIT2(w0, w1)	{w1, 0, 0, w0}
 #endif /* _D0 == 0 */

		/* static data */
extern /* const */ _Dconst _Denorm = {INIT2(0, 1)};
extern /* const */ _Dconst _Eps = {
	INIT((_DBIAS - NBITS - 1) << _DOFF)};
extern /* const */ _Dconst _Hugeval = {INIT(_DMAX << _DOFF)};
extern /* const */ _Dconst _Inf = {INIT(_DMAX << _DOFF)};
extern /* const */ _Dconst _Nan = {INIT((_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
extern /* const */ _Dconst _Snan = {INIT2(_DMAX << _DOFF, 1)};
extern /* const */ _Dconst _Rteps = {
	INIT((_DBIAS - NBITS / 2) << _DOFF)};

extern /* const */ double _Xbig = (NBITS + 1) * 347L / 1000;
extern /* const */ double _Zero = 0.0;
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\xwcsxfrm.c ===
/***
*xwcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <stdlib.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcsxfrm */

/***
*size_t _Wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _end1 - _string1 wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = pointer to beginning of result string
*       wchar_t *_end1          = pointer past end of result string
*       const wchar_t *_string2 = pointer to beginning of source string
*       const wchar_t *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm (
        wchar_t *_string1,
        wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        size_t size = (size_t)-1;
        unsigned char *bbuffer=NULL;
        LCID handle;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_COLLATE];
        }
        else
        {
            handle = ploc->_Hand;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if (_n2 <= _n1)
            {
                memcpy(_string1, _string2, _n2 * sizeof (wchar_t));
            }
            size=_n2;
        }
        else
        {

            /*
            * When using LCMAP_SORTKEY, LCMapStringW handles BYTES not wide
            * chars. We use a byte buffer to hold bytes and then convert the
            * byte string to a wide char string and return this so it can be
            * compared using wcscmp(). User's buffer is _n1 wide chars, so
            * use an internal buffer of _n1 bytes.
            */

            if (NULL != (bbuffer = (unsigned char *)_malloc_crt(_n1)))
            {
                if (0 == (size = __crtLCMapStringW(handle,
                                                   LCMAP_SORTKEY,
                                                   _string2,
                                                   (int)_n2,
                                                   (wchar_t *)bbuffer,
                                                   (int)_n1)))
                {
                    /* buffer not big enough, get size required. */

                    if (0 == (size = __crtLCMapStringW(handle,
                                                       LCMAP_SORTKEY,
                                                       _string2,
                                                       (int)_n2,
                                                       NULL,
                                                       0)))
                    {
                        size = INT_MAX; /* default error */
                    }
                } else {
                    size_t i;
                    /* string successfully mapped, convert to wide char */

                    for (i = 0; i < size; i++)
                    {
                        _string1[i] = (wchar_t)bbuffer[i];
                    }
                }
            }
        }

        if(bbuffer)
        {
            _free_crt(bbuffer);
        }

        return (size_t)size;
}

#ifdef MRTDLL
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm (
        unsigned short *_string1,
        unsigned short *_end1,
        const unsigned short *_string2,
        const unsigned short *_end2,
        const _Collvec *ploc
        )
    {
    return _Wcsxfrm(
        (wchar_t *)_string1,
        (wchar_t *)_end1,
        (const wchar_t *)_string2,
        (const wchar_t *)_end2,
        ploc);
    }
#endif  /* MRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_filbuf.c ===
/***
*_filbuf.c - fill buffer and get character
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _filbuf() - fill buffer and read first character, allocate
*       buffer if there is none.  Used from getc().
*       defines _filwbuf() - fill buffer and read first wide character, allocate
*       buffer if there is none.  Used from getwc().
*
*Note:
*       this file is included in safecrt.lib build directly, plese refer
*       to safecrt_filwbuf.c
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <malloc.h>
#include <internal.h>
#include <msdos.h>
#include <wchar.h>
#include <mtdll.h>
#include <tchar.h>

#ifndef _UNICODE

/***
*int _filbuf(stream) - fill buffer and get first character
*
*Purpose:
*       get a buffer if the file doesn't have one, read into it, return first
*       char. try to get a buffer, if a user buffer is not assigned. called
*       only from getc; intended for use only within library. assume no input
*       stream is to remain unbuffered when memory is available unless it is
*       marked _IONBF. at worst, give it a single char buffer. the need for a
*       buffer, no matter how small, becomes evident when we consider the
*       ungetc's necessary in scanf
*
*       [NOTE: Multi-thread - _filbuf() assumes that the caller has aquired
*       the stream lock, if needed.]
*
*Entry:
*       FILE *stream - stream to read from
*
*Exit:
*       returns first character from buffer (next character to be read)
*       returns EOF if the FILE is actually a string, or not open for reading,
*       or if open for writing or if no more chars to read.
*       all fields in FILE structure may be changed except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _filbuf (
        FILE *str
        )

#else  /* _UNICODE */

/***
*int _filwbuf(stream) - fill buffer and get first wide character
*
*Purpose:
*       get a buffer if the file doesn't have one, read into it, return first
*       char. try to get a buffer, if a user buffer is not assigned. called
*       only from getc; intended for use only within library. assume no input
*       stream is to remain unbuffered when memory is available unless it is
*       marked _IONBF. at worst, give it a single char buffer. the need for a
*       buffer, no matter how small, becomes evident when we consider the
*       ungetc's necessary in scanf
*
*       [NOTE: Multi-thread - _filwbuf() assumes that the caller has aquired
*       the stream lock, if needed.]
*
*Entry:
*       FILE *stream - stream to read from
*
*Exit:
*       returns first wide character from buffer (next character to be read)
*       returns WEOF if the FILE is actually a string, or not open for reading,
*       or if open for writing or if no more chars to read.
*       all fields in FILE structure may be changed except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _filwbuf (
        FILE *str
        )

#endif  /* _UNICODE */

{

        REG1 FILE *stream=NULL;

                /* In safecrt, we assume we always have a buffer */
        _VALIDATE_RETURN(str != NULL, EINVAL, _TEOF);

        /* Init pointer to _iob2 entry. */
        stream = str;

        if (!inuse(stream) || stream->_flag & _IOSTRG)
                return(_TEOF);

        if (stream->_flag & _IOWRT) {
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

        stream->_flag |= _IOREAD;

        /* Get a buffer, if necessary. */

        if (!anybuf(stream))
        {
#ifndef _SAFECRT_IMPL
            _getbuf(stream);
#else  /* _SAFECRT_IMPL */
            /* In safecrt, we assume we always have a buffer */
            _VALIDATE_RETURN(FALSE, EINVAL, _TEOF);
#endif  /* _SAFECRT_IMPL */
        }
        else
        {
            stream->_ptr = stream->_base;
        }

        stream->_cnt = _read(_fileno(stream), stream->_base, stream->_bufsiz);

#ifndef _UNICODE
        if ((stream->_cnt == 0) || (stream->_cnt == -1)) {
#else  /* _UNICODE */
        if ((stream->_cnt == 0) || (stream->_cnt == 1) || stream->_cnt == -1) {
#endif  /* _UNICODE */
                stream->_flag |= stream->_cnt ? _IOERR : _IOEOF;
                stream->_cnt = 0;
                return(_TEOF);
        }

        if (  !(stream->_flag & (_IOWRT|_IORW)) &&
              ((_osfile_safe(_fileno(stream)) & (FTEXT|FEOFLAG)) ==
                (FTEXT|FEOFLAG)) )
                stream->_flag |= _IOCTRLZ;
        /* Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and
           if it is our buffer, then this must be the first _filbuf after
           an fseek on a read-access-only stream. Restore _bufsiz to its
           larger value (_INTERNAL_BUFSIZ) so that the next _filbuf call,
           if one is made, will fill the whole buffer. */
        if ( (stream->_bufsiz == _SMALL_BUFSIZ) && (stream->_flag &
              _IOMYBUF) && !(stream->_flag & _IOSETVBUF) )
        {
                stream->_bufsiz = _INTERNAL_BUFSIZ;
        }
#ifndef _UNICODE
        stream->_cnt--;
        return(0xff & *stream->_ptr++);
#else  /* _UNICODE */
        stream->_cnt -= sizeof(wchar_t);
        return (0xffff & *((wchar_t *)(stream->_ptr))++);
#endif  /* _UNICODE */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_ctype.c ===
/***
*_ctype.c - function versions of ctype macros
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This files provides function versions of the character
*       classification and conversion macros in ctype.h.
*
*******************************************************************************/

/***
*ctype - Function versions of ctype macros
*
*Purpose:
*       Function versions of the macros in ctype.h.  In order to define
*       these, we use a trick -- we use parentheses so we can use the
*       name in the function declaration without macro expansion, then
*       we use the macro in the definition part.
*
*       Functions defined:
*           isalpha     isupper     islower
*           isdigit     isxdigit    isspace
*           ispunct     isalnum     isprint
*           isgraph     isctrl      __isascii
*           __toascii   __iscsym    __iscsymf
*
*Entry:
*       int c = character to be tested
*Exit:
*       returns non-zero = character is of the requested type
*                  0 = character is NOT of the requested type
*
*Exceptions:
*       None.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#ifdef _DEBUG
#define __fast_ch_check(a,b)       _chvalidator(a,b)
#else  /* _DEBUG */
#define __fast_ch_check(a,b)       (__initiallocinfo.pctype[(a)] & (b))
#endif  /* _DEBUG */

extern "C"
{
extern __inline int (__cdecl _isalpha_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isalpha_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isalpha) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _ALPHA);
    }
    else
    {
        return (_isalpha_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isupper_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isupper_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isupper) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _UPPER);
    }
    else
    {
        return (_isupper_l)(c, NULL);
    }
}

extern __inline int (__cdecl _islower_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _islower_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl islower) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _LOWER);
    }
    else
    {
        return (_islower_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isdigit_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isdigit_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isdigit) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _DIGIT);
    }
    else
    {
        return (_isdigit_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isxdigit_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isxdigit_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isxdigit) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _HEX);
    }
    else
    {
        return (_isxdigit_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isspace_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isspace_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isspace) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _SPACE);
    }
    else
    {
        return (_isspace_l)(c, NULL);
    }
}

extern __inline int (__cdecl _ispunct_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _ispunct_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl ispunct) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _PUNCT);
    }
    else
    {
        return (_ispunct_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isalnum_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isalnum_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isalnum) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _ALPHA|_DIGIT);
    }
    else
    {
        return (_isalnum_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isprint_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isprint_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isprint) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _BLANK|_PUNCT|_ALPHA|_DIGIT);
    }
    else
    {
        return (_isprint_l)(c, NULL);
    }
}

extern __inline int (__cdecl _isgraph_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _isgraph_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl isgraph) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _PUNCT|_ALPHA|_DIGIT);
    }
    else
    {
        return (_isgraph_l)(c, NULL);
    }
}

extern __inline int (__cdecl _iscntrl_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return _iscntrl_l(c, _loc_update.GetLocaleT());
}

extern __inline int (__cdecl iscntrl) (
        int c
        )
{
    if (__locale_changed == 0)
    {
        return __fast_ch_check(c, _CONTROL);
    }
    else
    {
        return (_iscntrl_l)(c, NULL);
    }
}

extern __inline int (__cdecl __isascii) (
        int c
        )
{
    return __isascii(c);
}

extern __inline int (__cdecl __toascii) (
        int c
        )
{
    return __toascii(c);
}

extern __inline int (__cdecl _iscsymf_l) (
        int c,
        _locale_t plocinfo
        )
{
        return (_isalpha_l)(c, plocinfo) || (c) == '_';
}
extern __inline int (__cdecl __iscsymf) (
        int c
        )
{
    return __iscsymf(c);
}

extern __inline int (__cdecl _iscsym_l) (
        int c,
        _locale_t plocinfo
        )
{
    return (_isalnum_l)(c, plocinfo) || (c) == '_';
}

extern __inline int (__cdecl __iscsym) (
        int c
        )
{
    return __iscsym((unsigned char)(c));
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#include <crtdefs.h>

#pragma pack(push,_CRT_PACKING)

#define _CPPLIB_VER	520

#define _ALLOW_KEYWORD_MACROS	// TRANSITION
#ifndef _ALLOW_KEYWORD_MACROS
 #include <xkeycheck.h>
#endif /* _ALLOW_KEYWORD_MACROS */

#ifndef _HAS_CPP0X
 #define _HAS_CPP0X     1
#endif

#define _HAS_TR1	1	/* enable TR1 extensions */

/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.
 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate
 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Checked Iterators".
*/

#if defined(MRTDLL)
/*
process-global is the default for code built with /clr or /clr:oldSyntax.
appdomain-global is the default for code built with /clr:pure.
Code in MSVCM is built with /clr, but is used by user code built with /clr:pure
so it must conform to the expectations of /clr:pure clients.
Use __PURE_APPDOMAIN_GLOBAL when a global needs to be appdomain-global for pure
clients and process-global for mixed clients.
*/
#define __PURE_APPDOMAIN_GLOBAL   __declspec(appdomain)
#else
#define __PURE_APPDOMAIN_GLOBAL
#endif

#ifndef __CRTDECL
#if defined(_M_CEE_PURE) || defined(MRTDLL)
#define __CRTDECL   __clrcall
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef __CLR_OR_THIS_CALL
#if defined(MRTDLL) || defined(_M_CEE_PURE)
#define __CLR_OR_THIS_CALL  __clrcall
#else
#define __CLR_OR_THIS_CALL
#endif
#endif

#ifndef __CLRCALL_OR_CDECL
#if defined(MRTDLL) || defined(_M_CEE_PURE)
#define __CLRCALL_OR_CDECL __clrcall
#else
#define __CLRCALL_OR_CDECL __cdecl
#endif
#endif

#ifndef __CLRCALL_PURE_OR_CDECL
#if defined(_M_CEE_PURE)
#define __CLRCALL_PURE_OR_CDECL __clrcall
#else
#define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
#endif

		/* CURRENT DLL NAMES */
#ifndef _CRT_MSVCP_CURRENT
#ifdef _DEBUG
#define _CRT_MSVCP_CURRENT "MSVCP100D.dll"
#else
#define _CRT_MSVCP_CURRENT "MSVCP100.dll"
#endif
#endif

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	1	/* nontrivial locks if multithreaded */
#define _IOSTREAM_OP_LOCKS	1	/* lock iostream operations */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */

 #else /* _MULTI_THREAD */
  #define _TLS_QUAL
 #endif /* _MULTI_THREAD */

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif /* _HAS_EXCEPTIONS */

#ifndef _HAS_STRICT_CONFORMANCE
 #define _HAS_STRICT_CONFORMANCE 0
#endif /* _HAS_STRICT_CONFORMANCE */

 #ifndef _HAS_TR1_IMPORTS
  #define _HAS_TR1_IMPORTS	_HAS_CPP0X
 #endif

#define _GLOBAL_USING	1


#ifdef _ITERATOR_DEBUG_LEVEL /* A. _ITERATOR_DEBUG_LEVEL is already defined. */

	/* A1. Validate _ITERATOR_DEBUG_LEVEL. */
	#if _ITERATOR_DEBUG_LEVEL > 2 && defined(_DEBUG)
		#error _ITERATOR_DEBUG_LEVEL > 2 is not supported in debug mode.
	#elif _ITERATOR_DEBUG_LEVEL > 1 && !defined(_DEBUG)
		#error _ITERATOR_DEBUG_LEVEL > 1 is not supported in release mode.
	#endif

	/* A2. Inspect _HAS_ITERATOR_DEBUGGING. */
	#ifdef _HAS_ITERATOR_DEBUGGING /* A2i. _HAS_ITERATOR_DEBUGGING is already defined, validate it. */
		#if _ITERATOR_DEBUG_LEVEL == 2 && _HAS_ITERATOR_DEBUGGING != 1
			#error _ITERATOR_DEBUG_LEVEL == 2 must imply _HAS_ITERATOR_DEBUGGING == 1 .
		#elif _ITERATOR_DEBUG_LEVEL < 2 && _HAS_ITERATOR_DEBUGGING != 0
			#error _ITERATOR_DEBUG_LEVEL < 2 must imply _HAS_ITERATOR_DEBUGGING == 0 .
		#endif
	#else /* A2ii. _HAS_ITERATOR_DEBUGGING is not yet defined, derive it. */
		#if _ITERATOR_DEBUG_LEVEL == 2
			#define _HAS_ITERATOR_DEBUGGING 1
		#else
			#define _HAS_ITERATOR_DEBUGGING 0
		#endif
	#endif /* _HAS_ITERATOR_DEBUGGING */

	/* A3. Inspect _SECURE_SCL. */
	#ifdef _SECURE_SCL /* A3i. _SECURE_SCL is already defined, validate it. */
		#if _ITERATOR_DEBUG_LEVEL > 0 && _SECURE_SCL != 1
			#error _ITERATOR_DEBUG_LEVEL > 0 must imply _SECURE_SCL == 1 .
		#elif _ITERATOR_DEBUG_LEVEL == 0 && _SECURE_SCL != 0
			#error _ITERATOR_DEBUG_LEVEL == 0 must imply _SECURE_SCL == 0 .
		#endif
	#else /* A3ii. _SECURE_SCL is not yet defined, derive it. */
		#if _ITERATOR_DEBUG_LEVEL > 0
			#define _SECURE_SCL 1
		#else
			#define _SECURE_SCL 0
		#endif
	#endif /* _SECURE_SCL */

#else /* B. _ITERATOR_DEBUG_LEVEL is not yet defined. */

	/* B1. Inspect _HAS_ITERATOR_DEBUGGING. */
	#ifdef _HAS_ITERATOR_DEBUGGING /* B1i. _HAS_ITERATOR_DEBUGGING is already defined, validate it. */
		#if _HAS_ITERATOR_DEBUGGING > 1
			#error _HAS_ITERATOR_DEBUGGING must be either 0 or 1 .
		#elif _HAS_ITERATOR_DEBUGGING == 1 && !defined(_DEBUG)
			#error _HAS_ITERATOR_DEBUGGING == 1 is not supported in release mode.
		#endif
	#else /* B1ii. _HAS_ITERATOR_DEBUGGING is not yet defined, default it. */
		#ifdef _DEBUG
			#define _HAS_ITERATOR_DEBUGGING 1
		#else
			#define _HAS_ITERATOR_DEBUGGING 0
		#endif
	#endif /* _HAS_ITERATOR_DEBUGGING */

	/* B2. Inspect _SECURE_SCL. */
	#ifdef _SECURE_SCL /* B2i. _SECURE_SCL is already defined, validate it. */
		#if _SECURE_SCL > 1
			#error _SECURE_SCL must be either 0 or 1 .
		#endif
	#else /* B2ii. _SECURE_SCL is not yet defined, default it. */
		#if _HAS_ITERATOR_DEBUGGING == 1
			#define _SECURE_SCL 1
		#else
			#define _SECURE_SCL 0
		#endif
	#endif /* _SECURE_SCL */

	/* B3. Derive _ITERATOR_DEBUG_LEVEL. */
	#if _HAS_ITERATOR_DEBUGGING
		#define _ITERATOR_DEBUG_LEVEL 2
	#elif _SECURE_SCL
		#define _ITERATOR_DEBUG_LEVEL 1
	#else
		#define _ITERATOR_DEBUG_LEVEL 0
	#endif

#endif /* _ITERATOR_DEBUG_LEVEL */


#if defined(_CRTBLD) && defined(_DLL)
	#define _ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH
#endif

#ifdef __cplusplus
	#ifndef _ALLOW_MSC_VER_MISMATCH
		#pragma detect_mismatch("_MSC_VER", "1600")
	#endif /* _ALLOW_MSC_VER_MISMATCH */

	#ifndef _ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH
		#if _ITERATOR_DEBUG_LEVEL == 0
		     #pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
		#elif _ITERATOR_DEBUG_LEVEL == 1
		     #pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "1")
		#elif _ITERATOR_DEBUG_LEVEL == 2
		     #pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
		#else
		     #error Unrecognized _ITERATOR_DEBUG_LEVEL value.
		#endif
	#endif /* _ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH */
#endif /* __cplusplus */


/* See note on use of deprecate at the top of this file */
#if !defined(_SCL_SECURE_NO_WARNINGS) && defined(_SCL_SECURE_NO_DEPRECATE)
#define _SCL_SECURE_NO_WARNINGS
#endif

#if !defined (_SECURE_SCL_DEPRECATE)
#if defined(_SCL_SECURE_NO_WARNINGS)
#define _SECURE_SCL_DEPRECATE 0
#else
#define _SECURE_SCL_DEPRECATE 1
#endif
#endif

#if !defined (_SECURE_SCL_THROWS)
#define _SECURE_SCL_THROWS 0
#endif

/* _SECURE_SCL switches: helper macros */
/* See note on use of deprecate at the top of this file */

#if _ITERATOR_DEBUG_LEVEL > 0 && _SECURE_SCL_DEPRECATE
#define _SCL_INSECURE_DEPRECATE \
	_CRT_DEPRECATE_TEXT( \
		"Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " \
		"To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")
#else
#define _SCL_INSECURE_DEPRECATE
#endif


#ifndef _SCL_SECURE_INVALID_PARAMETER
 #define _SCL_SECURE_INVALID_PARAMETER(expr) _CRT_SECURE_INVALID_PARAMETER(expr)
#endif


 #if _SECURE_SCL_THROWS

 #ifndef _SILENCE_DEPRECATION_OF_SECURE_SCL_THROWS
  #include <crtwrn.h>
  #pragma push_macro("_SECURE_SCL_THROWS")
  #undef _SECURE_SCL_THROWS
  #pragma _CRT_WARNING( _DEPRECATE_SECURE_SCL_THROWS )
  #pragma pop_macro("_SECURE_SCL_THROWS")
 #endif /* _SILENCE_DEPRECATION_OF_SECURE_SCL_THROWS */

 #define _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT		_STD _Xinvalid_argument("invalid argument")
 #define _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT			_STD _Xout_of_range("out of range")

 #else /* _SECURE_SCL_THROWS */

 #define _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT		_SCL_SECURE_INVALID_PARAMETER("invalid argument")
 #define _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT			_SCL_SECURE_INVALID_PARAMETER("out of range")

 #endif /* _SECURE_SCL_THROWS */

 #define _SCL_SECURE_ALWAYS_VALIDATE(cond)				\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;		\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_ALWAYS_VALIDATE_RANGE(cond)		\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;			\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_CRT_VALIDATE(cond, retvalue)		\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_INVALID_PARAMETER(cond);		\
			return (retvalue);							\
		}												\
	}

 #if _ITERATOR_DEBUG_LEVEL > 0

 #define _SCL_SECURE_VALIDATE(cond)						\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;		\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_VALIDATE_RANGE(cond)				\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;			\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_INVALID_ARGUMENT					\
	{													\
		_ASSERTE("Standard C++ Libraries Invalid Argument" && 0); \
		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;			\
	}
 #define _SCL_SECURE_OUT_OF_RANGE						\
	{													\
		_ASSERTE("Standard C++ Libraries Out of Range" && 0); \
		_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;				\
	}

 #else /* _ITERATOR_DEBUG_LEVEL > 0 */
 
/* when users disable _SECURE_SCL to get performance, we don't want analysis warnings from SCL headers */
#if _ITERATOR_DEBUG_LEVEL == 2
 #define _SCL_SECURE_VALIDATE(cond)			__analysis_assume(cond)
 #define _SCL_SECURE_VALIDATE_RANGE(cond)	__analysis_assume(cond)
#else
 #define _SCL_SECURE_VALIDATE(cond)
 #define _SCL_SECURE_VALIDATE_RANGE(cond)
#endif

 #define _SCL_SECURE_INVALID_ARGUMENT 
 #define _SCL_SECURE_OUT_OF_RANGE 

 #endif /* _ITERATOR_DEBUG_LEVEL > 0 */

#if __STDC_WANT_SECURE_LIB__
#define _CRT_SECURE_MEMCPY(dest, destsize, source, count) ::memcpy_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_MEMMOVE(dest, destsize, source, count) ::memmove_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_WMEMCPY(dest, destsize, source, count) ::wmemcpy_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_WMEMMOVE(dest, destsize, source, count) ::wmemmove_s((dest), (destsize), (source), (count))
#else
#define _CRT_SECURE_MEMCPY(dest, destsize, source, count) ::memcpy((dest), (source), (count))
#define _CRT_SECURE_MEMMOVE(dest, destsize, source, count) ::memmove((dest), (source), (count))
#define _CRT_SECURE_WMEMCPY(dest, destsize, source, count) ::wmemcpy((dest), (source), (count))
#define _CRT_SECURE_WMEMMOVE(dest, destsize, source, count) ::wmemmove((dest), (source), (count))
#endif

#include <use_ansi.h>

#if defined(_M_CEE) && defined(_STATIC_CPPLIB)
#include <crtwrn.h>
#pragma push_macro("_STATIC_CPPLIB")
#undef _STATIC_CPPLIB
#pragma _CRT_WARNING( _CLR_AND_STATIC_CPPLIB )
#pragma pop_macro("_STATIC_CPPLIB")
#endif

#if defined(_DLL) && defined(_STATIC_CPPLIB) && !defined(_DISABLE_DEPRECATE_STATIC_CPPLIB)
#include <crtwrn.h>
#pragma push_macro("_STATIC_CPPLIB")
#undef _STATIC_CPPLIB
#pragma _CRT_WARNING( _DEPRECATE_STATIC_CPPLIB )
#pragma pop_macro("_STATIC_CPPLIB")
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2
  #ifdef  CRTDLL2
   #define _CRTIMP2	__declspec(dllexport)
  #else   /* ndef CRTDLL2 */

   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)

   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */

  #endif  /* CRTDLL2 */
 #endif  /* _CRTIMP2 */

/* Define _CRTIMP2_NCEEPURE */
 #ifndef _CRTIMP2_NCEEPURE
  #if defined(_M_CEE_PURE)
   #define _CRTIMP2_NCEEPURE
  #else
   #define _CRTIMP2_NCEEPURE _CRTIMP2
  #endif
 #endif

#ifndef _MRTIMP
  #ifdef MRTDLL
    #if !defined(_M_CEE_PURE)
      #define _MRTIMP __declspec(dllexport)
    #else
      #define _MRTIMP   
    #endif
  #else   /* ndef MRTDLL */
    #define _MRTIMP __declspec(dllimport)
  #endif  /* MRTDLL */
#endif  /* _MRTIMP */

/* Define _MRTIMP2 */
 #ifndef _MRTIMP2
  #if   defined(CRTDLL2)
   #define _MRTIMP2	__declspec(dllexport)
  #elif defined(MRTDLL)
    #define _MRTIMP2 _MRTIMP
  #else   /* ndef CRTDLL2 */

   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _MRTIMP2	__declspec(dllimport)

   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _MRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */

  #endif  /* CRTDLL2 */
 #endif  /* _MRTIMP2 */

 #ifndef _MRTIMP2_PURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_PURE
  #else
   #define _MRTIMP2_PURE _MRTIMP2
  #endif
 #endif

 #ifndef _MRTIMP2_PURE_NPURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_PURE_NPURE
  #else
   #define _MRTIMP2_PURE_NPURE _MRTIMP2_NPURE
  #endif
 #endif

/* Define _MRTIMP2_NPURE */
 #ifndef _MRTIMP2_NPURE
  #if   defined(MRTDLL)
    #if !defined(_M_CEE_PURE)
      #define _MRTIMP2_NPURE __declspec(dllexport)
    #else
      #define _MRTIMP2_NPURE
    #endif
  #else   /* ndef MRTDLL */

   #if defined(_DLL) && defined(_M_CEE_PURE)
    #define _MRTIMP2_NPURE	__declspec(dllimport)

   #else
    #define _MRTIMP2_NPURE
   #endif

  #endif  /* MRTDLL */
 #endif  /* _MRTIMP2_NPURE */

/* Define _MRTIMP2_NCEE */
 #ifndef _MRTIMP2_NCEE
  #if defined(_M_CEE)
   #define _MRTIMP2_NCEE
  #else
   #define _MRTIMP2_NCEE _MRTIMP2
  #endif
 #endif

/* Define _MRTIMP2_NCEEPURE */
 #ifndef _MRTIMP2_NCEEPURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_NCEEPURE
  #else
   #define _MRTIMP2_NCEEPURE _MRTIMP2
  #endif
 #endif

/* Define _MRTIMP2_NPURE_NCEEPURE */
 #ifndef _MRTIMP2_NPURE_NCEEPURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_NPURE_NCEEPURE
  #else
   #define _MRTIMP2_NPURE_NCEEPURE _MRTIMP2_NPURE
  #endif
 #endif

 #if defined(_DLL) && !defined(_STATIC_CPPLIB) && !defined(_M_CEE_PURE)
  #define _DLL_CPPLIB
 #endif

 #ifndef _CRTIMP2_PURE
  #if   defined(MRTDLL)
   #define _CRTIMP2_PURE
  #else
   #ifdef  _M_CEE_PURE
     #define _CRTIMP2_PURE
   #else
     #define _CRTIMP2_PURE _CRTIMP2
   #endif
  #endif
 #endif

#if !defined(_CRTDATA2)
  #if !defined(MRTDLL)
    #define _CRTDATA2 _CRTIMP2
  #else
    #define _CRTDATA2    
  #endif
#endif

  #ifndef _INTERNAL_IFSTRIP_
/* Define _CRTBLD_NATIVE_WCHAR_T */

   #if defined(_CRTBLD) && defined(__cplusplus)
    #ifndef _NATIVE_WCHAR_T_DEFINED
     #error Native wchar_t must be defined

    #else /* _NATIVE_WCHAR_T_DEFINED */
     #define _CRTBLD_NATIVE_WCHAR_T
    #endif /* _NATIVE_WCHAR_T_DEFINED */

   #endif /* defined(_CRTBLD) && defined(__cplusplus) */
  #endif /* _INTERNAL_IFSTRIP_ */

  #ifndef _INTERNAL_IFSTRIP_
/* These functions are for enabling STATIC_CPPLIB functionality */
   #define _cpp_stdin  (&(__iob_func())[0])
   #define _cpp_stdout (&(__iob_func())[1])
   #define _cpp_stderr (&(__iob_func())[2])
   #define _cpp_isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
  #endif

		/* NAMESPACE */

 #if defined(__cplusplus)
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}
  #define _STD	::std::

/*
We use the stdext (standard extension) namespace to contain extensions that are not part of the current standard
*/
  #define _STDEXT_BEGIN	    namespace stdext {
  #define _STDEXT_END		}
  #define _STDEXT	        ::stdext::

  #ifdef _STD_USING
   #define _C_STD_BEGIN	namespace std {	/* only if *.c compiled as C++ */
   #define _C_STD_END	}
   #define _CSTD	::std::

  #else /* _STD_USING */
/* #define _GLOBAL_USING	*.h in global namespace, c* imports to std */

   #define _C_STD_BEGIN
   #define _C_STD_END
   #define _CSTD	::
  #endif /* _STD_USING */

  #define _C_LIB_DECL		extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL	}
  #define _EXTERN_C			extern "C" {
  #define _END_EXTERN_C		}

 #else /* __cplusplus */
  #define _STD_BEGIN
  #define _STD_END
  #define _STD

  #define _C_STD_BEGIN
  #define _C_STD_END
  #define _CSTD

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

#ifndef _HAS_CHAR16_T_LANGUAGE_SUPPORT
 #define _HAS_CHAR16_T_LANGUAGE_SUPPORT 0
#endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */

		/* uchar PROPERTIES */
 #if _HAS_CHAR16_T_LANGUAGE_SUPPORT
 #else /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */
 #if !defined(_CHAR16T)
  #define _CHAR16T
typedef unsigned short char16_t;
typedef unsigned int char32_t;
 #endif /* !defined(_CHAR16T) */

 #endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _LOCK_DEBUG		3
#define _MAX_LOCK		4	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
enum _Uninitialized
	{	// tag for suppressing initialization
	_Noinit
	};

		// CLASS _Lockit
// warning 4412 is benign here
#pragma warning(push)
#pragma warning(disable:4412)
class _CRTIMP2_PURE _Lockit
	{	// lock while object in existence -- MUST NEST
public:
 #if _MULTI_THREAD

  #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Lockit()
        : _Locktype(0)
	    {	// default construct
        _Lockit_ctor(this);
	    }

	explicit __CLR_OR_THIS_CALL _Lockit(int _Kind)
	    {	// set the lock
        _Lockit_ctor(this, _Kind);
	    }

	__CLR_OR_THIS_CALL ~_Lockit()
	    {	// clear the lock
        _Lockit_dtor(this);
	    }

  #else /* defined(_M_CEE_PURE) || defined(MRTDLL) */
	__thiscall _Lockit();	// default construct
	explicit __thiscall _Lockit(int);	// set the lock
	__thiscall ~_Lockit();	// clear the lock
  #endif /* defined(_M_CEE_PURE) || defined(MRTDLL) */

    static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(int);
    static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(int);

private:
    static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *);
    static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *, int);
    static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(_Lockit *);

	__CLR_OR_THIS_CALL _Lockit(const _Lockit&);				// not defined
	_Lockit& __CLR_OR_THIS_CALL operator=(const _Lockit&);	// not defined

	int _Locktype;

  #else /* _MULTI_THREAD */
	_Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

 #ifdef _M_CEE
class _CRTIMP2_PURE _EmptyLockit
	{	// empty lock class used for bin compat
public:
  #if _MULTI_THREAD
private:
	int _Locktype;
  #endif /* _MULTI_THREAD */
	};

  #if defined(__cplusplus_cli)
   #define _M_CEE_FINALLY finally
  #else /* defined(__cplusplus_cli) */
   #define _M_CEE_FINALLY __finally
  #endif /* defined(__cplusplus_cli) */

  #define _BEGIN_LOCK(_Kind) \
	{ \
		typedef int _TmpTestType; \
		__if_exists(_TmpTestType::ToString) \
		{ \
		bool _MustReleaseLock = false; \
		int _LockKind = _Kind; \
		System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
		try \
		} \
		{ \
			__if_exists(_TmpTestType::ToString) \
			{ \
			System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
			try { } _M_CEE_FINALLY \
			{ \
				_STD _Lockit::_Lockit_ctor(_LockKind); \
				_MustReleaseLock = true; \
			} \
			} \
			__if_not_exists(_TmpTestType::ToString) \
			{ \
			_STD _Lockit _Lock(_Kind); \
			}

  #define _END_LOCK() \
		} \
		__if_exists(_TmpTestType::ToString) \
		{ \
		_M_CEE_FINALLY \
		{ \
			if (_MustReleaseLock) \
			{ \
				_STD _Lockit::_Lockit_dtor(_LockKind); \
			} \
		} \
		} \
	}

  #define _BEGIN_LOCINFO(_VarName) \
	_BEGIN_LOCK(_LOCK_LOCALE) \
	_Locinfo _VarName;

  #define _END_LOCINFO() \
	_END_LOCK() \

  #define _RELIABILITY_CONTRACT \
	[System::Runtime::ConstrainedExecution::ReliabilityContract( \
		System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState, \
		System::Runtime::ConstrainedExecution::Cer::Success)]

 #else /* _M_CEE */
  #define _BEGIN_LOCK(_Kind) \
	{ \
		_STD _Lockit _Lock(_Kind);

  #define _END_LOCK() \
	}

  #define _BEGIN_LOCINFO(_VarName) \
	{ \
		_Locinfo _VarName;

  #define _END_LOCINFO() \
	}

  #define _RELIABILITY_CONTRACT
 #endif /* _M_CEE */

class _CRTIMP2_PURE _Mutex
	{	// lock under program control
public:

 #if _MULTI_THREAD
  #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Mutex(_Uninitialized)
	    {	// do nothing
	    }

	__CLR_OR_THIS_CALL _Mutex()
	    {	// default construct
        _Mutex_ctor(this);
	    }

	__CLR_OR_THIS_CALL ~_Mutex()
	    {	// destroy the object
        _Mutex_dtor(this);
	    }

	void __CLR_OR_THIS_CALL _Lock()
	    {	// lock the mutex
        _Mutex_Lock(this);
	    }

	void __CLR_OR_THIS_CALL _Unlock()
	    {	// unlock the mutex
        _Mutex_Unlock(this);
	    }

  #else /* defined(_M_CEE_PURE) || defined(MRTDLL) */
    __thiscall _Mutex(_Uninitialized)
		{	// do nothing
		}

    __thiscall _Mutex();
	__thiscall ~_Mutex();
	void __thiscall _Lock();
	void __thiscall _Unlock();
  #endif /* defined(_M_CEE_PURE) || defined(MRTDLL) */

private:
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_ctor(_Mutex *);
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_dtor(_Mutex *);
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_Lock(_Mutex *);
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_Unlock(_Mutex *);

	__CLR_OR_THIS_CALL _Mutex(const _Mutex&);				// not defined
	_Mutex& __CLR_OR_THIS_CALL operator=(const _Mutex&);	// not defined
	void *_Mtx;

  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _CRTIMP2_PURE _Init_locks
	{	// initialize mutexes
public:
 #if _MULTI_THREAD
      #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Init_locks()
	    {	// default construct
        _Init_locks_ctor(this);
	    }

	__CLR_OR_THIS_CALL ~_Init_locks()
	    {	// destroy the object
        _Init_locks_dtor(this);
	    }

  #else /* defined(_M_CEE_PURE) || defined(MRTDLL) */
    __thiscall _Init_locks();
	__thiscall ~_Init_locks();
  #endif /* defined(_M_CEE_PURE) || defined(MRTDLL) */

private:
    static _MRTIMP2_NPURE void __cdecl _Init_locks_ctor(_Init_locks *);
    static _MRTIMP2_NPURE void __cdecl _Init_locks_dtor(_Init_locks *);

 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */
	};

#pragma warning(pop)
_STD_END
 #endif /* __cplusplus */

#ifndef _RELIABILITY_CONTRACT
 #define _RELIABILITY_CONTRACT
#endif /* _RELIABILITY_CONTRACT */

		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_MRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;
typedef unsigned long _Uint32t;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

 #define _THROW_BAD_ALLOC	_THROW1(...)

 #pragma pack(pop)

#endif /* _YVALS */


/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.20:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#ifndef RC_INVOKED
#include <yvals.h>
_C_STD_BEGIN
#ifndef MRTDLL
 #ifndef _M_CEE_PURE
_C_LIB_DECL
 #endif /* _M_CEE_PURE */

#endif /* MRTDLL */

#pragma pack(push, _CRT_PACKING)

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT	0x20
#define _FE_INVALID	0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __CLRCALL_PURE_OR_CDECL _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Cosh(double, double);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dtest(double *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Exp(double *, double, short);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Sinh(double, double);
extern _CRTIMP2_PURE /* const */ _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FCosh(float, float);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDtest(float *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FExp(float *, float, short);
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FSinh(float, float);
extern _CRTIMP2_PURE /* const */ _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LCosh(long double, long double);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDtest(long double *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LExp(long double *, long double, short);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LSinh(long double, long double);
extern _CRTIMP2_PURE /* const */ _Dconst _LDenorm, _LInf, _LNan, _LSnan;

#ifndef MRTDLL
 #ifndef _M_CEE_PURE
_END_C_LIB_DECL
 #endif /* _M_CEE_PURE */

#endif /* MRTDLL */

#pragma pack(pop)
_C_STD_END
#endif /* RC_INVOKED */
#endif /* _YMATH */

/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.20:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_file.c ===
/***
*_file.c - Definition of _iob[], initializer and terminator.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _iob[], the array of stdio control structures, the initializer
*       and terminator routines, and the multithread locking for stdio.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <rterr.h>
#include <dbgint.h>
#include <mtdll.h>

/*
 * Buffer for stdin.
 */

char _bufin[_INTERNAL_BUFSIZ];

/*
 * FILE descriptors; preset for stdin/out/err (note that the __tmpnum field
 * is not initialized)
 */
FILE _iob[_IOB_ENTRIES] = {
        /* _ptr, _cnt, _base,  _flag, _file, _charbuf, _bufsiz */

        /* stdin (_iob[0]) */

        { _bufin, 0, _bufin, _IOREAD | _IOYOURBUF, 0, 0, _INTERNAL_BUFSIZ },

        /* stdout (_iob[1]) */

        { NULL, 0, NULL, _IOWRT, 1, 0, 0 },

        /* stderr (_iob[3]) */

        { NULL, 0, NULL, _IOWRT, 2, 0, 0 },

};


/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP FILE * __cdecl __iob_func(void)
{
    return _iob;
}


/*
 * Pointer to array of FILE * or _FILEX * structures.
 */
void ** __piob;

/*
 * Number of open streams (set to _NSTREAM by default)
 */
#ifdef CRTDLL
int _nstream = _NSTREAM_;
#else  /* CRTDLL */
int _nstream;
#endif  /* CRTDLL */


/*
 * Initializer and terminator for stdio
 */
int  __cdecl __initstdio(void);
void __cdecl __endstdio(void);

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __initstdio;

_CRTALLOC(".CRT$XPXA") static _PVFV pterm = __endstdio;

#ifndef CRTDLL
/*
 * _cflush is a dummy variable used to pull in _endstdio() when any STDIO
 * routine is included in the user program.
 */
int _cflush = 0;
#endif  /* CRTDLL */


/***
* __initstdio - Initialize the stdio system
*
*Purpose:
*       Create and initialize the __piob array.
*
*Entry: <void>
*
*Exit:  Returns _RT_STDIOINIT if error encountered.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __initstdio(void)
{
        int i;

#ifndef CRTDLL
        /*
         * If the user has not supplied a definition of _nstream, set it
         * to _NSTREAM_. If the user has supplied a value that is too small
         * set _nstream to the minimum acceptable value (_IOB_ENTRIES).
         */
        if ( _nstream ==  0 )
            _nstream = _NSTREAM_;
        else if ( _nstream < _IOB_ENTRIES )
            _nstream = _IOB_ENTRIES;
#endif  /* CRTDLL */

        /*
         * Allocate the __piob array. Try for _nstream entries first. If this
         * fails then reset _nstream to _IOB_ENTRIES and try again. If it
         * still fails, bail out with an RTE.
         */
        if ( (__piob = (void **)_calloc_crt( _nstream, sizeof(void *) )) ==
             NULL ) {
            _nstream = _IOB_ENTRIES;
            if ( (__piob = (void **)_calloc_crt( _nstream, sizeof(void *) ))
                 == NULL )
                return _RT_STDIOINIT;
        }

        /*
         * Initialize the first _IOB_ENTRIES to point to the corresponding
         * entries in _iob[].
         */
        for ( i = 0 ; i < _IOB_ENTRIES ; i++ )
            __piob[i] = (void *)&_iob[i];

        for ( i = 0 ; i < 3 ; i++ ) {
            if ( (_osfhnd(i) == (intptr_t)INVALID_HANDLE_VALUE) ||
                 (_osfhnd(i) == _NO_CONSOLE_FILENO) ||
                 (_osfhnd(i) == 0) )
            {
            /*
             * For stdin, stdout & stderr, we use _NO_CONSOLE_FILENO (a value
             * different from _INVALID_HANDLE_VALUE to distinguish between
             * a failure in opening a file & a program run without a console.
             */
                _iob[i]._file = _NO_CONSOLE_FILENO;
            }
        }

        return 0;
}


/***
* __endstdio - Terminate the stdio system
*
*Purpose:
*       Terminate the stdio system
*
*       (1) Flush all streams.  (Do this even if we're going to
*       call fcloseall since that routine won't do anything to the
*       std streams.)
*
*       (2) If returning to caller, close all streams.  This is
*       not necessary if the exe is terminating because the OS will
*       close the files for us (much more efficiently, too).
*
*Entry: <void>
*
*Exit:  <void>
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __endstdio(void)
{
        /* flush all streams */
        _flushall();

        /* if in callable exit, close all streams */
        if (_exitflag)
                _fcloseall();
        _free_crt(__piob);
}


/***
* _lock_file - Lock a FILE
*
*Purpose:
*       Assert the lock for a stdio-level file
*
*Entry:
*       pf = __piob[] entry (pointer to a FILE or _FILEX)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock_file (
        FILE *pf
        )
{
        /*
         * The way the FILE (pointed to by pf) is locked depends on whether
         * it is part of _iob[] or not
         */
        if ( (pf >= _iob) && (pf <= (&_iob[_IOB_ENTRIES-1])) )
        {
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _lock( _STREAM_LOCKS + (int)(pf - _iob) );
            /* We set _IOLOCKED to indicate we locked the stream */
            pf->_flag |= _IOLOCKED;
        }
        else
            /*
             * Not part of _iob[]. Therefore, *pf is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            EnterCriticalSection( &(((_FILEX *)pf)->lock) );
}


/***
* _lock_file2(i, s) - Lock the FILE
*
*Purpose:
*       Assert the lock for a stdio-level file given by s == __piob[i].
*
*Entry:
*       s == __piob[i]
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock_file2 (
        int i,
        void *s
        )
{
        /*
         * The way the FILE is locked depends on whether it is part of _iob[]
         * _iob[] or not
         */
        if ( i < _IOB_ENTRIES )
        {
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _lock( _STREAM_LOCKS + i );
            /* We set _IOLOCKED to indicate we locked the stream */
            ((FILE*)s)->_flag |= _IOLOCKED;
        }
        else
            /*
             * Not part of _iob[]. Therefore, *s is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            EnterCriticalSection( &(((_FILEX *)s)->lock) );
}


/***
* _unlock_file - Unlock a FILE
*
*Purpose:
*       Release the lock for a stdio-level file
*
*Entry:
*       pf = __piob[] entry (pointer to a FILE or _FILEX)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_file (
        FILE *pf
        )
{
        /*
         * The way the FILE (pointed to by pf) is unlocked depends on whether
         * it is part of _iob[] or not
         */
        if ( (pf >= _iob) && (pf <= (&_iob[_IOB_ENTRIES-1])) )
        {
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             * We reset _IOLOCKED to indicate we unlock the stream.
             */
             pf->_flag &= ~_IOLOCKED;
            _unlock( _STREAM_LOCKS + (int)(pf - _iob) );
        }
        else
            /*
             * Not part of _iob[]. Therefore, *pf is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            LeaveCriticalSection( &(((_FILEX *)pf)->lock) );
}


/***
* _unlock_file2(i, s) - Lock the FILE
*
*Purpose:
*       Release the lock for a stdio-level file given by s == __piob[i].
*
*Entry:
*       s == __piob[i]
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_file2 (
        int i,
        void *s
        )
{
        /*
         * The way the FILE is locked depends on whether it is part of _iob[]
         * _iob[] or not
         */
        if ( i < _IOB_ENTRIES )
        {
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             * We reset _IOLOCKED to indicate we unlock the stream.
             */
             ((FILE*)s)->_flag &= ~_IOLOCKED;
            _unlock( _STREAM_LOCKS + i );
        }
        else
            /*
             * Not part of _iob[]. Therefore, *s is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            LeaveCriticalSection( &(((_FILEX *)s)->lock) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_flswbuf.c ===
/***
*_flswbuf.c - flush buffer and output wide character.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _flswbuf() - flush a file buffer and output a wide character.
*       If no buffer, make one.
*
*******************************************************************************/



#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "_flsbuf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_filwbuf.c ===
/***
*_filwbuf.c - fill buffer and get wide character
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _filwbuf() - fill buffer and read first character, allocate
*       buffer if there is none.  Used from getwc().
*
*******************************************************************************/



#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "_filbuf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_flsbuf.c ===
/***
*_flsbuf.c - flush buffer and output character.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _flsbuf() - flush a file buffer and output a character.
*       defines _flswbuf() - flush a file buffer and output a wide character.
*       If no buffer, make one.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <malloc.h>
#include <msdos.h>
#include <wchar.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

#ifndef _UNICODE

/***
*int _flsbuf(ch, stream) - flush buffer and output character.
*
*Purpose:
*       flush a buffer if this stream has one. if not, try to get one. put the
*       next output char (ch) into the buffer (or output it immediately if this
*       stream can't have a buffer). called only from putc. intended for use
*       only within library.
*
*       [NOTE: Multi-thread - It is assumed that the caller has aquired
*       the stream lock.]
*
*Entry:
*       FILE *stream - stream to flish and write on
*       int ch - character to output.
*
*Exit:
*       returns -1 if FILE is actually a string, or if can't write ch to
*       unbuffered file, or if we flush a buffer but the number of chars
*       written doesn't agree with buffer size.  Otherwise returns ch.
*       all fields in FILE struct can be affected except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flsbuf (
        int ch,
        FILE *str
        )

#else  /* _UNICODE */

/***
*int _flswbuf(ch, stream) - flush buffer and output wide character.
*
*Purpose:
*       flush a buffer if this stream has one. if not, try to get one. put the
*       next output wide char (ch) into the buffer (or output it immediately if this
*       stream can't have a buffer). called only from putwc. intended for use
*       only within library.
*
*       [NOTE: Multi-thread - It is assumed that the caller has aquired
*       the stream lock.]
*
*Entry:
*       FILE *stream - stream to flish and write on
*       int ch - wide character to output.
*
*Exit:
*       returns -1 if FILE is actually a string, or if can't write ch to
*       unbuffered file, or if we flush a buffer but the number of wide chars
*       written doesn't agree with buffer size.  Otherwise returns ch.
*       all fields in FILE struct can be affected except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flswbuf (
        int ch,
        FILE *str
        )

#endif  /* _UNICODE */

{

        REG1 FILE *stream;
        REG2 int charcount;
        REG3 int written;
        int fh;

        _ASSERTE(str != NULL);

        /* Init file handle and pointers */
        stream = str;
        fh = _fileno(stream);

        if (!(stream->_flag & (_IOWRT|_IORW))) {
                errno = EBADF;
                stream->_flag |= _IOERR;
                return(_TEOF);
        } else if ((stream->_flag & _IOSTRG)) {
                errno = ERANGE;
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

        /* Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note
           that _IOREAD and IOEOF both being set implies switching from read to
           write at end-of-file, which is allowed by ANSI. Note that resetting
           the _cnt and _ptr fields amounts to doing an fflush() on the stream
           in this case. Note also that the _cnt field has to be reset to 0 for
           the error path as well (i.e., _IOREAD set but _IOEOF not set) as
           well as the non-error path. */

        if (stream->_flag & _IOREAD) {
                stream->_cnt = 0;
                if (stream->_flag & _IOEOF) {
                        stream->_ptr = stream->_base;
                        stream->_flag &= ~_IOREAD;
                }
                else {
                        stream->_flag |= _IOERR;
                        return(_TEOF);
                }
        }

        stream->_flag |= _IOWRT;
        stream->_flag &= ~_IOEOF;
        written = charcount = stream->_cnt = 0;

        /* Get a buffer for this stream, if necessary. */
        if (!anybuf(stream)) {

                /* Do NOT get a buffer if (1) stream is stdout/stderr, and
                   (2) stream is NOT a tty.
                   [If stdout/stderr is a tty, we do NOT set up single char
                   buffering. This is so that later temporary buffering will
                   not be thwarted by the _IONBF bit being set (see
                   _stbuf/_ftbuf usage).]
                */
                if (!( ((stream==stdout) || (stream==stderr))
                && (_isatty(fh)) ))

                        _getbuf(stream);

        } /* end !anybuf() */

        /* If big buffer is assigned to stream... */
        if (bigbuf(stream)) {

                _ASSERTE(("inconsistent IOB fields", stream->_ptr - stream->_base >= 0));

                charcount = (int)(stream->_ptr - stream->_base);
                stream->_ptr = stream->_base + sizeof(TCHAR);
                stream->_cnt = stream->_bufsiz - (int)sizeof(TCHAR);

                if (charcount > 0)
                        written = _write(fh, stream->_base, charcount);
                else
                        if (_osfile_safe(fh) & FAPPEND)
                                                {
                                                        if( _lseeki64(fh,0L,SEEK_END)==-1)
                                                        {
                                                                stream->_flag |= _IOERR;
                                                                return(_TEOF);
                                                        }
                                                }

#ifndef _UNICODE
                *stream->_base = (char)ch;
#else  /* _UNICODE */
                *(wchar_t *)(stream->_base) = (wchar_t)(ch & 0xffff);
#endif  /* _UNICODE */
        }

    /* Perform single character output (either _IONBF or no buffering) */
        else {
                charcount = sizeof(TCHAR);
#ifndef _UNICODE
                written = _write(fh, &ch, charcount);
#else  /* _UNICODE */
                {
                        char mbc[4];

                        *(wchar_t *)mbc = (wchar_t)(ch & 0xffff);
                        written = _write(fh, mbc, charcount);
                }
#endif  /* _UNICODE */
        }

        /* See if the _write() was successful. */
        if (written != charcount) {
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

#ifndef _UNICODE
        return(ch & 0xff);
#else  /* _UNICODE */
        return(ch & 0xffff);
#endif  /* _UNICODE */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_freebuf.c ===
/***
*_freebuf.c - release a buffer from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _freebuf() - release a buffer from a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <stdlib.h>

/***
*void _freebuf(stream) - release a buffer from a stream
*
*Purpose:
*       free a buffer if at all possible. free() the space if malloc'd by me.
*       forget about trying to free a user's buffer for him; it may be static
*       memory (not from malloc), so he has to take care of it. this function
*       is not intended for use outside the library.
*
*       Multi-thread notes:
*       _freebuf() does NOT get the stream lock; it is assumed that the
*       caller has already done this.
*
*Entry:
*       FILE *stream - stream to free bufer on
*
*Exit:
*       Buffer may be freed.
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _freebuf (
        REG1 FILE *stream
        )
{
        _ASSERTE(stream != NULL);

        if (inuse(stream) && mbuf(stream))
        {
                _free_crt(stream->_base);

                stream->_flag &= ~(_IOMYBUF | _IOSETVBUF);
                stream->_base = stream->_ptr = NULL;
                stream->_cnt = 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_fptostr.c ===
/***
*_fptostr.c - workhorse routine for converting floating point to string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Workhorse routine for fcvt, ecvt.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <stddef.h>
#include <fltintrn.h>
#include <internal.h>

/***
*errno_t _fptostr(buf, size, digits, pflt) - workhorse floating point conversion
*
*Purpose:
*       This is the workhorse routine for fcvt, ecvt. Here is where
*       all the digits are put into a buffer and the rounding is
*       performed and indicators of the decimal point position are set. Note,
*       this must not change the mantissa field of pflt since routines which
*       use this routine rely on this being unchanged.
*
*Entry:
*       char *buf - the buffer in which the digits are to be put
*       int digits - the number of digits which are to go into the buffer
*       STRFLT pflt - a pointer to a structure containing information on the
*               floating point value, including a string containing the
*               non-zero significant digits of the mantissa.
*
*Exit:
*       Changes the contents of the buffer and also may increment the decpt
*       field of the structure pointer to by the 'pflt' parameter if overflow
*       occurs during rounding (e.g. 9.999999... gets rounded to 10.000...).
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

errno_t __cdecl _fptostr (
        char *buf,
        size_t sizeInBytes,
        REG4 int digits,
        REG3 STRFLT pflt
        )
{
        REG1 char *pbuf = buf;
        REG2 char *mantissa = pflt->mantissa;

        /* validation section */
        _VALIDATE_RETURN_ERRCODE(buf != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInBytes > 0, EINVAL);
        buf[0] = '\0';
        /* the buffer will contains ndec decimal digits plus an optional
         * overflow digit for the rounding
         */
        _VALIDATE_RETURN_ERRCODE(sizeInBytes > (size_t)((digits > 0 ? digits : 0) + 1), ERANGE);
        _VALIDATE_RETURN_ERRCODE(pflt != NULL, EINVAL);

        /* initialize the first digit in the buffer to '0' (NOTE - NOT '\0')
         * and set the pointer to the second digit of the buffer.  The first
         * digit is used to handle overflow on rounding (e.g. 9.9999...
         * becomes 10.000...) which requires a carry into the first digit.
         */

        *pbuf++ = '0';

        /* Copy the digits of the value into the buffer (with 0 padding)
         * and insert the terminating null character.
         */

        while (digits > 0) {
                *pbuf++ = (*mantissa) ? *mantissa++ : (char)'0';
                digits--;
        }
        *pbuf = '\0';

        /* do any rounding which may be needed.  Note - if digits < 0 don't
         * do any rounding since in this case, the rounding occurs in  a digit
         * which will not be output beause of the precision requested
         */

        if (digits >= 0 && *mantissa >= '5') {
                pbuf--;
                while (*pbuf == '9')
                        *pbuf-- = '0';
                *pbuf += 1;
        }

        if (*buf == '1') {
                /* the rounding caused overflow into the leading digit (e.g.
                 * 9.999.. went to 10.000...), so increment the decpt position
                 * by 1
                 */
                pflt->decpt++;
        }
        else {
                /* move the entire string to the left one digit to remove the
                 * unused overflow digit.
                 */
                memmove(buf, buf+1, strlen(buf+1)+1);
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_newmode.c ===
/***
*_newmode.c - set new() handler mode to not handle malloc failures
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global flag which controls whether the new() handler
*       is called on malloc failures.  The default behavior in Visual
*       C++ v2.0 and later is not to, that malloc failures return NULL
*       without calling the new handler.  This object is linked in unless
*       the special object NEWMODE.OBJ is manually linked.
*
*       This source file is the complement of LINKOPTS/NEWMODE.C.
*
*******************************************************************************/


#ifdef CRTDLL
#undef CRTDLL
#endif  /* CRTDLL */

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <internal.h>

/* enable new handler calls upon malloc failures */

int _newmode = 0;       /* Malloc New Handler MODE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_getbuf.c ===
/***
*_getbuf.c - Get a stream buffer
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Allocate a buffer and init stream data bases.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <malloc.h>
#include <internal.h>
#include <dbgint.h>

/***
*_getbuf() - Allocate a buffer and init stream data bases
*
*Purpose:
*       Allocates a buffer for a stream and inits the stream data bases.
*
*       [NOTE  1: This routine assumes the caller has already checked to make
*       sure the stream needs a buffer.
*
*       [NOTE 2: Multi-thread - Assumes caller has aquired stream lock, if
*       needed.]
*
*Entry:
*       FILE *stream = stream to allocate a buffer for
*
*Exit:
*       void
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _getbuf (
        FILE *str
        )
{
        REG1 FILE *stream;

        _ASSERTE(str != NULL);

#if !defined (CRTDLL)
        /* force library pre-termination procedure */
        _cflush++;
#endif  /* !defined (CRTDLL) */

        /* Init pointers */
        stream = str;


        /* Try to get a big buffer */
        if (stream->_base = _malloc_crt(_INTERNAL_BUFSIZ))
        {
                /* Got a big buffer */
                stream->_flag |= _IOMYBUF;
                stream->_bufsiz = _INTERNAL_BUFSIZ;
        }

        else {


                /* Did NOT get a buffer - use single char buffering. */
                stream->_flag |= _IONBF;
                stream->_base = (char *)&(stream->_charbuf);
                stream->_bufsiz = 2;

        }

        stream->_ptr = stream->_base;
        stream->_cnt = 0;

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_mbslen.c ===
/***
*_mbslen.c - Return number of multibyte characters in a multibyte string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <locale.h>
#include <dbgint.h>
#include <ctype.h>
#include <mbctype.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*_mbstrlen - Return number of multibyte characters in a multibyte string
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*Entry:
*       char *s = string
*
*Exit:
*       Returns the number of multibyte characters in the string, or
*       Returns (size_t)-1 if the string contains an invalid multibyte character.
*       Also, errno is set to EILSEQ.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

size_t __cdecl _mbstrlen_l(
        const char *s,
        _locale_t plocinfo
        )
{
    size_t n;
    _LocaleUpdate _loc_update(plocinfo);

    _ASSERTE (_loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 || _loc_update.GetLocaleT()->locinfo->mb_cur_max == 2);

    if ( _loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 )
        /* handle single byte character sets */
        return strlen(s);


    /* verify all valid MB chars */
    if ( MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                              MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                              s,
                              -1,
                              NULL,
                              0 ) == 0 )
    {
        /* bad MB char */
        errno = EILSEQ;
        return (size_t)-1;
    }

    /* count MB chars */
    for (n = 0; *s; n++, s++) {
        if ( _isleadbyte_l((unsigned char)*s, _loc_update.GetLocaleT()) )
        {
            if (*++s == '\0')
                break;
        }
    }


    return(n);
}

size_t __cdecl _mbstrlen(
        const char *s
        )
{
    if (__locale_changed == 0)
    {
        return strlen(s);
    }
    else
    {
        return _mbstrlen_l(s, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_mbslen_s.c ===
/***
*_mbslen_s.c - Return number of multibyte characters in a multibyte string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>
#include <locale.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*_mbstrnlen - Return number of multibyte characters in a multibyte string
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*Entry:
*       char *s = string
*       size_t maxsize
*
*Exit:
*       Returns the number of multibyte characters in the string, or
*       (size_t)-1 if the string contains an invalid multibyte character and errno
*       is set to EILSEQ.
*       Only the first sizeInBytes bytes of the string are inspected: if the null
*       terminator is not found, sizeInBytes is returned.
*       If the string is null terminated in sizeInBytes bytes, the return value
*       will always be less than sizeInBytes.
*       If something goes wrong, (size_t)-1 is returned and errno is set to EINVAL.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

size_t __cdecl _mbstrnlen_l(
        const char *s,
        size_t sizeInBytes,
        _locale_t plocinfo
        )
{
    size_t n, size;


    /* validation section */
    _VALIDATE_RETURN(s != NULL, EINVAL, (size_t)-1);
    _VALIDATE_RETURN(sizeInBytes <= INT_MAX, EINVAL, (size_t)-1);


    _LocaleUpdate _loc_update(plocinfo);

    _ASSERTE (_loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 || _loc_update.GetLocaleT()->locinfo->mb_cur_max == 2);

    if ( _loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 )
        /* handle single byte character sets */
        return (int)strnlen(s, sizeInBytes);


    /* verify all valid MB chars */
    if ( MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                              MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                              s,
                              (int)sizeInBytes,
                              NULL,
                              0 ) == 0 )
    {
        /* bad MB char */
        errno = EILSEQ;
        return (size_t)-1;
    }

    /* count MB chars */
    /* Note that sizeInBytes here is the number of bytes, not mb characters! */
    for (n = 0, size = 0; size < sizeInBytes && *s; n++, s++, size++)
    {
        if ( _isleadbyte_l((unsigned char)*s, _loc_update.GetLocaleT()) )
        {
                        size++;
                        if (size >= sizeInBytes)
                        {
                                break;
                        }
            if (*++s == '\0')
                        {
                break;
                        }
        }
    }


        return (size >= sizeInBytes ? sizeInBytes : n);
}

size_t __cdecl _mbstrnlen(
        const char *s,
        size_t maxsize
        )
{
    return _mbstrnlen_l(s, maxsize, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_open.c ===
/***
*_open.c - open a stream, with string mode
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _openfile() - opens a stream, with string arguments for mode
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <file2.h>
#include <share.h>
#include <io.h>
#include <dbgint.h>
#include <internal.h>
#include <tchar.h>
#include <sys\stat.h>

#define CMASK   0644    /* rw-r--r-- */
#define P_CMASK 0666    /* different for Posix */

/***
*FILE *_openfile(filename, mode, shflag, stream) - open a file with string
*       mode and file sharing flag.
*
*Purpose:
*       parse the string, looking for exactly one of {rwa}, at most one '+',
*       at most one of {tb}, at most one of {cn}, at most one of {SR}, at most
*       one 'T', and at most one 'D'. pass the result on as an int containing
*       flags of what was found. open a file with proper mode if permissions
*       allow. buffer not allocated until first i/o call is issued. intended
*       for use inside library only
*
*Entry:
*       char *filename - file to open
*       char *mode - mode to use (see above)
*       int shflag - file sharing flag
*       FILE *stream - stream to use for file
*
*Exit:
*       set stream's fields, and causes system file management by system calls
*       returns stream or NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl __topenfile (
        const _TSCHAR *filename,
        REG3 const _TSCHAR *mode,
        int shflag,
        FILE *str
        )
{
        REG2 int modeflag;
        int streamflag = _commode;
        int commodeset = 0;
        int scanset    = 0;
        int whileflag;
        int filedes;
        REG1 FILE *stream;
        BOOL encodingFlag = FALSE;

        _ASSERTE(filename != NULL);
        _ASSERTE(mode != NULL);
        _ASSERTE(str != NULL);

        /* Parse the user's specification string as set flags in
               (1) modeflag - system call flags word
               (2) streamflag - stream handle flags word. */

        /* Skip leading spaces */
        while (*mode == _T(' '))
        {
            ++mode;
        }

        /* First mode character must be 'r', 'w', or 'a'. */

        switch (*mode) {
        case _T('r'):
                modeflag = _O_RDONLY;
                streamflag |= _IOREAD;
                break;
        case _T('w'):
                modeflag = _O_WRONLY | _O_CREAT | _O_TRUNC;
                streamflag |= _IOWRT;
                break;
        case _T('a'):
                modeflag = _O_WRONLY | _O_CREAT | _O_APPEND;
                streamflag |= _IOWRT;
                break;
        default:
                _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
        }

        /* There can be up to three more optional mode characters:
           (1) A single '+' character,
           (2) One of 't' and 'b' and
           (3) One of 'c' and 'n'.
        */

        whileflag=1;

        while(*++mode && whileflag)
                switch(*mode) {

                case _T(' '):
                    /* skip spaces */
                    break;

                case _T('+'):
                        if (modeflag & _O_RDWR)
                                whileflag=0;
                        else {
                                modeflag |= _O_RDWR;
                                modeflag &= ~(_O_RDONLY | _O_WRONLY);
                                streamflag |= _IORW;
                                streamflag &= ~(_IOREAD | _IOWRT);
                        }
                        break;

                case _T('b'):
                        if (modeflag & (_O_TEXT | _O_BINARY))
                                whileflag=0;
                        else
                                modeflag |= _O_BINARY;
                        break;

                case _T('t'):
                        if (modeflag & (_O_TEXT | _O_BINARY))
                                whileflag=0;
                        else
                                modeflag |= _O_TEXT;
                        break;

                case _T('c'):
                        if (commodeset)
                                whileflag=0;
                        else {
                                commodeset = 1;
                                streamflag |= _IOCOMMIT;
                        }
                        break;

                case _T('n'):
                        if (commodeset)
                                whileflag=0;
                        else {
                                commodeset = 1;
                                streamflag &= ~_IOCOMMIT;
                        }
                        break;

                case _T('S'):
                        if (scanset)
                                whileflag=0;
                        else {
                                scanset = 1;
                                modeflag |= _O_SEQUENTIAL;
                        }
                        break;

                case _T('R'):
                        if (scanset)
                                whileflag=0;
                        else {
                                scanset = 1;
                                modeflag |= _O_RANDOM;
                        }
                        break;

                case _T('T'):
                        if (modeflag & _O_SHORT_LIVED)
                                whileflag=0;
                        else
                                modeflag |= _O_SHORT_LIVED;
                        break;

                case _T('D'):
                        if (modeflag & _O_TEMPORARY)
                                whileflag=0;
                        else
                                modeflag |= _O_TEMPORARY;
                        break;
                case _T('N'):
                        modeflag |= _O_NOINHERIT;
                        break;

                case _T(','):
                        encodingFlag = TRUE;
                        whileflag = 0;
                        break;


                default:
                        _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
                }
        if (encodingFlag)
        {
            static const _TSCHAR ccsField[] = _T("ccs");
            static const _TSCHAR utf8encoding[] = _T("UTF-8");
            static const _TSCHAR utf16encoding[] = _T("UTF-16LE");
            static const _TSCHAR unicodeencoding[] = _T("UNICODE");

            /* Skip spaces */
            while (*mode == _T(' '))
            {
                ++mode;
            }

            /*
             * The length that we want to compare is numbers of elements in
             * csField -1 since this number also contains NULL terminator
             */
            if (_tcsncmp(ccsField, mode, (_countof(ccsField))-1) != 0)
                _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);

            mode += _countof(ccsField)-1;

            /* Skip spaces */
            while (*mode == _T(' '))
            {
                ++mode;
            }

            /* Look for '=' */
            if (*mode != _T('='))
            {
                _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
            }
            ++mode;

            /* Skip spaces */
            while (*mode == _T(' '))
            {
                ++mode;
            }

            if (_tcsnicmp(mode, utf8encoding, _countof(utf8encoding) - 1) == 0){
                mode += _countof(utf8encoding)-1;
                modeflag |= _O_U8TEXT;
            }
            else if (_tcsnicmp(mode, utf16encoding, _countof(utf16encoding) - 1) == 0) {
                mode += _countof(utf16encoding)-1;
                modeflag |= _O_U16TEXT;
            }
            else if (_tcsnicmp(mode, unicodeencoding, _countof(unicodeencoding) - 1) == 0) {
                mode += _countof(unicodeencoding)-1;
                modeflag |= _O_WTEXT;
            }
            else
                _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);

        }

        /* Skip trailing spaces */
        while (*mode == _T(' '))
        {
            ++mode;
        }

        _VALIDATE_RETURN( (*mode == _T('\0')), EINVAL, NULL);

        /* Try to open the file.  Note that if neither 't' nor 'b' is
           specified, _sopen will use the default. */

        if (_tsopen_s(&filedes, filename, modeflag, shflag, _S_IREAD | _S_IWRITE) != 0)
                return(NULL);

        /* Set up the stream data base. */
#ifndef CRTDLL
        _cflush++;  /* force library pre-termination procedure */
#endif  /* CRTDLL */
        /* Init pointers */
        stream = str;

        stream->_flag = streamflag;
        stream->_cnt = 0;
        stream->_tmpfname = stream->_base = stream->_ptr = NULL;

        stream->_file = filedes;

        return(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_strerr.c ===
/***
*_strerr.c - routine for indexing into system error list
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Returns system error message index by errno; conforms to the
*   XENIX standard, much compatibility with 1983 uniforum draft standard.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <errmsg.h>
#include <syserr.h>
#include <string.h>
#include <tchar.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>
#include <internal.h>

/* Max length of message = user_string(94)+system_string+2 */
/* [NOTE: The mthread error message buffer is shared by both strerror
   and _strerror so must be the max length of both. */
#define _ERRMSGLEN_ (94+_SYS_MSGMAX+2)

#ifdef _UNICODE
#define _terrmsg    _werrmsg
#else  /* _UNICODE */
#define _terrmsg    _errmsg
#endif  /* _UNICODE */


/***
*char *_strerror(message) - get system error message
*
*Purpose:
*   builds an error message consisting of the users error message
*   (the message parameter), followed by ": ", followed by the system
*   error message (index through errno), followed by a newline.  If
*   message is NULL or a null string, returns a pointer to just
*   the system error message.
*
*Entry:
*   char *message - user's message to prefix system error message
*
*Exit:
*   returns pointer to static memory containing error message.
*   returns NULL if malloc() fails in multi-thread versions.
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * __cdecl __wcserror(
#else  /* _UNICODE */
char * __cdecl _strerror (
#endif  /* _UNICODE */
    REG1 const _TCHAR *message
    )
{
    const char *sysErrorMsg = NULL;
    _TCHAR *bldmsg;
    _ptiddata ptd = _getptd_noexit();
    if (!ptd)
        return NULL;

    /* Use per thread buffer area (malloc space, if necessary) */
    /* [NOTE: This buffer is shared between _strerror and streror.] */

    if ( (ptd->_terrmsg == NULL) && ((ptd->_terrmsg =
            _calloc_crt(_ERRMSGLEN_, sizeof(_TCHAR))) == NULL) )
            return(NULL);
    bldmsg = ptd->_terrmsg;

    /* Build the error message */

    bldmsg[0] = '\0';

    if (message && *message) {
        // should leave space for ": \n\0"
        _ERRCHECK(_tcsncat_s( bldmsg, _ERRMSGLEN_, message, _ERRMSGLEN_-4 ));
        _ERRCHECK(_tcscat_s( bldmsg, _ERRMSGLEN_, _T(": ")));
    }

    //  We should have extra space for "\n\0"
    sysErrorMsg = _get_sys_err_msg(errno);

#ifdef _UNICODE
    _ERRCHECK(mbstowcs_s(NULL, bldmsg + wcslen(bldmsg), _ERRMSGLEN_ - wcslen(bldmsg), sysErrorMsg, _ERRMSGLEN_ - wcslen(bldmsg) - 2));
#else  /* _UNICODE */
    _ERRCHECK(strncat_s(bldmsg, _ERRMSGLEN_, sysErrorMsg, _ERRMSGLEN_ - strlen(bldmsg) - 2));
#endif  /* _UNICODE */

    _ERRCHECK(_tcscat_s( bldmsg, _ERRMSGLEN_, _T("\n")));
    return bldmsg;
}

/***
*errno_t _strerror_s(buffer, sizeInTChars, message) - get system error message
*
*Purpose:
*   builds an error message consisting of the users error message
*   (the message parameter), followed by ": ", followed by the system
*   error message (index through errno), followed by a newline.  If
*   message is NULL or a null string, returns a pointer to just
*   the system error message.
*
*Entry:
*   TCHAR * buffer - Destination buffer.
*   size_t sizeInTChars - Size of the destination buffer.
*   TCHAR * message - user's message to prefix system error message
*
*Exit:
*   The error code.
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#define _MIN_MSG_LENGTH 5

#ifdef _UNICODE
errno_t __cdecl __wcserror_s(
#else  /* _UNICODE */
errno_t __cdecl _strerror_s(
#endif  /* _UNICODE */
    TCHAR* buffer,
    size_t sizeInTChars,
    REG1 const _TCHAR *message
    )
{
    errno_t e = 0;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(buffer != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sizeInTChars > 0, EINVAL);
    buffer[0] = '\0';

    if (message &&
        *message &&
        _tcslen(message) < (sizeInTChars - 2 - _MIN_MSG_LENGTH))
    {
        _ERRCHECK(_tcscpy_s(buffer, sizeInTChars, message));
        _ERRCHECK(_tcscat_s(buffer, sizeInTChars, _T(": ")));
    }

    /* append the error message at the end of the buffer */
    return _tcserror_s(buffer + _tcslen(buffer), sizeInTChars - _tcslen(buffer), errno);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_wcserr.c ===
/***
*_wcserr.c - routine for indexing into system error list
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns system error message index by errno; conforms to the
*       XENIX standard, much compatibility with 1983 uniforum draft standard.
*       (wide char version of _strerror())
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "_strerr.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_setargv.c ===
/***
*_setargv.c - Wildcard argv[] expansion
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       _setargv performs wildcard argv[] expansion
*
*       NOTE:  This stub module scheme is compatible with NT build
*       procedure.
*
*******************************************************************************/

#define WILDCARD 1
#include "stdargv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_toupper.c ===
/***
*_toupper.c - convert character to uppercase
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Toupper()
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <awint.h>
#include <yvals.h>

/* remove macro definitions of _toupper() and toupper()
 */
#undef  _toupper
#undef  toupper

/***
*int _Toupper(c) - convert character to uppercase
*
*Purpose:
*       _Toupper() is a version of toupper with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of uppercase representation of c
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Toupper (
        int c,
        const _Ctypevec *ploc
        )
{
        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'a') && (c <= 'z') )
                c = c - ('a' - 'A');
            return c;
        }

        /* if checking case of c does not require API call, do it */
        if ((unsigned)c < 256)
        {
            if (ploc == 0)
            {
                if (!islower(c))
                {
                    return c;
                }
            }
            else
            {
                if (!(ploc->_Table[c] & _LOWER))
                {
                    return c;
                }
            }
        }

        /* convert int c to multibyte string */
        if (ploc == 0 ? _cpp_isleadbyte((c >> 8) & 0xff)
                      : (ploc->_Table[(c >> 8) & 0xff] & _LEADBYTE) != 0)
        {
            inbuffer[0] = (c >> 8 & 0xff);
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to uppercase */
        if (0 == (size = __crtLCMapStringA(NULL, handle, LCMAP_UPPERCASE,
            (const char *)inbuffer, size, (char *)outbuffer, 3, codepage, TRUE)))
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_wctype.c ===
/***
*_wctype.c - function versions of wctype macros
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file provides function versions of the wide character
*       classification and conversion macros in ctype.h.
*
*******************************************************************************/


/***
*wctype - Function versions of wctype macros
*
*Purpose:
*       Function versions of the wide char macros in ctype.h,
*       including isleadbyte and iswascii.  In order to define
*       these, we use a trick -- we undefine the macro so we can use the
*       name in the function declaration, then re-include the file so
*       we can use the macro in the definition part.
*
*       Functions defined:
*           iswalpha    iswupper     iswlower
*           iswdigit    iswxdigit    iswspace
*           iswpunct    iswalnum     iswprint
*           iswgraph    iswctrl      iswascii
*                                    isleadbyte
*
*Entry:
*       wchar_t c = character to be tested
*Exit:
*       returns non-zero = character is of the requested type
*                  0 = character is NOT of the requested type
*
*Exceptions:
*       None.
*
*******************************************************************************/

#include <ctype.h>
#include <cruntime.h>
#include <stdlib.h>
#include <locale.h>
#include <mbctype.h>
#include <mtdll.h>
#include <setlocal.h>

extern "C"
{
extern __inline int (__cdecl _isleadbyte_l) (
        int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);
    return (_loc_update.GetLocaleT()->locinfo->pctype[(unsigned char)(c)] & _LEADBYTE);
}

extern __inline int (__cdecl isleadbyte) (
        int c
        )
{
        return _isleadbyte_l(c, NULL);
}

extern __inline int (__cdecl _iswalpha_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswalpha(c);
}

extern __inline int (__cdecl iswalpha) (
        wint_t c
        )
{
        return iswalpha(c);
}

extern __inline int (__cdecl _iswupper_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswupper(c);
}

extern __inline int (__cdecl iswupper) (
        wint_t c
        )
{
        return iswupper(c);
}

extern __inline int (__cdecl _iswlower_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswlower(c);
}

extern __inline int (__cdecl iswlower) (
        wint_t c
        )
{
        return iswlower(c);
}

extern __inline int (__cdecl _iswdigit_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswdigit(c);
}

extern __inline int (__cdecl iswdigit) (
        wint_t c
        )
{
        return iswdigit(c);
}

extern __inline int (__cdecl _iswxdigit_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswxdigit(c);
}

extern __inline int (__cdecl iswxdigit) (
        wint_t c
        )
{
        return iswxdigit(c);
}

extern __inline int (__cdecl _iswspace_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswspace(c);
}

extern __inline int (__cdecl iswspace) (
        wint_t c
        )
{
        return iswspace(c);
}

extern __inline int (__cdecl _iswpunct_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswpunct(c);
}

extern __inline int (__cdecl iswpunct) (
        wint_t c
        )
{
        return iswpunct(c);
}

extern __inline int (__cdecl _iswalnum_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswalnum(c);
}

extern __inline int (__cdecl iswalnum) (
        wint_t c
        )
{
        return iswalnum(c);
}

extern __inline int (__cdecl _iswprint_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswprint(c);
}

extern __inline int (__cdecl iswprint) (
        wint_t c
        )
{
        return iswprint(c);
}

extern __inline int (__cdecl _iswgraph_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswgraph(c);
}

extern __inline int (__cdecl iswgraph) (
        wint_t c
        )
{
        return iswgraph(c);
}

extern __inline int (__cdecl _iswcntrl_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return iswcntrl(c);
}

extern __inline int (__cdecl iswcntrl) (
        wint_t c
        )
{
        return iswcntrl(c);
}

extern __inline int (__cdecl iswascii) (
        wint_t c
        )
{
        return iswascii(c);
}

extern __inline int (__cdecl _iswcsym_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return __iswcsym(c);
}

extern __inline int (__cdecl __iswcsym) (
        wint_t c
        )
{
        return __iswcsym(c);
}

extern __inline int (__cdecl _iswcsymf_l) (
    wint_t c,
        _locale_t plocinfo
        )
{
        return __iswcsymf(c);
}

extern __inline int (__cdecl __iswcsymf) (
        wint_t c
        )
{
        return __iswcsymf(c);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_sftbuf.c ===
/***
*_sftbuf.c - temporary buffering initialization and flushing
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       temporary buffering initialization and flushing. if stdout/err is
*       unbuffered, buffer it temporarily so that string is sent to kernel as
*       a batch of chars, not char-at-a-time. if appropriate, make buffering
*       permanent.
*
*       [NOTE 1: These routines assume that the temporary buffering is only
*       used for output.  In particular, note that _stbuf() sets _IOWRT.]
*
*       [NOTE 2: It is valid for this module to assign a value directly to
*       _flag instead of simply twiddling bits since we are initializing the
*       buffer data base.]
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <internal.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>

/* Buffer pointers for stdout and stderr */
void *_stdbuf[2] = { NULL, NULL};

/***
*int _stbuf(stream) - set temp buffer on stdout, stdprn, stderr
*
*Purpose:
*       if stdout/stderr is still unbuffered, buffer it.
*       this function works intimately with _ftbuf, and accompanies it in
*       bracketing normally unbuffered output. these functions intended for
*       library use only.
*
*       Multi-thread: It is assumed that the caller has already aquired the
*       stream lock.
*
*Entry:
*       FILE *stream - stream to temp buffer
*
*Exit:
*       returns 1 if buffer initialized, 0 if not
*       sets fields in stdout or stderr to indicate buffering
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _stbuf (
        FILE *str
        )
{
        REG1 FILE *stream;
        int index;

        _ASSERTE(str != NULL);

        /* Init near stream pointer */
        stream = str;

        /* do nothing if not a tty device */
        if (!_isatty(_fileno(stream)))
                return(0);

        /* Make sure stream is stdout/stderr and init _stdbuf index */
        if (stream == stdout)
                index = 0;
        else if (stream == stderr)
                index = 1;
        else
                return(0);

#ifndef CRTDLL
        /* force library pre-termination procedure */
        _cflush++;
#endif  /* CRTDLL */

        /* Make sure the stream is not already buffered. */
        if (anybuf(stream))
                return(0);

        /* Allocate a buffer for this stream if we haven't done so yet. */
        if ( (_stdbuf[index] == NULL) &&
             ((_stdbuf[index]=_malloc_crt(_INTERNAL_BUFSIZ)) == NULL) ) {
                /* Cannot allocate buffer. Use _charbuf this time */
                stream->_ptr = stream->_base = (void *)&(stream->_charbuf);
                stream->_cnt = stream->_bufsiz = 2;
        }
        else {
                /* Set up the buffer */
                stream->_ptr = stream->_base = _stdbuf[index];
                stream->_cnt = stream->_bufsiz = _INTERNAL_BUFSIZ;
        }

        stream->_flag |= (_IOWRT | _IOYOURBUF | _IOFLRTN);

        return(1);
}


/***
*void _ftbuf(flag, stream) - take temp buffering off a stream
*
*Purpose:
*       If stdout/stderr is being buffered and it is a device, _flush and
*       dismantle the buffer. if it's not a device, leave the buffering on.
*       This function works intimately with _stbuf, and accompanies it in
*       bracketing normally unbuffered output. these functions intended for
*       library use only
*
*       Multi-thread: It is assumed that the caller has already aquired the
*       stream lock.
*
*Entry:
*       int flag     - a flag to tell whether to dismantle temp buffering on a
*                      stream
*       FILE *stream - the stream
*
*Exit:
*       no return value
*       sets fields in stdout/stderr
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _ftbuf (
        int flag,
        FILE *str
        )
{
        REG1 FILE *stream;

        _ASSERTE(flag == 0 || flag == 1);

        /* Init near stream pointers */
        stream = str;

        if (flag) {

                if (stream->_flag & _IOFLRTN) {

                        /* Flush the stream and tear down temp buffering. */
                        _flush(stream);
                        stream->_flag &= ~(_IOYOURBUF | _IOFLRTN);
                        stream->_bufsiz = 0;
                        stream->_base = stream->_ptr = NULL;
                }

                /* Note: If we expand the functionality of the _IOFLRTN bit to
                include other streams, we may want to clear that bit here under
                an 'else' clause (i.e., clear bit in the case that we leave the
                buffer permanently assigned.  Given our current use of the bit,
                the extra code is not needed. */

        } /* end flag = 1 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_wopen.c ===
/***
*_wopen.c - open a stream, with string mode (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wopenfile() - opens a stream, with string arguments for mode
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "_open.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_tolower.c ===
/***
*_tolower.c - convert character to lower case
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Tolower().
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <awint.h>
#include <stdlib.h>
#include <dbgint.h>
#include <yvals.h>

/* remove macro definitions of _tolower() and tolower()
 */
#undef  _tolower
#undef  tolower

/***
*int _Tolower(c) - convert character to lower case
*
*Purpose:
*       _Tolower() is a version of tolower with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of lower case representation of c
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Tolower (
        int c,
        const _Ctypevec *ploc
        )
{
        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'A') && (c <= 'Z') )
                c = c + ('a' - 'A');
            return c;
        }

        /* if checking case of c does not require API call, do it */
        if ((unsigned)c < 256)
        {
            if (ploc == 0)
            {
                if (!isupper(c))
                {
                    return c;
                }
            }
            else
            {
                if (!(ploc->_Table[c] & _UPPER))
                {
                    return c;
                }
            }
        }

        /* convert int c to multibyte string */
        if (ploc == 0 ? _cpp_isleadbyte((c >> 8) & 0xff)
                      : (ploc->_Table[(c >> 8) & 0xff] & _LEADBYTE) != 0)
        {
            inbuffer[0] = (c >> 8 & 0xff);
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to lowercase */
        if (0 == (size = __crtLCMapStringA(NULL, handle, LCMAP_LOWERCASE,
            (const char *)inbuffer, size, (char *)outbuffer, 3, codepage, TRUE)))
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

}


/***
*_Ctypevec _Getctype() - get ctype info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2_PURE _Ctypevec __CLRCALL_PURE_OR_CDECL _Getctype()
{
        /* get ctype info for current locale */
        _Ctypevec ctype;

        ctype._Hand = ___lc_handle_func()[LC_COLLATE];
        ctype._Page = ___lc_codepage_func();
        ctype._Table = (const short *)_calloc_crt(256, sizeof (*__pctype_func()));
        if (ctype._Table != 0)
        {
            memcpy((void *)ctype._Table, __pctype_func(), 256 * sizeof (*__pctype_func()));
            ctype._Delfl = 1;
        }
        else
        {
            ctype._Table = (const short *)__pctype_func();
            ctype._Delfl = 0;
        }

        return (ctype);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\IA64\fp8.c ===
/***
* fp8.c - Set default FP precision
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/
#include <float.h>
#include <internal.h>

void  _setdefaultprecision(void);

/*
 * Routine to set default FP precision to 64 bits.
 */

void _setdefaultprecision()
{
        _ERRCHECK(_controlfp_s(NULL, _PC_64, _MCW_PC));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\_wstargv.c ===
/***
*_wstargv.c - Wildcard argv[] expansion (wchar_t version)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       _wsetargv performs wildcard argv[] expansion
*
*       NOTE:  This stub module scheme is compatible with NT build
*       procedure.
*
*******************************************************************************/


#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#define WILDCARD 1

#include "stdargv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\IA64\secchk.c ===
/***
*secchk.c - checks buffer overrun security cookie for IA64
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines compiler helper __security_check_cookie, used by the /GS
*       compile switch to detect local buffer variable overrun bugs/attacks.
*
*       When compiling /GS, the compiler injects code to detect when a local
*       array variable has been overwritten, potentially overwriting other
*       variables on the stack.  A local variable is at the high end of the
*       local stack frame and initialized on entering the function.  When
*       exiting the function, the compiler inserts code to verify that the
*       local variable has not been modified.  If it has, then an error
*       reporting routine is called.
*
*******************************************************************************/

#include <windows.h>
#include <process.h>

/*
 * The global security cookie.  This name is known to the compiler.
 */
extern UINT_PTR __security_cookie;

/***
*__security_check_cookie(cookie) - check for buffer overrun
*
*Purpose:
*       Compiler helper.  Check if a local copy of the security cookie still
*       matches the global value.  If not, then report the fatal error.
*
*       The actual reporting is done by __report_gsfailure.
*
*Entry:
*       UINT_PTR cookie - local security cookie to check
*
*Exit:
*       Returns immediately if the local cookie matches the global version.
*       Otherwise, calls the failure reporting handler and exits.
*
*Exceptions:
*
*******************************************************************************/

void __security_check_cookie(UINT_PTR cookie)
{
    /* Immediately return if the local cookie is OK. */
    if (cookie == __security_cookie && (cookie & 0xFFFF000000000000i64) == 0)
    {
        return;
    }

    /* Report the failure */
    __report_gsfailure(cookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\AMD64\dllsupp.c ===
/***
*dllsupp.c - Definitions of public constants
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Provides definitions for public constants (absolutes) that are
*       'normally' defined in objects in the C library, but must be defined
*       here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
*
*                           _fltused
*
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */
int _fltused = 0x9875;
#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\IA64\divhelp.c ===
/***
*divhelp.c - Div/Rem helpers for IA64
*
*       Copyright (c) 2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Define a number of IA64 compiler support functions used to implement
*       integral divide and remainder in code compiled -Os.
*
*******************************************************************************/

/*
** First, turn on global optimizations and optimize for speed,
** so that compiler generates division/reminder inline.
*/

#pragma optimize ("gt", on)

/*
** Now proper helper functions.
*/

unsigned char __udiv8 (unsigned char i, unsigned char j)
{
    return i / j;
}

unsigned char __urem8 (unsigned char i, unsigned char j)
{
    return i % j;
}

signed char __div8 (signed char i, signed char j)
{
    return i / j;
}

signed char __rem8 (signed char i, signed char j)
{
    return i % j;
}

unsigned short __udiv16 (unsigned short i, unsigned short j)
{
    return i / j;
}

unsigned short __urem16 (unsigned short i, unsigned short j)
{
    return i % j;
}

signed short __div16 (signed short i, signed short j)
{
    return i / j;
}

signed short __rem16 (signed short i, signed short j)
{
    return i % j;
}

unsigned int __udiv32 (unsigned int i, unsigned int j)
{
    return i / j;
}

unsigned int __urem32 (unsigned int i, unsigned int j)
{
    return i % j;
}

signed int __div32 (signed int i, signed int j)
{
    return i / j;
}

signed int __rem32 (signed int i, signed int j)
{
    return i % j;
}

unsigned __int64 __udiv64 (unsigned __int64 i, unsigned __int64 j)
{
    return i / j;
}

unsigned __int64 __urem64 (unsigned __int64 i, unsigned __int64 j)
{
    return i % j;
}

signed __int64 __div64 (signed __int64 i, signed __int64 j)
{
    return i / j;
}

signed __int64 __rem64 (signed __int64 i, signed __int64 j)
{
    return i % j;
}

struct udivrem {
    unsigned __int64 div;
    unsigned __int64 rem;
};

struct divrem {
    signed __int64 div;
    signed __int64 rem;
};

struct udivrem __udivrem8 (unsigned char i, unsigned char j)
{
    struct udivrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct divrem __divrem8 (signed char i, signed char j)
{
    struct divrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct udivrem __udivrem16 (unsigned short i, unsigned short j)
{
    struct udivrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct divrem __divrem16 (signed short i, signed short j)
{
    struct divrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct udivrem __udivrem32 (unsigned int i, unsigned int j)
{
    struct udivrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct divrem __divrem32 (signed int i, signed int j)
{
    struct divrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct udivrem __udivrem64 (unsigned __int64 i, unsigned __int64 j)
{
    struct udivrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}

struct divrem __divrem64 (signed __int64 i, signed __int64 j)
{
    struct divrem s;

    s.div = i / j;
    s.rem = i % j;
    return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\AMD64\amdsecgs.asm ===
;***
;amdsecgs.asm      - amd64 -GS cookie check compiler helper
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       AMD64 security cookie checking routine
;
;*******************************************************************************

        TITLE   "AMD64 GS Security Check Compiler Helper"

include ksamd64.inc

        extern __security_cookie:QWORD
        extern __report_gsfailure:PROC

;*++
;
; VOID
; __security_check_cookie (
;    ULONG64 Value
;    )
;
; Routine Description:
;
;   This function checks the specified cookie value against the global
;   cookie value. If the values match, then control is returned to the
;   caller. Otherwise, the failure is reported and there is no return
;   to the caller.
;
;   N.B. No registers except for RCX are modified if the return is to the
;   caller.
;
; Arguments:
;
;   Value (rcx) - Supplies the value of cookie.
;
; Return Value:
;
;    None.
;
;--*

        LEAF_ENTRY __security_check_cookie, _TEXT

        cmp rcx, __security_cookie      ; check cookie value in frame
        jne ReportFailure               ; if ne, cookie check failure
        rol rcx, 16                     ; make sure high word is zero
        test cx, -1
        jne RestoreRcx
        db 0f3h                         ; (encode REP for REP RET)
        ret                             ; no overrun, use REP RET to avoid AMD
                                        ; branch prediction flaw after Jcc

;
; The cookie check failed.
;

RestoreRcx:
        ror rcx, 16

ReportFailure:

        jmp __report_gsfailure          ; overrun found

        LEAF_END __security_check_cookie, _TEXT

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\IA64\dllsupp.c ===
/***
*dllsupp.c - Definitions of public constants
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Provides definitions for public constants (absolutes) that are
*       'normally' defined in objects in the C library, but must be defined
*       here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
*
*                           _fltused
*
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */
int _fltused = 0x9875;
#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\alloca16.asm ===
page    ,132
        title   alloca16 - aligned C stack checking routine
;***
;chkstk.asm - aligned C stack checking routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Provides 16 and 8 bit aligned alloca routines.
;
;*******************************************************************************

.xlist
        include cruntime.inc
.list

extern  _chkstk:near

; size of a page of memory

        CODESEG

page
;***
; _alloca_probe_16, _alloca_probe_8 - align allocation to 16/8 byte boundary
;
;Purpose:
;       Adjust allocation size so the ESP returned from chkstk will be aligned
;       to 16/8 bit boundary. Call chkstk to do the real allocation.
;
;Entry:
;       EAX = size of local frame
;
;Exit:
;       Adjusted EAX.
;
;Uses:
;       EAX
;
;*******************************************************************************

public  _alloca_probe_8

_alloca_probe_16 proc                   ; 16 byte aligned alloca

        push    ecx
        lea     ecx, [esp] + 8          ; TOS before entering this function
        sub     ecx, eax                ; New TOS
        and     ecx, (16 - 1)           ; Distance from 16 bit align (align down)
        add     eax, ecx                ; Increase allocation size
        sbb     ecx, ecx                ; ecx = 0xFFFFFFFF if size wrapped around
        or      eax, ecx                ; cap allocation size on wraparound
        pop     ecx                     ; Restore ecx
        jmp     _chkstk

alloca_8:                               ; 8 byte aligned alloca
_alloca_probe_8 = alloca_8

        push    ecx
        lea     ecx, [esp] + 8          ; TOS before entering this function
        sub     ecx, eax                ; New TOS
        and     ecx, (8 - 1)            ; Distance from 8 bit align (align down)
        add     eax, ecx                ; Increase allocation Size
        sbb     ecx, ecx                ; ecx = 0xFFFFFFFF if size wrapped around
        or      eax, ecx                ; cap allocation size on wraparound
        pop     ecx                     ; Restore ecx
        jmp     _chkstk

_alloca_probe_16 endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\dllsupp.asm ===
;***
;dllsupp.asm - Definitions of public constants
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Provides definitions for public constants (absolutes) that are
;       'normally' defined in objects in the C library, but must be defined
;       here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
;
;                           _except_list
;                           _fltused
;                           _ldused
;
;*******************************************************************************

        .686
        .model  flat,c

; offset, with respect to FS, of pointer to currently active exception handler.
; referenced by compiler generated code for SEH and by _setjmp().

        public  _except_list
_except_list    equ     0

        public  _fltused
_fltused        equ     9876h

        public  _ldused
_ldused         equ     9876h

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\enable.asm ===
page    ,132
        title   enable - enable/disable interrupts
;***
;enable.asm - contains _enable() and _disable() routines
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;*******************************************************************************


        .xlist
        include cruntime.inc
        .list

page
;***
;void _enable(void)  - enables interrupts
;void _disable(void) - disables interrupts
;
;Purpose:
;       The _enable() functions executes a "sti" instruction. The _disable()
;       function executes a "cli" instruction.
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


        CODESEG

        public  _enable, _disable

_enable proc

        sti
        ret

_enable endp

        align   4

_disable proc

        cli
        ret

_disable endp


        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\chkstk.asm ===
page    ,132
        title   chkstk - C stack checking routine
;***
;chkstk.asm - C stack checking routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Provides support for automatic stack checking in C procedures
;       when stack checking is enabled.
;
;*******************************************************************************

.xlist
        include cruntime.inc
.list

; size of a page of memory

_PAGESIZE_      equ     1000h


        CODESEG

page
;***
;_chkstk - check stack upon procedure entry
;
;Purpose:
;       Provide stack checking on procedure entry. Method is to simply probe
;       each page of memory required for the stack in descending order. This
;       causes the necessary pages of memory to be allocated via the guard
;       page scheme, if possible. In the event of failure, the OS raises the
;       _XCPT_UNABLE_TO_GROW_STACK exception.
;
;       NOTE:  Currently, the (EAX < _PAGESIZE_) code path falls through
;       to the "lastpage" label of the (EAX >= _PAGESIZE_) code path.  This
;       is small; a minor speed optimization would be to special case
;       this up top.  This would avoid the painful save/restore of
;       ecx and would shorten the code path by 4-6 instructions.
;
;Entry:
;       EAX = size of local frame
;
;Exit:
;       ESP = new stackframe, if successful
;
;Uses:
;       EAX
;
;Exceptions:
;       _XCPT_GUARD_PAGE_VIOLATION - May be raised on a page probe. NEVER TRAP
;                                    THIS!!!! It is used by the OS to grow the
;                                    stack on demand.
;       _XCPT_UNABLE_TO_GROW_STACK - The stack cannot be grown. More precisely,
;                                    the attempt by the OS memory manager to
;                                    allocate another guard page in response
;                                    to a _XCPT_GUARD_PAGE_VIOLATION has
;                                    failed.
;
;*******************************************************************************

public  _alloca_probe

_chkstk proc

_alloca_probe    =  _chkstk

        push    ecx

; Calculate new TOS.

        lea     ecx, [esp] + 8 - 4      ; TOS before entering function + size for ret value
        sub     ecx, eax                ; new TOS

; Handle allocation size that results in wraparound.
; Wraparound will result in StackOverflow exception.

        sbb     eax, eax                ; 0 if CF==0, ~0 if CF==1
        not     eax                     ; ~0 if TOS did not wrapped around, 0 otherwise
        and     ecx, eax                ; set to 0 if wraparound

        mov     eax, esp                ; current TOS
        and     eax, not ( _PAGESIZE_ - 1) ; Round down to current page boundary

cs10:
        cmp     ecx, eax                ; Is new TOS
        jb      short cs20              ; in probed page?
        mov     eax, ecx                ; yes.
        pop     ecx
        xchg    esp, eax                ; update esp
        mov     eax, dword ptr [eax]    ; get return address
        mov     dword ptr [esp], eax    ; and put it at new TOS
        ret

; Find next lower page and probe
cs20:
        sub     eax, _PAGESIZE_         ; decrease by PAGESIZE
        test    dword ptr [eax],eax     ; probe page.
        jmp     short cs10

_chkstk endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\lldiv.asm ===
title   lldiv - signed long divide routine
;***
;lldiv.asm - signed long divide routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the signed long divide routine
;           __alldiv
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;lldiv - signed long divide
;
;Purpose:
;       Does a signed long divide of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the quotient (dividend/divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_alldiv PROC NEAR
.FPO (3, 4, 0, 0, 0, 0)

        push    edi
        push    esi
        push    ebx

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to lldiv(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;               |      EDI      |
;               |---------------|
;               |      ESI      |
;               |---------------|
;       ESP---->|      EBX      |
;               -----------------
;

DVND    equ     [esp + 16]      ; stack address of dividend (a)
DVSR    equ     [esp + 24]      ; stack address of divisor (b)


; Determine sign of the result (edi = 0 if result is positive, non-zero
; otherwise) and make operands positive.

        xor     edi,edi         ; result sign assumed positive

        mov     eax,HIWORD(DVND) ; hi word of a
        or      eax,eax         ; test to see if signed
        jge     short L1        ; skip rest if a is already positive
        inc     edi             ; complement result sign flag
        mov     edx,LOWORD(DVND) ; lo word of a
        neg     eax             ; make a positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVND),eax ; save positive value
        mov     LOWORD(DVND),edx
L1:
        mov     eax,HIWORD(DVSR) ; hi word of b
        or      eax,eax         ; test to see if signed
        jge     short L2        ; skip rest if b is already positive
        inc     edi             ; complement the result sign flag
        mov     edx,LOWORD(DVSR) ; lo word of a
        neg     eax             ; make b positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVSR),eax ; save positive value
        mov     LOWORD(DVSR),edx
L2:

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;
; NOTE - eax currently contains the high order word of DVSR
;

        or      eax,eax         ; check to see if divisor < 4194304K
        jnz     short L3        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; eax <- high order bits of quotient
        mov     ebx,eax         ; save high bits of quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; eax <- low order bits of quotient
        mov     edx,ebx         ; edx:eax <- quotient
        jmp     short L4        ; set sign, restore stack and return

;
; Here we do it the hard way.  Remember, eax contains the high word of DVSR
;

L3:
        mov     ebx,eax         ; ebx:ecx <- divisor
        mov     ecx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L5:
        shr     ebx,1           ; shift divisor right one bit
        rcr     ecx,1
        shr     edx,1           ; shift dividend right one bit
        rcr     eax,1
        or      ebx,ebx
        jnz     short L5        ; loop until divisor < 4194304K
        div     ecx             ; now divide, ignore remainder
        mov     esi,eax         ; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             ; QUOT * LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L6        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L6        ; if result > original, do subtract
        jb      short L7        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L7        ; if less or equal we are ok, else subtract
L6:
        dec     esi             ; subtract 1 from quotient
L7:
        xor     edx,edx         ; edx:eax <- quotient
        mov     eax,esi

;
; Just the cleanup left to do.  edx:eax contains the quotient.  Set the sign
; according to the save value, cleanup the stack, and return.
;

L4:
        dec     edi             ; check to see if result is negative
        jnz     short L8        ; if EDI == 0, result should be negative
        neg     edx             ; otherwise, negate the result
        neg     eax
        sbb     edx,0

;
; Restore the saved registers and return.
;

L8:
        pop     ebx
        pop     esi
        pop     edi

        ret     16

_alldiv ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\fp8.c ===
/***
* fp8.c - Set default FP precision to 53 bits (8-byte double)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/
#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <stddef.h>
#include <float.h>
#include <internal.h>

#ifdef __cplusplus
extern "C"
#endif  /* __cplusplus */
void  __CLRCALL_OR_CDECL _setdefaultprecision(void);

/*
 * Routine to set default FP precision to 53 bits.
 */

#ifdef __cplusplus
extern "C"
#endif  /* __cplusplus */
void __CLRCALL_OR_CDECL _setdefaultprecision()
{
        _ERRCHECK(_controlfp_s(NULL, _PC_53, _MCW_PC));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\inp.asm ===
page    ,132
        title   inp - input from ports
;***
;inp.asm - _inp, _inpw and _inpd routines
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Defines the read-from-a-port functions: _inp(), _inpw() and inpd().
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list


page
;***
;int            _inp(port)  - read byte from port
;unsigned short _inpw(port) - read word from port
;unsigned long  _inpd(port) - read dword from port
;
;Purpose:
;       Read single byte/word/dword from the specified port.
;
;Entry:
;       unsigned short port - port to read from
;
;Exit:
;       returns value read.
;
;Uses:
;       EAX, EDX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public _inp, _inpw, _inpd

_inp    proc

        xor     eax,eax
        mov     dx,word ptr [esp + 4]
        in      al,dx
        ret

_inp    endp


_inpw   proc

        mov     dx,word ptr [esp + 4]
        in      ax,dx
        ret

_inpw   endp

_inpd   proc

        mov     dx,word ptr [esp + 4]
        in      eax,dx
        ret

_inpd   endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\llmul.asm ===
title   llmul - long multiply routine
;***
;llmul.asm - long multiply routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Defines long multiply routine
;       Both signed and unsigned routines are the same, since multiply's
;       work out the same in 2's complement
;       creates the following routine:
;           __allmul
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;llmul - long multiply routine
;
;Purpose:
;       Does a long multiply (same for signed/unsigned)
;       Parameters are not changed.
;
;Entry:
;       Parameters are passed on the stack:
;               1st pushed: multiplier (QWORD)
;               2nd pushed: multiplicand (QWORD)
;
;Exit:
;       EDX:EAX - product of multiplier and multiplicand
;       NOTE: parameters are removed from the stack
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_allmul PROC NEAR
.FPO (0, 4, 0, 0, 0, 0)

A       EQU     [esp + 4]       ; stack address of a
B       EQU     [esp + 12]      ; stack address of b

;
;       AHI, BHI : upper 32 bits of A and B
;       ALO, BLO : lower 32 bits of A and B
;
;             ALO * BLO
;       ALO * BHI
; +     BLO * AHI
; ---------------------
;

        mov     eax,HIWORD(A)
        mov     ecx,HIWORD(B)
        or      ecx,eax         ;test for both hiwords zero.
        mov     ecx,LOWORD(B)
        jnz     short hard      ;both are zero, just mult ALO and BLO

        mov     eax,LOWORD(A)
        mul     ecx

        ret     16              ; callee restores the stack

hard:
        push    ebx
.FPO (1, 4, 0, 0, 0, 0)

; must redefine A and B since esp has been altered

A2      EQU     [esp + 8]       ; stack address of a
B2      EQU     [esp + 16]      ; stack address of b

        mul     ecx             ;eax has AHI, ecx has BLO, so AHI * BLO
        mov     ebx,eax         ;save result

        mov     eax,LOWORD(A2)
        mul     dword ptr HIWORD(B2) ;ALO * BHI
        add     ebx,eax         ;ebx = ((ALO * BHI) + (AHI * BLO))

        mov     eax,LOWORD(A2)  ;ecx = BLO
        mul     ecx             ;so edx:eax = ALO*BLO
        add     edx,ebx         ;now edx has all the LO*HI stuff

        pop     ebx

        ret     16              ; callee restores the stack

_allmul ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\lldvrm.asm ===
title   lldvrm - signed long divide and remainder routine
;***
;lldvrm.asm - signed long divide and remainder routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the signed long divide and remainder routine
;           __alldvrm
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;lldvrm - signed long divide and remainder
;
;Purpose:
;       Does a signed long divide and remainder of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the quotient (dividend/divisor)
;       EBX:ECX contains the remainder (divided % divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_alldvrm PROC NEAR
.FPO (3, 4, 0, 0, 1, 0)

        push    edi
        push    esi
        push    ebp

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to alldvrm(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;               |      EDI      |
;               |---------------|
;               |      ESI      |
;               |---------------|
;       ESP---->|      EBP      |
;               -----------------
;

DVND    equ     [esp + 16]      ; stack address of dividend (a)
DVSR    equ     [esp + 24]      ; stack address of divisor (b)


; Determine sign of the quotient (edi = 0 if result is positive, non-zero
; otherwise) and make operands positive.
; Sign of the remainder is kept in ebp.

        xor     edi,edi         ; result sign assumed positive
        xor     ebp,ebp         ; result sign assumed positive

        mov     eax,HIWORD(DVND) ; hi word of a
        or      eax,eax         ; test to see if signed
        jge     short L1        ; skip rest if a is already positive
        inc     edi             ; complement result sign flag
        inc     ebp             ; complement result sign flag
        mov     edx,LOWORD(DVND) ; lo word of a
        neg     eax             ; make a positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVND),eax ; save positive value
        mov     LOWORD(DVND),edx
L1:
        mov     eax,HIWORD(DVSR) ; hi word of b
        or      eax,eax         ; test to see if signed
        jge     short L2        ; skip rest if b is already positive
        inc     edi             ; complement the result sign flag
        mov     edx,LOWORD(DVSR) ; lo word of a
        neg     eax             ; make b positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVSR),eax ; save positive value
        mov     LOWORD(DVSR),edx
L2:

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;
; NOTE - eax currently contains the high order word of DVSR
;

        or      eax,eax         ; check to see if divisor < 4194304K
        jnz     short L3        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; eax <- high order bits of quotient
        mov     ebx,eax         ; save high bits of quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; eax <- low order bits of quotient
        mov     esi,eax         ; ebx:esi <- quotient
;
; Now we need to do a multiply so that we can compute the remainder.
;
        mov     eax,ebx         ; set up high word of quotient
        mul     dword ptr LOWORD(DVSR) ; HIWORD(QUOT) * DVSR
        mov     ecx,eax         ; save the result in ecx
        mov     eax,esi         ; set up low word of quotient
        mul     dword ptr LOWORD(DVSR) ; LOWORD(QUOT) * DVSR
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jmp     short L4        ; complete remainder calculation

;
; Here we do it the hard way.  Remember, eax contains the high word of DVSR
;

L3:
        mov     ebx,eax         ; ebx:ecx <- divisor
        mov     ecx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L5:
        shr     ebx,1           ; shift divisor right one bit
        rcr     ecx,1
        shr     edx,1           ; shift dividend right one bit
        rcr     eax,1
        or      ebx,ebx
        jnz     short L5        ; loop until divisor < 4194304K
        div     ecx             ; now divide, ignore remainder
        mov     esi,eax         ; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             ; QUOT * LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L6        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L6        ; if result > original, do subtract
        jb      short L7        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L7        ; if less or equal we are ok, else subtract
L6:
        dec     esi             ; subtract 1 from quotient
        sub     eax,LOWORD(DVSR) ; subtract divisor from result
        sbb     edx,HIWORD(DVSR)
L7:
        xor     ebx,ebx         ; ebx:esi <- quotient

L4:
;
; Calculate remainder by subtracting the result from the original dividend.
; Since the result is already in a register, we will do the subtract in the
; opposite direction and negate the result if necessary.
;

        sub     eax,LOWORD(DVND) ; subtract dividend from result
        sbb     edx,HIWORD(DVND)

;
; Now check the result sign flag to see if the result is supposed to be positive
; or negative.  It is currently negated (because we subtracted in the 'wrong'
; direction), so if the sign flag is set we are done, otherwise we must negate
; the result to make it positive again.
;

        dec     ebp             ; check result sign flag
        jns     short L9        ; result is ok, set up the quotient
        neg     edx             ; otherwise, negate the result
        neg     eax
        sbb     edx,0

;
; Now we need to get the quotient into edx:eax and the remainder into ebx:ecx.
;
L9:
        mov     ecx,edx
        mov     edx,ebx
        mov     ebx,ecx
        mov     ecx,eax
        mov     eax,esi

;
; Just the cleanup left to do.  edx:eax contains the quotient.  Set the sign
; according to the save value, cleanup the stack, and return.
;

        dec     edi             ; check to see if result is negative
        jnz     short L8        ; if EDI == 0, result should be negative
        neg     edx             ; otherwise, negate the result
        neg     eax
        sbb     edx,0

;
; Restore the saved registers and return.
;

L8:
        pop     ebp
        pop     esi
        pop     edi

        ret     16

_alldvrm ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\llshl.asm ===
title   llshl - long shift left
;***
;llshl.asm - long shift left
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       define long shift left routine (signed and unsigned are same)
;           __allshl
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;llshl - long shift left
;
;Purpose:
;       Does a Long Shift Left (signed and unsigned are identical)
;       Shifts a long left any number of bits.
;
;Entry:
;       EDX:EAX - long value to be shifted
;       CL    - number of bits to shift by
;
;Exit:
;       EDX:EAX - shifted value
;
;Uses:
;       CL is destroyed.
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_allshl PROC NEAR
.FPO (0, 0, 0, 0, 0 ,0)

;
; Handle shifts of 64 or more bits (all get 0)
;
        cmp     cl, 64
        jae     short RETZERO

;
; Handle shifts of between 0 and 31 bits
;
        cmp     cl, 32
        jae     short MORE32
        shld    edx,eax,cl
        shl     eax,cl
        ret

;
; Handle shifts of between 32 and 63 bits
;
MORE32:
        mov     edx,eax
        xor     eax,eax
        and     cl,31
        shl     edx,cl
        ret

;
; return 0 in edx:eax
;
RETZERO:
        xor     eax,eax
        xor     edx,edx
        ret

_allshl ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\llrem.asm ===
title   llrem - signed long remainder routine
;***
;llrem.asm - signed long remainder routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the signed long remainder routine
;           __allrem
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;llrem - signed long remainder
;
;Purpose:
;       Does a signed long remainder of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the remainder (dividend%divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_allrem PROC NEAR
.FPO (2, 4, 0, 0, 0, 0)

        push    ebx
        push    edi

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a%b will
; generate a call to lrem(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;               |       EBX     |
;               |---------------|
;       ESP---->|       EDI     |
;               -----------------
;

DVND    equ     [esp + 12]      ; stack address of dividend (a)
DVSR    equ     [esp + 20]      ; stack address of divisor (b)


; Determine sign of the result (edi = 0 if result is positive, non-zero
; otherwise) and make operands positive.

        xor     edi,edi         ; result sign assumed positive

        mov     eax,HIWORD(DVND) ; hi word of a
        or      eax,eax         ; test to see if signed
        jge     short L1        ; skip rest if a is already positive
        inc     edi             ; complement result sign flag bit
        mov     edx,LOWORD(DVND) ; lo word of a
        neg     eax             ; make a positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVND),eax ; save positive value
        mov     LOWORD(DVND),edx
L1:
        mov     eax,HIWORD(DVSR) ; hi word of b
        or      eax,eax         ; test to see if signed
        jge     short L2        ; skip rest if b is already positive
        mov     edx,LOWORD(DVSR) ; lo word of b
        neg     eax             ; make b positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVSR),eax ; save positive value
        mov     LOWORD(DVSR),edx
L2:

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;
; NOTE - eax currently contains the high order word of DVSR
;

        or      eax,eax         ; check to see if divisor < 4194304K
        jnz     short L3        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; edx <- remainder
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; edx <- final remainder
        mov     eax,edx         ; edx:eax <- remainder
        xor     edx,edx
        dec     edi             ; check result sign flag
        jns     short L4        ; negate result, restore stack and return
        jmp     short L8        ; result sign ok, restore stack and return

;
; Here we do it the hard way.  Remember, eax contains the high word of DVSR
;

L3:
        mov     ebx,eax         ; ebx:ecx <- divisor
        mov     ecx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L5:
        shr     ebx,1           ; shift divisor right one bit
        rcr     ecx,1
        shr     edx,1           ; shift dividend right one bit
        rcr     eax,1
        or      ebx,ebx
        jnz     short L5        ; loop until divisor < 4194304K
        div     ecx             ; now divide, ignore remainder

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mov     ecx,eax         ; save a copy of quotient in ECX
        mul     dword ptr HIWORD(DVSR)
        xchg    ecx,eax         ; save product, get quotient in EAX
        mul     dword ptr LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L6        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract the original divisor from the result.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L6        ; if result > original, do subtract
        jb      short L7        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L7        ; if less or equal we are ok, else subtract
L6:
        sub     eax,LOWORD(DVSR) ; subtract divisor from result
        sbb     edx,HIWORD(DVSR)
L7:

;
; Calculate remainder by subtracting the result from the original dividend.
; Since the result is already in a register, we will do the subtract in the
; opposite direction and negate the result if necessary.
;

        sub     eax,LOWORD(DVND) ; subtract dividend from result
        sbb     edx,HIWORD(DVND)

;
; Now check the result sign flag to see if the result is supposed to be positive
; or negative.  It is currently negated (because we subtracted in the 'wrong'
; direction), so if the sign flag is set we are done, otherwise we must negate
; the result to make it positive again.
;

        dec     edi             ; check result sign flag
        jns     short L8        ; result is ok, restore stack and return
L4:
        neg     edx             ; otherwise, negate the result
        neg     eax
        sbb     edx,0

;
; Just the cleanup left to do.  edx:eax contains the quotient.
; Restore the saved registers and return.
;

L8:
        pop     edi
        pop     ebx

        ret     16

_allrem ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\loadcfg.c ===
/***
*chkesp.c
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines the default load config struct linked into images.
*
*******************************************************************************/

#if !defined (_M_IX86)
#error  No need to compile this module for any platform besides x86
#endif  /* !defined (_M_IX86) */

#include <windows.h>

extern UINT_PTR     __security_cookie;  /* /GS security cookie */

/*
 * The following two names are automatically created by the linker for any
 * image that has the safe exception table present.
 */

extern PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
extern BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                           the count of table entries */

typedef struct {
    DWORD       Size;
    DWORD       TimeDateStamp;
    WORD        MajorVersion;
    WORD        MinorVersion;
    DWORD       GlobalFlagsClear;
    DWORD       GlobalFlagsSet;
    DWORD       CriticalSectionDefaultTimeout;
    DWORD       DeCommitFreeBlockThreshold;
    DWORD       DeCommitTotalFreeThreshold;
    DWORD       LockPrefixTable;            // VA
    DWORD       MaximumAllocationSize;
    DWORD       VirtualMemoryThreshold;
    DWORD       ProcessHeapFlags;
    DWORD       ProcessAffinityMask;
    WORD        CSDVersion;
    WORD        Reserved1;
    DWORD       EditList;                   // VA
    PUINT_PTR   SecurityCookie;
    PVOID       *SEHandlerTable;
    DWORD       SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32_2;

const
IMAGE_LOAD_CONFIG_DIRECTORY32_2   _load_config_used = {
    sizeof(IMAGE_LOAD_CONFIG_DIRECTORY32_2),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    &__security_cookie,
    __safe_se_handler_table,
    (DWORD)(DWORD_PTR) &__safe_se_handler_count
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\llshr.asm ===
title   llshr - long shift right
;***
;llshr.asm - long shift right
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       define signed long shift right routine
;           __allshr
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;llshr - long shift right
;
;Purpose:
;       Does a signed Long Shift Right
;       Shifts a long right any number of bits.
;
;Entry:
;       EDX:EAX - long value to be shifted
;       CL    - number of bits to shift by
;
;Exit:
;       EDX:EAX - shifted value
;
;Uses:
;       CL is destroyed.
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_allshr PROC NEAR
.FPO (0, 0, 0, 0, 0, 0)

;
; Handle shifts of 64 bits or more (if shifting 64 bits or more, the result
; depends only on the high order bit of edx).
;
        cmp     cl,64
        jae     short RETSIGN

;
; Handle shifts of between 0 and 31 bits
;
        cmp     cl, 32
        jae     short MORE32
        shrd    eax,edx,cl
        sar     edx,cl
        ret

;
; Handle shifts of between 32 and 63 bits
;
MORE32:
        mov     eax,edx
        sar     edx,31
        and     cl,31
        sar     eax,cl
        ret

;
; Return double precision 0 or -1, depending on the sign of edx
;
RETSIGN:
        sar     edx,31
        mov     eax,edx
        ret

_allshr ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\memccpy.asm ===
page    ,132
        title   memccpy - copy bytes until character found
;***
;memccpy.asm - copy bytes until a character is found
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines _memccpy() - copies bytes until a specifed character
;       is found, or a maximum number of characters have been copied.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *_memccpy(dest, src, _c, count) - copy bytes until character found
;
;Purpose:
;       Copies bytes from src to dest until count bytes have been
;       copied, or up to and including the character _c, whichever
;       comes first.
;
;       Algorithm:
;       char *
;       _memccpy (dest, src, _c, count)
;             char *dest, *src, _c;
;             unsigned int count;
;             {
;             while (count && (*dest++ = *src++) != _c)
;                     count--;
;
;             return(count ? dest : NULL);
;             }
;
;Entry:
;       char *dest - pointer to memory to receive copy
;       char *src - source of bytes
;       char _c - character to stop copy at
;       int count - max number of bytes to copy
;
;Exit:
;       returns pointer to byte immediately after _c in dest;
;       returns NULL if _c was never found
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  _memccpy
_memccpy proc \
        dest:ptr byte, \
        src:ptr byte, \
        _c:byte, \
        count:DWORD

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 4, 0, 0, 0, 0 )

        mov     ecx,[esp + 10h] ; ecx = max byte count
        push    ebx             ; save ebx

        test    ecx,ecx         ; if it's nothing to move
        jz      ret_zero_len    ; restore ebx, and return NULL

        mov     bh,[esp + 10h]  ; bh = byte to look for
        push    esi             ; save esi

        test    ecx,1           ; test if counter is odd or even

        mov     eax,[esp + 0ch] ; eax = dest   , don't affect flags
        mov     esi,[esp + 10h] ; esi = source , don't affect flags

;       nop
        jz      lupe2           ; if counter is even, do double loop
                                ; else do one iteration, and drop into double loop
        mov     bl,[esi]        ; get first byte into bl
        add     esi,1           ; kick src (esi points to src)

        mov     [eax],bl        ; store it in dest
        add     eax,1           ; kick dest

        cmp     bl,bh           ; see if we just moved the byte
        je      short toend

        sub     ecx,1           ; decrement counter
        jz      retnull         ; drop into double loop if nonzero

lupe2:
        mov     bl,[esi]        ; get first byte into bl
        add     esi,2           ; kick esi (src)

        cmp     bl,bh           ; check if we just moved the byte (from bl)
        je      toend_mov_inc   ; store bl & exit

        mov     [eax],bl        ; store first byte from bl
        mov     bl,[esi - 1]    ; get second byte  into bl

        mov     [eax + 1],bl    ; store second byte from bl
        add     eax,2           ; kick eax (dest)

        cmp     bl,bh           ; see if we just moved the byte
        je      short toend     ; end of string

        sub     ecx,2           ; modify counter, and if nonzero continue
        jnz     lupe2           ; else drop out & return NULL

retnull:
        pop     esi
ret_zero_len:
        xor     eax,eax         ; null pointer
        pop     ebx

        ret                     ; _cdecl return

toend_mov_inc:
        mov     [eax],bl        ; store first byte from bl
        add     eax,1           ; eax points right after the value

toend:  pop     esi
        pop     ebx

        ret                     ; _cdecl return

_memccpy endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\memchr.asm ===
page    ,132
        title   memchr - search memory for a given character
;***
;memchr.asm - search block of memory for a given character
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines memchr() - search memory until a character is
;       found or a limit is reached.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *memchr(buf, chr, cnt) - search memory for given character.
;
;Purpose:
;       Searched at buf for the given character, stopping when chr is
;       first found or cnt bytes have been searched through.
;
;       Algorithm:
;       char *
;       memchr (buf, chr, cnt)
;               char *buf;
;               int chr;
;               unsigned cnt;
;       {
;               while (cnt && *buf++ != c)
;                       cnt--;
;               return(cnt ? --buf : NULL);
;       }
;
;Entry:
;       char *buf - memory buffer to be searched
;       char chr - character to search for
;       unsigned cnt - max number of bytes to search
;
;Exit:
;       returns pointer to first occurence of chr in buf
;       returns NULL if chr not found in the first cnt bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  memchr
memchr  proc \
        buf:ptr byte, \
        chr:byte, \
        cnt:dword

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 1, 0, 0, 0, 0 )

        mov     eax,[esp+0ch]   ; eax = count
        push    ebx             ; Preserve ebx

        test    eax,eax         ; check if count=0
        jz      short retnull   ; if count=0, leave

        mov     edx,[esp+8]     ; edx = buffer
        xor     ebx,ebx

        mov     bl,[esp+0ch]    ; bl = search char

        test    edx,3           ; test if string is aligned on 32 bits
        jz      short main_loop_start

str_misaligned:                 ; simple byte loop until string is aligned
        mov     cl,byte ptr [edx]
        add     edx,1
        xor     cl,bl
        je      short found
        sub     eax,1           ; counter--
        jz      short retnull
        test    edx,3           ; already aligned ?
        jne     short str_misaligned

main_loop_start:
        sub     eax,4
        jb      short tail_less_then_4

; set all 4 bytes of ebx to [value]
        push    edi             ; Preserve edi
        mov     edi,ebx         ; edi=0/0/0/char
        shl     ebx,8           ; ebx=0/0/char/0
        add     ebx,edi         ; ebx=0/0/char/char
        mov     edi,ebx         ; edi=0/0/char/char
        shl     ebx,10h         ; ebx=char/char/0/0
        add     ebx,edi         ; ebx = all 4 bytes = [search char]
        jmp     short main_loop_entry   ; ecx >=0

return_from_main:
        pop     edi

tail_less_then_4:
        add     eax,4
        jz      retnull

tail_loop:                      ; 0 < eax < 4
        mov     cl,byte ptr [edx]
        add     edx,1
        xor     cl,bl
        je      short found
        sub     eax,1
        jnz     short tail_loop
retnull:
        pop     ebx
        ret                     ; _cdecl return

main_loop:
        sub     eax,4
        jb      short return_from_main
main_loop_entry:
        mov     ecx,dword ptr [edx]     ; read 4 bytes

        xor     ecx,ebx         ; ebx is byte\byte\byte\byte
        mov     edi,7efefeffh

        add     edi,ecx
        xor     ecx,-1

        xor     ecx,edi
        add     edx,4

        and     ecx,81010100h
        je      short main_loop

; found zero byte in the loop?
char_is_found:
        mov     ecx,[edx - 4]
        xor     cl,bl           ; is it byte 0
        je      short byte_0
        xor     ch,bl           ; is it byte 1
        je      short byte_1
        shr     ecx,10h         ; is it byte 2
        xor     cl,bl
        je      short byte_2
        xor     ch,bl           ; is it byte 3
        je      short byte_3
        jmp     short main_loop ; taken if bits 24-30 are clear and bit
                                ; 31 is set

byte_3:
        pop     edi             ; restore edi
found:
        lea     eax,[edx - 1]
        pop     ebx             ; restore ebx
        ret                     ; _cdecl return

byte_2:
        lea     eax,[edx - 2]
        pop     edi
        pop     ebx
        ret                     ; _cdecl return

byte_1:
        lea     eax,[edx - 3]
        pop     edi
        pop     ebx
        ret                     ; _cdecl return

byte_0:
        lea     eax,[edx - 4]
        pop     edi             ; restore edi
        pop     ebx             ; restore ebx
        ret                     ; _cdecl return

memchr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\memmove.asm ===
;***
;memmove.asm -
;
;       Copyright (c) Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       memmove() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are treated specially, to avoid propogation.
;
;       NOTE:  This stub module scheme is compatible with NT build
;       procedure.
;
;*******************************************************************************

MEM_MOVE EQU 1
INCLUDE Intel\MEMCPY.ASM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\memcpy.asm ===
page    ,132
        title   memcpy - Copy source memory bytes to destination
;***
;memcpy.asm - contains memcpy and memmove routines
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are not treated specially, so propogation may occur.
;       memmove() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are treated specially, to avoid propogation.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

M_EXIT  macro
        ret                     ; _cdecl return
        endm    ; M_EXIT

        CODESEG
    extrn   _VEC_memcpy:near
    extrn   __sse2_available:dword

page
;***
;memcpy - Copy source buffer to destination buffer
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination memory buffer.
;       This routine does NOT recognize overlapping buffers, and thus can lead
;       to propogation.
;       For cases where propogation must be avoided, memmove() must be used.
;
;       Algorithm:
;
;           Same as memmove. See Below
;
;
;memmove - Copy source buffer to destination buffer
;
;Purpose:
;       memmove() copies a source memory buffer to a destination memory buffer.
;       This routine recognize overlapping buffers to avoid propogation.
;       For cases where propogation is not a problem, memcpy() can be used.
;
;   Algorithm:
;
;       void * memmove(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               if (dst <= src || dst >= (src + count)) {
;                       /*
;                        * Non-Overlapping Buffers
;                        * copy from lower addresses to higher addresses
;                        */
;                       while (count--)
;                               *dst++ = *src++;
;                       }
;               else {
;                       /*
;                        * Overlapping Buffers
;                        * copy from higher addresses to lower addresses
;                        */
;                       dst += count - 1;
;                       src += count - 1;
;
;                       while (count--)
;                               *dst-- = *src--;
;                       }
;
;               return(ret);
;       }
;
;
;Entry:
;       void *dst = pointer to destination buffer
;       const void *src = pointer to source buffer
;       size_t count = number of bytes to copy
;
;Exit:
;       Returns a pointer to the destination buffer in AX/DX:AX
;
;Uses:
;       CX, DX
;
;Exceptions:
;*******************************************************************************

ifdef MEM_MOVE
        _MEM_     equ <memmove>
else  ; MEM_MOVE
        _MEM_     equ <memcpy>
endif  ; MEM_MOVE

%       public  _MEM_
_MEM_   proc \
        dst:ptr byte, \
        src:ptr byte, \
        count:IWORD

              ; destination pointer
              ; source pointer
              ; number of bytes to copy

;       push    ebp             ;U - save old frame pointer
;       mov     ebp, esp        ;V - set new frame pointer

        push    edi             ;U - save edi
        push    esi             ;V - save esi

        mov     esi,[src]       ;U - esi = source
        mov     ecx,[count]     ;V - ecx = number of bytes to move

        mov     edi,[dst]       ;U - edi = dest

;
; Check for overlapping buffers:
;       If (dst <= src) Or (dst >= src + Count) Then
;               Do normal (Upwards) Copy
;       Else
;               Do Downwards Copy to avoid propagation
;

        mov     eax,ecx         ;V - eax = byte count...

        mov     edx,ecx         ;U - edx = byte count...
        add     eax,esi         ;V - eax = point past source end

        cmp     edi,esi         ;U - dst <= src ?
        jbe     short CopyUp    ;V - yes, copy toward higher addresses

        cmp     edi,eax         ;U - dst < (src + count) ?
        jb      CopyDown        ;V - yes, copy toward lower addresses

;
; Copy toward higher addresses.
;
CopyUp:
;
; First, see if we can use a "fast" copy SSE2 routine
        ; block size greater than min threshold?
        cmp     ecx,080h
        jb      Dword_align
        ; SSE2 supported?
        cmp     DWORD PTR __sse2_available,0
        je      Dword_align
        ; alignments equal?
        push    edi
        push    esi
        and     edi,15
        and     esi,15
        cmp     edi,esi
        pop     esi
        pop     edi
        jne     Dword_align

        ; do fast SSE2 copy, params already set
        jmp     _VEC_memcpy
        ; no return
;
; The algorithm for forward moves is to align the destination to a dword
; boundary and so we can move dwords with an aligned destination.  This
; occurs in 3 steps.
;
;   - move x = ((4 - Dest & 3) & 3) bytes
;   - move y = ((L-x) >> 2) dwords
;   - move (L - x - y*4) bytes
;

Dword_align:
        test    edi,11b         ;U - destination dword aligned?
        jnz     short CopyLeadUp ;V - if we are not dword aligned already, align

        shr     ecx,2           ;U - shift down to dword count
        and     edx,11b         ;V - trailing byte count

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

;
; Code to do optimal memory copies for non-dword-aligned destinations.
;

; The following length check is done for two reasons:
;
;    1. to ensure that the actual move length is greater than any possiale
;       alignment move, and
;
;    2. to skip the multiple move logic for small moves where it would
;       be faster to move the bytes with one instruction.
;

        align   @WordSize
CopyLeadUp:

        mov     eax,edi         ;U - get destination offset
        mov     edx,11b         ;V - prepare for mask

        sub     ecx,4           ;U - check for really short string - sub for adjust
        jb      short ByteCopyUp ;V - branch to just copy bytes

        and     eax,11b         ;U - get offset within first dword
        add     ecx,eax         ;V - update size after leading bytes copied

        jmp     dword ptr LeadUpVec[eax*4-4] ;N - process leading bytes

        align   @WordSize
ByteCopyUp:
        jmp     dword ptr TrailUpVec[ecx*4+16] ;N - process just bytes

        align   @WordSize
CopyUnwindUp:
        jmp     dword ptr UnwindUpVec[ecx*4] ;N - unwind dword copy

        align   @WordSize
LeadUpVec       dd      LeadUp1, LeadUp2, LeadUp3

        align   @WordSize
LeadUp1:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get second byte from source

        mov     [edi+1],al      ;U - write second byte to destination
        mov     al,[esi+2]      ;V - get third byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+2],al      ;V - write third byte to destination

        add     esi,3           ;U - advance source pointer
        add     edi,3           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadUp2:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get second byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+1],al      ;V - write second byte to destination

        add     esi,2           ;U - advance source pointer
        add     edi,2           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadUp3:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        add     esi,1           ;V - advance source pointer

        shr     ecx,2           ;U - shift down to dword count
        add     edi,1           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
UnwindUpVec     dd      UnwindUp0, UnwindUp1, UnwindUp2, UnwindUp3
                dd      UnwindUp4, UnwindUp5, UnwindUp6, UnwindUp7

UnwindUp7:
        mov     eax,[esi+ecx*4-28] ;U - get dword from source
                                   ;V - spare
        mov     [edi+ecx*4-28],eax ;U - put dword into destination
UnwindUp6:
        mov     eax,[esi+ecx*4-24] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-24],eax ;U - put dword into destination
UnwindUp5:
        mov     eax,[esi+ecx*4-20] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-20],eax ;U - put dword into destination
UnwindUp4:
        mov     eax,[esi+ecx*4-16] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-16],eax ;U - put dword into destination
UnwindUp3:
        mov     eax,[esi+ecx*4-12] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-12],eax ;U - put dword into destination
UnwindUp2:
        mov     eax,[esi+ecx*4-8] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4-8],eax ;U - put dword into destination
UnwindUp1:
        mov     eax,[esi+ecx*4-4] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4-4],eax ;U - put dword into destination

        lea     eax,[ecx*4]     ;V - compute update for pointer

        add     esi,eax         ;U - update source pointer
        add     edi,eax         ;V - update destination pointer
UnwindUp0:
        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

;-----------------------------------------------------------------------------

        align   @WordSize
TrailUpVec      dd      TrailUp0, TrailUp1, TrailUp2, TrailUp3

        align   @WordSize
TrailUp0:
        mov     eax,[dst]       ;U - return pointer to destination
        pop     esi             ;V - restore esi
        pop     edi             ;U - restore edi
                                ;V - spare
        M_EXIT

        align   @WordSize
TrailUp1:
        mov     al,[esi]        ;U - get byte from source
                                ;V - spare
        mov     [edi],al        ;U - put byte in destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailUp2:
        mov     al,[esi]        ;U - get first byte from source
                                ;V - spare
        mov     [edi],al        ;U - put first byte into destination
        mov     al,[esi+1]      ;V - get second byte from source
        mov     [edi+1],al      ;U - put second byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailUp3:
        mov     al,[esi]        ;U - get first byte from source
                                ;V - spare
        mov     [edi],al        ;U - put first byte into destination
        mov     al,[esi+1]      ;V - get second byte from source
        mov     [edi+1],al      ;U - put second byte into destination
        mov     al,[esi+2]      ;V - get third byte from source
        mov     [edi+2],al      ;U - put third byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------

;
; Copy down to avoid propogation in overlapping buffers.
;
        align   @WordSize
CopyDown:
        lea     esi,[esi+ecx-4] ;U - point to 4 bytes before src buffer end
        lea     edi,[edi+ecx-4] ;V - point to 4 bytes before dest buffer end
;
; See if the destination start is dword aligned
;

        test    edi,11b         ;U - test if dword aligned
        jnz     short CopyLeadDown ;V - if not, jump

        shr     ecx,2           ;U - shift down to dword count
        and     edx,11b         ;V - trailing byte count

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag back

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
CopyUnwindDown:
        neg     ecx             ;U - negate dword count for table merging
                                ;V - spare

        jmp     dword ptr UnwindDownVec[ecx*4+28] ;N - unwind copy

        align   @WordSize
CopyLeadDown:

        mov     eax,edi         ;U - get destination offset
        mov     edx,11b         ;V - prepare for mask

        cmp     ecx,4           ;U - check for really short string
        jb      short ByteCopyDown ;V - branch to just copy bytes

        and     eax,11b         ;U - get offset within first dword
        sub     ecx,eax         ;U - to update size after lead copied

        jmp     dword ptr LeadDownVec[eax*4-4] ;N - process leading bytes

        align   @WordSize
ByteCopyDown:
        jmp     dword ptr TrailDownVec[ecx*4] ;N - process just bytes

        align   @WordSize
LeadDownVec     dd      LeadDown1, LeadDown2, LeadDown3

        align   @WordSize
LeadDown1:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        sub     esi,1           ;V - point to last src dword

        shr     ecx,2           ;U - shift down to dword count
        sub     edi,1           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadDown2:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        mov     al,[esi+2]      ;V - get second byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+2],al      ;V - write second byte to destination

        sub     esi,2           ;U - point to last src dword
        sub     edi,2           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadDown3:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        mov     al,[esi+2]      ;V - get second byte from source

        mov     [edi+2],al      ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get third byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+1],al      ;V - write third byte to destination

        sub     esi,3           ;U - point to last src dword
        sub     edi,3           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      CopyUnwindDown  ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

;------------------------------------------------------------------

        align   @WordSize
UnwindDownVec   dd      UnwindDown7, UnwindDown6, UnwindDown5, UnwindDown4
                dd      UnwindDown3, UnwindDown2, UnwindDown1, UnwindDown0

UnwindDown7:
        mov     eax,[esi+ecx*4+28] ;U - get dword from source
                                   ;V - spare
        mov     [edi+ecx*4+28],eax ;U - put dword into destination
UnwindDown6:
        mov     eax,[esi+ecx*4+24] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+24],eax ;U - put dword into destination
UnwindDown5:
        mov     eax,[esi+ecx*4+20] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+20],eax ;U - put dword into destination
UnwindDown4:
        mov     eax,[esi+ecx*4+16] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+16],eax ;U - put dword into destination
UnwindDown3:
        mov     eax,[esi+ecx*4+12] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+12],eax ;U - put dword into destination
UnwindDown2:
        mov     eax,[esi+ecx*4+8] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+8],eax ;U - put dword into destination
UnwindDown1:
        mov     eax,[esi+ecx*4+4] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4+4],eax ;U - put dword into destination

        lea     eax,[ecx*4]     ;V - compute update for pointer

        add     esi,eax         ;U - update source pointer
        add     edi,eax         ;V - update destination pointer
UnwindDown0:
        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

;-----------------------------------------------------------------------------

        align   @WordSize
TrailDownVec    dd      TrailDown0, TrailDown1, TrailDown2, TrailDown3

        align   @WordSize
TrailDown0:
        mov     eax,[dst]       ;U - return pointer to destination
                                ;V - spare
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown1:
        mov     al,[esi+3]      ;U - get byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put byte in destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown2:
        mov     al,[esi+3]      ;U - get first byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put first byte into destination
        mov     al,[esi+2]      ;V - get second byte from source
        mov     [edi+2],al      ;U - put second byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown3:
        mov     al,[esi+3]      ;U - get first byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put first byte into destination
        mov     al,[esi+2]      ;V - get second byte from source
        mov     [edi+2],al      ;U - put second byte into destination
        mov     al,[esi+1]      ;V - get third byte from source
        mov     [edi+1],al      ;U - put third byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

_MEM_   endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strcspn.asm ===
;***
;strcspn.asm -
;
;       Copyright (c) Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       defines strcspn()- finds the length of the initial substring of
;       a string consisting entirely of characters not in a control string.
;
;       NOTE:  This stub module scheme is compatible with NT build
;       procedure.
;
;*******************************************************************************

SSTRCSPN EQU 1
INCLUDE Intel\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strlen.asm ===
page    ,132
        title   strlen - return the length of a null-terminated string
;***
;strlen.asm - contains strlen() routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       strlen returns the length of a null-terminated string,
;       not including the null byte itself.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;strlen - return the length of a null-terminated string
;
;Purpose:
;       Finds the length in bytes of the given string, not including
;       the final null character.
;
;       Algorithm:
;       int strlen (const char * str)
;       {
;           int length = 0;
;
;           while( *str++ )
;                   ++length;
;
;           return( length );
;       }
;
;Entry:
;       const char * str - string whose length is to be computed
;
;Exit:
;       EAX = length of the string "str", exclusive of the final null byte
;
;Uses:
;       EAX, ECX, EDX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  strlen

strlen  proc \
        buf:ptr byte

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 1, 0, 0, 0, 0 )

string  equ     [esp + 4]

        mov     ecx,string              ; ecx -> string
        test    ecx,3                   ; test if string is aligned on 32 bits
        je      short main_loop

str_misaligned:
        ; simple byte loop until string is aligned
        mov     al,byte ptr [ecx]
        add     ecx,1
        test    al,al
        je      short byte_3
        test    ecx,3
        jne     short str_misaligned

        add     eax,dword ptr 0         ; 5 byte nop to align label below

        align   16                      ; should be redundant

main_loop:
        mov     eax,dword ptr [ecx]     ; read 4 bytes
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     ecx,4
        test    eax,81010100h
        je      short main_loop
        ; found zero byte in the loop
        mov     eax,[ecx - 4]
        test    al,al                   ; is it byte 0
        je      short byte_0
        test    ah,ah                   ; is it byte 1
        je      short byte_1
        test    eax,00ff0000h           ; is it byte 2
        je      short byte_2
        test    eax,0ff000000h          ; is it byte 3
        je      short byte_3
        jmp     short main_loop         ; taken if bits 24-30 are clear and bit
                                        ; 31 is set

byte_3:
        lea     eax,[ecx - 1]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_2:
        lea     eax,[ecx - 2]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_1:
        lea     eax,[ecx - 3]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_0:
        lea     eax,[ecx - 4]
        mov     ecx,string
        sub     eax,ecx
        ret

strlen  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\outp.asm ===
page    ,132
        title   outp - output from ports
;***
;outp.asm - _outp, _outpw and _outpd routines
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Defines the write-to-a-port functions: _outp(), _outpw() and outpd().
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list


page
;***
;int            _outp(port, databyte)   - write byte from port
;unsigned short _outpw(port, dataword)  - write word from port
;unsigned long  _outpd(port, datadword) - write dword from port
;
;Purpose:
;       Write single byte/word/dword to the specified port.
;
;Entry:
;       unsigned short port - port to write to
;
;Exit:
;       returns value written.
;
;Uses:
;       EAX, EDX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public _outp, _outpw, _outpd

_outp   proc

        xor     eax,eax
        mov     dx,word ptr [esp + 4]
        mov     al,byte ptr [esp + 8]
        out     dx,al
        ret

_outp   endp


_outpw  proc

        mov     dx,word ptr [esp + 4]
        mov     ax,word ptr [esp + 8]
        out     dx,ax
        ret

_outpw  endp


_outpd  proc

        mov     dx,word ptr [esp + 4]
        mov     eax,[esp + 8]
        out     dx,eax
        ret

_outpd  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\memset.asm ===
page    ,132
        title   memset - set sections of memory all to one byte
;***
;memset.asm - set a section of memory to all one byte
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       contains the memset() routine
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *memset(dst, value, count) - sets "count" bytes at "dst" to "value"
;
;Purpose:
;       Sets the first "count" bytes of the memory starting
;       at "dst" to the character value "value".
;
;       Algorithm:
;       char *
;       memset (dst, value, count)
;               char *dst;
;               char value;
;               unsigned int count;
;               {
;               char *start = dst;
;
;               while (count--)
;                       *dst++ = value;
;               return(start);
;               }
;
;Entry:
;       char *dst - pointer to memory to fill with value
;       char value - value to put in dst bytes
;       int count - number of bytes of dst to fill
;
;Exit:
;       returns dst, with filled bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

    extrn   _VEC_memzero:near
    extrn   __sse2_available:dword

        public  memset
memset proc \
        dst:ptr byte, \
        value:byte, \
        count:dword

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     edx,[esp + 0ch] ; edx = "count"
        mov     ecx,[esp + 4]   ; ecx points to "dst"

        test    edx,edx         ; 0?
        jz      short toend     ; if so, nothing to do

        xor     eax,eax
        mov     al,[esp + 8]    ; the byte "value" to be stored

; Special case large block zeroing using SSE2 support
    test    al,al ; memset using zero initializer?
    jne     dword_align
    cmp     edx,080h ; block size exceeds size threshold?
    jb      dword_align
    cmp     DWORD PTR __sse2_available,0 ; SSE2 supported?
    je      dword_align

    jmp     _VEC_memzero ; use fast zero SSE2 implementation
    ; no return

; Align address on dword boundary
dword_align:

        push    edi             ; preserve edi
        mov     edi,ecx         ; edi = dest pointer

        cmp     edx,4           ; if it's less then 4 bytes
        jb      tail            ; tail needs edi and edx to be initialized

        neg     ecx
        and     ecx,3           ; ecx = # bytes before dword boundary
        jz      short dwords    ; jump if address already aligned

        sub     edx,ecx         ; edx = adjusted count (for later)
adjust_loop:
        mov     [edi],al
        add     edi,1
        sub     ecx,1
        jnz     adjust_loop

dwords:
; set all 4 bytes of eax to [value]
        mov     ecx,eax         ; ecx=0/0/0/value
        shl     eax,8           ; eax=0/0/value/0

        add     eax,ecx         ; eax=0/0val/val

        mov     ecx,eax         ; ecx=0/0/val/val

        shl     eax,10h         ; eax=val/val/0/0

        add     eax,ecx         ; eax = all 4 bytes = [value]

; Set dword-sized blocks
        mov     ecx,edx         ; move original count to ecx
        and     edx,3           ; prepare in edx byte count (for tail loop)
        shr     ecx,2           ; adjust ecx to be dword count
        jz      tail            ; jump if it was less then 4 bytes

        rep     stosd
main_loop_tail:
        test    edx,edx         ; if there is no tail bytes,
        jz      finish          ; we finish, and it's time to leave
; Set remaining bytes

tail:
        mov     [edi],al        ; set remaining bytes
        add     edi,1

        sub     edx,1           ; if there is some more bytes
        jnz     tail            ; continue to fill them

; Done
finish:
        mov     eax,[esp + 8]   ; return dest pointer
        pop     edi             ; restore edi

        ret

toend:
        mov     eax,[esp + 4]   ; return dest pointer

        ret

memset  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strcat.asm ===
page    ,132
        title   strcat - concatenate (append) one string to another
;***
;strcat.asm - contains strcat() and strcpy() routines
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       STRCAT concatenates (appends) a copy of the source string to the
;       end of the destination string, returning the destination string.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list


page
;***
;char *strcat(dst, src) - concatenate (append) one string to another
;
;Purpose:
;       Concatenates src onto the end of dest.  Assumes enough
;       space in dest.
;
;       Algorithm:
;       char * strcat (char * dst, char * src)
;       {
;           char * cp = dst;
;
;           while( *cp )
;                   ++cp;           /* Find end of dst */
;           while( *cp++ = *src++ )
;                   ;               /* Copy src to end of dst */
;           return( dst );
;       }
;
;Entry:
;       char *dst - string to which "src" is to be appended
;       const char *src - string to be appended to the end of "dst"
;
;Exit:
;       The address of "dst" in EAX
;
;Uses:
;       EAX, ECX
;
;Exceptions:
;
;*******************************************************************************

page
;***
;char *strcpy(dst, src) - copy one string over another
;
;Purpose:
;       Copies the string src into the spot specified by
;       dest; assumes enough room.
;
;       Algorithm:
;       char * strcpy (char * dst, char * src)
;       {
;           char * cp = dst;
;
;           while( *cp++ = *src++ )
;                   ;               /* Copy src over dst */
;           return( dst );
;       }
;
;Entry:
;       char * dst - string over which "src" is to be copied
;       const char * src - string to be copied over "dst"
;
;Exit:
;       The address of "dst" in EAX
;
;Uses:
;       EAX, ECX
;
;Exceptions:
;*******************************************************************************


        CODESEG

%       public  strcat, strcpy      ; make both functions available
strcpy  proc \
        dst:ptr byte, \
        src:ptr byte

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        push    edi                 ; preserve edi
        mov     edi,[esp+8]         ; edi points to dest string
        jmp     short copy_start

strcpy  endp

        align   16

strcat  proc \
        dst:ptr byte, \
        src:ptr byte

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 2, 0, 0, 0, 0 )

        mov     ecx,[esp+4]         ; ecx -> dest string
        push    edi                 ; preserve edi
        test    ecx,3               ; test if string is aligned on 32 bits
        je      short find_end_of_dest_string_loop

dest_misaligned:                    ; simple byte loop until string is aligned
        mov     al,byte ptr [ecx]
        add     ecx,1
        test    al,al
        je      short start_byte_3
        test    ecx,3
        jne     short dest_misaligned

        align   4

find_end_of_dest_string_loop:
        mov     eax,dword ptr [ecx] ; read 4 bytes
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     ecx,4
        test    eax,81010100h
        je      short find_end_of_dest_string_loop
        ; found zero byte in the loop
        mov     eax,[ecx - 4]
        test    al,al               ; is it byte 0
        je      short start_byte_0
        test    ah,ah               ; is it byte 1
        je      short start_byte_1
        test    eax,00ff0000h       ; is it byte 2
        je      short start_byte_2
        test    eax,0ff000000h      ; is it byte 3
        je      short start_byte_3
        jmp     short find_end_of_dest_string_loop
                                    ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
start_byte_3:
        lea     edi,[ecx - 1]
        jmp     short copy_start
start_byte_2:
        lea     edi,[ecx - 2]
        jmp     short copy_start
start_byte_1:
        lea     edi,[ecx - 3]
        jmp     short copy_start
start_byte_0:
        lea     edi,[ecx - 4]
;       jmp     short copy_start

;       edi points to the end of dest string.
copy_start::
        mov     ecx,[esp+0ch]       ; ecx -> sorc string
        test    ecx,3               ; test if string is aligned on 32 bits
        je      short main_loop_entrance

src_misaligned:                     ; simple byte loop until string is aligned
        mov     dl,byte ptr [ecx]
        add     ecx,1
        test    dl,dl
        je      short byte_0
        mov     [edi],dl
        add     edi,1
        test    ecx,3
        jne     short src_misaligned
        jmp     short main_loop_entrance

main_loop:                          ; edx contains first dword of sorc string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick dest pointer
main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [ecx] ; read 4 bytes

        add     edx,eax
        xor     eax,-1

        xor     eax,edx
        mov     edx,[ecx]           ; it's in cache now

        add     ecx,4               ; kick dest pointer
        test    eax,81010100h

        je      short main_loop
        ; found zero byte in the loop
; main_loop_end:
        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        je      short byte_3
        jmp     short main_loop     ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
byte_3:
        mov     [edi],edx
        mov     eax,[esp+8]         ; return in eax pointer to dest string
        pop     edi
        ret
byte_2:
        mov     [edi],dx
        mov     eax,[esp+8]         ; return in eax pointer to dest string
        mov     byte ptr [edi+2],0
        pop     edi
        ret
byte_1:
        mov     [edi],dx
        mov     eax,[esp+8]         ; return in eax pointer to dest string
        pop     edi
        ret
byte_0:
        mov     [edi],dl
        mov     eax,[esp+8]         ; return in eax pointer to dest string
        pop     edi
        ret

strcat  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\secchk.c ===
/***
*secchk.c - checks buffer overrun security cookie for x86
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines compiler helper __security_check_cookie, used by the /GS
*       compile switch to detect local buffer variable overrun bugs/attacks.
*
*       When compiling /GS, the compiler injects code to detect when a local
*       array variable has been overwritten, potentially overwriting the
*       return address (on machines like x86 where the return address is on
*       the stack).  A local variable is allocated directly before the return
*       address and initialized on entering the function.  When exiting the
*       function, the compiler inserts code to verify that the local variable
*       has not been modified.  If it has, then an error reporting routine
*       is called.
*
*******************************************************************************/

#include <windows.h>
#include <process.h>

/*
 * The global security cookie.  This name is known to the compiler.
 */
extern UINT_PTR __security_cookie;

/***
*__security_check_cookie(cookie) - check for buffer overrun
*
*Purpose:
*       Compiler helper.  Check if a local copy of the security cookie still
*       matches the global value.  If not, then report the fatal error.
*
*       The actual reporting is done by __report_gsfailure
*       since the cookie check routine must be minimal code that preserves
*       any registers used in returning the callee's result.
*
*Entry:
*       UINT_PTR cookie - local security cookie to check
*
*Exit:
*       Returns immediately if the local cookie matches the global version.
*       Otherwise, calls the failure reporting handler and exits.
*
*Exceptions:
*
*******************************************************************************/

void __declspec(naked) __fastcall __security_check_cookie(UINT_PTR cookie)
{
    /* x86 version written in asm to preserve all regs */
    __asm {
        cmp ecx, __security_cookie
        jne failure
        rep ret /* REP to avoid AMD branch prediction penalty */
failure:
        jmp __report_gsfailure
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strcmp.asm ===
page    ,132
        title   strcmp.asm - compare two strings
;***
;strcmp.asm - routine to compare two strings (for equal, less, or greater)
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       STRCMP compares two strings and returns an integer
;       to indicate whether the first is less than the second, the two are
;       equal, or whether the first is greater than the second, respectively.
;       Comparison is done byte by byte on an UNSIGNED basis, which is to
;       say that Null (0) is less than any other character (1-255).
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;strcmp - compare two strings, returning less than, equal to, or greater than
;
;Purpose:
;       Compares two string, determining their lexical order.  Unsigned
;       comparison is used.
;
;       Algorithm:
;          int strcmp ( src , dst )
;                  unsigned char *src;
;                  unsigned char *dst;
;          {
;                  int ret = 0 ;
;
;                  while( ! (ret = *src - *dst) && *dst)
;                          ++src, ++dst;
;
;                  if ( ret < 0 )
;                          ret = -1 ;
;                  else if ( ret > 0 )
;                          ret = 1 ;
;
;                  return( ret );
;          }
;
;Entry:
;       const char * src - string for left-hand side of comparison
;       const char * dst - string for right-hand side of comparison
;
;Exit:
;       AX < 0, 0, or >0, indicating whether the first string is
;       Less than, Equal to, or Greater than the second string.
;
;Uses:
;       CX, DX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  strcmp
strcmp  proc \
        str1:ptr byte, \
        str2:ptr byte

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 2, 0, 0, 0, 0 )

        mov     edx,[esp + 4]   ; edx = src
        mov     ecx,[esp + 8]   ; ecx = dst

        test    edx,3
        jnz     short dopartial

        align   4
dodwords:
        mov     eax,[edx]

        cmp     al,[ecx]
        jne     short donene
        or      al,al
        jz      short doneeq
        cmp     ah,[ecx + 1]
        jne     short donene
        or      ah,ah
        jz      short doneeq

        shr     eax,16

        cmp     al,[ecx + 2]
        jne     short donene
        or      al,al
        jz      short doneeq
        cmp     ah,[ecx + 3]
        jne     short donene
        add     ecx,4
        add     edx,4
        or      ah,ah
        jnz     short dodwords

        align   4
doneeq:
        xor     eax,eax
        ret

        align   4
donene:
        ; The instructions below should place -1 in eax if src < dst,
        ; and 1 in eax if src > dst.

        sbb     eax,eax
        sal     eax,1
        add     eax,1
        ret

        align   4
dopartial:
        test    edx,1
        jz      short doword

        mov     al,[edx]
        add     edx,1
        cmp     al,[ecx]
        jne     short donene
        add     ecx,1
        or      al,al
        jz      short doneeq

        test    edx,2
        jz      short dodwords


        align   4
doword:
        mov     ax,[edx]
        add     edx,2
        cmp     al,[ecx]
        jne     short donene
        or      al,al
        jz      short doneeq
        cmp     ah,[ecx + 1]
        jne     short donene
        or      ah,ah
        jz      short doneeq
        add     ecx,2
        jmp     short dodwords

strcmp  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strchr.asm ===
page    ,132
        title   strchr - search string for given character
;***
;strchr.asm - search a string for a given character
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strchr() - search a string for a character
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strchr(string, chr) - search a string for a character
;
;Purpose:
;       Searches a string for a given character, which may be the
;       null character '\0'.
;
;       Algorithm:
;       char *
;       strchr (string, chr)
;       char *string, chr;
;       {
;         while (*string && *string != chr)
;             string++;
;         if (*string == chr)
;             return(string);
;         return((char *)0);
;       }
;
;Entry:
;       char *string - string to search in
;       char chr     - character to search for
;
;Exit:
;       returns pointer to the first occurence of c in string
;       returns NULL if chr does not occur in string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

found_bx:
        lea     eax,[edx - 1]
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

        align   16
        public  strchr, __from_strstr_to_strchr
strchr  proc \
        string:ptr byte, \
        chr:byte

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 2, 0, 0, 0, 0 )

        xor     eax,eax
        mov     al,[esp + 8]        ; al = chr (search char)

__from_strstr_to_strchr label proc

        push    ebx                 ; PRESERVE EBX
        mov     ebx,eax             ; ebx = 0/0/0/chr
        shl     eax,8               ; eax = 0/0/chr/0
        mov     edx,[esp + 8]       ; edx = buffer
        test    edx,3               ; test if string is aligned on 32 bits
        jz      short main_loop_start

str_misaligned:                     ; simple byte loop until string is aligned
        mov     cl,[edx]
        add     edx,1
        cmp     cl,bl
        je      short found_bx
        test    cl,cl
        jz      short retnull_bx
        test    edx,3               ; now aligned ?
        jne     short str_misaligned

main_loop_start:                    ; set all 4 bytes of ebx to [chr]
        or      ebx,eax             ; ebx = 0/0/chr/chr
        push    edi                 ; PRESERVE EDI
        mov     eax,ebx             ; eax = 0/0/chr/chr
        shl     ebx,10h             ; ebx = chr/chr/0/0
        push    esi                 ; PRESERVE ESI
        or      ebx,eax             ; ebx = all 4 bytes = [chr]

; in the main loop (below), we are looking for chr or for EOS (end of string)

main_loop:
        mov     ecx,[edx]           ; read  dword (4 bytes)
        mov     edi,7efefeffh       ; work with edi & ecx for looking for chr

        mov     eax,ecx             ; eax = dword
        mov     esi,edi             ; work with esi & eax for looking for EOS

        xor     ecx,ebx             ; eax = dword xor chr/chr/chr/chr
        add     esi,eax

        add     edi,ecx
        xor     ecx,-1

        xor     eax,-1
        xor     ecx,edi

        xor     eax,esi
        add     edx,4

        and     ecx,81010100h       ; test for chr
        jnz     short chr_is_found  ; chr probably has been found

        ; chr was not found, check for EOS

        and     eax,81010100h       ; is any flag set ??
        jz      short main_loop     ; EOS was not found, go get another dword

        and     eax,01010100h       ; is it in high byte?
        jnz     short retnull       ; no, definitely found EOS, return failure

        and     esi,80000000h       ; check was high byte 0 or 80h
        jnz     short main_loop     ; it just was 80h in high byte, go get
                                    ; another dword
retnull:
        pop     esi
        pop     edi
retnull_bx:
        pop     ebx
        xor     eax,eax
        ret                         ; _cdecl return

chr_is_found:
        mov     eax,[edx - 4]       ; let's look one more time on this dword
        cmp     al,bl               ; is chr in byte 0?
        je      short byte_0
        test    al,al               ; test if low byte is 0
        je      retnull
        cmp     ah,bl               ; is it byte 1
        je      short byte_1
        test    ah,ah               ; found EOS ?
        je      retnull
        shr     eax,10h             ; is it byte 2
        cmp     al,bl
        je      short byte_2
        test    al,al               ; if in al some bits were set, bl!=bh
        je      retnull
        cmp     ah,bl
        je      short byte_3
        test    ah,ah
        jz      retnull
        jmp     short main_loop     ; neither chr nor EOS found, go get
                                    ; another dword
byte_3:
        pop     esi
        pop     edi
        lea     eax,[edx - 1]
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

byte_2:
        lea     eax,[edx - 2]
        pop     esi
        pop     edi
        pop     ebx
        ret                         ; _cdecl return

byte_1:
        lea     eax,[edx - 3]
        pop     esi
        pop     edi
        pop     ebx
        ret                         ; _cdecl return

byte_0:
        lea     eax,[edx - 4]
        pop     esi                 ; restore esi
        pop     edi                 ; restore edi
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

strchr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strncat.asm ===
page    ,132
        title   strncat - append n chars of string1 to string2
;***
;strncat.asm - append n chars of string to new string
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strncat() - appends n characters of string onto
;       end of other string
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strncat(front, back, count) - append count chars of back onto front
;
;Purpose:
;       Appends at most count characters of the string back onto the
;       end of front, and ALWAYS terminates with a null character.
;       If count is greater than the length of back, the length of back
;       is used instead.  (Unlike strncpy, this routine does not pad out
;       to count characters).
;
;       Algorithm:
;       char *
;       strncat (front, back, count)
;           char *front, *back;
;           unsigned count;
;       {
;           char *start = front;
;
;           while (*front++)
;               ;
;           front--;
;           while (count--)
;               if (!(*front++ = *back++))
;                   return(start);
;           *front = '\0';
;           return(start);
;       }
;
;Entry:
;       char *   front - string to append onto
;       char *   back  - string to append
;       unsigned count - count of max characters to append
;
;Exit:
;       returns a pointer to string appended onto (front).
;
;Uses:  ECX, EDX
;
;Exceptions:
;
;*******************************************************************************

    CODESEG

    public  strncat
strncat proc
;   front:ptr byte,
;   back:ptr byte,
;   count:IWORD

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     ecx,[esp + 0ch]     ; ecx = count
        push    edi                 ; preserve edi
        test    ecx,ecx
        jz      finish              ; leave if count is zero

        mov     edi,[esp + 8]       ; edi -> front string
        push    esi                 ; preserve esi
        test    edi,3               ; is string aligned on dword (4 bytes)
        push    ebx                 ; preserve ebx
        je      short find_end_of_front_string_loop

        ; simple byte loop until string is aligned

front_misaligned:
        mov     al,byte ptr [edi]
        add     edi,1
        test    al,al
        je      short start_byte_3
        test    edi,3
        jne     short front_misaligned

find_end_of_front_string_loop:
        mov     eax,dword ptr [edi] ; read dword (4 bytes)
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     edi,4
        test    eax,81010100h
        je      short find_end_of_front_string_loop

; found zero byte in the loop
        mov     eax,[edi - 4]
        test    al,al               ; is it byte 0
        je      short start_byte_0
        test    ah,ah               ; is it byte 1
        je      short start_byte_1
        test    eax,00ff0000h       ; is it byte 2
        je      short start_byte_2
        test    eax,0ff000000h      ; is it byte 3
        jne     short find_end_of_front_string_loop
                                    ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
start_byte_3:
        sub     edi,1
        jmp     short copy_start
start_byte_2:
        sub     edi,2
        jmp     short copy_start
start_byte_1:
        sub     edi,3
        jmp     short copy_start
start_byte_0:
        sub     edi,4

; edi now points to the end of front string.

copy_start:
        mov     esi,[esp + 14h]     ; esi -> back string
        test    esi,3               ; is back string is dword aligned?
        jnz     back_misaligned

        mov     ebx,ecx             ; store count for tail loop

        shr     ecx,2
        jnz     short main_loop_entrance
        jmp     short tail_loop_start   ; 0 < counter < 4

; simple byte loop until back string is aligned

back_misaligned:
        mov     dl,byte ptr [esi]
        add     esi,1
        test    dl,dl
        je      short byte_0
        mov     [edi],dl
        add     edi,1
        sub     ecx,1
        jz      empty_counter
        test    esi,3
        jne     short back_misaligned
        mov     ebx,ecx             ; store count for tail loop
        shr     ecx,2               ; convert ecx to dword count
        jnz     short main_loop_entrance

tail_loop_start:
        mov     ecx,ebx
        and     ecx,3               ; ecx = count of leftover bytes after the
                                    ; dwords have been concatenated
        jz      empty_counter

tail_loop:
        mov     dl,byte ptr [esi]
        add     esi,1
        mov     [edi],dl
        add     edi,1
        test    dl,dl
        je      short finish1       ; '\0' was already copied
        sub     ecx,1
        jnz     tail_loop

empty_counter:
        mov     [edi],cl            ; cl=0;
finish1:
        pop     ebx
        pop     esi
finish:
        mov     eax,[esp + 8]       ; return in eax pointer to front string
        pop     edi
        ret                         ; _cdecl return


byte_0:
        mov     [edi],dl
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return


main_loop:                          ; edx contains first dword of back string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick pointer to front string

        sub     ecx,1
        jz      tail_loop_start
main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [esi] ; read 4 bytes

        add     edx,eax
        xor     eax,-1

        xor     eax,edx
        mov     edx,[esi]           ; it's in cache now

        add     esi,4               ; kick pointer to back string
        test    eax,81010100h

        je      short main_loop

; may be found zero byte in the loop
        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        jne short main_loop         ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
byte_3:
        mov     [edi],edx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

byte_2:
        mov     [edi],dx
        xor     edx,edx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        mov     [edi + 2],dl
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

byte_1:
        mov     [edi],dx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

strncat endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strpbrk.asm ===
;***
;strpbrk.asm -
;
;       Copyright (c) Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       defines strpbrk()- finds the index of the first character in a string
;       that is not in a control string
;
;       NOTE:  This stub module scheme is compatible with NT build
;       procedure.
;
;*******************************************************************************

SSTRPBRK EQU 1
INCLUDE Intel\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strnset.asm ===
page    ,132
        title   strnset - set first n characters to one char.
;***
;strnset.asm - set first n characters to single character
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines _strnset() - sets at most the first n characters of a string
;       to a given character.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *_strnset(string, val, count) - set at most count characters to val
;
;Purpose:
;       Sets the first count characters of string the character value.
;       If the length of string is less than count, the length of
;       string is used in place of n.
;
;       Algorithm:
;       char *
;       _strnset (string, val, count)
;             char *string,val;
;             unsigned int count;
;             {
;             char *start = string;
;
;             while (count-- && *string)
;                     *string++ = val;
;             return(start);
;             }
;
;Entry:
;       char *string - string to set characters in
;       char val - character to fill with
;       unsigned count - count of characters to fill
;
;Exit:
;       returns string, now filled with count copies of val.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  _strnset
_strnset proc \
        uses edi ebx, \
        string:ptr byte, \
        val:byte, \
        count:IWORD


        mov     edi,[string]    ; di = string
        mov     edx,edi         ; dx=string addr; save return value
        mov     ebx,[count]     ; cx = max chars to set
        xor     eax,eax         ; null byte
        mov     ecx,ebx
        jecxz   short done      ; zero length specified

repne   scasb                   ; find null byte & count bytes in cx
        jne     short nonull    ; null not found
        add     ecx,1           ; don't want the null

nonull:
        sub     ebx,ecx         ; bx=strlen (not null)
        mov     ecx,ebx         ; cx=strlen (not null)

        mov     edi,edx         ; restore string pointer
        mov     al,val          ; byte value
rep     stosb                   ; fill 'er up

done:
        mov     eax,edx         ; return value: string addr

        ret                     ; _cdecl return

_strnset endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strset.asm ===
page    ,132
        title   strset - set all characters of string to character
;***
;strset.asm - sets all charcaters of string to given character
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines _strset() - sets all of the characters in a string (except
;       the '\0') equal to a given character.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *_strset(string, val) - sets all of string to val
;
;Purpose:
;       Sets all of characters in string (except the terminating '/0'
;       character) equal to val.
;
;       Algorithm:
;       char *
;       _strset (string, val)
;             char *string;
;             char val;
;             {
;             char *start = string;
;
;             while (*string)
;                     *string++ = val;
;             return(start);
;             }
;
;Entry:
;       char *string - string to modify
;       char val - value to fill string with
;
;Exit:
;       returns string -- now filled with val's
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  _strset
_strset proc \
        uses edi, \
        string:ptr byte, \
        val:byte


        mov     edi,[string]    ; di = string
        mov     edx,edi         ; dx=string addr; save return value

        xor     eax,eax         ; ax = 0
        or      ecx,-1          ; cx = -1
repne   scasb                   ; scan string & count bytes
        add     ecx,2           ; cx=-strlen
        neg     ecx             ; cx=strlen
        mov     al,[val]        ; al = byte value to store
        mov     edi,edx         ; di=string addr
rep     stosb

        mov     eax,edx         ; return value: string addr

        ret                     ; _cdecl return

_strset endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strncmp.c ===
/***
*strncmp.c - compare first n characters of two strings
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines strncmp() - compare first n characters of two strings
*   for lexical order.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*int strncmp(first, last, count) - compare first count chars of strings
*
*Purpose:
*   Compares two strings for lexical order.  The comparison stops
*   after: (1) a difference between the strings is found, (2) the end
*   of the strings is reached, or (3) count characters have been
*   compared.
*
*Entry:
*   char *first, *last - strings to compare
*   unsigned count - maximum number of characters to compare
*
*Exit:
*   returns <0 if first < last
*   returns  0 if first == last
*   returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strncmp (
    const char * first,
    const char * last,
    size_t count
)
{
    size_t n = 0;

    if (!count)
        return(0);

    if( count >= 4 )
    {
        /* unroll by four */
        for (; n < count-4; n += 4)
        {
            first += 4;
            last += 4;

            if (*(first - 4) == 0 || *(first - 4) != *(last - 4))
            {
                return (*(unsigned char *)(first - 4) - *(unsigned char *)(last - 4));
            }

            if (*(first - 3) == 0 || *(first - 3) != *(last - 3))
            {
                return (*(unsigned char *)(first - 3) - *(unsigned char *)(last - 3));
            }

            if (*(first - 2) == 0 || *(first - 2) != *(last - 2))
            {
                return (*(unsigned char *)(first - 2) - *(unsigned char *)(last - 2));
            }

            if (*(first - 1) == 0 || *(first - 1) != *(last - 1))
            {
                return (*(unsigned char *)(first - 1) - *(unsigned char *)(last - 1));
            }
        }
    }

    /* residual loop */
    for (; n < count; ++n)
    {
        if (*first == 0 || *first != *last)
        {
            return (*(unsigned char *)first - *(unsigned char *)last);
        }
        ++first;
        ++last;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strncpy.asm ===
page    ,132
        title   strncpy - copy at most n characters of string
;***
;strncpy.asm - copy at most n characters of string
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strncpy() - copy at most n characters of string
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strncpy(dest, source, count) - copy at most n characters
;
;Purpose:
;       Copies count characters from the source string to the
;       destination.  If count is less than the length of source,
;       NO NULL CHARACTER is put onto the end of the copied string.
;       If count is greater than the length of sources, dest is padded
;       with null characters to length count.
;
;       Algorithm:
;       char *
;       strncpy (dest, source, count)
;       char *dest, *source;
;       unsigned count;
;       {
;         char *start = dest;
;
;         while (count && (*dest++ = *source++))
;             count--;
;         if (count)
;             while (--count)
;                 *dest++ = '\0';
;         return(start);
;       }
;
;Entry:
;       char *dest     - pointer to spot to copy source, enough space
;                        is assumed.
;       char *source   - source string for copy
;       unsigned count - characters to copy
;
;Exit:
;       returns dest, with the character copied there.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  strncpy
strncpy proc \
        dest:ptr byte, \
        source:ptr byte, \
        count:dword

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     ecx,[esp + 0ch]     ; ecx = count
        push    edi                 ; preserve edi
        test    ecx,ecx
        jz      finish              ; leave if count is zero

        push    esi                 ; preserve edi
        push    ebx                 ; preserve ebx
        mov     ebx,ecx             ; store count for tail loop
        mov     esi,[esp + 14h]     ; esi -> source string
        test    esi,3               ; test if source string is aligned on 32 bits
        mov     edi,[esp + 10h]     ; edi -> dest string
        jnz     short src_misaligned    ; (almost always source is aligned)

        shr     ecx,2               ; convert ecx to dword count
        jnz     main_loop_entrance
        jmp     short copy_tail_loop    ; 0 < count < 4

; simple byte loop until string is aligned

src_misaligned:
        mov     al,byte ptr [esi]   ; copy a byte from source to dest
        add     esi,1
        mov     [edi],al
        add     edi,1
        sub     ecx,1
        jz      fill_tail_end1      ; if count == 0, leave
        test    al,al               ; was last copied byte zero?
        jz      short align_dest    ; if so, go align dest and pad it out
                                    ; with zeros
        test    esi,3               ; esi already aligned ?
        jne     short src_misaligned
        mov     ebx,ecx             ; store count for tail loop
        shr     ecx,2
        jnz     short main_loop_entrance

tail_loop_start:
        and     ebx,3               ; ebx = count_before_main_loop%4
        jz      short fill_tail_end1    ; if ebx == 0 then leave without
                                        ; appending a null byte

; while ( EOS (end-of-string) not found and count > 0 ) copy bytes

copy_tail_loop:
        mov     al,byte ptr [esi]   ; load byte from source
        add     esi,1
        mov     [edi],al            ; store byte to dest
        add     edi,1
        test    al,al               ; EOS found?
        je      short fill_tail_zero_bytes  ; '\0' was already copied
        sub     ebx,1
        jnz     copy_tail_loop
fill_tail_end1:
        mov     eax,[esp + 10h]     ; prepare return value
        pop     ebx
        pop     esi
        pop     edi
        ret

; EOS found. Pad with null characters to length count

align_dest:
        test    edi,3               ; dest string aligned?
        jz      dest_align_loop_end
dest_align_loop:
        mov     [edi],al
        add     edi,1
        sub     ecx,1               ; count == 0?
        jz      fill_tail_end       ; if so, finished
        test    edi,3               ; is edi aligned ?
        jnz     dest_align_loop
dest_align_loop_end:
        mov     ebx,ecx             ; ebx > 0
        shr     ecx,2               ; convert ecx to count of dwords
        jnz     fill_dwords_with_EOS
        ; pad tail bytes
finish_loop:                        ; 0 < ebx < 4
        mov     [edi],al
        add     edi,1
fill_tail_zero_bytes:
        sub     ebx,1
        jnz     finish_loop
        pop     ebx
        pop     esi
finish:
        mov     eax,[esp + 8]       ; return in eax pointer to dest string
        pop     edi
        ret

; copy (source) string to (dest). Also look for end of (source) string

main_loop:                          ; edx contains first dword of source string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick dest pointer
        sub     ecx,1
        jz      tail_loop_start

main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [esi] ; read 4 bytes (dword)
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        mov     edx,[esi]           ; it's in cache now
        add     esi,4               ; kick dest pointer
        test    eax,81010100h
        je      short main_loop

        ; may have found zero byte in the dword

        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        jne     short main_loop     ; taken if bits 24-30 are clear and bit
                                    ; 31 is set

; a null character was found, so dest needs to be padded out with null chars
; to count length.

        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_2:
        and     edx,0ffffh          ; fill high 2 bytes with 0
        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_1:
        and     edx,0ffh            ; fill high 3 bytes with 0
        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_0:
        xor     edx,edx             ; fill whole dword with 0
        mov     [edi],edx

; End of string was found. Pad out dest string with dwords of 0

fill_with_EOS_dwords:               ; ecx > 0   (ecx is dword counter)
        add     edi,4
        xor     eax,eax             ; it is instead of ???????????????????
        sub     ecx,1
        jz      fill_tail           ; we filled all dwords

fill_dwords_with_EOS:
        xor     eax,eax
fill_with_EOS_loop:
        mov     [edi],eax
        add     edi,4
        sub     ecx,1
        jnz     short fill_with_EOS_loop
fill_tail:                          ; let's pad tail bytes with zero
        and     ebx,3               ; ebx = ebx % 4
        jnz     finish_loop         ; taken, when there are some tail bytes
fill_tail_end:
        mov     eax,[esp + 10h]
        pop     ebx
        pop     esi
        pop     edi
        ret

strncpy endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strrchr.asm ===
page    ,132
        title   strrchr - find last occurence of character in string
;***
;strrchr.asm - find last occurrence of character in string
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strrchr() - find the last occurrence of a given character
;       in a string.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strrchr(string, ch) - find last occurrence of ch in string
;
;Purpose:
;       Finds the last occurrence of ch in string.  The terminating
;       null character is used as part of the search.
;
;       Algorithm:
;       char *
;       strrchr (string, ch)
;             char *string, ch;
;             {
;             char *start = string;
;
;             while (*string++)
;                     ;
;             while (--string != start && *string != ch)
;                     ;
;             if (*string == ch)
;                     return(string);
;             return(NULL);
;             }
;
;Entry:
;       char *string - string to search in
;       char ch - character to search for
;
;Exit:
;       returns a pointer to the last occurrence of ch in the given
;       string
;       returns NULL if ch does not occurr in the string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  strrchr
strrchr proc \
        uses edi, \
        string:ptr byte, \
        chr:byte

        mov     edi,[string]    ; di = string
        xor     eax,eax         ; al=null byte
        or      ecx,-1          ; cx = -1
repne   scasb                   ; find the null & count bytes
        add     ecx,1           ; cx=-byte count (with null)
        neg     ecx             ; cx=+byte count (with null)
        sub     edi,1           ; di points to terminal null
        mov     al,chr          ; al=search byte
        std                     ; count 'down' on string this time
repne   scasb                   ; find that byte
        add     edi,1           ; di points to byte which stopped scan

        cmp     [edi],al        ; see if we have a hit
        je      short returndi  ; yes, point to byte

        xor     eax,eax         ; no, return NULL
        jmp     short toend     ; do return sequence

returndi:
        mov     eax,edi         ; ax=pointer to byte

toend:
        cld

        ret                     ; _cdecl return

strrchr endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strrev.asm ===
page    ,132
        title   strrev - reverse a string in place
;***
;strrev.asm - reverse a string in place
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines _strrev() - reverse a string in place (not including
;       '\0' character)
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *_strrev(string) - reverse a string in place
;
;Purpose:
;       Reverses the order of characters in the string.  The terminating
;       null character remains in place.
;
;       Algorithm:
;       char *
;       _strrev (string)
;             char *string;
;             {
;             char *start = string;
;             char *left = string;
;             char ch;
;
;             while (*string++)
;                     ;
;             string -= 2;
;             while (left < string)
;                     {
;                     ch = *left;
;                     *left++ = *string;
;                     *string-- = ch;
;                     }
;             return(start);
;             }
;
;       NOTE: There is a check for an empty string in the following code.
;       Normally, this would fall out of the "cmp si,di" instruction in the
;       loop portion of the routine.  However, if the offset of the empty
;       string is 0 (as it could be in large model), then the cmp does not
;       catch the empty string and the routine essentially hangs (i.e., loops
;       moving bytes one at a time FFFFh times).  An explicit empty string
;       check corrects this.
;
;Entry:
;       char *string - string to reverse
;
;Exit:
;       returns string - now with reversed characters
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  _strrev
_strrev proc \
        uses edi esi, \
        string:ptr byte

        mov     edi,[string]    ; di = string
        mov     edx,edi         ; dx=pointer to string; save return value

        mov     esi,edi         ; si=pointer to string
        xor     eax,eax         ; search value (null)
        or      ecx,-1          ; cx = -1
repne   scasb                   ; find null
        cmp     ecx,-2          ; is string empty? (if offset value is 0, the
        je      short done      ; cmp below will not catch it and we'll hang).

        sub     edi,2           ; string is not empty, move di pointer back
                                ; di points to last non-null byte

lupe:
        cmp     esi,edi         ; see if pointers have crossed yet
        jae     short done      ; exit when pointers meet (or cross)

        mov     ah,[esi]        ; get front byte...
        mov     al,[edi]        ;   and end byte
        mov     [esi],al        ; put end byte in front...
        mov     [edi],ah        ;   and front byte at end
        add     esi,1           ; front moves up...
        sub     edi,1           ;   and end moves down
        jmp     short lupe      ; keep switching bytes

done:
        mov     eax,edx         ; return value: string addr

        ret                     ; _cdecl return

_strrev endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\_memicmp.asm ===
page        ,132
        title        memicmp - compare blocks of memory, ignore case
;***
;memicmp.asm - compare memory, ignore case
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines __ascii_memicmp() - compare two blocks of memory for lexical
;       order. Case is ignored in the comparison.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_memicmp(first, last, count) - compare two blocks of memory, ignore case
;
;Purpose:
;       Compares count bytes of the two blocks of memory stored at first
;       and last.  The characters are converted to lowercase before
;       comparing (not permanently), so case is ignored in the search.
;
;       Algorithm:
;       int
;       _memicmp (first, last, count)
;               char *first, *last;
;               unsigned count;
;               {
;               if (!count)
;                       return(0);
;               while (--count && tolower(*first) == tolower(*last))
;                       {
;                       first++;
;                       last++;
;                       }
;               return(tolower(*first) - tolower(*last));
;               }
;
;Entry:
;       char *first, *last - memory buffers to compare
;       unsigned count - maximum length to compare
;
;Exit:
;       returns <0 if first < last
;       returns 0 if first == last
;       returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_memicmp
__ascii_memicmp proc \
        uses edi esi ebx, \
        first:ptr byte, \
        last:ptr byte, \
        count:IWORD

        mov     ecx,[count]     ; cx = count
        or      ecx,ecx
        jz      short toend     ; if count=0, nothing to do

        mov     esi,[first]     ; si = first
        mov     edi,[last]      ; di = last

        ; C locale

        mov     bh,'A'
        mov     bl,'Z'
        mov     dh,'a'-'A'      ; add to cap to make lower

        align   4

lupe:
        mov     ah,[esi]        ; ah = *first
        add     esi,1           ; first++
        mov     al,[edi]        ; al = *last
        add     edi,1           ; last++

        cmp     ah,al           ; test for equality BEFORE converting case
        je      short dolupe

        cmp     ah,bh           ; ah < 'A' ??
        jb      short skip1

        cmp     ah,bl           ; ah > 'Z' ??
        ja      short skip1

        add     ah,dh           ; make lower case

skip1:
        cmp     al,bh           ; al < 'A' ??
        jb      short skip2

        cmp     al,bl           ; al > 'Z' ??
        ja      short skip2

        add     al,dh           ; make lower case

skip2:
        cmp     ah,al           ; *first == *last ??
        jne     short differ    ; nope, found mismatched chars

dolupe:
        sub     ecx,1
        jnz     short lupe

        jmp     short toend     ; cx = 0, return 0

differ:
        mov     ecx,-1          ; assume last is bigger
                                ; *** can't use "or ecx,-1" due to flags ***
        jb      short toend     ; last is, in fact, bigger (return -1)
        neg     ecx             ; first is bigger (return 1)

toend:
        mov     eax,ecx         ; move return value to ax

        ret                     ; _cdecl return

__ascii_memicmp endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\ulldvrm.asm ===
title   ulldvrm - unsigned long divide and remainder routine
;***
;ulldvrm.asm - unsigned long divide and remainder routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the unsigned long divide and remainder routine
;           __aulldvrm
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;ulldvrm - unsigned long divide and remainder
;
;Purpose:
;       Does a unsigned long divide and remainder of the arguments.  Arguments
;       are not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the quotient (dividend/divisor)
;       EBX:ECX contains the remainder (divided % divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_aulldvrm PROC NEAR
.FPO (1, 4, 0, 0, 0, 0)

        push    esi

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to aulldvrm(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;       ESP---->|      ESI      |
;               -----------------
;

DVND    equ     [esp + 8]       ; stack address of dividend (a)
DVSR    equ     [esp + 16]      ; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

        mov     eax,HIWORD(DVSR) ; check to see if divisor < 4194304K
        or      eax,eax
        jnz     short L1        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; get high order bits of quotient
        mov     ebx,eax         ; save high bits of quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; get low order bits of quotient
        mov     esi,eax         ; ebx:esi <- quotient

;
; Now we need to do a multiply so that we can compute the remainder.
;
        mov     eax,ebx         ; set up high word of quotient
        mul     dword ptr LOWORD(DVSR) ; HIWORD(QUOT) * DVSR
        mov     ecx,eax         ; save the result in ecx
        mov     eax,esi         ; set up low word of quotient
        mul     dword ptr LOWORD(DVSR) ; LOWORD(QUOT) * DVSR
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jmp     short L2        ; complete remainder calculation

;
; Here we do it the hard way.  Remember, eax contains DVSRHI
;

L1:
        mov     ecx,eax         ; ecx:ebx <- divisor
        mov     ebx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L3:
        shr     ecx,1           ; shift divisor right one bit; hi bit <- 0
        rcr     ebx,1
        shr     edx,1           ; shift dividend right one bit; hi bit <- 0
        rcr     eax,1
        or      ecx,ecx
        jnz     short L3        ; loop until divisor < 4194304K
        div     ebx             ; now divide, ignore remainder
        mov     esi,eax         ; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             ; QUOT * LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L4        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L4        ; if result > original, do subtract
        jb      short L5        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L5        ; if less or equal we are ok, else subtract
L4:
        dec     esi             ; subtract 1 from quotient
        sub     eax,LOWORD(DVSR) ; subtract divisor from result
        sbb     edx,HIWORD(DVSR)
L5:
        xor     ebx,ebx         ; ebx:esi <- quotient

L2:
;
; Calculate remainder by subtracting the result from the original dividend.
; Since the result is already in a register, we will do the subtract in the
; opposite direction and negate the result.
;

        sub     eax,LOWORD(DVND) ; subtract dividend from result
        sbb     edx,HIWORD(DVND)
        neg     edx             ; otherwise, negate the result
        neg     eax
        sbb     edx,0

;
; Now we need to get the quotient into edx:eax and the remainder into ebx:ecx.
;
        mov     ecx,edx
        mov     edx,ebx
        mov     ebx,ecx
        mov     ecx,eax
        mov     eax,esi
;
; Just the cleanup left to do.  edx:eax contains the quotient.
; Restore the saved registers and return.
;

        pop     esi

        ret     16

_aulldvrm ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\ullrem.asm ===
title   ullrem - unsigned long remainder routine
;***
;ullrem.asm - unsigned long remainder routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the unsigned long remainder routine
;           __aullrem
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;ullrem - unsigned long remainder
;
;Purpose:
;       Does a unsigned long remainder of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the remainder (dividend%divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_aullrem        PROC NEAR
.FPO (1, 4, 0, 0, 0, 0)

        push    ebx

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a%b will
; generate a call to ullrem(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;       ESP---->|      EBX      |
;               -----------------
;

DVND    equ     [esp + 8]       ; stack address of dividend (a)
DVSR    equ     [esp + 16]      ; stack address of divisor (b)

; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

        mov     eax,HIWORD(DVSR) ; check to see if divisor < 4194304K
        or      eax,eax
        jnz     short L1        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; edx <- remainder, eax <- quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; edx <- final remainder
        mov     eax,edx         ; edx:eax <- remainder
        xor     edx,edx
        jmp     short L2        ; restore stack and return

;
; Here we do it the hard way.  Remember, eax contains DVSRHI
;

L1:
        mov     ecx,eax         ; ecx:ebx <- divisor
        mov     ebx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L3:
        shr     ecx,1           ; shift divisor right one bit; hi bit <- 0
        rcr     ebx,1
        shr     edx,1           ; shift dividend right one bit; hi bit <- 0
        rcr     eax,1
        or      ecx,ecx
        jnz     short L3        ; loop until divisor < 4194304K
        div     ebx             ; now divide, ignore remainder

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mov     ecx,eax         ; save a copy of quotient in ECX
        mul     dword ptr HIWORD(DVSR)
        xchg    ecx,eax         ; put partial product in ECX, get quotient in EAX
        mul     dword ptr LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L4        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we're ok, otherwise
; subtract the original divisor from the result.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L4        ; if result > original, do subtract
        jb      short L5        ; if result < original, we're ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L5        ; if less or equal we're ok, else subtract
L4:
        sub     eax,LOWORD(DVSR) ; subtract divisor from result
        sbb     edx,HIWORD(DVSR)
L5:

;
; Calculate remainder by subtracting the result from the original dividend.
; Since the result is already in a register, we will perform the subtract in
; the opposite direction and negate the result to make it positive.
;

        sub     eax,LOWORD(DVND) ; subtract original dividend from result
        sbb     edx,HIWORD(DVND)
        neg     edx             ; and negate it
        neg     eax
        sbb     edx,0

;
; Just the cleanup left to do.  dx:ax contains the remainder.
; Restore the saved registers and return.
;

L2:

        pop     ebx

        ret     16

_aullrem        ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strstr.asm ===
page    ,132
        title   strstr - search for one string inside another
;***
;strstr.asm - search for one string inside another
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strstr() - search for one string inside another
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strstr(str1, str2) - search for str2 in str1
;
;Purpose:
;       finds the first occurrence of str2 in str1
;
;Entry:
;       char *str1 - string to search in
;       char *str2 - string to search for
;
;Exit:
;       returns a pointer to the first occurrence of string2 in
;       string1, or NULL if string2 does not occur in string1
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


__from_strstr_to_strchr proto

        CODESEG

        public  strstr

strstr  proc \
        str1:ptr byte, \
        str2:ptr byte

        OPTION PROLOGUE:NONE, EPILOGUE:NONE

        mov     ecx,[esp + 8]       ; str2 (the string to be searched for)

        push    edi                 ; Preserve edi, ebx and esi
        push    ebx
        push    esi

        mov     dl,[ecx]            ; dl contains first char from str2

        mov     edi,[esp + 10h]     ; str1 (the string to be searched)

        test    dl,dl               ; is str2 empty?
        jz      empty_str2

        mov     dh,[ecx + 1]        ; second char from str2
        test    dh,dh               ; is str2 a one-character string?
        jz      strchr_call         ; if so, go use strchr code

; length of str2 is now known to be > 1 (used later)
; dl contains first char from str2
; dh contains second char from str2
; edi holds str1

findnext:
        mov     esi,edi             ; esi = edi = pointers to somewhere in str1
        mov     ecx,[esp + 14h]     ; str2

;use edi instead of esi to eliminate AGI
        mov     al,[edi]            ; al is next char from str1

        add     esi,1               ; increment pointer into str1

        cmp     al,dl
        je      first_char_found

        test    al,al               ; end of str1?
        jz      not_found           ; yes, and no match has been found

loop_start:
        mov     al,[esi]            ; put next char from str1 into al
        add     esi,1               ; increment pointer in str1
in_loop:
        cmp     al,dl
        je      first_char_found

        test    al,al               ; end of str1?
        jnz     loop_start          ; no, go get another char from str1

not_found:
        pop     esi
        pop     ebx
        pop     edi
        xor     eax,eax
        ret

; recall that dh contains the second char from str2

first_char_found:
        mov     al,[esi]            ; put next char from str1 into al
        add     esi,1

        cmp     al,dh               ; compare second chars
        jnz     in_loop             ; no match, continue search

two_first_chars_equal:
        lea     edi,[esi - 1]       ; store position of last read char in str1

compare_loop:
        mov     ah,[ecx + 2]        ; put next char from str2 into ah
        test    ah,ah               ; end of str2?
        jz      match               ; if so, then a match has been found

        mov     al,[esi]            ; get next char from str1
        add     esi,2               ; bump pointer into str1 by 2

        cmp     al,ah               ; are chars from str1 and str2 equal?
        jne     findnext            ; no

; do one more iteration

        mov     al,[ecx + 3]        ; put the next char from str2 into al
        test    al,al               ; end of str2
        jz      match               ; if so, then a match has been found

        mov     ah,[esi - 1]        ; get next char from str1
        add     ecx,2               ; bump pointer in str1 by 2
        cmp     al,ah               ; are chars from str1 and str2 equal?
        je      compare_loop

; no match. test some more chars (to improve execution time for bad strings).

        jmp     findnext

; str2 string contains only one character so it's like the strchr functioin

strchr_call:
        xor     eax,eax
        pop     esi
        pop     ebx
        pop     edi
        mov     al,dl
        jmp     __from_strstr_to_strchr

;
;
; Match!  Return (ebx - 1)
;
match:
        lea     eax,[edi - 1]
        pop     esi
        pop     ebx
        pop     edi
        ret

empty_str2:           ; empty target string, return src (ANSI mandated)
        mov     eax,edi
        pop     esi
        pop     ebx
        pop     edi
        ret

strstr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\ulldiv.asm ===
title   ulldiv - unsigned long divide routine
;***
;ulldiv.asm - unsigned long divide routine
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the unsigned long divide routine
;           __aulldiv
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;ulldiv - unsigned long divide
;
;Purpose:
;       Does a unsigned long divide of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the quotient (dividend/divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_aulldiv        PROC NEAR
.FPO (2, 4, 0, 0, 0, 0)

        push    ebx
        push    esi

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to uldiv(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;               |      EBX      |
;               |---------------|
;       ESP---->|      ESI      |
;               -----------------
;

DVND    equ     [esp + 12]      ; stack address of dividend (a)
DVSR    equ     [esp + 20]      ; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

        mov     eax,HIWORD(DVSR) ; check to see if divisor < 4194304K
        or      eax,eax
        jnz     short L1        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; get high order bits of quotient
        mov     ebx,eax         ; save high bits of quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; get low order bits of quotient
        mov     edx,ebx         ; edx:eax <- quotient hi:quotient lo
        jmp     short L2        ; restore stack and return

;
; Here we do it the hard way.  Remember, eax contains DVSRHI
;

L1:
        mov     ecx,eax         ; ecx:ebx <- divisor
        mov     ebx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L3:
        shr     ecx,1           ; shift divisor right one bit; hi bit <- 0
        rcr     ebx,1
        shr     edx,1           ; shift dividend right one bit; hi bit <- 0
        rcr     eax,1
        or      ecx,ecx
        jnz     short L3        ; loop until divisor < 4194304K
        div     ebx             ; now divide, ignore remainder
        mov     esi,eax         ; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             ; QUOT * LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L4        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L4        ; if result > original, do subtract
        jb      short L5        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L5        ; if less or equal we are ok, else subtract
L4:
        dec     esi             ; subtract 1 from quotient
L5:
        xor     edx,edx         ; edx:eax <- quotient
        mov     eax,esi

;
; Just the cleanup left to do.  edx:eax contains the quotient.
; Restore the saved registers and return.
;

L2:

        pop     esi
        pop     ebx

        ret     16

_aulldiv        ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\strspn.asm ===
page    ,132
        title   strspn - search for init substring of chars from control str
;***
;strspn.asm - find length of initial substring of chars from a control string
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strspn() - finds the length of the initial substring of
;       a string consisting entirely of characters from a control string.
;
;       defines strcspn()- finds the length of the initial substring of
;       a string consisting entirely of characters not in a control string.
;
;       defines strpbrk()- finds the index of the first character in a string
;       that is not in a control string
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int strspn(string, control) - find init substring of control chars
;
;Purpose:
;       Finds the index of the first character in string that does belong
;       to the set of characters specified by control.  This is
;       equivalent to the length of the initial substring of string that
;       consists entirely of characters from control.  The '\0' character
;       that terminates control is not considered in the matching process.
;
;       Algorithm:
;       int
;       strspn (string, control)
;               unsigned char *string, *control;
;       {
;               unsigned char map[32];
;               int count;
;
;               for (count = 0; count < 32; count++)
;                       map[count] = 0;
;               while (*control)
;               {
;                       map[*control >> 3] |= (1 << (*control & 7));
;                       control++;
;               }
;               if (*string)
;               {
;                       while (map[*string >> 3] & (1 << (*string & 7)))
;                       {
;                               count++;
;                               string++;
;                       }
;                       return(count);
;               }
;               return(0);
;       }
;
;Entry:
;       char *string - string to search
;       char *control - string containing characters not to search for
;
;Exit:
;       returns index of first char in string not in control
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;int strcspn(string, control) - search for init substring w/o control chars
;
;Purpose:
;       returns the index of the first character in string that belongs
;       to the set of characters specified by control.  This is equivalent
;       to the length of the length of the initial substring of string
;       composed entirely of characters not in control.  Null chars not
;       considered.
;
;       Algorithm:
;       int
;       strcspn (string, control)
;               unsigned char *string, *control;
;       {
;               unsigned char map[32];
;               int count;
;
;               for (count = 0; count < 32; count++)
;                       map[count] = 0;
;               while (*control)
;               {
;                       map[*control >> 3] |= (1 << (*control & 7));
;                       control++;
;               }
;               map[0] |= 1;
;               while (!(map[*string >> 3] & (1 << (*string & 7))))
;               {
;                       count++;
;                       string++;
;               }
;               return(count);
;       }
;
;Entry:
;       char *string - string to search
;       char *control - set of characters not allowed in init substring
;
;Exit:
;       returns the index of the first char in string
;       that is in the set of characters specified by control.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;char *strpbrk(string, control) - scans string for a character from control
;
;Purpose:
;       Finds the first occurence in string of any character from
;       the control string.
;
;       Algorithm:
;       char *
;       strpbrk (string, control)
;               unsigned char *string, *control;
;       {
;               unsigned char map[32];
;               int count;
;
;               for (count = 0; count < 32; count++)
;                       map[count] = 0;
;               while (*control)
;               {
;                       map[*control >> 3] |= (1 << (*control & 7));
;                       control++;
;               }
;               while (*string)
;               {
;                       if (map[*string >> 3] & (1 << (*string & 7)))
;                               return(string);
;                       string++;
;               }
;               return(NULL);
;       }
;
;Entry:
;       char *string - string to search in
;       char *control - string containing characters to search for
;
;Exit:
;       returns a pointer to the first character from control found
;       in string.
;       returns NULL if string and control have no characters in common.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


ifdef SSTRCSPN

    _STRSPN_ equ <strcspn>

elseifdef SSTRPBRK

    _STRSPN_ equ <strpbrk>

else  ; SSTRCSPN

; Default is to build strspn()

    SSTRSPN equ 1
    _STRSPN_ equ <strspn>

endif  ; SSTRCSPN

% public  _STRSPN_

    CODESEG

_STRSPN_ proc \
        uses esi, \
        string:ptr byte, \
        control:ptr byte

; create and zero out char bit map

        xor     eax,eax
        push    eax             ; 32
        push    eax
        push    eax
        push    eax             ; 128
        push    eax
        push    eax
        push    eax
        push    eax             ; 256

map     equ     [esp]

; Set control char bits in map

        mov     edx,control     ; si = control string

        align   @WordSize
lab listnext                    ; init char bit map
        mov     al,[edx]
        or      al,al
        jz      short listdone
        add     edx,1
        bts     map,eax
        jmp     short listnext

lab listdone

; Loop through comparing source string with control bits

        mov     esi,string      ; si = string

_ifnd   SSTRPBRK <or     ecx,-1> ; set ecx to -1

        align   @WordSize
lab dstnext

_ifnd   SSTRPBRK <add    ecx,1>

        mov     al,[esi]
        or      al,al
        jz      short dstdone
        add     esi,1
        bt      map, eax

ifdef SSTRSPN
        jc      short dstnext   ; strspn: found char, continue
elseifdef SSTRCSPN
        jnc     short dstnext   ; strcspn: did not find char, continue
elseifdef SSTRPBRK
        jnc     short dstnext   ; strpbrk: did not find char, continue
        lea     eax,[esi - 1]   ; found char, return address of it
endif  ; SSTRSPN

; Return code

lab dstdone

_ifnd   SSTRPBRK <mov   eax,ecx> ; strspn/strcspn: return index

        add     esp,32

        ret                     ; _cdecl return

_STRSPN_ endp
         end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\ullshr.asm ===
title   ullshr - long shift right
;***
;ullshr.asm - long shift right
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       define unsigned long shift right routine
;           __aullshr
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;ullshr - long shift right
;
;Purpose:
;       Does a unsigned Long Shift Right
;       Shifts a long right any number of bits.
;
;Entry:
;       EDX:EAX - long value to be shifted
;       CL    - number of bits to shift by
;
;Exit:
;       EDX:EAX - shifted value
;
;Uses:
;       CL is destroyed.
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_aullshr        PROC NEAR
.FPO (0, 0, 0, 0, 0, 0)

;
; Handle shifts of 64 bits or more (if shifting 64 bits or more, the result
; depends only on the high order bit of edx).
;
        cmp     cl,64
        jae     short RETZERO

;
; Handle shifts of between 0 and 31 bits
;
        cmp     cl, 32
        jae     short MORE32
        shrd    eax,edx,cl
        shr     edx,cl
        ret

;
; Handle shifts of between 32 and 63 bits
;
MORE32:
        mov     eax,edx
        xor     edx,edx
        and     cl,31
        shr     eax,cl
        ret

;
; return 0 in edx:eax
;
RETZERO:
        xor     eax,eax
        xor     edx,edx
        ret

_aullshr        ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\gcroot.h ===
/***
*gcroot.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:  Template class that wraps GCHandle from mscorlib.dll.
*
*       Use this class to declare gc "pointers" that live in the C++ heap.
*
*       Example:
*               struct StringList {
*                       msclr::gcroot<String^> str;
*                       StringList *next;
*                       StringList(); // should have ctors and dtors
*                       ~StringList();
*               };
*
*       By convention, we maintain a 1-to-1 relationship between C++ objects
*       and the handle slots they "point" to.  Thus, two distinct C++ objects
*       always refer to two distinct handles, even if they "point" to the same
*       object.  Therefore, when the C++ object is destroyed, its handle can
*       be freed without error.
*
*       Note that we cannot currently embed a GCHandle directly in an unmanaged C++
*       class.  We therefore store a void*, and use the conversion methods of
*       GCHandle to reconstitute a GCHandle from the void* on demand.
*
*   [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_GCROOT)
#define _INC_MSCLR_GCROOT
#ifndef RC_INVOKED

#include <stddef.h>


#ifdef __cplusplus_cli
 #define __GCHANDLE_TO_VOIDPTR(x) ((GCHandle::operator System::IntPtr(x)).ToPointer())
 #define __VOIDPTR_TO_GCHANDLE(x) (GCHandle::operator GCHandle(System::IntPtr(x)))
 #define __NULLPTR nullptr
#else  /* __cplusplus_cli */
 #define __GCHANDLE_TO_VOIDPTR(x) ((GCHandle::op_Explicit(x)).ToPointer())
 #define __VOIDPTR_TO_GCHANDLE(x) (GCHandle::op_Explicit(x))
 #define __NULLPTR 0
#endif  /* __cplusplus_cli */

#ifndef __DEFINE_GCROOT_IN_GLOBAL_NAMESPACE
namespace msclr
{
#endif  /* __DEFINE_GCROOT_IN_GLOBAL_NAMESPACE */

template <class T> struct gcroot {

        typedef System::Runtime::InteropServices::GCHandle GCHandle;

        // always allocate a new handle during construction (see above)
        //
    // Initializes to a NULL handle, which is always safe
        [System::Diagnostics::DebuggerStepThroughAttribute]
    [System::Security::SecuritySafeCritical]
        gcroot() {
                _handle = __GCHANDLE_TO_VOIDPTR(GCHandle::Alloc(__NULLPTR));
        }

        // this can't be T& here because & does not yet work on managed types
        // (T should be a pointer anyway).
        //
        gcroot(T t) {
                _handle = __GCHANDLE_TO_VOIDPTR(GCHandle::Alloc(t));
        }

        gcroot(const gcroot& r) {
                // don't copy a handle, copy what it points to (see above)
                _handle = __GCHANDLE_TO_VOIDPTR(
                                                GCHandle::Alloc(
                                                        __VOIDPTR_TO_GCHANDLE(r._handle).Target ));
        }

        // Since C++ objects and handles are allocated 1-to-1, we can
        // free the handle when the object is destroyed
        //
        [System::Diagnostics::DebuggerStepThroughAttribute]
    [System::Security::SecurityCritical]
        ~gcroot() {
                GCHandle g = __VOIDPTR_TO_GCHANDLE(_handle);
                g.Free();
                _handle = 0; // should fail if reconstituted
        }

        [System::Diagnostics::DebuggerStepThroughAttribute]
    [System::Security::SecurityCritical]
        gcroot& operator=(T t) {
                // no need to check for valid handle; was allocated in ctor
                __VOIDPTR_TO_GCHANDLE(_handle).Target = t;
                return *this;
        }

        gcroot& operator=(const gcroot &r) {
                // no need to check for valid handle; was allocated in ctor
                T t = (T)r;
                __VOIDPTR_TO_GCHANDLE(_handle).Target = t;
                return *this;
        }

        void swap( gcroot<T> & _right )
        {
                using std::swap;
                swap( _handle, _right._handle );
        }

    // The managed object is not a secret or protected resource, so its okay to expose to anyone who has access to the gcroot object
    [System::Security::SecuritySafeCritical]
    operator T () const {
                // gcroot is typesafe, so use static_cast
                return static_cast<T>( __VOIDPTR_TO_GCHANDLE(_handle).Target );
        }

        // don't return T& here because & to gc pointer not yet implemented
        // (T should be a pointer anyway).
    [System::Security::SecuritySafeCritical]
        T operator->() const {
                // gcroot is typesafe, so use static_cast
                return static_cast<T>(__VOIDPTR_TO_GCHANDLE(_handle).Target);
        }

private:
        // Don't let anyone copy the handle value directly, or make a copy
        // by taking the address of this object and pointing to it from
        // somewhere else.  The root will be freed when the dtor of this
        // object gets called, and anyone pointing to it still will
        // cause serious harm to the Garbage Collector.
        //
        void* _handle;
        T* operator& ();
};

template<typename T>
void swap( gcroot<T> & _left,
        gcroot<T> & _right )
{
        _left.swap( _right );
}

#ifndef __DEFINE_GCROOT_IN_GLOBAL_NAMESPACE
} // namespace msclr
#endif  /* __DEFINE_GCROOT_IN_GLOBAL_NAMESPACE */

#undef __GCHANDLE_TO_VOIDPTR
#undef __VOIDPTR_TO_GCHANDLE
#undef __NULLPTR

#endif  /* RC_INVOKED */
#endif  /* !defined (_INC_MSCLR_GCROOT) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\lock.h ===
/***
*lock.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   lock class for automatically acquiring/releasing
*           the monitor lock on managed types.
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_LOCK)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#using <mscorlib.dll>
#include <msclr\safebool.h>
#if !defined (_M_CEE_SAFE)
#include <vcclr.h>
#endif  /* !defined (_M_CEE_SAFE) */

namespace msclr
{

    // The lock_when enumeration is used to defer the lock object
    // from taking the lock.
    enum lock_when { lock_later };

    ref class lock
    {
    private:
        System::Object ^ m_object;
        bool             m_locked;

        template<class T,class U> value struct is_not { typedef int __dont_use_this_type__; };
        template<class T> value struct is_not<T,T> { };

    public:
        // By default, take the lock immediately with an infinite timeout.
        // Accept an optional timespan (in milliseconds) and throw on failure or timeout.
        template<class T> lock( T ^ _object)
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;

            acquire(System::Threading::Timeout::Infinite);
        }

        template<class T> lock( T ^ _object, int _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;

            acquire( _timeout );
        }

        // By default, take the lock immediately within the specified timespan
        // and throw on failure or timeout.
        template<class T> lock( T ^ _object, System::TimeSpan _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;

            acquire( _timeout );
        }

        // If you use the "lock_later" enumeration, it causes lock
        // to defer taking the lock.
        template<class T> lock( T ^ _object, lock_when )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
        }

#if !defined (_M_CEE_SAFE)
        template<class T> lock( gcroot<T ^> _object)
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;

            acquire(System::Threading::Timeout::Infinite);
        }


        template<class T> lock( gcroot<T ^> _object, int _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;

            acquire( _timeout );
        }

        // By default, take the lock immediately within the specified timespan
        // and throw on failure or timeout.
        template<class T> lock( gcroot<T ^> _object, System::TimeSpan _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;

            acquire( _timeout );
        }

        // If you use the "lock_later" enumeration, it causes lock
        // to defer taking the lock.
        template<class T> lock( gcroot<T ^> _object, lock_when )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            typedef is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
        }
#endif  /* !defined (_M_CEE_SAFE) */

        // release the lock if it is not currently held
        ~lock()
        {
            release();
        }

        // Check to see if this lock object is currently holding the lock
        bool is_locked()
        {
            return m_locked;
        }

        // Check to see if this lock object is currently holding the lock
        operator _detail_class::_safe_bool()
        {
            return is_locked() ? _detail_class::_safe_true : _detail_class::_safe_false;
        }

        // disallow explicit comparisons to _safe_bool
        template<class T> bool operator==( T t )
        {
            // ensure that T is not a _safe_bool.
            typedef is_not<T, _detail_class::_safe_bool>::__dont_use_this_type__ _Diagnostic;

            return m_object == t;
        }

        template<class T> bool operator!=( T t )
        {
            // ensure that T is not a _safe_bool.
            typedef is_not<T, _detail_class::_safe_bool>::__dont_use_this_type__ _Diagnostic;

            return m_object != t;
        }

        // Take the lock within the specified timespan, or with an infinite
        // timespan if none is specified. Throw on timeout
        void acquire( int _timeout )
        {
            if( ! m_locked )
            {
                System::Threading::Monitor::TryEnter( m_object, _timeout, m_locked );
                if( ! m_locked )
                {
                    static const long _hresult_wait_timeout = 0x80070102;
                    throw System::Runtime::InteropServices::Marshal::GetExceptionForHR( _hresult_wait_timeout );
                }
            }
        }

        void acquire()
        {
            if( ! m_locked )
            {
                System::Threading::Monitor::TryEnter( m_object,
                          System::Threading::Timeout::Infinite, m_locked );
                if( ! m_locked )
                {
                    static const long _hresult_wait_timeout = 0x80070102;
                    throw System::Runtime::InteropServices::Marshal::GetExceptionForHR( _hresult_wait_timeout );
                }
            }
        }

        // Take the lock within the specified timespan.
        // throw on timeout
        void acquire( System::TimeSpan _timeout )
        {
            if( ! m_locked )
            {
                System::Threading::Monitor::TryEnter( m_object, _timeout, m_locked );
                if( ! m_locked )
                {
                    static const long _hresult_wait_timeout = 0x80070102;
                    throw System::Runtime::InteropServices::Marshal::GetExceptionForHR( _hresult_wait_timeout );
                }
            }
        }

        // Try to take the lock within the specified timespan. In the case
        // of timeout, return false.
        bool try_acquire( int _timeout ) // throw()
        {
            if( ! m_locked )
            {
                System::Threading::Monitor::TryEnter( m_object, _timeout, m_locked );
                if( ! m_locked )
                {
                    return false;
                }
            }
            return true;
        }

        // Try to take the lock within the specified timespan. In the case
        // of timeout, return false.
        bool try_acquire( System::TimeSpan _timeout ) // throw()
        {
            if( ! m_locked )
            {
                System::Threading::Monitor::TryEnter( m_object, _timeout, m_locked );
                if( ! m_locked )
                {
                    return false;
                }
            }
            return true;
        }

        // Release the lock if it is currently held
        void release()
        {
            if( m_locked )
            {
                System::Threading::Monitor::Exit( m_object );
                m_locked = false;
            }
        }
    };
}

#define _INC_MSCLR_LOCK

#endif  /* !defined (_INC_MSCLR_LOCK) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\auto_gcroot.h ===
/***
*auto_gcroot.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   automatic resource management, like std::auto_ptr which can be used
*           to embed a virtual handle into a native type
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_AUTO_GCROOT)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#include <vcclr.h>
#include <msclr\safebool.h>
#include <algorithm>

namespace msclr
{

// Forward Declaration
template<typename _element_type>
class auto_gcroot;

namespace _detail
{

// _auto_gcroot_ref is a proxy reference for auto_gcroot copying.
// auto_gcroot's copy constructor takes a non-const reference
// because it must assume ownership from the source. But this
// makes it impossible for auto_gcroot to be returned by value,
// because temporary objects cannot be bound to non-const
// references. Instead, a conversion to _auto_gcroot_ref is provided,
// and an auto_gcroot can be initialized from an _auto_gcroot_ref.

    template<typename _element_type>
    struct _auto_gcroot_ref
    {
        // construct from compatible auto_gcroot
        _auto_gcroot_ref( auto_gcroot<_element_type> & ref )
            : m_ref( ref )
        {
        }

        // reference to constructor argument
        auto_gcroot<_element_type> & m_ref;

    };

} // namespace detail

// wrap a resource to enforce strict ownership and ensure proper cleanup
template<typename _element_type>
class auto_gcroot
{
private:
    // disallow explicit comparisons to _safe_bool
    bool operator==( _detail_class::_safe_bool ) const;
    bool operator!=( _detail_class::_safe_bool ) const;

public:

    // Constructors

    // construct from object pointer
    auto_gcroot( _element_type _ptr = nullptr )
        : m_ptr( _ptr )
    {
    }

    // construct by assuming pointer from _right auto_gcroot
    auto_gcroot( auto_gcroot<_element_type> & _right )
            : m_ptr( _right.release() )
    {
    }

    // construct by assuming pointer from _right _detail::_auto_gcroot_ref
    auto_gcroot( _detail::_auto_gcroot_ref<_element_type> _right )
        : m_ptr( _right.m_ref.release() )
    {
    }

    template<typename _other_type>
    auto_gcroot( auto_gcroot<_other_type> & _right )
        : m_ptr( _right.release() )
    {
    }

    auto_gcroot<_element_type> & attach(_element_type _right)
    {
        reset(_right);
        return *this;
    }

    // assign compatible _right
    auto_gcroot<_element_type> & attach(
        auto_gcroot<_element_type> & _right )
    {
        reset( _right.release() );
        return *this;
    }

    // assign compatible _right.ref
    auto_gcroot<_element_type> & attach(
        _detail::_auto_gcroot_ref<_element_type> & _right )
    {
        reset( _right.m_ref.release() );
        return *this;
    }

    template<typename _other_type>
    auto_gcroot<_element_type> & attach(
    auto_gcroot<_other_type> & _right )
    {
        reset( _right.release() );
        return *this;
    }

    auto_gcroot<_element_type> & operator=(_element_type _right)
    {
        return attach(_right);
    }

    // assign compatible _right
    auto_gcroot<_element_type> & operator=(
        auto_gcroot<_element_type> & _right )
    {
        return attach(_right);
    }

    // assign compatible _right.ref
    auto_gcroot<_element_type> & operator=(
        _detail::_auto_gcroot_ref<_element_type> & _right )
    {
        return attach(_right);
    }

    template<typename _other_type>
    auto_gcroot<_element_type> & operator=(
    auto_gcroot<_other_type> & _right )
    {
        return attach(_right);
    }

    _element_type get() const
    {
        return m_ptr;
    }

    // return pointer to class object (assume pointer)
    _element_type operator->() const
    {
        return m_ptr;
    }

    // for use when auto_gcroot appears in a conditional
    operator _detail_class::_safe_bool() const
    {
        return valid() ? _detail_class::_safe_true : _detail_class::_safe_false;
    }

    // for use when auto_gcroot appears in a conditional
    bool operator!() const
    {
        return ! valid();
    }

    // convert to compatible _detail::_auto_gcroot_ref
    operator _detail::_auto_gcroot_ref<_element_type>()
    {
        return _detail::_auto_gcroot_ref<_element_type>( *this );
    }

    template<typename _other_type>
    operator auto_gcroot<_other_type>()
    {
        return auto_gcroot<_other_type>( *this );
    }

    template<typename _other_type>
    operator _detail::_auto_gcroot_ref<_other_type>()
    {
        return _detail::_auto_gcroot_ref<_other_type>( *this );
    }

    void swap( auto_gcroot<_element_type> & _right )
    {
        m_ptr.swap( _right.m_ptr );
    }

    void reset( _element_type _new_ptr = nullptr )
    {
        if( _element_type(m_ptr) != _new_ptr )
        {
            if( valid() )
            {
                delete _element_type(m_ptr);
            }
            m_ptr = _new_ptr;
        }
    }

    _element_type release()
    {
        _element_type _tmp_ptr = m_ptr;
        m_ptr = nullptr;
        return _tmp_ptr;
    }

    // destroy the object
    ~auto_gcroot()
    {
        if( valid() )
        {
            delete _element_type(m_ptr);
        }
    }

private:

    bool valid() const
    {
        // see if the managed resource is in the invalid state.
        return _element_type(m_ptr) != nullptr;
    }

    // the wrapped object
    gcroot<_element_type> m_ptr;
};

// swap the contents of two auto_gcroot objects
template<typename _element_type>
void swap( auto_gcroot<_element_type> & _left,
           auto_gcroot<_element_type> & _right )
{
    _left.swap( _right );
}

} // namespace msclr

#define _INC_MSCLR_AUTO_GCROOT

#endif  /* !defined (_INC_MSCLR_AUTO_GCROOT) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\intel\_strnicm.asm ===
page    ,132
        title   strnicmp - compare n chars of strings, ignore case
;***
;strnicmp.asm - compare n chars of strings, ignoring case
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines __ascii_strnicmp() - Compares at most n characters of two
;       strings, without regard to case.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_strnicmp(first, last, count) - compares count char of strings,
;       ignore case
;
;Purpose:
;       Compare the two strings for lexical order.  Stops the comparison
;       when the following occurs: (1) strings differ, (2) the end of the
;       strings is reached, or (3) count characters have been compared.
;       For the purposes of the comparison, upper case characters are
;       converted to lower case.
;
;       Algorithm:
;       int
;       _strncmpi (first, last, count)
;             char *first, *last;
;             unsigned int count;
;             {
;             int f,l;
;             int result = 0;
;
;             if (count) {
;                     do      {
;                             f = tolower(*first);
;                             l = tolower(*last);
;                             first++;
;                             last++;
;                             } while (--count && f && l && f == l);
;                     result = f - l;
;                     }
;             return(result);
;             }
;
;Entry:
;       char *first, *last - strings to compare
;       unsigned count - maximum number of characters to compare
;
;Exit:
;       returns <0 if first < last
;       returns 0 if first == last
;       returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_strnicmp
__ascii_strnicmp proc \
        uses edi esi ebx, \
        first:ptr byte, \
        last:ptr byte, \
        count:IWORD

        mov     ecx,[count]     ; cx = byte count
        or      ecx,ecx
        jz      toend           ; if count = 0, we are done

        mov     esi,[first]     ; si = first string
        mov     edi,[last]      ; di = last string

        mov     bh,'A'
        mov     bl,'Z'
        mov     dh,'a'-'A'      ; add to cap to make lower

        align   4

lupe:
        mov     ah,[esi]        ; *first

        or      ah,ah           ; see if *first is null

        mov     al,[edi]        ; *last

        jz      short eject     ;   jump if *first is null

        or      al,al           ; see if *last is null
        jz      short eject     ;   jump if so

        add     esi,1           ; first++
        add     edi,1           ; last++

        cmp     ah,bh           ; 'A'
        jb      short skip1

        cmp     ah,bl           ; 'Z'
        ja      short skip1

        add     ah,dh           ; make lower case

skip1:
        cmp     al,bh           ; 'A'
        jb      short skip2

        cmp     al,bl           ; 'Z'
        ja      short skip2

        add     al,dh           ; make lower case

skip2:
        cmp     ah,al           ; *first == *last ??
        jne     short differ

        sub     ecx,1
        jnz     short lupe

eject:
        xor     ecx,ecx
        cmp     ah,al           ; compare the (possibly) differing bytes
        je      short toend     ; both zero; return 0

differ:
        mov     ecx,-1          ; assume last is bigger (* can't use 'or' *)
        jb      short toend     ; last is, in fact, bigger (return -1)
        neg     ecx             ; first is bigger (return 1)

toend:
        mov     eax,ecx

        ret                     ; _cdecl return

__ascii_strnicmp endp
         end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\all.h ===
/***
*all.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Header file to include all MSL functionality
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_ALL)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#include <msclr\appdomain.h>
#include <msclr\auto_gcroot.h>
#include <msclr\auto_handle.h>
#include <msclr\event.h>
#include <msclr\lock.h>
#include <msclr\gcroot.h>
#include <msclr\com\ptr.h>

#define _INC_MSCLR_ALL

#endif  /* !defined (_INC_MSCLR_ALL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\event.h ===
/***
*event.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   delegate_proxy_factory class
*
*       [Public]
*
****/

#pragma once

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#include <gcroot.h>

namespace msclr {
    namespace delegate_map {
        namespace internal {

        template <typename CLASS> class delegate_proxy_factory
        {
            typedef typename CLASS::delegate_proxy_type proxy_type;
            gcroot<proxy_type^> m_gc_managed_native_delegate_proxy;

            public:
            delegate_proxy_factory() {}

            virtual ~delegate_proxy_factory()
            {
                if((proxy_type^)m_gc_managed_native_delegate_proxy != nullptr)
                {
                    m_gc_managed_native_delegate_proxy->detach();
                }
            }

            proxy_type^ get_proxy(CLASS* pNativeTarget)
            {
                if((proxy_type^)m_gc_managed_native_delegate_proxy == nullptr)
                {
                    m_gc_managed_native_delegate_proxy = gcnew proxy_type(pNativeTarget);
                }
                return (proxy_type^)m_gc_managed_native_delegate_proxy;
            }
        };

        }
    }
}


#define BEGIN_DELEGATE_MAP(CLASS)\
        ref class delegate_proxy_type;\
        msclr::delegate_map::internal::delegate_proxy_factory<CLASS> m_delegate_map_proxy;\
        \
        ref class delegate_proxy_type\
        {\
                CLASS* m_p_native_target;\
        public:\
                delegate_proxy_type(CLASS* pNativeTarget) : m_p_native_target(pNativeTarget) {}\
                void detach() { m_p_native_target = NULL; }

#define EVENT_DELEGATE_ENTRY(MEMBER,ARG0,ARG1)\
        void MEMBER(ARG0 arg0,ARG1 arg1)\
        {\
                if(m_p_native_target == NULL)\
                throw gcnew System::ArgumentNullException("Delegate call failed: Native sink was not attached or has already detached from the managed proxy (m_p_native_target == NULL). Hint: see if native sink was destructed or not constructed properly");\
                \
                m_p_native_target->MEMBER(arg0,arg1);\
        }

#define END_DELEGATE_MAP()\
        };

#define MAKE_DELEGATE(DELEGATE,MEMBER)\
        gcnew DELEGATE(m_delegate_map_proxy.get_proxy(this),&delegate_proxy_type::MEMBER)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\auto_handle.h ===
/***
*auto_handle.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   automatic resource management, like std::auto_ptr for ref classes
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_AUTO_HANDLE)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#include <msclr\safebool.h>

namespace msclr
{

    // wrap a resource to enforce strict ownership and ensure proper cleanup
    template<typename _element_type>
    ref class auto_handle
    {
    private:
        // disallow explicit comparisons to _safe_bool
        bool operator==( _detail_class::_safe_bool );
        bool operator!=( _detail_class::_safe_bool );

    public:

        // Constructors

        auto_handle()
            : m_handle( nullptr )
        {
        }

        // construct from object pointer
        auto_handle( _element_type ^ _ptr )
            : m_handle( _ptr )
        {
        }

        // construct by assuming pointer from _right auto_handle
        auto_handle(auto_handle<_element_type> % _right )
                : m_handle( _right.release() )
        {
        }

        template<typename _other_type>
        auto_handle( auto_handle<_other_type> % _right )
                : m_handle( _right.release() )
        {
        }

        // assign compatible _right
        auto_handle<_element_type> % operator=(
            auto_handle<_element_type> % _right )
        {
            reset( _right.release() );
            return *this;
        }


        template<typename _other_type>
        auto_handle<_element_type> % operator=(
            auto_handle<_other_type> % _right )
        {
            reset( _right.release() );
            return *this;
        }

        _element_type ^ get()
        {
            return m_handle;
        }

        // return pointer to class object (assume pointer)
        _element_type ^ operator->()
        {
            return m_handle;
        }

        // for use when auto_handle appears in a conditional
        operator _detail_class::_safe_bool()
        {
            return valid() ? _detail_class::_safe_true : _detail_class::_safe_false;
        }

        // for use when auto_handle appears in a conditional
        bool operator!()
        {
            return ! valid();
        }


        template<typename _other_type>
        operator auto_handle<_other_type>()
        {
            return auto_handle<_other_type>( *this );
        }

        void swap( auto_handle<_element_type> % _right )
        {
                        auto_handle<_element_type> tmp = _right;
                        _right = *this;
                        *this = tmp;
        }

        void reset( _element_type ^ _new_ptr )
        {
            if( m_handle != _new_ptr )
            {
                if( valid() )
                {
                    delete m_handle;
                }
                m_handle = _new_ptr;
            }
        }

        void reset( )
        {
            reset(nullptr);
        }

        _element_type ^ release()
        {
            _element_type ^_tmp_ptr = m_handle;
            m_handle = nullptr;
            return _tmp_ptr;
        }

        // destroy the object
        ~auto_handle()
        {
            if( valid() )
            {
                delete m_handle;
            }
        }

        private:

        bool valid()
        {
            // see if the managed resource is in the invalid state.
            return m_handle != nullptr;

        }

        // the wrapped object
        _element_type ^ m_handle;
    };

    // swap the contents of two auto_handle objects
    template<typename _element_type>
    void swap( auto_handle<_element_type> % _left,
               auto_handle<_element_type> % _right )
    {
        _left.swap( _right );
    }

} // namespace msclr

#define _INC_MSCLR_AUTO_HANDLE

#endif  /* !defined (_INC_MSCLR_AUTO_HANDLE) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\appdomain.h ===
/***
*appdomain.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Utitily for cross App Domain Calls
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_APPDOMAIN)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries require /clr and are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#ifdef _M_CEE_PURE
#error ERROR: msclr appdomain helpers can only be used in mixed mode. Use a cross-domain delegate in pure mode
#endif  /* _M_CEE_PURE */
#include <mscoree.h>
#include <crtdbg.h>

#if defined (_M_IX86)
#define _MSCLR_STDCALL_DISTINCT 1
#elif defined (_M_IA64)
#define _MSCLR_STDCALL_DISTINCT 0
#elif defined (_M_AMD64)
#define _MSCLR_STDCALL_DISTINCT 0
#else  /* defined (_M_AMD64) */
#error Need to add setting for different CPU
#endif  /* defined (_M_AMD64) */

namespace msclr
{

namespace _detail
{

/* helper functions */

inline
void validate(HRESULT hr)
{
    _ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(hr);
    }
}

inline
System::Guid FromGUID(GUID const & guid)
{
   return System::Guid( guid.Data1, guid.Data2, guid.Data3,
                        guid.Data4[ 0 ], guid.Data4[ 1 ],
                        guid.Data4[ 2 ], guid.Data4[ 3 ],
                        guid.Data4[ 4 ], guid.Data4[ 5 ],
                        guid.Data4[ 6 ], guid.Data4[ 7 ] );
}

inline
ICLRRuntimeHost *get_clr_runtime_host(void)
{
    using System::Runtime::InteropServices::RuntimeEnvironment;

    // Throws HR exception on failure.
    ICLRRuntimeHost *pClrHost = NULL;
    pClrHost = reinterpret_cast<ICLRRuntimeHost*>(
        RuntimeEnvironment::GetRuntimeInterfaceAsIntPtr(
            FromGUID(CLSID_CLRRuntimeHost), FromGUID(IID_ICLRRuntimeHost)).ToPointer());

    return pClrHost;
}

/* callback struct */

/* __stdcall version */

#if _MSCLR_STDCALL_DISTINCT

template <typename RetType>
struct callback_stdcall_struct0
{
    RetType (__stdcall *func)();
    RetType retValue;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct0 *pcs = (callback_stdcall_struct0*)cookie;
        pcs->retValue = pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1>
struct callback_stdcall_struct1
{
    RetType (__stdcall *func)(ArgType1);
    RetType retValue;
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct1 *pcs = (callback_stdcall_struct1*)cookie;
        pcs->retValue = pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2>
struct callback_stdcall_struct2
{
    RetType (__stdcall *func)(ArgType1, ArgType2);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct2 *pcs = (callback_stdcall_struct2*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_stdcall_struct3
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct3 *pcs = (callback_stdcall_struct3*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_stdcall_struct4
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct4 *pcs = (callback_stdcall_struct4*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_stdcall_struct5
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct5 *pcs = (callback_stdcall_struct5*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_stdcall_struct6
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct6 *pcs = (callback_stdcall_struct6*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_stdcall_struct7
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct7 *pcs = (callback_stdcall_struct7*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_stdcall_struct8
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct8 *pcs = (callback_stdcall_struct8*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_stdcall_struct9
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct9 *pcs = (callback_stdcall_struct9*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_stdcall_struct10
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct10 *pcs = (callback_stdcall_struct10*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_stdcall_struct11
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct11 *pcs = (callback_stdcall_struct11*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_stdcall_struct12
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct12 *pcs = (callback_stdcall_struct12*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_stdcall_struct13
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct13 *pcs = (callback_stdcall_struct13*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_stdcall_struct14
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct14 *pcs = (callback_stdcall_struct14*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_stdcall_struct15
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct15 *pcs = (callback_stdcall_struct15*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
        return hr;
    }
};

struct callback_stdcall_void_struct0
{
    void (__stdcall *func)();

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct0 *pcs = (callback_stdcall_void_struct0*)cookie;
        pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1>
struct callback_stdcall_void_struct1
{
    void (__stdcall * func)(ArgType1);
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct1 *pcs = (callback_stdcall_void_struct1*)cookie;
        pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2>
struct callback_stdcall_void_struct2
{
    void (__stdcall * func)(ArgType1, ArgType2);
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct2 *pcs = (callback_stdcall_void_struct2*)cookie;
        pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_stdcall_void_struct3
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct3 *pcs = (callback_stdcall_void_struct3*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_stdcall_void_struct4
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct4 *pcs = (callback_stdcall_void_struct4*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_stdcall_void_struct5
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct5 *pcs = (callback_stdcall_void_struct5*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_stdcall_void_struct6
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct6 *pcs = (callback_stdcall_void_struct6*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_stdcall_void_struct7
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct7 *pcs = (callback_stdcall_void_struct7*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_stdcall_void_struct8
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct8 *pcs = (callback_stdcall_void_struct8*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_stdcall_void_struct9
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct9 *pcs = (callback_stdcall_void_struct9*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_stdcall_void_struct10
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct10 *pcs = (callback_stdcall_void_struct10*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_stdcall_void_struct11
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct11 *pcs = (callback_stdcall_void_struct11*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_stdcall_void_struct12
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct12 *pcs = (callback_stdcall_void_struct12*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_stdcall_void_struct13
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct13 *pcs = (callback_stdcall_void_struct13*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_stdcall_void_struct14
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct14 *pcs = (callback_stdcall_void_struct14*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_stdcall_void_struct15
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct15 *pcs = (callback_stdcall_void_struct15*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
        return hr;
    }
};

#endif  /* _MSCLR_STDCALL_DISTINCT */

/* __cdecl version */

template <typename RetType>
struct callback_cdecl_struct0
{
    RetType (__cdecl *func)();
    RetType retValue;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct0 *pcs = (callback_cdecl_struct0*)cookie;
        pcs->retValue = pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1>
struct callback_cdecl_struct1
{
    RetType (__cdecl *func)(ArgType1);
    RetType retValue;
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct1 *pcs = (callback_cdecl_struct1*)cookie;
        pcs->retValue = pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2>
struct callback_cdecl_struct2
{
    RetType (__cdecl *func)(ArgType1, ArgType2);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct2 *pcs = (callback_cdecl_struct2*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_cdecl_struct3
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct3 *pcs = (callback_cdecl_struct3*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_cdecl_struct4
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct4 *pcs = (callback_cdecl_struct4*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_cdecl_struct5
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct5 *pcs = (callback_cdecl_struct5*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_cdecl_struct6
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct6 *pcs = (callback_cdecl_struct6*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_cdecl_struct7
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct7 *pcs = (callback_cdecl_struct7*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_cdecl_struct8
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct8 *pcs = (callback_cdecl_struct8*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_cdecl_struct9
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct9 *pcs = (callback_cdecl_struct9*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_cdecl_struct10
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct10 *pcs = (callback_cdecl_struct10*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_cdecl_struct11
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct11 *pcs = (callback_cdecl_struct11*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_cdecl_struct12
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct12 *pcs = (callback_cdecl_struct12*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_cdecl_struct13
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct13 *pcs = (callback_cdecl_struct13*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_cdecl_struct14
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct14 *pcs = (callback_cdecl_struct14*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_cdecl_struct15
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct15 *pcs = (callback_cdecl_struct15*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
        return hr;
    }
};

struct callback_cdecl_void_struct0
{
    void (__cdecl *func)();

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct0 *pcs = (callback_cdecl_void_struct0*)cookie;
        pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1>
struct callback_cdecl_void_struct1
{
    void (__cdecl * func)(ArgType1);
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct1 *pcs = (callback_cdecl_void_struct1*)cookie;
        pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2>
struct callback_cdecl_void_struct2
{
    void (__cdecl * func)(ArgType1, ArgType2);
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct2 *pcs = (callback_cdecl_void_struct2*)cookie;
        pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_cdecl_void_struct3
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct3 *pcs = (callback_cdecl_void_struct3*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_cdecl_void_struct4
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct4 *pcs = (callback_cdecl_void_struct4*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_cdecl_void_struct5
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct5 *pcs = (callback_cdecl_void_struct5*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_cdecl_void_struct6
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct6 *pcs = (callback_cdecl_void_struct6*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_cdecl_void_struct7
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct7 *pcs = (callback_cdecl_void_struct7*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_cdecl_void_struct8
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct8 *pcs = (callback_cdecl_void_struct8*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_cdecl_void_struct9
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct9 *pcs = (callback_cdecl_void_struct9*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_cdecl_void_struct10
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct10 *pcs = (callback_cdecl_void_struct10*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_cdecl_void_struct11
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct11 *pcs = (callback_cdecl_void_struct11*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_cdecl_void_struct12
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct12 *pcs = (callback_cdecl_void_struct12*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_cdecl_void_struct13
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct13 *pcs = (callback_cdecl_void_struct13*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_cdecl_void_struct14
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct14 *pcs = (callback_cdecl_void_struct14*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_cdecl_void_struct15
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct15 *pcs = (callback_cdecl_void_struct15*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
                return hr;
        }
};

} // namespace _detail

/* __stdcall version */
#if _MSCLR_STDCALL_DISTINCT

template <typename RetType>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct0<RetType> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct1<RetType, ArgType1> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct2<RetType, ArgType1, ArgType2> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct3<RetType, ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct4<RetType, ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct5<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct6<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct7<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct8<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct9<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct10<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct11<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct12<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct13<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct14<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct15<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct0 cs;

    // fill up the callback_stdcall_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct1<ArgType1> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct2<ArgType1, ArgType2> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct3<ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct4<ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct5<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct6<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct7<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct8<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct9<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct10<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct11<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct12<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct13<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct14<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct15<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

#endif  /* _MSCLR_STDCALL_DISTINCT */

/* __cdecl version */

template <typename RetType>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct0<RetType> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct1<RetType, ArgType1> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct2<RetType, ArgType1, ArgType2> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct3<RetType, ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct4<RetType, ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct5<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct6<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct7<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct8<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct9<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct10<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct11<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct12<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct13<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct14<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct15<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);

    return cs.retValue;
}

void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct0 cs;

    // fill up the callback_cdecl_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct1<ArgType1> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct2<ArgType1, ArgType2> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct3<ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct4<ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct5<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct6<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct7<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct8<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct9<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct10<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct11<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct12<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct13<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct14<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct15<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

} // namespace msclr

#define _INC_MSCLR_APPDOMAIN

#endif  /* !defined (_INC_MSCLR_APPDOMAIN) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\stat.inl ===
/***
*stat.inl - inline definitions for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function definitions for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#pragma once

#if !defined (__CRTDECL)
#if defined (_M_CEE_PURE)
#define __CRTDECL
#else  /* defined (_M_CEE_PURE) */
#define __CRTDECL   __cdecl
#endif  /* defined (_M_CEE_PURE) */
#endif  /* !defined (__CRTDECL) */

#ifndef _INC_STAT_INL
#define _INC_STAT_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif  /* _STATIC_ASSERT */

#if !__STDC__

/* Non-ANSI names for compatibility */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL fstat(int _Desc, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat32) );
    return _fstat32(_Desc,(struct _stat32 *)_Stat);
}
static __inline int __CRTDECL stat(const char * _Filename, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat32) );
    return _stat32(_Filename,(struct _stat32 *)_Stat);
}
#else  /* _USE_32BIT_TIME_T */
static __inline int __CRTDECL fstat(int _Desc, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
    return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);
}
static __inline int __CRTDECL stat(const char * _Filename, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
    return _stat64i32(_Filename,(struct _stat64i32 *)_Stat);
}
#endif  /* _USE_32BIT_TIME_T */
#endif  /* !__STDC__ */

#endif  /* _INC_STAT_INL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_TIMEB
#define _INC_TIMEB

#include <crtdefs.h>

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#pragma pack(push,_CRT_PACKING)

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#if !defined (_W64)
#if !defined (__midl) && (defined (_X86_) || defined (_M_IX86))
#define _W64 __w64
#else  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#define _W64
#endif  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#endif  /* !defined (_W64) */

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif  /* _TIME32_T_DEFINED */

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif  /* _TIME64_T_DEFINED */

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else  /* _USE_32BIT_TIME_T */
typedef __time64_t time_t;      /* time value */
#endif  /* _USE_32BIT_TIME_T */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif  /* _TIME_T_DEFINED */

/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct __timeb32 {
        __time32_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if !__STDC__

/* Non-ANSI name for compatibility */
struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };


#endif  /* !__STDC__ */

struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#ifdef _USE_32BIT_TIME_T

#define _timeb      __timeb32
#define _ftime      _ftime32
#define _ftime_s    _ftime32_s

#else  /* _USE_32BIT_TIME_T */

#define _timeb      __timeb64
#define _ftime      _ftime64
#define _ftime_s    _ftime64_s

#endif  /* _USE_32BIT_TIME_T */
#define _TIMEB_DEFINED
#endif  /* _TIMEB_DEFINED */

#include <crtdefs.h>

/* Function prototypes */

_CRT_INSECURE_DEPRECATE(_ftime32_s) _CRTIMP void __cdecl _ftime32(_Out_ struct __timeb32 * _Time);
_CRTIMP errno_t __cdecl _ftime32_s(_Out_ struct __timeb32 * _Time);
_CRT_INSECURE_DEPRECATE(_ftime64_s) _CRTIMP void __cdecl _ftime64(_Out_ struct __timeb64 * _Time);
_CRTIMP errno_t __cdecl _ftime64_s(_Out_ struct __timeb64 * _Time);

#if !defined (RC_INVOKED) && !defined (__midl)
#include <sys/timeb.inl>
#endif  /* !defined (RC_INVOKED) && !defined (__midl) */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#pragma pack(pop)

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\com\ptr.h ===
/***
*ptr.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   COM Wrapper for the Managed World
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_COM_PTR)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

#include <vcclr.h>

#include <msclr\safebool.h>

namespace msclr
{

namespace _detail
{
    // COM::ptr::operator->() returns a smart_com_ptr instead of
    // a regular interface pointer so that a Release is done automatically
    // when the temporary is destroyed

    template<class _interface_type>
    ref class smart_com_ptr
    {
        public:
        smart_com_ptr(_interface_type * p)
        {
            ptr= p;
        }

        smart_com_ptr(smart_com_ptr % ip)
        {
            ptr = ip.ptr;
            ptr->AddRef();
        }

        _interface_type * operator ->()
        {
            return ptr;
        }

        ~smart_com_ptr()
        {
            ptr->Release();
        }

        private:
        _interface_type * ptr;
    };
} //namespace _detail


namespace com
{
    template<class _interface_type>
    ref class ptr
    {
        public:

        ptr():obj_rcw(nullptr)
        {
        }

        // Construct from interface pointer
        ptr(_interface_type * p)
        {
            obj_rcw = nullptr;
            assign(p);
        }

        // Attach to an interface pointer
        void Attach(_interface_type * _right)
        {
            if (valid())
            {
                throw gcnew System::InvalidOperationException("COM::ptr.Attach");
            }

            assign(_right);
        }

        // Assign an interface pointer
        ptr<_interface_type> % operator=(_interface_type * _right)
        {
            Attach(_right);
            return *this;
        }

        // All CreateInstance methods create an instance of a COM Object
        // by calling CoCreateInstance
        void CreateInstance(System::String ^ prog_id, LPUNKNOWN pouter, DWORD cls_context)
        {
            wchar_t * pwszprog_id = NULL;

            if(prog_id != nullptr)
            {
                pin_ptr<const __wchar_t> _pinned_ptr = PtrToStringChars( prog_id );
                pwszprog_id = _wcsdup(_pinned_ptr);
            }

            try
            {
                CreateInstance(pwszprog_id, pouter, cls_context);
            }
            finally
            {
                free(pwszprog_id);
            }
        }

        void CreateInstance(System::String ^ prog_id, LPUNKNOWN pouter)
        {
            CreateInstance(prog_id, pouter, CLSCTX_ALL);
        }

        void CreateInstance(System::String ^ prog_id)
        {
            CreateInstance(prog_id, NULL, CLSCTX_ALL);
        }

        void CreateInstance(const wchar_t* progid, LPUNKNOWN pouter, DWORD cls_context)
        {
            CLSID clsid;
            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(
                CLSIDFromProgID(progid, &clsid));
            CreateInstance(clsid, pouter, cls_context);
        }

        void CreateInstance(const wchar_t * progid, LPUNKNOWN pouter)
        {
            CreateInstance(progid, pouter, CLSCTX_ALL);
        }

        void CreateInstance(const wchar_t * progid)
        {
            CreateInstance(progid, NULL, CLSCTX_ALL);
        }

        void CreateInstance(REFCLSID rclsid,LPUNKNOWN pouter,DWORD cls_context)
        {
            if (valid())
            {
                throw gcnew System::InvalidOperationException("COM::ptr.CreateInstance");
            }

            _interface_type * interface_ptr = NULL;

            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(CoCreateInstance(
                        rclsid, pouter, cls_context, __uuidof(_interface_type),
                        (void**)&interface_ptr));

            if (interface_ptr)
            {
                assign(interface_ptr);
                interface_ptr->Release();
            }
        }

        void CreateInstance(REFCLSID rclsid,LPUNKNOWN pouter)
        {
            CreateInstance(rclsid, pouter, CLSCTX_ALL);
        }

        void CreateInstance(REFCLSID rclsid)
        {
            CreateInstance(rclsid, NULL, CLSCTX_ALL);
        }

        // Give up ownership of the interface pointer & return the
        // interface pointer
        _interface_type * Detach()
        {
            if(valid())
            {
                _interface_type * interface_ptr = GetInterface();
                destroy();
                return interface_ptr;
            }

            return NULL;
        }

        // Give up ownership of the interface pointer
        void Release()
        {
            if(valid())
            {
                destroy();
            }
        }

        // Operator ->() - to be used to call methods on the owned COM Object
        // We return a smart_com_ptr instead of an interface pointer so that
        // the reference is released automatically
        _detail::smart_com_ptr<_interface_type> operator->()
        {
            _detail::smart_com_ptr<_interface_type> interface_ptr(GetInterface());
            return interface_ptr;
        }

        // Return an interface pointer
        _interface_type * GetInterface()
        {
            if(!valid())
            {
                return NULL;
            }

            System::IntPtr iface_intptr = System::Runtime::InteropServices::Marshal::GetIUnknownForObject(obj_rcw);

            IUnknown * iunk = static_cast<IUnknown *>(static_cast<void*>(iface_intptr));

            _interface_type * interface_ptr;
            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(iunk->QueryInterface(__uuidof(_interface_type), (void **)&interface_ptr));

            iunk->Release();

            interface_ptr->AddRef();
            System::Runtime::InteropServices::Marshal::Release(iface_intptr);

            return interface_ptr;
        }

        // QueryInteface & fillup up the passed it COM::ptr with the result
        template<class _other_type>
        void QueryInterface(ptr<_other_type> % other)
        {
            QueryInterface<_other_type>(__uuidof(_other_type), other);
        }

        // for use when com::ptr appears in a conditional
        operator _detail_class::_safe_bool()
        {
            return valid() ? _detail_class::_safe_true : _detail_class::_safe_false;
        }

        // for use when com::ptr appears in a conditional
        bool operator!()
        {
            return ! valid();
        }

        ~ptr()
        {
            if(valid())
            {
                destroy();
            }
        }

        private:

        void destroy()
        {
            System::Runtime::InteropServices::Marshal::ReleaseComObject(obj_rcw);
            obj_rcw = nullptr;
        }

        bool valid()
        {
            return (obj_rcw != nullptr);
        }


        void assign(_interface_type *p)
        {
            if(p)
            {
                obj_rcw = System::Runtime::InteropServices::Marshal::GetUniqueObjectForIUnknown(System::IntPtr(p));
            }
        }

        template<class _other_type>
        void QueryInterface(REFIID riid, ptr<_other_type> % other)
        {
            _detail::smart_com_ptr<_interface_type> interface_ptr(GetInterface());
            _other_type * other_ptr;

            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(interface_ptr->QueryInterface(riid,(void **)&other_ptr));
            other.Attach(other_ptr);

            other_ptr->Release();
        }

        Object ^obj_rcw;
    };
} // namespace com

} // namespace msclr

#define _INC_MSCLR_COM_PTR
#endif  /* !defined (_INC_MSCLR_COM_PTR) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\msclr\safebool.h ===
/***
*safebool.h - types and constants for implementing the "smart bool" idiom.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Prefer _safe_bool to an implicit conversion to bool. When a
*           type is implicitly convertible to bool, it is also implicitly
*           convertible to any integral type, and this is often not
*           desired.  Instead, provide a conversion to _safe_bool, which
*           is really a pointer to a member function on a dummy struct.
*           This pointer can be evaluated in Boolean context, but it will
*           never be converted to an integral type.
*
*       [Public]
*
****/

#pragma once

#if !defined (_INC_MSCLR_SAFEBOOL)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif  /* __cplusplus_cli */

namespace msclr
{

value class _detail_class
{
public:
    value class dummy_struct
    {
    public:
        static initonly System::String^ dummy_string = "";
    };
    typedef System::String^ _safe_bool;
    static _safe_bool const _safe_true  = dummy_struct::dummy_string;
    static _safe_bool const _safe_false = nullptr;
};

}


#define _INC_MSCLR_SAFEBOOL

#endif  /* !defined (_INC_MSCLR_SAFEBOOL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_STAT
#define _INC_STAT

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#include <crtdefs.h>

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#pragma pack(push,_CRT_PACKING)

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#include <sys/types.h>

#if !defined (_W64)
#if !defined (__midl) && (defined (_X86_) || defined (_M_IX86))
#define _W64 __w64
#else  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#define _W64
#endif  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#endif  /* !defined (_W64) */

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif  /* _TIME32_T_DEFINED */

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif  /* _TIME64_T_DEFINED */

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else  /* _USE_32BIT_TIME_T */
typedef __time64_t time_t;      /* time value */
#endif  /* _USE_32BIT_TIME_T */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif  /* _TIME_T_DEFINED */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

#if !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* !__STDC__ */

struct _stat32i64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

/*
 * We have to have same name for structure and the fuction so as to do the
 * macro magic.we need the structure name and function name the same.
 */
#define __stat64    _stat64

#ifdef _USE_32BIT_TIME_T
#define _fstat      _fstat32
#define _fstati64   _fstat32i64
#define _stat       _stat32
#define _stati64    _stat32i64
#define _wstat      _wstat32
#define _wstati64   _wstat32i64

#else  /* _USE_32BIT_TIME_T */
#define _fstat      _fstat64i32
#define _fstati64   _fstat64
#define _stat       _stat64i32
#define _stati64    _stat64
#define _wstat      _wstat64i32
#define _wstati64   _wstat64

#endif  /* _USE_32BIT_TIME_T */

#define _STAT_DEFINED
#endif  /* _STAT_DEFINED */


#define _S_IFMT         0xF000          /* file type mask */
#define _S_IFDIR        0x4000          /* directory */
#define _S_IFCHR        0x2000          /* character special */
#define _S_IFIFO        0x1000          /* pipe */
#define _S_IFREG        0x8000          /* regular */
#define _S_IREAD        0x0100          /* read permission, owner */
#define _S_IWRITE       0x0080          /* write permission, owner */
#define _S_IEXEC        0x0040          /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat32(_In_ int _FileDes, _Out_ struct _stat32 * _Stat);
_CRTIMP int __cdecl _stat32(_In_z_ const char * _Name, _Out_ struct _stat32 * _Stat);

_CRTIMP int __cdecl _fstat32i64(_In_ int _FileDes, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _fstat64i32(_In_ int _FileDes, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _fstat64(_In_ int _FileDes, _Out_ struct _stat64 * _Stat);
_CRTIMP int __cdecl _stat32i64(_In_z_ const char * _Name, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _stat64i32(_In_z_ const char * _Name, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _stat64(_In_z_ const char * _Name, _Out_ struct _stat64 * _Stat);

#ifndef _WSTAT_DEFINED

/* also declared in wchar.h */

_CRTIMP int __cdecl _wstat32(_In_z_ const wchar_t * _Name, _Out_ struct _stat32 * _Stat);

_CRTIMP int __cdecl _wstat32i64(_In_z_ const wchar_t * _Name, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _wstat64i32(_In_z_ const wchar_t * _Name, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _wstat64(_In_z_ const wchar_t * _Name, _Out_ struct _stat64 * _Stat);

#define _WSTAT_DEFINED
#endif  /* _WSTAT_DEFINED */

#if !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

#endif  /* !__STDC__ */

/*
 * This file is included for __inlined non stdc functions. i.e. stat and fstat
 */
#if !defined (RC_INVOKED) && !defined (__midl)
#include <sys/stat.inl>
#endif  /* !defined (RC_INVOKED) && !defined (__midl) */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#pragma pack(pop)

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif  /* !__STDC__ */

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_TYPES
#define _INC_TYPES

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#if !defined (_W64)
#if !defined (__midl) && (defined (_X86_) || defined (_M_IX86))
#define _W64 __w64
#else  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#define _W64
#endif  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#endif  /* !defined (_W64) */

#ifdef _USE_32BIT_TIME_T
#ifdef _WIN64
#include <crtwrn.h>
#endif  /* _WIN64 */
#endif  /* _USE_32BIT_TIME_T */

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif  /* _TIME32_T_DEFINED */

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif  /* _TIME64_T_DEFINED */

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else  /* _USE_32BIT_TIME_T */
typedef __time64_t time_t;      /* time value */
#endif  /* _USE_32BIT_TIME_T */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif  /* _TIME_T_DEFINED */


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif  /* !__STDC__ */

#define _INO_T_DEFINED
#endif  /* _INO_T_DEFINED */


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif  /* !__STDC__ */

#define _DEV_T_DEFINED
#endif  /* _DEV_T_DEFINED */


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif  /* !__STDC__ */

#define _OFF_T_DEFINED
#endif  /* _OFF_T_DEFINED */

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\timeb.inl ===
/***
*timeb.inl - inline definitions for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of the _ftime() function.
*
*       [Public]
*
****/

#pragma once

#if !defined (__CRTDECL)
#if defined (_M_CEE_PURE)
#define __CRTDECL
#else  /* defined (_M_CEE_PURE) */
#define __CRTDECL   __cdecl
#endif  /* defined (_M_CEE_PURE) */
#endif  /* !defined (__CRTDECL) */

#ifndef _INC_TIMEB_INL
#define _INC_TIMEB_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif  /* _STATIC_ASSERT */

#if !__STDC__

/* Non-ANSI name for compatibility */

#pragma warning(push)
#pragma warning(disable:4996)

#ifdef _USE_32BIT_TIME_T
static __inline void __CRTDECL ftime(struct timeb * _Tmb)
{
    _STATIC_ASSERT( sizeof(struct timeb) == sizeof(struct __timeb32) );
    _ftime32((struct __timeb32 *)_Tmb);
}
#else  /* _USE_32BIT_TIME_T */
static __inline void __CRTDECL ftime(struct timeb * _Tmb)
{
    _STATIC_ASSERT( sizeof(struct timeb) == sizeof(struct __timeb64) );
    _ftime64((struct __timeb64 *)_Tmb);
}
#endif  /* _USE_32BIT_TIME_T */

#pragma warning(pop)

#endif  /* !__STDC__ */

#endif  /* _INC_TIMEB_INL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#include <crtdefs.h>

#undef  assert

#ifdef  NDEBUG

#define assert(_Expression)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _wassert(_In_z_ const wchar_t * _Message, _In_z_ const wchar_t *_File, _In_ unsigned _Line);

#ifdef  __cplusplus
}
#endif

#define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE(#_Expression), _CRT_WIDE(__FILE__), __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\utime.inl ===
/***
*utime.inl - inline definitions for time handling functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of the _utime() function.
*
*       [Public]
*
****/

#pragma once

#if !defined (__CRTDECL)
#if defined (_M_CEE_PURE)
#define __CRTDECL
#else  /* defined (_M_CEE_PURE) */
#define __CRTDECL   __cdecl
#endif  /* defined (_M_CEE_PURE) */
#endif  /* !defined (__CRTDECL) */

#ifndef _INC_UTIME_INL
#define _INC_UTIME_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif  /* _STATIC_ASSERT */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL _utime(const char * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf32) );
    return _utime32(_Filename,(struct __utimbuf32 *)_Utimbuf);
}
static __inline int __CRTDECL _futime(int _Desc, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf32) );
    return _futime32(_Desc,(struct __utimbuf32 *)_Utimbuf);
}
static __inline int __CRTDECL _wutime(const wchar_t * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf32) );
    return _wutime32(_Filename,(struct __utimbuf32 *)_Utimbuf);
}
#else  /* _USE_32BIT_TIME_T */
static __inline int __CRTDECL _utime(const char * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf64) );
    return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}
static __inline int __CRTDECL _futime(int _Desc, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf64) );
    return _futime64(_Desc,(struct __utimbuf64 *)_Utimbuf);
}
static __inline int __CRTDECL _wutime(const wchar_t * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf64) );
    return _wutime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}
#endif  /* _USE_32BIT_TIME_T */


#if !__STDC__

/* Non-ANSI name for compatibility */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL utime(const char * _Filename, struct utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct utimbuf) == sizeof(struct __utimbuf32) );
    return _utime32(_Filename,(struct __utimbuf32 *)_Utimbuf);
}
#else  /* _USE_32BIT_TIME_T */
static __inline int __CRTDECL utime(const char * _Filename, struct utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct utimbuf) == sizeof(struct __utimbuf64) );
    return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}
#endif  /* _USE_32BIT_TIME_T */

#endif  /* !__STDC__ */

#endif  /* _INC_UTIME_INL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\wstat.inl ===
/***
*wstat.inl - inline definitions for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function definitions for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#pragma once

#if !defined (__CRTDECL)
#if defined (_M_CEE_PURE)
#define __CRTDECL
#else  /* defined (_M_CEE_PURE) */
#define __CRTDECL   __cdecl
#endif  /* defined (_M_CEE_PURE) */
#endif  /* !defined (__CRTDECL) */

#ifndef _INC_WSTAT_INL
#define _INC_WSTAT_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif  /* _STATIC_ASSERT */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL _wstat(const wchar_t * _Filename, struct _stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stat) == sizeof(struct _stat32) );
    return _wstat32(_Filename,(struct _stat32 *)_Stat);
}
#else  /* _USE_32BIT_TIME_T */
static __inline int __CRTDECL _wstat(const wchar_t * _Filename, struct _stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stat) == sizeof(struct _stat64i32) );
    return _wstat64i32(_Filename,(struct _stat64i32 *)_Stat);
}
#endif  /* _USE_32BIT_TIME_T */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL _wstati64(const wchar_t * _Filename, struct _stati64 * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stati64) == sizeof(struct _stat32i64) );
    return _wstat32i64(_Filename,(struct _stat32i64*)_Stat);
}
#else  /* _USE_32BIT_TIME_T */
static __inline int __CRTDECL _wstati64(const wchar_t * _Filename, struct _stati64 * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stati64) == sizeof(struct _stat64) );
    return _wstat64(_Filename,(struct _stat64*)_Stat);
}
#endif  /* _USE_32BIT_TIME_T */

#endif  /* _INC_WSTAT_INL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\agents.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* agents.h
*
* Main public header file for ConcRT's asynchronous agents layer. This is the only header file a
* C++ program should have to include in order to avail itself of asynchronous agents.
*
* The core runtime, PPL, and resource manager are in separate headers.
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

#pragma once

#include <crtdefs.h>
#include <concrt.h>
#include <stdexcept>
#include <functional>
#include <tuple> 
#include <type_traits> 
#include <vector>

#pragma pack(push,_CRT_PACKING)

// Forward declarations

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{
/// <summary>
///     Each message instance has an identity that follows it as it is
///     cloned and passed between messaging components. This cannot be the
///     address of the message object.
/// </summary>
/**/
typedef __int32 runtime_object_identity;

/// <summary>
///     A lock holder that acquires a non-reentrant lock on instantiation and releases
///     it on destruction.
/// </summary>
/**/
typedef ::Concurrency::details::_NonReentrantPPLLock::_Scoped_lock _NR_lock;

/// <summary>
///     A lock holder that acquires a reentrant lock on instantiation and releases
///     it on destruction
/// </summary>
/**/
typedef ::Concurrency::details::_ReentrantPPLLock::_Scoped_lock _R_lock;


//***************************************************************************
// Internal namespace:
//
// Concurrency::details contains definitions to support routines in the public namespaces and macros.
// Clients should not directly interact with this namespace.
//***************************************************************************

namespace details
{
    //**************************************************************************
    // Core Messaging Support:
    //**************************************************************************

    //
    // A base class to derive from that keeps unique ids on its derived classes
    //
    class _Runtime_object : public _AllocBase
    {
    public:
        // Creates a new runtime object.
        _CRTIMP2 _Runtime_object();

        // Creates a runtime object from an identity.
        _CRTIMP2 _Runtime_object(::Concurrency::runtime_object_identity _Id);

        // Gets the runtime object identity.
        virtual ::Concurrency::runtime_object_identity _GetId() const
        {
            return _M_id;
        }

    protected:
        // The runtime object identity.
        ::Concurrency::runtime_object_identity _M_id;
    };

    // A queue used to hold the messages for the messaging blocks
    template<class _Message>
    class _Queue : public _AllocBase
    {
    protected:
        // A pointer to the head of the queue.
        _Message * _M_pHead;

        // A pointer to a pointer to the tail of the queue.
        _Message ** _M_ppTail;

        // The number of elements presently stored in the queue.
        size_t _M_count;

    public:
        typedef typename _Message type;

        // Create a Queue
        _Queue() : _M_pHead(NULL), _M_ppTail(&_M_pHead), _M_count(0)
        {
        }

        // Destroy the queue
        ~_Queue() 
        { 
            // Delete any messages that may be remaining in the queue
            _Message * _Msg = _Dequeue();
            while (_Msg != NULL)
            {
                delete _Msg;
                _Msg = _Dequeue();
            }
        }

        // Returns the count of items in the queue
        size_t _Count() const 
        { 
            return _M_count; 
        }

        // Add an item to the tail of the queue
        //
        // Returns a Boolean indicating whether the operation succeeded.
        bool _Enqueue(_Message *_Element)
        {
            _ASSERTE(_Element->_M_pNext == NULL);
            _ASSERTE(*_M_ppTail == NULL);

            *_M_ppTail = _Element;
            _Element->_M_pNext = NULL;
            _M_ppTail = &(_Element->_M_pNext);
            _M_count++;

            return true;
        }

        // Remove the specified element from the queue
        //
        // Returns a Boolean indicating whether the operation succeeded, i.e. that the message was found in the queue.
        bool _Remove(_Message * _OldElement)
        {
            bool _Result = false;

            _ASSERTE(_OldElement != NULL);

            if (_M_pHead == _OldElement)
            {
                _M_pHead = _OldElement->_M_pNext;
                if (_M_pHead == NULL)
                {
                    _M_ppTail = &_M_pHead;
                }

                _OldElement->_M_pNext = NULL;
                _M_count--;
                _Result = true;
            }
            else
            {
                _Message * _Next = NULL;
                for (_Message * _Node = _M_pHead; _Node != NULL; _Node = _Next)
                {
                    _Next = _Node->_M_pNext;

                    if (_Node->_M_pNext == _OldElement)
                    {
                        _Node->_M_pNext = _OldElement->_M_pNext;
                        // if this is the last element of the _Queue
                        if (_Node->_M_pNext == NULL && _M_count == 1) 
                        {
                            _M_ppTail = &_M_pHead;
                        }

                        _OldElement->_M_pNext = NULL;
                        _M_count--;
                        _Result = true;
                        break;
                    }
                }
            }

            return _Result;
        }

        // Dequeue an item from the head of queue
        //
        // Returns a pointer to the message found at the head of the queue.
        _Message * _Dequeue()
        {
            if (_M_pHead == NULL) 
            {
                return NULL;
            }

            _Message * _Result = _M_pHead;

            _M_pHead = _Result->_M_pNext;
            if (_M_pHead == NULL) 
            {
                _M_ppTail = &_M_pHead;
            }

            _Result->_M_pNext = NULL;
            _M_count--;
            return _Result;
        }

        // Return the item at the head of the queue, without dequeuing
        //
        // Returns a pointer to the message found at the head of the queue.
        _Message * _Peek()
        {
            return _M_pHead;
        }

        // Return true if the id matches the message at the head of the queue
        bool _Is_head(runtime_object_identity _MsgId)
        {
            // Peek at the next message in the message buffer.  Use it to
            // check if the ids match
            _Message * _Msg = _M_pHead;

            if (_Msg == NULL || _Msg->msg_id() != _MsgId)
            {
                return false;
            }

            return true;
        }
    };

    //
    // The async_send_queue class puts a lock around the Enqueue/Dequeue operations on
    // a Queue.  This class is here mainly to support the message propagation queue
    // It holds incoming messages and will be written to on async_send(). Messages in
    // this queue will be moved to the internal storage of the block within an LWT.
    //
    template<class _Message> 
    class _Async_send_queue
    {
    public:
        // Create an async send queue
        _Async_send_queue()
        {
        }

        // Return the count of items in the async send queue
        size_t _Count() const 
        { 
            return _M_queue._Count(); 
        }

        // Add an item to the back of the async send queue
        //
        // Returns a Boolean indicating whether the operation succeeded.
        bool _Enqueue(_Message * _Element)
        {
            _NR_lock _Lock(_M_lock);

            return (_M_queue._Enqueue(_Element));
        }

        // Remove an item from the async send queue
        //
        // Returns a Boolean indicating whether the operation succeeded, i.e. that the message was found in the async send queue.
        bool _Remove(_Message * _OldElement)
        {
            _NR_lock _Lock(_M_lock);  

            return (_M_queue._Remove(_OldElement));
        }

        // Remove an item from the head of the async send queue
        //
        // Returns a pointer to the message found at the head of the async send queue.
        _Message * _Dequeue()
        {
            _NR_lock _Lock(_M_lock);

            return (_M_queue._Dequeue());
        }

        // Return the item at the head of the async send queue, without dequeuing
        //
        // Returns a pointer to the message found at the head of the async send queue.
        _Message * _Peek()
        {
            return _M_queue._Peek();
        }

    private:
        // A lock to guard the queue
        ::Concurrency::details::_NonReentrantPPLLock _M_lock;

        // Underlying queue
        _Queue<_Message> _M_queue;
    };


    //
    // _Dynamic_array implements a container very similar to std::vector.
    // However, it exposes a reduced subset of functionality that is
    // geared towards use in network_link_registry. The array acess is not
    // thread-safe.
    //
    template<class _Type>
    class _Dynamic_array
    {
    public:

        typedef _Dynamic_array<_Type> _Myt;

        typedef _Type& reference;
        typedef _Type const& const_reference;

        //
        // Construct a dynamic array
        //
        _Dynamic_array()
        {
            _Init();
        }

        //
        // Release any resources used by dynamic array
        //
        ~_Dynamic_array()
        {
            _Clear();
        }

        //
        // Assignment operator. Copy the contents of _Right
        //
        _Myt& operator=(const _Myt& _Right)
        {
            if (this != &_Right)
            {
                // Remove all the elements
                _Clear();

                // Allocate space for the new elements
                size_t _Size = _Right._Size();
                _Grow(_Size);

                // Copy over the new elements
                for (size_t _I=0; _I < _Size; _I++)
                {
                    _Push_back(_Right[_I]);
                }
            }

            return *this;
        }

        //
        // Clear all the elements in the array
        //
        void _Clear()
        {
            if (_M_array != NULL)
            {
                delete [] _M_array;
                _Init();
            }
        }

        //
        // Add an element to the end of the array
        //
        void _Push_back(_Type const& _Element)
        {
            if (_M_index >= _M_size)
            {
                // Not enough space. Grow the array
                size_t _NewSize = (_M_index + 1) * _S_growthFactor;
                _Grow(_NewSize);
            }

            _ASSERTE(_M_index < _M_size);
            _M_array[_M_index] = _Element;
            _M_index++;
        }

        //
        // Index operation. Retrieve an element at the specified index. No bounds check is done.
        //
        reference operator[](size_t _Pos)
        {
            _ASSERTE(_Pos < _M_size);
            return _M_array[_Pos];
        }

        //
        // Index operation. Retrieve an element at the specified index. No bounds check is done.
        //
        const_reference operator[](size_t _Pos) const
        {
            _ASSERTE(_Pos < _M_size);
            return _M_array[_Pos];
        }

        //
        // Returns the count of elements in the array
        //
        size_t _Size() const
        {
            return _M_index;
        }

        //
        // Swap the contents of this array with _Right
        //
        void _Swap(_Myt& _Right)
        {
            if (this != &_Right)
            {
                // Swap the details.
                _Type * _Array = _M_array;
                size_t _Index = _M_index;
                size_t _Size = _M_size;

                _M_array = _Right._M_array;
                _M_index = _Right._M_index;
                _M_size = _Right._M_size;

                _Right._M_array = _Array;
                _Right._M_index = _Index;
                _Right._M_size = _Size;
            }
        }

    private:
        // 
        // Initialize the array
        //
        void _Init()
        {
            _M_array = NULL;
            _M_index = 0;
            _M_size = 0;
        }

        //
        // Grow the array to the given size. The old elements are copied over.
        //
        void _Grow(size_t _NewSize)
        {
            _ASSERTE(_NewSize > _M_size);

            _Type * _Array = new _Type[_NewSize];

            if (_M_array != NULL)
            {
                // Copy over the elememts
                for (size_t _I = 0; _I < _M_size; _I++)
                {
                    _Array[_I] = _M_array[_I];
                }

                delete [] _M_array;
            }

            _M_array = _Array;
            _M_size = _NewSize;
        }

        // Private data members

        // Array of elements
        _Type * _M_array;

        // Index where the next element should be inserted
        size_t  _M_index;

        // Capacity of the array.
        size_t  _M_size;

        static const int _S_growthFactor = 2;
    };
} // namespace details

//**************************************************************************
// Public Namespace:
//
// Anything in the Concurrency namespace is intended for direct client consumption.
//
//**************************************************************************

//
// Forward declarations:
//
template<class _Type> class ISource;
template<class _Type> class ITarget;

//**************************************************************************
// Network link registry
//**************************************************************************

// Forward declaration for use in the iterator
template<class _Block> class network_link_registry;

/// <summary>
///     Const iterator for network link registry. Message blocks should use
///     the link_registry::iterator type for iteration. 
/// </summary>
/// <typeparam name="_Block">
///     The network block type 
/// </typeparam>
/**/
template<class _Block>
class _Network_link_iterator
{
public:

    typedef _Network_link_iterator<_Block> _Myt;
    typedef network_link_registry<_Block>  _MyContainer;

    // Element type
    typedef _Block* _EType;

    // Const iterator - iterator shall not be used to modify the links
    typedef _EType const& const_reference;
    typedef _EType const* const_pointer;

    /// <summary>
    ///     Construct iterator
    /// </summary>
    /**/
    _Network_link_iterator(_MyContainer * _PNetwork_link, size_t _Index) : _M_pNetwork_link(_PNetwork_link), _M_index(_Index), _M_value(NULL)
    {
        _M_pNetwork_link->_Next_index(_M_index);
    }

    /// <summary>
    ///     Copy construct an iterator
    /// </summary>
    /**/
    _Network_link_iterator(_Myt const& _Right)
    {
        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
    }

    /// <summary>
    ///     Copy assign an iterator 
    /// </summary>
    /**/
    _Myt const& operator=(_Myt const& _Right)
    {
        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
        return *this;
    }

    /// <summary>
    ///     Returns the object pointed to by the iterator
    /// </summary>
    /// <returns>
    ///     Reference to the object pointed to by the iterator
    /// </returns>
    /**/
    const_reference operator*() 
    {
        _M_value = _M_pNetwork_link->_Get_element(_M_index);
        return _M_value;
    }

    /// <summary>
    ///     Returns a pointer to the class object
    /// </summary>
    /// <returns>
    ///     Returns a pointer to the class object
    /// </returns>
    /**/
    const_pointer operator->() const
    {
        return (&**this);
    }

    /// <summary>
    ///     Pre-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator after
    ///     incrementing it
    /// </returns>
    /**/
    _Myt& operator++()
    {
        ++_M_index;
        _M_pNetwork_link->_Next_index(_M_index);
        return (*this);
    }

    /// <summary>
    ///     Post-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator before
    ///     incrementing it
    /// </returns>
    /**/
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        ++*this;
        return (_Tmp);
    }

private:

    // Pointer to the underlying container (network link registry)
    _MyContainer * _M_pNetwork_link;

    // Current index
    size_t _M_index;

    // Current value
    _EType _M_value;
};

/// <summary>
///     The <c>network_link_registry</c> abstract base class manages the links between source 
///     and target blocks.
/// </summary>
/// <typeparam name="_Block">
///     The block data type being stored in the <c>network_link_registry</c>.
/// </typeparam>
/// <remarks>
///     The <c>network link registry</c> is not safe for concurrent access.
/// </remarks>
/// <seealso cref="single_link_registry Class"/>
/// <seealso cref="multi_link_registry Class"/>
/**/
template<class _Block>
class network_link_registry
{
public:

    /// <summary>
    ///     A type that represents the block type stored in the <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef typename _Block type;

    /// <summary>
    ///     A type that represents an element pointer stored in the <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef _Block * _EType;

    /// <summary>
    ///     A type that provides a reference to a <c>const</c> element stored in a
    ///     <c>network_link_registry</c> object for reading and performing const operations.
    /// </summary>
    /**/
    typedef _EType const& const_reference;

    /// <summary>
    ///     A type that provides a pointer to a <c>const</c> element in a
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef _EType const* const_pointer;

    // Make the iterators friends so that they can access some of the
    // private routines such as _Get_element.
    /**/
    friend class _Network_link_iterator<_Block>;

    /// <summary>
    ///     A type that provides an iterator that can read or modify any element in a 
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef _Network_link_iterator<_Block> iterator;

    /// <summary>
    ///     When overridden in a derived class, adds a link to the <c>network_link_registry</c>
    ///     object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /**/
    virtual void add(_EType _Link) = 0;

    /// <summary>
    ///     When overridden in a derived class, removes a specified block from the
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool remove(_EType _Link) = 0;

    /// <summary>
    ///     When overridden in a derived class, searches the <c>network_link_registry</c> object
    ///     for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is being searched for in the <c>network_link_registry</c> 
    ///     object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the block was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool contains(_EType _Link) = 0;

    /// <summary>
    ///     When overridden in a derived class, returns the number of items in the
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /// <returns>
    ///     The number of items in the <c>network_link_registry</c> object.
    /// </returns>
    /**/
    virtual size_t count() = 0;

    /// <summary>
    ///     When overridden in a derived class, returns an iterator to the first element in the
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state of the iterator is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>network_link_registry</c> object.
    /// </returns>
    /**/
    virtual iterator begin() = 0;

protected:

    /// <summary>
    ///     Skips empty slots and updates the index to the next
    ///     non-empty slot. This is called by the iterator.
    /// </summary>
    /// <param name="_Index">
    ///     A reference to the index that is to be updated.
    /// </param>
    /**/
    virtual void _Next_index(size_t& _Index) = 0;

    /// <summary>
    ///     Retrieves the element at the given index. If the index is out of bounds,
    ///     <c>NULL</c> is returned. Users need to use the iterator to access the links.
    /// </summary>
    /// <param name="_Index">
    ///     Index of the link to be retrieved.
    /// </param>
    /// <returns>
    ///     The element in the registry at  the index specified by the <paramref name="_Index"/> parameter.
    /// </returns>
    /**/
    virtual _EType _Get_element(size_t _Index) const = 0;
};

/// <summary>
///     The <c>single_link_registry</c> object is a <c>network_link_registry</c> that manages
///     only a single source or target block.
/// </summary>
/// <typeparam name="_Block">
///     The block data type being stored in the <c>single_link_registry</c> object.
/// </typeparam>
/// <seealso cref="multi_link_registry Class"/>
/**/
template<class _Block>
class single_link_registry : public network_link_registry<_Block>
{
public:

    /// <summary>
    ///     Constructs a <c>single_link_registry</c> object.
    /// </summary>
    /**/
    single_link_registry() : _M_connectedLink(NULL)
    {
    }

    /// <summary>
    ///     Destroys the <c>single_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The method throws an <see cref="invalid_operation Class">invalid_operation</see> exception if
    ///     it is called before the link is removed.
    /// </remarks>
    /**/
    virtual ~single_link_registry()
    {
        // It is an error to delete link registry with links
        // still present
        if (count() != 0)
        {
            throw invalid_operation("Deleting link registry before removing all the links");
        }
    }

    /// <summary>
    ///     Adds a link to the <c>single_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_link_target Class">invalid_link_target</see> exception
    ///     if there is already a link in this registry.
    /// </remarks>
    /**/
    virtual void add(_EType _Link)
    {
        if (_Link == NULL)
        {
            return;
        }

        // Only one link can be added.
        if (_M_connectedLink != NULL)
        {
            throw invalid_link_target("_Link");
        }

        _M_connectedLink = _Link;
    }

    /// <summary>
    ///     Removes a link from the <c>single_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool remove(_EType _Link)
    {
        if ((_Link != NULL) && (_M_connectedLink == _Link))
        {
            _M_connectedLink = NULL;
            return true;
        }

        return false;
    }

    /// <summary>
    ///     Searches the <c>single_link_registry</c> object for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched for in the <c>single_link_registry</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool contains(_EType _Link)
    {
        return ((_Link != NULL) && (_M_connectedLink == _Link));
    }

    /// <summary>
    ///     Counts the number of items in the <c>single_link_registry</c> object.
    /// </summary>
    /// <returns>
    ///     The number of items in the <c>single_link_registry</c> object.
    /// </returns>
    /**/
    virtual size_t count() 
    {
        return (_M_connectedLink == NULL) ? 0 : 1;
    }

    /// <summary>
    ///     Returns an iterator to the first element in the <c>single_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>single_link_registry</c> object.
    /// </returns>
    /**/
    virtual iterator begin()
    {
        return (iterator(this, 0));
    }

protected:

    /// <summary>
    ///     Skips empty slots and updates the index to the next
    ///     non-empty slot. This is called by the iterator.
    /// </summary>
    /// <param name="_Index">
    ///     A reference to the index that is to be updated.
    /// </param>
    /**/
    virtual void _Next_index(size_t& _Index)
    {
        if (_M_connectedLink == NULL)
        {
            _Index++;
        }
    }

    /// <summary>
    ///     Retrieves the element at the given index. If the index is out of bounds,
    ///     <c>NULL</c> is returned. Users need to use the iterator to access the links.
    /// </summary>
    /// <param name="_Index">
    ///     The index of the link to be retrieved.
    /// </param>
    /// <returns>
    ///     The element in the registry at  the index specified by the <paramref name="_Index"/> parameter.
    /// </returns>
    /**/
    virtual _EType _Get_element(size_t _Index) const
    {
        if (_Index == 0)
        {
            return _M_connectedLink;
        }

        return NULL;
    }

private:

    // A single pointer is used to hold the link
    _EType _M_connectedLink;
};

/// <summary>
///     The <c>multi_link_registry</c> object is a <c>network_link_registry</c> that manages multiple
///     source blocks or multiple target blocks.
/// </summary>
/// <typeparam name="_Block">
///     The block data type being stored in the <c>multi_link_registry</c> object.
/// </typeparam>
/// <seealso cref="single_link_registry Class"/>
/**/
template<class _Block>
class multi_link_registry : public network_link_registry<_Block>
{
public:

    /// <summary>
    ///     Constructs a <c>multi_link_registry</c> object.
    /// </summary>
    /**/
    multi_link_registry() : _M_maxLinks(_NOT_SET)
    {
    }

    /// <summary>
    ///     Destroys the <c>multi_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The method throws an <see cref="invalid_operation Class">invalid_operation</see> exception if
    ///     called before all links are removed.
    /// </remarks>
    /**/
    virtual ~multi_link_registry()
    {
        // It is an error to delete link registry with links
        // still present
        if (count() != 0)
        {
            throw invalid_operation("Deleting link registry before removing all the links");
        }
    }

    /// <summary>
    ///     Sets an upper bound on the number of links that the <c>multi_link_registry</c> object
    ///     can hold.
    /// </summary>
    /// <param name="_MaxLinks">
    ///     The maximum number of links that the <c>multi_link_registry</c> object can hold.
    /// </param>
    /// <remarks>
    ///     Once a bound is set, unlinking an entry will cause the <c>multi_link_registry</c>
    ///     object to enter an immutable state where further calls to <c>add</c> will throw an
    ///     <c>invalid_link_target</c> exception.
    /// </remarks>
    /**/
    void set_bound(size_t _MaxLinks)
    {
        _ASSERTE(count() == 0);
        _M_maxLinks = _MaxLinks;
    }

    /// <summary>
    ///     Adds a link to the <c>multi_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_link_target Class">invalid_link_target</see> exception if
    ///     the link is already present in the registry, or if a bound has already been set with the <c>set_bound</c>
    ///     function and a link has since been removed.
    /// </remarks>
    /**/
    virtual void add(_EType _Link)
    {
        if (_Link == NULL)
        {
            return;
        }

        _Add(_Link);
    }

    /// <summary>
    ///     Removes a link from the <c>multi_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool remove(_EType _Link)
    {
        if (_Link == NULL)
        {
            return false;
        }

        return (_Remove(_Link));
    }

    /// <summary>
    ///     Searches the <c>multi_link_registry</c> object for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched for in the <c>multi_link_registry</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the specified block was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool contains(_EType _Link)
    {
        if (_Link == NULL)
        {
            return false;
        }

        return (_Find(_Link) < _M_vector._Size());
    }

    /// <summary>
    ///     Counts the number of items in the <c>multi_link_registry</c> object.
    /// </summary>
    /// <returns>
    ///     The number of items in the <c>multi_link_registry</c> object.
    /// </returns>
    /**/
    virtual size_t count()
    {
        return _Count();
    }

    /// <summary>
    ///     Returns an iterator to the first element in the <c>multi_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state is indicated by a <c>NULL</c> link. 
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>multi_link_registry</c> object.
    /// </returns>
    /**/
    virtual iterator begin() 
    {
        return (iterator(this, 0));
    }

protected:

    /// <summary>
    ///     Skips empty slots and updates the index to the next
    ///     non-empty slot. This is called by the iterator.
    /// </summary>
    /// <param name="_Index">
    ///     A reference to the index that is to be updated.
    /// </param>
    /**/
    virtual void _Next_index(size_t& _Index)
    {
        size_t _Size = _M_vector._Size();
        while (_Index < _Size)
        {
            if (_M_vector[_Index] != NULL)
            {
                break;
            }

            ++_Index;
        }
    }

    /// <summary>
    ///     Retrieves the element at the given index. If the index is out of bounds,
    ///     <c>NULL</c> is returned. Users need to use the iterator to access the links
    /// </summary>
    /// <param name="_Index">
    ///     Index of the link to be retrieved.
    /// </param>
    /// <returns>
    ///     The element in the registry at the index specified by the <paramref name="_Index"/> parameter.
    /// </returns>
    /**/
    virtual _EType _Get_element(size_t _Index) const
    {
        if (_Index < _M_vector._Size())
        {
            return _M_vector[_Index];
        }

        return NULL;
    }

private:

    /// <summary>
    ///     Adds a link to the <c>multi_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /**/
    void _Add(_EType _Link) 
    {
        size_t _Size = _M_vector._Size();
        size_t _Insert_pos = 0;

        _ASSERTE(_Link != NULL);

        // If max links is set, ensure that inserting the new
        // link will not exceed the bound.
        if ((_M_maxLinks != _NOT_SET) && ((_Size+1) > (size_t) _M_maxLinks))
        {
            throw invalid_link_target("_Link");
        }

        for (size_t _Index = 0; _Index < _Size; _Index++)
        {
            if (_M_vector[_Index] != NULL)
            {
                // We want to find the first NULL entry after all the 
                // non-NULL entries.
                _Insert_pos = _Index + 1;

                // Throw if dupiclate entry is found
                if (_M_vector[_Index] == _Link)
                {
                    throw invalid_link_target("_Link");
                }
            }
        }

        if (_Insert_pos < _Size)
        {
            _M_vector[_Insert_pos] = _Link;
        }
        else
        {
            _M_vector._Push_back(_Link);
        }
    }

    /// <summary>
    ///     Removes a link from the <c>multi_link_registry</c>
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the specified link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool _Remove(_EType _Link)
    {
        _ASSERTE(_Link != NULL);

        for (size_t _Index = 0; _Index < _M_vector._Size(); _Index++)
        {
            if (_M_vector[_Index] == _Link)
            {
                _M_vector[_Index] = NULL;

                // If max links is set, prevent new additions to the registry
                if (_M_maxLinks != _NOT_SET && _M_maxLinks > 0)
                {
                    // Setting the bound to 0. This causes add to always throw.
                    _M_maxLinks = 0;
                }

                return true;
            }
        }

        return false;
    }


    /// <summary>
    ///     Searches the registry for the given link
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched.
    /// </param>
    /// <returns>
    ///     Index of the entry if found.
    /// </returns>
    /**/
    virtual size_t _Find(_EType _Link)
    {
        size_t _Index = 0;
        for (_Index = 0; _Index < _M_vector._Size(); _Index++)
        {
            if (_M_vector[_Index] == _Link)
            {
                break;
            }
        }

        return _Index;
    }

    /// <summary>
    ///     Returns the count of items in the registry.
    /// </summary>
    /// <returns>
    ///     The count of items in the registry.
    /// </returns>
    /**/
    size_t _Count() const
    {
        size_t _Count = 0;

        for (size_t _Index = 0; _Index < _M_vector._Size(); _Index++)
        {
            if (_M_vector[_Index] != NULL)
            {
                _Count++;
            }
        }

        return _Count;
    }

    static const size_t _NOT_SET = SIZE_MAX;

    // Maximum number of links allowed.
    size_t _M_maxLinks;

    // ::Concurrency::details::_Dynamic_array is used to hold the links
    ::Concurrency::details::_Dynamic_array<_EType> _M_vector;
};

// Forward declaration for the iterator
template<class _LinkRegistry> class source_link_manager;

/// <summary>
///     Const Iterator for referenced link manager.
/// </summary>
/// <typeparam name="_LinkRegistry">
///     The underlying network link registry
/// </typeparam>
/**/
template<class _LinkRegistry>
class _Source_link_iterator
{
public:

    typedef typename _LinkRegistry::type  _Block;

    typedef _Source_link_iterator<_LinkRegistry> _Myt;
    typedef source_link_manager<_LinkRegistry>  _MyContainer;

    // Element type
    typedef _Block* _EType;

    // Const iterator - iterator shall not be used to modify the links
    typedef _EType const& const_reference;
    typedef _EType const* const_pointer;

    /// <summary>
    ///     Construct iterator
    /// </summary>
    /**/
    _Source_link_iterator(_MyContainer * _PNetwork_link, size_t _Index) : _M_pNetwork_link(_PNetwork_link), _M_index(_Index), _M_sentinel(NULL)
    {
        // Take a snapshot of the link registry. This will reference the registry.
        _M_pNetwork_link->_To_array(_M_array);
    }

    /// <summary>
    ///     Destruct iterator
    /// </summary>
    /**/
    virtual ~_Source_link_iterator()
    {
        if (_M_pNetwork_link != NULL)
        {
            _M_pNetwork_link->release();
        }
    }
    /// <summary>
    ///     Copy construct an iterator
    /// </summary>
    /**/
    _Source_link_iterator(_Myt const& _Right)
    {        
        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
        _M_array = _Right._M_array;

        _M_pNetwork_link->reference();
    }

    /// <summary>
    ///     Copy assign an iterator 
    /// </summary>
    /**/
    _Myt const& operator=(_Myt const& _Right)
    {
        _MyContainer * _OldContainer = _M_pNetwork_link;
        _ASSERTE(_OldContainer != NULL);

        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
        _M_array = _Right._M_array;

        if (_OldContainer != _M_pNetwork_link)
        {
            _OldContainer->release();
            _M_pNetwork_link->reference();
        }

        return *this;
    }

    /// <summary>
    ///     Returns the object pointed to by the iterator
    /// </summary>
    /// <returns>
    ///     Reference to the object pointed to by the iterator
    /// </returns>
    /**/
    const_reference operator*() 
    {
        return _Get(0);
    }

    /// <summary>
    ///     Returns a pointer to the class object
    /// </summary>
    /// <returns>
    ///     Returns a pointer to the class object
    /// </returns>
    /**/
    const_pointer operator->() const
    {
        return (&**this);
    }

    /// <summary>
    ///     Index operation. Retrieve an element at the specified index.
    /// </summary>
    /**/
    const_reference operator[](size_t _Pos) const
    {
        return _Get(_Pos);
    }

    /// <summary>
    ///     Pre-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator after incrementing it
    /// </returns>
    /**/
    _Myt& operator++()
    {
        ++_M_index;
        return (*this);
    }

    /// <summary>
    ///     Post-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator before incrementing it
    /// </returns>
    /**/
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        ++*this;
        return (_Tmp);
    }

private:

    // Get the element at the given offset.
    const_reference _Get(size_t _Pos) const
    {
        size_t _Index = _M_index + _Pos;
        if (_Index >= _M_array._Size())
        {
            return _M_sentinel;
        }

        return _M_array[_Index];
    }

    // Array to hold the snapshot of the link registry
    ::Concurrency::details::_Dynamic_array<_EType> _M_array;
    
    // Pointer to the underlying container (network link registry)
    _MyContainer * _M_pNetwork_link;

    // Current index
    size_t _M_index;

    // Sentinel value to return on bounds overflow
    _EType _M_sentinel;
};

/// <summary>
///     The <c>source_link_manager</c> object manages messaging block network links
///     to <c>ISource</c> blocks.
/// </summary>
/// <typeparam name="_LinkRegistry">
///     The network link registry.
/// </typeparam>
/// <remarks>
///     Currently, the source blocks are reference counted. This is a wrapper on a
///     <c>network_link_registry</c> object that allows concurrent access to the links and
///     provides the ability to reference the links through callbacks. Message
///     blocks (<c>target_block</c>s or <c>propagator_block</c>s) should use this class
///     for their source links.
/// </remarks>
/// <seealso cref="single_link_registry Class"/>
/// <seealso cref="multi_link_registry Class"/>
/**/
template<class _LinkRegistry>
class source_link_manager
{
public:

    /// <summary>
    ///     The type of link registry being managed by the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _LinkRegistry type;

    /// <summary>
    ///     The type of the blocks being managed by the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef typename _LinkRegistry::type _Block;

    /// <summary>
    ///     The method signature for a callback method for this <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef std::tr1::function<void(_Block *, bool)>  _Callback_method;

    /// <summary>
    ///     A type that represents a pointer to an element stored in the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _Block * _EType;

    /// <summary>
    ///     A type that provides a reference to a <c>const</c> element stored in a <c>source_link_manager</c> object
    ///     for reading and performing const operations.
    /// </summary>
    /**/
    typedef _EType const& const_reference;

    /// <summary>
    ///     A type that provides a pointer to a <c>const</c> element in a <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _EType const* const_pointer;

    // Iterator
    friend class _Source_link_iterator<_LinkRegistry>;

    /// <summary>
    ///     A type that provides an iterator that can read or modify any element in the
    ///     <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _Source_link_iterator<_LinkRegistry> iterator;

    /// <summary>
    ///     A type that provides a reentrant lock for the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef ::Concurrency::details::_ReentrantPPLLock _LockType;

    /// <summary>
    ///     A type that provides a RAII scoped lock holder for a lock.
    /// </summary>
    /**/
    typedef _LockType::_Scoped_lock _LockHolder;

    /// <summary>
    ///     Constructs a <c>source_link_manager</c> object.
    /// </summary>
    /**/
    source_link_manager() : _M_iteratorCount(0), _M_pLinkedTarget(NULL)
    {
    }

    /// <summary>
    ///     Destroys the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    ~source_link_manager()
    {
        _ASSERTE(_M_pendingRemove._Size() == 0);
    }

    /// <summary>
    ///     Registers the target block that holds this <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     The target block holding this <c>source_link_manager</c> object.
    /// </param>
    /**/
    void register_target_block(ITarget<typename _Block::source_type> * _PTarget)
    {
        _M_pLinkedTarget = _PTarget;
    }

    /// <summary>
    ///     Sets the maximum number of source links that can be added to this 
    ///     <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_MaxLinks">
    ///     The maximum number of links.
    /// </param>
    /**/
    void set_bound(size_t _MaxLinks)
    {
        _M_links.set_bound(_MaxLinks);
    }

    /// <summary>
    ///     Adds a source link to the <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /**/
    void add(_EType _Link)
    {
        if (_Link == NULL)
        {
            return;
        }

        {
            _LockHolder _Lock(_M_lock);
            _M_links.add(_Link);

            // We need to add the _Link first and then invoke the
            // callback since _Add could throw.

            // As soon as the above lock is released, remove would
            // find the link that was added and could unlink it before
            // we are able to invoke the notification below. Keeping an
            // active iterator would prevent that from happening.
            _M_iteratorCount++;
        }

        // Acquire a reference on this link by the target
        _Link->acquire_ref(_M_pLinkedTarget);

        // Release the active iterator
        release();
    }

    /// <summary>
    ///     Removes a link from the <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool remove(_EType _Link)
    {
        bool _Removed = false;
        _EType _RemovedLink = NULL;
        ITarget<typename _Block::source_type> * _LinkedTarget = _M_pLinkedTarget;

        if (_Link == NULL)
        {
            return false;
        }

        {
             _LockHolder _Lock(_M_lock);
             _Removed = _M_links.remove(_Link);

             if (!_Removed)
             {
                 // No change was made
                 return _Removed;
             }

             if (_M_iteratorCount == 0)
             {
                 // Set the removed link to indicate that 
                 // notification callback needs to be invoked.
                 _RemovedLink = _Link;
             }
             else
             {
                 // The iterator will complete the pending operation
                 _M_pendingRemove._Push_back(_Link);
             }
        }

        // NOTE: touching "this" pointer is dangerous as soon as the above lock is released

        // Release the reference for this link
        if (_RemovedLink != NULL)
        {
            _RemovedLink->release_ref(_LinkedTarget);
        }

         return _Removed;
    }

    /// <summary>
    ///     Acquires a reference on the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    void reference()
    {
        _LockHolder _Lock(_M_lock);
        _M_iteratorCount++;
    }

    /// <summary>
    ///     Releases the reference on the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    void release()
    {
        ITarget<typename _Block::source_type> * _LinkedTarget = _M_pLinkedTarget;
        ::Concurrency::details::_Dynamic_array<_EType> _LinksToRemove;

        {
            _LockHolder _Lock(_M_lock);
            _ASSERTE(_M_iteratorCount > 0);
            _M_iteratorCount--;

            if (_M_iteratorCount == 0)
            {
                if (_M_pendingRemove._Size() > 0)
                {
                    // Snap the pending remove list with the lock held
                    _M_pendingRemove._Swap(_LinksToRemove);
                }
            }
        }

        // NOTE: touching "this" pointer is dangerous as soon as the above lock is released

        // Release the references
        size_t _Size = _LinksToRemove._Size();

        for (size_t _I=0; _I < _Size; _I++)
        {
            _LinksToRemove[_I]->release_ref(_LinkedTarget);
        }
    }

    /// <summary>
    ///     Searches the <c>network_link_registry</c> within this <c>source_link_manager</c> 
    ///     object for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched for in the <c>source_link_manager</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the specified block was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool contains(_EType _Link)
    {
        _LockHolder _Lock(_M_lock);
        return _M_links.contains(_Link);
    }

    /// <summary>
    ///     Counts the number of linked blocks in the <c>source_link_manager</c> object.
    /// </summary>
    /// <returns>
    ///     The number of linked blocks in the <c>source_link_manager</c> object.
    /// </returns>
    /**/
    size_t count()
    {
        _LockHolder _Lock(_M_lock);
        return _M_links.count();
    }


    /// <summary>
    ///     Returns an iterator to the first element in the <c>source_link_manager</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state of the iterator is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>source_link_manager</c> object.
    /// </returns>
    /**/
    iterator begin() 
    {
        return (iterator(this, 0));
    }

private:

    // Called by the iterator. This routine takes a snapshot of the links
    // in the registry and copies it to the array provided.
    void _To_array(::Concurrency::details::_Dynamic_array<_EType>& _Array)
    {
        _LockHolder _Lock(_M_lock);
        _M_iteratorCount++;

        for(_LinkRegistry::iterator _Link = _M_links.begin(); *_Link != NULL; _Link++)
        {
            _Array._Push_back(*_Link);
        }
    }

    // Internal lock used for synchronization
    _LockType _M_lock;

    // Count to indicate that an iterator is active
    volatile long _M_iteratorCount;

    // A vector of all pending link remove operations
    ::Concurrency::details::_Dynamic_array<_EType> _M_pendingRemove;

    // Underlying link registry
    _LinkRegistry _M_links;

    // Target block holding this source link manager
    ITarget<typename _Block::source_type> * volatile _M_pLinkedTarget;
};

/// <summary>
///     The valid responses for an offer of a <c>message</c> object to a block.
/// </summary>
/**/
enum message_status
{
    /// <summary>
    ///     The target accepted the message.
    /// </summary>
    /**/
    accepted,
    /// <summary>
    ///     The target did not accept the message.
    /// </summary>
    /**/
    declined,
    /// <summary>
    ///     The target postponed the message.
    /// </summary>
    /**/
    postponed,
    /// <summary>
    ///     The target tried to accept the message, but it was no longer available.
    /// </summary>
    /**/
    missed 
};

/// <summary>
///     The basic message envelope containing the data payload being passed between
///     messaging blocks.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within the message.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/**/
template<class _Type>
class message : public ::Concurrency::details::_Runtime_object
{
    friend class ::Concurrency::details::_Queue<message<_Type>>;
    friend class ::Concurrency::details::_Async_send_queue<message<_Type>>;

public:
    /// <summary>
    ///     Constructs a <c>message</c> object.
    /// </summary>
    /// <param name="_P">
    ///     The payload of this message.
    /// </param>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if the parameter <paramref name="_Msg"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    message(_Type const &_P) : payload(_P), _M_pNext(NULL), _M_refCount(0) { }

    /// <summary>
    ///     Constructs a <c>message</c> object.
    /// </summary>
    /// <param name="_Msg">
    ///     A reference or pointer to a <c>message</c> object.
    /// </param>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if the parameter <paramref name="_Msg"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    message(message const & _Msg) : payload(_Msg.payload), _M_pNext(NULL), _M_refCount(0) { }

    /// <summary>
    ///     Constructs a <c>message</c> object.
    /// </summary>
    /// <param name="_Msg">
    ///     A reference or pointer to a <c>message</c> object.
    /// </param>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if the parameter <paramref name="_Msg"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    message(message const * _Msg) : payload((_Msg == NULL) ? NULL : _Msg->payload), _M_pNext(NULL), _M_refCount(0)
    {
        if (_Msg == NULL)
        {
            throw std::invalid_argument("_Msg");
        }
    }

    /// <summary>
    ///     Destroys the <c>message</c> object.
    /// </summary>
    /**/
    virtual ~message() { }

    /// <summary>
    ///     Returns the ID of the <c>message</c> object.
    /// </summary>
    /// <returns>
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object.
    /// </returns>
    /**/
    runtime_object_identity msg_id() const
    {
        return _M_id;
    }

    /// <summary>
    ///     The payload of the <c>message</c> object.
    /// </summary>
    /**/
    _Type const payload;

    /// <summary>
    ///     Adds to the reference count for the <c>message</c> object.  Used for message blocks that
    ///     need reference counting to determine message lifetimes.
    /// </summary>
    /// <returns>
    ///     The new value of the reference count.
    /// </returns>
    /**/
    long add_ref()
    {
        return _InterlockedIncrement(&_M_refCount);
    }

    /// <summary>
    ///     Subtracts from the reference count for the <c>message</c> object.  Used for message blocks that
    ///     need reference counting to determine message lifetimes.
    /// </summary>
    /// <returns>
    ///     The new value of the reference count.
    /// </returns>
    /**/
    long remove_ref()
    {
        return _InterlockedDecrement(&_M_refCount);
    }

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

private:
    // The intrusive next pointer used by blocks that need
    // to chain messages it's holding together
    message * _M_pNext;

    // Avoid warnings about not generating assignment operators.
    message<_Type> const &operator =(message<_Type> const &);

    // A reference count for the message
    volatile long _M_refCount;
};

//**************************************************************************
// Message processor:
//**************************************************************************

/// <summary>
///     The <c>message_processor</c> class is the abstract base class for processing of
///     <c>message</c> objects.  There is no guarantee on the ordering of the messages.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within messages handled by this <c>message_processor</c> object.
/// </typeparam>
/// <seealso cref="ordered_message_processor Class"/>
/**/
template<class _Type>
class message_processor
{
public:

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    /// <summary>
    ///     When overridden in a derived class, places messages into the block asynchronously.
    /// </summary>
    /// <param name="_Msg">
    ///     A <c>message</c> object to send asynchronously.
    /// </param>
    /// <remarks>
    ///     Processor implementations should override this method.
    /// </remarks>
    /**/
    virtual void async_send(message<_Type> * _Msg) = 0;

    /// <summary>
    ///     When overridden in a derived class, places messages into the block synchronously.
    /// </summary>
    /// <param name="_Msg">
    ///     A <c>message</c> object to send synchronously.
    /// </param>
    /// <remarks>
    ///     Processor implementations should override this method.
    /// </remarks>
    /**/
    virtual void sync_send(message<_Type> * _Msg) = 0;

    /// <summary>
    ///     When overridden in a derived class, waits for all asynchronous operations to complete.
    /// </summary>
    /// <remarks>
    ///     Processor implementations should override this method.
    /// </remarks>
    /**/
    virtual void wait() = 0;

protected:

    /// <summary>
    ///     When overridden in a derived class, performs the forward processing of
    ///     messages into the block. Called once every time a new message is added and
    ///     the queue is found to be empty.
    /// </summary>
    /// <remarks>
    ///     Message block implementations should override this method.
    /// </remarks>
    /**/
    virtual void process_incoming_message() = 0;

    /// <summary>
    ///     Wrapper for <c>process_incoming_message</c> suitable for use as a argument to
    ///     <c>CreateThread</c> and other similar methods.
    /// </summary>
    /// <param name="_Data">
    ///     A pointer to a message processor passed as a void pointer.
    /// </param>
    /**/
    static void __cdecl _Process_incoming_message_wrapper(void * _Data)
    {
       message_processor<_Type> * _PMessageProcessor = (message_processor<_Type> *) _Data;
       _PMessageProcessor->process_incoming_message();
    }
};

/// <summary>
///     An <c>ordered_message_processor</c> is a <c>message_processor</c> that allows message blocks
///     to process messages in the order they were received.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of messages handled by the processor.
/// </typeparam>
/**/
template<class _Type>
class ordered_message_processor : public message_processor<_Type>
{
public:

    /// <summary>
    ///     The signature of the callback method invoked while processing messages. 
    /// </summary>
    /**/
    typedef std::tr1::function<void(message<_Type> *)>  _Handler_method;

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef _Type type;

    /// <summary>
    ///     Constructs an <c>ordered_message_processor</c> object.
    /// </summary>
    /// <remarks>
    ///     This <c>ordered_message_processor</c> will not schedule asynchronous or synchronous 
    ///     handlers until the <c>initialize</c> function is called.
    /// </remarks>
    /**/
    ordered_message_processor() :
      _M_queuedDataCount(0),
      _M_stopProcessing(1),
      _M_lwtCount(0),
      _M_pScheduler(NULL),
      _M_pScheduleGroup(NULL),
      _M_handler(NULL)
    {
    }

    /// <summary>
    ///     Destroys the <c>ordered_message_processor</c> object.
    /// </summary>
    /// <remarks>
    ///     Waits for all outstanding asynchronous operations before destroying the processor.
    /// </remarks>
    /**/
    virtual ~ordered_message_processor()
    {
        wait();
    }

    /// <summary>
    ///     Initializes the <c>ordered_message_processor</c> object with the appropriate
    ///     callback function, scheduler and schedule group.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A pointer to the scheduler to be used for scheduling light-weight tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     A pointer to the schedule group to be used for scheduling light-weight tasks.
    /// </param>
    /// <param name="_Handler">
    ///     The handler functor invoked during callback.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize(Scheduler * _PScheduler, ScheduleGroup * _PScheduleGroup, _Handler_method const& _Handler)
    {
        _M_pScheduler = _PScheduler;
        _M_pScheduleGroup = _PScheduleGroup;
        _M_handler = _Handler;
        _M_stopProcessing = 0;
    }

    /// <summary>
    ///     Synchronously queues up messages and starts a processing task, if this has not been done
    ///     already.
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a message.
    /// </param>
    /**/
    virtual void sync_send(message<_Type> * _Msg)
    {
         if (_M_handler == NULL)
         {
             throw invalid_operation("sync_send called without registering a callback");
         }

        // Indicate that an LWT is in progress. This will cause the
        // destructor to block.
        _InterlockedIncrement(&_M_lwtCount);

        // Message block destructors sets the _M_stopProcessing flag to stop
        // processing any more messages. This is required to guarantee
        // that the destructor's wait_for_async_sends will complete

        if (_M_stopProcessing != 0) 
        {
            // Destructor is running. Do not process the message
            // Delete the msg, if any.
            if (_Msg != NULL)
            {
                delete _Msg;
            }
        }
        else
        {
            if (_Msg != NULL)
            {
                _M_queuedMessages._Enqueue(_Msg);
            }

            _InterlockedIncrement(&_M_queuedDataCount);

            _Process_message_helper();
        }

        // If we get there then no task was scheduled. Decrement LWT count to reflect this fact
        _InterlockedDecrement(&_M_lwtCount);
    }

    /// <summary>
    ///     Asynchronously queues up messages and starts a processing task, if this has not been done
    ///     already.
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a message.
    /// </param>
    /**/
    virtual void async_send(message<_Type> * _Msg)
    {
         if (_M_handler == NULL)
         {
             throw invalid_operation("async_send called without registering a callback");
         }

        // Indicate that an LWT is in progress. This will cause the
        // destructor to block.
        _InterlockedIncrement(&_M_lwtCount);

        // Message block destructors sets the _M_stopProcessing flag to stop
        // processing any more messages. This is required to guarantee
        // that the destructor's wait_for_async_Sends will complete
        if (_M_stopProcessing != 0) 
        {
            // Destructor is running. Do not scheduler an LWT.
            // Delete the msg, if any.
            if (_Msg != NULL)
            {
                delete _Msg;
            }
        }
        else
        {
            //
            // If there is a message to send, enqueue it in the processing queue.
            // async_send can be sent a NULL message if the block wishes to reprocess
            // the messages that are in its queue.  For example, an unbounded_buffer
            // that has its head node released after reservation.
            //
            if (_Msg != NULL)
            {
                _M_queuedMessages._Enqueue(_Msg);
            }

            if (_InterlockedIncrement(&_M_queuedDataCount) == 1)
            {
                
                _ASSERTE(_M_lwtCount > 0);

                TaskProc _Proc = &::Concurrency::ordered_message_processor<_Type>::_Process_incoming_message_wrapper;
                if (_M_pScheduleGroup != NULL)
                {
                    _M_pScheduleGroup->ScheduleTask(_Proc, this);
                }
                else if (_M_pScheduler != NULL)
                {
                    _M_pScheduler->ScheduleTask(_Proc, this);
                }
                else
                {
                    CurrentScheduler::ScheduleTask(_Proc, this);
                }

                // The LWT will decrement _M_lwtCount.
                return;
            }
            
        }

        // If we get here then no task was scheduled. Decrement LWT count to reflect this fact
        _InterlockedDecrement(&_M_lwtCount);
    }

    /// <summary>
    ///     A processor-specific spin wait used in destructors of message blocks to make sure
    ///     that all asynchronous processing tasks have time to finish before destroying the block.
    /// </summary>
    /**/
    virtual void wait()
    {
        // Cease processing of any new messages
        _InterlockedIncrement(&_M_stopProcessing);

        // This spin is here waiting to make sure all previously initiated message processings
        // will still correctly process.  As soon as this count reaches zero, we can
        // procede with the message block destructor.
        ::Concurrency::details::_SpinWaitBackoffNone spinWait(Context::Yield);
        while(_M_lwtCount != 0)
        {
            spinWait._SpinOnce();
        }
    }

protected:
    /// <summary>
    ///     The processing function that is called asynchronously.  It dequeues messages and begins
    ///     processing them.
    /// </summary>
    /**/
    virtual void process_incoming_message()
    {
        _Process_message_helper();

        // Indicate that an LWT completed
        _InterlockedDecrement(&_M_lwtCount);

        // Do not access any members here. If the count goes to
        // 0 as a result of the above decrement, the object
        // could be immediately deleted.
    }

 private:

    // Helper function to dequeue and process messages to any targets
    void _Process_message_helper()
    {
        _NR_lock _Lock(_M_internalLock);

        // This count could be 0 if there was both a synchronous and asynchronous
        // send occuring.  One of them could have sent all of the messages for the other
        if (_M_queuedDataCount == 0)
        {
            return;
        }

        do
        {
            message<_Type> * _Msg = _M_queuedMessages._Dequeue();
            _M_handler(_Msg);
        }
        while(_InterlockedDecrement(&_M_queuedDataCount) > 0);
    }

private:
    /// <summary>
    ///     The scheduler to process messages on
    /// </summary>
    /**/
    Scheduler * _M_pScheduler;

    /// <summary>
    ///     The schedule group to process messages on
    /// </summary>
    /**/
    ScheduleGroup * _M_pScheduleGroup;
    
    /// <summary>
    ///     A queue of the messages
    /// </summary>
    /**/
    ::Concurrency::details::_Async_send_queue<message<_Type>> _M_queuedMessages;

    /// <summary>
    ///     A lock to use for queueing incoming messages.
    /// </summary>
    /**/
    ::Concurrency::details::_NonReentrantPPLLock _M_internalLock;

    /// <summary>
    ///     A count of the current number of messages to process.  Used as a flag
    ///     to see if a new process message task needs to be created.
    /// </summary>
    /**/
    volatile long _M_queuedDataCount;

    /// <summary>
    ///     A flag set in the destructor of a block to cease processing of new messages.
    ///     This is required to guarantee that _M_queuedDataCount will get to 0 eventually. 
    /// </summary>
    /**/
    volatile long _M_stopProcessing;

    /// <summary>
    ///     A counter to indicate the number of outstanding LWTs
    /// </summary>
    /**/
    volatile long _M_lwtCount;

    /// <summary>
    ///     A message handler object which expose the callback to be invoked
    /// </summary>
    /**/
    _Handler_method _M_handler;
};

/// <summary>
///     The <c>ITarget</c> class is the interface for all target blocks.  Target blocks
///     consume messages offered to them by <c>ISource</c> blocks.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within the messages accepted by the target block.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="ISource Class"/>
/**/
template<class _Type>
class ITarget
{
    //
    // ISource<T> is a friend class because calls to Source->link_target()
    // and Source->unlink_target() need to call their respective
    // Target->link_source() and Target->unlink_source() on the block they are
    // linking/unlinking.  Those functions are private here because we don't
    // want users calling link_source() or unlink_source() directly.  link_source/
    // unlink_source don't call respective link_target/unlink_target because an
    // infinite loop would occur.
    //
    friend class ISource<_Type>;

public:
    /// <summary>
    ///     Destroys the <c>ITarget</c> object.
    /// </summary>
    /**/
    virtual ~ITarget() {}

    // It is important that calls to propagate do *not* take the same lock on an
    // internal message structure that is used by Consume and the LWT.  Doing so could
    // result in a deadlock with the Consume call.

    /// <summary>
    ///     When overridden in a derived class, asynchronously passes a message from a source block to
    ///     this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual message_status propagate(message<_Type> * _PMessage, ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, synchronously passes a message to the target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    ///     <para>Using the <c>send</c> method outside of message initiation and to propagate messages
    ///     within a network is dangerous and can lead to deadlock.</para>
    ///     <para>When <c>send</c> returns, the message has either already been accepted, and transferred into
    ///     the target block, or it has been declined by the target.</para>
    /// </remarks>
    /**/
    virtual message_status send(message<_Type> * _PMessage, ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    /// <summary>
    ///     The signature of any method used by the block that returns a <c>bool</c> value to determine
    ///     whether an offered message should be accepted.
    /// </summary>
    /**/
    typedef std::tr1::function<bool(_Type const&)> filter_method;

protected:

    /// <summary>
    ///     When overridden in a derived class, links a specified source block to this <c>ITarget</c> block.
    /// </summary>
    /// <param name="_PSource">
    ///     The <c>ISource</c> block being linked to this <c>ITarget</c> block.
    /// </param>
    /// <remarks>
    ///     This function should not be called directly on an <c>ITarget</c> block. Blocks should be connected together
    ///     using the <c>link_target</c> method on <c>ISource</c> blocks, which will invoke the <c>link_source</c> method
    ///     on the corresponding target.
    /// </remarks>
    /**/
    virtual void link_source(ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks a specified source block from this <c>ITarget</c> block.
    /// </summary>
    /// <param name="_PSource">
    ///     The <c>ISource</c> block being unlinked from this <c>ITarget</c> block.
    /// </param>
    /// <remarks>
    ///     This function should not be called directly on an <c>ITarget</c> block. Blocks should be disconnected
    ///     using the <c>unlink_target</c> or <c>unlink_targets</c> methods on <c>ISource</c> blocks, which will invoke
    ///     the <c>unlink_source</c> method on the corresponding target.
    /// </remarks>
    /**/
    virtual void unlink_source(ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks all source blocks from this <c>ITarget</c> block.
    /// </summary>
    /**/
    virtual void unlink_sources() = 0;
};

/// <summary>
///     The <c>ISource</c> class is the interface for all source blocks.  Source blocks
///     propagate messages to <c>ITarget</c> blocks.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within the messages produced by the source block.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="ITarget Class"/>
/**/
template<class _Type>
class ISource
{
public:
    /// <summary>
    ///     Destroys the <c>ISource</c> object.
    /// </summary>
    /**/
    virtual ~ISource() {}

    /// <summary>
    ///     When overridden in a derived class, links a target block to this <c>ISource</c> block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block being linked to this <c>ISource</c> block.
    /// </param>
    /**/
    virtual void link_target(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks a target block from this <c>ISource</c> block,
    ///     if found to be previously linked.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block being unlinked from this <c>ISource</c> block.
    /// </param>
    /**/
    virtual void unlink_target(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks all target blocks from this
    ///     <c>ISource</c> block.
    /// </summary>
    /**/
    virtual void unlink_targets() = 0;

    /// <summary>
    ///     When overridden in a derived class, accepts a message that was offered by this <c>ISource</c> block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>accept</c> method is called by a target while a message is being offered by this <c>ISource</c> block.
    ///     The message pointer returned may be different from the one passed into the <c>propagate</c> method
    ///     of the <c>ITarget</c> block, if this source decides to make a copy of the message.
    /// </remarks>
    /**/
    virtual message<_Type> * accept(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, reserves a message previously offered by this <c>ISource</c> block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, consumes a message previously offered by this <c>ISource</c> block
    ///     and successfully reserved by the target, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, acquires a reference count on this <c>ISource</c> block, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, releases a reference count on this <c>ISource</c> block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type source_type;

protected:
    /// <summary>
    ///     Links this source to a target.
    /// </summary>
    /// <param name="_PLinkFrom">
    ///     A pointer to the target.
    /// </param>
    /// <remarks>
    ///     This function definition is required because ISource blocks need to call
    ///     Target->link_source(), which is a private memeber of ITarget.  ISource is
    ///     declared as a friend class, so this is an way for derived classes of ISource
    ///     to properly link/unlink their targets during link_target(), unlink_target() and
    ///     unlink_targets()
    /// </remarks>
    /**/
    void _Invoke_link_source(ITarget<_Type> * _PLinkFrom)
    {
        _PLinkFrom->link_source(this);
    }

    /// <summary>
    ///     Unlinks this source from a target.
    /// </summary>
    /// <param name="_PUnlinkFrom">
    ///     A pointer to the target.
    /// </param>
    /// <remarks>
    ///     This function definition is required because ISource blocks need to call
    ///     Target->unlink_source(), which is a private memeber of ITarget.  ISource is
    ///     declared as a friend class, so this is an way for derived classes of ISource
    ///     to properly link/unlink their targets during link_target(), unlink_target() and
    ///     unlink_targets()
    /// </remarks>
    /**/
    void _Invoke_unlink_source(ITarget<_Type> * _PUnlinkFrom)
    {
        _PUnlinkFrom->unlink_source(this);
    }
};

//**************************************************************************
// Target Block:
//**************************************************************************

/// <summary>
///     The <c>target_block</c> class is an abstract base class that provides basic link management
///     functionality and error checking for target only blocks.
/// </summary>
/// <typeparam name="_SourceLinkRegistry">
///     The link registry to be used for holding the source links.
/// </typeparam>
/// <typeparam name="_MessageProcessorType">
///     The processor type for message processing.
/// </typeparam>
/// <seealso cref="ITarget Class"/>
/**/
template<class _SourceLinkRegistry, 
    class _MessageProcessorType = ordered_message_processor<typename _SourceLinkRegistry::type::source_type>>
class target_block : public ITarget<typename _SourceLinkRegistry::type::source_type>
{
public:

    /// <summary>
    ///     The type of the payload for the incoming messages to this <c>target_block</c> object.
    /// </summary>
    /**/
    typedef typename _SourceLinkRegistry::type::source_type _Source_type;

    /// <summary>
    ///     The type of the <c>source_link_manager</c> this <c>target_block</c> object.
    /// </summary>
    /**/
    typedef source_link_manager<_SourceLinkRegistry> _SourceLinkManager;

    /// <summary>
    ///     The type of the iterator for the <c>source_link_manager</c> for this <c>target_block</c> object.
    /// </summary>
    /**/
    typedef typename _SourceLinkManager::iterator source_iterator;

    /// <summary>
    ///     Constructs a <c>target_block</c> object.
    /// </summary>
    /**/
    target_block() : _M_pFilter(NULL), _M_fDeclineMessages(false)
    {
    }

    /// <summary>
    ///     Destroys the <c>target_block</c> object.
    /// </summary>
    /**/
    virtual ~target_block()
    {
        // All sources should have been unlinked
        _ASSERTE(_M_connectedSources.count() == 0);
        delete _M_pFilter;
    }

    /// <summary>
    ///     Asynchronously passes a message from a source block to this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     <para> The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.</para>
    /// </remarks>
    /**/
    virtual message_status propagate(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by <c>consume</c> and the LWT.  Doing so could
        // result in a deadlock.

        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return propagate_message(_PMessage, _PSource);
    }

    /// <summary>
    ///     Synchronously passes a message from a source block to this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    ///     <para>Using the <c>send</c> method outside of message initiation and to propagate messages
    ///     within a network is dangerous and can lead to deadlock.</para>
    ///     <para>When <c>send</c> returns, the message has either already been accepted, and transferred into
    ///     the target block, or it has been declined by the target.</para>
    /// </remarks>
    /**/
    virtual message_status send(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return send_message(_PMessage, _PSource);
    }

protected:

    /// <summary>
    ///     When overridden in a derived class, this method asynchronously passes a message from an <c>ISource</c>
    ///     block to this <c>target_block</c> object. It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, this method synchronously passes a message from an <c>ISource</c>
    ///     block to this <c>target_block</c> object. It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     By default, this block returns <c>declined</c> unless overridden by a derived class.
    /// </remarks>
    /**/
    virtual message_status send_message(message<_Source_type> *, ISource<_Source_type> *)
    {
        // By default we do not allow send()
        return declined;
    }

    /// <summary>
    ///     Links a specified source block to this <c>target_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be linked.
    /// </param>
    /// <remarks>
    ///     This function should not be called directly on a <c>target_block</c> object. Blocks should be connected together
    ///     using the <c>link_target</c> method on <c>ISource</c> blocks, which will invoke the <c>link_source</c> method
    ///     on the corresponding target.
    /// </remarks>
    /**/
    virtual void link_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.add(_PSource);
    }

    /// <summary>
    ///     Unlinks a specified source block from this <c>target_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be unlinked.
    /// </param>
    ///     This function should not be called directly on n <c>target_block</c> object. Blocks should be disconnected
    ///     using the <c>unlink_target</c> or <c>unlink_targets</c> methods on <c>ISource</c> blocks, which will invoke
    ///     the <c>unlink_source</c> method on the corresponding target.
    /**/
    virtual void unlink_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.remove(_PSource);
    }

    /// <summary>
    ///     Unlinks all source blocks from this <c>target_block</c> object.
    /// </summary>
    /**/
    virtual void unlink_sources()
    {
        for (source_iterator _Iter = _M_connectedSources.begin(); *_Iter != NULL; ++_Iter)
        {
             ISource<_Source_type> * _PSource = *_Iter;
             _PSource->unlink_target(this);
        }
    }

    /// <summary>
    ///     When overriden in a derived class, processes a message that was accepted by this <c>target_block</c> object.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message that is to be handled.
    /// </param>
    /**/
    virtual void process_message(message<_Source_type> *)
    {
    }

    //
    // Utility routines
    //

    /// <summary>
    ///     Registers a filter method that will be invoked on
    ///     every message received.
    /// </summary>
    /// <param name="_Filter">
    ///     The filter method.
    /// </param>
    /**/
    void register_filter(filter_method const& _Filter)
    {
        if (_Filter != NULL)
        {
            _M_pFilter = new filter_method(_Filter);
        }
    }

    /// <summary>
    ///     Indicates to the block that new messages should be declined.
    /// </summary>
    /// <remarks>
    ///     This method is called by the destructor to ensure that new messages are declined while destruction is in progress.
    /// </remarks>
    /**/
    void decline_incoming_messages()
    {
        _M_fDeclineMessages = true;
    }

    /// <summary>
    ///     Initializes the base object. Specifically, the <c>message_processor</c> object needs
    ///     to be initialized.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The scheduler to be used for scheduling tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group to be used for scheduling tasks.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize_target(Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        // Register a callback with the processor
        _M_messageProcessor.initialize(_PScheduler, _PScheduleGroup, [this](message<_Source_type> * _PMessage)
        {
            this->process_message(_PMessage);
        });

        // Register this target block as the owner of the connected sources
        _M_connectedSources.register_target_block(this);
    }

    /// <summary>
    ///     Asynchronously sends a message for processing.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message being sent.
    /// </param>
    /**/
    void async_send(message<_Source_type> * _PMessage)
    {
        _M_messageProcessor.async_send(_PMessage);
    }

    /// <summary>
    ///     Synchronously send a message for processing.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message being sent.
    /// </param>
    /**/
    void sync_send(message<_Source_type> * _PMessage)
    {
        _M_messageProcessor.sync_send(_PMessage);
    }

    /// <summary>
    ///     Waits for all asynchronous propagations to complete.
    /// </summary>
    /// <remarks>
    ///     This method is used by message block destructors to ensure all asynchronous operations
    ///     have had time to finish before destroying the block.
    /// </remarks>
    /**/
    void wait_for_async_sends()
    {
        // Decline new messages to ensure that messages are not dropped during the wait
        decline_incoming_messages();

        _M_messageProcessor.wait();
    }

    /// <summary>
    ///     Unlinks all sources after waiting for outstanding asynchronous send operations to complete.
    /// </summary>
    /// <remarks>
    ///     All target blocks should call this routine to remove the sources in their destructor.
    /// </remarks>
    /**/
    void remove_sources()
    {
        wait_for_async_sends();

        unlink_sources();
    }

    /// <summary>
    ///     The container for all the sources connected to this block.
    /// </summary>
    /**/
    _SourceLinkManager _M_connectedSources;

    /// <summary>
    ///     The filter function which determines whether offered messages should be accepted.
    /// </summary>
    /**/
    filter_method * _M_pFilter;

    /// <summary>
    ///     A <c>bool</c> that is set to indicate that all messages should be declined 
    ///     in preparation for deleting the block
    /// <summary>
    /**/
    bool _M_fDeclineMessages;  

    /// <summary>
    ///     The <c>message_processor</c> for this <c>target_block</c>.
    /// <summary>
    /**/
    _MessageProcessorType _M_messageProcessor;
};

//**************************************************************************
// Source Block:
//**************************************************************************

/// <summary>
///     The <c>source_block</c> class is an abstract base class for source-only blocks. The class
///     provides basic link management functionality as well as common error checks.
/// </summary>
/// <typeparam name="_TargetLinkRegistry">
///     Link registry to be used for holding the target links.
/// </typeparam>
/// <typeparam name="_MessageProcessorType">
///     Processor type for message processing.
/// </typeparam>
/// <remarks>
///     Message blocks should derive from this block to take advantage of link management and
///     synchronization provided by this class.
/// </remarks>
/// <seealso cref="ISource Class"/>
/**/
template<class _TargetLinkRegistry,
    class _MessageProcessorType = ordered_message_processor<typename _TargetLinkRegistry::type::type>>
class source_block : public ISource<typename _TargetLinkRegistry::type::type>
{
public:

    /// <summary>
    ///     The payload type of messages handled by this <c>source_block</c>.
    /// </summary>
    /**/
    typedef typename _TargetLinkRegistry::type::type _Target_type;

    /// <summary>
    ///     The iterator to walk the connected targets.
    /// </summary>
    /**/
    typedef typename _TargetLinkRegistry::iterator target_iterator;

    /// <summary>
    ///     Constructs a <c>source_block</c> object.
    /// </summary>
    /**/
    source_block() : 
      _M_pReservedFor(NULL),
      _M_reservedId(0),
      _M_referenceCount(0)
    {
    }

    /// <summary>
    ///     Destroys the <c>source_block</c> object.
    /// </summary>
    /**/
    virtual ~source_block()
    {
        // All targets should have been unlinked
        _ASSERTE(_M_connectedTargets.count() == 0);
    }

    /// <summary>
    ///     Links a target block to this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to link to this <c>source_block</c> object.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual void link_target(ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        _M_connectedTargets.add(_PTarget);
        _Invoke_link_source(_PTarget);
        link_target_notification(_PTarget);

    }

    /// <summary>
    ///     Unlinks a target block from this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to unlink from this <c>source_block</c> object.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual void unlink_target(ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if (_M_connectedTargets.remove(_PTarget))
        {
            // We were able to remove the target from our list.
            // Inform the target to unlink from us
            _Invoke_unlink_source(_PTarget);
        }
    }

    /// <summary>
    ///     Unlinks all target blocks from this <c>source_block</c> object.
    /// </summary>
    /**/
    virtual void unlink_targets()
    {
        _R_lock _Lock(_M_internalLock);

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter) 
        {
            ITarget<_Target_type> * _PTarget = *_Iter;
            _ASSERTE(_PTarget != NULL);

            unlink_target(_PTarget);
        }

        // All the targets should be unlinked.
        _ASSERTE(_M_connectedTargets.count() == 0);
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>source_block</c> object, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     <para>
    ///     The <c>accept</c> method is called by a target while a message is being offered by this <c>ISource</c> block.
    ///     The message pointer returned may be different from the one passed into the <c>propagate</c> method
    ///     of the <c>ITarget</c> block, if this source decides to make a copy of the message.
    ///     </para>
    /// </remarks>
    /**/
    virtual message<_Target_type> * accept(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        // Assert if the target is not connected
        _ASSERTE(_M_connectedTargets.contains(_PTarget));

        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>source_block</c> object.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     <para>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    ///     </para>
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if ( _M_pReservedFor != NULL)
        {
            // Someone else is holding the reservation
            return false;
        }

        if (!reserve_message(_MsgId))
        {
            // Failed to reserve the msg id
            return false;
        }

        // Save the reserving target and the msg id
        _M_pReservedFor = _PTarget;
        _M_reservedId = _MsgId;
        
        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by this <c>source_block</c> object and successfully reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     <para>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     </para>
    ///     <para>
    ///     The method throws a <see cref="bad_target Class">bad_target</see> exception if the parameter <paramref name="_PTarget"/>
    ///     does not represent the target that called <c>reserve</c>.
    ///     </para>
    ///     <para>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    ///     </para>
    /// </remarks>
    /**/
    virtual message<_Target_type> * consume(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }       

        if (_M_pReservedFor == NULL || _PTarget != _M_pReservedFor)
        {
            throw bad_target();
        }

        message<_Target_type> * _Msg = consume_message(_MsgId);

        if (_Msg != NULL)
        {
            // Clear the reservation 
            // _M_pReservedId is intentionally not reset so that it can assist in debugging
            _M_pReservedFor = NULL;

            // Reservation is assumed to block propagation. Notify that propagation can now be resumed
            resume_propagation();
        }

        return _Msg;
    }

    /// <summary>
    ///     Releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /// <remarks>
    ///     <para>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     </para>
    ///     <para>
    ///     The method throws a <see cref="bad_target Class">bad_target</see> exception if the parameter <paramref name="_PTarget"/>
    ///     does not represent the target that called <c>reserve</c>.
    ///     </para>
    /// </remarks>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if (_PTarget != _M_pReservedFor)
        {
            throw bad_target();
        }

        release_message(_MsgId);

        // Clear the reservation
        // _M_pReservedId is intentionally not reset so that it can assist in debugging
        _M_pReservedFor = NULL;

        // Reservation is assumed to block propagation. Notify that propagation can now be resumed
        resume_propagation();
    }

    /// <summary>
    ///     Acquires a reference count on this <c>source_block</c> object, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<_Target_type> *)
    {
        _InterlockedIncrement(&_M_referenceCount);
    }

    /// <summary>
    ///     Releases a reference count on this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<_Target_type> * _PTarget)
    {
        if (_PTarget != NULL)
        {
            _R_lock _Lock(_M_internalLock);

            // We assume that each target would keep a single reference on its source, so
            // we call unlink target notification on every release. Otherwise, we would be
            // required to keep a reference count per target.
            // Note: unlink_target_notification can check the value of this _PTarget pointer, but
            // must not dereference it, as it may have already been deleted.
            unlink_target_notification(_PTarget);
        }

        _InterlockedDecrement(&_M_referenceCount);

        // It is *unsafe* to touch the "this" pointer after decrementing the reference count
    }

protected:

    //
    // Protected methods that a derived class can override to customize
    // the functionality
    //

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     The <c>ITarget</c> block that was linked.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Target_type> *)
    {
        // By default, we restart propagation if there is no pending resrvation
        if (_M_pReservedFor == NULL)
        {
            propagate_to_any_targets(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a target has been unlinked from this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     The <c>ITarget</c> block that was unlinked.
    /// </param>
    /**/
    virtual void unlink_target_notification(ITarget<_Target_type> * _PTarget)
    {
        // At this point, the target has already been disconnected from the
        // source.  It is safe to check the value of this pointer, but not
        // safe to dereference it, as it may have already been deleted.

        // If the target being unlinked is the one holding the reservation,
        // release the reservation
        if (_M_pReservedFor == _PTarget)
        {
            release(_M_reservedId, _PTarget);
        }
    }

    /// <summary>
    ///     When overridden in a derived class, accepts an offered message by the source. 
    ///     Message blocks should override this method to validate the <paramref name="_MsgId"/> and
    ///     return a message.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     To transfer ownership, the original message pointer should be returned. To maintain
    ///     ownership, a copy of message payload needs to be made and returned.
    /// </remarks>
    /**/
    virtual message<_Target_type> * accept_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, reserves a message previously offered by this 
    ///     <c>source_block</c> object.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, consumes a message that was previously reserved.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Target_type> * consume_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation() = 0;

    /// <summary>
    ///     When overridden in a derived class, propagates the given message to any or all of the linked targets.
    ///     This is the main propagation routine for message blocks.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message that is to be propagated.
    /// </param>
    /**/
    virtual void propagate_to_any_targets(message<_Target_type> * _PMessage) = 0;

    //
    // Utility routines
    //

    /// <summary>
    ///     Initializes the <c>message_propagator</c> within this <c>source_block</c>.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The scheduler to be used for scheduling tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group to be used for scheduling tasks.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize_source(Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        // Register a callback
        _M_messageProcessor.initialize(_PScheduler, _PScheduleGroup, [this](message<_Target_type> * _PMessage)
        {
            this->_Handle_message(_PMessage);
        });
    }

    /// <summary>
    ///     Synchronously queues up messages and starts a propagation task, if this has not been done
    ///     already.
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a <c>message</c> object to synchronously send.
    /// </param>
    /**/
    virtual void sync_send(message<_Target_type> * _Msg)
    {
        // Caller shall not be holding any locks when calling this routine
        _M_messageProcessor.sync_send(_Msg);
    }

    /// <summary>
    ///     Asynchronously queues up messages and starts a propagation task, if this has not been done
    ///     already
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a <c>message</c> object to asynchronously send.
    /// </param>
    /**/
    virtual void async_send(message<_Target_type> * _Msg)
    {
        _M_messageProcessor.async_send(_Msg);
    }

    /// <summary>
    ///     Waits for all asynchronous propagations to complete. This propagator-specific spin wait is used 
    ///     in destructors of message blocks to make sure that all asynchronous propagations have time to finish 
    ///     before destroying the block.
    /// </summary>
    /**/
    void wait_for_outstanding_async_sends()
    {
        _M_messageProcessor.wait();
    }

    /// <summary>
    ///     Removes all target links for this source block. This should be called from the destructor.
    /// </summary>
    /**/
    void remove_targets()
    {
        // Wait for outstanding propagation to complete.
        wait_for_outstanding_async_sends();

        unlink_targets();

        _Wait_on_ref();
    }

    // 
    // Protected members
    //

    /// <summary>
    ///     Connected target that is holding a reservation
    /// </summary>
    /**/
    ITarget<_Target_type> * _M_pReservedFor;

    /// <summary>
    ///     Reserved message ID
    /// </summary>
    /**/
    runtime_object_identity _M_reservedId;

    /// <summary>
    ///     Connected targets
    /// </summary>
    /**/
    _TargetLinkRegistry _M_connectedTargets;

    /// <summary>
    ///     Processor used for asynchronous message handling
    /// </summary>
    /**/
    _MessageProcessorType _M_messageProcessor;

private:

    /// Private methods


    // Message handler callback for the propagator. Invokes propagate_to_any_targets
    // which derived classes should implement.
    /**/
    void _Handle_message(message<_Target_type> * _PMessage)
    {
        // Hold a lock to synchronize with unlink targets
        _R_lock _Lock(_M_internalLock);
        propagate_to_any_targets(_PMessage);
    }

    // Wait for the reference on this block to drop to zero
    /**/
    void _Wait_on_ref(long _RefCount = 0)
    {
        ::Concurrency::details::_SpinWaitBackoffNone spinWait;
        while(_M_referenceCount != _RefCount)
        {
            spinWait._SpinOnce();
        }
    }

    // Private Data members

    /// <summary>
    ///     Internal lock used for the following synchronization:
    ///     1. Synchronize between link and unlink target
    ///     2. Synchronize between propagate_to_any_targets and unlink_target
    ///     3. Synchronize between reserve and consume/release
    /// </summary>
    /**/
    ::Concurrency::details::_ReentrantPPLLock _M_internalLock;

    volatile long _M_referenceCount;

};

//**************************************************************************
// Propagator (source and target) Block:
//**************************************************************************
/// <summary>
///     The <c>propagator_block</c> class is an abstract base class for message blocks that are both a source and target.
///     It combines the functionality of both the <c>source_block</c> and <c>target_block</c> classes.
/// </summary>
/// <typeparam name="_TargetLinkRegistry">
///     The link registry to be used for holding the target links.
/// </typeparam>
/// <typeparam name="_SourceLinkRegistry">
///     The link registry to be used for holding the source links.
/// </typeparam>
/// <typeparam name="_MessageProcessorType">
///     The processor type for message processing.
/// </typeparam>
/// <remarks>
///     To avoid multiple inheritance, the <c>propagator_block</c> class inherits from the <c>source_block</c> class and <c>ITarget</c>
///     abstract class.  Most of the functionality in the <c>target_block</c> class is replicated here.
/// </remarks>
/// <seealso cref="source_block Class"/>
/// <seealso cref="ITarget Class"/>
/**/
template<class _TargetLinkRegistry, class _SourceLinkRegistry,
    class _MessageProcessorType = ordered_message_processor<typename _TargetLinkRegistry::type::type>>
class propagator_block : public source_block<_TargetLinkRegistry, _MessageProcessorType>, public ITarget<typename _SourceLinkRegistry::type::source_type>
{
public:

    /// <summary>
    ///     The type of the payload for the incoming message to this <c>propagator_block</c>.
    /// </summary>
    /**/
    typedef typename _SourceLinkRegistry::type::source_type _Source_type;

    /// <summary>
    ///     The type of the <c>source_link_manager</c> this <c>propagator_block</c>.
    /// </summary>
    /**/
    typedef source_link_manager<_SourceLinkRegistry> _SourceLinkManager;

    /// <summary>
    ///     The type of the iterator for the <c>source_link_manager</c> for this <c>propagator_block</c>.
    /// </summary>
    /**/
    typedef typename _SourceLinkManager::iterator source_iterator;

    /// <summary>
    ///     Constructs a <c>propagator_block</c> object.
    /// </summary>
    /**/
    propagator_block() : _M_pFilter(NULL), _M_fDeclineMessages(false)
    {
    }

    /// <summary>
    ///     Destroys a <c>propagator_block</c> object.
    /// </summary>
    /**/
    virtual ~propagator_block()
    {
        remove_network_links();

        delete _M_pFilter;
    }

    /// <summary>
    ///     Asynchronously passes a message from a source block to this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The <c>propagate</c> method is invoked on a target block by a linked source block. It queues up an
    ///     asynchronous task to handle the message, if one is not already queued or executing.
    ///     <para> The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.</para>
    /// </remarks>
    /**/
    virtual message_status propagate(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by <c>consume</c> and the LWT.  Doing so could
        // result in a deadlock.

        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return propagate_message(_PMessage, _PSource);
    }

    /// <summary>
    ///     Synchronously initiates a message to this block.  Called by an <c>ISource</c> block.
    ///     When this function completes, the message will already have propagated into the block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if either
    ///     the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual message_status send(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return send_message(_PMessage, _PSource);
    }

protected:

    /// <summary>
    ///     When overridden in a derived class, this method asynchronously passes a message from an <c>ISource</c>
    ///     block to this <c>propagator_block</c> object. It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, this method synchronously passes a message from an <c>ISource</c>
    ///     block to this <c>propagator_block</c> object. It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     By default, this block returns <c>declined</c> unless overridden by a derived class.
    /// </remarks>
    /**/
    virtual message_status send_message(message<_Source_type> *, ISource<_Source_type> *)
    {
        // By default we do not allow send()
        return declined;
    }

    /// <summary>
    ///     Links a specified source block to this <c>propagator_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be linked.
    /// </param>
    /**/
    virtual void link_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.add(_PSource);
    }

    /// <summary>
    ///     Unlinks a specified source block from this <c>propagator_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be unlinked.
    /// </param>
    /**/
    virtual void unlink_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.remove(_PSource);
    }

    /// <summary>
    ///     Unlinks all source blocks from this <c>propagator_block</c> object.
    /// </summary>
    /**/
    virtual void unlink_sources()
    {
        for (source_iterator _Iter = _M_connectedSources.begin(); *_Iter != NULL; ++_Iter)
        {
             ISource<_Source_type> * _PSource = *_Iter;
             _PSource->unlink_target(this);
        }
    }

    //
    // Utility routines
    //

    /// <summary>
    ///     Initializes the base object. Specifically, the <c>message_processor</c> object needs
    ///     to be initialized.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The scheduler to be used for scheduling tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group to be used for scheduling tasks.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize_source_and_target(Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        initialize_source(_PScheduler, _PScheduleGroup);

        // Register this propagator block as the owner of the connected sources
        _M_connectedSources.register_target_block(this);
    }

    /// <summary>
    ///     Registers a filter method that will be invoked on every received message.
    /// </summary>
    /// <param name="_Filter">
    ///     The filter method.
    /// </param>
    /**/
    void register_filter(filter_method const& _Filter)
    {
        if (_Filter != NULL)
        {
            _M_pFilter = new filter_method(_Filter);
        }
    }

    /// <summary>
    ///     Indicates to the block that new messages should be declined.
    /// </summary>
    /// <remarks>
    ///     This method is called by the destructor to ensure that new messages are declined while destruction is in progress.
    /// </remarks>
    /**/
    void decline_incoming_messages()
    {
        _M_fDeclineMessages = true;
    }

    /// <summary>
    ///     Removes all the source and target network links from this <c>propagator_block</c> object.
    /// </summary>
    /**/
    void remove_network_links()
    {
        // Decline messages while the links are being removed
        decline_incoming_messages();

        // Remove all the target links. This waits for 
        // all outstanding async propagation operations.
        remove_targets();

        // unlink all sources. The above steps guarantee that
        // they can be removed safely.
        unlink_sources();
    }

    /// <summary>
    ///     The container for all the sources connected to this block.
    /// </summary>
    /**/
    _SourceLinkManager _M_connectedSources;

    /// <summary>
    ///     The filter function which determines whether offered messages should be accepted.
    /// </summary>
    /**/
    filter_method * _M_pFilter;

    /// <summary>
    ///     A <c>bool</c> that is set to indicate that all messages should be declined 
    ///     in preparation for deleting the block
    /// <summary>
    /**/
    volatile bool _M_fDeclineMessages;   
};

//**************************************************************************
// Unbounded Buffers:
//**************************************************************************

/// <summary>
///     An <c>unbounded_buffer</c> messaging block is a multi-target, multi-source, ordered
///     <c>propagator_block</c> capable of storing an unbounded number of messages.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages stored and propagated by the buffer.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="overwrite_buffer Class"/>
/// <seealso cref="single_assignment Class"/>
/**/
template<class _Type>
class unbounded_buffer : public propagator_block<multi_link_registry<ITarget<_Type>>, multi_link_registry<ISource<_Type>>>
{
public:
    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer() 
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(filter_method const& _Filter)
    {
        initialize_source_and_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>unbounded_buffer</c> object is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(Scheduler& _PScheduler)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>unbounded_buffer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(Scheduler& _PScheduler, filter_method const& _Filter) 
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>unbounded_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(ScheduleGroup& _PScheduleGroup)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>unbounded_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(ScheduleGroup& _PScheduleGroup, filter_method const& _Filter)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /**/
    ~unbounded_buffer()
    {
        // Remove all links
        remove_network_links();
    }

    /// <summary>
    ///     Adds an item to the <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_Item">
    ///     The item to add.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the item was accepted, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool enqueue(_Type const& _Item)
    {
        return Concurrency::send<_Type>(this, _Item);
    }

    /// <summary>
    ///     Removes an item from the <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The payload of the message removed from the <c>unbounded_buffer</c>.
    /// </returns>
    /**/
    _Type dequeue()
    {
        return receive<_Type>(this);
    }


protected:

    //
    // propagator_block protected function implementations
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>unbounded_buffer</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by <c>consume</c> and the LWT.  Doing so could
        // result in a deadlock.

        message_status _Result = accepted;

        // Accept the message being propagated
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            async_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>unbounded_buffer</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            sync_send(_PMessage);
        }
        else
        {
            return missed;
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>unbounded_buffer</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the IDs match
        // dequeue and transfer ownership
        //
        message<_Type> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>unbounded_buffer</c> messaging block and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If the message queue is blocked due to reservation
        // there is no need to do any message propagation
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        message<_Type> * _Msg = _M_messageBuffer._Peek();

        if (_Msg != NULL)
        {
            // Propagate the head message to the new target
            message_status _Status = _PTarget->propagate(_Msg, this);

            if (_Status == accepted)
            {
                // The target accepted the message, restart propagation.
                propagate_to_any_targets(NULL);
            }

            // If the status is anything other than accepted, then leave
            // the message queue blocked.
        }
    }

    /// <summary>
    ///     Places the <c>message</c> <paramref name="_PMessage"/> in this <c>unbounded_buffer</c> messaging block and
    ///     tries to offer it to all of the linked targets.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a <c>message</c> object that this <c>unbounded_buffer</c> has taken ownership of.
    /// </param>
    /// <remarks>
    ///     If another message is already ahead of this one in the <c>unbounded_buffer</c>,
    ///     propagation to linked targets will not occur until any earlier messages have been accepted
    ///     or consumed. The first linked target to successfully <c>accept</c> or <c>consume</c> the
    ///     message takes ownership, and no other target can then get the message.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<_Type> * _PMessage)
    {
        // Move the message from the queuedMessages Buffer to the internal storage
        // Enqueue pMessage to the internal unbounded_buffer queue if it is non-NULL.
        // pMessage can be NULL if this LWT was the result of a repropagate call
        // out of a Consume or Release (where no new message is queued up, but
        // everything remaining in the unboundedbuffer needs to be propagated out)
        if (_PMessage != NULL)
        {
            _M_messageBuffer._Enqueue(_PMessage);

            // If the incoming pMessage is not the head message, we can safely assume that
            // the head message is blocked and waiting on Consume(), Release() or a new
            // link_target()
            if (!_M_messageBuffer._Is_head(_PMessage->msg_id()))
            {
                return;
            }
        }

        // Attempt to propagate messages to all the targets
        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    /// <summary>
    ///     Propagates messages in priority order.
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    /// <summary>
    ///     Message queue used to store messages
    /// </summary>
    /**/
    ::Concurrency::details::_Queue<message<_Type>> _M_messageBuffer;

private:
    //
    // Hide assignment operator and copy constructor
    //
    unbounded_buffer const &operator =(unbounded_buffer const&);  // no assignment operator
    unbounded_buffer(unbounded_buffer const &);                   // no copy constructor
};

//**************************************************************************
// Overwrite Buffers:
//**************************************************************************

/// <summary>
///     An <c>overwrite_buffer</c> messaging block is a multi-target, multi-source, ordered
///     <c>propagator_block</c> capable of storing a single message at
///     a time. New messages overwrite previously held ones.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages stored and propagated by the buffer.
/// </typeparam>
/// <remarks>
///     An <c>overwrite_buffer</c> messaging block propagates out copies of its stored message to each of its targets.
///     <para>For more information, see <see cref="Asynchronous Message Blocks"/>.</para>
/// </remarks>
/// <seealso cref="unbounded_buffer Class"/>
/// <seealso cref="single_assignment Class"/>
/**/
template<class _Type>
class overwrite_buffer : public propagator_block<multi_link_registry<ITarget<_Type>>, multi_link_registry<ISource<_Type>>>
{
public:
    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer() :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(Scheduler& _PScheduler) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(Scheduler& _PScheduler,
        filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(ScheduleGroup& _PScheduleGroup) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(ScheduleGroup& _PScheduleGroup,
        filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /**/
    ~overwrite_buffer()
    {
        // Remove all links that are targets of this overwrite_buffer
        remove_network_links();

        // The messages for an overwrite buffer are deleted when overwritten
        // through reference counting.  This final check is put in place in
        // case any message still exists in the buffer when the overwrite_buffer
        // is deleted.  The reference count of this message has not yet reached
        // zero since it hasn't been overwritten yet.  It is safe because of
        // we have finished all propagation.
        if (_M_pMessage != NULL)
        {
            // A block can only have a reserved message after receiving a message
            // at some point, so it must be within the above if-clause.
            // Now delete the reserved message if it is non-NULL and different from
            // the saved internal message
            if (_M_pReservedMessage != NULL && _M_pReservedMessage != _M_pMessage)
            {
                delete _M_pReservedMessage;
            }
            delete _M_pMessage;
        }
    }

    /// <summary>
    ///     Checks whether this <c>overwrite_buffer</c> messaging block has a value yet.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the block has received a value, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return _M_fIsInitialized != 0;
    }

    /// <summary>
    ///     Gets a reference to the current payload of the message being stored in the <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The payload of the currently stored message.
    /// </returns>
    /// <remarks>
    ///     The value stored in the <c>overwrite_buffer</c> could change immediately after this method returns. This method will
    ///     wait until a message arrives if no message is currently stored in the <c>overwrite_buffer</c>.
    /// </remarks>
    /**/
    _Type value()
    {
        return receive<_Type>(this);
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>overwrite_buffer</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_PMessage != NULL)
        {
            // Add a reference for the async_send holding the message
            _PMessage->add_ref();

            async_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>overwrite_buffer</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_PMessage != NULL)
        {
            // Add a reference for the sync_send holding the message
            _PMessage->add_ref();

            sync_send(_PMessage);
        }
        else
        {
            return missed;
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>overwrite_buffer</c> messaging block,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>overwrite_buffer</c> messaging block returns copies of the message
    ///     to its targets, rather than transferring ownership of the currently
    ///     held message.
    /// </remarks>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // If the internal message has not yet been initialized yet, return NULL
        //
        if (_M_pMessage == NULL)
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message stored.
        //
        // Since we are returning a copy, the accept routine for an overwritebuffer
        // does not need to grab the internalLock
        //
        message<_Type> * _Msg = NULL;
        if (_M_pMessage->msg_id() == _MsgId)
        {
            _Msg = new message<_Type>(_M_pMessage->payload);
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Ensure that this message currently exists in the overwrite buffer
        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            return false;
        }

        // Can only reserve one message, any other blocks trying to reserve
        // will return false
        _ASSERTE(_M_pReservedMessage == NULL);

        // Save this message away
        _M_pReservedMessage = _M_pMessage;

        // Add a reference for this message to prevent deletion
        _M_pReservedMessage->add_ref();

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>overwrite_buffer</c> messaging block and reserved by the target, 
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        // Leave and return NULL if this msgId doesn't match the reserved message
        // Otherwise this is a pull of a later overwritten message, and messages
        // could them appear out of order.
        if (_M_pReservedMessage != NULL && _M_pReservedMessage->msg_id() != _MsgId)
        {
            return NULL;
        }

        _Type _Payload = _M_pReservedMessage->payload;

        // Take the reserved message
        message<_Type> * _Result =  new message<_Type>(_Payload);

        if (_M_pReservedMessage->remove_ref() == 0)
        {
            delete _M_pReservedMessage;
        }
        _M_pReservedMessage = NULL;

        return _Result;
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        _ASSERTE(_M_fIsInitialized);
        _ASSERTE(_M_pReservedMessage != NULL);

        if (_MsgId != _M_pReservedMessage->msg_id())
        {
            throw message_not_found();
        }

        if (_M_pReservedMessage->remove_ref() == 0)
        {
            delete _M_pReservedMessage;
        }
        _M_pReservedMessage = NULL;
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // On reservation we do not stop propagation. So there
        // is nothing to be done to resume propagation.
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If there is a message available already, propagate it
        if (_M_pMessage != NULL)
        {
            _PTarget->propagate(_M_pMessage, this);
        }
    }

    /// <summary>
    ///     Places the <c>message</c> <paramref name="_PMessage"/> in this <c>overwrite_buffer</c> messaging block and
    ///     offers it to all of the linked targets.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a <c>message</c> object that this <c>overwrite_buffer</c> has taken ownership of.
    /// </param>
    /// <remarks>
    ///     This method overwrites the current message in the <c>overwrite_buffer</c> with the newly
    ///     accepted message <paramref name="_PMessage"/>.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<_Type> * _PMessage)
    {
        // Move the message from the queuedMessages Buffer to the internal storage

        // Add a reference for the overwrite_buffer holding the message
        _PMessage->add_ref();

        if (_M_pMessage != NULL)
        {
            if (_M_pMessage->remove_ref() == 0)
            {
                delete _M_pMessage;
            }
        }

        _M_pMessage = _PMessage;

        // Now that message has been received, set this block as initialized
        _M_fIsInitialized = true;

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            // Overwrite buffers can propagate its message out
            // to any number of Targets

            ITarget<_Type> * _PTarget = *_Iter;
            _PTarget->propagate(_PMessage, this);
        }

        if (_PMessage->remove_ref() == 0)
        {
            delete _PMessage;
        }
    }
   
private:

    //
    //  Private Data Members
    //

    // The message being stored
    message<_Type> * _M_pMessage;

    // The message being reserved
    message<_Type> * _M_pReservedMessage;

    // The marker for whether the overwrite buffer has already been initialized
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    overwrite_buffer const &operator =(overwrite_buffer const&);  // no assignment operator
    overwrite_buffer(overwrite_buffer const &);                   // no copy constructor
};

//**************************************************************************
// Call:
//**************************************************************************

/// <summary>
///     A <c>call</c> messaging block is a multi-source, ordered <c>target_block</c> that
///     invokes a specified function when receiving a message.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages propagated to this block.
/// </typeparam>
/// <typeparam name="_FunctorType">
///     The signature of functions that this block can accept.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="transformer Class"/>
/**/
template<class _Type, class _FunctorType = std::tr1::function<void(_Type const&)>>
class call : public target_block<multi_link_registry<ISource<_Type>>>
{
    /// <summary>
    ///     The function type that this block executes upon receiving a <c>message</c>.
    /// </summary>
    /**/
    typedef _FunctorType _Call_method;

public:
    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(_Call_method const& _Func) :
        _M_pFunc(_Func)
    {
        initialize_target();
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(_Call_method const& _Func,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(Scheduler& _PScheduler,
        _Call_method const& _Func) :
        _M_pFunc(_Func)
    {
        initialize_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(Scheduler& _PScheduler,
        _Call_method const& _Func,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(ScheduleGroup& _PScheduleGroup,
        _Call_method const& _Func) :
        _M_pFunc(_Func)
    {
        initialize_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(ScheduleGroup& _PScheduleGroup,
        _Call_method const& _Func,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }
    /// <summary>
    ///    Destroys the <c>call</c> messaging block.
    /// </summary>
    /**/
    ~call()
    {
        remove_sources();
    }

protected:

    //
    // target_block protected function implementations
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>call</c> messaging block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        //
        // Accept the message being propagated
        // Note: depending on the source block propagating the message
        // this may not necessarily be the same message (pMessage) first
        // passed into the function.
        //
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            async_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>call</c> messaging block. It is invoked
    ///     by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = accepted;

        //
        // Accept the message being propagated
        // Note: depending on the source block propagating the message
        // this may not necessarily be the same message (pMessage) first
        // passed into the function.
        //
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            sync_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Processes a message that was accepted by this <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message that is to be handled.
    /// </param>
    /**/
    virtual void process_message(message<_Type> * _PMessage)
    {
        // Invoke the function provided by the user
        _ASSERTE(_PMessage != NULL);
        _M_pFunc(_PMessage->payload);
        delete _PMessage;
    }

private:

    //
    //  Private Data Members
    //

    // The call method called by this block
    _Call_method _M_pFunc;

private:
    //
    // Hide assignment operator and copy constructor
    //
    call const &operator =(call const&);  // no assignment operator
    call(call const &);                   // no copy constructor
};

//**************************************************************************
// Transformer:
//**************************************************************************

/// <summary>
///     A <c>transformer</c> messaging block is a single-target, multi-source, ordered 
///     <c>propagator_block</c> which can accept messages of one type and is
///     capable of storing an unbounded number of messages of a different type.
/// </summary>
/// <typeparam name="_Input">
///     The payload type of the messages accepted by the buffer.
/// </typeparam>
/// <typeparam name="_Output">
///     The payload type of the messages stored and propagated out by the buffer.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="call Class"/>
/**/
template<class _Input, class _Output>
class transformer : public propagator_block<single_link_registry<ITarget<_Output>>, multi_link_registry<ISource<_Input>>>
{
    typedef std::tr1::function<_Output(_Input const&)> _Transform_method;

public:
    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(_Transform_method const& _Func, 
        ITarget<_Output> * _PTarget = NULL) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target();

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transform.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(_Transform_method const& _Func,
        ITarget<_Output> * _PTarget,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target();
        register_filter(_Filter);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }


    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(Scheduler& _PScheduler,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget = NULL) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(&_PScheduler);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(Scheduler& _PScheduler,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(ScheduleGroup& _PScheduleGroup,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget = NULL) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(ScheduleGroup& _PScheduleGroup,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Destroys the <c>transformer</c> messaging block.
    /// </summary>
    /**/
    ~transformer()
    {
        // Remove all links 
        remove_network_links();
    }

protected:

    // Propagator_block protected function implementations

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>transformer</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Input> * _PMessage, ISource<_Input> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        //
        // Accept the message being propagated
        // Note: depending on the source block propagating the message
        // this may not necessarily be the same message (pMessage) first
        // passed into the function.
        //
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            // Enqueue the input message
            _M_inputMessages._Enqueue(_PMessage);
            async_send(NULL);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>transformer</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Input> * _PMessage, ISource<_Input> * _PSource)
    {
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            // Enqueue the input message
            _M_inputMessages._Enqueue(_PMessage);
            sync_send(NULL);
        }
        else
        {
            return missed;
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>transformer</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Output> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the Ids match
        // dequeue and transfer ownership
        //
        message<_Output> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>transformer</c> and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Output> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Output> *)
    {
        // If the message queue is blocked due to reservation
        // there is no need to do any message propagation
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

    /// <summary>
    ///     Executes the transformer function on the input message and
    ///     tries to offer the resulting message to all of the linked targets.
    /// </summary>
    /**/
    virtual void propagate_to_any_targets(message<_Output> *)
    {
        message<_Output> * _Msg = NULL;

        // Process input message.
        message<_Input> * _PInputMessage = _M_inputMessages._Dequeue();

        if (_PInputMessage != NULL)
        {
            // Invoke the TransformMethod on the data
            // Let exceptions flow
            _Output _Out = _M_pFunc(_PInputMessage->payload);

            _Msg = new message<_Output>(_Out);
            _M_messageBuffer._Enqueue(_Msg);

            // Message cleanup
            delete _PInputMessage;

            if (!_M_messageBuffer._Is_head(_Msg->msg_id()))
            {
                return;
            }
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    /// <summary>
    ///     Propagates messages in priority order.
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    //
    //  Private Data Members
    //

    // The transformer method called by this block
    _Transform_method _M_pFunc;

    // The queue of input messages for this Transformer block
    ::Concurrency::details::_Async_send_queue<message<_Input>> _M_inputMessages;

    /// <summary>
    ///    Message queue used to store messages
    /// </summary>
    /**/
    ::Concurrency::details::_Queue<message<_Output>> _M_messageBuffer;

private:
    //
    // Hide assignment operator and copy constructor
    //
    transformer const &operator =(transformer const &);  // no assignment operator
    transformer(transformer const &);                    // no copy constructor
};

//**************************************************************************
// Timer:
//**************************************************************************
/// <summary>
///     A <c>timer</c> messaging block is a single-target <c>source_block</c> capable of sending
///     a message to its target after a specified time period has elapsed
///     or at specific intervals.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the output messages of this block.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/**/
template<class _Type>
class timer : public Concurrency::details::_Timer, public source_block<single_link_registry<ITarget<_Type>>>
{
private:

    /// <summary>
    ///     Tracks the state machine of the timer.
    /// </summary>
    /**/
    enum State
    {
        /// <summary>
        ///     The timer has been initialized, but not yet started.
        /// </summary>
        /**/
        Initialized,
        /// <summary>
        ///     The timer has been started.
        /// </summary>
        /**/
        Started,
        /// <summary>
        ///     The timer has started and been paused.
        /// </summary>
        /**/
        Paused,
        /// <summary>
        ///     The timer has been stopped.
        /// </summary>
        /**/
        Stopped
    };

public:

    /// <summary>
    ///     Constructs a <c>timer</c> messaging block that will fire a given message after a specified interval.
    /// </summary>
    /// <param name="_Ms">
    ///     The number of milliseconds that must elapse after the call to start for the specified message
    ///     to be propagated downstream.
    /// </param>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every <paramref name="_Ms"/> milliseconds.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_Scheduler"/>
    ///     or <paramref name="_ScheduleGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    timer(unsigned int _Ms, _Type const& _Value, ITarget<_Type> *_PTarget = NULL, bool _Repeating = false) :
        _Timer(_Ms, _Repeating)
    {
        _Initialize(_Value, _PTarget, _Repeating);
    }

    /// <summary>
    ///     Constructs a <c>timer</c> messaging block that will fire a given message after a specified interval.
    /// </summary>
    /// <param name="_Scheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>timer</c> messaging block is scheduled is scheduled.
    /// </param>
    /// <param name="_Ms">
    ///     The number of milliseconds that must elapse after the call to start for the specified message
    ///     to be propagated downstream.
    /// </param>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every <paramref name="_Ms"/> milliseconds.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_Scheduler"/>
    ///     or <paramref name="_ScheduleGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    timer(Scheduler& _Scheduler, unsigned int _Ms, _Type const& _Value, ITarget<_Type> *_PTarget = NULL, bool _Repeating = false) :
        _Timer(_Ms, _Repeating)
    {
        _Initialize(_Value, _PTarget, _Repeating, &_Scheduler);
    }

    /// <summary>
    ///     Constructs a <c>timer</c> messaging block that will fire a given message after a specified interval.
    /// </summary>
    /// <param name="_ScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>timer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Ms">
    ///     The number of milliseconds that must elapse after the call to start for the specified message
    ///     to be propagated downstream.
    /// </param>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every <paramref name="_Ms"/> milliseconds.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_Scheduler"/>
    ///     or <paramref name="_ScheduleGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    timer(ScheduleGroup& _ScheduleGroup, unsigned int _Ms, _Type const& _Value, ITarget<_Type> *_PTarget = NULL, bool _Repeating = false) :
        _Timer(_Ms, _Repeating)
    {
        _Initialize(_Value, _PTarget, _Repeating, NULL, &_ScheduleGroup);
    }

    /// <summary>
    ///     Destroys a <c>timer</c> messaging block.
    /// </summary>
    /**/
    ~timer()
    {
        //
        // Make sure there are no more outstanding timer fires.  Note that this does not mean that the LWT that was queued is finished, it only
        // means that no more timers will fire after the return from _Stop.  We still *MUST* wait on any outstanding LWTs.
        //
        if (_M_state == Started)
            _Stop();

        // Remove all the targets. This will wait for any outstanding LWTs
        remove_targets(); 

        //
        // No more asynchronous operations can happen as of this point.
        //
        if (_M_pMessage != NULL)
        {
            delete _M_pMessage;
        }

        if (_M_fReferencedScheduler)
        {
            _M_pScheduler->Release();
        }
    }

    /// <summary>
    ///     Starts the <c>timer</c> messaging block.  The specified number of milliseconds after this is called, the specified value will be propagated
    ///     downstream as a <c>message</c>.
    /// </summary>
    /**/
    void start()
    {
        if (_M_state == Initialized || _M_state == Paused)
        {
            _M_state = Started;
            _Start();
        }
    }

    /// <summary>
    ///     Stops the <c>timer</c> messaging block.
    /// </summary>
    /**/
    void stop()
    {
        if (_M_state == Started)
            _Stop();
        
        _M_state = Stopped;
    }

    /// <summary>
    ///     Stops the <c>timer</c> messaging block.  If it is a repeating <c>timer</c> messaging block, it can be restarted with a subsequent
    ///     <c>start()</c> call.  For non-repeating timers, this has the same effect as a <c>stop</c> call.
    /// </summary>
    /**/
    void pause()
    {
        //
        // Non repeating timers cannot pause.  They go to a final stopped state on pause.
        //
        if (!_M_fRepeating)
        {
            stop();
        }
        else
        {
            // Pause only a started timer.

            if (_M_state == Started)
            {
                _Stop();
                _M_state = Paused;
            }
        }
    }

protected:

    /// <summary>
    ///     Accepts a message that was offered by this <c>timer</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        if (_M_pMessage == NULL || _MsgId != _M_pMessage->msg_id())
        {
            return NULL;
        }

        message<_Type> *_PMessage = _M_pMessage;
        _M_pMessage = NULL;
            
        return _PMessage;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>timer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId) 
    {
        //
        // Semantically, every timer tick is the same value -- it doesn't matter the message id.  Since we can only
        // have one target as well, we do not need to track anything here.
        //
        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>timer</c> and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            throw message_not_found();
        }

        delete _M_pMessage;
        _M_pMessage = NULL;
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // Since reservation doesn't prevent propagation there is 
        // no need to resume on consume/release.
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>timer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If there is a timer message sitting around, it must be propagated to the target now.

        if (_M_pMessage != NULL)
        {
            _PTarget->propagate(_M_pMessage, this);
        }
    }

    /// <summary>
    ///     Tries to offer the message produced by the <c>timer</c> block to all of the linked targets.
    /// </summary>
    /**/
    virtual void propagate_to_any_targets(message<_Type> *)
    {
        if (_M_pMessage == NULL)
        {
            _M_pMessage = _NewMessage();
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Type> * _PTarget = *_Iter;
                _PTarget->propagate(_M_pMessage, this);
            }
        }
    }

private:

    // The timer message we contain
    message<_Type> *_M_pMessage;

    // Current state of the timer.
    State _M_state;

    // The value to send on elapse of the timer.
    _Type _M_value;

    // An indication of whether the timer is repeating.
    bool _M_fRepeating;

    // A flag for whether we need to release a reference on the scheduler.
    bool _M_fReferencedScheduler;

    // Scheduler used for the timer
    Scheduler * _M_pScheduler;

    /// <summary>
    ///     Allocates a new message.
    /// </summary>
    /**/
    message<_Type>* _NewMessage() const
    {
        return new message<_Type>(_M_value);
    }

    /// <summary>
    ///     Called when the timer fires.
    /// </summary>
    /**/
    virtual void _Fire()
    {
        async_send(NULL);
    }

    /// <summary>
    ///     Common initialization.
    /// </summary>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every _Ms milliseconds.
    /// </param>
    /**/
    void _Initialize(const _Type& _Value, ITarget<_Type> *_PTarget, bool _Repeating, Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        _M_pMessage = NULL;
        _M_value = _Value;
        _M_fRepeating = _Repeating;
        _M_state = Initialized;
        _M_fReferencedScheduler = false;

        //
        // If we are going to utilize the current scheduler for timer firing, we need to capture it now.  Otherwise,
        // the timer threads fired from Windows (what _Fire executes within) will wind up with a default scheduler 
        // attached -- probably not the semantic we want.
        //
        if (_PScheduleGroup == NULL && _PScheduler == NULL)
        {
            _PScheduler = CurrentScheduler::Get();
            _PScheduler->Reference();
            _M_fReferencedScheduler = true;
        }

        _M_pScheduler = _PScheduler;
        initialize_source(_PScheduler, _PScheduleGroup);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

private:
    //
    // Hide assignment operator and copy constructor
    //
    timer const &operator =(timer const &);  // no assignment operator
    timer(timer const &);                    // no copy constructor
};

//**************************************************************************
// Single assignment:
//**************************************************************************

/// <summary>
///     A <c>single_assignment</c> messaging block is a multi-target, multi-source, ordered
///     <c>propagator_block</c> capable of storing a single, write-once 
///     <c>message</c>.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the message stored and propagated by the buffer.
/// </typeparam>
/// <remarks>
///     A <c>single_assignment</c> messaging block propagates out copies of its message to each target.
///     <para>For more information, see <see cref="Asynchronous Message Blocks"/>.</para>
/// </remarks>
/// <seealso cref="overwrite_buffer Class"/>
/// <seealso cref="unbounded_buffer Class"/>
/**/
template<class _Type>
class single_assignment : public propagator_block<multi_link_registry<ITarget<_Type>>, multi_link_registry<ISource<_Type>>>
{
public:

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment() :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(Scheduler& _PScheduler) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(Scheduler& _PScheduler, filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(ScheduleGroup& _PScheduleGroup) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(ScheduleGroup& _PScheduleGroup, filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>single_assignment</c> messaging block.
    /// </summary>
    /**/
    ~single_assignment()
    {
        // Remove all links 
        remove_network_links();

        // The messages for a single_assignment are deleted at the end when
        // single_assignment is deleted.
        delete _M_pMessage;
    }

    /// <summary>
    ///     Checks whether this <c>single_assignment</c> messaging block has been initialized with a value yet.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the block has received a value, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return (_M_pMessage != NULL);
    }


    /// <summary>
    ///     Gets a reference to the current payload of the message being stored in the <c>single_assignment</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The payload of the stored message.
    /// </returns>
    /// <remarks>
    ///     This method will wait until a message arrives if no message is currently stored in the <c>single_assignment</c> messaging block.
    /// </remarks>
    /**/
    _Type const & value()
    {
        if (_M_pMessage == NULL)
        {
            receive<_Type>(this);
        }
        _ASSERTE(_M_pMessage != NULL);

        return _M_pMessage->payload;
    }


protected:

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>single_assignment</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        // single_assignment messaging block can be initialized only once
        if (_M_fIsInitialized)
        {
            return declined;
        }

        {
            _NR_lock _Lock(_M_propagationLock);

            if (_M_fIsInitialized)
            {
                _Result = declined;
            }
            else
            {
                _PMessage = _PSource->accept(_PMessage->msg_id(), this);

                // Set initialized flag only if we have a message
                if (_PMessage != NULL)
                {
                    _M_fIsInitialized = true;
                }
                else
                {
                    _Result = missed;
                }
            }
        }

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_Result == accepted)
        {
            async_send(_PMessage);
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>single_assignment</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = accepted;

        // single_assignment messaging block can be initialized only once
        if (_M_fIsInitialized)
        {
            return declined;
        }

        {
            _NR_lock _Lock(_M_propagationLock);

            if (_M_fIsInitialized)
            {
                _Result = declined;
            }
            else
            {
                _PMessage = _PSource->accept(_PMessage->msg_id(), this);

                // Set initialized flag only if we have a message
                if (_PMessage != NULL)
                {
                    _M_fIsInitialized = true;
                }
                else
                {
                    _Result = missed;
                }
            }
        }

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_Result == accepted)
        {
            sync_send(_PMessage);
        }

        return _Result;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>single_assignment</c> messaging block,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>single_assignment</c> messaging block returns copies of the message
    ///     to its targets, rather than transferring ownership of the currently
    ///     held message.
    /// </remarks>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pMessage == NULL || _MsgId != _M_pMessage->msg_id())
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a single_assignment
        // does not need to grab the internal lock.
        //
        return (new message<_Type>(_M_pMessage->payload));
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        if (_M_pMessage == NULL)
        {
            return false;
        }

        if (_M_pMessage->msg_id() != _MsgId)
        {
            throw message_not_found();
        }

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>single_assignment</c> and reserved by the target,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        _ASSERTE(_M_fIsInitialized);

        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        _ASSERTE(_M_fIsInitialized);

        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // Since reservation doesn't stop propagation, we don't
        // need to do anything on resume after consume/release.
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If there is a message available already, propagate it.

        if (_M_pMessage != NULL)
        {
            _PTarget->propagate(_M_pMessage, this);
        }
    }
    /// <summary>
    ///     Places the <c>message</c> <paramref name="_PMessage"/> in this <c>single_assignment</c> messaging block and
    ///     offers it to all of the linked targets.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a <c>message</c> that this <c>single_assignment</c> messaging block has taken ownership of.
    /// </param>
    /**/
    virtual void propagate_to_any_targets(message<_Type> * _PMessage)
    {
        // Initialized flag should have been set by the propagate function using interlocked operation.
        _ASSERTE(_M_fIsInitialized);

        // Move the message to the internal storage

        _ASSERTE(_M_pMessage == NULL);
        _M_pMessage = _PMessage;

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            // Single assignment can propagate its message out
            // to any number of Targets

            ITarget<_Type> * _PTarget = *_Iter;
            _PTarget->propagate(_PMessage, this);
        }
    }

private:

    //
    //  Private Data Members
    //

    // The message being stored
    message<_Type> * _M_pMessage;

    // The lock used to protect propagation
    ::Concurrency::details::_NonReentrantPPLLock _M_propagationLock;

    // The marker for whether the single_assignment has already been initialized
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    single_assignment const & operator=(single_assignment const &);  // no assignment operator
    single_assignment(single_assignment const &);                    // no copy constructor
};

//**************************************************************************
// Join (single-type)
//**************************************************************************

/// <summary>
///     The type of a <c>join</c> messaging block.
/// </summary>
/**/
enum join_type { 
    /// <summary>
    ///     Greedy <c>join</c> messaging blocks immediately accept a message upon propagation.  This is more efficient,
    ///     but has the possibility for live-lock, depending on the network configuration.
    /// </summary>
    /**/
    greedy = 0,
    /// <summary>
    ///     Non-greedy <c>join</c> messaging blocks postpone messages and try and consume them after all have arrived.
    ///     These are guaranteed to work, but slower.
    /// </summary>
    /**/
    non_greedy = 1 
};

/// <summary>
///     A <c>join</c> messaging block  is a single-target, multi-source, ordered 
///     <c>propagator_block</c> which combines together messages of type <typeparamref name="_Type"/> from each
///     of its sources.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages joined and propagated by the block.
/// </typeparam>
/// <typeparam name="_Jtype">
///     The kind of <c>join</c> block this is, either <c>greedy</c> or <c>non_greedy</c>
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="choice Class"/>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="join_type Enumeration"/>
/**/
template<class _Type, join_type _Jtype = non_greedy>
class join : public propagator_block<single_link_registry<ITarget<std::vector<_Type>>>, multi_link_registry<ISource<_Type>>>
{
public:
    typedef typename std::vector<_Type> _OutputType;

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(size_t _NumInputs)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(size_t _NumInputs, filter_method const& _Filter)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(Scheduler& _PScheduler, size_t _NumInputs)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(Scheduler& _PScheduler, size_t _NumInputs, filter_method const& _Filter)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, &_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(ScheduleGroup& _PScheduleGroup, size_t _NumInputs)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(ScheduleGroup& _PScheduleGroup, size_t _NumInputs, filter_method const& _Filter)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>join</c> block.
    /// </summary>
    /**/
    ~join()
    {
        // Remove all links that are targets of this join
        remove_network_links();

        delete [] _M_savedIdBuffer;
    }

protected:
    //
    // propagator_block protected function implementations
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>join</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource) 
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call. 

        message_status _Ret_val = accepted;

        //
        // Find the slot index of this source
        //
        size_t _Slot = 0;
        bool _Found = false;
        for (source_iterator _Iter = _M_connectedSources.begin(); *_Iter != NULL; ++_Iter)
        {
            if (*_Iter == _PSource)
            {
                _Found = true;
                break;
            }

            _Slot++;
        }

        if (!_Found)
        {
            // If this source was not found in the array, this is not a connected source
            // decline the message
            return declined;
        }

        _ASSERTE(_Slot < _M_messageArray._M_count);

        bool fIsGreedy = (_Jtype == greedy);

        if (fIsGreedy)
        {
            //
            // Greedy type joins immediately accept the message.
            //
            {
                _NR_lock lockHolder(_M_propagationLock);
                if (_M_messageArray._M_messages[_Slot] != NULL)
                {
                    _M_savedMessageIdArray._M_savedIds[_Slot] = _PMessage->msg_id();
                    _Ret_val = postponed;
                }
            }

            if (_Ret_val != postponed)
            {
                _M_messageArray._M_messages[_Slot] = _PSource->accept(_PMessage->msg_id(), this);

                if (_M_messageArray._M_messages[_Slot] != NULL)
                {
                    if (_InterlockedDecrementSizeT(&_M_messagesRemaining) == 0)
                    {
                        // If messages have arrived on all links, start a propagation
                        // of the current message
                        async_send(NULL);
                    }
                }
                else
                {
                    _Ret_val = missed;
                }
            }
        }
        else
        {
            //
            // Non-greedy type joins save the message ids until they have all arrived
            //

            if (_InterlockedExchange((volatile long *) &_M_savedMessageIdArray._M_savedIds[_Slot], _PMessage->msg_id()) == -1)
            {
                // Decrement the message remaining count if this thread is switching 
                // the saved id from -1 to a valid value.
                if (_InterlockedDecrementSizeT(&_M_messagesRemaining) == 0)
                {
                    async_send(NULL);
                }
            }

            // Always return postponed.  This message will be consumed
            // in the LWT
            _Ret_val = postponed;
        }

        return _Ret_val;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>join</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_OutputType> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the Ids match
        // dequeue and transfer ownership
        //
        message<_OutputType> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>join</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>join</c> messaging block and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_OutputType> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<std::vector<_Type>> *)
    {
        // If the message queue is blocked due to reservation
        // there is no need to do any message propagation
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

    /// <summary>
    ///     Constructs an output message containing an input message from each source when
    ///     they have all propagated a message.  Sends this output message out to each of
    ///     its targets.
    /// </summary>
    /**/
    void propagate_to_any_targets(message<_OutputType> *) 
    {
        message<_OutputType> * _Msg = NULL;
        // Create a new message from the input sources
        // If messagesRemaining == 0, we have a new message to create.  Otherwise, this is coming from
        // a consume or release from the target.  In that case we don't want to create a new message.
        if (_M_messagesRemaining == 0)
        {
            // A greedy join can immediately create the message, a non-greedy
            // join must try and consume all the messages it has postponed
            _Msg = _Create_new_message();
        }

        if (_Msg == NULL)
        {
            // Create message failed.  This happens in non_greedy joins when the
            // reserve/consumption of a postponed message failed.
            _Propagate_priority_order(_M_messageBuffer);
            return;
        }

        bool fIsGreedy = (_Jtype == greedy);

        // For a greedy join, reset the number of messages remaining
        // Check to see if multiple messages have been passed in on any of the links,
        // and postponed. If so, try and reserve/consume them now
        if (fIsGreedy)
        {
            // Look at the saved ids and reserve/consume any that have passed in while
            // this join was waiting to complete
            _ASSERTE(_M_messageArray._M_count == _M_savedMessageIdArray._M_count);

            for (size_t i = 0; i < _M_messageArray._M_count; i++)
            {
                for(;;)
                {
                    runtime_object_identity _Saved_id;
                    // Grab the current saved id value.  This value could be changing from based on any
                    // calls of source->propagate(this).  If the message id is different than what is snapped
                    // here, that means, the reserve below must fail.  This is because reserve is trying
                    // to get the same source lock the propagate(this) call must be holding.
                    {
                        _NR_lock lockHolder(_M_propagationLock);

                        _ASSERTE(_M_messageArray._M_messages[i] != NULL);

                        _Saved_id = _M_savedMessageIdArray._M_savedIds[i];

                        if (_Saved_id == -1)
                        {
                            _M_messageArray._M_messages[i] = NULL;
                            break;
                        }
                        else
                        {
                            _M_savedMessageIdArray._M_savedIds[i] = -1;
                        }
                    }

                    if (_Saved_id != -1)
                    {
                        source_iterator _Iter = _M_connectedSources.begin();
                        
                        ISource<_Type> * _PSource = _Iter[i];
                        if ((_PSource != NULL) && _PSource->reserve(_Saved_id, this))
                        {
                            _M_messageArray._M_messages[i] = _PSource->consume(_Saved_id, this);
                            _InterlockedDecrementSizeT(&_M_messagesRemaining);
                            break;
                        }
                    }
                }
            }

            // If messages have all been received, async_send again, this will start the
            // LWT up to create a new message
            if (_M_messagesRemaining == 0)
            {
                async_send(NULL);
            }
        }
        
        // Add the new message to the outbound queue
        _M_messageBuffer._Enqueue(_Msg);

        if (!_M_messageBuffer._Is_head(_Msg->msg_id()))
        {
            // another message is at the head of the outbound message queue and blocked
            // simply return
            return;
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    //
    //  Private Methods
    //

    /// <summary>
    ///     Propagate messages in priority order.
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    /// <summary>
    ///     Constructs a new message from the data output.
    /// </summary>
    /// <returns>
    ///     The created message (NULL if creation failed)
    /// </returns>
    /**/
    message<std::vector<_Type>> * __cdecl _Create_new_message()
    {
        bool fIsNonGreedy = (_Jtype == non_greedy);

        // If this is a non-greedy join, check each source and try to consume their message
        if (fIsNonGreedy)
        {

            // The iterator _Iter below will ensure that it is safe to touch
            // non-NULL source pointers. Take a snapshot.
            std::vector<ISource<_Type> *> _Sources;
            source_iterator _Iter = _M_connectedSources.begin();

            while (*_Iter != NULL)
            {
                ISource<_Type> * _PSource = *_Iter;

                if (_PSource == NULL)
                {
                    break;
                }

                _Sources.push_back(_PSource);
                ++_Iter;
            }

            if (_Sources.size() != _M_messageArray._M_count)
            {
                // Some of the sources were unlinked. The join is broken
                return NULL;
            }

            // First, try and reserve all the messages.  If a reservation fails,
            // then release any reservations that had been made.
            for (size_t i = 0; i < _M_savedMessageIdArray._M_count; i++)
            {
                // Snap the current saved id into a buffer.  This value can be changing behind the scenes from
                // other source->propagate(msg, this) calls, but if so, that just means the reserve below will
                // fail.
                _InterlockedIncrementSizeT(&_M_messagesRemaining);
                _M_savedIdBuffer[i] = _InterlockedExchange((volatile long *) &_M_savedMessageIdArray._M_savedIds[i], -1);

                _ASSERTE(_M_savedIdBuffer[i] != -1);

                if (!_Sources[i]->reserve(_M_savedIdBuffer[i], this))
                {
                    // A reservation failed, release all reservations made up until
                    // this block, and wait for another message to arrive on this link
                    for (size_t j = 0; j < i; j++)
                    {
                        _Sources[j]->release(_M_savedIdBuffer[j], this);
                        if (_InterlockedCompareExchange((volatile long *) &_M_savedMessageIdArray._M_savedIds[j], _M_savedIdBuffer[j], -1) == -1)
                        {
                            if (_InterlockedDecrementSizeT(&_M_messagesRemaining) == 0)
                            {
                                async_send(NULL);
                            }
                        }
                    }

                    // Return NULL to indicate that the create failed
                    return NULL;
                }  
            }

            // Since everything has been reserved, consume all the messages.
            // This is guaranteed to return true.
            for (size_t i = 0; i < _M_messageArray._M_count; i++)
            {
                _M_messageArray._M_messages[i] = _Sources[i]->consume(_M_savedIdBuffer[i], this);
                _M_savedIdBuffer[i] = -1;
            }
        }

        if (!fIsNonGreedy)
        {
            // Reinitialize how many messages are being waited for.
            // This is safe because all messages have been received, thus no new async_sends for
            // greedy joins can be called.
            _M_messagesRemaining = _M_messageArray._M_count;
        }

        std::vector<_Type> _OutputVector;
        for (size_t i = 0; i < _M_messageArray._M_count; i++)
        {
            _ASSERTE(_M_messageArray._M_messages[i] != NULL);
            _OutputVector.push_back(_M_messageArray._M_messages[i]->payload);

            delete _M_messageArray._M_messages[i];
            if (fIsNonGreedy)
            {
                _M_messageArray._M_messages[i] = NULL;
            }
        }
        return (new message<std::vector<_Type>>(_OutputVector));
    }

    /// <summary>
    ///     Initializes the <c>join</c> messaging block.
    /// </summary>
    /// <param name="_NumInputs">
    ///     The number of inputs.
    /// </param>
    /// <param name="_PScheduler">
    ///     The scheduler onto which the task to propagate the <c>join</c> block's message will be scheduled.
    ///     If unspecified, the <c>join</c> messaging block uses the default scheduler.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group into which the task to propagate the <c>join</c> block's message will be scheduled.
    ///     The scheduler used is implied by the schedule group.  If unspecified, the <c>join</c> uses a schedule
    ///     group of the scheduler's choosing.
    /// </param>
    /**/
    void _Initialize(size_t _NumInputs, Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        initialize_source_and_target(_PScheduler, _PScheduleGroup);

        _M_connectedSources.set_bound(_NumInputs);
        _M_messagesRemaining = _NumInputs;

        bool fIsNonGreedy = (_Jtype == non_greedy);

        if (fIsNonGreedy)
        {
            // Non greedy joins need a buffer to snap off saved message ids to.
            _M_savedIdBuffer = new runtime_object_identity[_NumInputs];
            memset(_M_savedIdBuffer, -1, sizeof(runtime_object_identity) * _NumInputs);
        }
        else
        {
            _M_savedIdBuffer = NULL;
        }
    }

    // The current number of messages remaining
    volatile size_t _M_messagesRemaining;

    // An array containing the accepted messages of this join.
    // Wrapped in a struct to enable debugger visualization.
    struct _MessageArray
    {
        size_t _M_count;
        message<_Type>** _M_messages;

        _MessageArray(size_t _NumInputs)
            : _M_count(_NumInputs),
              _M_messages(new message<_Type>*[_NumInputs])
        {
            memset(_M_messages,  0, sizeof(message<_Type> *) * _NumInputs);
        }

        ~_MessageArray()
        {
            for (size_t i = 0; i < _M_count; i++)
                delete _M_messages[i];
            delete [] _M_messages;
        }
    };
    _MessageArray _M_messageArray;

    // An array containing the msg ids of messages propagated to the array
    // For greedy joins, this contains a log of other messages passed to this
    // join after the first has been accepted
    // For non-greedy joins, this contains the message id of any message 
    // passed to it.
    // Wrapped in a struct to enable debugger visualization.
    struct _SavedMessageIdArray
    {
        size_t _M_count;
        runtime_object_identity * _M_savedIds;

        _SavedMessageIdArray(size_t _NumInputs)
            : _M_count(_NumInputs),
              _M_savedIds(new runtime_object_identity[_NumInputs])
        {
            memset(_M_savedIds, -1, sizeof(runtime_object_identity) * _NumInputs);
        }

        ~_SavedMessageIdArray()
        {
            delete [] _M_savedIds;
        }
    };
    _SavedMessageIdArray _M_savedMessageIdArray;

    // Buffer for snapping saved ids in non-greedy joins
    runtime_object_identity * _M_savedIdBuffer;

    // A lock for modifying the buffer or the connected blocks
    ::Concurrency::details::_NonReentrantPPLLock _M_propagationLock;

    // Queue to hold output messages
    ::Concurrency::details::_Queue<message<std::vector<_Type>>> _M_messageBuffer;
};


//**************************************************************************
// Multi-Type Choice and Join helper node:
//**************************************************************************

/// <summary>
///     Base class for Helper node used in multi-type join and choice blocks
///     Order node is a single-target, single-source ordered propagator block
///     The main property of an order node is that it accepts a message of _Type
///     and outputs a message of int, with some unique assigned index number.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Order_node_base: public propagator_block<single_link_registry<ITarget<size_t>>, multi_link_registry<ISource<_Type>>>
{
public:

    /// <summary>
    ///     Constructs a _Order_node_base within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /**/
    _Order_node_base() :
        _M_index(0),
        _M_pReceiveMessage(NULL),
        _M_pSendMessage(NULL)
    {
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Order_node.
    /// </summary>
    /**/
    ~_Order_node_base()
    {
        // The messages for an _Order_node_base are deleted at the end when
        // _Order_node_base is deleted.
        delete _M_pReceiveMessage;
        delete _M_pSendMessage;
    }

    /// <summary>
    ///     Checks whether this block has been initialized yet.
    /// </summary>
    /// <returns>
    ///     true, if the block has received a value, false otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return (_M_pReceiveMessage != NULL);
    }

    /// <summary>
    ///     Gets a reference to the current payload of the message being stored.
    /// </summary>
    /// <returns>
    ///     The incoming payload.
    /// </returns>
    /**/
    _Type const & value()
    {
        _ASSERTE(_M_pReceiveMessage != NULL);

        return _M_pReceiveMessage->payload;
    }

    /// <summary>
    ///     Resets the _Order_node_base and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     _Reset is called from Populate_destination_tuple through propagate_to_any_targets()
    ///     thus, it always has the internal lock held.  This is only used for _Greedy_node and
    ///     _Non_greedy_node.
    /// </remarks>
    /**/
    virtual void _Reset() = 0;

    /// <summary>
    ///     Reserves a message previously offered by the source.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A bool indicating whether the reservation worked or not
    /// </returns>
    /// <remarks>
    ///     After 'reserve' is called, either 'consume' or 'release' must be called.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity)
    {
        // reserve should never be called for this block.
        _ASSERTE(false);

        return false;
    }

    /// <summary>
    ///     Consumes a message previously offered by the source and reserved by the target, 
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to 'accept', but is always preceded by a call to 'reserve'
    /// </remarks>
    /**/
    virtual message<size_t> * consume_message(runtime_object_identity)
    {
        // consume should never be called for this block.
        _ASSERTE(false);

        return NULL;
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity)
    {
        // release should never be called for this block.
        _ASSERTE(false);
    }

protected:


    /// <summary>
    ///     Resumes propagation after a reservation has been released
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // Since there is only a single target, nothing needs
        // to be done on resume
    }

    /// <summary>
    /// Notification that a target was linked to this source.    
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<size_t> *)
    {
        if (_M_pSendMessage != NULL)
        {
            propagate_to_any_targets(NULL);
        }
    }

    /// <summary>
    ///     Create a message that contains an index used to determine the source message
    /// </summary>
    /**/
    void _Create_send_message()
    {
        _M_pSendMessage = new message<size_t>(_M_index);
    }

    /// <summary>
    ///     Validate constructor arguments and fully connect this _Order_node_base.
    /// </summary>
    /**/
    void _Initialize_order_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        if (_Index < 0)
        {
            throw std::invalid_argument("_Index");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        _M_index = _Index;

        initialize_source_and_target(_PScheduler, _PScheduleGroup);

        // Allow only a single source and ensure that they
        // cannot be unlinked and relinked.
        _M_connectedSources.set_bound(1);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }

        _PSource->link_target(this);
    }

    //
    //  Private Data Members
    //

    // The message to be received from the source
    message<_Type> * _M_pReceiveMessage;

    // The message to be sent to all targets
    message<size_t> * _M_pSendMessage;

    // The index of the _Order_node_base in the user's construct
    size_t _M_index;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Order_node_base const & operator=(_Order_node_base const &);  // no assignment operator
    _Order_node_base(_Order_node_base const &);                    // no copy constructor
};


/// <summary>
///     Helper class used in multi-type choice blocks
///     Ordered node is a single-target, single-source ordered propagator block
/// </summary>
///
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Reserving_node: public _Order_node_base<_Type>
{
public:
    /// <summary>
    ///     Constructs a _Reserving_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Reserving_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Reserving_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Reserving_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Reserving_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Reserving_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Reserving_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Reserving_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Order_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Reserving_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a _Order_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Reserving_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) : 
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Reserving_node.
    /// </summary>
    /**/
    ~_Reserving_node()
    {
        if (_M_pReservedSource != NULL)
        {
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }

        // Remove all links 
        remove_network_links();
    }


    /// <summary>
    ///     Resets the _Reserving_node and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     This function is not used in a _Reserving_node, which is only used for choice blocks
    /// </remarks>
    /**/
    virtual void _Reset()
    {
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     It is important that calls to propagate do *not* take the same lock on the
    ///     internal structure that is used by Consume and the light-weight task.  Doing so could
    ///     result in a deadlock with the Consume call.
    /// </remarks>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = postponed;

        // _Order_node messaging block can be initialized only once, just like single_assignment.
        if (_M_fIsInitialized)
        {
            return declined;
        }

        // Reserve a message on the source until this _Order_node gets the feedback from
        // the single_assignment on whether it has been selected.
        _M_fIsInitialized = _PSource->reserve(_PMessage->msg_id(), this);

        //
        // If message was successfully reserved, set the member variables for
        // this messaging block and start the asynchronous propagation task.
        //
        if (_M_fIsInitialized)
        {
            _M_savedId = _PMessage->msg_id();
            async_send(NULL);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Accept the message by making a copy of the payload.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pSendMessage == NULL || _MsgId != _M_pSendMessage->msg_id())
        {
            return NULL;
        }

        // If the source has disconnected then we can't allow for accept to succeed.
        source_iterator _Iter = _M_connectedSources.begin();
        ISource<_Type>* _PSource = *_Iter;

        if (_PSource == NULL)
        {
            // source was disconnected. Fail accept.
            return NULL;
        }

        _M_pReceiveMessage = _PSource->consume(_M_savedId, this);

        _ASSERTE(_M_pReceiveMessage != NULL);

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a _Order_node
        // does not need to grab the internal lock.
        //
        return (new message<size_t>(_M_pSendMessage->payload));
    }

    /// <summary>
    ///     Takes the message and propagates it to all the targets of this _Order_node
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages its _M_index into a message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<size_t> *)
    {
        if (_M_pSendMessage == NULL)
        {
            _Create_send_message();
        }

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<size_t> * _PTarget = *_Iter;
            _Propagate_to_target(_PTarget);
        }
    }

private:

    /// <summary>
    ///     Propagate messages to the given target
    /// </summary>
    /**/
    message_status _Propagate_to_target(ITarget<size_t> * _PTarget)
    {
        message_status _Status = _PTarget->propagate(_M_pSendMessage, this);

        // If the message got rejected we have to release the hold on the source message.
        if (_Status != accepted)
        {
            if (_M_savedId != -1)
            {
                // Release the reservation
                source_iterator _Iter = _M_connectedSources.begin();
                ISource<_Type> * _PSource = *_Iter;

                if (_PSource != NULL)
                {
                    _PSource->release(_M_savedId, this);
                }

                // If the source was disconnected, then it would
                // automatically release any reservation. So we
                // should reset our savedId regardless.
                _M_savedId = -1;
            }
            
        }

        return _Status;
    }

    //
    //  Private Data Members
    //

    // The source where we have reserved a message
    ISource<_Type> * _M_pReservedSource;

    // For greedy order-nodes, the message id of subsequent messages sent to this node
    // For non-greedy order nodes, the message id of the message to reserve/consume
    runtime_object_identity _M_savedId;

    // The marker that indicates that _Reserving_node has reserved a message
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Reserving_node const & operator=(_Reserving_node const &);  // no assignment operator
    _Reserving_node(_Reserving_node const &);                    // no copy constructor
};


/// <summary>
///     Helper class used in multi-type greedy join blocks
///     Ordered node is a single-target, single-source ordered propagator block
/// </summary>
///
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Greedy_node: public _Order_node_base<_Type>
{
public:
    /// <summary>
    ///     Constructs a _Greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Greedy_node.
    /// </summary>
    /**/
    ~_Greedy_node()
    {
        // Remove all links 
        remove_network_links();

        if (_M_pGreedyMessage != _M_pReceiveMessage)
        {
            delete _M_pGreedyMessage;
        }
    }

    /// <summary>
    ///     Resets the _Greedy_node and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     _Reset is called from Populate_destination_tuple through propagate_to_any_targets()
    ///     thus, it always has the internal lock held.
    /// </remarks>
    /**/
    void _Reset()
    {
        _R_lock _Lock(_M_resetLock);

        delete _M_pReceiveMessage;
        _M_pReceiveMessage = NULL;

        delete _M_pSendMessage;
        _M_pSendMessage = NULL;

        //
        // For greedy type joins, look to see if any other messages have been
        // passed to this _Greedy_node while the join was waiting for other
        // messages to arrive.  This function is already called with _M_resetLock
        // held through propagate_to_any_targets().
        //
        for(;;)
        {
            // Set the current saved id as -1.  Check to see if something was ready for consumption
            // (if _Saved_id != -1) and consume it if possible.
            runtime_object_identity _Saved_id;
            
            {
                _NR_lock lockHolder(_M_propagationLock);

                _Saved_id = _M_savedId;

                if (_Saved_id == -1)
                {
                    _M_pGreedyMessage = NULL;
                    break;
                }
                else
                {
                    _M_savedId = -1;
                }
            }

            if (_Saved_id != -1)
            {
                source_iterator _Iter = _M_connectedSources.begin();

                ISource<_Type> * _PSource = *_Iter;
                if ((_PSource != NULL) && _PSource->reserve(_Saved_id, this))
                {
                    _M_pGreedyMessage = _PSource->consume(_Saved_id, this);
                    async_send(NULL);
                    break;
                }
            }
        }
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     It is important that calls to propagate do *not* take the same lock on the
    ///     internal structure that is used by Consume and the light-weight task.  Doing so could
    ///     result in a deadlock with the Consume call.
    /// </remarks>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = postponed;

        bool _FDone = false;

        {
            _NR_lock lockHolder(_M_propagationLock);
            if (_M_pGreedyMessage != NULL)
            {
                _M_savedId = _PMessage->msg_id();
                _Result = postponed;
                _FDone = true;
            }
        }

        if (!_FDone)
        {
            _M_pGreedyMessage = _PSource->accept(_PMessage->msg_id(), this);

            if (_M_pGreedyMessage != NULL)
            {
                _Result = accepted;
                async_send(NULL);
            }
            else
            {
                _Result = missed;
            }
        }

        return _Result;
    }

    /// <summary>
    ///     Accept the message by making a copy of the payload.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pSendMessage == NULL || _MsgId != _M_pSendMessage->msg_id())
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a _Greedy_node
        // does not need to grab the internal lock.
        //
        return (new message<size_t>(_M_pSendMessage->payload));
    }


    /// <summary>
    ///     Takes the message and propagates it to all the targets of this _Greedy_node
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages its _M_index into a message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<size_t> *)
    {
        _R_lock _Lock(_M_resetLock);

        if (_M_pSendMessage == NULL)
        {
            // Save the incoming message so that it can be consumed in the accept function
            _M_pReceiveMessage = _M_pGreedyMessage;
            _Create_send_message();
        }

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<size_t> * _PTarget = *_Iter;
            _PTarget->propagate(_M_pSendMessage, this);
        }
    }

private:

    //
    //  Private Data Members
    //

    // The message to be saved by a greedy order node
    message<_Type> * _M_pGreedyMessage;

    // The lock used to protect propagation
    ::Concurrency::details::_NonReentrantPPLLock _M_propagationLock;

    // The lock used to protect modification during a reset
    ::Concurrency::details::_ReentrantPPLLock _M_resetLock;

    // For greedy order-nodes, the message id of subsequent messages sent to this node
    // For non-greedy order nodes, the message id of the message to reserve/consume
    runtime_object_identity _M_savedId;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Greedy_node const & operator=(_Greedy_node const &);  // no assignment operator
    _Greedy_node(_Greedy_node const &);                    // no copy constructor
};


/// <summary>
///     Helper class used in multi-type non-greedy join blocks
///     Ordered node is a single-target, single-source ordered propagator block
/// </summary>
///
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Non_greedy_node: public _Order_node_base<_Type>
{
public:
    /// <summary>
    ///     Constructs a _Non_greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Non_greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Non_greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Non_greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Non_greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Non_greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Non_greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Order_node.
    /// </summary>
    /**/
    ~_Non_greedy_node()
    {
        if (_M_pReservedSource != NULL)
        {
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }

        // Remove all links 
        remove_network_links();
    }

    /// <summary>
    ///     Resets the _Order_node and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     _Reset is called from Populate_destination_tuple through propagate_to_any_targets()
    ///     thus, it always has the internal lock held.
    /// </remarks>
    /**/
    void _Reset()
    {
        _R_lock _Lock(_M_resetLock);

        delete _M_pReceiveMessage;
        _M_pReceiveMessage = NULL;

        delete _M_pSendMessage;
        _M_pSendMessage = NULL;
    }

    /// <summary>
    ///     Called for a non_greedy type join block in order to reserve the message
    ///     in this join block
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the reservation worked
    /// </returns>
    /**/
    bool _Reserve_received_message()
    {
        bool _Ret_val = false;

        // Order node has only  a single source. 
        // Obtain an iterator to the first source. It will guarantee that the reference
        // count on the source is maintained
        source_iterator _Iter = _M_connectedSources.begin();
        ISource<_Type> * _PSource = *_Iter;

        if (_PSource != NULL)
        {
            // CAS out the current saved id, in order to try and reserve it
            runtime_object_identity _SavedId = _InterlockedExchange((volatile long *) &_M_savedId, -1);

            _Ret_val = _PSource->reserve(_SavedId, this);
            //
            // If this reserved failed, that means we need to wait for another message
            // to come in on this link.  _M_savedID was set to -1 to indicate to the _Order_node
            // that it needs to async_send when that next message comes through
            //
            // If the reserve succeeds, save away the reserved ID.  This will be use later in
            // consume
            //
            if (_Ret_val)
            {
                _M_reservedId = _SavedId;

                // Acquire a reference on the source
                _M_connectedSources.reference();
                _M_pReservedSource = _PSource;
            }
        }

        return _Ret_val;
    }

    /// <summary>
    ///     Called for a non_greedy type join block in order to consume the message
    ///     in this join block that has been reserved
    /// </summary>
    /**/
    void _Consume_received_message()
    {
        if (_M_pReservedSource != NULL)
        {
            runtime_object_identity _SavedId = _M_reservedId;
            _M_pReceiveMessage = _M_pReservedSource->consume(_SavedId, this);

            runtime_object_identity _OldId = NULL;
            _OldId = _InterlockedExchange((volatile long *) &_M_reservedId, -1);

            _ASSERTE(_OldId == _SavedId);

            // Release the reference on the source
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }
    }

    /// <summary>
    ///     Called for a non_greedy type join block release a reservation on this block
    /// </summary>
    /**/
    bool _Release_received_message()
    {
        bool retVal = false;

        if (_M_pReservedSource != NULL)
        {
            runtime_object_identity _SavedId = _M_reservedId;
            // If the _M_savedId is still -1, then swap the succeeded one back
            _M_pReservedSource->release(_SavedId, this);

            if (_InterlockedCompareExchange((volatile long *) &_M_savedId, _SavedId, -1) == -1)
            {
                retVal = true;
            }

            // Release the reference on the source
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }

        return retVal;
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     It is important that calls to propagate do *not* take the same lock on the
    ///     internal structure that is used by Consume and the light-weight task.  Doing so could
    ///     result in a deadlock with the Consume call.
    /// </remarks>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> *)
    {
        // Change the message id.  If it was -1, that means an async-send needs to occur
        if (_InterlockedExchange((volatile long *) &_M_savedId, _PMessage->msg_id()) == -1)
        {
            async_send(NULL);
        }

        // Always return postponed.  This message will be consumed
        // in the LWT

        return postponed;
    }

    /// <summary>
    ///     Accept the message by making a copy of the payload.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pSendMessage == NULL || _MsgId != _M_pSendMessage->msg_id())
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a _Non_greedy_node
        // does not need to grab the internal lock.
        //
        return (new message<size_t>(_M_pSendMessage->payload));
    }

    /// <summary>
    ///     Takes the message and propagates it to all the targets of this _Order_node
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages its _M_index into a message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<size_t> *)
    {
        _R_lock _Lock(_M_resetLock);

        if (_M_pSendMessage == NULL)
        {
            _Create_send_message();
        }

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<size_t> * _PTarget = *_Iter;
            _PTarget->propagate(_M_pSendMessage, this);
        }
    }

private:

    //
    //  Private Data Members
    //

    // The source where we have reserved a message
    ISource<_Type> * _M_pReservedSource;

    // The lock used to protect modification during a reset
    ::Concurrency::details::_ReentrantPPLLock _M_resetLock;

    // For non-greedy order nodes, the message id of the message to reserve/consume
    runtime_object_identity _M_savedId;

    // For non-greedy order nodes, the reserved id of the message that was reserved
    runtime_object_identity _M_reservedId;

    // The marker that indicates that _Non_greedy_node has reserved a message
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Non_greedy_node const & operator=(_Non_greedy_node const &);  // no assignment operator
    _Non_greedy_node(_Non_greedy_node const &);                    // no copy constructor
};

//**************************************************************************
// Choice:
//**************************************************************************

/// <summary>
///     A <c>choice</c> messaging block is a multi-source, single-target block that represents a control-flow
///     interaction with a set of sources. The choice block will wait for any one of multiple sources to
///     produce a message and will propagate the index of the source that produced the message.
/// </summary>
/// <typeparam name="_Type">
///     A <c>tuple</c>-based type representing the payloads of the input sources.
/// </typeparam>
/// <remarks>
///     The choice block ensures that only one of the incoming messages is consumed.
///     <para>For more information, see <see cref="Asynchronous Message Blocks"/>.</para>
/// </remarks>
/// <seealso cref="join Class"/>
/// <seealso cref="single_assignment Class"/>
/// <seealso cref="make_choice Function"/>
/// <seealso cref="tuple Class"/>
/**/
template<class _Type> 
class choice: public ISource<size_t>
{
public:

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for the choice.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    explicit choice(_Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(NULL)
    {
        _M_pSingleAssignment = new single_assignment<size_t>();
        _Initialize_choices<0>();
    }

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for the choice.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    choice(Scheduler& _PScheduler, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(&_PScheduler), _M_pScheduleGroup(NULL)
    {
        _M_pSingleAssignment = new single_assignment<size_t>(_PScheduler);
        _Initialize_choices<0>();
    }

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for the choice.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    choice(ScheduleGroup& _PScheduleGroup, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(&_PScheduleGroup)
    {
        _M_pSingleAssignment = new single_assignment<size_t>(_PScheduleGroup);
        _Initialize_choices<0>();
    }

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_Choice">
    ///     A <c>choice</c> messaging block to copy from.
    ///     Note that the original object is orphaned, making this a move constructor.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    choice(choice && _Choice)
    {
        // Copy scheduler group or scheduler to the new object.
        _M_pScheduleGroup = _Choice._M_pScheduleGroup;
        _M_pScheduler = _Choice._M_pScheduler;

        // Single assignment is heap allocated, so simply copy the pointer. If it already has
        // a value, it will be preserved.
        _M_pSingleAssignment = _Choice._M_pSingleAssignment;
        _Choice._M_pSingleAssignment = NULL;

        // Invoke copy assignment for tuple to copy pointers to message blocks.
        _M_sourceTuple = _Choice._M_sourceTuple;

        // Copy the pointers to order nodes to a new object and zero out in the old object.
        memcpy(_M_pSourceChoices, _Choice._M_pSourceChoices, sizeof(_M_pSourceChoices));
        memset(_Choice._M_pSourceChoices, 0, sizeof(_M_pSourceChoices));
    }

    /// <summary>
    ///     Destroys the <c>choice</c> messaging block.
    /// </summary>
    /**/
    ~choice()
    {
        delete _M_pSingleAssignment;
        _Delete_choices<0>();
    }

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    /// <summary>
    ///     Checks whether this <c>choice</c> messaging block has been initialized with a value yet.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the block has received a value, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return _M_pSingleAssignment->has_value();
    }

    /// <summary>
    ///     Returns an index into the <c>tuple</c> representing the element selected by the
    ///     <c>choice</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The message index.
    /// </returns>
    /// <remarks>
    ///      The message payload can be extracted using the <c>get</c> method.
    /// </remarks>
    /**/
    size_t index()
    {
        return _M_pSingleAssignment->value();
    }

    /// <summary>
    ///     Gets the message whose index was selected by the <c>choice</c> messaging block.
    /// </summary>
    /// <typeparam name="_Payload_type">
    ///     The type of the message payload.
    /// </typeparam>
    /// <returns>
    ///     The payload of the message.
    /// </returns>
    /// <remarks>
    ///     Since a <c>choice</c> messaging block can take inputs with different payload types, you must specify
    ///     the type of the payload at the point of retrieval. You can determine the type based on the result of
    ///     the <c>index</c> method.
    /// </remarks>
    /**/
    template <typename _Payload_type>
    _Payload_type const & value()
    {
        return reinterpret_cast<_Reserving_node<_Payload_type> *>(_M_pSourceChoices[_M_pSingleAssignment->value()])->value();
    }

    //
    // ISource public function implementations
    //

    /// <summary>
    ///     Links a target block to this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to link to this <c>choice</c> messaging block.
    /// </param>
    /**/
    virtual void link_target(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->link_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks a target block from this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to unlink from this <c>choice</c> messaging block.
    /// </param>
    /**/
    virtual void unlink_target(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->unlink_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks all targets from this <c>choice</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     This method does not need to be called from the destructor because destructor for the internal
    ///     <c>single_assignment</c> block will unlink properly.
    /// </remarks>
    /**/
    virtual void unlink_targets()
    {
        _M_pSingleAssignment->unlink_targets();
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>choice</c> block, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        return _M_pSingleAssignment->accept(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        return _M_pSingleAssignment->reserve(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Consumes a message previously offered by this <c>choice</c> messaging block and successfully reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    /// </remarks>
    /**/
    virtual message<size_t> * consume(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        return _M_pSingleAssignment->consume(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->release(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Acquires a reference count on this <c>choice</c> messaging block, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->acquire_ref(_PTarget);
    }

    /// <summary>
    ///     Releases a reference count on this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->release_ref(_PTarget);
    }

private:

    /// <summary>
    ///     Constructs and initializes a _Reserving_node for each tuple messaging block passed in.
    /// </summary>
    /// <typeparam>The highest-number index of the choice's sources</typeparam>
    /**/
    template<int _Index>
    void _Initialize_choices()
    {
        std::tr1::tuple_element<_Index, _Type>::type _Item = std::tr1::get<_Index>(_M_sourceTuple);
        _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Order_node_element = NULL;

        if (_M_pScheduleGroup != NULL)
        {
            _Order_node_element = new _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduleGroup, _Item, _Index);
        }
        else if (_M_pScheduler != NULL)
        {
            _Order_node_element = new _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduler, _Item, _Index);
        }
        else
        {
            _Order_node_element = new _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (_Item, _Index);
        }

        _M_pSourceChoices[_Index] = _Order_node_element;
        _Order_node_element->link_target(_M_pSingleAssignment);
        _Initialize_choices<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Initialize_choices recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Initialize_choices<std::tr1::tuple_size<_Type>::value>()
    {
    }

    /// <summary>
    ///     Deletes all _Reserving_node elements that were created in _Initialize_choices.
    /// </summary>
    /// <typeparam>The highest-number index of the choice's sources</typeparam>
    /**/
    template<int _Index>
    void _Delete_choices()
    {
        delete reinterpret_cast<_Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_M_pSourceChoices[_Index]);
        _M_pSourceChoices[_Index] = NULL;
        _Delete_choices<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Delete_choices recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Delete_choices<std::tr1::tuple_size<_Type>::value>()
    {
    }

    // Array of pointers to _Reserving_node elements representing each source
    void * _M_pSourceChoices[std::tr1::tuple_size<_Type>::value];

    // Single assignment which chooses between source messaging blocks
    single_assignment<size_t> * _M_pSingleAssignment;

    // Tuple of messaging blocks that are sources to this choice
    _Type _M_sourceTuple;

    // The scheduler to propagate messages on
    Scheduler * _M_pScheduler;

    // The schedule group to propagate messages on
    ScheduleGroup * _M_pScheduleGroup;

private:
    //
    // Hide assignment operator
    //
    choice const &operator =(choice const &);                      // no assignment operator
    choice(choice const &);                                        // no copy constructor
};

// Up to 10 templated factory functions that create a choice, three flavors

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2>
choice<std::tr1::tuple<_Type1, _Type2>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2)
{
    return choice<std::tr1::tuple<_Type1, _Type2>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
choice<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1>
choice<std::tr1::tuple<_Type1>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1)
{
    return choice<std::tr1::tuple<_Type1>>(_PScheduleGroup, std::tr1::make_tuple(_Item1));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2>
choice<std::tr1::tuple<_Type1, _Type2>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2)
{
    return choice<std::tr1::tuple<_Type1, _Type2>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
choice<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1>
choice<std::tr1::tuple<_Type1>>
make_choice(_Type1 _Item1)
{
    return choice<std::tr1::tuple<_Type1>>(std::tr1::make_tuple(_Item1));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2>
choice<std::tr1::tuple<_Type1, _Type2>>
make_choice(_Type1 _Item1, _Type2 _Item2)
{
    return choice<std::tr1::tuple<_Type1, _Type2>>(std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <summary>
/// Create a choice from a schedule group and three input sources
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
choice<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3>>(std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c> 
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

//**************************************************************************
// Join:
//**************************************************************************

// Template specialization used to unwrap the types from within a tuple.

/**/
template <typename _Tuple> struct _Unwrap;

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/**/
template <typename _T1>
struct _Unwrap<std::tr1::tuple<_T1>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2>
struct _Unwrap<std::tr1::tuple<_T1, _T2>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_Type3">
///     The type of the third element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/// <typeparam name="_T8">
///     The type of the eighth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type, typename std::tr1::remove_pointer<_T8>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/// <typeparam name="_T8">
///     The type of the eighth element of the tuple.
/// </typeparam>
/// <typeparam name="_T9">
///     The type of the ninth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type, typename std::tr1::remove_pointer<_T8>::type::source_type,
        typename std::tr1::remove_pointer<_T9>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/// <typeparam name="_T8">
///     The type of the eighth element of the tuple.
/// </typeparam>
/// <typeparam name="_T9">
///     The type of the ninth element of the tuple.
/// </typeparam>
/// <typeparam name="_T10">
///     The type of the tenth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type, typename std::tr1::remove_pointer<_T8>::type::source_type,
        typename std::tr1::remove_pointer<_T9>::type::source_type, typename std::tr1::remove_pointer<_T10>::type::source_type> type;
};

/// <summary>
///     Defines a block allowing sources of distinct types to be joined.
///     Join node is a single-target, multi-source ordered propagator block
/// </summary>
/// <typeparam name="_Type">
///     The payload tuple type
/// </typeparam>
/// <typeparam name="_Jtype">
///     The kind of join this is, either 'greedy' or 'non-greedy'
/// </typeparam>
/**/
template<typename _Type, typename _Destination_type, join_type _Jtype>
class _Join_node: public propagator_block<single_link_registry<ITarget<_Destination_type>>, multi_link_registry<ISource<size_t>>>
{
public:

    /// <summary>
    ///     Constructs a join within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /**/
    _Join_node() : _M_counter(std::tr1::tuple_size<_Destination_type>::value)
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs a join within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /**/
    _Join_node(Scheduler& _PScheduler) : _M_counter(std::tr1::tuple_size<_Destination_type>::value)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs a join within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /**/
    _Join_node(ScheduleGroup& _PScheduleGroup) : _M_counter(std::tr1::tuple_size<_Destination_type>::value)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the join.
    /// </summary>
    /**/
    ~_Join_node()
    {
        // Remove all links 
        remove_network_links();
    }

protected:

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<size_t> * _PMessage, ISource<size_t> * _PSource)
    {
        // This join block is connected to the _Order_node sources, which know not to send
        // any more messages until join propagates them further. That is why join can
        // always accept the incoming messages.

        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        //
        // Source block created an int message only to notify join that the real
        // payload is available. There is no need to keep this message around.
        //
        _ASSERTE(_PMessage != NULL);
        delete _PMessage;

        long _Ret_val = _InterlockedDecrement(&_M_counter);

        _ASSERTE(_Ret_val >= 0);

        if (_Ret_val == 0)
        {
            //
            // All source messages are now received so join can propagate them further
            //
            async_send(NULL);
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts an offered message by the source, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Destination_type> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the Ids match
        // dequeue and transfer ownership
        //
        message<_Destination_type> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by the source.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A bool indicating whether the reservation worked or not.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the source and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     <c>consume_message</c> is similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Destination_type> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     Notification that a target was linked to this source.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Destination_type> *)
    {
        // There is only a single target.
        _Propagate_priority_order(_M_messageBuffer);
    }

    /// <summary>
    ///     Takes the message and propagates it to all the targets of this <c>join</c> block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages source payloads into a tuple message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<_Destination_type> *)
    {
        message<_Destination_type> * _Msg = NULL;

        if (_M_counter == 0)
        {
            bool fIsNonGreedy = (_Jtype == non_greedy);

            if (fIsNonGreedy)
            {
                if (!_Non_greedy_acquire_messages())
                {
                    return;
                }
            }

            if (!fIsNonGreedy)
            {
                // Since a greedy join has captured all input, we can reset
                // the counter to the total number of inputs
                _InterlockedExchange(&_M_counter, std::tr1::tuple_size<_Destination_type>::value);
            }

            _Msg = _Create_send_message();
        }

        if (_Msg != NULL)
        {
            _M_messageBuffer._Enqueue(_Msg);

            if (!_M_messageBuffer._Is_head(_Msg->msg_id()))
            {
                // another message is at the head of the outbound message queue and blocked
                // simply return
                return;
            }
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    /// <summary>
    ///     Tries to reserve from all sources.  If successful, it will consume all the messages
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the consumption attempt worked.
    /// </returns>
    /// <typeparam name="_Index">
    ///     The highest-number index of the join's sources
    /// </typeparam>
    /**/
    template<int _Index>
    bool _Try_consume_source_messages(_Destination_type & _Destination_tuple, ISource<size_t> ** _Sources)
    {
        _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Node =
            static_cast<_Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_Sources[_Index]);

        // Increment the counter once for each reservation
        _InterlockedIncrement(&_M_counter);

        if (_Node->_Reserve_received_message())
        {
            bool _Ret_val = _Try_consume_source_messages<_Index + 1>(_Destination_tuple, _Sources);

            if (_Ret_val)
            {
                _Node->_Consume_received_message();
            }
            else
            {
                if (_Node->_Release_received_message())
                {
                    // If _Release_received_message() restored the ID, decrement the count for that
                    // restoration
                    if (_InterlockedDecrement(&_M_counter) == 0)
                    {
                        async_send(NULL);
                    }
                }
            }

            return _Ret_val;
        }
        
        return false;
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Try_consume_source_messages recursive
    ///     template expansion.
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the consumption attempt worked.
    /// </returns>
    /**/
    template<> bool _Try_consume_source_messages<std::tr1::tuple_size<_Type>::value>(_Destination_type &, ISource<size_t> **)
    {
        return true;
    }

    /// <summary>
    ///     Tries to acquire all of the messages from the _Non_greedy_nodes.  Each node has already
    ///     indicated that it has received a message that it can try to reserve.  This function
    ///     starts the reservation and consume process.
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the reserve/consume of all messages succeeded.
    /// </returns>
    /**/
    bool _Non_greedy_acquire_messages()
    {
        _Destination_type _Destination_tuple;

        // Populate the sources buffer
        ISource<size_t> * _Sources[std::tr1::tuple_size<_Type>::value];
        size_t _Index = 0;

        // Get an iterator which will keep a reference on the connected sources
        source_iterator _Iter = _M_connectedSources.begin(); 

        while (*_Iter != NULL)
        {
            ISource<size_t> * _PSource = *_Iter;

            if (_PSource == NULL)
            {
                // One of the sources disconnected
                break;
            }

            if (_Index >= std::tr1::tuple_size<_Type>::value)
            {
                // More sources that we expect
                break;
            }

            _Sources[_Index] = _PSource;
            _Index++;
            ++_Iter;
        }

        // The order nodes should not have unlinked while the join node is
        // active.

        if (_Index != std::tr1::tuple_size<_Type>::value)
        {
            // On debug build assert to help debugging
            _ASSERTE(_Index == std::tr1::tuple_size<_Type>::value);
            return false;
        }

        bool _IsAcquireSuccessful = _Try_consume_source_messages<0>(_Destination_tuple, _Sources);

        return _IsAcquireSuccessful;
    }

    /// <summary>
    ///     Propagate messages in priority order
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    /// <summary>
    ///     Called when all the source messaging blocks have received their messages. The payloads are copied
    ///     into local tuple and then packaged into a message to be propagated: _M_pSendMessage.
    /// </summary>
    /**/
    message<_Destination_type> * _Create_send_message()
    {
        _Destination_type _Destination_tuple;

        // Populate the sources buffer
        ISource<size_t> * _Sources[std::tr1::tuple_size<_Type>::value];
        size_t _Index = 0;

        // Get an iterator which will keep a reference on the connected sources
        source_iterator _Iter = _M_connectedSources.begin(); 

        while (*_Iter != NULL)
        {
            ISource<size_t> * _PSource = *_Iter;

            if (_PSource == NULL)
            {
                // One of the sources disconnected
                break;
            }

            // Avoid buffer overrun
            if (_Index >= std::tr1::tuple_size<_Type>::value)
            {
                // More sources that we expect
                break;
            }

            _Sources[_Index] = *_Iter;
            _Index++;
            ++_Iter;
        }

        // The order nodes should not have unlinked while the join node is
        // active. 
        if (_Index != std::tr1::tuple_size<_Type>::value)
        {
            // On debug build assert to help debugging
            _ASSERTE(_Index == std::tr1::tuple_size<_Type>::value);
            return NULL;
        }

        _Populate_destination_tuple<0>(_Destination_tuple, _Sources);

        return new message<_Destination_type>(_Destination_tuple);
    }

    /// <summary>
    ///     Copies payloads from all sources to destination tuple.
    /// </summary>
    /**/
    template<int _Index>
    void _Populate_destination_tuple(_Destination_type & _Destination_tuple, ISource<size_t> ** _Sources)
    {
        _Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Node =
            static_cast<_Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_Sources[_Index]);

        std::tr1::get<_Index>(_Destination_tuple) = _Node->value();
        _Node->_Reset();

        _Populate_destination_tuple<_Index + 1>(_Destination_tuple, _Sources);
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Populate_destination_tuple recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Populate_destination_tuple<std::tr1::tuple_size<_Type>::value>(_Destination_type &, ISource<size_t> **)
    {
    }

    // A tuple containing a collection of source messaging blocks
    _Type _M_sourceTuple;

    // Counts messages received by sources of this node and is used to trigger propagation to targets
    // This value starts at the total number of inputs and counts down to zero.  When it reaches zero,
    // a join of the inputs is started.
    volatile long _M_counter;

    // Buffer to hold outgoing messages
    ::Concurrency::details::_Queue<message<_Destination_type>> _M_messageBuffer;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Join_node(const _Join_node & _Join);                                  // no copy constructor
    _Join_node const &operator =(_Join_node const &);                      // no assignment operator
};

/// <summary>
///     A <c>multitype_join</c> messaging block is a multi-source, single-target messaging block that
///     combines together messages of different types from each of its sources and offers a tuple
///     of the combined messages to its targets.
/// </summary>
/// <typeparam name="_Type">
///     The <c>tuple</c> payload type of the messages joined and propagated by the block.
/// </typeparam>
/// <typeparam name="_Jtype">
///     The kind of <c>join</c> block this is, either <c>greedy</c> or <c>non_greedy</c>
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="choice Class"/>
/// <seealso cref="join Class"/>
/// <seealso cref="join_type Enumeration"/>
/// <seealso cref="make_join Function"/>
/// <seealso cref="make_greedy_join Function"/>
/// <seealso cref="tuple Class"/>
/**/
template<typename _Type, join_type _Jtype = non_greedy>
class multitype_join: public ISource<typename _Unwrap<_Type>::type>
{
public:

    typedef typename _Unwrap<_Type>::type _Destination_type;

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for this <c>multitype_join</c> messaging block.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    explicit multitype_join(_Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(NULL)
    {
        _M_pJoinNode = new _Join_node<_Type, _Destination_type, _Jtype>();
        _Initialize_joins<0>();
    }

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for this <c>multitype_join</c> messaging block.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    multitype_join(Scheduler& _PScheduler, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(&_PScheduler), _M_pScheduleGroup(NULL)
    {
        _M_pJoinNode = new _Join_node<_Type, _Destination_type, _Jtype>(_PScheduler);
        _Initialize_joins<0>();
    }

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for this <c>multitype_join</c> messaging block.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    multitype_join(ScheduleGroup& _PScheduleGroup, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(&_PScheduleGroup)
    {
        _M_pJoinNode = new _Join_node<_Type, _Destination_type, _Jtype>(_PScheduleGroup);
        _Initialize_joins<0>();
    }

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_Join">
    ///     A <c>multitype_join</c> messaging block to copy from.
    ///     Note that the original object is orphaned, making this a move constructor.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    multitype_join(multitype_join && _Join)
    {
        // Copy scheduler group or scheduler to the new object.
        _M_pScheduleGroup = _Join._M_pScheduleGroup;
        _M_pScheduler = _Join._M_pScheduler;

        // Single assignment is heap allocated, so simply copy the pointer. If it already has
        // a value, it will be preserved.
        _M_pJoinNode = _Join._M_pJoinNode;
        _Join._M_pJoinNode = NULL;

        // Invoke copy assignment for tuple to copy pointers to message blocks.
        _M_sourceTuple = _Join._M_sourceTuple;

        // Copy the pointers to order nodes to a new object and zero out in the old object.
        memcpy(_M_pSourceJoins, _Join._M_pSourceJoins, sizeof(_M_pSourceJoins));
        memset(_Join._M_pSourceJoins, 0, sizeof(_M_pSourceJoins));
    }

    /// <summary>
    ///     Destroys the <c>multitype_join</c> messaging block.
    /// </summary>
    /**/
    ~multitype_join()
    {
        delete _M_pJoinNode;
        _Delete_joins<0>();
    }

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    //
    // ISource public function implementations
    //

    /// <summary>
    ///     Links a target block to this <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to link to this <c>multitype_join</c> messaging block.
    /// </param>
    /**/
    virtual void link_target(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->link_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks a target block from this <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to unlink from this <c>multitype_join</c> messaging block.
    /// </param>
    /**/
    virtual void unlink_target(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->unlink_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks all targets from this <c>multitype_join</c> messaging block.
    /// </summary>
    /**/
    virtual void unlink_targets()
    {
        _M_pJoinNode->unlink_targets();
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>multitype_join</c> block, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Destination_type> * accept(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        return _M_pJoinNode->accept(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        return _M_pJoinNode->reserve(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>multitype_join</c> messaging block and successfully reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    /// </remarks>
    /**/
    virtual message<_Destination_type> * consume(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        return _M_pJoinNode->consume(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->release(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Acquires a reference count on this <c>multitype_join</c> messaging block, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->acquire_ref(_PTarget);
    }

    /// <summary>
    ///     Releases a reference count on this <c>multiple_join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->release_ref(_PTarget);
    }

private:

    /// <summary>
    ///     Constructs and initializes a _Order_node for each tuple messaging block passed in.
    /// </summary>
    /// <typeparam name="_Index">
    ///     The highest-number index of the multitype_join's sources
    /// </typeparam>
    /**/
    template<int _Index>
    void _Initialize_joins()
    {
        std::tr1::tuple_element<_Index, _Type>::type _Item = std::tr1::get<_Index>(_M_sourceTuple);
        _Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Order_node_element = NULL;

        bool fIsNonGreedy = (_Jtype == non_greedy);

        if (fIsNonGreedy)
        {
            if (_M_pScheduleGroup != NULL)
            {
                _Order_node_element = new _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduleGroup, _Item, _Index);
            }
            else if (_M_pScheduler != NULL)
            {
                _Order_node_element = new _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduler, _Item, _Index);
            }
            else
            {
                _Order_node_element = new _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (_Item, _Index);
            }
        }
        else
        {
            if (_M_pScheduleGroup != NULL)
            {
                _Order_node_element = new _Greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduleGroup, _Item, _Index);
            }
            else if (_M_pScheduler != NULL)
            {
                _Order_node_element = new _Greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduler, _Item, _Index);
            }
            else
            {
                _Order_node_element = new _Greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (_Item, _Index);
            }
        }
        _M_pSourceJoins[_Index] = _Order_node_element;
        _Order_node_element->link_target(_M_pJoinNode);
        _Initialize_joins<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Initialize_joins recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Initialize_joins<std::tr1::tuple_size<_Type>::value>()
    {
    }

    /// <summary>
    ///     Deletes all _Order_node elements that were created in _Initialize_joins.
    /// </summary>
    /// <typeparam name="_Index">
    ///     The highest-number index of the multitype_join's sources
    /// </typeparam>
    /**/
    template<int _Index>
    void _Delete_joins()
    {
        delete reinterpret_cast<_Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_M_pSourceJoins[_Index]);
        _M_pSourceJoins[_Index] = NULL;
        _Delete_joins<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Delete_joins recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Delete_joins<std::tr1::tuple_size<_Type>::value>()
    {
    }

    // Array of pointers to _Order_node elements representing each source
    void * _M_pSourceJoins[std::tr1::tuple_size<_Type>::value];

    // Join node that collects source messaging block messages
    _Join_node<_Type, _Destination_type, _Jtype> * _M_pJoinNode;

    // Tuple of messaging blocks that are sources to this multitype_join
    _Type _M_sourceTuple;

    // The scheduler to propagate messages on
    Scheduler * _M_pScheduler;

    // The schedule group to propagate messages on
    ScheduleGroup * _M_pScheduleGroup;

private:
    //
    // Hide assignment operator
    //
    multitype_join const &operator =(multitype_join const &);                      // no assignment operator
    multitype_join(multitype_join const &);                                        // no copy constructor
};

// Up to 10 templated factory functions that create a join, three flavors

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>>
make_join(_Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>>(std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>(std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c> 
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

// Up to 10 templated factory functions that create a *greedy* join, three flavors

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block
///     is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}


/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>(std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>(std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

//**************************************************************************
// Agents:
//**************************************************************************

/// <summary>
///     The valid states for an <c>agent</c>.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Asynchronous Agents"/>.
/// </remarks>
/**/
enum agent_status {
    /// <summary>
    ///     The <c>agent</c> has been created but not started.
    /// </summary>
    /**/
    agent_created,
    /// <summary>
    ///     The <c>agent</c> has been started, but not entered its <c>run</c> method.
    /// </summary>
    /**/
    agent_runnable,
    /// <summary>
    ///     The <c>agent</c> has started.
    /// </summary>
    /**/
    agent_started,
    /// <summary>
    ///     The <c>agent</c> finished without being canceled.
    /// </summary>
    /**/
    agent_done,
    /// <summary>
    ///     The <c>agent</c> was canceled.
    /// </summary>
    /**/
    agent_canceled
};

/// <summary>
///     A class intended to be used as a base class for all independent agents. It is used to hide
///     state from other agents and interact via message-passing.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Asynchronous Agents"/>.
/// </remarks>
/**/
class agent
{
public:
    /// <summary>
    ///     Constructs an agent.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP2 agent();

    /// <summary>
    ///     Constructs an agent.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the execution task of the agent is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP2 agent(Scheduler& _PScheduler);

    /// <summary>
    ///     Constructs an agent.
    /// </summary>
    /// <param name="_PGroup">
    ///     The <c>ScheduleGroup</c> object within which the execution task of the agent is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP2 agent(ScheduleGroup& _PGroup);

    /// <summary>
    ///     Destroys the agent.
    /// </summary>
    /// <remarks>
    ///     It is an error to destroy an agent that is not in a terminal state (either <c>agent_done</c> or
    ///     <c>agent_canceled</c>). This can be avoided by waiting for the agent to reach a terminal state
    ///     in the destructor of a class that inherits from the <c>agent</c> class.
    /// </remarks>
    /**/
    _CRTIMP2 virtual ~agent();

    /// <summary>
    ///     An asynchronous source of status information from the agent.
    /// </summary>
    /// <returns>
    ///     Returns a message source that can send messages about the current state of the agent.
    /// </returns>
    /**/
    _CRTIMP2 ISource<agent_status> * status_port();

    /// <summary>
    ///     A synchronous source of status information from the agent.
    /// </summary>
    /// <returns>
    ///     Returns the current state of the agent.  Note that this returned state could change
    ///     immediately after being returned.
    /// </returns>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 agent_status status();

    /// <summary>
    ///     Moves an agent from the <c>agent_created</c> state to the <c>agent_runnable</c> state, and schedules it for execution.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the agent started correctly, <c>false</c> otherwise. An agent that has been canceled cannot be started.
    /// </returns>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 bool start();

    /// <summary>
    ///     Moves an agent from either the <c>agent_created</c> or <c>agent_runnable</c> states to the <c>agent_canceled</c> state.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the agent was canceled, <c>false</c> otherwise. An agent cannot be canceled if it has already started
    ///     running or has already completed.
    /// </returns>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 bool cancel();

    /// <summary>
    ///     Waits for an agent to complete its task.
    /// </summary>
    /// <param name="_PAgent">
    ///     A pointer to the agent to wait for.
    /// </param>
    /// <param name="_Timeout">
    ///     The maximum time for which to wait, in milliseconds.
    /// </param>
    /// <returns>
    ///     The <c>agent_status</c> of the agent when the wait completes. This can either be <c>agent_canceled</c>
    ///     or <c>agent_done</c>.
    /// </returns>
    /// <remarks>
    ///     An agent task is completed when the agent enters the <c>agent_canceled</c> or <c>agent_done</c> states.
    ///     <para>If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
    ///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
    ///     of time expires before the agent has completed its task.</para>
    /// </remarks>
    /// <seealso cref="agent::wait_for_all Method"/>
    /// <seealso cref="agent::wait_for_one Method"/>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 static agent_status __cdecl wait(agent * _PAgent, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    /// <summary>
    ///     Waits for all of the specified agents to complete their tasks.
    /// </summary>
    /// <param name="_Count">
    ///     The number of agent pointers present in the array <paramref name="_PAgents"/>.
    /// </param>
    /// <param name="_PAgents">
    ///     An array of pointers to the agents to wait for.
    /// </param>
    /// <param name="_PStatus">
    ///     A pointer to an array of agent statuses. Each status value will represent the status of the corresponding
    ///     agent when the method returns.
    /// </param>
    /// <param name="_Timeout">
    ///     The maximum time for which to wait, in milliseconds.
    /// </param>
    /// <remarks>
    ///     An agent task is completed when the agent enters the <c>agent_canceled</c> or <c>agent_done</c> states.
    ///     <para>If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
    ///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
    ///     of time expires before the agent has completed its task.</para>
    /// </remarks>
    /// <seealso cref="agent::wait Method"/>
    /// <seealso cref="agent::wait_for_one Method"/>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 static void __cdecl wait_for_all(size_t _Count, __in_ecount(_Count) agent ** _PAgents,
        __out_ecount_opt(_Count) agent_status * _PStatus = NULL, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    /// <summary>
    ///     Waits for any one of the specified agents to complete its task.
    /// </summary>
    /// <param name="_Count">
    ///     The number of agent pointers present in the array <paramref name="_PAgents"/>.
    /// </param>
    /// <param name="_PAgents">
    ///     An array of pointers to the agents to wait for.
    /// </param>
    /// <param name="_Status">
    ///     A reference to a variable where the agent status will be placed.
    /// </param>
    /// <param name="_Index">
    ///     A reference to a variable where the agent index will be placed.
    /// </param>
    /// <param name="_Timeout">
    ///     The maximum time for which to wait, in milliseconds.
    /// </param>
    /// <remarks>
    ///     An agent task is completed when the agent enters the <c>agent_canceled</c> or <c>agent_done</c> states.
    ///     <para>If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
    ///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
    ///     of time expires before the agent has completed its task.</para>
    /// </remarks>
    /// <seealso cref="agent::wait Method"/>
    /// <seealso cref="agent::wait_for_all Method"/>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 static void __cdecl wait_for_one(size_t _Count, agent ** _PAgents, agent_status& _Status,
                                      size_t& _Index, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

protected:
    /// <summary>
    ///     Represents the main task of an agent. <c>run</c> should be overridden in a derived class, and specifies what
    ///     the agent should do after it has been started.
    /// </summary>
    /// <remarks>
    ///     The agent status is changed to <c>agent_started</c> right before this method is invoked. The method should
    ///     invoke <c>done</c> on the agent with an appropriate status before returning, and may not throw any
    ///     exceptions.
    /// </remarks>
    /**/
    virtual void run() = 0;

    /// <summary>
    ///     Moves an agent into the <c>agent_done</c> state, indicating that the agent has completed.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the agent is moved to the <c>agent_done</c> state, <c>false</c> otherwise. An agent that has
    ///     been canceled cannot be moved to the <c>agent_done</c> state.
    /// </returns>
    /// <remarks>
    ///     This method should be called at the end of the <c>run</c> method, when you know the execution of your agent
    ///     has completed.
    /// </remarks>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 bool done();

    /// <summary>
    ///     Holds the current status of the agent.
    /// </summary>
    /**/
    overwrite_buffer<agent_status> _M_status;

private:

    // A flag to check of whether the agent can be started
    // This is initialized to TRUE and there is a race between Start() and Cancel() to set it
    // to FALSE.  Once Started or Canceled, further calls to Start() or Cancel() will return false.
    /**/
    volatile long _M_fStartable;

    // A flag to check of whether the agent can be canceled
    // This is initailized to TRUE and there is a race between Cancel() and the LWT executing
    // a task that has been started to set it to FALSE.  If Cancel() wins, the task will not be
    // executed.  If the LWT wins, Cancel() will return false.
    /**/
    volatile long _M_fCancelable;

    // A static wrapper function that calls the Run() method.  Used for scheduling of the task
    /**/
    static void __cdecl _Agent_task_wrapper(void * data);

    Scheduler * _M_pScheduler;
    ScheduleGroup * _M_pScheduleGroup;
};

//**************************************************************************
// Direct Messaging APIs:
//**************************************************************************

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.  If the specified timeout is not
///     COOPERATIVE_TIMEOUT_INFINITE, an exception (operation_timed_out) will be thrown if the specified amount
///     of time expires before a message is received.  Note that zero length timeouts should likely use
///     try_receive as opposed to receive with a timeout of zero as it is more efficient and does not
///     throw exceptions on timeouts.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer to the source from which data is expected.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <param name="_Filter_proc">
///     A pointer to a filter which will indicate whether to accept the data or not.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/**/
template <class _Type>
_Type _receive_impl(ISource<_Type> * _Src, unsigned int _Timeout, typename ITarget<_Type>::filter_method const* _Filter_proc)
{
    // The Blocking Recipient messaging block class is internal to the receive function
    class _Blocking_recipient : public ITarget<_Type>
    {
    public:
        // Create an Blocking Recipient
        _Blocking_recipient(ISource<_Type> * _PSource,
            unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fState(_NotInitialized), _M_timeout(_Timeout)
        {
            _Connect(_PSource);
        }

        // Create an Blocking Recipient
        _Blocking_recipient(ISource<_Type> * _PSource,
            filter_method const& _Filter,
            unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fState(_NotInitialized), _M_timeout(_Timeout)
        {
            if (_Filter != NULL)
            {
                _M_pFilter = new filter_method(_Filter);
            }

            _Connect(_PSource);
        }

        // Cleans up any resources that may have been created by the BlockingRecipient.
        ~_Blocking_recipient()
        {
            _Disconnect();

            delete _M_pFilter;
            delete _M_pMessage;
        }

        // Gets the value of the message sent to this BlockingRecipient.  Blocks by
        // spinning until a message has arrived.
        _Type _Value()
        {
            _Wait_for_message();

            return _M_pMessage->payload;
        }

        // The main propagation function for ITarget blocks.  Called by a source
        // block, generally within an asynchronous task to send messages to its targets.
        virtual message_status propagate(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            // Throw exception if the message being propagated to this block is NULL
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Reject if the message does not meet the filter requirements
            if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
            {
                return declined;
            }

            // Reject if the recipient has already received a message
            if (_M_fState == _Initialized)
            {
                return declined;
            }

            // Accept the message
            _ASSERTE(_PSource != NULL);
            _M_pMessage = _PSource->accept(_PMessage->msg_id(), this);

            if (_M_pMessage != NULL)
            {
                // Set the initialized flag on this block
                if (_InterlockedExchange(&_M_fState, _Initialized) == _Blocked)
                {
                    _M_ev.set();
                }

                return accepted;
            }

            return missed;
        }

        // Synchronously sends a message to this block.  When this function completes the message will
        // already have propagated into the block.
        virtual message_status send(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Only the connected source is allowed to send messages
            // to the blocking recepient. Decline messages without
            // a source.

            return declined;
        }

    private:

        // Link a source block
        virtual void link_source(ISource<_Type> * _PSrc)
        {
            _M_pConnectedTo = _PSrc;
            _PSrc->acquire_ref(this);
        }

        // Remove a source messaging block for this BlockingRecipient
        virtual void unlink_source(ISource<_Type> * _PSource)
        {
            if (_InterlockedCompareExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL, _PSource) == _PSource)
            {
                _PSource->release_ref(this);
            }
        }

        // Remove the source messaging block for this BlockingRecipient
        virtual void unlink_sources()
        {
            ISource<_Type> * _PSource = reinterpret_cast<ISource<_Type> *>(_InterlockedExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL));
            if (_PSource != NULL)
            {
                _PSource->unlink_target(this);
                _PSource->release_ref(this);
            }
        }


        // Connect the blocking recipient to the source
        void _Connect(ISource<_Type> * _PSource)
        {
            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            _PSource->link_target(this);
        }

        // Cleanup the connection to the blocking recipient's source. There is no need
        // to do anything about the associated context.
        void _Disconnect()
        {
            unlink_sources();
        }

        // Internal function used to block while waiting for a message to arrive
        // at this BlockingRecipient
        void _Wait_for_message()
        {
            bool _Timeout = false;

            // If we haven't received a message yet, cooperatively block.
            if (_InterlockedCompareExchange(&_M_fState, _Blocked, _NotInitialized) == _NotInitialized)
            {
                if (_M_ev.wait(_M_timeout) == COOPERATIVE_WAIT_TIMEOUT)
                {
                    _Timeout = true;
                }
            }

            // Unlinking from our source guarantees that there are no threads in propagate
            _Disconnect();

            if (_M_fState != _Initialized)
            {
                // We had to have timed out if we came out of the wait
                // without being initialized.
                _ASSERTE(_Timeout);

                throw operation_timed_out();
            }
        }

        // States for this block
        enum
        {
            _NotInitialized,
            _Blocked,
            _Initialized
        };

        volatile long _M_fState;

        // The source messaging block connected to this Recipient
        ISource<_Type> * _M_pConnectedTo;

        // The message that was received
        message<_Type> * volatile _M_pMessage;

        // The timeout.
        unsigned int _M_timeout;

        // The event we wait upon
        event _M_ev;

        // The filter that is called on this block before accepting a message
        filter_method * _M_pFilter;
    };

    if (_Filter_proc != NULL)
    {
        _Blocking_recipient _Recipient(_Src, *_Filter_proc, _Timeout);
        return _Recipient._Value();
    }
    else
    {
        _Blocking_recipient _Recipient(_Src, _Timeout);
        return _Recipient._Value();
    }
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> * _Src, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(_Src, _Timeout, NULL);
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> * _Src, typename ITarget<_Type>::filter_method const& _Filter_proc, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(_Src, _Timeout, &_Filter_proc);
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> &_Src, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(&_Src, _Timeout, NULL);
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> &_Src, typename ITarget<_Type>::filter_method const& _Filter_proc, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(&_Src, _Timeout, &_Filter_proc);
}

/// <summary>
///     Helper function that implements try_receive
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, try_receive will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <param name="_Filter_proc">
///     A pointer to a filter which will indicate whether to accept the data or not.
/// </param>
/// <returns>
///     A bool indicating whether a payload was placed in <paramref name="_value"/> or not.
/// </returns>
/**/
template <class _Type>
bool _try_receive_impl(ISource<_Type> * _Src, _Type & _value, typename ITarget<_Type>::filter_method const * _Filter_proc)
{
    // The Immediate Recipient messaging block class is internal to the receive function
    class _Immediate_recipient : public ITarget<_Type>
    {
    public:
        // Create an Immediate Recipient
        _Immediate_recipient(ISource<_Type> * _PSource) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fIsInitialized(0)
        {
            _Connect(_PSource);
        }

        // Create an Immediate Recipient
        _Immediate_recipient(ISource<_Type> * _PSource,
            filter_method const& _Filter) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fIsInitialized(0)
        {
            if (_Filter != NULL)
            {
                _M_pFilter = new filter_method(_Filter);
            }

            _Connect(_PSource);
        }

        // Cleans up any resources that may have been created by the ImmediateRecipient.
        ~_Immediate_recipient()
        {
            _Disconnect();

            delete _M_pFilter;
            delete _M_pMessage;
        }

        // Gets the value of the message sent to this ImmediateRecipient.
        bool _Value(_Type & _value)
        {     
            // Unlinking from our source guarantees that there are no threads in propagate
            _Disconnect();

            if (_M_pMessage != NULL)
            {
                _value = _M_pMessage->payload;
                return true;
            }

            return false;
        }

        // The main propagation function for ITarget blocks.  Called by a source
        // block, generally within an asynchronous task to send messages to its targets.
        virtual message_status propagate(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            message_status _Result = accepted;

            // Throw exception if the message being propagated to this block is NULL
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Reject if the message does not meet the filter requirements
            if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
            {
                return declined;
            }

            // Reject if the recipient has already received a message
            if (_M_fIsInitialized == 1)
            {
                return declined;
            }

            // Accept the message
            _ASSERTE(_PSource != NULL);
            _M_pMessage = _PSource->accept(_PMessage->msg_id(), this);

            // Set the initialized flag on this block

            if (_M_pMessage != NULL)
            {
                // Fence to ensure that the above update to _M_pMessage is visible
                _InterlockedExchange(&_M_fIsInitialized, 1);
                _Result = accepted;
            }
            else
            {
                _Result = missed;
            }

            return _Result;
        }


        // Synchronously sends a message to this block.  When this function completes the message will
        // already have propagated into the block.
        virtual message_status send(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Only the connected source is allowed to send messages
            // to the blocking recepient. Decline messages without
            // a source.

            return declined;
        }

    private:

        // Add a source messaging block 
        virtual void link_source(ISource<_Type> * _PSrc)
        {
            _M_pConnectedTo = _PSrc;
            _PSrc->acquire_ref(this);
        }

        // Remove a source messaging block for this BlockingRecipient
        virtual void unlink_source(ISource<_Type> * _PSource)
        {
            if (_InterlockedCompareExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL, _PSource) == _PSource)
            {
                _PSource->release_ref(this);
            }
        }

        // Remove the source messaging block for this BlockingRecipient
        virtual void unlink_sources()
        {
            ISource<_Type> * _PSource = reinterpret_cast<ISource<_Type> *>(_InterlockedExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL));
            if (_PSource != NULL)
            {
                _PSource->unlink_target(this);
                _PSource->release_ref(this);
            }
        }

        // Connect to a source block
        void _Connect(ISource<_Type> * _PSource)
        {
            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            _ASSERTE(_M_fIsInitialized == 0);

            _PSource->link_target(this);
        }

        //
        // Cleanup the connection to the trigger's source. There is no need
        // to do anything about the associated context.
        //
        void _Disconnect()
        {
            unlink_sources();
        }

        // The source messaging block connected to this Recipient
        ISource<_Type> * _M_pConnectedTo;

        // The message that was received
        message<_Type> * volatile _M_pMessage;

        // A flag for whether or not this block has been initialized with a value
        volatile long _M_fIsInitialized;

        // The filter that is called on this block before accepting a message
        filter_method * _M_pFilter;
    };

    if (_Filter_proc != NULL)
    {
        _Immediate_recipient _Recipient(_Src, *_Filter_proc);
        return _Recipient._Value(_value);
    }
    else
    {
        _Immediate_recipient _Recipient(_Src);
        return _Recipient._Value(_value);
    }
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> * _Src, _Type & _value)
{
    return _try_receive_impl(_Src, _value, NULL);
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> * _Src, _Type & _value, typename ITarget<_Type>::filter_method const& _Filter_proc)
{
    return _try_receive_impl(_Src, _value, &_Filter_proc);
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> & _Src, _Type & _value)
{
    return _try_receive_impl(&_Src, _value, NULL);
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> & _Src, _Type & _value, typename ITarget<_Type>::filter_method const& _Filter_proc)
{
    return _try_receive_impl(&_Src, _value, &_Filter_proc);
}

/// <summary>
///     A synchronous send operation, which waits until the target either accepts or declines the message.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool send(ITarget<_Type> * _Trg, const _Type& _Data)
{
    // The Originator messaging block class is internal to the send function.
    class _Originator : public ISource<_Type>
    {
    public:

        typedef single_link_registry<ITarget<_Type>> _Target_registry;

        // Create an Originator
        _Originator() :
          _M_pMessage(NULL),
          _M_fStatus(postponed),
          _M_referenceCount(0)
        {
        }

        // Cleans up any resources that may have been created by the Originator.
        virtual ~_Originator()
        {
            unlink_targets();

            _Wait_on_ref();

            delete _M_pMessage;
        }

        // Removes a target messaging block for this Originator
        virtual void unlink_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);
                if (_M_connectedTargets.remove(_PTarget))
                {
                    _Invoke_unlink_source(_PTarget);

                    // Indicate that the send is complete
                    _Done(declined);
                }
            }
        }

        // Removes the target messaging block from this Originator
        virtual void unlink_targets()
        {
            // Hold the lock to ensure that the target doesn't unlink while
            // propagation is in progress.
            _R_lock _Lock(_M_internalLock);

            for (_Target_registry::iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Type> * _PTarget = *_Iter;
                if (_M_connectedTargets.remove(_PTarget))
                {
                    _Invoke_unlink_source(_PTarget);
                }
            }

            // All targets should be unlinked
            _ASSERTE(_M_connectedTargets.count() == 0);

            // Indicate that the send is complete
            _Done(declined);
        }

        // Accept on this Originator is called by a target to take ownership of a
        // propagated message
        virtual message<_Type> * accept(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                return NULL;
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return NULL;
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return NULL;
            }

            // The Id's match, actaully transfer ownership of the message and
            // unlink away from the target
            message<_Type> * _Result = _M_pMessage;

            // The ownership of this message has changed.  Set the internal pointer to NULL
            // so it won't be deleted in the destructor
            _M_pMessage = NULL;

            // The message has been accepted/consumed, propagate indication that it has succeeded
            _Done(accepted);

            return _Result;
        }

        // Reserve needs to be defined for ISource blocks, but Originator doesn't need to
        // do anything for reservation since there can only be one target block to read
        // the data at a later time.
        virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return false;
            }

            if (_M_pMessage->msg_id() != _MsgId)
            {
                return false;
            }

            return true;
        }

        // Consume is called by a target messaging block to take ownership of a
        // previously reserved message.
        virtual message<_Type> * consume(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            return accept(_MsgId, _PTarget);
        }

        // Release needs to be defined for ISource blocks, but Originator doesn't need to
        // do anything for reservation release since there can only be one target block to read
        // the data at a later time.
        virtual void release(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            if ((_M_pMessage == NULL) || (_M_pMessage->msg_id() != _MsgId))
            {
                throw message_not_found();
            }

            // If the previously reserved message is released, then propagate
            // declined  to indicate that the message was not accepted.
            _Done(declined);
        }

        virtual void acquire_ref(ITarget<_Type> *)
        {
            _InterlockedIncrement(&_M_referenceCount);
        }

        virtual void release_ref(ITarget<_Type> *)
        {
            _InterlockedDecrement(&_M_referenceCount);
        }

        // Send the given value to the target
        bool _send(ITarget<_Type> * _PTarget, _Type const & _Value)
        {
            // _send should only be called once.
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            message_status _Status = declined;
            message<_Type> * _Msg = new message<_Type>(_Value);
           
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                // link to the target, create a message and send it
                link_target(_PTarget);

                _ASSERTE(_M_pMessage == NULL);
                _M_pMessage = _Msg;

                // Send the message synchronously to the target
                _Status = _PTarget->send(_M_pMessage, this);
            }
                
            if (_Status == postponed)
            {
                // If the target postponed the message, wait for it to
                // be accepted/declined.
                _Wait_for_completion();

                // Procure the final status
                _Status = _M_fStatus;
            }

            // status should not be postponed.
            _ASSERTE(_Status != postponed);
            

            return (_Status == accepted);
        }

    private:

        // Add a target messaging block for this Originator
        virtual void link_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            _M_connectedTargets.add(_PTarget);
            _Invoke_link_source(_PTarget);

            // There should be no pending messages to propagate at this time.
            _ASSERTE(_M_pMessage == NULL);
        }

        // Wait for the status to reach one of the terminal
        // states (!= postponed)
        void _Wait_for_completion()
        {
            // Wait for the event to be signalled
            _M_ev.wait(COOPERATIVE_TIMEOUT_INFINITE);
            _ASSERTE(_M_fStatus != postponed);

        }

        void _Wait_on_ref()
        {
            ::Concurrency::details::_SpinWaitBackoffNone spinWait;
            while(_M_referenceCount != 0)
            {
                spinWait._SpinOnce();
            }
        }

        // Indicate that the send operation has completed
        void _Done(message_status _Status)
        {
            // postponed is not a done state
            _ASSERTE(_Status != postponed);

            _M_fStatus = _Status;
            _M_ev.set();
        }

        // The message that will be propagated by the Originator
        message<_Type> * _M_pMessage;

        // Event to indicate completion
        event _M_ev;

        // Final status of the send
        volatile message_status _M_fStatus;

        // A lock for modifying the buffer or the connected blocks
        ::Concurrency::details::_ReentrantPPLLock _M_internalLock;

        // Connected targets
        _Target_registry _M_connectedTargets;

        volatile long _M_referenceCount;
    };

    // Create a blocking originator on the stack. _send will block until the 
    // message is accepted/rejected.
    _Originator _Orig;
    return _Orig._send(_Trg, _Data);
}


/// <summary>
///     A synchronous send operation, which waits until the target either accepts or declines the message.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool send(ITarget<_Type> &_Trg, const _Type &_Data)
{
    return send(&_Trg, _Data);
}

/// <summary>
///     An asynchronous send operation, which schedules a task to propagate the data to the target block.
/// </summary>
/// <typeparam name="_Type">
///     The type of the data to be sent.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted before the method returned, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/**/
template <class _Type>
bool asend(ITarget<_Type> * _Trg, const _Type& _Data)
{
    // The Originator messaging block class is internal to the send function.
    class _AsyncOriginator : public ISource<_Type>
    {
    public:

        typedef single_link_registry<ITarget<_Type>> _Target_registry;

        // The constructor is private to disallow allocation on the stack.
        static _AsyncOriginator * _create()
        {
            return new _AsyncOriginator;
        }

        // Cleans up any resources that may have been created by the AsyncOriginator.
        virtual ~_AsyncOriginator()
        {
            unlink_targets();

            delete _M_pMessage;
        }

        // Send the given value to the target
        message_status _send(ITarget<_Type> * _PTarget, _Type const & _Value)
        {
            // Keep a refcount so that this object doesn't get deleted if
            // the target decides to unlink before we release our lock
            _Acquire_ref();

            message_status _Status = declined;
            message<_Type> * _Msg = new message<_Type>(_Value);

            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                // link to the target, create a message and send it
                link_target(_PTarget);

                _ASSERTE(_M_pMessage == NULL);
                _M_pMessage = _Msg;

                _Status = _PTarget->propagate(_M_pMessage, this);
            }

            // If the status is anything other than postponed, unlink away
            // from the target and delete the AsyncOriginator.
            if (_Status != postponed)
            {
                unlink_target(_PTarget);
            }

            // Release the reference acquired above
            _Release_ref();

            return _Status;
        }

        // Removes a target messaging block for this AsyncOriginator
        virtual void unlink_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            bool _Unlinked = false;
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                if (_M_connectedTargets.remove(_PTarget))
                {
                    _Invoke_unlink_source(_PTarget);
                    _Unlinked = true;
                }
            }

            // Release the lock before decrementing the refcount. Otherwise, the
            // lock release could corrupt memory.
            if (_Unlinked)
            {
                _Release_ref();
            }
        }

        // Removes the target messaging block from this AsyncOriginator
        virtual void unlink_targets()
        {
            bool _Unlinked = false;
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                for (_Target_registry::iterator _Iter = _M_connectedTargets.begin();
                    *_Iter != NULL;
                    ++_Iter)
                {
                    ITarget<_Type> * _PTarget = *_Iter;
                    if (_M_connectedTargets.remove(_PTarget))
                    {
                        _Invoke_unlink_source(_PTarget);
                        _Unlinked = true;
                    }

                }

                // All targets should be unlinked
                _ASSERTE(_M_connectedTargets.count() == 0);
            }

            // Release the lock before decrementing the refcount. Otherwise, the
            // lock release could corrupt memory.
            if (_Unlinked)
            {
                _Release_ref();
            }
        }

        // Accept on this AsyncOriginator is called by a target to take ownership of a
        // propagated message. This can only be called from propagate.
        virtual message<_Type> * accept(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                return NULL;
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return NULL;
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return NULL;
            }
            
            //
            // If the Id's match, actaully transfer ownership of the message.
            //
            message<_Type> * _Result = _M_pMessage;
            _M_pMessage = NULL;

            return _Result;
        }

        // Reserve needs to be defined for ISource blocks, but AsyncOriginator doesn't need to
        // do anything for reservation since there can only be one target block to read
        // the data at a later time.
        virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return false;
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return false;
            }

            return true;
        }

        // Consume is called by a target messaging block to take ownership of a
        // previously reserved message.
        virtual message<_Type> * consume(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return NULL;
            }

            // The ownership of this message has changed.  Set the internal pointer to NULL
            // so it won't be deleted in the destructor

            message<_Type> * _Result = _M_pMessage;
            _M_pMessage = NULL;

            // We are done. Unlink from the target. DO NOT TOUCH "this" pointer after unlink
            unlink_target(_PTarget);

            return _Result;
        }

        // Release needs to be defined for ISource blocks, but AsyncOriginator doesn't need to
        // do anything for reservation release since there can only be one target block to read
        // the data at a later time.
        virtual void release(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            if ((_M_pMessage == NULL) || (_M_pMessage->msg_id() != _MsgId))
            {
                throw message_not_found();
            }

            // We can be connected to only 1 target. Unlink from the target.
            // DO NOT TOUCH "this" pointer after unlink
            unlink_target(_PTarget);
        }

        virtual void acquire_ref(ITarget<_Type> *)
        {
            _Acquire_ref();
        }

        virtual void release_ref(ITarget<_Type> *)
        {
            _Release_ref();
        }

    private:

        // Create an AsyncOriginator (constructor is private to ensure that
        // it is allocated on the heap).
        _AsyncOriginator() : 
          _M_pMessage(NULL),
          _M_refcount(0)
        {
        }

        // Add a target messaging block for this AsyncOriginator
        virtual void link_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            // Acquire a reference that will be released by unlink_target
            _Acquire_ref();
            _M_connectedTargets.add(_PTarget);
            _Invoke_link_source(_PTarget);

            // There should be no pending messages to propagate at this time.
            _ASSERTE(_M_pMessage == NULL);

        }

        // Acquire a reference on the async originator object
        void _Acquire_ref()
        {
            _InterlockedIncrement(&_M_refcount);
        }

        // Release the reference on the async originator object. The object
        // will be deleted when the reference count goes to 0.
        void _Release_ref()
        {
            _ASSERTE(_M_refcount > 0);
            if (_InterlockedDecrement(&_M_refcount) == 0)
            {
                delete this;
            }
        }

        // The message that will be propagated by the AsyncOriginator
        message<_Type> * _M_pMessage;

        // Reference count to manage object lifetime
        volatile long _M_refcount;

        // The internal lock for this block for its message
        ::Concurrency::details::_ReentrantPPLLock _M_internalLock;

        // connected targets
        _Target_registry _M_connectedTargets;
    };

    _AsyncOriginator * _AsyncOrig = _AsyncOriginator::_create();

    message_status _Status = _AsyncOrig->_send(_Trg, _Data);
    if (_Status != accepted)
    {
        return false;
    }

    return true;
}


/// <summary>
///     An asynchronous send operation, which schedules a task to propagate the value to the target block.
/// </summary>
/// <typeparam name="_Type">
///     The type of the data to be sent.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/**/
template <class _Type>
bool asend(ITarget<_Type> &_Trg, const _Type &_Data)
{
    return asend(&_Trg, _Data);
}
} // namespace Concurrency

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\comdef.h ===
/***
* comdef.h - Native C++ compiler COM support - main definitions header
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_COMDEF)
#define _INC_COMDEF
#if !defined(RC_INVOKED)

#ifndef  __cplusplus
#error Native Compiler support only available in C++ compiler
#endif

#ifdef _M_CEE_PURE
#error comdef.h header cannot be included under /clr:safe or /clr:pure
#endif

#include <ole2.h>
#include <olectl.h>

#include <comutil.h>

#pragma warning(push)
#pragma warning(disable: 4244)
#pragma warning(disable: 4290)

#ifdef _NATIVE_WCHAR_T_DEFINED
# ifdef _DEBUG
# pragma comment(lib, "comsuppwd.lib")
# else
# pragma comment(lib, "comsuppw.lib")
# endif
#else
# ifdef _DEBUG
# pragma comment(lib, "comsuppd.lib")
# else
# pragma comment(lib, "comsupp.lib")
# endif
#endif

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")

class _com_error;

void __declspec(noreturn) __stdcall
    _com_raise_error(HRESULT hr, IErrorInfo* perrinfo = 0) ;

void __stdcall 
    _set_com_error_handler(void (__stdcall *pHandler)(HRESULT hr, IErrorInfo* perrinfo));

void __stdcall
    _com_issue_error(HRESULT) ;
void __stdcall
    _com_issue_errorex(HRESULT, IUnknown*, REFIID) ;

HRESULT __stdcall
    _com_dispatch_propget(IDispatch*, DISPID, VARTYPE, void*) ;
HRESULT __cdecl
    _com_dispatch_propput(IDispatch*, DISPID, VARTYPE, ...) ;
HRESULT __cdecl
    _com_dispatch_method(IDispatch*, DISPID, WORD, VARTYPE, void*,
                         const wchar_t*, ...) ;

HRESULT __stdcall
    _com_dispatch_raw_propget(IDispatch*, DISPID, VARTYPE, void*) throw();
HRESULT __cdecl
    _com_dispatch_raw_propput(IDispatch*, DISPID, VARTYPE, ...) throw();
HRESULT __cdecl
    _com_dispatch_raw_method(IDispatch*, DISPID, WORD, VARTYPE, void*,
                             const wchar_t*, ...) throw();

class _com_error {
public:
    // Constructors
    //
    _com_error(HRESULT hr,
               IErrorInfo* perrinfo = NULL,
               bool fAddRef = false) throw();
    _com_error(const _com_error& that) throw();

    // Destructor
    //
    virtual ~_com_error() throw();

    // Assignment operator
    //
    _com_error& operator=(const _com_error& that) throw();

    // Accessors
    //
    HRESULT Error() const throw();
    WORD WCode() const throw();
    IErrorInfo * ErrorInfo() const throw();

    // IErrorInfo method accessors
    //
    _bstr_t Description() const ;
    DWORD HelpContext() const throw();
    _bstr_t HelpFile() const ;
    _bstr_t Source() const ;
    GUID GUID() const throw();

    // FormatMessage accessors
    //
    const TCHAR * ErrorMessage() const throw();

    // EXCEPINFO.wCode <-> HRESULT mappers
    //
    static HRESULT WCodeToHRESULT(WORD wCode) throw();
    static WORD HRESULTToWCode(HRESULT hr) throw();

private:
    enum {
        WCODE_HRESULT_FIRST = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200),
        WCODE_HRESULT_LAST = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF+1, 0) - 1
    };
    const HRESULT           m_hresult;
    IErrorInfo *            m_perrinfo;
    mutable TCHAR *         m_pszMsg;
};

inline _com_error::_com_error(HRESULT hr,
                              IErrorInfo* perrinfo,
                              bool fAddRef) throw()
    : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)
{
    if (m_perrinfo != NULL && fAddRef) {
        m_perrinfo->AddRef();
    }
}

inline _com_error::_com_error(const _com_error& that) throw()
    : m_hresult(that.m_hresult), m_perrinfo(that.m_perrinfo), m_pszMsg(NULL)
{
    if (m_perrinfo != NULL) {
        m_perrinfo->AddRef();
    }
}

inline _com_error::~_com_error() throw()
{
    if (m_perrinfo != NULL) {
        m_perrinfo->Release();
    }
    if (m_pszMsg != NULL) {
        LocalFree((HLOCAL)m_pszMsg);
    }
}

inline _com_error& _com_error::operator=(const _com_error& that) throw()
{
    if (this != &that) {
        this->_com_error::~_com_error();
        this->_com_error::_com_error(that);
    }
    return *this;
}

inline HRESULT _com_error::Error() const throw()
{
    return m_hresult;
}

inline WORD _com_error::WCode() const throw()
{
    return HRESULTToWCode(m_hresult);
}

inline IErrorInfo * _com_error::ErrorInfo() const throw()
{
    if (m_perrinfo != NULL) {
        m_perrinfo->AddRef();
    }
    return m_perrinfo;
}

inline _bstr_t _com_error::Description() const 
{
    BSTR bstr = NULL;
    if (m_perrinfo != NULL) {
        m_perrinfo->GetDescription(&bstr);
    }
    return _bstr_t(bstr, false);
}

inline DWORD _com_error::HelpContext() const throw()
{
    DWORD dwHelpContext = 0;
    if (m_perrinfo != NULL) {
        m_perrinfo->GetHelpContext(&dwHelpContext);
    }
    return dwHelpContext;
}

inline _bstr_t _com_error::HelpFile() const 
{
    BSTR bstr = NULL;
    if (m_perrinfo != NULL) {
        m_perrinfo->GetHelpFile(&bstr);
    }
    return _bstr_t(bstr, false);
}

inline _bstr_t _com_error::Source() const 
{
    BSTR bstr = NULL;
    if (m_perrinfo != NULL) {
        m_perrinfo->GetSource(&bstr);
    }
    return _bstr_t(bstr, false);
}

inline _GUID _com_error::GUID() const throw()
{
    _GUID guid;
    _COM_MEMCPY_S(&guid, sizeof(_GUID), &__uuidof(NULL), sizeof(_GUID));
    if (m_perrinfo != NULL) {
        m_perrinfo->GetGUID(&guid);
    } 
    return guid;
}

inline const TCHAR * _com_error::ErrorMessage() const throw()
{
    if (m_pszMsg == NULL) {
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|
                          FORMAT_MESSAGE_FROM_SYSTEM|
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      m_hresult,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPTSTR)&m_pszMsg,
                      0,
                      NULL);
        if (m_pszMsg != NULL) {
            int nLen = lstrlen(m_pszMsg);
            if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {
                m_pszMsg[nLen - 1] = 0;
                if (m_pszMsg[nLen - 2] == '\r') {
                        m_pszMsg[nLen - 2] = 0;
                }
            }
        } 
        else {
            m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));
            if (m_pszMsg != NULL) {
                WORD wCode = WCode();
                if (wCode != 0) {
                    _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("IDispatch error #%d"), wCode);
                } 
                else {
                    _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);
                }
            }
        }
    }
    return m_pszMsg;
}

inline HRESULT _com_error::WCodeToHRESULT(WORD wCode) throw()
{
    return wCode >= 0xFE00 ? WCODE_HRESULT_LAST : WCODE_HRESULT_FIRST + wCode;
}

inline WORD _com_error::HRESULTToWCode(HRESULT hr) throw()
{
    return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)
        ? WORD(hr - WCODE_HRESULT_FIRST)
        : 0;
}

//
// give missing types from dependent type libraries a chance
//
typedef int __missing_type__;

#if !defined(_COM_SMARTPTR)
 #if !defined(_INC_COMIP)
  #include <comip.h>
 #endif
 #define _COM_SMARTPTR        _com_ptr_t
 #define _COM_SMARTPTR_LEVEL2 _com_IIID
#endif
#if defined(_COM_SMARTPTR)
 #if !defined(_COM_SMARTPTR_TYPEDEF)
  #if defined(_COM_SMARTPTR_LEVEL2)
   #define _COM_SMARTPTR_TYPEDEF(Interface, IID) \
    typedef _COM_SMARTPTR<_COM_SMARTPTR_LEVEL2<Interface, &IID> > \
            Interface ## Ptr
  #else
   #define _COM_SMARTPTR_TYPEDEF(Interface, IID) \
    typedef _COM_SMARTPTR<Interface, &IID> \
            Interface ## Ptr
  #endif
 #endif
#endif

#if !defined(_COM_NO_STANDARD_GUIDS_)

// hard-coded smart pointer defs
#if defined(__IFontDisp_INTERFACE_DEFINED__)
__if_not_exists(Font)
{
    struct Font : IFontDisp {};
}
_COM_SMARTPTR_TYPEDEF(Font, __uuidof(IDispatch));
#endif
#if defined(__IFontEventsDisp_INTERFACE_DEFINED__)
__if_not_exists(FontEvents)
{
    struct FontEvents : IFontEventsDisp {};
}
_COM_SMARTPTR_TYPEDEF(FontEvents, __uuidof(IDispatch));
#endif
#if defined(__IPictureDisp_INTERFACE_DEFINED__)
__if_not_exists(Picture)
{
    struct Picture : IPictureDisp {};
}
_COM_SMARTPTR_TYPEDEF(Picture, __uuidof(IDispatch));
#endif

#include "comdefsp.h"

#endif  /* _COM_NO_STANDARD_GUIDS_ */

#pragma warning(pop)

#endif /* RC_INVOKED */
#endif  /* _INC_COMDEF */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#pragma once

#include <crtdefs.h>

#ifndef _INC_UTIME
#define _INC_UTIME

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#include <crtdefs.h>

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#pragma pack(push,_CRT_PACKING)

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#if !defined (_W64)
#if !defined (__midl) && (defined (_X86_) || defined (_M_IX86))
#define _W64 __w64
#else  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#define _W64
#endif  /* !defined (__midl) && (defined (_X86_) || defined (_M_IX86)) */
#endif  /* !defined (_W64) */

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif  /* _TIME32_T_DEFINED */

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif  /* _TIME64_T_DEFINED */

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else  /* _USE_32BIT_TIME_T */
typedef __time64_t time_t;      /* time value */
#endif  /* _USE_32BIT_TIME_T */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif  /* _TIME_T_DEFINED */

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

struct __utimbuf32 {
        __time32_t actime;      /* access time */
        __time32_t modtime;     /* modification time */
        };

struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };

#if !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

struct utimbuf32 {
        __time32_t actime;      /* access time */
        __time32_t modtime;     /* modification time */
        };

#endif  /* !__STDC__ */

#define _UTIMBUF_DEFINED
#endif  /* _UTIMBUF_DEFINED */


/* Function Prototypes */

_CRTIMP int __cdecl _utime32(_In_z_ const char * _Filename, _In_opt_ struct __utimbuf32 * _Time);

_CRTIMP int __cdecl _futime32(_In_ int _FileDes, _In_opt_ struct __utimbuf32 * _Time);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime32(_In_z_ const wchar_t * _Filename, _In_opt_ struct __utimbuf32 * _Time);

_CRTIMP int __cdecl _utime64(_In_z_ const char * _Filename, _In_opt_ struct __utimbuf64 * _Time);
_CRTIMP int __cdecl _futime64(_In_ int _FileDes, _In_opt_ struct __utimbuf64 * _Time);
_CRTIMP int __cdecl _wutime64(_In_z_ const wchar_t * _Filename, _In_opt_ struct __utimbuf64 * _Time);

#if !defined (RC_INVOKED) && !defined (__midl)
#include <sys/utime.inl>
#endif  /* !defined (RC_INVOKED) && !defined (__midl) */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#pragma pack(pop)

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\comip.h ===
/***
* comip.h - Native C++ compiler COM support - COM interface pointers header
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef _M_CEE_PURE
#error comip.h header cannot be included under /clr:safe or /clr:pure
#endif

#if !defined(_INC_COMIP)
#define _INC_COMIP

#include <ole2.h>
#include <malloc.h>

#include <comutil.h>

#pragma warning(push)
#pragma warning(disable: 4290)

#pragma push_macro("new")
#undef new

#include <new.h>

class _com_error;

void __stdcall _com_issue_error(HRESULT);
struct __declspec(uuid("00000000-0000-0000-c000-000000000046")) IUnknown;

// Provide Interface to IID association
//
template<typename _Interface, const IID* _IID /*= &__uuidof(_Interface)*/> 
class _com_IIID {
public:
    typedef _Interface Interface;

    static _Interface* GetInterfacePtr() throw()
    {
        return NULL;
    }

    static _Interface& GetInterface() throw()
    {
        return *GetInterfacePtr();
    }

    static const IID& GetIID() throw()
    {
        return *_IID;
    }
};

template<typename _IIID> class _com_ptr_t {
public:
    // Declare interface type so that the type may be available outside
    // the scope of this template.
    //
    typedef _IIID ThisIIID;
    typedef typename _IIID::Interface Interface;

    // When the compiler supports references in template parameters,
    // _CLSID will be changed to a reference.  To avoid conversion
    // difficulties this function should be used to obtain the
    // CLSID.
    //
    static const IID& GetIID() throw()
    { 
        return ThisIIID::GetIID(); 
    }

    // Constructs a smart-pointer from any other smart pointer.
    //
    template<typename _OtherIID> _com_ptr_t(const _com_ptr_t<_OtherIID>& p) 
        : m_pInterface(NULL)
    {
        HRESULT hr = _QueryInterface(p);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }
    }

    // Constructs a smart-pointer from any IUnknown-based interface pointer.
    //
    template<typename _InterfaceType> _com_ptr_t(_InterfaceType* p) 
        : m_pInterface(NULL)
    {
        HRESULT hr = _QueryInterface(p);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }
    }

    // Make sure correct ctor is called
    //
    template<> _com_ptr_t(_In_ LPSTR str) 
    {
        new(this) _com_ptr_t(static_cast<LPCSTR> (str), NULL);
    }

    // Make sure correct ctor is called
    //
    template<> _com_ptr_t(_In_ LPWSTR str) 
    {
        new(this) _com_ptr_t(static_cast<LPCWSTR> (str), NULL);
    }

    // Disable conversion using _com_ptr_t* specialization of
    // template<typename _InterfaceType> _com_ptr_t(_InterfaceType* p)
    //
    template<> explicit _com_ptr_t(_com_ptr_t* p) 
        : m_pInterface(NULL)
    {
        if (p == NULL) {
            _com_issue_error(E_POINTER);
        }
        else {
            m_pInterface = p->m_pInterface;
            AddRef();
        }
    }

    // Default constructor.
    //
    _com_ptr_t() throw()
        : m_pInterface(NULL)
    {
    }

    // This constructor is provided to allow NULL assignment. It will issue
    // an error if any value other than null is assigned to the object.
    //
    _com_ptr_t(int null) 
        : m_pInterface(NULL)
    {
        if (null != 0) {
            _com_issue_error(E_POINTER);
        }
    }

#if defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_COM_PTR_T)

    // This constructor is provided to allow nullptr assignment.
    _com_ptr_t(decltype(__nullptr)) : m_pInterface(NULL) { }

#endif // defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_COM_PTR_T)

    // Copy the pointer and AddRef().
    //
    _com_ptr_t(const _com_ptr_t& cp) throw()
        : m_pInterface(cp.m_pInterface)
    { 
        _AddRef(); 
    }

    // Saves the interface.
    //
    template<> _com_ptr_t(Interface* pInterface) throw()
        : m_pInterface(pInterface)
    { 
        _AddRef(); 
    }

    // Copies the pointer. If fAddRef is TRUE, the interface will
    // be AddRef()ed.
    //
    _com_ptr_t(Interface* pInterface, bool fAddRef) throw()
        : m_pInterface(pInterface)
    {
        if (fAddRef) {
            _AddRef();
        }
    }

    // Construct a pointer for a _variant_t object.
    //
    _com_ptr_t(const _variant_t& varSrc) 
        : m_pInterface(NULL)
    {
        HRESULT hr = QueryStdInterfaces(varSrc);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }
    }

    // Calls CoCreateClass with the provided CLSID.
    //
    explicit _com_ptr_t(const CLSID& clsid, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) 
        : m_pInterface(NULL)
    {
        HRESULT hr = CreateInstance(clsid, pOuter, dwClsContext);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }
    }

    // Calls CoCreateClass with the provided CLSID retrieved from
    // the string.
    //
    explicit _com_ptr_t(LPCWSTR str, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) 
        : m_pInterface(NULL)
    {
        HRESULT hr = CreateInstance(str, pOuter, dwClsContext);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }
    }

    // Calls CoCreateClass with the provided SBCS CLSID retrieved from
    // the string.
    //
    explicit _com_ptr_t(LPCSTR str, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) 
        : m_pInterface(NULL)
    {
        HRESULT hr = CreateInstance(str, pOuter, dwClsContext);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }
    }

    // Queries for interface.
    //
    template<typename _OtherIID> _com_ptr_t& operator=(const _com_ptr_t<_OtherIID>& p) 
    {
        HRESULT hr = _QueryInterface(p);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }

        return *this;
    }

    // Queries for interface.
    //
    template<typename _InterfaceType> _com_ptr_t& operator=(_InterfaceType* p) 
    {
        HRESULT hr = _QueryInterface(p);
    
        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }

        return *this;
    }

    // Saves the interface.
    //
    template<> _com_ptr_t& operator=(Interface* pInterface) throw()
    {
        if (m_pInterface != pInterface) {
            Interface* pOldInterface = m_pInterface;

            m_pInterface = pInterface;

            _AddRef();

            if (pOldInterface != NULL) {
                pOldInterface->Release();
            }
        }

        return *this;
    }

    // Copies and AddRef()'s the interface.
    //
    _com_ptr_t& operator=(const _com_ptr_t& cp) throw()
    { 
        return operator=(cp.m_pInterface); 
    }

    // This operator is provided to permit the assignment of NULL to the class.
    // It will issue an error if any value other than NULL is assigned to it.
    //
    _com_ptr_t& operator=(int null) 
    {
        if (null != 0) {
            _com_issue_error(E_POINTER);
        }

        return operator=(reinterpret_cast<Interface*>(NULL));
    }

    // Construct a pointer for a _variant_t object.
    //
    _com_ptr_t& operator=(const _variant_t& varSrc) 
    {
        HRESULT hr = QueryStdInterfaces(varSrc);

        if (FAILED(hr) && (hr != E_NOINTERFACE)) {
            _com_issue_error(hr);
        }

        return *this;
    }

    // If we still have an interface then Release() it. The interface
    // may be NULL if Detach() has previously been called, or if it was
    // never set.
    //
    ~_com_ptr_t() throw()
    { 
        _Release(); 
    }

    // Saves/sets the interface without AddRef()ing. This call
    // will release any previously acquired interface.
    //
    void Attach(Interface* pInterface) throw()
    {
        _Release();
        m_pInterface = pInterface;
    }

    // Saves/sets the interface only AddRef()ing if fAddRef is TRUE.
    // This call will release any previously acquired interface.
    //
    void Attach(Interface* pInterface, bool fAddRef) throw()
    {
        _Release();
        m_pInterface = pInterface;

        if (fAddRef) {
            if (pInterface == NULL) {
                _com_issue_error(E_POINTER);
            } 
            else {
                pInterface->AddRef();
            }
        }
    }

    // Simply NULL the interface pointer so that it isn't Released()'ed.
    //
    Interface* Detach() throw()
    {
        Interface* const old = m_pInterface;
        m_pInterface = NULL;
        return old;
    }

    // Return the interface. This value may be NULL.
    //
    operator Interface*() const throw()
    { 
        return m_pInterface; 
    }

    // Queries for the unknown and return it
    // Provides minimal level error checking before use.
    //
    operator Interface&() const 
    { 
        if (m_pInterface == NULL) {
            _com_issue_error(E_POINTER);
        }

        return *m_pInterface; 
    }

    // Allows an instance of this class to act as though it were the
    // actual interface. Also provides minimal error checking.
    //
    Interface& operator*() const 
    { 
        if (m_pInterface == NULL) {
            _com_issue_error(E_POINTER);
        }

        return *m_pInterface; 
    }

    // Returns the address of the interface pointer contained in this
    // class. This is useful when using the COM/OLE interfaces to create
    // this interface.
    //
    Interface** operator&() throw()
    {
        _Release();
        m_pInterface = NULL;
        return &m_pInterface;
    }

    // Allows this class to be used as the interface itself.
    // Also provides simple error checking.
    //
    Interface* operator->() const 
    { 
        if (m_pInterface == NULL) {
            _com_issue_error(E_POINTER);
        }

        return m_pInterface; 
    }

    // This operator is provided so that simple boolean expressions will
    // work.  For example: "if (p) ...".
    // Returns TRUE if the pointer is not NULL.
    //
    operator bool() const throw()
    { 
        return m_pInterface != NULL; 
    }

    // Compare two smart pointers
    //
    template<typename _OtherIID> bool operator==(const _com_ptr_t<_OtherIID>& p) const
    {
        return _CompareUnknown(p) == 0;
    }

    // Compare two pointers
    //
    template<typename _InterfaceType> bool operator==(_InterfaceType* p) const
    {
        return _CompareUnknown(p) == 0;
    }

    // Compare with other interface
    //
    template<> bool operator==(Interface* p) const
    {
        return (m_pInterface == p) 
                    ? true
                    : _CompareUnknown(p) == 0;
    }

    // Compare two smart pointers
    //
    template<> bool operator==(const _com_ptr_t& p) const throw()
    {
        return operator==(p.m_pInterface);
    }

    // For comparison to NULL
    //
    bool operator==(int null) const
    {
        if (null != 0) {
            _com_issue_error(E_POINTER);
        }

        return m_pInterface == NULL;
    }

    // Compare two smart pointers
    //
    template<typename _OtherIID> bool operator!=(const _com_ptr_t<_OtherIID>& p) const
    {
        return !(operator==(p));
    }

    // Compare two pointers
    //
    template<typename _InterfaceType> bool operator!=(_InterfaceType* p) const
    {
        return !(operator==(p));
    }

    // For comparison to NULL
    //
    bool operator!=(int null) const
    {
        return !(operator==(null));
    }

    // Compare two smart pointers
    //
    template<typename _OtherIID> bool operator<(const _com_ptr_t<_OtherIID>& p) const
    {
        return _CompareUnknown(p) < 0;
    }

    // Compare two pointers
    //
    template<typename _InterfaceType> bool operator<(_InterfaceType* p) const
    {
        return _CompareUnknown(p) < 0;
    }

    // Compare two smart pointers
    //
    template<typename _OtherIID> bool operator>(const _com_ptr_t<_OtherIID>& p) const
    {
        return _CompareUnknown(p) > 0;
    }

    // Compare two pointers
    //
    template<typename _InterfaceType> bool operator>(_InterfaceType* p) const
    {
        return _CompareUnknown(p) > 0;
    }

    // Compare two smart pointers
    //
    template<typename _OtherIID> bool operator<=(const _com_ptr_t<_OtherIID>& p) const
    {
        return _CompareUnknown(p) <= 0;
    }

    // Compare two pointers
    //
    template<typename _InterfaceType> bool operator<=(_InterfaceType* p) const
    {
        return _CompareUnknown(p) <= 0;
    }

    // Compare two smart pointers
    //
    template<typename _OtherIID> bool operator>=(const _com_ptr_t<_OtherIID>& p) const
    {
        return _CompareUnknown(p) >= 0;
    }

    // Compare two pointers
    //
    template<typename _InterfaceType> bool operator>=(_InterfaceType* p) const
    {
        return _CompareUnknown(p) >= 0;
    }

    // Provides error-checking Release()ing of this interface.
    //
    void Release() 
    {
        if (m_pInterface == NULL) {
            _com_issue_error(E_POINTER);
        }
        else {
            m_pInterface->Release();
            m_pInterface = NULL;
        }
    }

    // Provides error-checking AddRef()ing of this interface.
    //
    void AddRef() 
    { 
        if (m_pInterface == NULL) {
            _com_issue_error(E_POINTER);
        }
        else {
            m_pInterface->AddRef();
        }
    }

    // Another way to get the interface pointer without casting.
    //
    Interface* GetInterfacePtr() const throw()
    { 
        return m_pInterface; 
    }

    // Another way to get the interface pointer without casting.
    // Use for [in, out] parameter passing
    Interface*& GetInterfacePtr() throw()
    { 
        return m_pInterface; 
    }

    // Loads an interface for the provided CLSID.
    // Returns an HRESULT.  Any previous interface is unconditionally released.
    //
    HRESULT CreateInstance(const CLSID& rclsid, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
    {
        HRESULT hr;

        _Release();

        if (dwClsContext & (CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)) {
            IUnknown* pIUnknown;
            hr = CoCreateInstance(rclsid, pOuter, dwClsContext, __uuidof(IUnknown), reinterpret_cast<void**>(&pIUnknown));

            if (SUCCEEDED(hr)) {
                hr = OleRun(pIUnknown);

                if (SUCCEEDED(hr)) {
                    hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));
                }

                pIUnknown->Release();
            }
        }
        else {
            hr = CoCreateInstance(rclsid, pOuter, dwClsContext, GetIID(), reinterpret_cast<void**>(&m_pInterface));
        }

        if (FAILED(hr)) {
            // just in case refcount = 0 and dtor gets called
            m_pInterface = NULL;
        }

        return hr;
    }

    // Creates the class specified by clsidString.  clsidString may
    // contain a class id, or a prog id string.
    //
    HRESULT CreateInstance(LPCWSTR clsidString, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
    {
        if (clsidString == NULL) {
            return E_INVALIDARG;
        }

        CLSID clsid;
        HRESULT hr;

        if (clsidString[0] == L'{') {
            hr = CLSIDFromString(const_cast<LPWSTR> (clsidString), &clsid);
        }
        else {
            hr = CLSIDFromProgID(const_cast<LPWSTR> (clsidString), &clsid);
        }

        if (FAILED(hr)) {
            return hr;
        }

        return CreateInstance(clsid, pOuter, dwClsContext);
    }

    // Creates the class specified by SBCS clsidString.  clsidString may
    // contain a class id, or a prog id string.
    //
    HRESULT CreateInstance(LPCSTR clsidStringA, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
    {
        if (clsidStringA == NULL) {
            return E_INVALIDARG;
        }

        int size = lstrlenA(clsidStringA) + 1;
        int destSize = MultiByteToWideChar(CP_ACP, 0, clsidStringA, size, NULL, 0);

        if (destSize == 0) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        LPWSTR clsidStringW;
        clsidStringW = static_cast<LPWSTR>(_malloca(destSize * sizeof(WCHAR)));

        if (clsidStringW == NULL) {
            return E_OUTOFMEMORY;
        }

        if (MultiByteToWideChar(CP_ACP, 0, clsidStringA, size, clsidStringW, destSize) == 0) {
           _freea(clsidStringW);
           return HRESULT_FROM_WIN32(GetLastError());
        }

        HRESULT hr=CreateInstance(clsidStringW, pOuter, dwClsContext);
        _freea(clsidStringW);
        return hr;
    }

    // Attach to the active object specified by rclsid.
    // Any previous interface is released.
    //
    HRESULT GetActiveObject(const CLSID& rclsid) throw()
    {
        _Release();

        IUnknown* pIUnknown;

        HRESULT hr = ::GetActiveObject(rclsid, NULL, &pIUnknown);

        if (SUCCEEDED(hr)) {
            hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));

            pIUnknown->Release();
        }

        if (FAILED(hr)) {
            // just in case refcount = 0 and dtor gets called
            m_pInterface = NULL;
        }

        return hr;
    }

    // Attach to the active object specified by clsidString.
    // First convert the LPCWSTR to a CLSID.
    //
    HRESULT GetActiveObject(LPCWSTR clsidString) throw()
    {
        if (clsidString == NULL) {
            return E_INVALIDARG;
        }

        CLSID clsid;
        HRESULT hr;

        if (clsidString[0] == '{') {
            hr = CLSIDFromString(const_cast<LPWSTR> (clsidString), &clsid);
        }
        else {
            hr = CLSIDFromProgID(const_cast<LPWSTR> (clsidString), &clsid);
        }

        if (FAILED(hr)) {
            return hr;
        }

        return GetActiveObject(clsid);
    }

    // Attach to the active object specified by clsidStringA.
    // First convert the LPCSTR to a LPCWSTR.
    //
    HRESULT GetActiveObject(LPCSTR clsidStringA) throw()
    {
        if (clsidStringA == NULL) {
            return E_INVALIDARG;
        }

        int size = lstrlenA(clsidStringA) + 1;
        int destSize = MultiByteToWideChar(CP_ACP, 0, clsidStringA, size, NULL, 0);

        LPWSTR clsidStringW;
        __try {
            clsidStringW = static_cast<LPWSTR>(_alloca(destSize * sizeof(WCHAR)));
        }
        __except (1) {
            clsidStringW = NULL;
        }

        if (clsidStringW == NULL) {
            return E_OUTOFMEMORY;
        }

        if (MultiByteToWideChar(CP_ACP, 0, clsidStringA, size, clsidStringW, destSize) == 0) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return GetActiveObject(clsidStringW);
    }

    // Performs the QI for the specified IID and returns it in p.
    // As with all QIs, the interface will be AddRef'd.
    //
    template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType*& p) throw ()
    {
        if (m_pInterface != NULL) {
            return m_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p));
        }

        return E_POINTER;
    }

    // Performs the QI for the specified IID and returns it in p.
    // As with all QIs, the interface will be AddRef'd.
    //
    template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType** p) throw()
    {
        return QueryInterface(iid, *p);
    }

private:
    // The Interface.
    //
    Interface* m_pInterface;

    // Releases only if the interface is not null.
    // The interface is not set to NULL.
    //
    void _Release() throw()
    {
        if (m_pInterface != NULL) {
            m_pInterface->Release();
        }
    }

    // AddRefs only if the interface is not NULL
    //
    void _AddRef() throw()
    {
        if (m_pInterface != NULL) {
            m_pInterface->AddRef();
        }
    }

    // Performs a QI on pUnknown for the interface type returned
    // for this class.  The interface is stored.  If pUnknown is
    // NULL, or the QI fails, E_NOINTERFACE is returned and
    // _pInterface is set to NULL.
    //
    template<typename _InterfacePtr> HRESULT _QueryInterface(_InterfacePtr p) throw()
    {
        HRESULT hr;

        // Can't QI NULL
        //
        if (p != NULL) {
            // Query for this interface
            //
            Interface* pInterface;
            hr = p->QueryInterface(GetIID(), reinterpret_cast<void**>(&pInterface));

            // Save the interface without AddRef()ing.
            //
            Attach(SUCCEEDED(hr)? pInterface: NULL);
        }
        else {
            operator=(static_cast<Interface*>(NULL));
            hr = E_NOINTERFACE;
        }

        return hr;
    }

    // Compares the provided pointer with this by obtaining IUnknown interfaces
    // for each pointer and then returning the difference.
    //
    template<typename _InterfacePtr> int _CompareUnknown(_InterfacePtr p) const
    {
        IUnknown* pu1, *pu2;

        if (m_pInterface != NULL) {
            HRESULT hr = m_pInterface->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(&pu1));

            if (FAILED(hr)) {
                pu1 = NULL;
                _com_issue_error(hr);
            }
            else {
                pu1->Release();
            }
        }
        else {
            pu1 = NULL;
        }

        if (p != NULL) {
            HRESULT hr = p->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(&pu2));

            if (FAILED(hr)) {
                pu2 = NULL;
                _com_issue_error(hr);
            }
            else {
                pu2->Release();
            }
        }
        else {
            pu2 = NULL;
        }

        return pu1 - pu2;
    }

    // Try to extract either IDispatch* or an IUnknown* from
    // the VARIANT
    //
    HRESULT QueryStdInterfaces(const _variant_t& varSrc) throw()
    {
        if (V_VT(&varSrc) == VT_DISPATCH) {
            return _QueryInterface(V_DISPATCH(&varSrc));
        }

        if (V_VT(&varSrc) == VT_UNKNOWN) {
            return _QueryInterface(V_UNKNOWN(&varSrc));
        }

        // We have something other than an IUnknown or an IDispatch.
        // Can we convert it to either one of these?
        // Try IDispatch first
        //
        VARIANT varDest;
        VariantInit(&varDest);

        HRESULT hr = VariantChangeType(&varDest, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc)), 0, VT_DISPATCH);
        if (SUCCEEDED(hr)) {
            hr = _QueryInterface(V_DISPATCH(&varDest));
        }

        if (hr == E_NOINTERFACE) {
            // That failed ... so try IUnknown
            //
            VariantInit(&varDest);
            hr = VariantChangeType(&varDest, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc)), 0, VT_UNKNOWN);
            if (SUCCEEDED(hr)) {
                hr = _QueryInterface(V_UNKNOWN(&varDest));
            }
        }

        VariantClear(&varDest);
        return hr;
    }
};

// Reverse comparison operators for _com_ptr_t
//
template<typename _InterfaceType> bool operator==(int null, const _com_ptr_t<_InterfaceType>& p) 
{
    if (null != 0) {
        _com_issue_error(E_POINTER);
    }

    return p == NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator==(_Interface* i, const _com_ptr_t<_InterfacePtr>& p) 
{
    return p == i;
}

template<typename _Interface> bool operator!=(int null, const _com_ptr_t<_Interface>& p) 
{
    if (null != 0) {
        _com_issue_error(E_POINTER);
    }

    return p != NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator!=(_Interface* i, const _com_ptr_t<_InterfacePtr>& p) 
{
    return p != i;
}

template<typename _Interface> bool operator<(int null, const _com_ptr_t<_Interface>& p) 
{
    if (null != 0) {
        _com_issue_error(E_POINTER);
    }

    return p > NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator<(_Interface* i, const _com_ptr_t<_InterfacePtr>& p) 
{
    return p > i;
}

template<typename _Interface> bool operator>(int null, const _com_ptr_t<_Interface>& p) 
{
    if (null != 0) {
        _com_issue_error(E_POINTER);
    }

    return p < NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator>(_Interface* i, const _com_ptr_t<_InterfacePtr>& p) 
{
    return p < i;
}

template<typename _Interface> bool operator<=(int null, const _com_ptr_t<_Interface>& p) 
{
    if (null != 0) {
        _com_issue_error(E_POINTER);
    }

    return p >= NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator<=(_Interface* i, const _com_ptr_t<_InterfacePtr>& p) 
{
    return p >= i;
}

template<typename _Interface> bool operator>=(int null, const _com_ptr_t<_Interface>& p) 
{
    if (null != 0) {
        _com_issue_error(E_POINTER);
    }

    return p <= NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator>=(_Interface* i, const _com_ptr_t<_InterfacePtr>& p) 
{
    return p <= i;
}

#pragma pop_macro("new")
#pragma warning(pop)

#endif // _INC_COMIP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\comdefsp.h ===
/***
* comdefsp.h - Native C++ compiler COM support - smart pointer support header
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_COMDEFSP)
#define _INC_COMDEFSP
#if !defined(RC_INVOKED)

#ifndef  __cplusplus
#error Native Compiler support only available in C++ compiler
#endif

#ifdef _M_CEE_PURE
#error comdefsp.h header cannot be included under /clr:safe or clr:pure
#endif

#ifndef _COM_SMARTPTR_TYPEDEF
#error comdefsp.h requires comdef.h to be included first
#endif

// interface smart pointer defs
#if defined(__AsyncIAdviseSink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIAdviseSink, __uuidof(AsyncIAdviseSink));
#endif// #if defined(__AsyncIAdviseSink_INTERFACE_DEFINED__)
#if defined(__AsyncIAdviseSink2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIAdviseSink2, __uuidof(AsyncIAdviseSink2));
#endif// #if defined(__AsyncIAdviseSink2_INTERFACE_DEFINED__)
#if defined(__AsyncIMultiQI_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIMultiQI, __uuidof(AsyncIMultiQI));
#endif// #if defined(__AsyncIMultiQI_INTERFACE_DEFINED__)
#if defined(__AsyncIPipeByte_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIPipeByte, __uuidof(AsyncIPipeByte));
#endif// #if defined(__AsyncIPipeByte_INTERFACE_DEFINED__)
#if defined(__AsyncIPipeDouble_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIPipeDouble, __uuidof(AsyncIPipeDouble));
#endif// #if defined(__AsyncIPipeDouble_INTERFACE_DEFINED__)
#if defined(__AsyncIPipeLong_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIPipeLong, __uuidof(AsyncIPipeLong));
#endif// #if defined(__AsyncIPipeLong_INTERFACE_DEFINED__)
#if defined(__AsyncIUnknown_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(AsyncIUnknown, __uuidof(AsyncIUnknown));
#endif// #if defined(__AsyncIUnknown_INTERFACE_DEFINED__)
#if defined(__FolderItem_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(FolderItem, __uuidof(FolderItem));
#endif// #if defined(__FolderItem_INTERFACE_DEFINED__)
#if defined(__FolderItemVerb_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(FolderItemVerb, __uuidof(FolderItemVerb));
#endif// #if defined(__FolderItemVerb_INTERFACE_DEFINED__)
#if defined(__FolderItemVerbs_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(FolderItemVerbs, __uuidof(FolderItemVerbs));
#endif// #if defined(__FolderItemVerbs_INTERFACE_DEFINED__)
#if defined(__FolderItems_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(FolderItems, __uuidof(FolderItems));
#endif// #if defined(__FolderItems_INTERFACE_DEFINED__)
#if defined(__IAccessible_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAccessible, __uuidof(IAccessible));
#endif// #if defined(__IAccessible_INTERFACE_DEFINED__)
#if defined(__IActiveScript_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScript, __uuidof(IActiveScript));
#endif// #if defined(__IActiveScript_INTERFACE_DEFINED__)
#if defined(__IActiveScriptError_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptError, __uuidof(IActiveScriptError));
#endif// #if defined(__IActiveScriptError_INTERFACE_DEFINED__)
#if defined(__IActiveScriptParse_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptParse, __uuidof(IActiveScriptParse));
#endif// #if defined(__IActiveScriptParse_INTERFACE_DEFINED__)
#if defined(__IActiveScriptParseProcedure_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedure, __uuidof(IActiveScriptParseProcedure));
#endif// #if defined(__IActiveScriptParseProcedure_INTERFACE_DEFINED__)
#if defined(__IActiveScriptParseProcedureOld_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedureOld, __uuidof(IActiveScriptParseProcedureOld));
#endif// #if defined(__IActiveScriptParseProcedureOld_INTERFACE_DEFINED__)
#if defined(__IActiveScriptSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptSite, __uuidof(IActiveScriptSite));
#endif// #if defined(__IActiveScriptSite_INTERFACE_DEFINED__)
#if defined(__IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptSiteInterruptPoll, __uuidof(IActiveScriptSiteInterruptPoll));
#endif// #if defined(__IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__)
#if defined(__IActiveScriptSiteWindow_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptSiteWindow, __uuidof(IActiveScriptSiteWindow));
#endif// #if defined(__IActiveScriptSiteWindow_INTERFACE_DEFINED__)
#if defined(__IActiveScriptStats_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IActiveScriptStats, __uuidof(IActiveScriptStats));
#endif// #if defined(__IActiveScriptStats_INTERFACE_DEFINED__)
#if defined(__IAddrExclusionControl_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAddrExclusionControl, __uuidof(IAddrExclusionControl));
#endif// #if defined(__IAddrExclusionControl_INTERFACE_DEFINED__)
#if defined(__IAddrTrackingControl_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAddrTrackingControl, __uuidof(IAddrTrackingControl));
#endif// #if defined(__IAddrTrackingControl_INTERFACE_DEFINED__)
#if defined(__IAdviseSink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAdviseSink, __uuidof(IAdviseSink));
#endif// #if defined(__IAdviseSink_INTERFACE_DEFINED__)
#if defined(__IAdviseSink2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAdviseSink2, __uuidof(IAdviseSink2));
#endif// #if defined(__IAdviseSink2_INTERFACE_DEFINED__)
#if defined(__IAdviseSinkEx_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAdviseSinkEx, __uuidof(IAdviseSinkEx));
#endif// #if defined(__IAdviseSinkEx_INTERFACE_DEFINED__)
#if defined(__IAsyncManager_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAsyncManager, __uuidof(IAsyncManager));
#endif// #if defined(__IAsyncManager_INTERFACE_DEFINED__)
#if defined(__IAsyncRpcChannelBuffer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAsyncRpcChannelBuffer, __uuidof(IAsyncRpcChannelBuffer));
#endif// #if defined(__IAsyncRpcChannelBuffer_INTERFACE_DEFINED__)
#if defined(__IAuthenticate_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IAuthenticate, __uuidof(IAuthenticate));
#endif// #if defined(__IAuthenticate_INTERFACE_DEFINED__)
#if defined(__IBindCtx_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBindCtx, __uuidof(IBindCtx));
#endif// #if defined(__IBindCtx_INTERFACE_DEFINED__)
#if defined(__IBindEventHandler_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBindEventHandler, __uuidof(IBindEventHandler));
#endif// #if defined(__IBindEventHandler_INTERFACE_DEFINED__)
#if defined(__IBindHost_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBindHost, __uuidof(IBindHost));
#endif// #if defined(__IBindHost_INTERFACE_DEFINED__)
#if defined(__IBindProtocol_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBindProtocol, __uuidof(IBindProtocol));
#endif// #if defined(__IBindProtocol_INTERFACE_DEFINED__)
#if defined(__IBindStatusCallback_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBindStatusCallback, __uuidof(IBindStatusCallback));
#endif// #if defined(__IBindStatusCallback_INTERFACE_DEFINED__)
#if defined(__IBinding_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBinding, __uuidof(IBinding));
#endif// #if defined(__IBinding_INTERFACE_DEFINED__)
#if defined(__IBlockingLock_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IBlockingLock, __uuidof(IBlockingLock));
#endif// #if defined(__IBlockingLock_INTERFACE_DEFINED__)
#if defined(__ICSSFilter_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICSSFilter, __uuidof(ICSSFilter));
#endif// #if defined(__ICSSFilter_INTERFACE_DEFINED__)
#if defined(__ICSSFilterSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICSSFilterSite, __uuidof(ICSSFilterSite));
#endif// #if defined(__ICSSFilterSite_INTERFACE_DEFINED__)
#if defined(__ICallFactory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICallFactory, __uuidof(ICallFactory));
#endif// #if defined(__ICallFactory_INTERFACE_DEFINED__)
#if defined(__ICancelMethodCalls_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICancelMethodCalls, __uuidof(ICancelMethodCalls));
#endif// #if defined(__ICancelMethodCalls_INTERFACE_DEFINED__)
#if defined(__ICatInformation_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICatInformation, __uuidof(ICatInformation));
#endif// #if defined(__ICatInformation_INTERFACE_DEFINED__)
#if defined(__ICatRegister_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICatRegister, __uuidof(ICatRegister));
#endif// #if defined(__ICatRegister_INTERFACE_DEFINED__)
#if defined(__ICatalogFileInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICatalogFileInfo, __uuidof(ICatalogFileInfo));
#endif// #if defined(__ICatalogFileInfo_INTERFACE_DEFINED__)
#if defined(__IChannelHook_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IChannelHook, __uuidof(IChannelHook));
#endif// #if defined(__IChannelHook_INTERFACE_DEFINED__)
#if defined(__IChannelMgr_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IChannelMgr, __uuidof(IChannelMgr));
#endif// #if defined(__IChannelMgr_INTERFACE_DEFINED__)
#if defined(__IClassActivator_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IClassActivator, __uuidof(IClassActivator));
#endif// #if defined(__IClassActivator_INTERFACE_DEFINED__)
#if defined(__IClassFactory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IClassFactory, __uuidof(IClassFactory));
#endif// #if defined(__IClassFactory_INTERFACE_DEFINED__)
#if defined(__IClassFactory2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IClassFactory2, __uuidof(IClassFactory2));
#endif// #if defined(__IClassFactory2_INTERFACE_DEFINED__)
#if defined(__IClientSecurity_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IClientSecurity, __uuidof(IClientSecurity));
#endif// #if defined(__IClientSecurity_INTERFACE_DEFINED__)
#if defined(__ICodeInstall_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICodeInstall, __uuidof(ICodeInstall));
#endif// #if defined(__ICodeInstall_INTERFACE_DEFINED__)
#if defined(__IConnectionPoint_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IConnectionPoint, __uuidof(IConnectionPoint));
#endif// #if defined(__IConnectionPoint_INTERFACE_DEFINED__)
#if defined(__IConnectionPointContainer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IConnectionPointContainer, __uuidof(IConnectionPointContainer));
#endif// #if defined(__IConnectionPointContainer_INTERFACE_DEFINED__)
#if defined(__IContinue_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IContinue, __uuidof(IContinue));
#endif// #if defined(__IContinue_INTERFACE_DEFINED__)
#if defined(__IContinueCallback_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IContinueCallback, __uuidof(IContinueCallback));
#endif// #if defined(__IContinueCallback_INTERFACE_DEFINED__)
#if defined(__ICreateErrorInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICreateErrorInfo, __uuidof(ICreateErrorInfo));
#endif// #if defined(__ICreateErrorInfo_INTERFACE_DEFINED__)
#if defined(__ICreateTypeInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICreateTypeInfo, __uuidof(ICreateTypeInfo));
#endif// #if defined(__ICreateTypeInfo_INTERFACE_DEFINED__)
#if defined(__ICreateTypeInfo2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICreateTypeInfo2, __uuidof(ICreateTypeInfo2));
#endif// #if defined(__ICreateTypeInfo2_INTERFACE_DEFINED__)
#if defined(__ICreateTypeLib_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICreateTypeLib, __uuidof(ICreateTypeLib));
#endif// #if defined(__ICreateTypeLib_INTERFACE_DEFINED__)
#if defined(__ICreateTypeLib2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICreateTypeLib2, __uuidof(ICreateTypeLib2));
#endif// #if defined(__ICreateTypeLib2_INTERFACE_DEFINED__)
#if defined(__ICustomDoc_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ICustomDoc, __uuidof(ICustomDoc));
#endif// #if defined(__ICustomDoc_INTERFACE_DEFINED__)
#if defined(__IDataAdviseHolder_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDataAdviseHolder, __uuidof(IDataAdviseHolder));
#endif// #if defined(__IDataAdviseHolder_INTERFACE_DEFINED__)
#if defined(__IDataFilter_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDataFilter, __uuidof(IDataFilter));
#endif// #if defined(__IDataFilter_INTERFACE_DEFINED__)
#if defined(__IDataObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDataObject, __uuidof(IDataObject));
#endif// #if defined(__IDataObject_INTERFACE_DEFINED__)
#if defined(__IDeskBand_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDeskBand, __uuidof(IDeskBand));
#endif// #if defined(__IDeskBand_INTERFACE_DEFINED__)
#if defined(__IDirectWriterLock_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDirectWriterLock, __uuidof(IDirectWriterLock));
#endif// #if defined(__IDirectWriterLock_INTERFACE_DEFINED__)
#if defined(__IDispError_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDispError, __uuidof(IDispError));
#endif// #if defined(__IDispError_INTERFACE_DEFINED__)
#if defined(__IDispatch_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDispatch, __uuidof(IDispatch));
#endif// #if defined(__IDispatch_INTERFACE_DEFINED__)
#if defined(__IDispatchEx_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDispatchEx, __uuidof(IDispatchEx));
#endif// #if defined(__IDispatchEx_INTERFACE_DEFINED__)
#if defined(__IDocHostShowUI_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDocHostShowUI, __uuidof(IDocHostShowUI));
#endif// #if defined(__IDocHostShowUI_INTERFACE_DEFINED__)
#if defined(__IDocHostUIHandler_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDocHostUIHandler, __uuidof(IDocHostUIHandler));
#endif// #if defined(__IDocHostUIHandler_INTERFACE_DEFINED__)
#if defined(__IDockingWindow_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDockingWindow, __uuidof(IDockingWindow));
#endif// #if defined(__IDockingWindow_INTERFACE_DEFINED__)
#if defined(__IDropSource_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDropSource, __uuidof(IDropSource));
#endif// #if defined(__IDropSource_INTERFACE_DEFINED__)
#if defined(__IDropTarget_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDropTarget, __uuidof(IDropTarget));
#endif// #if defined(__IDropTarget_INTERFACE_DEFINED__)
#if defined(__IDummyHICONIncluder_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IDummyHICONIncluder, __uuidof(IDummyHICONIncluder));
#endif// #if defined(__IDummyHICONIncluder_INTERFACE_DEFINED__)
#if defined(__IEncodingFilterFactory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEncodingFilterFactory, __uuidof(IEncodingFilterFactory));
#endif// #if defined(__IEncodingFilterFactory_INTERFACE_DEFINED__)
#if defined(__IEnumCATEGORYINFO_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumCATEGORYINFO, __uuidof(IEnumCATEGORYINFO));
#endif// #if defined(__IEnumCATEGORYINFO_INTERFACE_DEFINED__)
#if defined(__IEnumChannels_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumChannels, __uuidof(IEnumChannels));
#endif// #if defined(__IEnumChannels_INTERFACE_DEFINED__)
#if defined(__IEnumCodePage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumCodePage, __uuidof(IEnumCodePage));
#endif// #if defined(__IEnumCodePage_INTERFACE_DEFINED__)
#if defined(__IEnumConnectionPoints_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumConnectionPoints, __uuidof(IEnumConnectionPoints));
#endif// #if defined(__IEnumConnectionPoints_INTERFACE_DEFINED__)
#if defined(__IEnumConnections_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumConnections, __uuidof(IEnumConnections));
#endif// #if defined(__IEnumConnections_INTERFACE_DEFINED__)
#if defined(__IEnumFORMATETC_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumFORMATETC, __uuidof(IEnumFORMATETC));
#endif// #if defined(__IEnumFORMATETC_INTERFACE_DEFINED__)
#if defined(__IEnumGUID_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumGUID, __uuidof(IEnumGUID));
#endif// #if defined(__IEnumGUID_INTERFACE_DEFINED__)
#if defined(__IEnumHLITEM_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumHLITEM, __uuidof(IEnumHLITEM));
#endif// #if defined(__IEnumHLITEM_INTERFACE_DEFINED__)
#if defined(__IEnumIDList_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumIDList, __uuidof(IEnumIDList));
#endif// #if defined(__IEnumIDList_INTERFACE_DEFINED__)
#if defined(__IEnumMoniker_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumMoniker, __uuidof(IEnumMoniker));
#endif// #if defined(__IEnumMoniker_INTERFACE_DEFINED__)
#if defined(__IEnumOLEVERB_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumOLEVERB, __uuidof(IEnumOLEVERB));
#endif// #if defined(__IEnumOLEVERB_INTERFACE_DEFINED__)
#if defined(__IEnumOleDocumentViews_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumOleDocumentViews, __uuidof(IEnumOleDocumentViews));
#endif// #if defined(__IEnumOleDocumentViews_INTERFACE_DEFINED__)
#if defined(__IEnumOleUndoUnits_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumOleUndoUnits, __uuidof(IEnumOleUndoUnits));
#endif// #if defined(__IEnumOleUndoUnits_INTERFACE_DEFINED__)
#if defined(__IEnumRfc1766_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumRfc1766, __uuidof(IEnumRfc1766));
#endif// #if defined(__IEnumRfc1766_INTERFACE_DEFINED__)
#if defined(__IEnumSTATDATA_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumSTATDATA, __uuidof(IEnumSTATDATA));
#endif// #if defined(__IEnumSTATDATA_INTERFACE_DEFINED__)
#if defined(__IEnumSTATPROPSETSTG_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumSTATPROPSETSTG, __uuidof(IEnumSTATPROPSETSTG));
#endif// #if defined(__IEnumSTATPROPSETSTG_INTERFACE_DEFINED__)
#if defined(__IEnumSTATPROPSTG_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumSTATPROPSTG, __uuidof(IEnumSTATPROPSTG));
#endif// #if defined(__IEnumSTATPROPSTG_INTERFACE_DEFINED__)
#if defined(__IEnumSTATSTG_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumSTATSTG, __uuidof(IEnumSTATSTG));
#endif// #if defined(__IEnumSTATSTG_INTERFACE_DEFINED__)
#if defined(__IEnumSTATURL_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumSTATURL, __uuidof(IEnumSTATURL));
#endif// #if defined(__IEnumSTATURL_INTERFACE_DEFINED__)
#if defined(__IEnumString_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumString, __uuidof(IEnumString));
#endif// #if defined(__IEnumString_INTERFACE_DEFINED__)
#if defined(__IEnumUnknown_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumUnknown, __uuidof(IEnumUnknown));
#endif// #if defined(__IEnumUnknown_INTERFACE_DEFINED__)
#if defined(__IEnumVARIANT_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IEnumVARIANT, __uuidof(IEnumVARIANT));
#endif// #if defined(__IEnumVARIANT_INTERFACE_DEFINED__)
#if defined(__IErrorInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IErrorInfo, __uuidof(IErrorInfo));
#endif// #if defined(__IErrorInfo_INTERFACE_DEFINED__)
#if defined(__IErrorLog_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IErrorLog, __uuidof(IErrorLog));
#endif// #if defined(__IErrorLog_INTERFACE_DEFINED__)
#if defined(__IExtensionServices_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IExtensionServices, __uuidof(IExtensionServices));
#endif// #if defined(__IExtensionServices_INTERFACE_DEFINED__)
#if defined(__IExternalConnection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IExternalConnection, __uuidof(IExternalConnection));
#endif// #if defined(__IExternalConnection_INTERFACE_DEFINED__)
#if defined(__IFillLockBytes_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IFillLockBytes, __uuidof(IFillLockBytes));
#endif// #if defined(__IFillLockBytes_INTERFACE_DEFINED__)
#if defined(__IFilter_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IFilter, __uuidof(IFilter));
#endif// #if defined(__IFilter_INTERFACE_DEFINED__)
#if defined(__IFolderViewOC_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IFolderViewOC, __uuidof(IFolderViewOC));
#endif// #if defined(__IFolderViewOC_INTERFACE_DEFINED__)
#if defined(__IFont_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IFont, __uuidof(IFont));
#endif// #if defined(__IFont_INTERFACE_DEFINED__)
#if defined(__IFontDisp_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IFontDisp, __uuidof(IFontDisp));
#endif// #if defined(__IFontDisp_INTERFACE_DEFINED__)
#if defined(__IFontEventsDisp_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IFontEventsDisp, __uuidof(IFontEventsDisp));
#endif// #if defined(__IFontEventsDisp_INTERFACE_DEFINED__)
#if defined(__IForegroundTransfer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IForegroundTransfer, __uuidof(IForegroundTransfer));
#endif// #if defined(__IForegroundTransfer_INTERFACE_DEFINED__)
#if defined(__IGlobalInterfaceTable_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IGlobalInterfaceTable, __uuidof(IGlobalInterfaceTable));
#endif// #if defined(__IGlobalInterfaceTable_INTERFACE_DEFINED__)
#if defined(__IHTMLAnchorElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLAnchorElement, __uuidof(IHTMLAnchorElement));
#endif// #if defined(__IHTMLAnchorElement_INTERFACE_DEFINED__)
#if defined(__IHTMLAreaElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLAreaElement, __uuidof(IHTMLAreaElement));
#endif// #if defined(__IHTMLAreaElement_INTERFACE_DEFINED__)
#if defined(__IHTMLAreasCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLAreasCollection, __uuidof(IHTMLAreasCollection));
#endif// #if defined(__IHTMLAreasCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLBGsound_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLBGsound, __uuidof(IHTMLBGsound));
#endif// #if defined(__IHTMLBGsound_INTERFACE_DEFINED__)
#if defined(__IHTMLBRElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLBRElement, __uuidof(IHTMLBRElement));
#endif// #if defined(__IHTMLBRElement_INTERFACE_DEFINED__)
#if defined(__IHTMLBaseElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLBaseElement, __uuidof(IHTMLBaseElement));
#endif// #if defined(__IHTMLBaseElement_INTERFACE_DEFINED__)
#if defined(__IHTMLBaseFontElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLBaseFontElement, __uuidof(IHTMLBaseFontElement));
#endif// #if defined(__IHTMLBaseFontElement_INTERFACE_DEFINED__)
#if defined(__IHTMLBlockElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLBlockElement, __uuidof(IHTMLBlockElement));
#endif// #if defined(__IHTMLBlockElement_INTERFACE_DEFINED__)
#if defined(__IHTMLBodyElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLBodyElement, __uuidof(IHTMLBodyElement));
#endif// #if defined(__IHTMLBodyElement_INTERFACE_DEFINED__)
#if defined(__IHTMLButtonElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLButtonElement, __uuidof(IHTMLButtonElement));
#endif// #if defined(__IHTMLButtonElement_INTERFACE_DEFINED__)
#if defined(__IHTMLCommentElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLCommentElement, __uuidof(IHTMLCommentElement));
#endif// #if defined(__IHTMLCommentElement_INTERFACE_DEFINED__)
#if defined(__IHTMLControlElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLControlElement, __uuidof(IHTMLControlElement));
#endif// #if defined(__IHTMLControlElement_INTERFACE_DEFINED__)
#if defined(__IHTMLControlRange_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLControlRange, __uuidof(IHTMLControlRange));
#endif// #if defined(__IHTMLControlRange_INTERFACE_DEFINED__)
#if defined(__IHTMLDDElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDDElement, __uuidof(IHTMLDDElement));
#endif// #if defined(__IHTMLDDElement_INTERFACE_DEFINED__)
#if defined(__IHTMLDListElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDListElement, __uuidof(IHTMLDListElement));
#endif// #if defined(__IHTMLDListElement_INTERFACE_DEFINED__)
#if defined(__IHTMLDTElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDTElement, __uuidof(IHTMLDTElement));
#endif// #if defined(__IHTMLDTElement_INTERFACE_DEFINED__)
#if defined(__IHTMLDatabinding_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDatabinding, __uuidof(IHTMLDatabinding));
#endif// #if defined(__IHTMLDatabinding_INTERFACE_DEFINED__)
#if defined(__IHTMLDialog_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDialog, __uuidof(IHTMLDialog));
#endif// #if defined(__IHTMLDialog_INTERFACE_DEFINED__)
#if defined(__IHTMLDivElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDivElement, __uuidof(IHTMLDivElement));
#endif// #if defined(__IHTMLDivElement_INTERFACE_DEFINED__)
#if defined(__IHTMLDivPosition_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDivPosition, __uuidof(IHTMLDivPosition));
#endif// #if defined(__IHTMLDivPosition_INTERFACE_DEFINED__)
#if defined(__IHTMLDocument_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDocument, __uuidof(IHTMLDocument));
#endif// #if defined(__IHTMLDocument_INTERFACE_DEFINED__)
#if defined(__IHTMLDocument2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLDocument2, __uuidof(IHTMLDocument2));
#endif// #if defined(__IHTMLDocument2_INTERFACE_DEFINED__)
#if defined(__IHTMLElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLElement, __uuidof(IHTMLElement));
#endif// #if defined(__IHTMLElement_INTERFACE_DEFINED__)
#if defined(__IHTMLElementCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLElementCollection, __uuidof(IHTMLElementCollection));
#endif// #if defined(__IHTMLElementCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLEmbedElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLEmbedElement, __uuidof(IHTMLEmbedElement));
#endif// #if defined(__IHTMLEmbedElement_INTERFACE_DEFINED__)
#if defined(__IHTMLEventObj_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLEventObj, __uuidof(IHTMLEventObj));
#endif// #if defined(__IHTMLEventObj_INTERFACE_DEFINED__)
#if defined(__IHTMLFieldSetElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFieldSetElement, __uuidof(IHTMLFieldSetElement));
#endif// #if defined(__IHTMLFieldSetElement_INTERFACE_DEFINED__)
#if defined(__IHTMLFiltersCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFiltersCollection, __uuidof(IHTMLFiltersCollection));
#endif// #if defined(__IHTMLFiltersCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLFontElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFontElement, __uuidof(IHTMLFontElement));
#endif// #if defined(__IHTMLFontElement_INTERFACE_DEFINED__)
#if defined(__IHTMLFontNamesCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFontNamesCollection, __uuidof(IHTMLFontNamesCollection));
#endif// #if defined(__IHTMLFontNamesCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLFontSizesCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFontSizesCollection, __uuidof(IHTMLFontSizesCollection));
#endif// #if defined(__IHTMLFontSizesCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLFormElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFormElement, __uuidof(IHTMLFormElement));
#endif// #if defined(__IHTMLFormElement_INTERFACE_DEFINED__)
#if defined(__IHTMLFrameBase_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFrameBase, __uuidof(IHTMLFrameBase));
#endif// #if defined(__IHTMLFrameBase_INTERFACE_DEFINED__)
#if defined(__IHTMLFrameElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFrameElement, __uuidof(IHTMLFrameElement));
#endif// #if defined(__IHTMLFrameElement_INTERFACE_DEFINED__)
#if defined(__IHTMLFrameSetElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFrameSetElement, __uuidof(IHTMLFrameSetElement));
#endif// #if defined(__IHTMLFrameSetElement_INTERFACE_DEFINED__)
#if defined(__IHTMLFramesCollection2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLFramesCollection2, __uuidof(IHTMLFramesCollection2));
#endif// #if defined(__IHTMLFramesCollection2_INTERFACE_DEFINED__)
#if defined(__IHTMLHRElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLHRElement, __uuidof(IHTMLHRElement));
#endif// #if defined(__IHTMLHRElement_INTERFACE_DEFINED__)
#if defined(__IHTMLHeaderElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLHeaderElement, __uuidof(IHTMLHeaderElement));
#endif// #if defined(__IHTMLHeaderElement_INTERFACE_DEFINED__)
#if defined(__IHTMLIFrameElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLIFrameElement, __uuidof(IHTMLIFrameElement));
#endif// #if defined(__IHTMLIFrameElement_INTERFACE_DEFINED__)
#if defined(__IHTMLImageElementFactory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLImageElementFactory, __uuidof(IHTMLImageElementFactory));
#endif// #if defined(__IHTMLImageElementFactory_INTERFACE_DEFINED__)
#if defined(__IHTMLImgElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLImgElement, __uuidof(IHTMLImgElement));
#endif// #if defined(__IHTMLImgElement_INTERFACE_DEFINED__)
#if defined(__IHTMLInputButtonElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLInputButtonElement, __uuidof(IHTMLInputButtonElement));
#endif// #if defined(__IHTMLInputButtonElement_INTERFACE_DEFINED__)
#if defined(__IHTMLInputFileElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLInputFileElement, __uuidof(IHTMLInputFileElement));
#endif// #if defined(__IHTMLInputFileElement_INTERFACE_DEFINED__)
#if defined(__IHTMLInputHiddenElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLInputHiddenElement, __uuidof(IHTMLInputHiddenElement));
#endif// #if defined(__IHTMLInputHiddenElement_INTERFACE_DEFINED__)
#if defined(__IHTMLInputImage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLInputImage, __uuidof(IHTMLInputImage));
#endif// #if defined(__IHTMLInputImage_INTERFACE_DEFINED__)
#if defined(__IHTMLInputTextElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLInputTextElement, __uuidof(IHTMLInputTextElement));
#endif// #if defined(__IHTMLInputTextElement_INTERFACE_DEFINED__)
#if defined(__IHTMLIsIndexElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLIsIndexElement, __uuidof(IHTMLIsIndexElement));
#endif// #if defined(__IHTMLIsIndexElement_INTERFACE_DEFINED__)
#if defined(__IHTMLLIElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLLIElement, __uuidof(IHTMLLIElement));
#endif// #if defined(__IHTMLLIElement_INTERFACE_DEFINED__)
#if defined(__IHTMLLabelElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLLabelElement, __uuidof(IHTMLLabelElement));
#endif// #if defined(__IHTMLLabelElement_INTERFACE_DEFINED__)
#if defined(__IHTMLLegendElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLLegendElement, __uuidof(IHTMLLegendElement));
#endif// #if defined(__IHTMLLegendElement_INTERFACE_DEFINED__)
#if defined(__IHTMLLinkElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLLinkElement, __uuidof(IHTMLLinkElement));
#endif// #if defined(__IHTMLLinkElement_INTERFACE_DEFINED__)
#if defined(__IHTMLListElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLListElement, __uuidof(IHTMLListElement));
#endif// #if defined(__IHTMLListElement_INTERFACE_DEFINED__)
#if defined(__IHTMLLocation_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLLocation, __uuidof(IHTMLLocation));
#endif// #if defined(__IHTMLLocation_INTERFACE_DEFINED__)
#if defined(__IHTMLMapElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLMapElement, __uuidof(IHTMLMapElement));
#endif// #if defined(__IHTMLMapElement_INTERFACE_DEFINED__)
#if defined(__IHTMLMarqueeElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLMarqueeElement, __uuidof(IHTMLMarqueeElement));
#endif// #if defined(__IHTMLMarqueeElement_INTERFACE_DEFINED__)
#if defined(__IHTMLMetaElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLMetaElement, __uuidof(IHTMLMetaElement));
#endif// #if defined(__IHTMLMetaElement_INTERFACE_DEFINED__)
#if defined(__IHTMLMimeTypesCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLMimeTypesCollection, __uuidof(IHTMLMimeTypesCollection));
#endif// #if defined(__IHTMLMimeTypesCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLNextIdElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLNextIdElement, __uuidof(IHTMLNextIdElement));
#endif// #if defined(__IHTMLNextIdElement_INTERFACE_DEFINED__)
#if defined(__IHTMLNoShowElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLNoShowElement, __uuidof(IHTMLNoShowElement));
#endif// #if defined(__IHTMLNoShowElement_INTERFACE_DEFINED__)
#if defined(__IHTMLOListElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLOListElement, __uuidof(IHTMLOListElement));
#endif// #if defined(__IHTMLOListElement_INTERFACE_DEFINED__)
#if defined(__IHTMLObjectElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLObjectElement, __uuidof(IHTMLObjectElement));
#endif// #if defined(__IHTMLObjectElement_INTERFACE_DEFINED__)
#if defined(__IHTMLOpsProfile_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLOpsProfile, __uuidof(IHTMLOpsProfile));
#endif// #if defined(__IHTMLOpsProfile_INTERFACE_DEFINED__)
#if defined(__IHTMLOptionButtonElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLOptionButtonElement, __uuidof(IHTMLOptionButtonElement));
#endif// #if defined(__IHTMLOptionButtonElement_INTERFACE_DEFINED__)
#if defined(__IHTMLOptionElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLOptionElement, __uuidof(IHTMLOptionElement));
#endif// #if defined(__IHTMLOptionElement_INTERFACE_DEFINED__)
#if defined(__IHTMLOptionElementFactory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLOptionElementFactory, __uuidof(IHTMLOptionElementFactory));
#endif// #if defined(__IHTMLOptionElementFactory_INTERFACE_DEFINED__)
#if defined(__IHTMLOptionsHolder_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLOptionsHolder, __uuidof(IHTMLOptionsHolder));
#endif// #if defined(__IHTMLOptionsHolder_INTERFACE_DEFINED__)
#if defined(__IHTMLParaElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLParaElement, __uuidof(IHTMLParaElement));
#endif// #if defined(__IHTMLParaElement_INTERFACE_DEFINED__)
#if defined(__IHTMLPhraseElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLPhraseElement, __uuidof(IHTMLPhraseElement));
#endif// #if defined(__IHTMLPhraseElement_INTERFACE_DEFINED__)
#if defined(__IHTMLPluginsCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLPluginsCollection, __uuidof(IHTMLPluginsCollection));
#endif// #if defined(__IHTMLPluginsCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLRuleStyle_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLRuleStyle, __uuidof(IHTMLRuleStyle));
#endif// #if defined(__IHTMLRuleStyle_INTERFACE_DEFINED__)
#if defined(__IHTMLScreen_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLScreen, __uuidof(IHTMLScreen));
#endif// #if defined(__IHTMLScreen_INTERFACE_DEFINED__)
#if defined(__IHTMLScriptElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLScriptElement, __uuidof(IHTMLScriptElement));
#endif// #if defined(__IHTMLScriptElement_INTERFACE_DEFINED__)
#if defined(__IHTMLSelectElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLSelectElement, __uuidof(IHTMLSelectElement));
#endif// #if defined(__IHTMLSelectElement_INTERFACE_DEFINED__)
#if defined(__IHTMLSelectionObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLSelectionObject, __uuidof(IHTMLSelectionObject));
#endif// #if defined(__IHTMLSelectionObject_INTERFACE_DEFINED__)
#if defined(__IHTMLSpanElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLSpanElement, __uuidof(IHTMLSpanElement));
#endif// #if defined(__IHTMLSpanElement_INTERFACE_DEFINED__)
#if defined(__IHTMLSpanFlow_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLSpanFlow, __uuidof(IHTMLSpanFlow));
#endif// #if defined(__IHTMLSpanFlow_INTERFACE_DEFINED__)
#if defined(__IHTMLStyle_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyle, __uuidof(IHTMLStyle));
#endif// #if defined(__IHTMLStyle_INTERFACE_DEFINED__)
#if defined(__IHTMLStyleElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyleElement, __uuidof(IHTMLStyleElement));
#endif// #if defined(__IHTMLStyleElement_INTERFACE_DEFINED__)
#if defined(__IHTMLStyleFontFace_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyleFontFace, __uuidof(IHTMLStyleFontFace));
#endif// #if defined(__IHTMLStyleFontFace_INTERFACE_DEFINED__)
#if defined(__IHTMLStyleSheet_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheet, __uuidof(IHTMLStyleSheet));
#endif// #if defined(__IHTMLStyleSheet_INTERFACE_DEFINED__)
#if defined(__IHTMLStyleSheetRule_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetRule, __uuidof(IHTMLStyleSheetRule));
#endif// #if defined(__IHTMLStyleSheetRule_INTERFACE_DEFINED__)
#if defined(__IHTMLStyleSheetRulesCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetRulesCollection, __uuidof(IHTMLStyleSheetRulesCollection));
#endif// #if defined(__IHTMLStyleSheetRulesCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLStyleSheetsCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetsCollection, __uuidof(IHTMLStyleSheetsCollection));
#endif// #if defined(__IHTMLStyleSheetsCollection_INTERFACE_DEFINED__)
#if defined(__IHTMLTable_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTable, __uuidof(IHTMLTable));
#endif// #if defined(__IHTMLTable_INTERFACE_DEFINED__)
#if defined(__IHTMLTableCaption_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTableCaption, __uuidof(IHTMLTableCaption));
#endif// #if defined(__IHTMLTableCaption_INTERFACE_DEFINED__)
#if defined(__IHTMLTableCell_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTableCell, __uuidof(IHTMLTableCell));
#endif// #if defined(__IHTMLTableCell_INTERFACE_DEFINED__)
#if defined(__IHTMLTableCol_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTableCol, __uuidof(IHTMLTableCol));
#endif// #if defined(__IHTMLTableCol_INTERFACE_DEFINED__)
#if defined(__IHTMLTableRow_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTableRow, __uuidof(IHTMLTableRow));
#endif// #if defined(__IHTMLTableRow_INTERFACE_DEFINED__)
#if defined(__IHTMLTableSection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTableSection, __uuidof(IHTMLTableSection));
#endif// #if defined(__IHTMLTableSection_INTERFACE_DEFINED__)
#if defined(__IHTMLTextAreaElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTextAreaElement, __uuidof(IHTMLTextAreaElement));
#endif// #if defined(__IHTMLTextAreaElement_INTERFACE_DEFINED__)
#if defined(__IHTMLTextContainer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTextContainer, __uuidof(IHTMLTextContainer));
#endif// #if defined(__IHTMLTextContainer_INTERFACE_DEFINED__)
#if defined(__IHTMLTextElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTextElement, __uuidof(IHTMLTextElement));
#endif// #if defined(__IHTMLTextElement_INTERFACE_DEFINED__)
#if defined(__IHTMLTitleElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTitleElement, __uuidof(IHTMLTitleElement));
#endif// #if defined(__IHTMLTitleElement_INTERFACE_DEFINED__)
#if defined(__IHTMLTxtRange_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLTxtRange, __uuidof(IHTMLTxtRange));
#endif// #if defined(__IHTMLTxtRange_INTERFACE_DEFINED__)
#if defined(__IHTMLUListElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLUListElement, __uuidof(IHTMLUListElement));
#endif// #if defined(__IHTMLUListElement_INTERFACE_DEFINED__)
#if defined(__IHTMLUnknownElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLUnknownElement, __uuidof(IHTMLUnknownElement));
#endif// #if defined(__IHTMLUnknownElement_INTERFACE_DEFINED__)
#if defined(__IHTMLWindow2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHTMLWindow2, __uuidof(IHTMLWindow2));
#endif// #if defined(__IHTMLWindow2_INTERFACE_DEFINED__)
#if defined(__IHlink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHlink, __uuidof(IHlink));
#endif// #if defined(__IHlink_INTERFACE_DEFINED__)
#if defined(__IHlinkBrowseContext_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHlinkBrowseContext, __uuidof(IHlinkBrowseContext));
#endif// #if defined(__IHlinkBrowseContext_INTERFACE_DEFINED__)
#if defined(__IHlinkFrame_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHlinkFrame, __uuidof(IHlinkFrame));
#endif// #if defined(__IHlinkFrame_INTERFACE_DEFINED__)
#if defined(__IHlinkSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHlinkSite, __uuidof(IHlinkSite));
#endif// #if defined(__IHlinkSite_INTERFACE_DEFINED__)
#if defined(__IHlinkTarget_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHlinkTarget, __uuidof(IHlinkTarget));
#endif// #if defined(__IHlinkTarget_INTERFACE_DEFINED__)
#if defined(__IHttpNegotiate_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHttpNegotiate, __uuidof(IHttpNegotiate));
#endif// #if defined(__IHttpNegotiate_INTERFACE_DEFINED__)
#if defined(__IHttpNegotiate2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHttpNegotiate2, __uuidof(IHttpNegotiate2));
#endif// #if defined(__IHttpNegotiate2_INTERFACE_DEFINED__)
#if defined(__IHttpSecurity_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IHttpSecurity, __uuidof(IHttpSecurity));
#endif// #if defined(__IHttpSecurity_INTERFACE_DEFINED__)
#if defined(__IImageDecodeEventSink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IImageDecodeEventSink, __uuidof(IImageDecodeEventSink));
#endif// #if defined(__IImageDecodeEventSink_INTERFACE_DEFINED__)
#if defined(__IImageDecodeFilter_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IImageDecodeFilter, __uuidof(IImageDecodeFilter));
#endif// #if defined(__IImageDecodeFilter_INTERFACE_DEFINED__)
#if defined(__IInternalUnknown_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternalUnknown, __uuidof(IInternalUnknown));
#endif// #if defined(__IInternalUnknown_INTERFACE_DEFINED__)
#if defined(__IInternet_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternet, __uuidof(IInternet));
#endif// #if defined(__IInternet_INTERFACE_DEFINED__)
#if defined(__IInternetBindInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetBindInfo, __uuidof(IInternetBindInfo));
#endif// #if defined(__IInternetBindInfo_INTERFACE_DEFINED__)
#if defined(__IInternetHostSecurityManager_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetHostSecurityManager, __uuidof(IInternetHostSecurityManager));
#endif// #if defined(__IInternetHostSecurityManager_INTERFACE_DEFINED__)
#if defined(__IInternetPriority_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetPriority, __uuidof(IInternetPriority));
#endif// #if defined(__IInternetPriority_INTERFACE_DEFINED__)
#if defined(__IInternetProtocol_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetProtocol, __uuidof(IInternetProtocol));
#endif// #if defined(__IInternetProtocol_INTERFACE_DEFINED__)
#if defined(__IInternetProtocolInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetProtocolInfo, __uuidof(IInternetProtocolInfo));
#endif// #if defined(__IInternetProtocolInfo_INTERFACE_DEFINED__)
#if defined(__IInternetProtocolRoot_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetProtocolRoot, __uuidof(IInternetProtocolRoot));
#endif// #if defined(__IInternetProtocolRoot_INTERFACE_DEFINED__)
#if defined(__IInternetProtocolSink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetProtocolSink, __uuidof(IInternetProtocolSink));
#endif// #if defined(__IInternetProtocolSink_INTERFACE_DEFINED__)
#if defined(__IInternetProtocolSinkStackable_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetProtocolSinkStackable, __uuidof(IInternetProtocolSinkStackable));
#endif// #if defined(__IInternetProtocolSinkStackable_INTERFACE_DEFINED__)
#if defined(__IInternetSecurityManager_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetSecurityManager, __uuidof(IInternetSecurityManager));
#endif// #if defined(__IInternetSecurityManager_INTERFACE_DEFINED__)
#if defined(__IInternetSecurityMgrSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetSecurityMgrSite, __uuidof(IInternetSecurityMgrSite));
#endif// #if defined(__IInternetSecurityMgrSite_INTERFACE_DEFINED__)
#if defined(__IInternetSession_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetSession, __uuidof(IInternetSession));
#endif// #if defined(__IInternetSession_INTERFACE_DEFINED__)
#if defined(__IInternetThreadSwitch_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetThreadSwitch, __uuidof(IInternetThreadSwitch));
#endif// #if defined(__IInternetThreadSwitch_INTERFACE_DEFINED__)
#if defined(__IInternetZoneManager_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IInternetZoneManager, __uuidof(IInternetZoneManager));
#endif// #if defined(__IInternetZoneManager_INTERFACE_DEFINED__)
#if defined(__ILayoutStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ILayoutStorage, __uuidof(ILayoutStorage));
#endif// #if defined(__ILayoutStorage_INTERFACE_DEFINED__)
#if defined(__ILockBytes_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ILockBytes, __uuidof(ILockBytes));
#endif// #if defined(__ILockBytes_INTERFACE_DEFINED__)
#if defined(__IMLangCodePages_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangCodePages, __uuidof(IMLangCodePages));
#endif// #if defined(__IMLangCodePages_INTERFACE_DEFINED__)
#if defined(__IMLangConvertCharset_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangConvertCharset, __uuidof(IMLangConvertCharset));
#endif// #if defined(__IMLangConvertCharset_INTERFACE_DEFINED__)
#if defined(__IMLangFontLink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangFontLink, __uuidof(IMLangFontLink));
#endif// #if defined(__IMLangFontLink_INTERFACE_DEFINED__)
#if defined(__IMLangLineBreakConsole_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangLineBreakConsole, __uuidof(IMLangLineBreakConsole));
#endif// #if defined(__IMLangLineBreakConsole_INTERFACE_DEFINED__)
#if defined(__IMLangString_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangString, __uuidof(IMLangString));
#endif// #if defined(__IMLangString_INTERFACE_DEFINED__)
#if defined(__IMLangStringAStr_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangStringAStr, __uuidof(IMLangStringAStr));
#endif// #if defined(__IMLangStringAStr_INTERFACE_DEFINED__)
#if defined(__IMLangStringBufA_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangStringBufA, __uuidof(IMLangStringBufA));
#endif// #if defined(__IMLangStringBufA_INTERFACE_DEFINED__)
#if defined(__IMLangStringBufW_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangStringBufW, __uuidof(IMLangStringBufW));
#endif// #if defined(__IMLangStringBufW_INTERFACE_DEFINED__)
#if defined(__IMLangStringWStr_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMLangStringWStr, __uuidof(IMLangStringWStr));
#endif// #if defined(__IMLangStringWStr_INTERFACE_DEFINED__)
#if defined(__IMalloc_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMalloc, __uuidof(IMalloc));
#endif// #if defined(__IMalloc_INTERFACE_DEFINED__)
#if defined(__IMallocSpy_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMallocSpy, __uuidof(IMallocSpy));
#endif// #if defined(__IMallocSpy_INTERFACE_DEFINED__)
#if defined(__IMapMIMEToCLSID_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMapMIMEToCLSID, __uuidof(IMapMIMEToCLSID));
#endif// #if defined(__IMapMIMEToCLSID_INTERFACE_DEFINED__)
#if defined(__IMarshal_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMarshal, __uuidof(IMarshal));
#endif// #if defined(__IMarshal_INTERFACE_DEFINED__)
#if defined(__IMarshal2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMarshal2, __uuidof(IMarshal2));
#endif// #if defined(__IMarshal2_INTERFACE_DEFINED__)
#if defined(__IMessageFilter_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMessageFilter, __uuidof(IMessageFilter));
#endif// #if defined(__IMessageFilter_INTERFACE_DEFINED__)
#if defined(__IMimeInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMimeInfo, __uuidof(IMimeInfo));
#endif// #if defined(__IMimeInfo_INTERFACE_DEFINED__)
#if defined(__IMoniker_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMoniker, __uuidof(IMoniker));
#endif// #if defined(__IMoniker_INTERFACE_DEFINED__)
#if defined(__IMonikerProp_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMonikerProp, __uuidof(IMonikerProp));
#endif// #if defined(__IMonikerProp_INTERFACE_DEFINED__)
#if defined(__IMultiLanguage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMultiLanguage, __uuidof(IMultiLanguage));
#endif// #if defined(__IMultiLanguage_INTERFACE_DEFINED__)
#if defined(__IMultiQI_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IMultiQI, __uuidof(IMultiQI));
#endif// #if defined(__IMultiQI_INTERFACE_DEFINED__)
#if defined(__IObjectIdentity_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IObjectIdentity, __uuidof(IObjectIdentity));
#endif// #if defined(__IObjectIdentity_INTERFACE_DEFINED__)
#if defined(__IObjectSafety_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IObjectSafety, __uuidof(IObjectSafety));
#endif// #if defined(__IObjectSafety_INTERFACE_DEFINED__)
#if defined(__IObjectWithSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IObjectWithSite, __uuidof(IObjectWithSite));
#endif// #if defined(__IObjectWithSite_INTERFACE_DEFINED__)
#if defined(__IOleAdviseHolder_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleAdviseHolder, __uuidof(IOleAdviseHolder));
#endif// #if defined(__IOleAdviseHolder_INTERFACE_DEFINED__)
#if defined(__IOleCache_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleCache, __uuidof(IOleCache));
#endif// #if defined(__IOleCache_INTERFACE_DEFINED__)
#if defined(__IOleCache2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleCache2, __uuidof(IOleCache2));
#endif// #if defined(__IOleCache2_INTERFACE_DEFINED__)
#if defined(__IOleCacheControl_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleCacheControl, __uuidof(IOleCacheControl));
#endif// #if defined(__IOleCacheControl_INTERFACE_DEFINED__)
#if defined(__IOleClientSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleClientSite, __uuidof(IOleClientSite));
#endif// #if defined(__IOleClientSite_INTERFACE_DEFINED__)
#if defined(__IOleCommandTarget_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleCommandTarget, __uuidof(IOleCommandTarget));
#endif// #if defined(__IOleCommandTarget_INTERFACE_DEFINED__)
#if defined(__IOleContainer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleContainer, __uuidof(IOleContainer));
#endif// #if defined(__IOleContainer_INTERFACE_DEFINED__)
#if defined(__IOleControl_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleControl, __uuidof(IOleControl));
#endif// #if defined(__IOleControl_INTERFACE_DEFINED__)
#if defined(__IOleControlSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleControlSite, __uuidof(IOleControlSite));
#endif// #if defined(__IOleControlSite_INTERFACE_DEFINED__)
#if defined(__IOleDocument_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleDocument, __uuidof(IOleDocument));
#endif// #if defined(__IOleDocument_INTERFACE_DEFINED__)
#if defined(__IOleDocumentSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleDocumentSite, __uuidof(IOleDocumentSite));
#endif// #if defined(__IOleDocumentSite_INTERFACE_DEFINED__)
#if defined(__IOleDocumentView_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleDocumentView, __uuidof(IOleDocumentView));
#endif// #if defined(__IOleDocumentView_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceActiveObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceActiveObject, __uuidof(IOleInPlaceActiveObject));
#endif// #if defined(__IOleInPlaceActiveObject_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceFrame_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceFrame, __uuidof(IOleInPlaceFrame));
#endif// #if defined(__IOleInPlaceFrame_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceObject, __uuidof(IOleInPlaceObject));
#endif// #if defined(__IOleInPlaceObject_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceObjectWindowless_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceObjectWindowless, __uuidof(IOleInPlaceObjectWindowless));
#endif// #if defined(__IOleInPlaceObjectWindowless_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSite, __uuidof(IOleInPlaceSite));
#endif// #if defined(__IOleInPlaceSite_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceSiteEx_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSiteEx, __uuidof(IOleInPlaceSiteEx));
#endif// #if defined(__IOleInPlaceSiteEx_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceSiteWindowless_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSiteWindowless, __uuidof(IOleInPlaceSiteWindowless));
#endif// #if defined(__IOleInPlaceSiteWindowless_INTERFACE_DEFINED__)
#if defined(__IOleInPlaceUIWindow_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleInPlaceUIWindow, __uuidof(IOleInPlaceUIWindow));
#endif// #if defined(__IOleInPlaceUIWindow_INTERFACE_DEFINED__)
#if defined(__IOleItemContainer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleItemContainer, __uuidof(IOleItemContainer));
#endif// #if defined(__IOleItemContainer_INTERFACE_DEFINED__)
#if defined(__IOleLink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleLink, __uuidof(IOleLink));
#endif// #if defined(__IOleLink_INTERFACE_DEFINED__)
#if defined(__IOleObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleObject, __uuidof(IOleObject));
#endif// #if defined(__IOleObject_INTERFACE_DEFINED__)
#if defined(__IOleParentUndoUnit_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleParentUndoUnit, __uuidof(IOleParentUndoUnit));
#endif// #if defined(__IOleParentUndoUnit_INTERFACE_DEFINED__)
#if defined(__IOleUndoManager_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleUndoManager, __uuidof(IOleUndoManager));
#endif// #if defined(__IOleUndoManager_INTERFACE_DEFINED__)
#if defined(__IOleUndoUnit_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleUndoUnit, __uuidof(IOleUndoUnit));
#endif// #if defined(__IOleUndoUnit_INTERFACE_DEFINED__)
#if defined(__IOleWindow_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOleWindow, __uuidof(IOleWindow));
#endif// #if defined(__IOleWindow_INTERFACE_DEFINED__)
#if defined(__IOmHistory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOmHistory, __uuidof(IOmHistory));
#endif// #if defined(__IOmHistory_INTERFACE_DEFINED__)
#if defined(__IOmNavigator_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOmNavigator, __uuidof(IOmNavigator));
#endif// #if defined(__IOmNavigator_INTERFACE_DEFINED__)
#if defined(__IOplockStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IOplockStorage, __uuidof(IOplockStorage));
#endif// #if defined(__IOplockStorage_INTERFACE_DEFINED__)
#if defined(__IPSFactoryBuffer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPSFactoryBuffer, __uuidof(IPSFactoryBuffer));
#endif// #if defined(__IPSFactoryBuffer_INTERFACE_DEFINED__)
#if defined(__IParseDisplayName_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IParseDisplayName, __uuidof(IParseDisplayName));
#endif// #if defined(__IParseDisplayName_INTERFACE_DEFINED__)
#if defined(__IPerPropertyBrowsing_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPerPropertyBrowsing, __uuidof(IPerPropertyBrowsing));
#endif// #if defined(__IPerPropertyBrowsing_INTERFACE_DEFINED__)
#if defined(__IPersist_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersist, __uuidof(IPersist));
#endif// #if defined(__IPersist_INTERFACE_DEFINED__)
#if defined(__IPersistFile_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistFile, __uuidof(IPersistFile));
#endif// #if defined(__IPersistFile_INTERFACE_DEFINED__)
#if defined(__IPersistFolder_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistFolder, __uuidof(IPersistFolder));
#endif// #if defined(__IPersistFolder_INTERFACE_DEFINED__)
#if defined(__IPersistFolder2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistFolder2, __uuidof(IPersistFolder2));
#endif// #if defined(__IPersistFolder2_INTERFACE_DEFINED__)
#if defined(__IPersistHistory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistHistory, __uuidof(IPersistHistory));
#endif// #if defined(__IPersistHistory_INTERFACE_DEFINED__)
#if defined(__IPersistMemory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistMemory, __uuidof(IPersistMemory));
#endif// #if defined(__IPersistMemory_INTERFACE_DEFINED__)
#if defined(__IPersistMoniker_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistMoniker, __uuidof(IPersistMoniker));
#endif// #if defined(__IPersistMoniker_INTERFACE_DEFINED__)
#if defined(__IPersistPropertyBag_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistPropertyBag, __uuidof(IPersistPropertyBag));
#endif// #if defined(__IPersistPropertyBag_INTERFACE_DEFINED__)
#if defined(__IPersistPropertyBag2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistPropertyBag2, __uuidof(IPersistPropertyBag2));
#endif// #if defined(__IPersistPropertyBag2_INTERFACE_DEFINED__)
#if defined(__IPersistStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistStorage, __uuidof(IPersistStorage));
#endif// #if defined(__IPersistStorage_INTERFACE_DEFINED__)
#if defined(__IPersistStream_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistStream, __uuidof(IPersistStream));
#endif// #if defined(__IPersistStream_INTERFACE_DEFINED__)
#if defined(__IPersistStreamInit_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPersistStreamInit, __uuidof(IPersistStreamInit));
#endif// #if defined(__IPersistStreamInit_INTERFACE_DEFINED__)
#if defined(__IPicture_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPicture, __uuidof(IPicture));
#endif// #if defined(__IPicture_INTERFACE_DEFINED__)
#if defined(__IPictureDisp_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPictureDisp, __uuidof(IPictureDisp));
#endif// #if defined(__IPictureDisp_INTERFACE_DEFINED__)
#if defined(__IPipeByte_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPipeByte, __uuidof(IPipeByte));
#endif// #if defined(__IPipeByte_INTERFACE_DEFINED__)
#if defined(__IPipeDouble_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPipeDouble, __uuidof(IPipeDouble));
#endif// #if defined(__IPipeDouble_INTERFACE_DEFINED__)
#if defined(__IPipeLong_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPipeLong, __uuidof(IPipeLong));
#endif// #if defined(__IPipeLong_INTERFACE_DEFINED__)
#if defined(__IPointerInactive_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPointerInactive, __uuidof(IPointerInactive));
#endif// #if defined(__IPointerInactive_INTERFACE_DEFINED__)
#if defined(__IPrint_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPrint, __uuidof(IPrint));
#endif// #if defined(__IPrint_INTERFACE_DEFINED__)
#if defined(__IProgressNotify_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IProgressNotify, __uuidof(IProgressNotify));
#endif// #if defined(__IProgressNotify_INTERFACE_DEFINED__)
#if defined(__IPropertyBag_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyBag, __uuidof(IPropertyBag));
#endif// #if defined(__IPropertyBag_INTERFACE_DEFINED__)
#if defined(__IPropertyBag2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyBag2, __uuidof(IPropertyBag2));
#endif// #if defined(__IPropertyBag2_INTERFACE_DEFINED__)
#if defined(__IPropertyNotifySink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyNotifySink, __uuidof(IPropertyNotifySink));
#endif// #if defined(__IPropertyNotifySink_INTERFACE_DEFINED__)
#if defined(__IPropertyPage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyPage, __uuidof(IPropertyPage));
#endif// #if defined(__IPropertyPage_INTERFACE_DEFINED__)
#if defined(__IPropertyPage2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyPage2, __uuidof(IPropertyPage2));
#endif// #if defined(__IPropertyPage2_INTERFACE_DEFINED__)
#if defined(__IPropertyPageSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyPageSite, __uuidof(IPropertyPageSite));
#endif// #if defined(__IPropertyPageSite_INTERFACE_DEFINED__)
#if defined(__IPropertySetStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertySetStorage, __uuidof(IPropertySetStorage));
#endif// #if defined(__IPropertySetStorage_INTERFACE_DEFINED__)
#if defined(__IPropertyStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IPropertyStorage, __uuidof(IPropertyStorage));
#endif// #if defined(__IPropertyStorage_INTERFACE_DEFINED__)
#if defined(__IProvideClassInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IProvideClassInfo, __uuidof(IProvideClassInfo));
#endif// #if defined(__IProvideClassInfo_INTERFACE_DEFINED__)
#if defined(__IProvideClassInfo2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IProvideClassInfo2, __uuidof(IProvideClassInfo2));
#endif// #if defined(__IProvideClassInfo2_INTERFACE_DEFINED__)
#if defined(__IProvideMultipleClassInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IProvideMultipleClassInfo, __uuidof(IProvideMultipleClassInfo));
#endif// #if defined(__IProvideMultipleClassInfo_INTERFACE_DEFINED__)
#if defined(__IQuickActivate_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IQuickActivate, __uuidof(IQuickActivate));
#endif// #if defined(__IQuickActivate_INTERFACE_DEFINED__)
#if defined(__IROTData_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IROTData, __uuidof(IROTData));
#endif// #if defined(__IROTData_INTERFACE_DEFINED__)
#if defined(__IRecordInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRecordInfo, __uuidof(IRecordInfo));
#endif// #if defined(__IRecordInfo_INTERFACE_DEFINED__)
#if defined(__IReleaseMarshalBuffers_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IReleaseMarshalBuffers, __uuidof(IReleaseMarshalBuffers));
#endif// #if defined(__IReleaseMarshalBuffers_INTERFACE_DEFINED__)
#if defined(__IRootStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRootStorage, __uuidof(IRootStorage));
#endif// #if defined(__IRootStorage_INTERFACE_DEFINED__)
#if defined(__IRpcChannelBuffer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer, __uuidof(IRpcChannelBuffer));
#endif// #if defined(__IRpcChannelBuffer_INTERFACE_DEFINED__)
#if defined(__IRpcChannelBuffer2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer2, __uuidof(IRpcChannelBuffer2));
#endif// #if defined(__IRpcChannelBuffer2_INTERFACE_DEFINED__)
#if defined(__IRpcChannelBuffer3_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer3, __uuidof(IRpcChannelBuffer3));
#endif// #if defined(__IRpcChannelBuffer3_INTERFACE_DEFINED__)
#if defined(__IRpcHelper_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcHelper, __uuidof(IRpcHelper));
#endif// #if defined(__IRpcHelper_INTERFACE_DEFINED__)
#if defined(__IRpcOptions_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcOptions, __uuidof(IRpcOptions));
#endif// #if defined(__IRpcOptions_INTERFACE_DEFINED__)
#if defined(__IRpcProxyBuffer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcProxyBuffer, __uuidof(IRpcProxyBuffer));
#endif// #if defined(__IRpcProxyBuffer_INTERFACE_DEFINED__)
#if defined(__IRpcStubBuffer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcStubBuffer, __uuidof(IRpcStubBuffer));
#endif// #if defined(__IRpcStubBuffer_INTERFACE_DEFINED__)
#if defined(__IRpcSyntaxNegotiate_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRpcSyntaxNegotiate, __uuidof(IRpcSyntaxNegotiate));
#endif// #if defined(__IRpcSyntaxNegotiate_INTERFACE_DEFINED__)
#if defined(__IRunnableObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRunnableObject, __uuidof(IRunnableObject));
#endif// #if defined(__IRunnableObject_INTERFACE_DEFINED__)
#if defined(__IRunningObjectTable_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IRunningObjectTable, __uuidof(IRunningObjectTable));
#endif// #if defined(__IRunningObjectTable_INTERFACE_DEFINED__)
#if defined(__ISequentialStream_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISequentialStream, __uuidof(ISequentialStream));
#endif// #if defined(__ISequentialStream_INTERFACE_DEFINED__)
#if defined(__IServerSecurity_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IServerSecurity, __uuidof(IServerSecurity));
#endif// #if defined(__IServerSecurity_INTERFACE_DEFINED__)
#if defined(__IServiceProvider_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IServiceProvider, __uuidof(IServiceProvider));
#endif// #if defined(__IServiceProvider_INTERFACE_DEFINED__)
#if defined(__IShellBrowser_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellBrowser, __uuidof(IShellBrowser));
#endif// #if defined(__IShellBrowser_INTERFACE_DEFINED__)
#if defined(__IShellDispatch_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellDispatch, __uuidof(IShellDispatch));
#endif// #if defined(__IShellDispatch_INTERFACE_DEFINED__)
#if defined(__IShellExtInit_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellExtInit, __uuidof(IShellExtInit));
#endif// #if defined(__IShellExtInit_INTERFACE_DEFINED__)
#if defined(__IShellFolder_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellFolder, __uuidof(IShellFolder));
#endif// #if defined(__IShellFolder_INTERFACE_DEFINED__)
#if defined(__IShellFolderViewDual_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellFolderViewDual, __uuidof(IShellFolderViewDual));
#endif// #if defined(__IShellFolderViewDual_INTERFACE_DEFINED__)
#if defined(__IShellLinkA_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellLinkA, __uuidof(IShellLinkA));
#endif// #if defined(__IShellLinkA_INTERFACE_DEFINED__)
#if defined(__IShellLinkDual_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellLinkDual, __uuidof(IShellLinkDual));
#endif// #if defined(__IShellLinkDual_INTERFACE_DEFINED__)
#if defined(__IShellLinkW_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellLinkW, __uuidof(IShellLinkW));
#endif// #if defined(__IShellLinkW_INTERFACE_DEFINED__)
#if defined(__IShellPropSheetExt_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellPropSheetExt, __uuidof(IShellPropSheetExt));
#endif// #if defined(__IShellPropSheetExt_INTERFACE_DEFINED__)
#if defined(__IShellUIHelper_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellUIHelper, __uuidof(IShellUIHelper));
#endif// #if defined(__IShellUIHelper_INTERFACE_DEFINED__)
#if defined(__IShellView_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellView, __uuidof(IShellView));
#endif// #if defined(__IShellView_INTERFACE_DEFINED__)
#if defined(__IShellView2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellView2, __uuidof(IShellView2));
#endif// #if defined(__IShellView2_INTERFACE_DEFINED__)
#if defined(__IShellWindows_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IShellWindows, __uuidof(IShellWindows));
#endif// #if defined(__IShellWindows_INTERFACE_DEFINED__)
#if defined(__ISimpleFrameSite_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISimpleFrameSite, __uuidof(ISimpleFrameSite));
#endif// #if defined(__ISimpleFrameSite_INTERFACE_DEFINED__)
#if defined(__ISoftDistExt_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISoftDistExt, __uuidof(ISoftDistExt));
#endif// #if defined(__ISoftDistExt_INTERFACE_DEFINED__)
#if defined(__ISpecifyPropertyPages_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISpecifyPropertyPages, __uuidof(ISpecifyPropertyPages));
#endif// #if defined(__ISpecifyPropertyPages_INTERFACE_DEFINED__)
#if defined(__IStdMarshalInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IStdMarshalInfo, __uuidof(IStdMarshalInfo));
#endif// #if defined(__IStdMarshalInfo_INTERFACE_DEFINED__)
#if defined(__IStorage_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IStorage, __uuidof(IStorage));
#endif// #if defined(__IStorage_INTERFACE_DEFINED__)
#if defined(__IStream_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IStream, __uuidof(IStream));
#endif// #if defined(__IStream_INTERFACE_DEFINED__)
#if defined(__ISubscriptionMgr_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISubscriptionMgr, __uuidof(ISubscriptionMgr));
#endif// #if defined(__ISubscriptionMgr_INTERFACE_DEFINED__)
#if defined(__ISupportErrorInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISupportErrorInfo, __uuidof(ISupportErrorInfo));
#endif// #if defined(__ISupportErrorInfo_INTERFACE_DEFINED__)
#if defined(__ISurrogate_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISurrogate, __uuidof(ISurrogate));
#endif// #if defined(__ISurrogate_INTERFACE_DEFINED__)
#if defined(__ISynchronize_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISynchronize, __uuidof(ISynchronize));
#endif// #if defined(__ISynchronize_INTERFACE_DEFINED__)
#if defined(__ISynchronizeContainer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISynchronizeContainer, __uuidof(ISynchronizeContainer));
#endif// #if defined(__ISynchronizeContainer_INTERFACE_DEFINED__)
#if defined(__ISynchronizeEvent_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISynchronizeEvent, __uuidof(ISynchronizeEvent));
#endif// #if defined(__ISynchronizeEvent_INTERFACE_DEFINED__)
#if defined(__ISynchronizeHandle_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISynchronizeHandle, __uuidof(ISynchronizeHandle));
#endif// #if defined(__ISynchronizeHandle_INTERFACE_DEFINED__)
#if defined(__ISynchronizeMutex_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ISynchronizeMutex, __uuidof(ISynchronizeMutex));
#endif// #if defined(__ISynchronizeMutex_INTERFACE_DEFINED__)
#if defined(__IThumbnailExtractor_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IThumbnailExtractor, __uuidof(IThumbnailExtractor));
#endif// #if defined(__IThumbnailExtractor_INTERFACE_DEFINED__)
#if defined(__ITimeAndNoticeControl_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITimeAndNoticeControl, __uuidof(ITimeAndNoticeControl));
#endif// #if defined(__ITimeAndNoticeControl_INTERFACE_DEFINED__)
#if defined(__ITimer_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITimer, __uuidof(ITimer));
#endif// #if defined(__ITimer_INTERFACE_DEFINED__)
#if defined(__ITimerService_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITimerService, __uuidof(ITimerService));
#endif// #if defined(__ITimerService_INTERFACE_DEFINED__)
#if defined(__ITimerSink_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITimerSink, __uuidof(ITimerSink));
#endif// #if defined(__ITimerSink_INTERFACE_DEFINED__)
#if defined(__ITypeChangeEvents_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeChangeEvents, __uuidof(ITypeChangeEvents));
#endif// #if defined(__ITypeChangeEvents_INTERFACE_DEFINED__)
#if defined(__ITypeComp_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeComp, __uuidof(ITypeComp));
#endif// #if defined(__ITypeComp_INTERFACE_DEFINED__)
#if defined(__ITypeFactory_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeFactory, __uuidof(ITypeFactory));
#endif// #if defined(__ITypeFactory_INTERFACE_DEFINED__)
#if defined(__ITypeInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeInfo, __uuidof(ITypeInfo));
#endif// #if defined(__ITypeInfo_INTERFACE_DEFINED__)
#if defined(__ITypeInfo2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeInfo2, __uuidof(ITypeInfo2));
#endif// #if defined(__ITypeInfo2_INTERFACE_DEFINED__)
#if defined(__ITypeLib_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeLib, __uuidof(ITypeLib));
#endif// #if defined(__ITypeLib_INTERFACE_DEFINED__)
#if defined(__ITypeLib2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeLib2, __uuidof(ITypeLib2));
#endif// #if defined(__ITypeLib2_INTERFACE_DEFINED__)
#if defined(__ITypeMarshal_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(ITypeMarshal, __uuidof(ITypeMarshal));
#endif// #if defined(__ITypeMarshal_INTERFACE_DEFINED__)
#if defined(__IUnknown_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IUnknown, __uuidof(IUnknown));
#endif// #if defined(__IUnknown_INTERFACE_DEFINED__)
#if defined(__IUrlHistoryNotify_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IUrlHistoryNotify, __uuidof(IUrlHistoryNotify));
#endif// #if defined(__IUrlHistoryNotify_INTERFACE_DEFINED__)
#if defined(__IUrlHistoryStg_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IUrlHistoryStg, __uuidof(IUrlHistoryStg));
#endif// #if defined(__IUrlHistoryStg_INTERFACE_DEFINED__)
#if defined(__IUrlHistoryStg2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IUrlHistoryStg2, __uuidof(IUrlHistoryStg2));
#endif// #if defined(__IUrlHistoryStg2_INTERFACE_DEFINED__)
#if defined(__IUrlMon_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IUrlMon, __uuidof(IUrlMon));
#endif// #if defined(__IUrlMon_INTERFACE_DEFINED__)
#if defined(__IVariantChangeType_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IVariantChangeType, __uuidof(IVariantChangeType));
#endif// #if defined(__IVariantChangeType_INTERFACE_DEFINED__)
#if defined(__IViewObject_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IViewObject, __uuidof(IViewObject));
#endif// #if defined(__IViewObject_INTERFACE_DEFINED__)
#if defined(__IViewObject2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IViewObject2, __uuidof(IViewObject2));
#endif// #if defined(__IViewObject2_INTERFACE_DEFINED__)
#if defined(__IViewObjectEx_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IViewObjectEx, __uuidof(IViewObjectEx));
#endif// #if defined(__IViewObjectEx_INTERFACE_DEFINED__)
#if defined(__IWaitMultiple_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWaitMultiple, __uuidof(IWaitMultiple));
#endif// #if defined(__IWaitMultiple_INTERFACE_DEFINED__)
#if defined(__IWebBrowser_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWebBrowser, __uuidof(IWebBrowser));
#endif// #if defined(__IWebBrowser_INTERFACE_DEFINED__)
#if defined(__IWebBrowser2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWebBrowser2, __uuidof(IWebBrowser2));
#endif// #if defined(__IWebBrowser2_INTERFACE_DEFINED__)
#if defined(__IWebBrowserApp_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWebBrowserApp, __uuidof(IWebBrowserApp));
#endif// #if defined(__IWebBrowserApp_INTERFACE_DEFINED__)
#if defined(__IWinInetHttpInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWinInetHttpInfo, __uuidof(IWinInetHttpInfo));
#endif// #if defined(__IWinInetHttpInfo_INTERFACE_DEFINED__)
#if defined(__IWinInetInfo_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWinInetInfo, __uuidof(IWinInetInfo));
#endif// #if defined(__IWinInetInfo_INTERFACE_DEFINED__)
#if defined(__IWindowForBindingUI_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWindowForBindingUI, __uuidof(IWindowForBindingUI));
#endif// #if defined(__IWindowForBindingUI_INTERFACE_DEFINED__)
#if defined(__IWrappedProtocol_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IWrappedProtocol, __uuidof(IWrappedProtocol));
#endif// #if defined(__IWrappedProtocol_INTERFACE_DEFINED__)
#if defined(__IXMLAttribute_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLAttribute, __uuidof(IXMLAttribute));
#endif// #if defined(__IXMLAttribute_INTERFACE_DEFINED__)
#if defined(__IXMLDOMAttribute_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMAttribute, __uuidof(IXMLDOMAttribute));
#endif// #if defined(__IXMLDOMAttribute_INTERFACE_DEFINED__)
#if defined(__IXMLDOMCDATASection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMCDATASection, __uuidof(IXMLDOMCDATASection));
#endif// #if defined(__IXMLDOMCDATASection_INTERFACE_DEFINED__)
#if defined(__IXMLDOMCharacterData_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMCharacterData, __uuidof(IXMLDOMCharacterData));
#endif// #if defined(__IXMLDOMCharacterData_INTERFACE_DEFINED__)
#if defined(__IXMLDOMComment_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMComment, __uuidof(IXMLDOMComment));
#endif// #if defined(__IXMLDOMComment_INTERFACE_DEFINED__)
#if defined(__IXMLDOMDocument_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMDocument, __uuidof(IXMLDOMDocument));
#endif// #if defined(__IXMLDOMDocument_INTERFACE_DEFINED__)
#if defined(__IXMLDOMDocumentFragment_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMDocumentFragment, __uuidof(IXMLDOMDocumentFragment));
#endif// #if defined(__IXMLDOMDocumentFragment_INTERFACE_DEFINED__)
#if defined(__IXMLDOMDocumentType_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMDocumentType, __uuidof(IXMLDOMDocumentType));
#endif// #if defined(__IXMLDOMDocumentType_INTERFACE_DEFINED__)
#if defined(__IXMLDOMElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMElement, __uuidof(IXMLDOMElement));
#endif// #if defined(__IXMLDOMElement_INTERFACE_DEFINED__)
#if defined(__IXMLDOMEntity_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMEntity, __uuidof(IXMLDOMEntity));
#endif// #if defined(__IXMLDOMEntity_INTERFACE_DEFINED__)
#if defined(__IXMLDOMEntityReference_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMEntityReference, __uuidof(IXMLDOMEntityReference));
#endif// #if defined(__IXMLDOMEntityReference_INTERFACE_DEFINED__)
#if defined(__IXMLDOMImplementation_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMImplementation, __uuidof(IXMLDOMImplementation));
#endif// #if defined(__IXMLDOMImplementation_INTERFACE_DEFINED__)
#if defined(__IXMLDOMNamedNodeMap_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMNamedNodeMap, __uuidof(IXMLDOMNamedNodeMap));
#endif// #if defined(__IXMLDOMNamedNodeMap_INTERFACE_DEFINED__)
#if defined(__IXMLDOMNode_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMNode, __uuidof(IXMLDOMNode));
#endif// #if defined(__IXMLDOMNode_INTERFACE_DEFINED__)
#if defined(__IXMLDOMNodeList_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMNodeList, __uuidof(IXMLDOMNodeList));
#endif// #if defined(__IXMLDOMNodeList_INTERFACE_DEFINED__)
#if defined(__IXMLDOMNotation_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMNotation, __uuidof(IXMLDOMNotation));
#endif// #if defined(__IXMLDOMNotation_INTERFACE_DEFINED__)
#if defined(__IXMLDOMParseError_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMParseError, __uuidof(IXMLDOMParseError));
#endif// #if defined(__IXMLDOMParseError_INTERFACE_DEFINED__)
#if defined(__IXMLDOMProcessingInstruction_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMProcessingInstruction, __uuidof(IXMLDOMProcessingInstruction));
#endif// #if defined(__IXMLDOMProcessingInstruction_INTERFACE_DEFINED__)
#if defined(__IXMLDOMText_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDOMText, __uuidof(IXMLDOMText));
#endif// #if defined(__IXMLDOMText_INTERFACE_DEFINED__)
#if defined(__IXMLDSOControl_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDSOControl, __uuidof(IXMLDSOControl));
#endif// #if defined(__IXMLDSOControl_INTERFACE_DEFINED__)
#if defined(__IXMLDocument_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDocument, __uuidof(IXMLDocument));
#endif// #if defined(__IXMLDocument_INTERFACE_DEFINED__)
#if defined(__IXMLDocument2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLDocument2, __uuidof(IXMLDocument2));
#endif// #if defined(__IXMLDocument2_INTERFACE_DEFINED__)
#if defined(__IXMLElement_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLElement, __uuidof(IXMLElement));
#endif// #if defined(__IXMLElement_INTERFACE_DEFINED__)
#if defined(__IXMLElement2_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLElement2, __uuidof(IXMLElement2));
#endif// #if defined(__IXMLElement2_INTERFACE_DEFINED__)
#if defined(__IXMLElementCollection_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLElementCollection, __uuidof(IXMLElementCollection));
#endif// #if defined(__IXMLElementCollection_INTERFACE_DEFINED__)
#if defined(__IXMLError_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLError, __uuidof(IXMLError));
#endif// #if defined(__IXMLError_INTERFACE_DEFINED__)
#if defined(__IXMLHttpRequest_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXMLHttpRequest, __uuidof(IXMLHttpRequest));
#endif// #if defined(__IXMLHttpRequest_INTERFACE_DEFINED__)
#if defined(__IXTLRuntime_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(IXTLRuntime, __uuidof(IXTLRuntime));
#endif// #if defined(__IXTLRuntime_INTERFACE_DEFINED__)
#if defined(__OLEDBSimpleProvider_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(OLEDBSimpleProvider, __uuidof(OLEDBSimpleProvider));
#endif// #if defined(__OLEDBSimpleProvider_INTERFACE_DEFINED__)
#if defined(__OLEDBSimpleProviderListener_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(OLEDBSimpleProviderListener, __uuidof(OLEDBSimpleProviderListener));
#endif// #if defined(__OLEDBSimpleProviderListener_INTERFACE_DEFINED__)
#if defined(__XMLDOMDocumentEvents_INTERFACE_DEFINED__)
_COM_SMARTPTR_TYPEDEF(XMLDOMDocumentEvents, __uuidof(XMLDOMDocumentEvents));
#endif// #if defined(__XMLDOMDocumentEvents_INTERFACE_DEFINED__)

// coclass smart pointer defs
#if defined(__DOMDocument_FWD_DEFINED__)
_COM_SMARTPTR_TYPEDEF(DOMDocument, __uuidof(DOMDocument));
#endif// #if defined(__DOMDocument_FWD_DEFINED__)
#if defined(__DOMFreeThreadedDocument_FWD_DEFINED__)
_COM_SMARTPTR_TYPEDEF(DOMFreeThreadedDocument, __uuidof(DOMFreeThreadedDocument));
#endif// #if defined(__DOMFreeThreadedDocument_FWD_DEFINED__)
#if defined(__XMLDSOControl_FWD_DEFINED__)
_COM_SMARTPTR_TYPEDEF(XMLDSOControl, __uuidof(XMLDSOControl));
#endif// #if defined(__XMLDSOControl_FWD_DEFINED__)
#if defined(__XMLDocument_FWD_DEFINED__)
_COM_SMARTPTR_TYPEDEF(XMLDocument, __uuidof(XMLDocument));
#endif// #if defined(__XMLDocument_FWD_DEFINED__)
#if defined(__XMLHTTPRequest_FWD_DEFINED__)
_COM_SMARTPTR_TYPEDEF(XMLHTTPRequest, __uuidof(XMLHTTPRequest));
#endif// #if defined(__XMLHTTPRequest_FWD_DEFINED__)
#endif /* RC_INVOKED */
#endif  /* _INC_COMDEFSP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\comutil.h ===
/***
* comutil.h - Native C++ compiler COM support - BSTR, VARIANT wrappers header
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef _M_CEE_PURE
#error comutil.h header cannot be included under /clr:safe or /clr:pure
#endif

#if !defined(_INC_COMUTIL)
#define _INC_COMUTIL

#include <ole2.h>

#if !defined(_COM_ASSERT)
# if defined(_DEBUG)
# include <assert.h>
# define _COM_ASSERT(x) assert(x)
# else
# define _COM_ASSERT(x) ((void)0)
# endif
#endif

#if !defined(_SECURE_COMPILER_COM)
/* use secure versions by default if not specified otherwise */
#define _SECURE_COMPILER_COM 1
#endif

#if _SECURE_COMPILER_COM && defined(__GOT_SECURE_LIB__) && __GOT_SECURE_LIB__ >= 200402L

#include <stdio.h>

# define _COM_MEMCPY_S(dest, destsize, src, count) memcpy_s(dest, destsize, src, count)
# if defined(UNICODE)
#  define _COM_PRINTF_S_1(dest, destsize, format, arg1) swprintf_s(dest, destsize, format, arg1)
# else
#  define _COM_PRINTF_S_1(dest, destsize, format, arg1) sprintf_s(dest, destsize, format, arg1)
# endif

#else

# define _COM_MEMCPY_S(dest, destsize, src, count) memcpy(dest, src, count)
# define _COM_PRINTF_S_1(dest, destsize, format, arg1) wsprintf(dest, format, arg1)

#endif

#pragma warning(push)
#pragma warning(disable: 4290)
#pragma warning(disable: 4310)

#pragma push_macro("new")
#undef new

/* Add macros if the macros were not defined. */
#ifndef S_OK
#define S_OK                            ((HRESULT)0L)
#endif
#ifndef INTSAFE_E_ARITHMETIC_OVERFLOW
#define INTSAFE_E_ARITHMETIC_OVERFLOW   ((HRESULT)0x80070216L)  // 0x216 = 534 = ERROR_ARITHMETIC_OVERFLOW
#endif
#ifndef INTSAFE_UINT_MAX
#define INTSAFE_UINT_MAX        		0xffffffff
#endif
#ifndef FAILED
#define FAILED(hr) (((HRESULT)(hr)) < 0)
#endif

class _com_error;

void __declspec(noreturn) __stdcall _com_issue_error(HRESULT);

//////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t;
class _variant_t;

//////////////////////////////////////////////////////////////////////////////
//
// Error checking routines
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
    inline void CheckError(HRESULT hr) throw(...)
    {
        if (FAILED(hr)) {
            _com_issue_error(hr);
        }
    }
	static HRESULT UIntAdd(UINT uAugend, UINT uAddend, UINT *puResult)
	{
		if((uAugend + uAddend) < uAddend)
		{
			return INTSAFE_E_ARITHMETIC_OVERFLOW;
		}
		*puResult = uAugend + uAddend;
		return S_OK;
	}

	static HRESULT UIntMult(UINT uMultiplicand, UINT uMultiplier, UINT *puResult)
	{
		ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);
		if(ull64Result <= INTSAFE_UINT_MAX)
		{
			*puResult = (UINT)ull64Result;
			return S_OK;
		}
		return INTSAFE_E_ARITHMETIC_OVERFLOW;
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Routines for handling conversions between BSTR and char*
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
    // Convert char * to BSTR
    //
    BSTR __stdcall ConvertStringToBSTR(const char* pSrc) ;

    // Convert BSTR to char *
    //
    char* __stdcall ConvertBSTRToString(BSTR pSrc) ;
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for BSTR
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t {
public:
    // Constructors
    //
    _bstr_t() throw();
    _bstr_t(const _bstr_t& s) throw();
    _bstr_t(const char* s) ;
    _bstr_t(const wchar_t* s) ;
    _bstr_t(const _variant_t& var) ;
    _bstr_t(BSTR bstr, bool fCopy) ;

    // Destructor
    //
    ~_bstr_t() throw();

    // Assignment operators
    //
    _bstr_t& operator=(const _bstr_t& s) throw();
    _bstr_t& operator=(const char* s) ;
    _bstr_t& operator=(const wchar_t* s) ;
    _bstr_t& operator=(const _variant_t& var) ;

    // Operators
    //
    _bstr_t& operator+=(const _bstr_t& s) ;
    _bstr_t operator+(const _bstr_t& s) const ;

    // Friend operators
    //
    friend _bstr_t operator+(const char* s1, const _bstr_t& s2) ;
    friend _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) ;

    // Extractors
    //
    operator const wchar_t*() const throw();
    operator wchar_t*() const throw();
    operator const char*() const ;
    operator char*() const ;

    // Comparison operators
    //
    bool operator!() const throw();
    bool operator==(const _bstr_t& str) const throw();
    bool operator!=(const _bstr_t& str) const throw();
    bool operator<(const _bstr_t& str) const throw();
    bool operator>(const _bstr_t& str) const throw();
    bool operator<=(const _bstr_t& str) const throw();
    bool operator>=(const _bstr_t& str) const throw();

    // Low-level helper functions
    //
    BSTR copy(bool fCopy = true) const ;
    unsigned int length() const throw();

    // Binary string assign
    //
    void Assign(BSTR s) ;

    // Get the physical BSTR
    //
    BSTR& GetBSTR() ;
    BSTR* GetAddress() ;

    // Attach to the internal BSTR w/o copying
    //
    void Attach(BSTR s) ;

    // Detach the internal BSTR
    //
    BSTR Detach() throw();

private:
    // Referenced counted wrapper
    //
    class Data_t {
    public:
        // Constructors
        //
        Data_t(const char* s) ;
        Data_t(const wchar_t* s) ;
        Data_t(BSTR bstr, bool fCopy) ;
        Data_t(const _bstr_t& s1, const _bstr_t& s2) ;

        // Reference counting routines
        //
        unsigned long AddRef() throw();
        unsigned long Release() throw();
        unsigned long RefCount() const throw();

        // Extractors
        //
        operator const wchar_t*() const throw();
        operator const char*() const ;

        // Low-level helper functions
        //
        const wchar_t* GetWString() const throw();
        wchar_t*& GetWString() throw();
        const char* GetString() const ;

        BSTR Copy() const ;
        void Assign(BSTR s) ;
        void Attach(BSTR s) throw();
        unsigned int Length() const throw();
        int Compare(const Data_t& str) const throw();

        // Exception agnostic wrapper for new
        //
        void* operator new(size_t sz);          

    private:
        BSTR            m_wstr;
        mutable char*   m_str;
        unsigned long   m_RefCount;

        // Never allow default construction
        //
        Data_t() throw();

        // Never allow copy
        //
        Data_t(const Data_t& s) throw();

        // Prevent deletes from outside. Release() must be used.
        //
        ~Data_t() throw();

        void _Free() throw();
    };

private:
    // Reference counted representation
    //
    Data_t* m_Data;

private:
    // Low-level utilities
    //
    void _AddRef() throw();
    void _Free() throw();
    int _Compare(const _bstr_t& str) const throw();
};

//////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _bstr_t::_bstr_t() throw()
    : m_Data(NULL)
{
}

// Copy constructor
//
inline _bstr_t::_bstr_t(const _bstr_t& s) throw()
    : m_Data(s.m_Data)
{
    _AddRef();
}

// Construct a _bstr_t from a const char*
//
inline _bstr_t::_bstr_t(const char* s) 
    : m_Data(new Data_t(s))
{
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a _bstr_t from a const whar_t*
//
inline _bstr_t::_bstr_t(const wchar_t* s) 
    : m_Data(new Data_t(s))
{
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a _bstr_t from a BSTR.  If fCopy is FALSE, give control of
// data to the _bstr_t without making a new copy.
//
inline _bstr_t::_bstr_t(BSTR bstr, bool fCopy) 
    : m_Data(new Data_t(bstr, fCopy))
{
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Destructor
//
inline _bstr_t::~_bstr_t() throw()
{
    _Free();
}

//////////////////////////////////////////////////////////////////////////////
//
// Assignment operators
//
//////////////////////////////////////////////////////////////////////////////

// Default assign operator
//
inline _bstr_t& _bstr_t::operator=(const _bstr_t& s) throw()
{
    if (this != &s) {
        _Free();

        m_Data = s.m_Data;
        _AddRef();
    }

    return *this;
}

// Assign a const char* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const char* s) 
{
    _COM_ASSERT(s == NULL || static_cast<const char*>(*this) != s);

    if (s == NULL || static_cast<const char*>(*this) != s)
    {
        _Free();

        m_Data = new Data_t(s);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    return *this;
}

// Assign a const wchar_t* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const wchar_t* s) 
{
    _COM_ASSERT(s == NULL || static_cast<const wchar_t*>(*this) != s);

    if (s == NULL || static_cast<const wchar_t*>(*this) != s)
    {
        _Free();

        m_Data = new Data_t(s);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////////////
//
// Operators
//
//////////////////////////////////////////////////////////////////////////////

// Concatenate a _bstr_t onto this _bstr_t
//
inline _bstr_t& _bstr_t::operator+=(const _bstr_t& s) 
{
    Data_t* newData = new Data_t(*this, s);
    if (newData == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
    else {
        _Free();
        m_Data = newData;
    }

    return *this;
}

// Return the concatenation of this _bstr_t with another _bstr_t
//
inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const 
{
    _bstr_t b = *this;
    b += s;

    return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Friend Operators
//
//////////////////////////////////////////////////////////////////////////////

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const char* s1, const _bstr_t& s2) 
{
    _bstr_t b = s1; 
    b += s2;

    return b;
}

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) 
{
    _bstr_t b = s1; 
    b += s2;

    return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::operator const wchar_t*() const throw()
{
    return (m_Data != NULL) ? m_Data->GetWString() : NULL;
}

// Extract a wchar_t*
//
inline _bstr_t::operator wchar_t*() const throw()
{
    return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);
}

// Extract a const char_t*
//
inline _bstr_t::operator const char*() const 
{
    return (m_Data != NULL) ? m_Data->GetString() : NULL;
}

// Extract a char_t*
//
inline _bstr_t::operator char*() const 
{
    return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
// Comparison operators
//
//////////////////////////////////////////////////////////////////////////////

inline bool _bstr_t::operator!() const throw()
{
    return (m_Data != NULL) ? !m_Data->GetWString() : true;
}

inline bool _bstr_t::operator==(const _bstr_t& str) const throw()
{
    return _Compare(str) == 0;
}

inline bool _bstr_t::operator!=(const _bstr_t& str) const throw()
{
    return _Compare(str) != 0;
}

inline bool _bstr_t::operator<(const _bstr_t& str) const throw()
{
    return _Compare(str) < 0;
}

inline bool _bstr_t::operator>(const _bstr_t& str) const throw()
{
    return _Compare(str) > 0;
}

inline bool _bstr_t::operator<=(const _bstr_t& str) const throw()
{
    return _Compare(str) <= 0;
}

inline bool _bstr_t::operator>=(const _bstr_t& str) const throw()
{
    return _Compare(str) >= 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// Low-level help functions
//
//////////////////////////////////////////////////////////////////////////////

// Extract a copy of the wrapped BSTR
//
inline BSTR _bstr_t::copy(bool fCopy) const 
{
    return (m_Data != NULL) ? (fCopy ? m_Data->Copy() : m_Data->GetWString()) : NULL;
}

// Return the length of the wrapped BSTR
//
inline unsigned int _bstr_t::length() const throw()
{
    return (m_Data != NULL) ? m_Data->Length() : 0;
}

// Binary string assign
//
inline void _bstr_t::Assign(BSTR s) 
{
    _COM_ASSERT(s == NULL || m_Data == NULL || m_Data->GetWString() != s);
    
    if (s == NULL || m_Data == NULL || m_Data->GetWString() != s)
    {
        _Free();

        m_Data = new Data_t(s, TRUE);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
}

// Get the physical BSTR
//
inline BSTR& _bstr_t::GetBSTR()  
{
    if (m_Data == NULL) {
        m_Data = new Data_t(0, FALSE);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
    return m_Data->GetWString();
}

// Get the address of the physical BSTR to pass as an 'out'-parameter
//
inline BSTR* _bstr_t::GetAddress()  
{
    Attach(0);
    return &m_Data->GetWString();
}

// Attach to the internal BSTR w/o copying
//
inline void _bstr_t::Attach(BSTR s) 
{
    _Free();

    m_Data = new Data_t(s, FALSE);
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Detach the internal BSTR
//
inline BSTR _bstr_t::Detach()
{
    _COM_ASSERT(m_Data != NULL && m_Data->RefCount() == 1);

    if (m_Data != NULL && m_Data->RefCount() == 1) {
        BSTR b = m_Data->GetWString();
        m_Data->GetWString() = NULL;
        _Free();
        return b;
    } 
    else {
        _com_issue_error(E_POINTER);		
    }
}

// AddRef the BSTR
//
inline void _bstr_t::_AddRef() throw()
{
    if (m_Data != NULL) {
        m_Data->AddRef();
    }
}

// Free the BSTR
//
inline void _bstr_t::_Free() throw()
{
    if (m_Data != NULL) {
        m_Data->Release();
        m_Data = NULL;
    }
}

// Compare two _bstr_t objects
//
inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
{
    if (m_Data == str.m_Data) {
        return 0;
    }

    if (m_Data == NULL) {
        if (str.length() == 0) {
            return 0;
        }
        else {
            return -1;
        }
    }

    if (str.m_Data == NULL){
        if (this->length() == 0) {
            return 0;
        }
        else {
            return 1;
        }
    }

    return m_Data->Compare(*str.m_Data);
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Construct a Data_t from a const char*
//
inline _bstr_t::Data_t::Data_t(const char* s) 
    : m_str(NULL), m_RefCount(1)
{
    m_wstr = _com_util::ConvertStringToBSTR(s);
}

// Construct a Data_t from a const wchar_t*
//
inline _bstr_t::Data_t::Data_t(const wchar_t* s) 
    : m_str(NULL), m_RefCount(1)
{
    m_wstr = ::SysAllocString(s);

    if (m_wstr == NULL && s != NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a Data_t from a BSTR.  If fCopy is FALSE, give control of
// data to the Data_t without doing a SysAllocStringByteLen.
//
inline _bstr_t::Data_t::Data_t(BSTR bstr, bool fCopy) 
    : m_str(NULL), m_RefCount(1)
{
    if (fCopy && bstr != NULL) {
        m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                         ::SysStringByteLen(bstr));

        if (m_wstr == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
    else {
        m_wstr = bstr;
    }
}

// Construct a Data_t from the concatenation of two _bstr_t objects
//
inline _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2) 
    : m_str(NULL), m_RefCount(1)
{
	const unsigned int l1 = s1.length();
	const unsigned int l2 = s2.length();
	unsigned int l3;

	if (FAILED(_com_util::UIntAdd(l1, l2, &l3)) ||
		FAILED(_com_util::UIntMult(l3, sizeof(wchar_t), &l3)))
	{
		_com_issue_error(E_OUTOFMEMORY);
		return;
	}
	
	m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));
	if (m_wstr == NULL) 
	{
		if (l1 + l2 == 0)
		{
			return;
		}
		_com_issue_error(E_OUTOFMEMORY);
		return;
	}

	const wchar_t* wstr1 = static_cast<const wchar_t*>(s1);

	if (wstr1 != NULL) 
	{
		_COM_MEMCPY_S(m_wstr, (l1 + l2 + 1) * sizeof(wchar_t), wstr1, (l1 + 1) * sizeof(wchar_t));
	}

	const wchar_t* wstr2 = static_cast<const wchar_t*>(s2);

	if (wstr2 != NULL) 
	{
		_COM_MEMCPY_S(m_wstr + l1, (l2 + 1) * sizeof(wchar_t), wstr2, (l2 + 1) * sizeof(wchar_t));
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - reference counting routines
//
//////////////////////////////////////////////////////////////////////////////

inline unsigned long _bstr_t::Data_t::AddRef() throw()
{
    InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
    return m_RefCount;
}

inline unsigned long _bstr_t::Data_t::Release() throw()
{
    unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));
    if (cRef == 0) {
        delete this;
    }

    return cRef;
}

inline unsigned long _bstr_t::Data_t::RefCount() const throw()
{
    return m_RefCount;
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::Data_t::operator const wchar_t*() const throw()
{
    return m_wstr;
}

// Extract a const char_t*
//
inline _bstr_t::Data_t::operator const char*() const 
{
    return GetString();
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - helper functions
//
//////////////////////////////////////////////////////////////////////////////

inline const wchar_t* _bstr_t::Data_t::GetWString() const throw()
{
    return m_wstr;
}

inline wchar_t*& _bstr_t::Data_t::GetWString() throw()
{
    return m_wstr;
}

inline const char* _bstr_t::Data_t::GetString() const 
{
    if (m_str == NULL) {
        m_str = _com_util::ConvertBSTRToString(m_wstr);
    }

    return m_str;
}

// Return a copy of the wrapped BSTR
//
inline BSTR _bstr_t::Data_t::Copy() const 
{
    if (m_wstr != NULL) {
        BSTR bstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(m_wstr), ::SysStringByteLen(m_wstr));

        if (bstr == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }

        return bstr;
    }

    return NULL;
}

inline void _bstr_t::Data_t::Assign(BSTR s) 
{
    _Free();

    if (s != NULL) {
        m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(s), ::SysStringByteLen(s));
        m_str = 0;
    }
}

inline void _bstr_t::Data_t::Attach(BSTR s) throw()
{
    _Free();

    m_wstr = s;
    m_str = 0;
    m_RefCount = 1;
}

// Return the length of the wrapper BSTR
//
inline unsigned int _bstr_t::Data_t::Length() const throw()
{
    return m_wstr ? ::SysStringLen(m_wstr) : 0;
}

// Compare two wrapped BSTRs
//
inline int _bstr_t::Data_t::Compare(const _bstr_t::Data_t& str) const throw()
{
    // Dont need to check for NULL here, because 
    // SysStringLen will return 0 if you pass in NULL
    const unsigned int l1 = ::SysStringLen(m_wstr);
    const unsigned int l2 = ::SysStringLen(str.m_wstr);

    unsigned int len = l1;
    if (len > l2) {
        len = l2;
    }

    BSTR bstr1 = m_wstr;
    BSTR bstr2 = str.m_wstr;

    while (len-- > 0) {
        if (*bstr1++ != *bstr2++) {
            return bstr1[-1] - bstr2[-1];
        }
    }

    return (l1 < l2) ? -1 : (l1 == l2) ? 0 : 1;
}

// Exception agnostic wrapper for new
//
#ifdef _COM_OPERATOR_NEW_THROWS
inline void* _bstr_t::Data_t::operator new(size_t sz) 
{
    try {
        return ::operator new(sz);
    }
    catch (...) {
        return NULL;
    }
}
#else // _COM_OPERATOR_NEW_THROWS
inline void* _bstr_t::Data_t::operator new(size_t sz) 
{
    return ::operator new(sz);
}
#endif // _COM_OPERATOR_NEW_THROWS

// Destruct this object
//
inline _bstr_t::Data_t::~Data_t() throw()
{
    _Free();
}

// Free up this object
//
inline void _bstr_t::Data_t::_Free() throw()
{
    if (m_wstr != NULL) {
        ::SysFreeString(m_wstr);
    }

    if (m_str != NULL) {
        delete [] m_str;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for VARIANT
//
//////////////////////////////////////////////////////////////////////////////

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class _variant_t
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

class _variant_t : public ::tagVARIANT {
public:
    // Constructors
    //
    _variant_t() throw();

    _variant_t(const VARIANT& varSrc) ;
    _variant_t(const VARIANT* pSrc) ;
    _variant_t(const _variant_t& varSrc) ;

    _variant_t(VARIANT& varSrc, bool fCopy) ;          // Attach VARIANT if !fCopy

    _variant_t(short sSrc, VARTYPE vtSrc = VT_I2) ;    // Creates a VT_I2, or a VT_BOOL
    _variant_t(long lSrc, VARTYPE vtSrc = VT_I4) ;     // Creates a VT_I4, a VT_ERROR, or a VT_BOOL
    _variant_t(float fltSrc) throw();                                   // Creates a VT_R4
    _variant_t(double dblSrc, VARTYPE vtSrc = VT_R8) ; // Creates a VT_R8, or a VT_DATE
    _variant_t(const CY& cySrc) throw();                                // Creates a VT_CY
    _variant_t(const _bstr_t& bstrSrc) ;               // Creates a VT_BSTR
    _variant_t(const wchar_t *pSrc) ;                  // Creates a VT_BSTR
    _variant_t(const char* pSrc) ;                     // Creates a VT_BSTR
    _variant_t(IDispatch* pSrc, bool fAddRef = true) throw();           // Creates a VT_DISPATCH
    _variant_t(bool boolSrc) throw();                                   // Creates a VT_BOOL
    _variant_t(IUnknown* pSrc, bool fAddRef = true) throw();            // Creates a VT_UNKNOWN
    _variant_t(const DECIMAL& decSrc) throw();                          // Creates a VT_DECIMAL
    _variant_t(BYTE bSrc) throw();                                      // Creates a VT_UI1

    _variant_t(char cSrc) throw();                                      // Creates a VT_I1
    _variant_t(unsigned short usSrc) throw();                           // Creates a VT_UI2
    _variant_t(unsigned long ulSrc) throw();                            // Creates a VT_UI4
    _variant_t(int iSrc) throw();                                       // Creates a VT_INT
    _variant_t(unsigned int uiSrc) throw();                             // Creates a VT_UINT
#if (_WIN32_WINNT >= 0x0501)
    _variant_t(__int64 i8Src) throw();                                  // Creates a VT_I8
    _variant_t(unsigned __int64 ui8Src) throw();                        // Creates a VT_UI8
#endif

    // Destructor
    //
    ~_variant_t() throw() ;

    // Extractors
    //
    operator short() const ;                           // Extracts a short from a VT_I2
    operator long() const ;                            // Extracts a long from a VT_I4
    operator float() const ;                           // Extracts a float from a VT_R4
    operator double() const ;                          // Extracts a double from a VT_R8
    operator CY() const ;                              // Extracts a CY from a VT_CY
    operator _bstr_t() const ;                         // Extracts a _bstr_t from a VT_BSTR
    operator IDispatch*() const ;                      // Extracts a IDispatch* from a VT_DISPATCH
    operator bool() const ;                            // Extracts a bool from a VT_BOOL
    operator IUnknown*() const ;                       // Extracts a IUnknown* from a VT_UNKNOWN
    operator DECIMAL() const ;                         // Extracts a DECIMAL from a VT_DECIMAL
    operator BYTE() const ;                            // Extracts a BTYE (unsigned char) from a VT_UI1
    operator VARIANT() const throw();

    operator char() const ;                            // Extracts a char from a VT_I1
    operator unsigned short() const ;                  // Extracts a unsigned short from a VT_UI2
    operator unsigned long() const ;                   // Extracts a unsigned long from a VT_UI4
    operator int() const ;                             // Extracts a int from a VT_INT
    operator unsigned int() const ;                    // Extracts a unsigned int from a VT_UINT
#if (_WIN32_WINNT >= 0x0501)
    operator __int64() const ;                         // Extracts a __int64 from a VT_I8
    operator unsigned __int64() const ;                // Extracts a unsigned __int64 from a VT_UI8
#endif

    // Assignment operations
    //
    _variant_t& operator=(const VARIANT& varSrc) ;
    _variant_t& operator=(const VARIANT* pSrc) ;
    _variant_t& operator=(const _variant_t& varSrc) ;

    _variant_t& operator=(short sSrc) ;                // Assign a VT_I2, or a VT_BOOL
    _variant_t& operator=(long lSrc) ;                 // Assign a VT_I4, a VT_ERROR or a VT_BOOL
    _variant_t& operator=(float fltSrc) ;              // Assign a VT_R4
    _variant_t& operator=(double dblSrc) ;             // Assign a VT_R8, or a VT_DATE
    _variant_t& operator=(const CY& cySrc) ;           // Assign a VT_CY
    _variant_t& operator=(const _bstr_t& bstrSrc) ;    // Assign a VT_BSTR
    _variant_t& operator=(const wchar_t* pSrc) ;       // Assign a VT_BSTR
    _variant_t& operator=(const char* pSrc) ;          // Assign a VT_BSTR
    _variant_t& operator=(IDispatch* pSrc) ;           // Assign a VT_DISPATCH
    _variant_t& operator=(bool boolSrc) ;              // Assign a VT_BOOL
    _variant_t& operator=(IUnknown* pSrc) ;            // Assign a VT_UNKNOWN
    _variant_t& operator=(const DECIMAL& decSrc) ;     // Assign a VT_DECIMAL
    _variant_t& operator=(BYTE bSrc) ;                 // Assign a VT_UI1

    _variant_t& operator=(char cSrc) ;                 // Assign a VT_I1
    _variant_t& operator=(unsigned short usSrc) ;      // Assign a VT_UI2
    _variant_t& operator=(unsigned long ulSrc) ;       // Assign a VT_UI4
    _variant_t& operator=(int iSrc) ;                  // Assign a VT_INT
    _variant_t& operator=(unsigned int uiSrc) ;        // Assign a VT_UINT
#if (_WIN32_WINNT >= 0x0501)
    _variant_t& operator=(__int64 i8Src) ;             // Assign a VT_I8
    _variant_t& operator=(unsigned __int64 ui8Src) ;   // Assign a VT_UI8
#endif

    // Comparison operations
    //
    bool operator==(const VARIANT& varSrc) const throw();
    bool operator==(const VARIANT* pSrc) const throw();

    bool operator!=(const VARIANT& varSrc) const throw();
    bool operator!=(const VARIANT* pSrc) const throw();

    // Low-level operations
    //
    void Clear() ;

    void Attach(VARIANT& varSrc) ;
    VARIANT Detach() ;

    VARIANT& GetVARIANT() throw();
    VARIANT* GetAddress() ;

    void ChangeType(VARTYPE vartype, const _variant_t* pSrc = NULL) ;

    void SetString(const char* pSrc) ; // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _variant_t::_variant_t() throw()
{
    ::VariantInit(this);
}

// Construct a _variant_t from a const VARIANT&
//
inline _variant_t::_variant_t(const VARIANT& varSrc) 
{
    ::VariantInit(this);
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a _variant_t from a const VARIANT*
//
inline _variant_t::_variant_t(const VARIANT* pSrc) 
{
    if (pSrc == NULL) {
        _com_issue_error(E_POINTER);
    }
    else {
        ::VariantInit(this);
        _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
    }
}

// Construct a _variant_t from a const _variant_t&
//
inline _variant_t::_variant_t(const _variant_t& varSrc) 
{
    ::VariantInit(this);
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a _variant_t from a VARIANT&.  If fCopy is FALSE, give control of
// data to the _variant_t without doing a VariantCopy.
//
inline _variant_t::_variant_t(VARIANT& varSrc, bool fCopy) 
{
    if (fCopy) {
        ::VariantInit(this);
        _com_util::CheckError(::VariantCopy(this, &varSrc));
    } 
    else {
        _COM_MEMCPY_S(this, sizeof(varSrc), &varSrc, sizeof(varSrc));
        V_VT(&varSrc) = VT_EMPTY;
    }
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline _variant_t::_variant_t(short sSrc, VARTYPE vtSrc) 
{
    if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
        _com_issue_error(E_INVALIDARG);
        return;
    }

    if (vtSrc == VT_BOOL) {
        V_VT(this) = VT_BOOL;
        V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        V_VT(this) = VT_I2;
        V_I2(this) = sSrc;
    }
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline _variant_t::_variant_t(long lSrc, VARTYPE vtSrc) 
{
    if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
        _com_issue_error(E_INVALIDARG);
        return;
    }

    if (vtSrc == VT_ERROR) {
        V_VT(this) = VT_ERROR;
        V_ERROR(this) = lSrc;
    }
    else if (vtSrc == VT_BOOL) {
        V_VT(this) = VT_BOOL;
        V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        V_VT(this) = VT_I4;
        V_I4(this) = lSrc;
    }
}

// Construct a VT_R4 VARIANT from a float
//
inline _variant_t::_variant_t(float fltSrc) throw()
{
    V_VT(this) = VT_R4;
    V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline _variant_t::_variant_t(double dblSrc, VARTYPE vtSrc) 
{
    if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
        _com_issue_error(E_INVALIDARG);
        return;
    }

    if (vtSrc == VT_DATE) {
        V_VT(this) = VT_DATE;
        V_DATE(this) = dblSrc;
    }
    else {
        V_VT(this) = VT_R8;
        V_R8(this) = dblSrc;
    }
}

// Construct a VT_CY from a CY
//
inline _variant_t::_variant_t(const CY& cySrc) throw()
{
    V_VT(this) = VT_CY;
    V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline _variant_t::_variant_t(const _bstr_t& bstrSrc) 
{
    V_VT(this) = VT_BSTR;

    BSTR bstr = static_cast<wchar_t*>(bstrSrc);
    if (bstr == NULL) {
        V_BSTR(this) = NULL;
    }
    else {
        V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                               ::SysStringByteLen(bstr));
        if (V_BSTR(this) == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline _variant_t::_variant_t(const wchar_t* pSrc) 
{
    V_VT(this) = VT_BSTR;

    V_BSTR(this) = ::SysAllocString(pSrc);

    if (V_BSTR(this) == NULL && pSrc != NULL) {
            _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline _variant_t::_variant_t(const char* pSrc) 
{
    V_VT(this) = VT_BSTR;
    V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline _variant_t::_variant_t(IDispatch* pSrc, bool fAddRef) throw()
{
    V_VT(this) = VT_DISPATCH;
    V_DISPATCH(this) = pSrc;

    // Need the AddRef() as VariantClear() calls Release(), unless fAddRef
    // false indicates we're taking ownership
    //
    if (fAddRef) {
        if (V_DISPATCH(this) != NULL) {
            V_DISPATCH(this)->AddRef();
        }
    }
}

// Construct a VT_BOOL VARIANT from a bool
//
inline _variant_t::_variant_t(bool boolSrc) throw()
{
    V_VT(this) = VT_BOOL;
    V_BOOL(this) = (boolSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline _variant_t::_variant_t(IUnknown* pSrc, bool fAddRef) throw()
{
    V_VT(this) = VT_UNKNOWN;
    V_UNKNOWN(this) = pSrc;

    // Need the AddRef() as VariantClear() calls Release(), unless fAddRef
    // false indicates we're taking ownership
    //
    if (fAddRef) {
        if (V_UNKNOWN(this) != NULL) {
            V_UNKNOWN(this)->AddRef();
        }
    }
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline _variant_t::_variant_t(const DECIMAL& decSrc) throw()
{
    // Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
    //
    V_DECIMAL(this) = decSrc;
    V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline _variant_t::_variant_t(BYTE bSrc) throw()
{
    V_VT(this) = VT_UI1;
    V_UI1(this) = bSrc;
}

// Construct a VT_I1 VARIANT from a char 
//
inline _variant_t::_variant_t(char cSrc) throw() 
{
    V_VT(this) = VT_I1;
    V_I1(this) = cSrc;
}

// Construct a VT_UI2 VARIANT from a unsigned short 
//
inline _variant_t::_variant_t(unsigned short usSrc) throw()
{
    V_VT(this) = VT_UI2;
    V_UI2(this) = usSrc;
}

// Construct a VT_UI4 VARIANT from a unsigned long 
//
inline _variant_t::_variant_t(unsigned long ulSrc) throw()
{
    V_VT(this) = VT_UI4;
    V_UI4(this) = ulSrc;
}

// Construct a VT_INT VARIANT from a int 
//
inline _variant_t::_variant_t(int iSrc) throw()
{
    V_VT(this) = VT_INT;
    V_INT(this) = iSrc;
}

// Construct a VT_UINT VARIANT from a unsigned int 
//
inline _variant_t::_variant_t(unsigned int uiSrc) throw()
{
    V_VT(this) = VT_UINT;
    V_UINT(this) = uiSrc;
}

#if (_WIN32_WINNT >= 0x0501)
// Construct a VT_I8 VARIANT from a __int64 
//
inline _variant_t::_variant_t(__int64 i8Src) throw()
{
    V_VT(this) = VT_I8;
    V_I8(this) = i8Src;
}

// Construct a VT_UI8 VARIANT from a unsigned __int64 
//
inline _variant_t::_variant_t(unsigned __int64 ui8Src) throw()
{
    V_VT(this) = VT_UI8;
    V_UI8(this) = ui8Src;
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline _variant_t::operator short() const 
{
    if (V_VT(this) == VT_I2) {
        return V_I2(this); 
    }

    _variant_t varDest;
    varDest.ChangeType(VT_I2, this);

    return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline _variant_t::operator long() const 
{
    if (V_VT(this) == VT_I4) {
        return V_I4(this); 
    }

    _variant_t varDest;
    varDest.ChangeType(VT_I4, this);

    return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline _variant_t::operator float() const 
{
    if (V_VT(this) == VT_R4) {
        return V_R4(this); 
    }

    _variant_t varDest;
    varDest.ChangeType(VT_R4, this);

    return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline _variant_t::operator double() const 
{
    if (V_VT(this) == VT_R8) {
        return V_R8(this); 
    }

    _variant_t varDest;
    varDest.ChangeType(VT_R8, this);

    return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline _variant_t::operator CY() const 
{
    if (V_VT(this) == VT_CY) {
        return V_CY(this); 
    }

    _variant_t varDest;
    varDest.ChangeType(VT_CY, this);

    return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline _variant_t::operator _bstr_t() const 
{
    if (V_VT(this) == VT_BSTR) {
        return V_BSTR(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_BSTR, this);

    return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline _variant_t::operator IDispatch*() const 
{
    if (V_VT(this) == VT_DISPATCH) {
        if (V_DISPATCH(this) != NULL) {
            V_DISPATCH(this)->AddRef();
        }
        return V_DISPATCH(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_DISPATCH, this);
    
    if (V_DISPATCH(&varDest) != NULL) {
        V_DISPATCH(&varDest)->AddRef();
    }

    return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline _variant_t::operator bool() const 
{
    if (V_VT(this) == VT_BOOL) {
        return V_BOOL(this) ? true : false;
    }

    _variant_t varDest;
    varDest.ChangeType(VT_BOOL, this);

    return (V_BOOL(&varDest) == VARIANT_TRUE) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline _variant_t::operator IUnknown*() const 
{
    if (V_VT(this) == VT_UNKNOWN) {
        if (V_UNKNOWN(this) != NULL) {
            V_UNKNOWN(this)->AddRef();
        }
        return V_UNKNOWN(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_UNKNOWN, this);

    if (V_UNKNOWN(&varDest) != NULL) {
        V_UNKNOWN(&varDest)->AddRef();
    }

    return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline _variant_t::operator DECIMAL() const 
{
    if (V_VT(this) == VT_DECIMAL) {
        return V_DECIMAL(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_DECIMAL, this);

    return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline _variant_t::operator BYTE() const 
{
    if (V_VT(this) == VT_UI1) {
        return V_UI1(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_UI1, this);

    return V_UI1(&varDest);
}

// Extract the physical VARIANT
//
inline _variant_t::operator VARIANT() const throw()
{
    return *(VARIANT*) this;
}

// Extracts a VT_I1 into a char
//
inline _variant_t::operator char() const  
{
    if (V_VT(this) == VT_I1) {
        return V_I1(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_I1, this);

    return V_I1(&varDest);
}

// Extracts a VT_UI2 into a unsigned short
//
inline _variant_t::operator unsigned short() const  
{
    if (V_VT(this) == VT_UI2) {
        return V_UI2(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_UI2, this);

    return V_UI2(&varDest);
}

// Extracts a VT_UI4 into a unsigned long
//
inline _variant_t::operator unsigned long() const  
{
    if (V_VT(this) == VT_UI4) {
        return V_UI4(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_UI4, this);

    return V_UI4(&varDest);
}

// Extracts a VT_INT into a int
//
inline _variant_t::operator int() const  
{
    if (V_VT(this) == VT_INT) {
        return V_INT(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_INT, this);

    return V_INT(&varDest);
}

// Extracts a VT_UINT into a unsigned int
//
inline _variant_t::operator unsigned int() const  
{
    if (V_VT(this) == VT_UINT) {
        return V_UINT(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_UINT, this);

    return V_UINT(&varDest);
}

#if (_WIN32_WINNT >= 0x0501)
// Extracts a VT_I8 into a __int64
//
inline _variant_t::operator __int64() const  
{
    if (V_VT(this) == VT_I8) {
        return V_I8(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_I8, this);

    return V_I8(&varDest);
}

// Extracts a VT_UI8 into a unsigned __int64
//
inline _variant_t::operator unsigned __int64() const  
{
    if (V_VT(this) == VT_UI8) {
        return V_UI8(this);
    }

    _variant_t varDest;
    varDest.ChangeType(VT_UI8, this);

    return V_UI8(&varDest);
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT& varSrc) 
{
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

    return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT* pSrc) 
{
    if (pSrc == NULL) {
        _com_issue_error(E_POINTER);
    }
    else {
        _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
    }

    return *this;
}

// Assign a const _variant_t& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const _variant_t& varSrc) 
{
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

    return *this;
}

// Assign a short creating either VT_I2 VARIANT or a 
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline _variant_t& _variant_t::operator=(short sSrc) 
{
    if (V_VT(this) == VT_I2) {
        V_I2(this) = sSrc;
    }
    else if (V_VT(this) == VT_BOOL) {
        V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        // Clear the VARIANT and create a VT_I2
        //
        Clear();

        V_VT(this) = VT_I2;
        V_I2(this) = sSrc;
    }

    return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline _variant_t& _variant_t::operator=(long lSrc) 
{
    if (V_VT(this) == VT_I4) {
        V_I4(this) = lSrc;
    }
    else if (V_VT(this) == VT_ERROR) {
        V_ERROR(this) = lSrc;
    }
    else if (V_VT(this) == VT_BOOL) {
        V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        // Clear the VARIANT and create a VT_I4
        //
        Clear();

        V_VT(this) = VT_I4;
        V_I4(this) = lSrc;
    }

    return *this;
}

// Assign a float creating a VT_R4 VARIANT 
//
inline _variant_t& _variant_t::operator=(float fltSrc) 
{
    if (V_VT(this) != VT_R4) {
        // Clear the VARIANT and create a VT_R4
        //
        Clear();

        V_VT(this) = VT_R4;
    }

    V_R4(this) = fltSrc;

    return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline _variant_t& _variant_t::operator=(double dblSrc) 
{
    if (V_VT(this) == VT_R8) {
        V_R8(this) = dblSrc;
    }
    else if(V_VT(this) == VT_DATE) {
        V_DATE(this) = dblSrc;
    }
    else {
        // Clear the VARIANT and create a VT_R8
        //
        Clear();

        V_VT(this) = VT_R8;
        V_R8(this) = dblSrc;
    }

    return *this;
}

// Assign a CY creating a VT_CY VARIANT 
//
inline _variant_t& _variant_t::operator=(const CY& cySrc) 
{
    if (V_VT(this) != VT_CY) {
        // Clear the VARIANT and create a VT_CY
        //
        Clear();

        V_VT(this) = VT_CY;
    }

    V_CY(this) = cySrc;

    return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const _bstr_t& bstrSrc) 
{
    _COM_ASSERT(V_VT(this) != VT_BSTR || (BSTR) bstrSrc == NULL || V_BSTR(this) != (BSTR) bstrSrc);

    // Clear the VARIANT (This will SysFreeString() any previous occupant)
    //
    Clear();

    V_VT(this) = VT_BSTR;

    if (!bstrSrc) {
        V_BSTR(this) = NULL;
    }
    else {
        BSTR bstr = static_cast<wchar_t*>(bstrSrc);
        V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                               ::SysStringByteLen(bstr));

        if (V_BSTR(this) == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const wchar_t* pSrc) 
{
    _COM_ASSERT(V_VT(this) != VT_BSTR || pSrc == NULL || V_BSTR(this) != pSrc);

    // Clear the VARIANT (This will SysFreeString() any previous occupant)
    //
    Clear();

    V_VT(this) = VT_BSTR;

    if (pSrc == NULL) {
        V_BSTR(this) = NULL;
    }
    else {
        V_BSTR(this) = ::SysAllocString(pSrc);

        if (V_BSTR(this) == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const char* pSrc) 
{
    _COM_ASSERT(V_VT(this) != (VT_I1 | VT_BYREF) || pSrc == NULL || V_I1REF(this) != pSrc);

    // Clear the VARIANT (This will SysFreeString() any previous occupant)
    //
    Clear();

    V_VT(this) = VT_BSTR;
    V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

    return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT 
//
inline _variant_t& _variant_t::operator=(IDispatch* pSrc) 
{
    _COM_ASSERT(V_VT(this) != VT_DISPATCH || pSrc == 0 || V_DISPATCH(this) != pSrc);

    // Clear the VARIANT (This will Release() any previous occupant)
    //
    Clear();

    V_VT(this) = VT_DISPATCH;
    V_DISPATCH(this) = pSrc;

    if (V_DISPATCH(this) != NULL) {
        // Need the AddRef() as VariantClear() calls Release()
        //
        V_DISPATCH(this)->AddRef();
    }

    return *this;
}

// Assign a bool creating a VT_BOOL VARIANT 
//
inline _variant_t& _variant_t::operator=(bool boolSrc) 
{
    if (V_VT(this) != VT_BOOL) {
        // Clear the VARIANT and create a VT_BOOL
        //
        Clear();

        V_VT(this) = VT_BOOL;
    }

    V_BOOL(this) = (boolSrc ? VARIANT_TRUE : VARIANT_FALSE);

    return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT 
//
inline _variant_t& _variant_t::operator=(IUnknown* pSrc) 
{
    _COM_ASSERT(V_VT(this) != VT_UNKNOWN || pSrc == NULL || V_UNKNOWN(this) != pSrc);

    // Clear VARIANT (This will Release() any previous occupant)
    //
    Clear();

    V_VT(this) = VT_UNKNOWN;
    V_UNKNOWN(this) = pSrc;

    if (V_UNKNOWN(this) != NULL) {
        // Need the AddRef() as VariantClear() calls Release()
        //
        V_UNKNOWN(this)->AddRef();
    }

    return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline _variant_t& _variant_t::operator=(const DECIMAL& decSrc) 
{
    if (V_VT(this) != VT_DECIMAL) {
        // Clear the VARIANT
        //
        Clear();
    }

    // Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
    V_DECIMAL(this) = decSrc;
    V_VT(this) = VT_DECIMAL;

    return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline _variant_t& _variant_t::operator=(BYTE bSrc) 
{
    if (V_VT(this) != VT_UI1) {
        // Clear the VARIANT and create a VT_UI1
        //
        Clear();

        V_VT(this) = VT_UI1;
    }

    V_UI1(this) = bSrc;

    return *this;
}

// Assign a char creating a VT_I1 VARIANT
//
inline _variant_t& _variant_t::operator=(char cSrc) 
{
    if (V_VT(this) != VT_I1) {
        // Clear the VARIANT and create a VT_I1
        //
        Clear();

        V_VT(this) = VT_I1;
    }

    V_I1(this) = cSrc;

    return *this;
}

// Assign a char creating a VT_UI2 VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned short usSrc) 
{
    if (V_VT(this) != VT_UI2) {
        // Clear the VARIANT and create a VT_UI2
        //
        Clear();

        V_VT(this) = VT_UI2;
    }

    V_UI2(this) = usSrc;

    return *this;
}

// Assign a char creating a VT_UI4 VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned long ulSrc) 
{
    if (V_VT(this) != VT_UI4) {
        // Clear the VARIANT and create a VT_UI4
        //
        Clear();

        V_VT(this) = VT_UI4;
    }

    V_UI4(this) = ulSrc;

    return *this;
}

// Assign a char creating a VT_INT VARIANT
//
inline _variant_t& _variant_t::operator=(int iSrc) 
{
    if (V_VT(this) != VT_INT) {
        // Clear the VARIANT and create a VT_INT
        //
        Clear();

        V_VT(this) = VT_INT;
    }

    V_INT(this) = iSrc;

    return *this;
}

// Assign a char creating a VT_UINT VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned int uiSrc) 
{
    if (V_VT(this) != VT_UINT) {
        // Clear the VARIANT and create a VT_UINT
        //
        Clear();

        V_VT(this) = VT_UINT;
    }

    V_UINT(this) = uiSrc;

    return *this;
}

#if (_WIN32_WINNT >= 0x0501)
// Assign a char creating a VT_I8 VARIANT
//
inline _variant_t& _variant_t::operator=(__int64 i8Src) 
{
    if (V_VT(this) != VT_I8) {
        // Clear the VARIANT and create a VT_I8
        //
        Clear();

        V_VT(this) = VT_I8;
    }

    V_I8(this) = i8Src;

    return *this;
}

// Assign a char creating a VT_UI8 VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned __int64 ui8Src) 
{
    if (V_VT(this) != VT_UI8) {
        // Clear the VARIANT and create a VT_UI8
        //
        Clear();

        V_VT(this) = VT_UI8;
    }

    V_UI8(this) = ui8Src;

    return *this;
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a _variant_t against a const VARIANT& for equality
//
inline bool _variant_t::operator==(const VARIANT& varSrc) const throw()
{
    return *this == &varSrc;
}

#pragma warning(push)
#pragma warning(disable: 4702) // unreachable code

// Compare a _variant_t against a const VARIANT* for equality
//
inline bool _variant_t::operator==(const VARIANT* pSrc) const throw()
{
    if (pSrc == NULL) {
        return false;
    }

    if (this == pSrc) {
        return true;
    }

    //
    // Variants not equal if types don't match
    //
    if (V_VT(this) != V_VT(pSrc)) {
        return false;
    }

    //
    // Check type specific values
    //
    switch (V_VT(this)) {
        case VT_EMPTY:
        case VT_NULL:
            return true;

        case VT_I2:
            return V_I2(this) == V_I2(pSrc);

        case VT_I4:
            return V_I4(this) == V_I4(pSrc);

        case VT_R4:
            return V_R4(this) == V_R4(pSrc);

        case VT_R8:
            return V_R8(this) == V_R8(pSrc);

        case VT_CY:
            return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

        case VT_DATE:
            return V_DATE(this) == V_DATE(pSrc);

        case VT_BSTR:
            return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
                    (memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

        case VT_DISPATCH:
            return V_DISPATCH(this) == V_DISPATCH(pSrc);

        case VT_ERROR:
            return V_ERROR(this) == V_ERROR(pSrc);

        case VT_BOOL:
            return V_BOOL(this) == V_BOOL(pSrc);

        case VT_UNKNOWN:
            return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

        case VT_DECIMAL:
            return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

        case VT_UI1:
            return V_UI1(this) == V_UI1(pSrc);

        case VT_I1:
            return V_I1(this) == V_I1(pSrc);

        case VT_UI2:
            return V_UI2(this) == V_UI2(pSrc);

        case VT_UI4:
            return V_UI4(this) == V_UI4(pSrc);

        case VT_INT:
            return V_INT(this) == V_INT(pSrc);

        case VT_UINT:
            return V_UINT(this) == V_UINT(pSrc);

#if (_WIN32_WINNT >= 0x0501)
        case VT_I8:
            return V_I8(this) == V_I8(pSrc);

        case VT_UI8:
            return V_UI8(this) == V_UI8(pSrc);
#endif

        default:
            _com_issue_error(E_INVALIDARG);
            // fall through
    }

    return false;
}

#pragma warning(pop)

// Compare a _variant_t against a const VARIANT& for in-equality
//
inline bool _variant_t::operator!=(const VARIANT& varSrc) const throw()
{
    return !(*this == &varSrc);
}

// Compare a _variant_t against a const VARIANT* for in-equality
//
inline bool _variant_t::operator!=(const VARIANT* pSrc) const throw()
{
    return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the _variant_t
//
inline void _variant_t::Clear() 
{
    _com_util::CheckError(::VariantClear(this));
}

inline void _variant_t::Attach(VARIANT& varSrc) 
{
    //
    // Free up previous VARIANT
    //
    Clear();

    //
    // Give control of data to _variant_t
    //
    _COM_MEMCPY_S(this, sizeof(varSrc), &varSrc, sizeof(varSrc));
    V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT _variant_t::Detach() 
{
    VARIANT varResult = *this;
    V_VT(this) = VT_EMPTY;

    return varResult;
}

inline VARIANT& _variant_t::GetVARIANT() throw() 
{
    return *(VARIANT*) this;
}

inline VARIANT* _variant_t::GetAddress() 
{
    Clear();
    return (VARIANT*) this;
}

// Change the type and contents of this _variant_t to the type vartype and
// contents of pSrc
//
inline void _variant_t::ChangeType(VARTYPE vartype, const _variant_t* pSrc) 
{
    //
    // If pDest is NULL, convert type in place
    //
    if (pSrc == NULL) {
        pSrc = this;
    }

    if ((this != pSrc) || (vartype != V_VT(this))) {
        _com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
                                                  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
                                                  0, vartype));
    }
}

inline void _variant_t::SetString(const char* pSrc) 
{
    operator=(pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////////////////

inline _variant_t::~_variant_t() throw()
{
    ::VariantClear(this);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Mutually-dependent definitions
//
//////////////////////////////////////////////////////////////////////////////////////////

// Construct a _bstr_t from a const _variant_t&
//
inline _bstr_t::_bstr_t(const _variant_t &var) 
    : m_Data(NULL)
{
    if (V_VT(&var) == VT_BSTR) {
        *this = V_BSTR(&var);
        return;
    }

    _variant_t varDest;
    varDest.ChangeType(VT_BSTR, &var);

    *this = V_BSTR(&varDest);
}

// Assign a const _variant_t& to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const _variant_t &var) 
{
    if (V_VT(&var) == VT_BSTR) {
        *this = V_BSTR(&var);
        return *this;
    }

    _variant_t varDest;
    varDest.ChangeType(VT_BSTR, &var);

    *this = V_BSTR(&varDest);

    return *this;
}

extern _variant_t vtMissing;

#ifndef _USE_RAW
#define bstr_t _bstr_t
#define variant_t _variant_t
#endif

#pragma pop_macro("new")

#pragma warning(pop)

#endif  // _INC_COMUTIL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\concurrent_queue.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
* Microsoft would like to acknowledge that this concurrency data structure implementation
* is based on Intels implementation in its Threading Building Blocks ("Intel Material").
* 
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* concurrent_queue.h
*
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

/*
    Intel Material Copyright 2005-2008 Intel Corporation.  All Rights Reserved.
*/

#pragma once


#include <crtdefs.h>
#include <memory>
#include <cstddef>
#include <crtdbg.h>
#include <concrt.h>

#if !(defined(_M_AMD64) || defined(_M_IX86))
    #error ERROR: Concurrency Runtime is supported only on X64 and X86 architectures.
#endif

#if defined(_M_CEE)
    #error ERROR: Concurrency Runtime is not supported when compiling /clr.
#endif

#pragma pack(push,_CRT_PACKING)

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{

template<typename _Ty, class _Ax = std::allocator<_Ty> > 
class concurrent_queue;

namespace details
{

    class _Concurrent_queue_rep;

    typedef size_t _Ticket;

    class _Concurrent_queue_iterator_rep;
    class _Concurrent_queue_iterator_base_v4;
    template<typename _Container, typename _Value> class _Concurrent_queue_iterator;

    //  Type-independent portion of concurrent_queue.
    class _Concurrent_queue_base_v4 
    {
        // Internal representation
        _Concurrent_queue_rep* _My_rep;

        friend class _Concurrent_queue_rep;
        friend struct _Micro_queue;
        friend class _Micro_queue_pop_finalizer;
        friend class _Concurrent_queue_iterator_rep;
        friend class _Concurrent_queue_iterator_base_v4;
    protected:
        // Prefix on a page
        struct _Page 
        {
            _Page* _Next;
            size_t _Mask; 
        };

        // Always a power of 2
        size_t _Items_per_page;

        // Size of an item
        size_t _Item_size;

    private:
        virtual void _Copy_item( _Page& _Dst, size_t _Index, const void* _Src ) = 0;
        virtual void _Assign_and_destroy_item( void* _Dst, _Page& _Src, size_t _Index ) = 0;
    protected:
        _CRTIMP2 _Concurrent_queue_base_v4( size_t _Item_size );
        _CRTIMP2 virtual ~_Concurrent_queue_base_v4();

        // Enqueue item at tail of queue
        _CRTIMP2 void _Internal_push( const void* _Src );

        // Attempt to dequeue item from queue.
        /** NULL if there was no item to dequeue. */
        _CRTIMP2 bool _Internal_pop_if_present( void* _Dst );

        // Get size of queue
        _CRTIMP2 size_t _Internal_size() const;

        // Test instantaneous queue empty
        _CRTIMP2 bool _Internal_empty() const;

        // custom allocator
        virtual _Page *_Allocate_page() = 0;

        // custom de-allocator
        virtual void _Deallocate_page( _Page *p ) = 0;

        // free any remaining pages
        _CRTIMP2 void _Internal_finish_clear() ;

        // throw an exception
        _CRTIMP2 void _Internal_throw_exception() const;

    private:
        // Deny copy construction
        _Concurrent_queue_base_v4( const _Concurrent_queue_base_v4& );

        // Deny assignment
        void operator=( const _Concurrent_queue_base_v4& );
    };

    typedef _Concurrent_queue_base_v4 _Concurrent_queue_base ;


    // A queue using simple locking.
    /** For efficiency, this class has no constructor.  
        The caller is expected to zero-initialize it. */
    struct _Micro_queue
    {
        class _Pop_finalizer;
        class _Push_finalizer;

        _Subatomic<_Concurrent_queue_base::_Page*> _Head_page;
        _Subatomic<_Ticket> _Head_counter;

        _Subatomic<_Concurrent_queue_base::_Page*> _Tail_page;
        _Subatomic<_Ticket> _Tail_counter;

        volatile long _Page_mutex_flag;

        void _Push( const void* _Item, _Ticket _K, _Concurrent_queue_base& _Base );

        bool _Pop( void* _Dest, _Ticket _K, _Concurrent_queue_base& _Base );
    };

    // Disable warning C4324: structure was padded due to __declspec(align())
    // This padding is expected and necessary.
    #pragma warning(push)
    #pragma warning(disable: 4324)


    // Internal representation of a ConcurrentQueue.
    /** For efficiency, this class has no constructor.  
        The caller is expected to zero-initialize it. */
    class _Concurrent_queue_rep
    {
    private:
        friend struct _Micro_queue;

        // Approximately n_queue/golden ratio
        static const size_t _Phi = 3;

    public:
        // Must be power of 2
        static const size_t _N_queue = 8; 

        // Map ticket to an array index
        static size_t _Index( _Ticket _K )
        {
            return _K*_Phi%_N_queue;
        }

        __declspec(align(64))
        _Subatomic<_Ticket> _Head_counter;

        __declspec(align(64))
        _Subatomic<_Ticket> _Tail_counter;

        __declspec(align(64))
        _Micro_queue _Array[_N_queue];    

        _Micro_queue& _Choose( _Ticket _K )
        {
            // The formula here approximates LRU in a cache-oblivious way.
            return _Array[_Index(_K)];
        }
    };

    #pragma warning(pop)


    // Type-independent portion of _Concurrent_queue_iterator.
    class _Concurrent_queue_iterator_base_v4 {
        // Concurrentconcurrent_queue over which we are iterating.
        /** NULL if one past last element in queue. */
        _Concurrent_queue_iterator_rep* _My_rep;

        template<typename _C, typename _Ty, typename _U>
        friend bool operator==( const _Concurrent_queue_iterator<_C,_Ty>&, const _Concurrent_queue_iterator<_C,_U>& );

        template<typename _C, typename _Ty, typename _U>
        friend bool operator!=( const _Concurrent_queue_iterator<_C,_Ty>&, const _Concurrent_queue_iterator<_C,_U>& );
    protected:
        // Pointer to current item
        mutable void* _My_item;

        // Default constructor
        _Concurrent_queue_iterator_base_v4()
            : _My_rep(NULL), _My_item(NULL)
        {
        }

        // Copy constructor
        _Concurrent_queue_iterator_base_v4( const _Concurrent_queue_iterator_base_v4& _I )
            : _My_rep(NULL), _My_item(NULL)
        {
            _Assign(_I);
        }

        // Construct iterator pointing to head of queue.
        _CRTIMP2 _Concurrent_queue_iterator_base_v4( const _Concurrent_queue_base&  );

        // Assignment
        _CRTIMP2 void _Assign( const _Concurrent_queue_iterator_base_v4& );

        // Advance iterator one step towards tail of queue.
        _CRTIMP2 void _Advance();

        // Destructor
        _CRTIMP2 ~_Concurrent_queue_iterator_base_v4();
    };

    typedef _Concurrent_queue_iterator_base_v4 concurrent_queue_iterator_base;

    // Meets requirements of a forward iterator for STL.
    /** _Value is either the _Ty or const _Ty type of the container. */
    template<typename _Container, typename _Value>
    class _Concurrent_queue_iterator: public _Concurrent_queue_iterator_base_v4
    {
        template<typename _Ty, class _Ax> friend class ::Concurrency::concurrent_queue;

        // Construct iterator pointing to head of queue.
        _Concurrent_queue_iterator( const _Concurrent_queue_base& _Queue )
            : _Concurrent_queue_iterator_base_v4(_Queue)
        {
        }
    public:
        _Concurrent_queue_iterator()
        {
        }

        /** If _Value==_Container::value_type, then this routine is the copy constructor. 
            If _Value==const _Container::value_type, then this routine is a conversion constructor. */
        _Concurrent_queue_iterator( const _Concurrent_queue_iterator<_Container,typename _Container::value_type>& _Other )
            : _Concurrent_queue_iterator_base_v4(_Other)
        {
        }

        // Iterator assignment
        _Concurrent_queue_iterator& operator=( const _Concurrent_queue_iterator& _Other )
        {
            _Assign(_Other);
            return *this;
        }

        // Reference to current item 
        _Value& operator*() const
        {
            return *static_cast<_Value*>(_My_item);
        }

        _Value* operator->() const 
        {
            return &operator*();
        }

        // Advance to next item in queue
        _Concurrent_queue_iterator& operator++() 
        {
            _Advance();
            return *this;
        }

        // Post increment
        _Concurrent_queue_iterator operator++(int) 
        {
            _Concurrent_queue_iterator _Result = *this;
            _Advance();
            return _Result;
        }
    }; // _Concurrent_queue_iterator


    template<typename _C, typename _Ty, typename _U>
    bool operator==( const _Concurrent_queue_iterator<_C,_Ty>& _I, const _Concurrent_queue_iterator<_C,_U>& _J )
    {
        return _I._My_item==_J._My_item;
    }

    template<typename _C, typename _Ty, typename _U>
    bool operator!=( const _Concurrent_queue_iterator<_C,_Ty>& _I, const _Concurrent_queue_iterator<_C,_U>& _J ) 
    {
        return _I._My_item!=_J._My_item;
    }

} // namespace details;


/// <summary>
///     The <c>concurrent_queue</c> class is a sequence container class that allows first-in,
///     first-out access to its elements. It enables a limited set of concurrency-safe operations, such as
///     <c>push</c> and <c>try_pop</c>, to name a few.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements to be stored in the queue.
/// </typeparam>
/// <typeparam name="_Ax">
///     The type that represents the stored allocator object that encapsulates details about the allocation and 
///     deallocation of memory for this concurrent queue. This argument is optional and the default value is
///     <c>allocator&lt;</c><typeparamref name="_Ty"/><c>&gt;</c>.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Parallel Containers and Objects"/>.
/// </remarks>
/**/
template<typename _Ty, class _Ax>
class concurrent_queue: public ::Concurrency::details::_Concurrent_queue_base_v4
{
    template<typename _Container, typename _Value> friend class ::Concurrency::details::_Concurrent_queue_iterator;

    // allocator type
    typedef typename _Ax::template rebind<char>::other _Page_allocator_type;
    _Page_allocator_type _My_allocator;

    // Class used to ensure exception-safety of method "pop" 
    class _Destroyer
    {
    private:
        _Ty& _My_value;

        void operator=(const _Destroyer&); // prevent warning: assign operator can't be generated
    public:
        _Destroyer( _Ty& _Value )
            : _My_value(_Value)
        {
        }

        ~_Destroyer()
        {
            _My_value.~_Ty();
        }
    };

    _Ty& _Get_ref( _Page& _Pg, size_t _Index )
    {
        _ASSERTE( _Index<_Items_per_page );
        return static_cast<_Ty*>(static_cast<void*>(&_Pg+1))[_Index];
    }

    /*override*/ virtual void _Copy_item( _Page& _Dst, size_t _Index, const void* _Src )
    {
        new( &_Get_ref(_Dst,_Index) ) _Ty(*static_cast<const _Ty*>(_Src)); 
    }

    /*override*/ virtual void _Assign_and_destroy_item( void* _Dst, _Page& _Src, size_t _Index )
    {
        _Ty& _From = _Get_ref(_Src,_Index);
        _Destroyer _D(_From);
        *static_cast<_Ty*>(_Dst) = _From;
    }

    /*overide*/ virtual _Page *_Allocate_page()
    {
        size_t _N = sizeof(_Page) + _Items_per_page*_Item_size;
        _Page *_Pg = reinterpret_cast<_Page*>(_My_allocator.allocate( _N ));
        if( !_Pg )
            _Internal_throw_exception(); 
        return _Pg;
    }
    
    /*override*/ virtual void _Deallocate_page( _Page *_Pg )
    {
        size_t _N = sizeof(_Page) + _Items_per_page*_Item_size;
        _My_allocator.deallocate( reinterpret_cast<char*>(_Pg), _N );
    }

public:
    /// <summary>
    ///     A type that represents the data type stored in a concurrent queue.
    /// </summary>
    /**/
    typedef _Ty value_type;

    /// <summary>
    ///     A type that represents the allocator class for the concurrent queue.
    /// </summary>
    /**/
    typedef _Ax allocator_type;

    /// <summary>
    ///     A type that provides a reference to an element stored in a concurrent queue.
    /// </summary>
    /**/
    typedef _Ty& reference;

    /// <summary>
    ///     A type that provides a reference to a <c>const</c> element stored in a concurrent queue for reading and
    ///     performing <c>const</c> operations.
    /// </summary>
    /**/
    typedef const _Ty& const_reference;

    /// <summary>
    ///     A type that counts the number of elements in a concurrent queue.
    /// </summary>
    /**/
	typedef std::size_t size_type;

    /// <summary>
    ///     A type that provides the signed distance between two elements in a concurrent queue.
    /// </summary>
    /**/
    typedef std::ptrdiff_t difference_type;

    /// <summary>
    ///     Constructs a concurrent queue.
    /// </summary>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the queue.
    ///     <para>The first constructor specifies an empty initial queue and explicitly specifies the allocator
    ///     type to be used.</para>
    ///     <para>The second constructor specifies a copy of the concurrent queue <paramref name="_OtherQ"/>.</para>
    ///     <para>The third constructor specifies values supplied by the iterator range 
    ///     [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    explicit concurrent_queue(const allocator_type  &_Al = allocator_type())
        : _Concurrent_queue_base_v4( sizeof(_Ty) ), _My_allocator( _Al )
    {
    }

    /// <summary>
    ///     Constructs a concurrent queue.
    /// </summary>
    /// <param name="_OtherQ">
    ///     The source <c>concurrent_queue</c> object to copy elements from.
    /// </param>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the queue.
    ///     <para>The first constructor specifies an empty initial queue and explicitly specifies the allocator
    ///     type to be used.</para>
    ///     <para>The second constructor specifies a copy of the concurrent queue <paramref name="_OtherQ"/>.</para>
    ///     <para>The third constructor specifies values supplied by the iterator range 
    ///     [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    concurrent_queue(const concurrent_queue& _OtherQ, const allocator_type &_Al = allocator_type());

    /// <summary>
    ///     Constructs a concurrent queue.
    /// </summary>
    /// <typeparam name="_InputIterator">
    ///     The type of the input iterator that specifies a range of values.
    /// </typeparam>
    /// <param name="_Begin">
    ///     Position of the first element in the range of elements to be copied.
    /// </param>
    /// <param name="_End">
    ///     Position of the first element beyond the range of elements to be copied.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the queue.
    ///     <para>The first constructor specifies an empty initial queue and explicitly specifies the allocator
    ///     type to be used.</para>
    ///     <para>The second constructor specifies a copy of the concurrent queue <paramref name="_OtherQ"/>.</para>
    ///     <para>The third constructor specifies values supplied by the iterator range 
    ///     [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    template<typename _InputIterator>
    concurrent_queue(_InputIterator _Begin, _InputIterator _End)
        : _Concurrent_queue_base_v4( sizeof(_Ty) ), _My_allocator( allocator_type() )
    {
        while (_Begin != _End)
        {
            this->push(*_Begin);
            ++_Begin;
        }
    }

    /// <summary>
    ///     Destroys the concurrent queue.
    /// </summary>
    /**/
    ~concurrent_queue();

    /// <summary>
    ///     Enqueues an item at tail end of the concurrent queue. This method is concurrency-safe.
    /// </summary>
    /// <param name="_Src">
    ///     The item to be added to the queue.
    /// </param>
    /// <remarks>
    ///     <c>push</c> is concurrency-safe with respect to calls to the methods <c>push</c>, <c>try_pop</c>, and <c>empty</c>.
    /// </remarks>
    /**/
    void push( const _Ty& _Src )
    {
        _Internal_push( &_Src );
    }


    /// <summary>
    ///     Dequeues an item from the queue if one is available. This method is concurrency-safe.
    /// </summary>
    /// <param name="_Dest">
    ///     A reference to a location to store the dequeued item.
    /// </param>
    /// <returns>
    ///     <c>true</c> if an item was successfully dequeued,<c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     If an item was successfully dequeued, the parameter <paramref name="_Dest"/> receives the
    ///     dequeued value, the original value held in the queue is destroyed, and this function returns
    ///     <c>true</c>. If there was no item to dequeue, this function returns <c>false</c> without blocking,
    ///     and the contents of the <paramref name="_Dest"/> parameter are undefined.
    ///     <para><c>try_pop</c> is concurrency-safe with respect to calls to the methods <c>push</c>, <c>try_pop</c>,
    ///     and <c>empty</c>.</para>
    /// </remarks>
    /**/
    bool try_pop( _Ty& _Dest )
    {
        return _Internal_pop_if_present( &_Dest );
    }

    /// <summary>
    ///     Returns the number of items in the queue. This method is not concurrency-safe.
    /// </summary>
    /// <returns>
    ///     The size of the concurrent queue.
    /// </returns>
    /// <remarks>
    ///     <c>unsafe_size</c> is not concurrency-safe and can produce incorrect results if called concurrently
    ///     with calls to the methods <c>push</c>, <c>try_pop</c>, and <c>empty</c>.
    /// </remarks>
    /**/
    size_type unsafe_size() const
    {
        return _Internal_size();
    }

    /// <summary>
    ///     Tests if the concurrent queue is empty at the moment this method is called. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the concurrent queue was empty at the moment we looked, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     While this method is concurrency-safe with respect to calls to the methods <c>push</c>, <c>try_pop</c>, and
    ///     <c>empty</c>, the value returned might be incorrect by the time it is inspected by the calling thread.
    /// </remarks>
    /**/
    bool empty() const
    {
        return _Internal_empty();
    }

    /// <summary>
    ///     Returns a copy of the allocator used to construct the concurrent queue. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     A copy of the allocator used to construct the concurrent queue.
    /// </returns>
    /**/
    allocator_type get_allocator() const
    {
        return this->_My_allocator;
    }

    /// <summary>
    ///     Clears the concurrent queue, destroying any currently enqueued elements. This method is not concurrency-safe.
    /// </summary>
    /**/
    void clear();

    /// <summary>
    ///     A type that represents a non-thread-safe iterator over the elements in a concurrent queue.
    /// </summary>
    /**/
    typedef details::_Concurrent_queue_iterator<concurrent_queue,_Ty> iterator;

    /// <summary>
    ///     A type that represents a non-thread-safe <c>const</c> iterator over elements in a concurrent queue.
    /// </summary>
    /**/
    typedef details::_Concurrent_queue_iterator<concurrent_queue,const _Ty> const_iterator;

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     beginning of the concurrent queue. This method is not concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     beginning of the  concurrent queue object.
    /// </returns>
    /// <remarks>
    ///     The iterators for the <c>concurrent_queue</c> class are primarily intended for debugging, as they are slow, and iteration
    ///     is not concurrency-safe with respect to other queue operations.
    /// </remarks>
    /**/
    iterator unsafe_begin()
    {
        return iterator(*this);
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     end of the concurrent queue. This method is not concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     end of the concurrent queue.
    /// </returns>
    /// <remarks>
    ///     The iterators for the <c>concurrent_queue</c> class are primarily intended for debugging, as they are slow, and iteration
    ///     is not concurrency-safe with respect to other queue operations.
    /// </remarks>
    /**/
    iterator unsafe_end()
    {
        return iterator();
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     beginning of the concurrent queue. This method is not concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     beginning of the concurrent queue.
    /// </returns>
    /// <remarks>
    ///     The iterators for the <c>concurrent_queue</c> class are primarily intended for debugging, as they are slow, and iteration
    ///     is not concurrency-safe with respect to other queue operations.
    /// </remarks>
    /**/
    const_iterator unsafe_begin() const
    {
        return const_iterator(*this);
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     end of the concurrent queue. This method is not concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the
    ///     end of the concurrent queue.
    /// </returns>
    /// <remarks>
    ///     The iterators for the <c>concurrent_queue</c> class are primarily intended for debugging, as they are slow, and iteration
    ///     is not concurrency-safe with respect to other queue operations.
    /// </remarks>
    /**/
    const_iterator unsafe_end() const 
    {
        return const_iterator();
    }
}; 


/// <summary>
///     Constructs a concurrent queue.
/// </summary>
/// <param name="_OtherQ">
///     The source <c>concurrent_queue</c> object to copy elements from.
/// </param>
/// <param name="_Al">
///     The allocator class to use with this object.
/// </param>
/// <remarks>
///     All constructors store an allocator object <paramref name="_Al"/> and initialize the queue.
///     <para>The first constructor specifies an empty initial queue and explicitly specifies the allocator
///     type to be used</para>
///     <para>The second constructor specifies a copy of the concurrent queue <paramref name="_OtherQ"/>.</para>
///     <para>The third constructor specifies values supplied by the iterator range 
///     [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
/// </remarks>
/**/
template<typename _Ty, class _Ax>
concurrent_queue<_Ty,_Ax>::concurrent_queue(const concurrent_queue& _Queue, const allocator_type& _Al = allocator_type())
    : _Concurrent_queue_base_v4( sizeof(_Ty) ), _My_allocator(_Al)
{
    concurrent_queue::const_iterator _QEnd = _Queue.unsafe_end();
    for (concurrent_queue::const_iterator _It = _Queue.unsafe_begin(); _It != _QEnd; ++_It)
        this->push(*_It);
}

/// <summary>
///     Destroys the concurrent queue.
/// </summary>
/**/
template<typename _Ty, class _Ax>
concurrent_queue<_Ty,_Ax>::~concurrent_queue()
{
    clear();
    _Internal_finish_clear();
}

/// <summary>
///     Clears the concurrent queue, destroying any currently enqueued elements. This method is not concurrency-safe.
/// </summary>
/**/
template<typename _Ty, class _Ax>
void concurrent_queue<_Ty,_Ax>::clear()
{
    while( !empty() )
    {
        char _Buf[sizeof(_Ty)];
        if (!_Internal_pop_if_present(reinterpret_cast<_Ty*>(_Buf)))
        {
            _ASSERTE(empty());
            break;
        }
    }
}

} // namespace Concurrency

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\concurrent_vector.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
* Microsoft would like to acknowledge that this concurrency data structure implementation
* is based on Intels implementation in its Threading Building Blocks ("Intel Material").
* 
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* concurrent_vector.h
*
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

/*
    Intel Material Copyright 2005-2008 Intel Corporation.  All Rights Reserved.
*/


#pragma once

#include <crtdefs.h>
#include <memory>
#include <iterator>
#include <limits>
#include <algorithm>
#include <cstring>
#include <crtdbg.h>
#include <concrt.h>

#if !(defined(_M_AMD64) || defined(_M_IX86))
    #error ERROR: Concurrency Runtime is supported only on X64 and X86 architectures.
#endif

#if defined(_M_CEE)
    #error ERROR: Concurrency Runtime is not supported when compiling /clr.
#endif

#pragma pack(push,_CRT_PACKING)

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{

template<typename _Ty, class _Ax = std::allocator<_Ty> >
class concurrent_vector;

namespace details
{

    // Bad allocation marker
    #define _BAD_ALLOC_MARKER reinterpret_cast<void*>(63)
    
    // Base class of concurrent vector implementation.
    class _Concurrent_vector_base_v4
    {
    protected:

        // Basic types declarations
        typedef size_t _Segment_index_t;
        typedef size_t _Size_type;

        // Size constants
        static const _Segment_index_t _Default_initial_segments = 1; // 2 initial items
 
        // Number of slots for segment's pointers inside the class
        static const _Segment_index_t _Pointers_per_short_table = 3; // to fit into 8 words of entire structure
        static const _Segment_index_t _Pointers_per_long_table = sizeof(_Segment_index_t) * 8; // one segment per bit

        // Segment pointer. Can be zero-initialized
        struct _Segment_t
        {
            void* _My_array;
        };
 
        // Data fields

        // allocator function pointer
        void* (*_My_vector_allocator_ptr)(_Concurrent_vector_base_v4 &, size_t);

        // embedded storage of segment pointers
        _Segment_t _My_storage[_Pointers_per_short_table];

        // Methods

        _Concurrent_vector_base_v4() 
        {
            _My_early_size = 0;
            _My_first_block = 0; // here is not _Default_initial_segments
            for( _Segment_index_t _I = 0; _I < _Pointers_per_short_table; _I++)
                _My_storage[_I]._My_array = NULL;
            _My_segment = _My_storage;
        }
        _CRTIMP2 ~_Concurrent_vector_base_v4();

        _CRTIMP2 static _Segment_index_t __cdecl _Segment_index_of( _Size_type _Index );

        static _Segment_index_t _Segment_base( _Segment_index_t _K )
        {
            return (_Segment_index_t(1)<<_K & ~_Segment_index_t(1));
        }

        static _Segment_index_t _Segment_base_index_of( _Segment_index_t &_Index )
        {
            _Segment_index_t _K = _Segment_index_of( _Index );
            _Index -= _Segment_base(_K);
            return _K;
        }

        static _Size_type _Segment_size( _Segment_index_t _K )
        {
            return _Segment_index_t(1)<<_K; // fake value for _K==0
        }

        // An operation on an n-element array starting at begin.
        typedef void (*_My_internal_array_op1)(void* _Begin, _Size_type _N );

        // An operation on n-element destination array and n-element source array.
        typedef void (*_My_internal_array_op2)(void* _Dst, const void* _Src, _Size_type _N );

        // Internal structure for shrink_to_fit()
        struct _Internal_segments_table
        {
            _Segment_index_t _First_block;
            void* _Table[_Pointers_per_long_table];
        };

        _CRTIMP2 void _Internal_reserve( _Size_type _N, _Size_type _Element_size, _Size_type _Max_size );
        _CRTIMP2 _Size_type _Internal_capacity() const;
        void _Internal_grow( _Size_type _Start, _Size_type _Finish, _Size_type _Element_size, _My_internal_array_op2 _Init, const void *_Src );
        _Size_type _Internal_grow_segment( const _Size_type _Start, _Size_type _Finish, _Size_type _Element_size, _Segment_t** _PPSegment, _Size_type* _PSegStart, _Size_type* _PSegFinish );
        _CRTIMP2 _Size_type _Internal_grow_by( _Size_type _Delta, _Size_type _Element_size, _My_internal_array_op2 _Init, const void *_Src );
        _CRTIMP2 void* _Internal_push_back( _Size_type _Element_size, _Size_type& _Index );
        _CRTIMP2 _Segment_index_t _Internal_clear( _My_internal_array_op1 _Destroy );
        void _Internal_truncate( _Size_type _Old_size, _Size_type _New_size, _Size_type _Element_size, _My_internal_array_op1 _Destroy);
        _CRTIMP2 void* _Internal_compact( _Size_type _Element_size, void *_Table, _My_internal_array_op1 _Destroy, _My_internal_array_op2 _Copy );
        _CRTIMP2 void _Internal_copy( const _Concurrent_vector_base_v4& _Src, _Size_type _Element_size, _My_internal_array_op2 _Copy );
        _CRTIMP2 void _Internal_assign( const _Concurrent_vector_base_v4& _Src, _Size_type _Element_size,
                              _My_internal_array_op1 _Destroy, _My_internal_array_op2 _Assign, _My_internal_array_op2 _Copy );
        _CRTIMP2 void _Internal_throw_exception(_Size_type) const;
        _CRTIMP2 void _Internal_swap(_Concurrent_vector_base_v4&);

        _CRTIMP2 void _Internal_resize( _Size_type _New_size, _Size_type _Element_size, _Size_type _Max_size, _My_internal_array_op1 _Destroy, _My_internal_array_op2 _Init, const void* _Src);
        _CRTIMP2 _Size_type _Internal_grow_to_at_least_with_result( _Size_type _New_size, _Size_type _Element_size, _My_internal_array_op2 _Init, const void *_Src );

        // count of segments in the first block
        _Subatomic<_Size_type> _My_first_block;

        // Requested size of vector
        _Subatomic<_Size_type> _My_early_size;

        // Pointer to the segments table
        _Subatomic<_Segment_t*> _My_segment;


    private:
        // Private functionality
        class _Helper;
        friend class _Helper;
    };
    
    typedef _Concurrent_vector_base_v4 _Concurrent_vector_base;

    // Meets requirements of a forward iterator for STL.*/
    /** _Value is either the _Ty or const _Ty type of the container. */
    template<typename _Container, typename _Value>
    class _Vector_iterator 
    {
        // concurrent_vector over which we are iterating.
        _Container* _My_vector;

        // Index into the vector 
        size_t _My_index;

        // Caches _My_vector-&gt;_Internal_subscript(_My_index)
        /** NULL if cached value is not available */
        mutable _Value* _My_item;

        template<typename _C, typename _Ty>
        friend _Vector_iterator<_C,_Ty> operator+( ptrdiff_t _Offset, const _Vector_iterator<_C,_Ty>& _Vec );

        template<typename _C, typename _Ty, typename _U>
        friend bool operator==( const _Vector_iterator<_C,_Ty>&, const _Vector_iterator<_C,_U>& );

        template<typename _C, typename _Ty, typename _U>
        friend bool operator<( const _Vector_iterator<_C,_Ty>&, const _Vector_iterator<_C,_U>& );

        template<typename _C, typename _Ty, typename _U>
        friend ptrdiff_t operator-( const _Vector_iterator<_C,_Ty>&, const _Vector_iterator<_C,_U>& );
    
        template<typename _C, typename _U>
        friend class ::Concurrency::details::_Vector_iterator;

        template<typename _Ty, class _Ax>
        friend class ::Concurrency::concurrent_vector;

        _Vector_iterator( const _Container& _Vec, size_t _Index, void* _Ptr = NULL )
            : _My_vector(const_cast<_Container*>(&_Vec)), 
              _My_index(_Index), 
              _My_item(static_cast<_Value*>(_Ptr))
        {
        }

    public:
        // Default constructor
        _Vector_iterator()
            : _My_vector(NULL), _My_index(~size_t(0)), _My_item(NULL)
        {
        }

        _Vector_iterator( const _Vector_iterator<_Container,typename _Container::value_type>& _Other )
            : _My_vector(_Other._My_vector),
              _My_index(_Other._My_index),
              _My_item(_Other._My_item)
        {
        }

        _Vector_iterator operator+( ptrdiff_t _Offset ) const
        {
            return _Vector_iterator( *_My_vector, _My_index+_Offset );
        }
        _Vector_iterator& operator+=( ptrdiff_t _Offset ) 
        {
            _My_index+=_Offset;
            _My_item = NULL;
            return *this;
        }
        _Vector_iterator operator-( ptrdiff_t _Offset ) const
        {
            return _Vector_iterator( *_My_vector, _My_index-_Offset );
        }
        _Vector_iterator& operator-=( ptrdiff_t _Offset ) 
        {
            _My_index-=_Offset;
            _My_item = NULL;
            return *this;
        }
        _Value& operator*() const 
        {
            _Value* _Item = _My_item;
            if( !_Item )
                _Item = _My_item = &_My_vector->_Internal_subscript(_My_index);
            _ASSERTE( _Item==&_My_vector->_Internal_subscript(_My_index));  // corrupt cache
            return *_Item;
        }
        _Value& operator[]( ptrdiff_t _K ) const
        {
            return _My_vector->_Internal_subscript(_My_index+_K);
        }
        _Value* operator->() const 
        {
            return &operator*();
        }

        // Pre increment
        _Vector_iterator& operator++()
        {
            size_t _K = ++_My_index;
            if( _My_item )
            {
                // Following test uses 2's-complement wizardry
                if( (_K& (_K-2))==0 )
                {
                    // _K is a power of two that is at least _K-2
                    _My_item= NULL;
                }
                else
                {
                    ++_My_item;
                }
            }
            return *this;
        }

        // Pre decrement
        _Vector_iterator& operator--() 
        {
            _ASSERTE( _My_index>0 ); // operator--() applied to iterator already at beginning of concurrent_vector
            size_t _K = _My_index--;
            if( _My_item )
            {
                // Following test uses 2's-complement wizardry
                if( (_K& (_K-2))==0 )
                {
                    // k is a power of two that is at least k-2  
                    _My_item= NULL;
                }
                else
                {
                    --_My_item;
                }
            }
            return *this;
        }

        // Post increment
        _Vector_iterator operator++(int)
        {
            _Vector_iterator _Result = *this;
            operator++();
            return _Result;
        }

        // Post decrement
        _Vector_iterator operator--(int)
        {
            _Vector_iterator _Result = *this;
            operator--();
            return _Result;
        }

        // STL support

        typedef ptrdiff_t difference_type;
        typedef _Value value_type;
        typedef _Value* pointer;
        typedef _Value& reference;
        typedef std::random_access_iterator_tag iterator_category;
    };

    template<typename _Container, typename _Ty>
    _Vector_iterator<_Container,_Ty> operator+( ptrdiff_t _Offset, const _Vector_iterator<_Container,_Ty>& _Vec )
    {
        return _Vector_iterator<_Container,_Ty>( *_Vec._My_vector, _Vec._My_index+_Offset );
    }

    template<typename _Container, typename _Ty, typename _U>
    bool operator==( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J )
    {
        return _I._My_index==_J._My_index && _I._My_vector == _J._My_vector;
    }

    template<typename _Container, typename _Ty, typename _U>
    bool operator!=( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J )
    {
        return !(_I==_J);
    }

    template<typename _Container, typename _Ty, typename _U>
    bool operator<( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J ) 
    {
        return _I._My_index<_J._My_index && _I._My_vector == _J._My_vector;
    }

    template<typename _Container, typename _Ty, typename _U>
    bool operator>( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J )
    {
        return _J<_I;
    }

    template<typename _Container, typename _Ty, typename _U>
    bool operator>=( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J ) 
    {
        return !(_I<_J);
    }

    template<typename _Container, typename _Ty, typename _U>
    bool operator<=( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J )
    {
        return !(_J<_I);
    }

    template<typename _Container, typename _Ty, typename _U>
    ptrdiff_t operator-( const _Vector_iterator<_Container,_Ty>& _I, const _Vector_iterator<_Container,_U>& _J )
    {
        return ptrdiff_t(_I._My_index)-ptrdiff_t(_J._My_index);
    }

    template<typename _Ty, class _Ax>
    class _Allocator_base
    {
    public:
        typedef typename _Ax::template
            rebind<_Ty>::other _Allocator_type;
        _Allocator_type _My_allocator;

        _Allocator_base(const _Allocator_type &_Al = _Allocator_type() )
            : _My_allocator(_Al)
        {
        }
    };

} // namespace details

/// <summary>
///     The <c>concurrent_vector</c> class is a sequence container class that allows random access to any element.
///     It enables concurrency-safe append, element access, iterator access and iterator traversal operations.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements to be stored in the vector.
/// </typeparam>
/// <typeparam name="_Ax">
///     The type that represents the stored allocator object that encapsulates details about the allocation and
///     deallocation of memory for the concurrent vector. This argument is optional and the default value is
///     <c>allocator&lt;</c><typeparamref name="_Ty"/><c>&gt;</c>.
/// </typeparam>
/// <remarks>
///     For detailed information on the <c>concurrent_vector</c> class, see <see cref="Parallel Containers and Objects"/>.
/// </remarks>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class _Ax>
class concurrent_vector: protected details::_Allocator_base<_Ty, _Ax>,
                         private details::_Concurrent_vector_base_v4
{
private:
	typedef concurrent_vector<_Ty, _Ax> _Myt;

    template<typename _C, typename _U>
    friend class details::_Vector_iterator;

public:

    /// <summary>
    ///     A type that counts the number of elements in a concurrent vector.
    /// </summary>
    /**/
    typedef details::_Concurrent_vector_base_v4::_Size_type size_type;

    /// <summary>
    ///     A type that represents the allocator class for the concurrent vector.
    /// </summary>
    /**/
    typedef typename details::_Allocator_base<_Ty, _Ax>::_Allocator_type allocator_type;

    /// <summary>
    ///     A type that represents the data type stored in a concurrent vector.
    /// </summary>
    /**/
    typedef _Ty value_type;

    /// <summary>
    /// A type that provides the signed distance between two elements in a concurrent vector.
    /// </summary>
    /**/
    typedef ptrdiff_t difference_type;

    /// <summary>
    ///     A type that provides a reference to an element stored in a concurrent vector.
    /// </summary>
    /**/
    typedef _Ty& reference;

    /// <summary>
    ///     A type that provides a reference to a <c>const</c> element stored in a concurrent vector for reading and
    ///     performing <c>const</c> operations.
    /// </summary>
    /**/
    typedef const _Ty& const_reference;

    /// <summary>
    ///     A type that provides a pointer to an element in a concurrent vector.
    /// </summary>
    /**/
    typedef _Ty *pointer;

    /// <summary>
    ///     A type that provides a pointer to a <c>const</c> element in a concurrent vector.
    /// </summary>
    /**/
    typedef const _Ty *const_pointer;

    /// <summary>
    ///     A type that provides a random-access iterator that can read any element in a concurrent vector. Modification of an
    ///     element using the iterator is not concurrency-safe.
    /// </summary>
    /**/
    typedef details::_Vector_iterator<concurrent_vector,_Ty> iterator;

    /// <summary>
    ///     A type that provides a random-access iterator that can read a <c>const</c> element in a concurrent vector.
    /// </summary>
    /**/
    typedef details::_Vector_iterator<concurrent_vector,const _Ty> const_iterator;

    /// <summary>
    ///     A type that provides a random-access iterator that can read any element in a reversed concurrent vector. Modification of an
    ///     element using the iterator is not concurrency-safe.
    /// </summary>
    /**/
    typedef std::reverse_iterator<iterator> reverse_iterator;

    /// <summary>
    ///     A type that provides a random-access iterator that can read any <c>const</c> element in the concurrent vector.
    /// </summary>
    /**/
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    /// <summary>
    ///     Constructs a concurrent vector.
    /// </summary>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the vector.
    ///     <para>The first constructor specify an empty initial vector and explicitly specifies the allocator type.
    ///     to be used.</para>
    ///     <para>The second and third constructors specify a copy of the concurrent vector <paramref name="_Vector"/>.</para>
    ///     <para>The fourth constructor specifies a repetition of a specified number (<paramref name="_N"/>) of elements of the default
    ///     value for class <typeparamref name="_Ty"/>.</para>
    ///     <para>The fifth constructor specifies a repetition of (<paramref name="_N"/>) elements of value <paramref name="_Item"/>.</para>
    ///     <para>The last constructor specifies values supplied by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    explicit concurrent_vector(const allocator_type &_Al = allocator_type())
        : details::_Allocator_base<_Ty, _Ax>(_Al)
    {
        _My_vector_allocator_ptr = &_Internal_allocator;
    }

    /// <summary>
    ///     Constructs a concurrent vector.
    /// </summary>
    /// <param name="_Vector">
    ///     The source <c>concurrent_vector</c> object to copy elements from.
    /// </param>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the vector.
    ///     <para>The first constructor specify an empty initial vector and explicitly specifies the allocator type.
    ///     to be used.</para>
    ///     <para>The second and third constructors specify a copy of the concurrent vector <paramref name="_Vector"/>.</para>
    ///     <para>The fourth constructor specifies a repetition of a specified number (<paramref name="_N"/>) of elements of the default
    ///     value for class <typeparamref name="_Ty"/>.</para>
    ///     <para>The fifth constructor specifies a repetition of (<paramref name="_N"/>) elements of value <paramref name="_Item"/>.</para>
    ///     <para>The last constructor specifies values supplied by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    concurrent_vector( const concurrent_vector& _Vector, const allocator_type& _Al = allocator_type() )
        : details::_Allocator_base<_Ty, _Ax>(_Al)
    {
        _My_vector_allocator_ptr = &_Internal_allocator;
        _Internal_copy(_Vector, sizeof(_Ty), &_Copy_array);
    }

    /// <summary>
    ///     Constructs a concurrent vector.
    /// </summary>
    /// <typeparam name="M">
    ///     The allocator type of the source vector.
    /// </typeparam>
    /// <param name="_Vector">
    ///     The source <c>concurrent_vector</c> object to copy elements from.
    /// </param>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the vector.
    ///     <para>The first constructor specify an empty initial vector and explicitly specifies the allocator type.
    ///     to be used.</para>
    ///     <para>The second and third constructors specify a copy of the concurrent vector <paramref name="_Vector"/>.</para>
    ///     <para>The fourth constructor specifies a repetition of a specified number (<paramref name="_N"/>) of elements of the default
    ///     value for class <typeparamref name="_Ty"/>.</para>
    ///     <para>The fifth constructor specifies a repetition of (<paramref name="_N"/>) elements of value <paramref name="_Item"/>.</para>
    ///     <para>The last constructor specifies values supplied by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    template<class M>
    concurrent_vector( const concurrent_vector<_Ty, M>& _Vector, const allocator_type& _Al = allocator_type() )
        : details::_Allocator_base<_Ty, _Ax>(_Al)
    {
        _My_vector_allocator_ptr = &_Internal_allocator;
        _Internal_copy(_Vector._Internal_vector_base(), sizeof(_Ty), &_Copy_array);
    }

    /// <summary>
    ///     Constructs a concurrent vector.
    /// </summary>
    /// <param name="_N">
    ///     The initial size of the <c>concurrent_vector</c> object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the vector.
    ///     <para>The first constructor specify an empty initial vector and explicitly specifies the allocator type.
    ///     to be used.</para>
    ///     <para>The second and third constructors specify a copy of the concurrent vector <paramref name="_Vector"/>.</para>
    ///     <para>The fourth constructor specifies a repetition of a specified number (<paramref name="_N"/>) of elements of the default
    ///     value for class <typeparamref name="_Ty"/>.</para>
    ///     <para>The fifth constructor specifies a repetition of (<paramref name="_N"/>) elements of value <paramref name="_Item"/>.</para>
    ///     <para>The last constructor specifies values supplied by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    explicit concurrent_vector(size_type _N)
    {
        _My_vector_allocator_ptr = &_Internal_allocator;
        if ( !_N ) return;
        _Internal_reserve(_N, sizeof(_Ty), max_size()); _My_early_size = _N;
        _ASSERTE( _My_first_block == _Segment_index_of(_N-1)+1 );
        _Initialize_array(static_cast<_Ty*>(_My_segment[0]._My_array), NULL, _N);
    }

    /// <summary>
    ///     Constructs a concurrent vector.
    /// </summary>
    /// <param name="_N">
    ///     The initial capacity of the <c>concurrent_vector</c> object.
    /// </param>
    /// <param name="_Item">
    ///     The value of elements in the constructed object.
    /// </param>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the vector.
    ///     <para>The first constructor specify an empty initial vector and explicitly specifies the allocator type.
    ///     to be used.</para>
    ///     <para>The second and third constructors specify a copy of the concurrent vector <paramref name="_Vector"/>.</para>
    ///     <para>The fourth constructor specifies a repetition of a specified number (<paramref name="_N"/>) of elements of the default
    ///     value for class <typeparamref name="_Ty"/>.</para>
    ///     <para>The fifth constructor specifies a repetition of (<paramref name="_N"/>) elements of value <paramref name="_Item"/>.</para>
    ///     <para>The last constructor specifies values supplied by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    concurrent_vector(size_type _N, const_reference _Item, const allocator_type& _Al = allocator_type())
        : details::_Allocator_base<_Ty, _Ax>(_Al)
    {
        _My_vector_allocator_ptr = &_Internal_allocator;
        _Internal_assign( _N, _Item );
    }

    /// <summary>
    ///     Constructs a concurrent vector.
    /// </summary>
    /// <typeparam name="_InputIterator">
    ///     The type of the input iterator.
    /// </typeparam>
    /// <param name="_Begin">
    ///     Position of the first element in the range of elements to be copied.
    /// </param>
    /// <param name="_End">
    ///     Position of the first element beyond the range of elements to be copied.
    /// </param>
    /// <param name="_Al">
    ///     The allocator class to use with this object.
    /// </param>
    /// <remarks>
    ///     All constructors store an allocator object <paramref name="_Al"/> and initialize the vector.
    ///     <para>The first constructor specify an empty initial vector and explicitly specifies the allocator type.
    ///     to be used.</para>
    ///     <para>The second and third constructors specify a copy of the concurrent vector <paramref name="_Vector"/>.</para>
    ///     <para>The fourth constructor specifies a repetition of a specified number (<paramref name="_N"/>) of elements of the default
    ///     value for class <typeparamref name="_Ty"/>.</para>
    ///     <para>The fifth constructor specifies a repetition of (<paramref name="_N"/>) elements of value <paramref name="_Item"/>.</para>
    ///     <para>The last constructor specifies values supplied by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).</para>
    /// </remarks>
    /**/
    template<class _InputIterator>
    concurrent_vector(_InputIterator _Begin, _InputIterator _End, const allocator_type &_Al = allocator_type())
        : details::_Allocator_base<_Ty, _Ax>(_Al)
    {
        _My_vector_allocator_ptr = &_Internal_allocator;
        _Internal_assign(_Begin, _End, static_cast<_Is_integer_tag<std::numeric_limits<_InputIterator>::is_integer> *>(0) );
    }

    /// <summary>
    ///     Assigns the contents of another <c>concurrent_vector</c> object to this one. This method is not concurrency-safe.
    /// </summary>
    /// <param name="_Vector">
    ///     The source <c>concurrent_vector</c> object.
    /// </param>
    /// <returns>
    ///     A reference to this <c>concurrent_vector</c> object.
    /// </returns>
    /**/
    concurrent_vector& operator=( const concurrent_vector& _Vector )
    {
        if( this != &_Vector )
            _Concurrent_vector_base_v4::_Internal_assign(_Vector, sizeof(_Ty), &_Destroy_array, &_Assign_array, &_Copy_array);
        return *this;
    }

    /// <summary>
    ///     Assigns the contents of another <c>concurrent_vector</c> object to this one. This method is not concurrency-safe.
    /// </summary>
    /// <typeparam name="M">
    ///     The allocator type of the source vector.
    /// </typeparam>
    /// <param name="_Vector">
    ///     The source <c>concurrent_vector</c> object.
    /// </param>
    /// <returns>
    ///     A reference to this <c>concurrent_vector</c> object.
    /// </returns>
    /**/
    template<class M>
    concurrent_vector& operator=( const concurrent_vector<_Ty, M>& _Vector )
    {
        if( static_cast<void*>( this ) != static_cast<const void*>( &_Vector ) )
        {
            _Concurrent_vector_base_v4::_Internal_assign(_Vector._Internal_vector_base(),
                                                         sizeof(_Ty), &_Destroy_array, &_Assign_array, &_Copy_array);
        }
        return *this;
    }

    /// <summary>
    ///     Grows this concurrent vector by <paramref name="_Delta"/> elements. This method is concurrency-safe.
    /// </summary>
    /// <param name="_Delta">
    ///     The number of elements to append to the object.
    /// </param>
    /// <returns>
    ///     An iterator to first item appended.
    /// </returns>
    /// <remarks>
    ///     If <paramref name="_Item"/> is not specified, the new elements are default constructed.
    /// </remarks>
    /**/
    iterator grow_by( size_type _Delta ) 
    {
        return iterator(*this, _Delta ? _Internal_grow_by( _Delta, sizeof(_Ty), &_Initialize_array, NULL ) : _My_early_size);
    }

    /// <summary>
    ///     Grows this concurrent vector by <paramref name="_Delta"/> elements. This method is concurrency-safe.
    /// </summary>
    /// <param name="_Delta">
    ///     The number of elements to append to the object.
    /// </param>
    /// <param name="_Item">
    ///     The value to initialize the new elements with.
    /// </param>
    /// <returns>
    ///     An iterator to first item appended.
    /// </returns>
    /// <remarks>
    ///     If <paramref name="_Item"/> is not specified, the new elements are default constructed.
    /// </remarks>
    /**/
    iterator grow_by( size_type _Delta, const_reference _Item )
    {
        return iterator(*this, _Delta ? _Internal_grow_by( _Delta, sizeof(_Ty), &_Initialize_array_by, static_cast<const void*>(&_Item) ) : _My_early_size);
    }

    /// <summary>
    ///     Grows this concurrent vector until it has at least <paramref name="_N"/> elements. This method is concurrency-safe.
    /// </summary>
    /// <param name="_N">
    ///     The new minimum size for the <c>concurrent_vector</c> object.
    /// </param>
    /// <returns>
    ///     An iterator that points to beginning of appended sequence, or to the element at index <paramref name="_N"/> if no
    ///     elements were appended.
    /// </returns>
    /**/
    iterator grow_to_at_least( size_type _N )
    {
        size_type _M = 0;
        if( _N )
        {
            _M = _Internal_grow_to_at_least_with_result( _N, sizeof(_Ty), &_Initialize_array, NULL );
            if( _M > _N )
                _M = _N;
        }
        return iterator(*this, _M);
    };

    /// <summary>
    ///     Appends the given item to the end of the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <param name="_Item">
    ///     The value to be appended.
    /// </param>
    /// <returns>
    ///     An iterator to item appended.
    /// </returns>
    /**/
    iterator push_back( const_reference _Item )
    {
        size_type _K;
        void *_Ptr = _Internal_push_back(sizeof(_Ty), _K);
        _Internal_loop_guide _Loop(1, _Ptr);
        _Loop._Init(&_Item);
        return iterator(*this, _K, _Ptr);
    }

    /// <summary>
    ///     Provides access to the element at the given index in the concurrent vector. This method is concurrency-safe for read operations,
    ///     and also while growing the vector, as long as the you have ensured that the value <paramref name="_Index"/> is less than
    ///     the size of the concurrent vector.
    /// </summary>
    /// <param name="_Index">
    ///     The index of the element to be retrieved.
    /// </param>
    /// <returns>
    ///     A reference to the item at the given index.
    /// </returns>
    /// <remarks>
    ///     The version of <c>operator []</c> that returns a non-<c>const</c> refernce cannot be used to concurrently write to the element
    ///     from different threads. A different synchronization object should be used to synchronize concurrent read and write operations
    ///     to the same data element.
    ///     <para>No bounds checking is performed to ensure that <paramref name="_Index"/> is a valid index into the concurrent vector.</para>
    /// </remarks>
    /**/
    reference operator[]( size_type _Index )
    {
        return _Internal_subscript(_Index);
    }

    /// <summary>
    ///     Provides read access to element at the given index in the concurrent vector. This method is concurrency-safe for read operations,
    ///     and also while growing the vector, as long as the you have ensured that the value <paramref name="_Index"/> is less than
    ///     the size of the concurrent vector.
    /// </summary>
    /// <param name="_Index">
    ///     The index of the element to be retrieved.
    /// </param>
    /// <returns>
    ///     A <c>const</c> reference to the item at the given index.
    /// </returns>
    /// <remarks>
    ///     The version of <c>operator []</c> that returns a non-<c>const</c> refernce cannot be used to concurrently write to the element
    ///     from different threads. A different synchronization object should be used to synchronize concurrent read and write operations
    ///     to the same data element.
    ///     <para>No bounds checking is performed to ensure that <paramref name="_Index"/> is a valid index into the concurrent vector.</para>
    /// </remarks>
    /**/
    const_reference operator[]( size_type _Index ) const 
    {
        return _Internal_subscript(_Index);
    }

    /// <summary>
    ///     Provides access to the element at the given index in the concurrent vector. This method is concurrency-safe for read operations,
    ///     and also while growing the vector, as long as you have ensured that the value <paramref name="_Index"/> is less than
    ///     the size of the concurrent vector.
    /// </summary>
    /// <param name="_Index">
    ///     The index of the element to be retrieved.
    /// </param>
    /// <returns>
    ///     A reference to the item at the given index.
    /// </returns>
    /// <remarks>
    ///     The version of the function <c>at</c> that returns a non-<c>const</c> refernce cannot be used to concurrently write to the element
    ///     from different threads. A different synchronization object should be used to synchronize concurrent read and write operations
    ///     to the same data element.
    ///     <para>The method throws <c>out_of_range</c> if <paramref name="_Index"/> is greater than or equal to the size of the concurrent vector,
    ///     and <c>range_error</c> if the index is for a broken portion of the vector. For details on how a vector can become broken,
    ///     see <see cref="Parallel Containers and Objects"/>.</para>
    /// </remarks>
    /**/
    reference at( size_type _Index )
    {
        return _Internal_subscript_with_exceptions(_Index);
    }

    /// <summary>
    ///     Provides access to the element at the given index in the concurrent vector. This method is concurrency-safe for read operations,
    ///     and also while growing the vector, as long as you have ensured that the value <paramref name="_Index"/> is less than
    ///     the size of the concurrent vector.
    /// </summary>
    /// <param name="_Index">
    ///     The index of the element to be retrieved.
    /// </param>
    /// <returns>
    ///     A <c>const</c> reference to the item at the given index.
    /// </returns>
    /// <remarks>
    ///     The version of the function <c>at</c> that returns a non-<c>const</c> refernce cannot be used to concurrently write to the element
    ///     from different threads. A different synchronization object should be used to synchronize concurrent read and write operations
    ///     to the same data element.
    ///     <para>The method throws <c>out_of_range</c> if <paramref name="_Index"/> is greater than or equal to the size of the concurrent vector,
    ///     and <c>range_error</c> if the index is for a broken portion of the vector. For details on how a vector can become broken,
    ///     see <see cref="Parallel Containers and Objects"/>.</para>
    /// </remarks>
    /**/
    const_reference at( size_type _Index ) const
    {
        return _Internal_subscript_with_exceptions(_Index);
    }

    /// <summary>
    ///     Returns the number of elements in the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     The number of elements in this <c>concurrent_vector</c> object.
    /// </returns>
    /// <remarks>
    ///     The returned size is guaranteed to include all elements appended by calls to the function <c>push_back</c>,
    ///     or grow operations that have completed prior to invoking this method. However, it may also include elements
    ///     that are allocated but still under construction by concurrent calls to any of the growth methods.
    /// </remarks>
    /**/
    size_type size() const
    { 
        size_type _Sz = _My_early_size;
        size_type _Cp = _Internal_capacity();
        return _Cp < _Sz ? _Cp : _Sz;
    }

    /// <summary>
    ///     Tests if the concurrent vector is empty at the time this method is called. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the vector was empty at the moment the function was called, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool empty() const
    {
        return !_My_early_size;
    }

    /// <summary>
    ///     Returns the maximum size to which the concurrent vector can grow without having to allocate more memory.
    ///     This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     The maximum size to which the concurrent bector can grow without having to allocate more memory.
    /// </returns>
    /// <remarks>
    ///     Unlike an STL <c>vector</c>, a <c>concurrent_vector</c> object does not move existing elements if it allocates more memory.
    /// </remarks>
    /**/
    size_type capacity() const
    {
        return _Internal_capacity();
    }

    /// <summary>
    ///     Allocates enough space to grow the concurrent vector to size <paramref name="_N"/> without having to allocate more memory later.
    ///     This method is not concurrency-safe.
    /// </summary>
    /// <param name="_N">
    ///     The number of elements to reserve space for.
    /// </param>
    /// <remarks>
    ///     <c>reserve</c> is not concurrency-safe. You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this method. The capacity of the concurrent vector after the method returns
    ///     may be bigger than the requested reservation.
    /// </remarks>
    /**/
    void reserve( size_type _N )
    {
        if( _N )
            _Internal_reserve(_N, sizeof(_Ty), max_size());
    }

    /// <summary>
    ///     Compacts the internal representation of the concurrent vector to reduce fragmentation and optimize memory usage.
    ///     This method is not concurrency-safe.
    /// </summary>
    /// <remarks>
    ///     This method will internally re-allocate memory move elements around, invalidating all the iterators.
    ///     <c>shrink_to_fit</c> is not concurrency-safe. You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this function.
    /// </remarks>
    /**/
    void shrink_to_fit();

    /// <summary>
    ///     Changes the size of the concurrent vector to the requested size, deleting or adding elements as
    ///     necessary. This method is not concurrency-safe.
    /// </summary>
    /// <param name="_N">
    ///     The new size of the concurrent vector.
    /// </param>
    /// <remarks>
    ///     If the size of the container is less than the requested size, elements are added to the vector until it reaches the
    ///     requested size. If the size of the container is larger than the requested size, the elements closest to the end of the container
    ///     are deleted until the container reaches the size <paramref name="_N"/>. If the present size of the container is the same as the requested
    ///     size, no action is taken.
    ///     <para><c>resize</c> is not concurrency safe.  You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this method.</para>
    /// </remarks>
    /**/
    void resize(size_type _N)
    {
        _Internal_resize( _N, sizeof(_Ty), max_size(), _Destroy_array, _Initialize_array, NULL);
    }

    /// <summary>
    ///     Changes the size of the concurrent vector to the requested size, deleting or adding elements as
    ///     necessary. This method is not concurrency-safe.
    /// </summary>
    /// <param name="_N">
    ///     The new size of the concurrent_vector.
    /// </param>
    /// <param name="_Val">
    ///     The value of new elements added to the vector if the new size is larger that the original size. If the value is omitted,
    ///     the new objects are assigned the default value for their type.
    /// </param>
    /// <remarks>
    ///     If the size of the container is less than the requested size, elements are added to the vector until it reaches the
    ///     requested size. If the size of the container is larger than the requested size, the elements closest to the end of the container
    ///     are deleted until the container reaches the size <paramref name="_N"/>. If the present size of the container is the same as the requested
    ///     size, no action is taken.
    ///     <para><c>resize</c> is not concurrency safe.  You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this method.</para>
    /// </remarks>
    /**/
    void resize(size_type _N, const _Ty& _Val) 
    {
        _Internal_resize( _N, sizeof(_Ty), max_size(), _Destroy_array, _Initialize_array_by, static_cast<const void*>(&_Val) );
    }

    /// <summary>
    ///     Returns the maximum number of elements the concurrent vector can hold. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     The maximum number of elements the <c>concurrent_vector</c> object can hold.
    /// </returns>
    /**/
    size_type max_size() const 
    {
        return (~size_type(0))/sizeof(_Ty);
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the beginning of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the beginning of
    ///     the concurrent vector.
    /// </returns>
    /**/
    iterator begin() 
    {
        return iterator(*this,0);
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the end of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the end of
    ///     the concurrent vector.
    /// </returns>
    /**/
    iterator end()
    {
        return iterator(*this,size());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the beginning of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the beginning of
    ///     the concurrent vector.
    /// </returns>
    /**/
    const_iterator begin() const
    {
        return const_iterator(*this,0);
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the end of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="iterator"/> or <typeparamref name="const_iterator"/> to the end of
    ///     the concurrent vector.
    /// </returns>
    /**/
    const_iterator end() const
    {
        return const_iterator(*this,size());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the beginning of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the beginning of
    ///     the concurrent vector.
    /// </returns>
    /**/
    reverse_iterator rbegin() 
    {
        return reverse_iterator(end());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the end of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the end of
    ///     the concurrent vector.
    /// </returns>
    /**/
    reverse_iterator rend()
    {
        return reverse_iterator(begin());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the beginning
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the beginning of
    ///     the concurrent vector.
    /// </returns>
    /**/
    const_reverse_iterator rbegin() const 
    {
        return const_reverse_iterator(end());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the end of
    ///     the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="reverse_iterator"/> or <typeparamref name="const_reverse_iterator"/> to the end of
    ///     the concurrent vector.
    /// </returns>
    /**/
    const_reverse_iterator rend() const 
    {
        return const_reverse_iterator(begin());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="const_iterator"/> to the beginning of the concurrent vector.
    ///     This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="const_iterator"/> to the beginning of the concurrent vector.
    /// </returns>
    /**/
    const_iterator cbegin() const
    { 
        return (((const _Myt *)this)->begin());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="const_iterator"/> to the end of the concurrent vector.
    ///     This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="const_iterator"/> to the end of the concurrent vector.
    /// </returns>
    /**/
    const_iterator cend() const
    { 
        return (((const _Myt *)this)->end());
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="const_reverse_iterator"/> to the beginning of the concurrent vector.
    ///     This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="const_reverse_iterator"/> to the beginning of the concurrent vector.
    /// </returns>
    /**/
    const_reverse_iterator crbegin() const
    { 
        return (((const _Myt *)this)->rbegin()); 
    }

    /// <summary>
    ///     Returns an iterator of type <typeparamref name="const_reverse_iterator"/> to the end of the concurrent vector.
    ///     This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     An iterator of type <typeparamref name="const_reverse_iterator"/> to the end of the concurrent vector.
    /// </returns>
    /**/
    const_reverse_iterator crend() const 
    {
        return (((const _Myt *)this)->rend());
    }

    /// <summary>
    ///     Returns a reference or a <c>const</c> reference to the first element in the concurrent vector. If the
    ///     concurrent vector is empty, the return value is undefined.  This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     A reference or a <c>const</c> reference to the first element in the concurrent vector.
    /// </returns>
    /**/
    reference front()
    {
        _ASSERTE( size()>0 );
        return static_cast<_Ty*>(_My_segment[0]._My_array)[0];
    }

    /// <summary>
    ///     Returns a reference or a <c>const</c> reference to the first element in the concurrent vector. If the
    ///     concurrent vector is empty, the return value is undefined. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     A reference or a <c>const</c> reference to the first element in the <c>concurrent_vector</c> object.
    /// </returns>
    /**/
    const_reference front() const
    {
        _ASSERTE( size()>0 );
        return static_cast<_Ty*>(_My_segment[0]._My_array)[0];
    }

    /// <summary>
    ///     Returns a reference or a <c>const</c> reference to the last element in the concurrent vector. If the
    ///     concurrent vector is empty, the return value is undefined. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     A reference or a <c>const</c> reference to the last element in the concurrent vector.
    /// </returns>
    /**/
    reference back()
    {
        _Size_type sz = size();
        _ASSERTE( sz > 0 );
        return _Internal_subscript( sz-1 );
    }

    /// <summary>
    ///     Returns a reference or a <c>const</c> reference to the last element in the concurrent_vector. If the
    ///     concurrent vector is empty, the return value is undefined. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     A reference or a <c>const</c> reference to the last element in the concurrent vector.
    /// </returns>
    /**/
    const_reference back() const
    {
        _Size_type sz = size();
        _ASSERTE( sz > 0 );
        return _Internal_subscript( sz-1 );
    }

    /// <summary>
    ///     Returns a copy of the allocator used to construct the concurrent vector. This method is concurrency-safe.
    /// </summary>
    /// <returns>
    ///     A copy of the allocator used to construct the <c>concurrent_vector</c> object.
    /// </returns>
    /**/
    allocator_type get_allocator() const
    { 
        return this->_My_allocator;
    }

    /// <summary>
    ///     Erases the elements of the concurrent vector and assigns to it either <paramref name="_N"/> copies of
    ///     <paramref name="_Item"/>, or values specified by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).
    ///     This method is not concurrency-safe.
    /// </summary>
    /// <param name="_N">
    ///     The number of items to copy into the concurrent vector.
    /// </param>
    /// <param name="_Item">
    ///     Reference to a value used to fill the concurrent vector.
    /// </param>
    /// <remarks>
    ///     <c>assign</c> is not concurrency-safe. You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this method.
    /// </remarks>
    /**/
    void assign(size_type _N, const_reference _Item) 
    {
        clear();
        _Internal_assign( _N, _Item );
    }

    /// <summary>
    ///     Erases the elements of the concurrent vector and assigns to it either <paramref name="_N"/> copies of <paramref name="_Item"/>,
    ///     or values specified by the iterator range [<paramref name="_Begin"/>, <paramref name="_End"/>).
    ///     This method is not concurrency-safe.
    /// </summary>
    /// <typeparam name="_InputIterator">
    ///     The type of the specified iterator.
    /// </typeparam>
    /// <param name="_Begin">
    ///     An iterator to the first element of the source range.
    /// </param>
    /// <param name="_End">
    ///     An iterator to one past the last element of the source range.
    /// </param>
    /// <remarks>
    ///     <c>assign</c> is not concurrency-safe. You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this method.
    /// </remarks>
    /**/
    template<class _InputIterator>
    void assign(_InputIterator _Begin, _InputIterator _End)
    {
        clear();
        _Internal_assign( _Begin, _End, static_cast<_Is_integer_tag<std::numeric_limits<_InputIterator>::is_integer> *>(0) );
    }

    /// <summary>
    ///     Swaps the contents of two concurrent vectors. This method is not concurrency-safe.
    /// </summary>
    /// <param name="_Vector">
    ///     The <c>concurrent_vector</c> object to swap contents with.
    /// </param>
    /**/
    void swap(concurrent_vector &_Vector)
    {
        if( this != &_Vector )
        {
            _Concurrent_vector_base_v4::_Internal_swap(static_cast<_Concurrent_vector_base_v4&>(_Vector));
            std::swap(this->_My_allocator, _Vector._My_allocator);
        }
    }

    /// <summary>
    ///     Erases all elements in the concurrent vector. This method is not concurrency-safe.
    /// </summary>
    /// <remarks>
    ///     <c>clear</c> is not concurrency-safe. You must ensure that no other threads are invoking methods
    ///     on the concurrent vector when you call this method. <c>clear</c> does not free internal arrays. To free internal arrays,
    ///     call the function <c>shrink_to_fit</c> after <c>clear</c>.
    /// </remarks>
    /**/
    void clear()
    {
        _Internal_clear(&_Destroy_array);
    }

    /// <summary>
    ///     Erases all elements and destroys this concurrent vector.
    /// </summary>
    /**/
    ~concurrent_vector()
    {
        _Segment_t *_Table = _My_segment;
        _Internal_free_segments( reinterpret_cast<void**>(_Table), _Internal_clear(&_Destroy_array), _My_first_block );
        // base class destructor call
    }

    const ::Concurrency::details::_Concurrent_vector_base_v4 &_Internal_vector_base() const { return *this; }
private:
    // Allocate _K items
    static void *_Internal_allocator(::Concurrency::details::_Concurrent_vector_base_v4 &_Vb, size_t _K) 
    {
        return static_cast<concurrent_vector<_Ty, _Ax>&>(_Vb)._My_allocator.allocate(_K);
    }
    // Free _K segments from table
    void _Internal_free_segments(void *_Table[], _Segment_index_t _K, _Segment_index_t _First_block);

    // Get reference to element at given _Index.
    _Ty& _Internal_subscript( size_type _Index ) const;

    // Get reference to element at given _Index with errors checks
    _Ty& _Internal_subscript_with_exceptions( size_type _Index ) const;

    // assign _N items by copying _Item
    void _Internal_assign(size_type _N, const_reference _Item);

    // helper class
    template<bool B> class _Is_integer_tag;

    // assign integer items by copying when arguments are treated as iterators. See C++ Standard 2003 23.1.1p9
    template<class _I>
    void _Internal_assign(_I _First, _I _Last, _Is_integer_tag<true> *) 
    {
        _Internal_assign(static_cast<size_type>(_First), static_cast<_Ty>(_Last));
    }
    // inline proxy assign by iterators
    template<class _I>
    void _Internal_assign(_I _First, _I _Last, _Is_integer_tag<false> *) {
        internal_assign_iterators(_First, _Last);
    }
    // assign by iterators
    template<class _I>
    void internal_assign_iterators(_I _First, _I _Last);

    // Construct _N instances of _Ty, starting at "begin".
    static void _Initialize_array( void* _Begin, const void*, size_type _N );

    // Construct _N instances of _Ty, starting at "begin".
    static void _Initialize_array_by( void* _Begin, const void* _Src, size_type _N );

    // Construct _N instances of _Ty, starting at "begin".
    static void _Copy_array( void* _Dst, const void* _Src, size_type _N );

    // Assign _N instances of _Ty, starting at "begin".
    static void _Assign_array( void* _Dst, const void* _Src, size_type _N );

    // Destroy _N instances of _Ty, starting at "begin".
    static void _Destroy_array( void* _Begin, size_type _N );

    // Exception-aware helper class for filling a segment by exception-danger operators of user class
    class _Internal_loop_guide
    {
    public:
        const pointer _My_array;
        const size_type _N;
        size_type _I;
        _Internal_loop_guide(size_type _NTrials, void *_Ptr)
            : _My_array(static_cast<pointer>(_Ptr)), _N(_NTrials), _I(0)
        {
        }

        void _Init()
        {
            for(; _I < _N; ++_I) 
                new( &_My_array[_I] ) _Ty(); 
        }
        void _Init(const void *_Src)
        { 
            for(; _I < _N; ++_I)
                new( &_My_array[_I] ) _Ty(*static_cast<const _Ty*>(_Src));
        }
        void _Copy(const void *_Src)
        {
            for(; _I < _N; ++_I)
                new( &_My_array[_I] ) _Ty(static_cast<const _Ty*>(_Src)[_I]);
        }
        void _Assign(const void *_Src)
        {
            for(; _I < _N; ++_I)
                _My_array[_I] = static_cast<const _Ty*>(_Src)[_I];
        }
        template<class _It> void _Iterate(_It &_Src)
        {
            for(; _I < _N; ++_I, ++_Src)
                new( &_My_array[_I] ) _Ty( *_Src );
        }
        ~_Internal_loop_guide() 
        {
            if(_I < _N) // if exception raised, do zeroing on the rest of items
                std::memset(_My_array+_I, 0, (_N-_I)*sizeof(value_type));
        }
    private:
        void operator=(const _Internal_loop_guide&); // prevent warning:  assign operator can't be generated
    };
};

/// <summary>
///     Compacts the internal representation of the concurrent vector to reduce fragmentation and optimize memory usage.
/// </summary>
/// <remarks>
///     This method will internally re-allocate memory move elements around, invalidating all the iterators.
///     <c>shrink_to_fit</c> is not concurrency-safe. You must ensure that no other threads are invoking methods
///     on the concurrent vector when you call this function.
/// </remarks>
/**/
template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::shrink_to_fit() 
{
    _Internal_segments_table _Old;
    try
    {
        if( _Internal_compact( sizeof(_Ty), &_Old, &_Destroy_array, &_Copy_array ) )
            _Internal_free_segments( _Old._Table, _Pointers_per_long_table, _Old._First_block ); // free joined and unnecessary segments
    }
    catch(...)
    {
        if( _Old._First_block ) // free segment allocated for compacting. Only for support of exceptions in ctor of user _Ty[pe]
            _Internal_free_segments( _Old._Table, 1, _Old._First_block );
        throw;
    }
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Internal_free_segments(void *_Table[], _Segment_index_t _K, _Segment_index_t _First_block) 
{
    // Free the arrays
    while( _K > _First_block )
    {
        --_K;
        _Ty* _Array = static_cast<_Ty*>(_Table[_K]);
        _Table[_K] = NULL;
        if( _Array > _BAD_ALLOC_MARKER ) // check for correct segment pointer
            this->_My_allocator.deallocate( _Array, _Segment_size(_K) );
    }
    _Ty* _Array = static_cast<_Ty*>(_Table[0]);
    if( _Array > _BAD_ALLOC_MARKER )
    {
        _ASSERTE( _First_block > 0 );
        while(_K > 0)
            _Table[--_K] = NULL;
        this->_My_allocator.deallocate( _Array, _Segment_size(_First_block) );
    }
}

template<typename _Ty, class _Ax>
_Ty& concurrent_vector<_Ty, _Ax>::_Internal_subscript( size_type _Index ) const
{
    _ASSERTE( _Index<_My_early_size ); // index out of bounds
    size_type _J = _Index;
    _Segment_index_t _K = _Segment_base_index_of( _J );
    _ASSERTE( _My_segment != (_Segment_t*)_My_storage || _K < _Pointers_per_short_table ); // index is under construction
    // no need in load_with_acquire since thread works in own space or gets 
    _Ty* _Array = static_cast<_Ty*>(_My_segment[_K]._My_array);
    _ASSERTE( _Array != _BAD_ALLOC_MARKER ); // instance may be broken by bad allocation; use at() instead
    _ASSERTE( _Array != NULL ); // index is being allocated
    return _Array[_J];
}

template<typename _Ty, class _Ax>
_Ty& concurrent_vector<_Ty, _Ax>::_Internal_subscript_with_exceptions( size_type _Index ) const
{
    if( _Index >= _My_early_size )
        _Internal_throw_exception(0); // throw std::out_of_range
    size_type _J = _Index;
    _Segment_index_t _K = _Segment_base_index_of( _J );
    if( _My_segment == (_Segment_t*)_My_storage && _K >= _Pointers_per_short_table )
        _Internal_throw_exception(1); // throw std::out_of_range
    void *_Array = _My_segment[_K]._My_array; // no need in load_with_acquire
    if( _Array <= _BAD_ALLOC_MARKER ) // check for correct segment pointer
        _Internal_throw_exception(2); // throw std::range_error
    return static_cast<_Ty*>(_Array)[_J];
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Internal_assign(size_type _N, const_reference _Item)
{
    _ASSERTE( _My_early_size == 0 );
    if( !_N )
        return;
    _Internal_reserve(_N, sizeof(_Ty), max_size());
    _My_early_size = _N;
    _Segment_index_t _K = 0;
    _Size_type _Sz = _Segment_size( _My_first_block );
    while (_Sz < _N)
    {
        _Initialize_array_by(static_cast<_Ty*>(_My_segment[_K]._My_array), static_cast<const void*>(&_Item), _Sz);
        _N -= _Sz;
        if (!_K)
        {
            _K = _My_first_block;
        }
        else {
            ++_K;
            _Sz <<= 1;
        }
    }
    _Initialize_array_by(static_cast<_Ty*>(_My_segment[_K]._My_array), static_cast<const void*>(&_Item), _N);
}

template<typename _Ty, class _Ax> template<class _I>
void concurrent_vector<_Ty, _Ax>::internal_assign_iterators(_I _First, _I _Last)
{
    _ASSERTE(_My_early_size == 0);
    size_type _N = std::distance(_First, _Last);
    if( !_N ) return;
    _Internal_reserve(_N, sizeof(_Ty), max_size());
    _My_early_size = _N;
    _Segment_index_t _K = 0;
    _Size_type _Sz = _Segment_size( _My_first_block );
    while (_Sz < _N) 
    {
        _Internal_loop_guide _Loop(_Sz, _My_segment[_K]._My_array);
        _Loop._Iterate(_First);
        _N -= _Sz;
        if (!_K) 
        {
            _K = _My_first_block;
        }
        else {
            ++_K;
            _Sz <<= 1;
        }
    }

    _Internal_loop_guide _Loop(_N, _My_segment[_K]._My_array);
    _Loop._Iterate(_First);
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Initialize_array( void* _Begin, const void *, size_type _N )
{
    _Internal_loop_guide _Loop(_N, _Begin); _Loop._Init();
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Initialize_array_by( void* _Begin, const void *_Src, size_type _N )
{
    _Internal_loop_guide _Loop(_N, _Begin); _Loop._Init(_Src);
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Copy_array( void* _Dst, const void* _Src, size_type _N ) {
    _Internal_loop_guide _Loop(_N, _Dst); _Loop._Copy(_Src);
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Assign_array( void* _Dst, const void* _Src, size_type _N )
{
    _Internal_loop_guide _Loop(_N, _Dst); _Loop._Assign(_Src);
}

template<typename _Ty, class _Ax>
void concurrent_vector<_Ty, _Ax>::_Destroy_array( void* _Begin, size_type _N ) 
{
    _Ty* _Array = static_cast<_Ty*>(_Begin);
    for( size_type _J=_N; _J>0; --_J )
        _Array[_J-1].~_Ty(); // destructors are supposed to not throw any exceptions
}

/// <summary>
///     Tests if the <c>concurrent_vector</c> object on the left side of the operator is equal to the <c>concurrent_vector</c>
///     object on the right side.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="A1">
///     The allocator type of the first <c>concurrent_vector</c> object.
/// </typeparam>
/// <typeparam name="A2">
///     The allocator type of the second <c>concurrent_vector</c> object.
/// </typeparam>
/// <param name="_A">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <param name="_B">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <returns>
///     <c>true</c> if the concurrent vector on the left side of the operator is equal to the concurrent vector on the right side
///     of the operator; otherwise <c>false</c>.
/// </returns>
/// <remarks>
///     Two concurrent vectors are equal if they have the same number of elements and their respective elements have the same values.
///     Otherwise, they are unequal.
///     <para> This method is not concurrency-safe with respect to other methods that could modify either of the concurrent vectors
///     <paramref name="_A"/> or <paramref name="_B"/>.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class A1, class A2>
inline bool operator==(const concurrent_vector<_Ty, A1> &_A, const concurrent_vector<_Ty, A2> &_B)
{
    // Simply:    return _A.size() == _B.size() && std::equal(_A.begin(), _A.end(), _B.begin());
    if(_A.size() != _B.size())
        return false;
    typename concurrent_vector<_Ty, A1>::const_iterator _I(_A.begin());
    typename concurrent_vector<_Ty, A2>::const_iterator _J(_B.begin());
    for(; _I != _A.end(); ++_I, ++_J)
    {
        if( !(*_I == *_J) )
            return false;
    }
    return true;
}

/// <summary>
///     Tests if the <c>concurrent_vector</c> object on the left side of the operator is not equal to the <c>concurrent_vector</c>
///     object on the right side.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="A1">
///     The allocator type of the first <c>concurrent_vector</c> object.
/// </typeparam>
/// <typeparam name="A2">
///     The allocator type of the second <c>concurrent_vector</c> object.
/// </typeparam>
/// <param name="_A">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <param name="_B">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <returns>
///     <c>true</c> if the concurrent vectors are not equal; <c>false</c> if the concurrent vectors are equal.
/// </returns>
/// <remarks>
///     Two concurrent vectors are equal if they have the same number of elements and their respective elements have the same
///     values. Otherwise, they are unequal.
///     <para> This method is not concurrency-safe with respect to other methods that could modify either of the concurrent vectors
///     <paramref name="_A"/> or <paramref name="_B"/>.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class A1, class A2>
inline bool operator!=(const concurrent_vector<_Ty, A1> &_A, const concurrent_vector<_Ty, A2> &_B)
{
    return !(_A == _B);
}

/// <summary>
///     Tests if the <c>concurrent_vector</c> object on the left side of the operator is less than the <c>concurrent_vector</c>
///     object on the right side.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="A1">
///     The allocator type of the first <c>concurrent_vector</c> object.
/// </typeparam>
/// <typeparam name="A2">
///     The allocator type of the second <c>concurrent_vector</c> object.
/// </typeparam>
/// <param name="_A">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <param name="_B">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <returns>
///     <c>true</c> if the concurrent vector on the left side of the operator is less than the concurrent vector
///     on the right side of the operator; otherwise <c>false</c>.
/// </returns>
/// <remarks>
///     The behavior of this operator is identical to the equivalent operator for the <c>vector</c> class in the <c>std</c>
///     namespace.
///     <para> This method is not concurrency-safe with respect to other methods that could modify either of the concurrent vectors
///     <paramref name="_A"/> or <paramref name="_B"/>.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class A1, class A2>
inline bool operator<(const concurrent_vector<_Ty, A1> &_A, const concurrent_vector<_Ty, A2> &_B)
{
    return (std::lexicographical_compare(_A.begin(), _A.end(), _B.begin(), _B.end()));
}

/// <summary>
///     Tests if the <c>concurrent_vector</c> object on the left side of the operator is greater than the <c>concurrent_vector</c>
///     object on the right side.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="A1">
///     The allocator type of the first <c>concurrent_vector</c> object.
/// </typeparam>
/// <typeparam name="A2">
///     The allocator type of the second <c>concurrent_vector</c> object.
/// </typeparam>
/// <param name="_A">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <param name="_B">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <returns>
///     <c>true</c> if the concurrent vector on the left side of the operator is greater than the concurrent vector
///     on the right side of the operator; otherwise <c>false</c>.
/// </returns>
/// <remarks>
///     The behavior of this operator is identical to the equivalent operator for the <c>vector</c> class in the <c>std</c>
///     namespace.
///     <para> This method is not concurrency-safe with respect to other methods that could modify either of the concurrent vectors
///     <paramref name="_A"/> or <paramref name="_B"/>.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class A1, class A2>
inline bool operator>(const concurrent_vector<_Ty, A1> &_A, const concurrent_vector<_Ty, A2> &_B)
{
    return _B < _A;
}

/// <summary>
///     Tests if the <c>concurrent_vector</c> object on the left side of the operator is less than or equal to the <c>concurrent_vector</c>
///     object on the right side.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="A1">
///     The allocator type of the first <c>concurrent_vector</c> object.
/// </typeparam>
/// <typeparam name="A2">
///     The allocator type of the second <c>concurrent_vector</c> object.
/// </typeparam>
/// <param name="_A">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <param name="_B">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <returns>
///     <c>true</c> if the concurrent vector on the left side of the operator is less than or equal to the concurrent vector
///     on the right side of the operator; otherwise <c>false</c>.
/// </returns>
/// <remarks>
///     The behavior of this operator is identical to the equivalent operator for the <c>vector</c> class in the <c>std</c>
///     namespace.
///     <para> This method is not concurrency-safe with respect to other methods that could modify either of the concurrent vectors
///     <paramref name="_A"/> or <paramref name="_B"/>.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class A1, class A2>
inline bool operator<=(const concurrent_vector<_Ty, A1> &_A, const concurrent_vector<_Ty, A2> &_B)
{
    return !(_B < _A);
}

/// <summary>
///     Tests if the <c>concurrent_vector</c> object on the left side of the operator is greater than or equal to the <c>concurrent_vector</c>
///     object on the right side.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="A1">
///     The allocator type of the first <c>concurrent_vector</c> object.
/// </typeparam>
/// <typeparam name="A2">
///     The allocator type of the second <c>concurrent_vector</c> object.
/// </typeparam>
/// <param name="_A">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <param name="_B">
///     An object of type <c>concurrent_vector</c>.
/// </param>
/// <returns>
///     <c>true</c> if the concurrent vector on the left side of the operator is greater than or equal to the concurrent vector
///     on the right side of the operator; otherwise <c>false</c>.
/// </returns>
/// <remarks>
///     The behavior of this operator is identical to the equivalent operator for the <c>vector</c> class in the <c>std</c>
///     namespace.
///     <para> This method is not concurrency-safe with respect to other methods that could modify either of the concurrent vectors
///     <paramref name="_A"/> or <paramref name="_B"/>.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class A1, class A2>
inline bool operator>=(const concurrent_vector<_Ty, A1> &_A, const concurrent_vector<_Ty, A2> &_B)
{
    return !(_A < _B);
}

/// <summary>
///     Exchanges the elements of two <c>concurrent_vector</c> objects.
/// </summary>
/// <typeparam name="_Ty">
///     The data type of the elements stored in the concurrent vectors.
/// </typeparam>
/// <typeparam name="_Ax">
///     The allocator type of the concurrent vectors.
/// </typeparam>
/// <param name="_B">
///     The concurrent vector providing the elements to be swapped, or the vector whose elements are to be exchanged with those of the
///     concurrent vector <paramref name="_A"/>.
/// </param>
/// <param name="_A">
///     The concurrent vector whose elements are to be exchanged with those of the concurrent vector <paramref name="_B"/>.
/// </param>
/// <remarks>
///     The template function is an algorithm specialized on the container class <c>concurrent_vector</c> to execute the member function
///     <paramref name="_A"/>.<see cref="concurrent_vector::swap Method">concurrent_vector::swap</see>(<paramref name="_B"/>). These are
///     instances of the partial ordering of function templates by the compiler. When template functions are overloaded in such a way that
///     the match of the template with the function call is not unique, then the compiler will select the most specialized version of the
///     template function. The general version of the template function, <c>template &lt;class T&gt; void swap(T&amp;, T&amp;)</c>, in the
///     algorithm class works by assignment and is a slow operation. The specialized version in each container is much faster as it can
///     work with the internal representation of the container class.
///     <para> This method is not concurrency-safe. You must ensure that no other threads are performing operations on either of the concurrent
///     vectors when you call this method.</para>
/// </remarks>
/// <seealso cref="concurrent_vector Class"/>
/// <seealso cref="Parallel Containers and Objects"/>
/**/
template<typename _Ty, class _Ax>
inline void swap(concurrent_vector<_Ty, _Ax> &_A, concurrent_vector<_Ty, _Ax> &_B)
{
    _A.swap( _B );
}

} // namespace Concurrency

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\concrtrm.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
* 
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* concrtrm.h
*
* Main public header file for ConcRT's Resource Manager. This is the only header file a client
* needs to include to build atop the resource manager.
*
* The core runtime, agents, and the PPL live in different headers.
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

#pragma once

#include <crtdefs.h>

#if !(defined(_M_AMD64) || defined(_M_IX86))
    #error ERROR: Concurrency Runtime is supported only on X64 and X86 architectures.
#endif

#if defined(_M_CEE)
    #error ERROR: Concurrency Runtime is not supported when compiling /clr.
#endif

#ifndef __cplusplus
    #error ERROR: Concurrency Runtime is supported only for C++.
#endif

#pragma pack(push,_CRT_PACKING)

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{
    //
    // Forward Declarations:
    //
    struct IScheduler;
    struct IThreadProxy;
    class SchedulerPolicy;

    /// <summary>
    ///     Used to denote the state a thread proxy is in, when it is executing a cooperative context switch to a different thread
    ///     proxy.
    /// </summary>
    /// <remarks>
    ///     A parameter of type <c>SwitchingProxyState</c> is passed in to the method <c>IThreadProxy::SwitchTo</c> to
    ///     instruct the Resource Manager how to treat the thread proxy that is making the call.
    ///     <para>For more information on how this type is used, see <see cref="IThreadProxy::SwitchTo Method">IThreadProxy::SwitchTo
    ///     </see>.</para>
    /// </remarks>
    /**/
    enum SwitchingProxyState
    {
        /// <summary>
        ///     Indicates that the calling thread is no longer needed by the scheduler and is being returned to the Resource Manager.  The
        ///     context which was being dispatched is no longer able to be utilized by the Resource Manager.
        /// </summary>
        /**/
        Idle,

        /// <summary>
        ///     Indicates that the calling thread is cooperatively blocking and should be exclusively owned by the caller until subsequently
        ///     running again and performing other action.
        /// </summary>
        /**/
        Blocking,

        /// <summary>
        ///     Indicates that the calling thread is nesting a child scheduler and is needed by the caller, in order to attach to a
        ///     different scheduler.
        /// </summary>
        /**/
        Nesting
    };

    /// <summary>
    ///     The <c>DispatchState</c> structure is used to transfer state to the <c>IExecutionContext::Dispatch</c> method. It describes
    ///     the circumstances under which the <c>Dispatch</c> method is invoked on an <c>IExecutionContext</c> interface.
    /// </summary>
    /// <seealso cref="IExecutionContext::Dispatch Method"/>
    /**/
    struct DispatchState
    {
        /// <summary>
        ///     Constructs a new <c>DispatchState</c> object.
        /// </summary>
        /**/
        DispatchState() : m_dispatchStateSize(sizeof(DispatchState)), m_fIsPreviousContextAsynchronouslyBlocked(0), m_reserved(0)
        {
        }

        /// <summary>
        ///     Size of this structure, which is used for versioning.
        /// </summary>
        /**/
        unsigned long m_dispatchStateSize;

        /// <summary>
        ///     Tells whether this context has entered the <c>Dispatch</c> method because the previous context asynchronously blocked.
        ///     This is used only on the UMS scheduling context, and is set to the value <c>0</c> for all other execution contexts.
        /// </summary>
        /// <seealso cref="IExecutionContext::Dispatch Method"/>
        /**/
        unsigned int  m_fIsPreviousContextAsynchronouslyBlocked : 1;

        /// <summary>
        ///     Bits reserved for future information passing.
        /// </summary>
        /// <seealso cref="IExecutionContext::Dispatch Method"/>
        /**/
        unsigned int  m_reserved : 31;
    };

    /// <summary>
    ///     An interface to an execution context which can run on a given virtual processor and be cooperatively context switched.
    /// </summary>
    /// <remarks>
    ///     If you are implementing a custom scheduler that interfaces with the Concurrency Runtime's Resource Manager, you will need
    ///     to implement the <c>IExecutionContext</c> interface. The threads created by the Resource Manager perform work on behalf
    ///     of your scheduler by executing the <c>IExecutionContext::Dispatch</c> method.
    /// </remarks>
    /// <seealso cref="IScheduler Structure"/>
    /// <seealso cref="IThreadProxy Structure"/>
    /**/
    struct IExecutionContext
    {
        /// <summary>
        ///     Returns a unique identifier for the execution context.
        /// </summary>
        /// <returns>
        ///     A unique integer identifier.
        /// </returns>
        /// <remarks>
        ///     You should use the method <c>GetExecutionContextId</c> to obtain a unique identifier for the object that implements the
        ///     <c>IExecutionContext</c> interface, before you use the interface as a parameter to methods supplied by the Resource Manager.
        ///     You are expected to return the same identifier when the <c>GetId</c> function is invoked. <para> An identifier obtained from a different
        ///     source could result in undefined behavior.</para>
        /// </remarks>
        /// <seealso cref="GetExecutionContextId Function"/>
        /**/
        virtual unsigned int GetId() const =0;

        /// <summary>
        ///     Returns an interface to the scheduler this execution context belongs to.
        /// </summary>
        /// <returns>
        ///     An <c>IScheduler</c> interface.
        /// </returns>
        /// <remarks>
        ///     You are required to initialize the execution context with a valid <c>IScheduler</c> interface before you use it as a parameter to
        ///     methods supplied by the Resource Manager.
        /// </remarks>
        /**/
        virtual IScheduler * GetScheduler() =0;

        /// <summary>
        ///     Returns an interface to the thread proxy that is executing this context.
        /// </summary>
        /// <returns>
        ///     An <c>IThreadProxy</c> interface. If the execution context's thread proxy has not been initialized with a call to <c>SetProxy</c>,
        ///     the function must return <c>NULL</c>.
        /// </returns>
        /// <remarks>
        ///     The Resource Manager will invoke the <c>SetProxy</c> method on an execution context, with an <c>IThreadProxy</c> interface
        ///     as a parameter, prior to entering the <c>Dispatch</c> method on the on the context. You are expected to store this argument and return it
        ///     on calls to <c>GetProxy()</c>.
        /// </remarks>
        /// <seealso cref="IExecutionContext::SetProxy Method"/>
        /**/
        virtual IThreadProxy * GetProxy() =0;

        /// <summary>
        ///     Associates a thread proxy with this execution context. The associated thread proxy invokes this method right before it starts
        ///     executing the context's <c>Dispatch</c> method.
        /// </summary>
        /// <param name="pThreadProxy">
        ///     An interface to the thread proxy that is about to enter the <c>Dispatch</c> method on this execution context.
        /// </param>
        /// <remarks>
        ///     You are expected to save the parameter <paramref name="pThreadProxy"/> and return it on a call to the <c>GetProxy</c> method.
        ///     The Resource Manager guarantees that the thread proxy associated with the execution context will not change while the
        ///     thread proxy is executing the <c>Dispatch</c> method.
        /// </remarks>
        /// <seealso cref="IExecutionContext::GetProxy Method"/>
        /**/
        virtual void SetProxy(IThreadProxy * pThreadProxy) =0;

        /// <summary>
        ///     The method that is called when a thread proxy starts executing a particular execution context. This should be the main worker
        ///     routine for your scheduler.
        /// </summary>
        /// <param name="pDispatchState">
        ///     A pointer to the state under which this execution context is being dispatched. For more information on dispatch state, see
        ///     <see cref="DispatchState Structure">DispatchState</see>.
        /// </param>
        /**/
        virtual void Dispatch(DispatchState * pDispatchState) =0;
    };

    /// <summary>
    ///     An abstraction for a thread of execution. Depending on the <c>SchedulerType</c> policy key of the scheduler you create, the Resource
    ///     Manager will grant you a thread proxy that is backed by either a regular Win32 thread or a user-mode schedulable (UMS) thread.
    ///     UMS threads are supported on 64-bit operating systems with version Windows 7 and higher.
    /// </summary>
    /// <remarks>
    ///     Thread proxies are coupled to execution contexts represented by the interface <c>IExecutionContext</c> as a means of dispatching work.
    /// </remarks>
    /// <seealso cref="IExecutionContext Structure"/>
    /// <seealso cref="IScheduler Structure"/>
    /// <seealso cref="IVirtualProcessorRoot Structure"/>
    /**/
    struct IThreadProxy
    {
        /// <summary>
        ///     Returns a unique identifier for the thread proxy.
        /// </summary>
        /// <returns>
        ///     A unique integer identifier.
        /// </returns>
        /**/
        virtual unsigned int GetId() const =0;

        /// <summary>
        ///     Performs a cooperative context switch from the currently executing context to a different one.
        /// </summary>
        /// <param name="pContext">
        ///     The execution context to cooperatively switch to.
        /// </param>
        /// <param name="switchState">
        ///     Indicates the state of the thread proxy that is executing the switch. The parameter is of type <typeparamref name="SwitchingProxyState"/>.
        /// </param>
        /// <remarks>
        ///     Use this method to switch from one execution context to another, from the <see cref="IExecutionContext::Dispatch Method">
        ///     IExecutionContext::Dispatch </see> method of the first execution context.
        ///     The method associates the execution context <paramref name="pContext"/> with a thread proxy if it is not already associated
        ///     with one. The ownership of the current thread proxy is determined by the value you specify for the <paramref name="switchState"/>
        ///     argument.
        ///
        ///     <para> Use the value <c>Idle</c> when you want to return the currently executing thread proxy to the Resource Manager.
        ///     Calling <c>SwitchTo</c> with the parameter <paramref name="switchState"/> set to <c>Idle</c> will cause
        ///     the execution context <paramref name="pContext"/> to start executing on the underlying execution resource. Ownership of
        ///     this thread proxy is transferred to the Resource Manager, and you are expected to return from the execution context's
        ///     <c>Dispatch</c> method soon after <c>SwitchTo</c> returns, in order to complete the transfer. The execution context that the 
        ///     thread proxy was dispatching is disassociated from the thread proxy, and the scheduler is free to reuse it or destroy it
        ///     as it sees fit.</para>
        ///
        ///     <para> Use the value <c>Blocking</c> when you want this thread proxy to enter a blocked state. Calling
        ///     <c>SwitchTo</c> with the parameter <paramref name="switchState"/> set to <c>Blocking</c> will cause the execution context
        ///     <paramref name="pContext"/> to start executing, and block the current thread proxy until it is resumed. The scheduler retains
        ///     ownership of the thread proxy when the thread proxy is in the <c>Blocking</c> state. The blocking thread proxy
        ///     can be resumed by calling the function <c>SwitchTo</c> to switch to this thread proxy's execution context. You can also
        ///     resume the thread proxy, by using its associated context to activate a virtual processor root. For more information on how
        ///     to do this, see <see cref="IVirtualProcessorRoot::Activate Method"> IVirtualProcessorRoot::Activate</see>.</para>
        ///
        ///     <para> Use the value <c>Nesting</c> when you want to temporarily detach this thread proxy from the virtual processor root
        ///     it is running on, and the scheduler it is dispatching work for. Calling <c>SwitchTo</c> with the parameter <paramref name="switchState"/>
        ///     set to <c>Nesting</c> will cause the execution context <paramref name="pContext"/> to start executing and the
        ///     current thread proxy also continues executing without the need for a virtual processor root. The thread proxy is considered
        ///     to have left the scheduler until it calls the <see cref="IThreadProxy::SwitchOut Method">IThreadProxy::SwitchOut</see>
        ///     method at a later point in time. The <c>IThreadProxy::SwitchOut</c> method could block the thread proxy until a virtual
        ///     processor root is available to reschedule it.</para>
        ///     <para><c>SwitchTo</c> must be called on the <c>IThreadProxy</c> interface that represents the currently executing thread
        ///     or the results are undefined. The function throws <c>invalid_argument</c> if the parameter <paramref name="pContext"/>
        ///     is set to <c>NULL</c>.</para>
        /// </remarks>
        /// <seealso cref="SwitchingProxyState Enumeration"/>
        /**/
        virtual void SwitchTo(IExecutionContext * pContext, SwitchingProxyState switchState) =0;

        /// <summary>
        ///     Blocks the currently executing thread proxy until it can be resumed by an available virtual processor root.
        /// </summary>
        /// <remarks>
        ///     Use <c>SwitchOut</c> to block an executing thread proxy after relinquishing the underlying virtual processor root. This method is
        ///     useful when you want to reduce the number of virtual processor roots your scheduler has, either because the Resource Manager has
        ///     instructed you to do so, or because you requested a temporary oversubscribed virtual processor root, and are done with it. The
        ///     thread proxy can resume execution when a different virtual processor root in the scheduler is available to execute it.
        ///     <para> The blocking thread proxy can be resumed by calling the function <c>SwitchTo</c> to switch to this thread proxy's
        ///     execution context. You can also resume the thread proxy, by using its associated context to activate a virtual processor root.
        ///     For more information on how to do this, see <see cref="IVirtualProcessorRoot::Activate Method"> IVirtualProcessorRoot::Activate</see>.</para>
        ///     <para><c>SwitchOut</c> must be called on the <c>IThreadProxy</c> interface that represents the currently executing thread
        ///     or the results are undefined.</para>
        /// </remarks>
        /**/
        virtual void SwitchOut() =0;

        /// <summary>
        ///     Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating
        ///     system selects the next thread to be executed.
        /// </summary>
        /// <remarks>
        ///     When called by a thread proxy backed by a regular Windows thread, <c>YieldToSystem</c> behaves exactly like the Windows function
        ///     <c>SwitchToThread</c>. However, when called from user-mode schedulable (UMS) threads, the <c>SwitchToThread</c> function delegates the task
        ///     of picking the next thread to run to the user mode scheduler, not the operating system. To achieve the desired effect of switching
        ///     to a different ready thread in the system, use <c>YieldToSystem</c>.
        ///     <para><c>YieldToSystem</c> must be called on the <c>IThreadProxy</c> interface that represents the currently executing thread
        ///     or the results are undefined.</para>
        /// </remarks>
        /**/
        virtual void YieldToSystem() = 0;
    };

    /// <summary>
    ///    The type of critical region a context is inside.
    /// </summary>
    /// <seealso cref="IUMSThreadProxy Structure"/>
    /**/
    enum CriticalRegionType
    {
        /// <summary>
        ///     Indicates that the context is outside any critical region.
        /// </summary>
        /**/
        OutsideCriticalRegion,

        /// <summary>
        ///     Indicates that the context is inside a critical region.  When inside a critical region, asynchronous suspensions are hidden from
        ///     the scheduler.  Should such a suspension happen, the Resource Manager will wait for the thread to become runnable and simply resume it instead
        ///     of invoking the scheduler again.  Any locks taken inside such a region must be taken with extreme care.
        /// </summary>
        /**/
        InsideCriticalRegion,

        /// <summary>
        ///     Indicates that the context is inside a hyper-critical region.  When inside a hyper-critical region, both synchronous and asynchronous 
        ///     suspensions are hidden from the scheduler.  Should such a suspension or blocking happen, the resource manager will wait for the thread to 
        ///     become runnable and simply resume it instead of invoking the scheduler again.  Locks taken inside such a region must never be shared with 
        ///     code running outside such a region.  Doing so will cause unpredictable deadlock.
        /// </summary>
        /**/
        InsideHyperCriticalRegion
    };

    /// <summary>
    ///     An abstraction for a thread of execution. If you want your scheduler to be granted user-mode schedulable (UMS) threads, set the value for the
    ///     scheduler policy element <c>SchedulerKind</c> to <c>UmsThreadDefault</c>, and implement the <c>IUMSScheduler</c> interface.
    ///     UMS threads are only supported on 64-bit operating systems with version Windows 7 and higher.
    /// </summary>
    /// <seealso cref="IUMSScheduler Structure"/>
    /// <seealso cref="SchedulerType Enumeration"/>
    /**/
    struct IUMSThreadProxy : public IThreadProxy
    {
        /// <summary>
        ///     Called in order to enter a critical region.  When inside a critical region, the scheduler will not observe asynchronous blocking operations
        ///     that happen during the region.  This means that the scheduler will not be reentered for page faults, thread suspensions, kernel asynchronous
        ///     procedure calls (APCs), etc., for a UMS thread.
        /// </summary>
        /// <returns>
        ///     The new depth of critical region.  Critical regions are reentrant.
        /// </returns>
        /// <seealso cref="IUMSThreadProxy::ExitCriticalRegion Method"/>
        /**/
        virtual int EnterCriticalRegion() =0;

        /// <summary>
        ///     Called in order to exit a critical region.
        /// </summary>
        /// <returns>
        ///     The new depth of critical region.  Critical regions are reentrant.
        /// </returns>
        /// <seealso cref="IUMSThreadProxy::EnterCriticalRegion Method"/>
        /**/
        virtual int ExitCriticalRegion() =0;

        /// <summary>
        ///     Called in order to enter a hyper-critical region.  When inside a hyper-critical region, the scheduler will not observe any blocking operations
        ///     that happen during the region.  This means the scheduler will not be reentered for blocking function calls, lock acquisition attempts which 
        ///     block, page faults, thread suspensions, kernel asynchronous procedure calls (APCs), etc., for a UMS thread. 
        /// </summary>
        /// <returns>
        ///     The new depth of hyper-critical region.  Hyper-critical regions are reentrant.
        /// </returns>
        /// <remarks>
        ///     The scheduler must be extraordinarily careful about what methods it calls and what locks it acquires in such regions.  If code in such a 
        ///     region blocks on a lock that is held by something the scheduler is responsible for scheduling, deadlock may ensue.
        /// </remarks>
        /// <seealso cref="IUMSThreadProxy::ExitHyperCriticalRegion Method"/>
        /**/
        virtual int EnterHyperCriticalRegion() =0;

        /// <summary>
        ///     Called in order to exit a hyper-critical region.
        /// </summary>
        /// <returns>
        ///     The new depth of hyper-critical region.  Hyper-critical regions are reentrant.
        /// </returns>
        /// <seealso cref="IUMSThreadProxy::EnterHyperCriticalRegion Method"/>
        /**/
        virtual int ExitHyperCriticalRegion() =0;

        /// <summary>
        ///     Returns what kind of critical region the thread proxy is within.  Since hyper-critical regions are a superset of critical regions, if code
        ///     has entered a critical region and then a hyper-critical region, <c>InsideHyperCriticalRegion</c> will be returned.
        /// </summary>
        /// <returns>
        ///     The type of critical region the thread proxy is within.
        /// </returns>
        /// <seealso cref="CriticalRegionType Enumeration"/>
        /**/
        virtual CriticalRegionType GetCriticalRegionType() const =0;
    };

    /// <summary>
    ///     An abstraction for a hardware thread.
    /// </summary>
    /// <remarks>
    ///     Execution resources can be standalone or associated with virtual processor roots. A standalone execution resource is created when
    ///     a thread in your application creates a thread subscription. The methods <see cref="ISchedulerProxy::SubscribeCurrentThread Method">
    ///     ISchedulerProxy::SubscribeThread</see> and <see cref="ISchedulerProxy::RequestInitialVirtualProcessors Method">
    ///     ISchedulerProxy::RequestInitialVirtualProcessors</see> create thread subscriptions, and return an <c>IExecutionResource</c> interface
    ///     representing the subscription. Creating a thread subscription is a way to inform the Resource Manager that a given thread will participate
    ///     in the work queued to a scheduler, along with the virtual processor roots Resource Manager assigns to the scheduler.
    ///     The Resource Manager uses the information to avoid oversubscribing hardware threads where it can.
    /// </remarks>
    /// <seealso cref="IVirtualProcessorRoot Structure"/>
    /// <seealso cref="ISchedulerProxy::SubscribeCurrentThread Method"/>
    /// <seealso cref="ISchedulerProxy::RequestInitialVirtualProcessors Method"/>
    /**/
    struct IExecutionResource
    {
        /// <summary>
        ///     Returns a unique identifier for the processor node that this execution resource belongs to.
        /// </summary>
        /// <returns>
        ///     A unique identifier for a processor node.
        /// </returns>
        /// <remarks>
        ///     The Concurrency Runtime represents hardware threads on the system in groups of processor nodes. Nodes are usually derived from
        ///     the hardware topology of the system. For example, all processors on a specific socket or a specific NUMA node may belong to the
        ///     same processor node. The Resource Manager assigns unique identifiers to these nodes starting with <c>0</c> up to and including
        ///     <c>nodeCount - 1</c>, where <c>nodeCount</c> represents the total number of processor nodes on the system.
        ///     <para>The count of nodes can be obtained from the function <see cref="GetProcessorNodeCount Function">GetProcessorNodeCount</see>.</para>
        /// </remarks>
        /**/
        virtual unsigned int GetNodeId() const =0;

        /// <summary>
        ///     Returns a unique identifier for the hardware thread that this execution resource represents.
        /// </summary>
        /// <returns>
        ///     A unique identifier for the hardware thread underlying this execution resource.
        /// </returns>
        /// <remarks>
        ///     Each hardware thread is assigned a unique identifier by the Concurrency Runtime. If multiple execution resources are associated
        ///     hardware thread, they will all have the same execution resource identifier.
        /// </remarks>
        /**/
        virtual unsigned int GetExecutionResourceId() const =0;

        /// <summary>
        ///     Returns this execution resource to the Resource Manager.
        /// </summary>
        /// <param name="pScheduler">
        ///     An interface to the scheduler making the request to remove this execution resource.
        /// </param>
        /// <remarks>
        ///     Use this method to return standalone execution resources as well as execution resources associated with virtual processor roots to
        ///     the Resource Manager.
        ///     <para>If this is a standalone execution resource you received from either of the methods <see cref="ISchedulerProxy::SubscribeCurrentThread Method">
        ///     ISchedulerProxy::SubscribeCurrentThread</see> or <see cref="ISchedulerProxy::RequestInitialVirtualProcessors Method">
        ///     ISchedulerProxy::RequestInitialVirtualProcessors</see>, calling the method <c>Remove</c> will end the thread subscription that the
        ///     resource was created to represent. You are required to end all thread subscriptions before shutting down a scheduler proxy, and must 
        ///     call <c>Remove</c> from the thread that created the subscription.</para>
        ///     <para>Virtual processor roots, too, can be returned to the Resource Manager by invoking the <c>Remove</c> method, since the interface
        ///     <c>IVirtualProcessorRoot</c> inherits from the <c>IExecutionResource</c> interface. You may need to return a virtual processor root either
        ///     in response to a call to the <see cref="IScheduler::RemoveVirtualProcessors Method">IScheduler::RemoveVirtualProcessors</see>
        ///     method, or when you are done with an oversubscribed virtual processor root you obtained from the <see cref="ISchedulerProxy::CreateOversubscriber Method">
        ///     ISchedulerProxy::CreateOversubscriber</see> method. For virtual processor roots, there are no restrictions on which thread can invoke
        ///     the <c>Remove</c> method.</para>
        ///     <para><c>invalid_argument</c> is thrown if the parameter <paramref name="pScheduler"/> is set to <c>NULL</c>.</para>
        ///     <para><c>invalid_operation</c> is thrown if the parameter <paramref name="pScheduler"/> is different from the scheduler that this
        ///     execution resource was created for, or, with a standalone execution resource, if the current thread is different from the
        ///     thread that created the thread subscription.</para>
        /// </remarks>
        /// <seealso cref="invalid_argument Class"/>
        /// <seealso cref="invalid_operation Class"/>
        /**/
        virtual void Remove(IScheduler * pScheduler) =0;

        /// <summary>
        ///     Returns the number of activated virtual processor roots and subscribed external threads currently associated with the underlying
        ///     hardware thread this execution resource represents.
        /// </summary>
        /// <returns>
        ///     The current subscription level.
        /// </returns>
        /// <remarks>
        ///     The subscription level tells you how many running threads are associated with the hardware thread. This only includes threads
        ///     the Resource Manager is aware of in the form of subscribed threads, and virtual processor roots that are actively executing
        ///     thread proxies.
        ///     <para>Calling the method <see cref="ISchedulerProxy::SubscribeCurrentThread Method">ISchedulerProxy::SubscribeCurrentThread</see>,
        ///     or the method <see cref="ISchedulerProxy::RequestInitialVirtualProcessors Method">ISchedulerProxy::RequestInitialVirtualProcessors
        ///     </see> with the parameter <paramref name="doSubscribeCurrentThread"/> set to the value <c>true</c> increments the subscription
        ///     level of a hardware thread by one. They also return an <c>IExecutionResource</c> interface representing the subscription.  A
        ///     corresponding call to the <see cref="IExecutionResource::Remove Method"> IExecutionResource::Remove</see> decrements the
        ///     hardware thread's subscription level by one.</para>
        ///     <para>The act of activating a virtual processor root using the method <see cref="IVirtualProcessorRoot::Activate Method">
        ///     IVirtualProcessorRoot::Activate</see> increments the subscription level of a hardware thread by one. The methods
        ///     <see cref="IVirtualProcessorRoot::Deactivate Method">IVirtualProcessorRoot::Deactivate</see>, or
        ///     <see cref="IExecutionResource::Remove Method">IExecutionResource::Remove</see> decrement the subscription level by one
        ///     when invoked on an activated virtual processor root.</para>
        ///     <para>The Resource Manager uses subscription level information as one of the ways in which to determine when to move resources
        ///     between schedulers.</para>
        /// </remarks>
        /**/
        virtual unsigned int CurrentSubscriptionLevel() const =0;
    };

    /// <summary>
    ///     An abstraction for a hardware thread on which a thread proxy can execute.
    /// </summary>
    /// <remarks>
    ///     Every virtual processor root has an associated execution resource. The <c>IVirtualProcessorRoot</c> interface inherits from the
    ///     <see cref="IExecutionResource Structure">IExecutionResource</see> interface. Multiple virtual processor roots may correspond to the same
    ///     underlying hardware thread.
    ///     <para>The Resource Manager grants virtual processor roots to schedulers in response to requests for resources. A scheduler can use
    ///     a virtual processor root to perform work by activating it with an execution context.</para>
    /// </remarks>
    /**/
    struct IVirtualProcessorRoot : public IExecutionResource
    {
        /// <summary>
        ///     Returns a unique identifier for the virtual processor root.
        /// </summary>
        /// <returns>
        ///     An integer identifier.
        /// </returns>
        /**/
        virtual unsigned int GetId() const =0;
        
        /// <summary>
        ///     Causes the thread proxy associated with the execution context interface <paramref name="pContext"/> to start executing on this
        ///     virtual processor root.
        /// </summary>
        /// <param name="pContext">
        ///     An interface to the execution context that will be dispatched on this virtual processor root.
        /// </param>
        /// <remarks>
        ///     The Resource Manager will supply a thread proxy if one is not associated with the execution context interface <paramref name="pContext"/> 
        ///     <para>The <c>Activate</c> method can be used to start executing work on a new virtual processor root returned by the Resource Manager, or to resume
        ///     the thread proxy on a virtual processor root that has deactivated or is about to deactivate. See <see cref="IVirtualProcessorRoot::Deactivate Method">
        ///     IVirtualProcessorRoot::Deactivate</see> for more information on deactivation. When you are resuming a deactivated virtual processor
        ///     root, the parameter <paramref name="pContext"/> must be the same as the parameter used to deactivate the virtual processor root.</para>
        ///     <para> Once a virtual processor root has been activated for the first time, subsequent pairs of calls to <c>Deactivate</c> and
        ///     <c>Activate</c> may race with each other. This means it is acceptable for the Resource Manager to receive a call to <c>Activate</c>
        ///     before it receives the <c>Deactivate</c> call it was meant for.</para>
        ///     <para>When you activate a virtual processor root, you signal to the Resource Manager that this virtual processor root is currently
        ///     busy with work. If your scheduler cannot find any work to execute on this root, it is expected to invoke the <c>Deactivate</c> method
        ///     informing the Resource Manager that the virtual processor root is idle. The Resource Manager uses this data to
        ///     load balance the system.</para>
        ///     <para><c>invalid_argument</c> is thrown if the argument <paramref name="pContext"/> has the value <c>NULL</c>.</para>
        ///     <para><c>invalid_operation</c> is thrown if the argument <paramref name="pContext"/> does not represent the execution context that
        ///     was most recently dispatched by this virtual processor root.</para>
        ///     <para>The act of activating a virtual processor root increases the subscription level of the underlying hardware thread by one. For more
        ///     information on subscription levels, see <see cref="IExecutionResource::CurrentSubscriptionLevel Method">
        ///     IExecutionResource::CurrentSubscriptionLevel</see>.</para>
        /// </remarks>
        /// <seealso cref="IVirtualProcessorRoot::Deactivate Method"/>
        /// <seealso cref="IExecutionResource::CurrentSubscriptionLevel Method"/>
        /**/
        virtual void Activate(IExecutionContext * pContext) =0;

        /// <summary>
        ///     Causes the thread proxy currently executing on this virtual processor root to stop dispatching the execution context. The thread proxy
        ///     will resume executing on a call to the <c>Activate</c> method.
        /// </summary>
        /// <param name="pContext">
        ///     The context which is currently being dispatched by this root.
        /// </param>
        /// <returns>
        ///     A boolean value. A value of <c>true</c> indicates that the thread proxy returned from the <c>Deactivate</c> method in response to
        ///     a call to the <c>Activate</c> method. A value of <c>false</c> indicates that the thread proxy returned from the method in response
        ///     to a notification event in the Resource Manager. On a user-mode schedulable (UMS) thread scheduler, this indicates that items have
        ///     appeared on the scheduler's completion list, and the scheduler is required to handle them.
        /// </returns>
        /// <remarks>
        ///     Use this method to temporarily stop executing a virtual processor root when you cannot find any work in your scheduler.
        ///     A call to the <c>Deactivate</c> method must originate from within the <c>Dispatch</c> method of the execution context that
        ///     the virtual processor root was last activated with. In other words, the thread proxy invoking the <c>Deactivate</c> method
        ///     must be the one that is currently executing on the virtual processor root. Calling the method on a virtual processor
        ///     root you are not executing on could result in undefined behavior.
        ///     <para>A deactivated virtual processor root may be woken up with a call to the <c>Activate</c> method, with the same
        ///     argument that was passed in to the <c>Deactivate</c> method. The scheduler is responsible for ensuring that calls to the <c>Activate</c>
        ///     and <c>Deactivate</c> methods are paired, but they are not required to be received in a specific order. The Resource
        ///     Manager can handle receiving a call to the <c>Activate</c> method before it receives a call to the <c>Deactivate</c> method it was
        ///     meant for.</para>
        ///     <para>If a virtual processor root awakens and the return value from the <c>Deactivate</c> method is the value <c>false</c>, the scheduler
        ///     should query the UMS completion list via the <c>IUMSCompletionList::GetUnblockNotifications</c> method, act on that information, and
        ///     then subsequently call the <c>Deactivate</c> method again.  This should be repeated until such time as the <c>Deactivate</c> method returns
        ///     the value <c>true</c>.</para>
        ///     <para><c>invalid_argument</c> is thrown if the argument <paramref name="pContext"/> has the value <c>NULL</c>.</para>
        ///     <para><c>invalid_operation</c> is thrown if the virtual processor root has never been activated, or the argument <paramref name="pContext"/>
        ///     does not represent the execution context that was most recently dispatched by this virtual processor root.</para>
        ///     <para>The act of deactivating a virtual processor root decreases the subscription level of the underlying hardware thread by one.  For
        ///     more information on subscription levels, see <see cref="IExecutionResource::CurrentSubscriptionLevel Method">
        ///     IExecutionResource::CurrentSubscriptionLevel</see>.</para>
        /// </remarks>
        /// <seealso cref="IVirtualProcessorRoot::Activate Method"/>
        /// <seealso cref="IExecutionResource::CurrentSubscriptionLevel Method"/>
        /// <seealso cref="IUMSCompletionList::GetUnblockNotifications Method"/>
        /**/
        virtual bool Deactivate(IExecutionContext * pContext) =0;

        /// <summary>
        ///     Causes data stored in the memory hierarchy of individual processors to become visible to all processors on the system.
        ///     It ensures that a full memory fence has been executed on all processors before the method returns.
        /// </summary>
        /// <param name="pContext">
        ///     The context which is currently being dispatched by this virtual processor root.
        /// </param>
        /// <remarks>
        ///     You may find this method useful when you want to synchronize deactivation of a virtual processor root with the addition of new work into
        ///     the scheduler. For performance reasons, you may decide to add work items to your scheduler without executing a memory barrier, which
        ///     means work items added by a thread executing on one processor are not immediately visible to all other processors. By using this method
        ///     in conjunction with the <c>Deactivate</c> method you can ensure that your scheduler does not deactivate all its virtual processor
        ///     roots while work items exist in your scheduler's collections.
        ///     <para> A call to the <c>EnsureAllTasksVisibleThe</c> method must originate from within the <c>Dispatch</c> method of the execution
        ///     context that the virtual processor root was last activated with. In other words, the thread proxy invoking the <c>EnsureAllTasksVisible</c>
        ///     method must be the one that is currently executing on the virtual processor root. Calling the method on a virtual processor
        ///     root you are not executing on could result in undefined behavior.</para>
        ///     <para><c>invalid_argument</c> is thrown if the argument <paramref name="pContext"/> has the value <c>NULL</c>.</para>
        ///     <para><c>invalid_operation</c> is thrown if the virtual processor root has never been activated, or the argument <paramref name="pContext"/>
        ///     does not represent the execution context that was most recently dispatched by this virtual processor root.</para>
        /// </remarks>
        /// <seealso cref="IVirtualProcessorRoot::Deactivate Method"/>
        /**/
        virtual void EnsureAllTasksVisible(IExecutionContext *pContext) =0;
    };

    /// <summary>
    ///     An interface to an abstraction of a work scheduler. The Concurrency Runtime's Resource Manager uses this interface to communicate with work
    ///     schedulers.
    /// </summary>
    /// <remarks>
    ///     If you are implementing a custom scheduler that communicates with the Resource Manager, you should provide an implementation of the
    ///     <c>IScheduler</c> interface. This interface is one end of a two-way channel of communication between a scheduler and the
    ///     Resource Manager.  The other end is represented by the <c>IResourceManager</c> and <c>ISchedulerProxy</c> interfaces which are
    ///     implemented by the Resource Manager.
    /// </remarks>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="IExecutionContext Structure"/>
    /// <seealso cref="IThreadProxy Structure"/>
    /// <seealso cref="IVirtualProcessorRoot Structure"/>
    /// <seealso cref="IResourceManager Structure"/>
    /**/
    struct IScheduler
    {
        /// <summary>
        ///     Returns a unique identifier for the scheduler.
        /// </summary>
        /// <returns>
        ///     A unique integer identifier.
        /// </returns>
        /// <remarks>
        ///     You should use the <see cref="GetSchedulerId Function">GetSchedulerId</see> function to obtain a unique identifier for the object
        ///     that implements the <c>IScheduler</c> interface, before you use the interface as a parameter to methods supplied by the Resource Manager.
        ///     You are expected to return the same identifier when the <c>GetId</c> function is invoked. <para> An identifier obtained from a different
        ///     source could result in undefined behavior.</para>
        /// </remarks>
        /**/
        virtual unsigned int GetId() const =0;

        /// <summary>
        ///     Provides information related to task arrival and completion rates, and change in queue length for a scheduler.
        /// </summary>
        /// <param name="pTaskCompletionRate">
        ///     The number of tasks that have been completed by the scheduler since the last call to this method.
        /// </param>
        /// <param name="pTaskArrivalRate">
        ///     The number of tasks that have arrived in the scheduler since the last call to this method.
        /// </param>
        /// <param name="pNumberOfTasksEnqueued">
        ///     The total number of tasks in all scheduler queues.
        /// </param>
        /// <remarks>
        ///     This method is invoked by the Resource Manager in order to gather statistics for a scheduler.  The statistics gathered here
        ///     will be used to drive dynamic feedback algorithms to determine when it is appropriate to assign more resources to
        ///     the scheduler and when to take resources away.  The values provided by the scheduler can be optimistic and do not necessarily
        ///     have to reflect the current count accurately.
        ///     <para> You should implement this method if you want the Resource Manager to use feedback about task arrival, etc. to determine
        ///     how to balance resource between your scheduler and other schedulers registered with the Resource Manager. If you choose not to
        ///     gather statistics, you can set the policy key <c>DynamicProgressFeedback</c> to the value <c>DynamicProgressFeedbackDisabled</c>
        ///     in your scheduler's policy, and the Resource Manager will not invoke this method on your scheduler.</para>
        ///     <para>In the absence of statistical information, the Resource Manager will use hardware thread subscription levels to make
        ///     resource allocation and migration decisions. For more information on subscription levels, see
        ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method"> IExecutionResource::CurrentSubscriptionLevel</see>.</para>
        /// </remarks>
        /// <seealso cref="PolicyElementKey Enumeration"/>
        /// <seealso cref="IExecutionResource::CurrentSubscriptionLevel Method"/>
        /**/
        virtual void Statistics(unsigned int * pTaskCompletionRate, unsigned int * pTaskArrivalRate, unsigned int * pNumberOfTasksEnqueued) =0;

        /// <summary>
        ///     Returns a copy of the scheduler's policy. For more information on scheduler policies, see <see cref="SchedulerPolicy Class">
        ///     SchedulerPolicy</see>.
        /// </summary>
        /// <returns>
        ///     A copy of the scheduler's policy.
        /// </returns>
        /// <seealso cref="SchedulerPolicy Class"/>
        /**/
        virtual SchedulerPolicy GetPolicy() const =0;

        /// <summary>
        ///     Provides a scheduler with a set of virtual processor roots for its use. Each <c>IVirtualProcessorRoot</c> interface represents
        ///     the right to execute a single thread that can perform work on behalf of the scheduler.
        /// </summary>
        /// <param name="ppVirtualProcessorRoots">
        ///     An array of <c>IVirtualProcessorRoot</c> interfaces representing the virtual processor roots being added to the scheduler.
        /// </param>
        /// <param name="count">
        ///     The number of <c>IVirtualProcessorRoot</c> interfaces in the array.
        /// </param>
        /// <remarks>
        ///     The Resource Manager invokes the <c>AddVirtualProcessor</c> method to grant an initial set of virtual processor roots to
        ///     a scheduler. It could also invoke the method to add virtual processor roots to the scheduler when it rebalances resources
        ///     among schedulers.
        /// </remarks>
        /// <seealso cref="IVirtualProcessorRoot Structure"/>
        /// <seealso cref="IScheduler::RemoveVirtualProcessors Method"/>
        /**/
        virtual void AddVirtualProcessors(IVirtualProcessorRoot ** ppVirtualProcessorRoots, unsigned int count) =0;

        /// <summary>
        ///     Initiates the removal of virtual processor roots that were previously allocated to this scheduler.
        /// </summary>
        /// <param name="ppVirtualProcessorRoots">
        ///     An array of <c>IVirtualProcessorRoot</c> interfaces representing the virtual processor roots to be removed.
        /// </param>
        /// <param name="count">
        ///     The number of <c>IVirtualProcessorRoot</c> interfaces in the array.
        /// </param>
        /// <remarks>
        ///     The Resource Manager invokes the <c>RemoveVirtualProcessors</c> method to take back a set of virtual processor roots from
        ///     a scheduler. The scheduler is expected to invoke the <see cref="IExecutionResource::Remove Method">Remove</see> method on each
        ///     interface when it is done with the virtual processor roots. Do not use an <c>IVirtualProcessorRoot</c> interface once you have
        ///     invoked the <c>Remove</c> method on it.
        ///     <para>The parameter <paramref name="ppVirtualProcessorRoots"/> points to an array of interfaces. Among the set of virtual processor
        ///     roots to be removed, the roots have never been activated can be returned immediately using the <c>Remove</c> method.
        ///     The roots that have been activated and are either executing work, or have been deactivated and are waiting for work to arrive, should be
        ///     returned asynchronously. The scheduler must make every attempt to remove the virtual processor root as quickly as possible.
        ///     Delaying removal of the virtual processor roots may result in unintentional oversubscription within the scheduler.</para>
        /// </remarks>
        /// <seealso cref="IVirtualProcessorRoot Structure"/>
        /// <seealso cref="IScheduler::RemoveVirtualProcessors Method"/>
        /**/
        virtual void RemoveVirtualProcessors(IVirtualProcessorRoot ** ppVirtualProcessorRoots, unsigned int count) =0;

        /// <summary>
        ///     Notifies this scheduler that the hardware threads represented by the set of virtual processor roots in the array
        ///     <paramref name="ppVirtualProcessorRoots"/> are not being used by other schedulers.
        /// </summary>
        /// <param name="ppVirtualProcessorRoots">
        ///     An array of <c>IVirtualProcessorRoot</c> interfaces associated with hardware threads on which other schedulers have become idle.
        /// </param>
        /// <param name="count">
        ///     The number of <c>IVirtualProcessorRoot</c> interfaces in the array.
        /// </param>
        /// <remarks>
        ///     It is possible for a particular hardware thread to be assigned to multiple schedulers at the same time. One reason for this could be
        ///     that there are not enough hardware threads on the system to satisfy the minimum concurrency for all schedulers, without sharing resources.
        ///     Another possibility is that resources are temporarily assigned to other schedulers when the owning scheduler is not using them, by way of
        ///     all its virtual processor roots on that hardware thread being deactivated.
        ///     <para>The subscription level of a hardware thread is denoted by the number of subscribed threads and activated virtual processor roots associated
        ///     with that hardware thread. From a particular scheduler's point of view, the external subscription level of a hardware thread is the portion
        ///     of the subscription other schedulers contribute to. Notifications that resources are externally busy are sent to a scheduler when the external
        ///     subscription level for a hardware thread falls to zero from a previous positive value.</para>
        ///     <para>Notifications via this method are only sent to schedulers that have a policy where the value for the <c>MinConcurrency</c>
        ///     policy key is equal to the value for the <c>MaxConcurrency</c> policy key. For more information on scheduler policies,
        ///     see <see cref="SchedulerPolicy Class">SchedulerPolicy</see>.</para>
        ///     <para>A scheduler that qualifies for notifications gets a set of initial notifications when it is created, informing it whether the
        ///     resources it was just assigned are externally busy or idle.</para>
        /// </remarks>
        /// <seealso cref="IExecutionResource::CurrentSubscriptionLevel Method"/>
        /// <seealso cref="IScheduler::NotifyResourcesExternallyBusy Method"/>
        /**/
        virtual void NotifyResourcesExternallyIdle(IVirtualProcessorRoot ** ppVirtualProcessorRoots, unsigned int count) =0;

        /// <summary>
        ///     Notifies this scheduler that the hardware threads represented by the set of virtual processor roots in the array
        ///     <paramref name="ppVirtualProcessorRoots"/> are now being used by other schedulers.
        /// </summary>
        /// <param name="ppVirtualProcessorRoots">
        ///     An array of <c>IVirtualProcessorRoot</c> interfaces associated with the hardware threads on which other schedulers have become busy.
        /// </param>
        /// <param name="count">
        ///     The number of <c>IVirtualProcessorRoot</c> interfaces in the array.
        /// </param>
        /// <remarks>
        ///     It is possible for a particular hardware thread to be assigned to multiple schedulers at the same time. One reason for this could be
        ///     that there are not enough hardware threads on the system to satisfy the minimum concurrency for all schedulers, without sharing resources.
        ///     Another possibility is that resources are temporarily assigned to other schedulers when the owning scheduler is not using them, by way of
        ///     all its virtual processor roots on that hardware thread being deactivated.
        ///     <para>The subscription level of a hardware thread is denoted by the number of subscribed threads and activated virtual processor roots associated
        ///     with that hardware thread. From a particular scheduler's point of view, the external subscription level of a hardware thread is the portion
        ///     of the subscription other schedulers contribute to. Notifications that resources are externally busy are sent to a scheduler when the external
        ///     subscription level for a hardware thread moves from zero into positive territory.</para>
        ///     <para>Notifications via this method are only sent to schedulers that have a policy where the value for the <c>MinConcurrency</c>
        ///     policy key is equal to the value for the <c>MaxConcurrency</c> policy key. For more information on scheduler policies,
        ///     see <see cref="SchedulerPolicy Class">SchedulerPolicy</see>.</para>
        ///     <para>A scheduler that qualifies for notifications gets a set of initial notifications when it is created, informing it whether the
        ///     resources it was just assigned are externally busy or idle.</para>
        /// </remarks>
        /// <seealso cref="IExecutionResource::CurrentSubscriptionLevel Method"/>
        /// <seealso cref="IScheduler::NotifyResourcesExternallyIdle Method"/>
        /**/
        virtual void NotifyResourcesExternallyBusy(IVirtualProcessorRoot ** ppVirtualProcessorRoots, unsigned int count) =0;
    };

    /// <summary>
    ///     Represents a notification from the Resource Manager that a thread proxy which blocked and triggered a return to the scheduler's
    ///     designated scheduling context has unblocked and is ready to be scheduled. This interface is invalid once the thread proxy's
    ///     associated execution context, returned from the <c>GetContext</c> method, is rescheduled.
    /// </summary>
    /// <seealso cref="IUMSScheduler Structure"/>
    /// <seealso cref="IUMSCompletionList Structure"/>
    /**/
    struct IUMSUnblockNotification
    {
        /// <summary>
        ///     Returns the <c>IExecutionContext</c> interface for the execution context associated with the thread proxy which has
        ///     unblocked.  Once this method returns and the underlying execution context has been rescheduled via a call to the
        ///     <c>IThreadProxy::SwitchTo</c> method, this interface is no longer valid.
        /// </summary>
        /// <returns>
        ///     An <c>IExecutionContext</c> interface for the execution context to a thread proxy which has unblocked.
        /// </returns>
        /**/
        virtual IExecutionContext* GetContext() =0;

        /// <summary>
        ///     Returns the next <c>IUMSUnblockNotification</c> interface in the chain returned from the method
        ///     <c>IUMSCompletionList::GetUnblockNotifications</c>.
        /// </summary>
        /// <returns>
        ///     The next <c>IUMSUnblockNotification</c> interface in the chain returned from the method <c>IUMSCompletionList::GetUnblockNotifications</c>.
        /// </returns>
        /**/
        virtual IUMSUnblockNotification* GetNextUnblockNotification() =0;
    };

    /// <summary>
    ///     Represents a UMS completion list.  When a UMS thread blocks, the scheduler's designated scheduling context is dispatched
    ///     in order to make a decision of what to schedule on the underlying virtual processor root while the original thread is blocked.  When the
    ///     original thread unblocks, the operating system queues it to the completion list which is accessible through this interface.  The scheduler can
    ///     query the completion list on the designated scheduling context or any other place it searches for work.
    /// </summary>
    /// <remarks>
    ///     A scheduler must be extraordinarily careful about what actions are performed after utilizing this interface to dequeue items from the completion
    ///     list.  The items should be placed on the scheduler's list of runnable contexts and be generally accessible as soon as possible.  It is entirely
    ///     possible that one of the dequeued items has been given ownership of an arbitrary lock.  The scheduler can make no arbitrary function calls that may
    ///     block between the call to dequeue items and the placement of those items on a list that can be generally accessed from within the scheduler.
    /// </remarks>
    /// <seealso cref="IUMSScheduler Structure"/>
    /// <seealso cref="IUMSUnblockNotification Structure"/>
    /**/
    struct IUMSCompletionList
    {
        /// <summary>
        ///     Retrieves a chain of <c>IUMSUnblockNotification</c> interfaces representing execution contexts whose associated thread proxies
        ///     have unblocked since the last time this method was invoked.
        /// </summary>
        /// <returns>
        ///     A chain of <c>IUMSUnblockNotification</c> interfaces.
        /// </returns>
        /// <remarks>
        ///     The returned notifications are invalid once the execution contexts are rescheduled.
        /// </remarks>
        /// <seealso cref="IUMSUnblockNotification Structure"/>
        /**/
        virtual IUMSUnblockNotification *GetUnblockNotifications() =0;
    };

    /// <summary>
    ///     An interface to an abstraction of a work scheduler that wants the Concurrency Runtime's Resource Manager to hand it user-mode 
    ///     schedulable (UMS) threads. The Resource Manager uses this interface to communicate with UMS thread schedulers. The <c>IUMSScheduler</c> interface
    ///     inherits from the <c>IScheduler</c> interface.
    /// </summary>
    /// <remarks>
    ///     If you are implementing a custom scheduler that communicates with the Resource Manager, and you want UMS threads to be handed to your scheduler
    ///     instead of ordinary Win32 threads, you should provide an implementation of the <c>IUMSScheduler</c> interface. In addition, you should set the
    ///     policy value for the scheduler policy key <c>SchedulerKind</c> to be <c>UmsThreadDefault</c>. If the policy specifies UMS thread, the
    ///     <c>IScheduler</c> interface that is passed as a parameter to the <see cref="IResourceManager::RegisterScheduler Method">IResourceManager::RegisterScheduler
    ///     </see> method must be an <c>IUMSScheduler</c> interface.
    ///     <para>The Resource Manager is able to hand you UMS threads only on operating systems that have the UMS feature. 64-bit operating systems with
    ///     version Windows 7 and higher support UMS threads.  If you create a scheduler policy with the <c>SchedulerKind</c> key set to the value
    ///     <c>UmsThreadDefault</c> and the underlying platform does not support UMS, the value of the <c>SchedulerKind</c> key on that policy will
    ///     be changed to the value <c>ThreadScheduler</c>.  You should always read back this policy value before expecting to receive UMS threads.</para>
    ///     <para> The <c>IUMSScheduler</c> interface is one end of a two-way channel of communication between a scheduler and the Resource Manager.
    ///     The other end is represented by the <c>IResourceManager</c> and <c>ISchedulerProxy</c> interfaces, which are implemented by the Resource Manager.</para>
    /// </remarks>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="IScheduler Structure"/>
    /// <seealso cref="IUMSCompletionList Structure"/>
    /// <seealso cref="IResourceManager Structure"/>
    /**/
    struct IUMSScheduler : public IScheduler
    {
        /// <summary>
        ///     Assigns an <c>IUMSCompletionList</c> interface to a UMS thread scheduler.
        /// </summary>
        /// <param name="pCompletionList">
        ///     The completion list interface for the scheduler.  There is a single list per scheduler.
        /// </param>
        /// <remarks>
        ///     The Resource Manager will invoke this method on a scheduler that specifies it wants UMS threads, after the scheduler has requested an initial
        ///     allocation of resources. The scheduler can use the <c>IUMSCompletionList</c> interface to determine when UMS thread proxies have unblocked.
        ///     It is only valid to access this interface from a thread proxy running on a virtual processor root assigned to the UMS scheduler.
        /// </remarks>
        /// <seealso cref="IScheduler Structure"/>
        /// <seealso cref="IUMSCompletionList Structure"/>
        /**/
        virtual void SetCompletionList(IUMSCompletionList * pCompletionList) =0;
    };

    /// <summary>
    ///     The interface by which schedulers communicate with the Concurrency Runtime's Resource Manager to negotiate resource allocation.
    /// </summary>
    /// <remarks>
    ///     The Resource Manager hands an <c>ISchedulerProxy</c> interface to every scheduler that registers with it using the
    ///     <see cref="IResourceManager::RegisterScheduler Method">IResourceManager::RegisterScheduler</see> method.
    /// </remarks>
    /// <seealso cref="IScheduler Structure"/>
    /// <seealso cref="IThreadProxy Structure"/>
    /// <seealso cref="IVirtualProcessorRoot Structure"/>
    /// <seealso cref="IResourceManager Structure"/>
    /**/
    struct ISchedulerProxy
    {
        /// <summary>
        ///     Requests an initial allocation of virtual processor roots. Every virtual processor root represents the ability to execute one thread
        ///     that can perform work for the scheduler.
        /// </summary>
        /// <param name="doSubscribeCurrentThread">
        ///     Whether to subscribe the current thread and account for it during resource allocation.
        /// </param>
        /// <returns>
        ///     The <c>IExecutionResource</c> interface for the current thread, if the parameter <paramref name="doSubscribeCurrentThread"/> has
        ///     the value <c>true</c>. If the value is <c>false</c>, the method returns <c>NULL</c>.
        /// </returns>
        /// <remarks>
        ///     Before a scheduler executes any work, it should use this method to request virtual processor roots from the Resource Manager. The Resource
        ///     Manager will access the scheduler's policy using <see cref="IScheduler::GetPolicy Method">IScheduler::GetPolicy</see> and use the 
        ///     values for the policy keys <c>MinConcurrency</c>, <c>MaxConcurrency</c> and <c>TargetOversubscriptionFactor</c> to determine how many 
        ///     hardware threads to assign to the scheduler initially and how many virtual processor roots to create for every hardware thread.
        ///     For more information on how scheduler policies are used to determine a scheduler's initial allocation, see <see cref="PolicyElementKey Enumeration">
        ///     PolicyElementKey</see>.
        ///     <para>The Resource Manager grants resources to a scheduler by calling the method <see cref="IScheduler::AddVirtualProcessors Method">
        ///     IScheduler::AddVirtualProcessors</see> with a list of virtual processor roots. The method is invoked as a callback into the scheduler
        ///     before this method returns.</para>
        ///     <para> If the scheduler requested subscription for the current thread by setting the parameter <paramref name="doSubscribeCurrentThread"/>
        ///     to <c>true</c>, the method returns an <c>IExecutionResource</c> interface. The subscription must be terminated at a later point by using
        ///     the <see cref="IExecutionResource::Remove Method">IExecutionResource::Remove</see> method.</para>
        ///     <para>When determining which hardware threads are selected, the Resource Manager will attempt to optimize for processor node affinity.
        ///     If subscription is requested for the current thread, it is an indication that the current thread intends to participate in the work assigned
        ///     to this scheduler. In such a case, the allocated virtual processors roots are located on the processor node the current thread is executing on,
        ///     if possible.</para>
        ///     <para>The act of subscribing a thread increases the subscription level of the underlying hardware thread by one. The subscription level is
        ///     reduced by one when the subscription is terminated. For more information on subscription levels, see 
        ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method">IExecutionResource::CurrentSubscriptionLevel</see>.</para>
        /// </remarks>
        /**/
        virtual IExecutionResource * RequestInitialVirtualProcessors(bool doSubscribeCurrentThread) =0; 

        /// <summary>
        ///     Notifies the Resource Manager that the scheduler is shutting down.  This will cause the Resource Manager to immediately reclaim
        ///     all resources granted to the scheduler.
        /// </summary>
        /// <remarks>
        ///     All <c>IExecutionContext</c> interfaces the scheduler received as a result of subscribing an external thread using the methods 
        ///     <c>ISchedulerProxy::RequestInitialVirtualProcessors</c> or <c>ISchedulerProxy::SubscribeCurrentThread</c> must be returned to the Resource 
        ///     Manager using <c>IExecutionResource::Remove</c> before a scheduler shuts itself down.
        ///     <para>If your scheduler had any deactivated virtual processor roots, you must activate them using <see cref="IVirtualProcessorRoot::Activate Method">
        ///     IVirtualProcessorRoot::Activate</see>, and have the thread proxies executing on them leave the <c>Dispatch</c> method of the execution contexts
        ///     they are dispatching before you invoke <c>Shutdown</c> on a scheduler proxy.</para>
        ///     <para>It is not necessary for the scheduler to individually return all of the virtual processor roots the Resource Manager granted to it via
        ///     calls to the <c>Remove</c> method since all virtual processors roots will be returned to the Resource Manager at shutdown.</para>
        /// </remarks>
        /// <seealso cref="ISchedulerProxy::RequestInitialVirtualProcessors Method"/>
        /// <seealso cref="ISchedulerProxy::SubscribeCurrentThread Method"/>
        /// <seealso cref="IExecutionResource::Remove Method"/>
        /**/
        virtual void Shutdown() =0;

        /// <summary>
        ///     Associates an execution context with a thread proxy, if it is not already associated with one.
        /// </summary>
        /// <param name="pContext">
        ///     An interface to the execution context to associate with a thread proxy.
        /// </param>
        /// <remarks>
        ///     Normally, the <see cref="IThreadProxy::SwitchTo Method">IThreadProxy::SwitchTo</see> method will bind a thread proxy to an
        ///     execution context on demand.  There are, however, circumstances where it is necessary to bind a context in advance
        ///     to ensure that the <c>SwitchTo</c> method switches to an already bound context.  This is the case on a UMS scheduling context as it
        ///     cannot call methods that allocate memory, and binding a thread proxy may involve memory allocation if a thread proxy is not readily
        ///     available in the free pool of the thread proxy factory.
        ///     <para><c>invalid_argument</c> is thrown if the parameter <paramref name="pContext"/> has the value <c>NULL</c>.</para>
        /// </remarks>
        /// <seealso cref="ISchedulerProxy::UnbindContext Method"/>
        /**/
        virtual void BindContext(IExecutionContext * pContext) =0;

        /// <summary>
        ///     Disassociates a thread proxy from the execution context specified by the <paramref name="pContext"/> parameter and returns it
        ///     to the thread proxy factory's free pool.  This method may only be called on an execution context which was bound via the 
        ///     <see cref="ISchedulerProxy::BindContext Method">ISchedulerProxy::BindContext</see> method and has not yet been started via being
        ///     the <c>pContext</c> parameter of an <see cref="IThreadProxy::SwitchTo Method">IThreadProxy::SwitchTo</see> method call.
        /// </summary>
        /// <param name="pContext">
        ///     The execution context to disassociate from its thread proxy.
        /// </param>
        /**/
        virtual void UnbindContext(IExecutionContext * pContext) =0;

        /// <summary>
        ///     Registers the current thread with the Resource Manager, associating it with this scheduler.
        /// </summary>
        /// <returns>
        ///     The <c>IExecutionResource</c> interfacing representing the current thread in the runtime.
        /// </returns>
        /// <remarks>
        ///     Use this method if you want the Resource Manager to account for the current thread while allocating resources to your scheduler and other
        ///     schedulers. It is especially useful when the thread plans to participate in the work queued to your scheduler, along with the virtual
        ///     processor roots the scheduler receives from the Resource Manager. The Resource Manager uses information to prevent unnecessary oversubscription
        ///     of hardware threads on the system.
        ///     <para>The execution resource received via this method should be returned to the Resource Manager using the
        ///     <see cref="IExecutionResource::Remove Method">IExecutionResource::Remove</see> method. The thread that calls the <c>Remove</c> method must be
        ///     the same thread that previously called the <c>SubscribeCurrentThread</c> method.</para>
        ///     <para>The act of subscribing a thread increases the subscription level of the underlying hardware thread by one. The subscription level is
        ///     reduced by one when the subscription is terminated. For more information on subscription levels, see
        ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method">IExecutionResource::CurrentSubscriptionLevel</see>.</para>
        /// </remarks>
        /**/
        virtual IExecutionResource * SubscribeCurrentThread() =0;

        /// <summary>
        ///     Creates a new virtual processor root on the hardware thread associated with an existing execution resource.
        /// </summary>
        /// <param name="pExecutionResource">
        ///     An <c>IExecutionResource</c> interface that represents the hardware thread you want to oversubscribe.
        /// </param>
        /// <returns>
        ///     An <c>IVirtualProcessorRoot</c> interface.
        /// </returns>
        /// <remarks>
        ///     Use this method when your scheduler wants to oversubscribe a particular hardware thread for a limited amount of time. Once you are
        ///     done with the virtual processor root, you should return it to the resource manager by calling the
        ///     <see cref="IExecutionResource::Remove Method">Remove</see> method on the <c>IVirtualProcessorRoot</c> interface.
        ///     <para>You may even oversubscribe an existing virtual processor root, since the <c>IVirtualProcessorRoot</c> interface inherits from the
        ///     <c>IExecutionResource</c> interface.</para>
        /// </remarks>
        /**/
        virtual IVirtualProcessorRoot * CreateOversubscriber(IExecutionResource * pExecutionResource) =0;
    };

    /// <summary>
    ///     Indicates support of the Resource Manager interface defined in Visual Studio 2010.
    /// </summary>
    /**/
    const unsigned int CONCRT_RM_VERSION_1 = 0x00010000;

    /// <summary>
    ///     An interface to the Concurrency Runtime's Resource Manager. This is the interface by which schedulers communicate with the
    ///     Resource Manager.
    /// </summary>
    /// <remarks>
    ///     Use the <see cref="CreateResourceManager Function">CreateResourceManager</see> function to obtain an interface to the singleton Resource Manager
    ///     instance.  The method increments a reference count on the Resource Manager, and you should invoke the <see cref="IResourceManager::Release Method">
    ///     IResourceManager::Release</see> method to release the reference when you are done with Resource Manager. Typically, each scheduler
    ///     you create will invoke this method during creation, and release the reference to the Resource Manager after it shuts down.
    /// </remarks>
    /// <seealso cref="ISchedulerProxy Structure"/>
    /// <seealso cref="IScheduler Structure"/>
    /**/
    struct IResourceManager
    {
        /// <summary>
        ///     Increments the reference count on the Resource Manager instance.
        /// </summary>
        /// <returns>
        ///     The resulting reference count.
        /// </returns>
        /// <seealso cref="IResourceManager::Release Method"/>
        /**/
        virtual unsigned int Reference() =0;

        /// <summary>
        ///     Decrements the reference count on the Resource Manager instance. The Resource Manager is destroyed when its reference count goes to <c>0</c>.
        /// </summary>
        /// <returns>
        ///     The resulting reference count.
        /// </returns>
        /// <seealso cref="CreateResourceManager Function"/>
        /// <seealso cref="IResourceManager::Reference Method"/>
        /**/
        virtual unsigned int Release() =0;

        /// <summary>
        ///     Registers a scheduler with the Resource Manager. Once the scheduler is registered, it should communicate with the Resource Manager using the
        ///     <c>ISchedulerProxy</c> interface that is returned.
        /// </summary>
        /// <param name="pScheduler">
        ///     An <c>IScheduler</c> interface to the scheduler to be registered.
        /// </param>
        /// <param name="version">
        ///     The version of communication interface the scheduler is using to communicate with the Resource Manager. Using a version allows the Resource
        ///     Manager to evolve the communication interface while allowing schedulers to obtain access to older features. Schedulers that wish to use Resource
        ///     Manager features present in Visual Studio 2010 should use the version <c>CONCRT_RM_VERSION_1</c>.
        /// </param>
        /// <returns>
        ///     The <c>ISchedulerProxy</c> interface the Resource Manager has associated with your scheduler. Your scheduler should use this interface to
        ///     communicate with Resource Manager from this point on.
        /// </returns>
        /// <remarks>
        ///     Use this method to initiate communication with the Resource Manager.  The method associates the <c>IScheduler</c> interface for your scheduler
        ///     with an <c>ISchedulerProxy</c> interface and hands it back to you. You can use the returned interface to request execution resources for use
        ///     by your scheduler, or to subscribe threads with the Resource Manager. The Resource Manager will use policy elements from the scheduler policy
        ///     returned by the <see cref="IScheduler::GetPolicy Method">IScheduler::GetPolicy</see> method to determine what type of threads the scheduler will
        ///     need to execute work. If your <c>SchedulerKind</c> policy key has the value <c>UmsThreadDefault</c> and the value is read back out of the
        ///     policy as the value <c>UmsThreadDefault</c>, the <c>IScheduler</c> interface passed to the method must be an <c>IUMSScheduler</c> interface.
        ///     <para>The method throws an <c>invalid_argument</c> exception if the parameter <paramref name="pScheduler"/> has the value <c>NULL</c> or if the
        ///     parameter <paramref name="version"/> is not a valid version for the communication interface.</para>
        /// </remarks>
        /// <seealso cref="IScheduler Structure"/>
        /// <seealso cref="ISchedulerProxy Structure"/>
        /// <seealso cref="SchedulerPolicy Class"/>
        /// <seealso cref="PolicyElementKey Enumeration"/>
        /**/
        virtual ISchedulerProxy *RegisterScheduler(IScheduler * pScheduler, unsigned int version) =0;

        /// <summary>
        ///     Present only in debug builds of the runtime, this method is a test hook designed to facilitate testing of the Resource Manager on varying hardware
        ///     topologies, without requiring actual hardware matching the configuration. With retail builds of the runtime, this method will return without performing
        ///     any action.
        /// </summary>
        /// <param name="nodeCount">
        ///     The number of processor nodes being simulated.
        /// </param>
        /// <param name="pCoreCount">
        ///     An array that specifies the number of cores on each node.
        /// </param>
        /// <param name="pNodeDistance">
        ///     A matrix specifying the node distance between any two nodes. This parameter can have the value <c>NULL</c>.
        /// </param>
        /// <param name="pProcessorGroups">
        ///     An array that specifies the processor group each node belongs to.
        /// </param>
        /// <remarks>
        ///     <see cref="invalid_argument Class">invalid_argument</see> is thrown if the parameter <paramref name="nodeCount"/> has the value <c>0</c> was passed
        ///     in, or if the parameter <paramref name="pCoreCount"/> has the value <c>NULL</c>.
        ///     <para><see cref="invalid_operation Class">invalid_operation</see> is thrown if this method is called while other schedulers exist in the process.</para>
        /// </remarks>
        /**/
        virtual void CreateNodeTopology(unsigned int nodeCount, unsigned int * pCoreCount, unsigned int ** pNodeDistance, unsigned int * pProcessorGroups) =0;

        /// <summary>
        ///     An enumerated type that represents the operating system version.
        /// </summary>
        /**/
        static enum OSVersion
        {
            /// <summary>
            ///     An operating system prior to Windows XP. The Concurrency Runtime is not supported on operating systems with a version earlier than Windows XP
            ///     with Service Pack 3.
            /// </summary>
            /**/
            UnsupportedOS,

            /// <summary>
            ///     The Windows XP operating system.
            /// </summary>
            /**/
            XP,

            /// <summary>
            ///     The Windows 2003 Server operating system.
            /// </summary>
            /**/
            Win2k3,

            /// <summary>
            ///     The Windows Vista operating system.
            /// </summary>
            /**/
            Vista,

            /// <summary>
            ///     Any operating system with version Windows 7 or higher.
            /// </summary>
            /**/
            Win7OrLater,

            /// <summary>
            ///     Any 64-bit operating system with version Windows 7 or higher. These operating systems support the user-mode schedulable threads feature.
            /// </summary>
            /**/
            UmsThreadAwareOS
        };
    };

    /// <summary>
    ///     Returns an interface that represents the singleton instance of the Concurrency Runtime's Resource Manager. The Resource Manager is responsible
    ///     for assigning resources to schedulers that want to cooperate with each other.
    /// </summary>
    /// <returns>
    ///     An <c>IResourceManager</c> interface.
    /// </returns>
    /// <remarks>
    ///     Multiple subsequent calls to this method will return the same instance of the Resource Manager. Each call to the method increments a reference
    ///     count on the Resource Manager, and must be matched with a call to the <see cref="IResourceManager::Release"> IResourceManager::Release</see>
    ///     method when your scheduler is done communicating with the Resource Manager.
    ///     <para><see cref="unsupported_os Class">unsupported_os</see> is thrown if the operating system is not supported by the Concurrency Runtime. The earliest
    ///     operating system supported is Windows XP with Service Pack 3.</para>
    /// </remarks>
    /// <seealso cref="IResourceManager::OSVersion Enumeration"/>
    /**/
    _CRTIMP IResourceManager* CreateResourceManager();

    /// <summary>
    ///     Returns the operating system version.
    /// </summary>
    /// <returns>
    ///     An enumerated value representing the operating system.
    /// </returns>
    /// <remarks>
    ///     <para><see cref="unsupported_os Class">unsupported_os</see> is thrown if the operating system is not supported by the Concurrency Runtime. The earliest
    ///     operating system supported is Windows XP with Service Pack 3.</para>
    /// </remarks>
    /// <seealso cref="IResourceManager::OSVersion Enumeration"/>
    /**/
    _CRTIMP IResourceManager::OSVersion GetOSVersion();

    /// <summary>
    ///     Returns a unique identifier that can be assigned to a scheduler that implements the <c>IScheduler</c> interface.
    /// </summary>
    /// <returns>
    ///     A unique identifier for a scheduler.
    /// </returns>
    /// <remarks>
    ///     Use this method to obtain an identifier for your scheduler before you pass an <c>IScheduler</c> interface as a parameter to any of the methods
    ///     offered by the Resource Manager.
    /// </remarks>
    /**/
    _CRTIMP unsigned int GetSchedulerId();

    /// <summary>
    ///     Returns a unique identifier that can be assigned to an execution context that implements the <c>IExecutionContext</c> interface.
    /// </summary>
    /// <returns>
    ///     A unique identifier for an execution context.
    /// </returns>
    /// <remarks>
    ///     Use this method to obtain an identifier for your execution context before you pass an <c>IExecutionContext</c> interface as a parameter to any
    ///     of the methods offered by the Resource Manager.
    /// </remarks>
    /**/
    _CRTIMP unsigned int GetExecutionContextId();

    /// <summary> 
    ///     Returns the number of hardware threads on the underlying system.
    /// </summary>
    /// <returns>
    ///     The number of hardware threads.
    /// </returns>
    /// <remarks>
    ///     <para><see cref="unsupported_os Class">unsupported_os</see> is thrown if the operating system is not supported by the Concurrency Runtime. The earliest
    ///     operating system supported is Windows XP with Service Pack 3.</para>
    /// </remarks>
    /// <seealso cref="IResourceManager::OSVersion Enumeration"/>
    /**/
    _CRTIMP unsigned int GetProcessorCount();

    /// <summary>
    ///     Returns the number of NUMA nodes or processor packages on the underlying system.
    /// </summary>
    /// <returns>
    ///     The number of NUMA nodes or processor packages.
    /// </returns>
    /// <remarks>
    ///     If the system contains more NUMA nodes than processor packages, the number of NUMA nodes is returned, otherwise, the number of processor packages is returned.
    ///     <para><see cref="unsupported_os Class">unsupported_os</see> is thrown if the operating system is not supported by the Concurrency Runtime. The earliest
    ///     operating system supported is Windows XP with Service Pack 3.</para>
    /// </remarks>
    /// <seealso cref="IResourceManager::OSVersion Enumeration"/>
    /**/
    _CRTIMP unsigned int GetProcessorNodeCount();
}

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\include\concrt.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
* 
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* concrt.h
*
* Main public header file for ConcRT. This is the only header file a C++ program should
* have to include in order to avail itself of the core concurrency runtime features.
*
* Agents and PPL live in separate headers.
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

#pragma once

#include <crtdefs.h>

#if !(defined(_M_AMD64) || defined(_M_IX86))
    #error ERROR: Concurrency Runtime is supported only on X64 and X86 architectures.
#endif

#if defined(_M_CEE)
    #error ERROR: Concurrency Runtime is not supported when compiling /clr.
#endif

#ifndef __cplusplus
    #error ERROR: Concurrency Runtime is supported only for C++.
#endif

#include <exception>
#include <sal.h>
#include <limits.h>
#include <crtdbg.h>
#include <guiddef.h>
#include <intrin.h>
#include <new>

#pragma pack(push,_CRT_PACKING)

// Forward declare structs needed from windows headers

struct _SECURITY_ATTRIBUTES;
typedef _SECURITY_ATTRIBUTES* LPSECURITY_ATTRIBUTES;

// Define essential types needed from windows headers

typedef unsigned long DWORD;
typedef long HRESULT;
typedef void * HANDLE;

// Undefine Yield that is possibly defined by windows.h, and _YieldProcessor just in case

#undef Yield
#undef _YieldProcessor

#define _YieldProcessor _mm_pause

// Make sure exchange pointer intrinsics work on x86

#if defined(_M_IX86)

#undef _InterlockedExchangePointer
#undef _InterlockedCompareExchangePointer

#define _InterlockedExchangePointer(_Target, _Value) reinterpret_cast<void *>(static_cast<__w64 long>(_InterlockedExchange( \
    static_cast<long volatile *>(reinterpret_cast<__w64 long volatile *>(static_cast<void * volatile *>(_Target))), \
    static_cast<long>(reinterpret_cast<__w64 long>(static_cast<void *>(_Value))))))

#define _InterlockedCompareExchangePointer(_Target, _Exchange, _Comparand) reinterpret_cast<void *>(static_cast<__w64 long>(_InterlockedCompareExchange( \
    static_cast<long volatile *>(reinterpret_cast<__w64 long volatile *>(static_cast<void * volatile *>(_Target))), \
    static_cast<long>(reinterpret_cast<__w64 long>(static_cast<void *>(_Exchange))), \
    static_cast<long>(reinterpret_cast<__w64 long>(static_cast<void *>(_Comparand))))))

#define _InterlockedIncrementSizeT(_Target) _InterlockedIncrement(reinterpret_cast<long volatile *>(_Target))
#define _InterlockedDecrementSizeT(_Target) _InterlockedDecrement(reinterpret_cast<long volatile *>(_Target))
#define _InterlockedCompareExchangeSizeT(_Target, _Exchange, _Comparand) _InterlockedCompareExchange( \
    reinterpret_cast<long volatile *>(_Target), \
    static_cast<long>(_Exchange), \
    static_cast<long>(_Comparand))

#else

#define _InterlockedIncrementSizeT(_Target) _InterlockedIncrement64(reinterpret_cast<__int64 volatile *>(_Target))
#define _InterlockedDecrementSizeT(_Target) _InterlockedDecrement64(reinterpret_cast<__int64 volatile *>(_Target))
#define _InterlockedCompareExchangeSizeT(_Target, _Exchange, _Comparand) _InterlockedCompareExchange64( \
    reinterpret_cast<__int64 volatile *>(_Target), \
    static_cast<__int64>(_Exchange), \
    static_cast<__int64>(_Comparand))

#endif

// Used internally to represent the smallest unit in which to allocate hidden types

typedef void * _CONCRT_BUFFER;

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{
/// <summary>
///     Pauses the current context for a specified amount of time.
/// </summary>
/// <param name="_Milliseconds">
///     The number of milliseconds that the current context should be paused for.  If the <paramref name="_Milliseconds"/> parameter is set to
///     the value <c>0</c>, it indicates that the current context should yield execution to other runnable contexts before continuing.
/// </param>
/// <remarks>
///     If this method is called on a Concurrency Runtime scheduler context, the scheduler will find a different context to run on the underlying
///     resource. Since the scheduler is cooperative in nature, this context may not resume exactly after the number of milliseconds specified.
///     If the scheduler is busy executing other tasks that do not cooperatively yield to the scheduler in a hurry, the wait period could be
///     indefinite.
/// </remarks>
/**/
_CRTIMP void __cdecl wait(unsigned int _Milliseconds);

/// <summary>
///     Allocates a block of memory of the size specified from the Concurrency Runtime's Caching Suballocator.
/// </summary>
/// <param name="_NumBytes">
///     The number of bytes of memory to allocate.
/// </param>
/// <returns>
///     A pointer to newly allocated memory.
/// </returns>
/// <remarks>
///     For more information on what scenarios in your application could benefit from using the Caching Suballocator,
///     see <see cref="Task Scheduler (Concurrency Runtime)"/>.
/// </remarks>
/// <seealso cref="Concurrency::Free Function"/>
/**/
_CRTIMP void * __cdecl Alloc(size_t _NumBytes);

/// <summary>
///     Frees a block of memory previously allocated by the <c>Alloc</c> method to the Concurrency Runtime's Caching Suballocator.
/// </summary>
/// <param name="_PAllocation">
///     A pointer to memory previously allocated by the <c>Alloc</c> method which is to be freed. If the parameter <paramref name="_PAllocation"/>
///     is set to the value <c>NULL</c>, this method will ignore it and return immediately.
/// </param>
/// <remarks>
///     For more information on what scenarios in your application could benefit from using the Caching Suballocator,
///     see <see cref="Task Scheduler (Concurrency Runtime)"/>.
/// </remarks>
/// <seealso cref="Concurrency::Alloc Function"/>
/**/
_CRTIMP void __cdecl Free(void * _PAllocation);

/// <summary>
///     Concurrency::details contains definitions of support routines in the public namespaces and some macros.
///     Users should not directly interact with this internal namespace.
/// </summary>
/**/
namespace details
{
    //
    // Forward declarations:
    //
    class ContextBase;
    class _TaskCollectionBase;

    //
    // A utility to hide operator delete from certain objects while still allowing the runtime to delete them internally.
    //
    template<class _T>
    void _InternalDeleteHelper(_T * _PObject)
    {
        delete _PObject;
    }

    // This class's purpose is solely to direct allocations of ConcRT classes
    // through a single point, using internal allocator.
    struct _AllocBase
    {
        // Standard operator new
        void * operator new(size_t _Size)
        {
            return Concurrency::Alloc(_Size);
        }

        // Standard operator delete
        void operator delete(void * _Ptr) throw()
        {
            Concurrency::Free(_Ptr);
        }

        // Standard operator new, no-throw version
        void * operator new(size_t _Size, const std::nothrow_t&) throw()
        {
            void * _Ptr;

            try
            {
                _Ptr = Concurrency::Alloc(_Size);
            }
            catch(...)
            {
                _Ptr = NULL;
            }

            return (_Ptr);
        }

        // Standard operator delete, no-throw version
        void operator delete(void * _Ptr, const std::nothrow_t&) throw()
        {
            operator delete(_Ptr);
        }

        // Standard operator new array
        void * operator new[](size_t _Size)
        {
            return operator new(_Size);
        }

        // Standard operator delete array
        void operator delete[](void * _Ptr) throw()
        {
            operator delete(_Ptr);
        }

        // Standard operator new array, no-throw version
        void * operator new[](size_t _Size, const std::nothrow_t& _No_throw) throw ()
        {
            return operator new(_Size, _No_throw);
        }

        // Standard operator delete array, no-throw version
        void operator delete[](void * _Ptr, const std::nothrow_t& _No_throw) throw()
        {
            operator delete(_Ptr, _No_throw);
        }

        // Standard operator new with void* placement
        void * operator new(size_t, void * _Location) throw()
        {
            return _Location;
        }

        // Standard operator delete with void* placement
        void operator delete(void *, void *) throw()
        {
        }

        // Standard operator new array with void* placement
        void * __cdecl operator new[](size_t, void * _Location) throw()
        {
            return _Location;
        }
        
        // Standard operator delete array with void* placement
        void __cdecl operator delete[](void *, void *) throw()
        {
        }
    };

    //
    // Wrappers for atomic access
    //
    template <size_t _Size>
    struct _Subatomic_impl { };

    template<>
    struct _Subatomic_impl<4> {
        template <typename _Ty>
        static void _StoreWithRelease(volatile _Ty& _Location, _Ty _Rhs) {
            _ReadWriteBarrier();
            _Location = _Rhs;
        }

        template <typename _Ty>
        static _Ty _LoadWithAquire(volatile _Ty& _Location) {
            _ReadWriteBarrier();
            return _Location;
        }

        template <typename _Ty>
        static _Ty _CompareAndSwap(volatile _Ty& _Location, _Ty _NewValue, _Ty _Comperand) {
            return (_Ty)_InterlockedCompareExchange((volatile long*)&_Location, (long)_NewValue, (long)_Comperand);
        }

        template <typename _Ty>
        static _Ty _FetchAndAdd(volatile _Ty& _Location, _Ty _Addend) {
            return (_Ty)_InterlockedExchangeAdd((volatile long*)&_Location, (long)_Addend);
        }

        template <typename _Ty>
        static _Ty _Increment(volatile _Ty& _Location) {
            return (_Ty)_InterlockedIncrement((volatile long*)&_Location);
        }

        template <typename _Ty>
        static _Ty _Decrement(volatile _Ty& _Location) {
            return (_Ty)_InterlockedDecrement((volatile long*)&_Location);
        }
    };

#if defined(_M_X64)
    template<>
    struct _Subatomic_impl<8> {
        template <typename _Ty>
        static void _StoreWithRelease(volatile _Ty& _Location, _Ty _Rhs) {
            _ReadWriteBarrier();
            _Location = _Rhs;
        }

        template <typename _Ty>
        static _Ty _LoadWithAquire(volatile _Ty& _Location) {
            _ReadWriteBarrier();
            return _Location;
        }

        template <typename _Ty>
        static _Ty _CompareAndSwap(volatile _Ty& _Location, _Ty _NewValue, _Ty _Comperand) {
            return (_Ty)_InterlockedCompareExchange64((volatile __int64*)&_Location, (__int64)_NewValue, (__int64)_Comperand);
        }

        template <typename _Ty>
        static _Ty _FetchAndAdd(volatile _Ty& _Location, _Ty _Addend) {
            return (_Ty)_InterlockedExchangeAdd64((volatile __int64*)&_Location, (__int64)_Addend);
        }

        template <typename _Ty>
        static _Ty _Increment(volatile _Ty& _Location) {
            return (_Ty)_InterlockedIncrement64((volatile __int64*)&_Location);
        }

        template <typename _Ty>
        static _Ty _Decrement(volatile _Ty& _Location) {
            return (_Ty)_InterlockedDecrement64((volatile __int64*)&_Location);
        }
    };
#endif


    //
    // Wrapper for atomic access.  Only works for 4-byte or 8-byte types (e.g., int, long, long long, size_t, pointer).
    // Anything else will likely fail to compile.
    // 
    template <typename _Ty> 
    class _Subatomic {
    private:
        volatile _Ty _M_value;

    public:
        operator _Ty() const volatile {
            return _Subatomic_impl<sizeof(_Ty)>::_LoadWithAquire(_M_value);
        }

        _Ty operator=(_Ty _Rhs) {
            _Subatomic_impl<sizeof(_Ty)>::_StoreWithRelease(_M_value, _Rhs);
            return _Rhs;
        }

        _Ty _CompareAndSwap(_Ty _NewValue, _Ty _Comperand) {
            return _Subatomic_impl<sizeof(_Ty)>::_CompareAndSwap(_M_value, _NewValue, _Comperand);
        }

        _Ty _FetchAndAdd(_Ty _Addend) {
            return _Subatomic_impl<sizeof(_Ty)>::_FetchAndAdd(_M_value, _Addend);
        }

        _Ty operator++() {
            return _Subatomic_impl<sizeof(_Ty)>::_Increment(_M_value);
        }

        _Ty operator++(int) {
            return _Subatomic_impl<sizeof(_Ty)>::_Increment(_M_value) - 1;
        }

        _Ty operator--() {
            return _Subatomic_impl<sizeof(_Ty)>::_Decrement(_M_value);
        }

        _Ty operator--(int) {
            return _Subatomic_impl<sizeof(_Ty)>::_Decrement(_M_value) + 1;
        }

        _Ty operator+=(_Ty _Addend) {
            return _FetchAndAdd(_Addend) + _Addend;
        }
    };

    //
    // An RAII class that spin-waits on a "rented" flag.
    //
    class _SpinLock
    {
    private:
        volatile long& _M_flag;

    public:
        _CRTIMP _SpinLock(volatile long& _Flag);
        _CRTIMP ~_SpinLock();

    private:
        _SpinLock(const _SpinLock&);
        void operator=(const _SpinLock&);
    };

    //
    // A class that holds the count used for spinning and is dependent
    // on the number of hardware threads
    //
    struct _SpinCount
    {
        // Initializes the spinCount to either 0 or SPIN_COUNT, depending on
        // the number of hardware threads.  
        static void __cdecl _Initialize();

        // Returns the current value of s_spinCount
        _CRTIMP static unsigned int __cdecl _Value();

        // The number of iterations used for spinning
        static unsigned int _S_spinCount;
    };

    /// <summary>
    ///     Default method for yielding during a spin wait
    /// </summary>
    /**/
    void _CRTIMP __cdecl _UnderlyingYield();

    /// <summary>
    ///     Implements busy wait with no backoff
    /// </summary>
    /**/
    template<unsigned int _YieldCount = 1>
    class _CRTIMP _SpinWait
    {
    public:

        typedef void (__cdecl *_YieldFunction)();

        /// <summary>
        ///     Construct a spin wait object
        /// </summary>
        /**/
        _SpinWait(_YieldFunction _YieldMethod = _UnderlyingYield)
            : _M_yieldFunction(_YieldMethod), _M_state(_StateInitial)
        {
            // Defer initialization of other fields to _SpinOnce().
        }

        /// <summary>
        ///     Set a dynamic spin count.
        /// </summary>
        /**/
        void _SetSpinCount(unsigned int _Count)
        {
            _ASSERTE(_M_state == _StateInitial);
            if (_Count == 0)
            {
                // Specify a count of 0 if we are on a single proc.
                _M_state = _StateSingle;
            }
            else
            {
                _M_currentSpin = _Count;
                _M_currentYield = _YieldCount;
                _M_state = _StateSpin;
            }
        }

        /// <summary>
        ///     Spins for one time quantum,until a maximum spin is reached.
        /// </summary>
        /// <returns>
        ///     false if spin count has reached steady state, true otherwise.
        /// </returns>
        /// <remarks>
        ///     If the spin count is not changing that means that it is probably not a good idea to spin again
        ///     because there is either only one processor, or maximum spin has been reached and blocking is
        ///     probably a better solution. However, if called again, SpinOnce will spin for a maximum spin count.
        /// </remarks>
        /**/
        bool _SpinOnce()
        {
            switch (_M_state)
            {
            case _StateSpin:
            {
                unsigned long _Count = _NumberOfSpins();

                for (unsigned long _I = 0; _I < _Count; _I++)
                {
                    _YieldProcessor();
                }

                if (!_ShouldSpinAgain())
                {
                    _M_state = (_M_currentYield == 0) ? _StateBlock : _StateYield;
                }

                return true;
            }

            case _StateYield:
                _ASSERTE(_M_currentYield > 0);
                if (--_M_currentYield == 0)
                {
                    _M_state = _StateBlock;
                }

                // Execute the yield
                _DoYield();
                return true;

            case _StateBlock:
                // Reset to defaults if client does not block
                _Reset();
                return false;

            case _StateSingle:
                // No need to spin on a single processor: just execute the yield
                _DoYield();
                return false;

            case _StateInitial:
                // Reset counters to their default value and Spin once.
                _Reset();
                return _SpinOnce();
            default:
                // Unreached
                return false;
            };
        }

    protected:

        /// <summary>
        ///     State of the spin wait class.
        /// </summary>
        /**/
        enum _SpinState
        {
            _StateInitial,
            _StateSpin,
            _StateYield,
            _StateBlock,
            _StateSingle
        };

        /// <summary>
        ///     Yields its time slice using the specified yieldFunciton
        /// </summary>
        /**/
        void _DoYield()
        {
            bool _ShouldYield = (_YieldCount != 0);
            if (_ShouldYield)
            {
                _ASSERTE(_M_yieldFunction != NULL);
                _M_yieldFunction();
            }
            else
            {
                _YieldProcessor();
            }
        }

        /// <summary>
        ///     Resets the counts and state to the default.
        /// </summary>
        /**/
        void _Reset()
        {
            _M_state = _StateInitial;

            // Reset to the default spin value. The value specified
            // by the client is ignored on a reset.
            _SetSpinCount(_SpinCount::_Value());

            _ASSERTE(_M_state != _StateInitial);
        }

        /// <summary>
        ///     Determines the current spin count
        /// </summary>
        /// <returns>
        ///     The number of spins to execute for this iteration
        /// </returns>
        /**/
        unsigned long _NumberOfSpins()
        {
            return 1;
        }

        /// <summary>
        ///     Determines whether maximum spin has been reached
        /// </summary>
        /// <returns>
        ///     false if spin count has reached steady state, true otherwise.
        /// </returns>
        /**/
        bool _ShouldSpinAgain()
        {
            return (--_M_currentSpin > 0);
        }

        unsigned long  _M_currentSpin;
        unsigned long  _M_currentYield;
        _SpinState     _M_state;
        _YieldFunction _M_yieldFunction;
    };

    typedef _SpinWait<>   _SpinWaitBackoffNone;
    typedef _SpinWait<0>  _SpinWaitNoYield;

    //
    // This reentrant lock uses CRITICAL_SECTION and is intended for use when kernel blocking
    // is desirable and where it is either known that the lock will be taken recursively in 
    // the same thread, or when it is just not known that a non-reentrant lock can be used safely.
    //
    class _ReentrantBlockingLock
    {
    public:
        // Constructor for _ReentrantBlockingLock
        _CRTIMP _ReentrantBlockingLock();

        // Destructor for _ReentrantBlockingLock
        _CRTIMP ~_ReentrantBlockingLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire();

        // Tries to acquire the lock, does not spin.
        // Returns true if the acquisition worked, false otherwise
        _CRTIMP bool _TryAcquire();

        // Releases the lock
        _CRTIMP void _Release();


        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            explicit _Scoped_lock(_ReentrantBlockingLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            // Destroys the holder and releases the lock
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _ReentrantBlockingLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // Critical section requires windows.h. Hide the implementation so that
        // user code need not include windows.
        _CONCRT_BUFFER _M_criticalSection[(4 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    //
    // This reentrant lock is a pure spin lock and is intended for use when kernel blocking
    // is desirable and where it is either known that the lock will be taken recursively in 
    // the same thread, or when it is just not known that a non-reentrant lock can be used safely.
    //
    class _ReentrantLock
    {
    public:
        // Constructor for _ReentrantLock
        _CRTIMP _ReentrantLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire();

        // Tries to acquire the lock, does not spin
        // Returns true if the acquisition worked, false otherwise
        _CRTIMP bool _TryAcquire();

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            explicit _Scoped_lock(_ReentrantLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            // Destroys the holder and releases the lock
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _ReentrantLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        long _M_recursionCount;
        volatile long _M_owner;
    };

    //
    // This non-reentrant lock uses CRITICAL_SECTION and is intended for use in situations
    // where it is known that the lock will not be taken recursively, and can thus be more 
    // efficiently implemented.
    //
    class _NonReentrantBlockingLock
    {
    public:
        // Constructor for _NonReentrantBlockingLock
        //  
        // The constructor is exported because of _NonReentrantLock's 
        // inclusion in DevUnitTests.  It is also used in RM.
        _CRTIMP _NonReentrantBlockingLock();

        // Constructor for _NonReentrantBlockingLock
        _CRTIMP ~_NonReentrantBlockingLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire();

        // Tries to acquire the lock, does not spin
        // Returns true if the lock is taken, false otherwise
        _CRTIMP bool _TryAcquire();

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            explicit _Scoped_lock(_NonReentrantBlockingLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            // Destroys the holder and releases the lock
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _NonReentrantBlockingLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // Critical section requires windows.h. Hide the implementation so that
        // user code need not include windows.h
        _CONCRT_BUFFER _M_criticalSection[(4 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    //
    // A Reader-Writer Lock is intended for use in situations with many readers and rare 
    // writers.  
    //
    // A writer request immediately blocks future readers and then waits until all current
    // readers drain.  A reader request does not block future writers and must wait until 
    // all writers are done, even those that cut in front of it.  In any race between a
    // reader and a writer, the writer always wins.
    //
    class _ReaderWriterLock
    {
    public:
        // Constructor for _ReaderWriterLock
        //  
        // The constructor and destructor are exported because of _ReaderWriterLock's 
        // inclusion in DevUnitTests.  We may want to revisit whether we actually want
        // to export this in the future.
        _CRTIMP _ReaderWriterLock();

        // Acquire lock for reading.  Spins until all writers finish, new writers
        // can cut in front of a waiting reader.
        _CRTIMP void _AcquireRead();

        // Release lock for reading.  The last reader changes m_state to State.kFree
        _CRTIMP void _ReleaseRead();

        // Acquire lock for writing. Spin until no readers exist, then acquire lock
        // and prevent new readers.
        _CRTIMP void _AcquireWrite();

        // Release lock for writing.
        _CRTIMP void _ReleaseWrite();

        // Try to acquire the write lock, do not spin if unable to acquire.
        // Returns true if the acquisition worked, false otherwise
        _CRTIMP bool _TryAcquireWrite();

        // Returns true if it is in write state, false otherwise
        bool _HasWriteLock() const
        {
            return (_M_state == _Write);
        }

        // Guarantees that all writers are out of the lock.  This does nothing if there are no pending writers.
        void _FlushWriteOwners();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the writer lock
            explicit _Scoped_lock(_ReaderWriterLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._AcquireWrite();
            }

            // Destroys the holder and releases the writer lock
            ~_Scoped_lock()
            {
                _M_lock._ReleaseWrite();
            }

        private:

            _ReaderWriterLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

        // An exception safe RAII wrapper for reads.
        class _Scoped_lock_read
        {
        public:
            // Constructs a holder and acquires the reader lock
            explicit _Scoped_lock_read(_ReaderWriterLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._AcquireRead();
            }

            // Destroys the holder and releases the reader lock
            ~_Scoped_lock_read()
            {
                _M_lock._ReleaseRead();
            }

        private:

            _ReaderWriterLock& _M_lock;

            _Scoped_lock_read(const _Scoped_lock_read&);                    // no copy constructor
            _Scoped_lock_read const & operator=(const _Scoped_lock_read&);  // no assignment operator
        };

    private:
        // State enum where:
        // -1    --> write mode
        // 0     --> free
        // n > 0 --> n readers have locked in read mode.
        enum _State
        {
          _Write = -1,
          _Free  = 0,
          _Read  = 1
        };

        // The current state of the lock, mapping to the State enum.  This is also
        // an indicator of the number of readers holding the lock, for any number > 0.
        volatile long _M_state;

        // A writer increments this as soon as it wants to lock and decrements this 
        // after releasing the lock. To prevent writers from starving, a reader will 
        // wait until this counter is zero, and only then will try to obtain the lock.
        volatile long _M_numberOfWriters;

        // Spin-Wait-Until variant
        static void __cdecl _WaitEquals(volatile const long& _Location, long _Value, long _Mask = 0xFFFFFFFF);
    };

    //
    // An exception safe RAII wrapper for  _malloca()
    //
    class _MallocaHolder
    {
    public:

        _MallocaHolder(void *pMemory) : m_pMemory(pMemory)
        {
        }

        ~_MallocaHolder()
        {
            _freea(m_pMemory);
        }

    private:

        void *m_pMemory;
    };

    // Forward declarations
    class _StructuredTaskCollection;
    class _TaskCollection;
    class _UnrealizedChore;
} // namespace details

//**************************************************************************
// Public Namespace:
//
// Anything in the Concurrency namespace is intended for direct client consumption.
//
//**************************************************************************

//
// Forward declarations:
//
class Scheduler;

/// <summary>
///     This class describes an exception that is thrown due to failure to acquire a critical resource in the Concurrency Runtime.
/// </summary>
/// <remarks>
///     This exception is typically thrown when a call to the operating system from within the Concurrency Runtime
///     fails.  The error code which would normally be returned from a call to the Win32 method <c>GetLastError</c> is
///     converted to a value of type <c>HRESULT</c> and can be retrieved via the <c>get_error_code</c> method.
/// </remarks>
/**/
class scheduler_resource_allocation_error : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>scheduler_resource_allocation_error</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /// <param name="_Hresult">
    ///     The <c>HRESULT</c> value of the error that caused the exception.
    /// </param>
    /**/
    _CRTIMP scheduler_resource_allocation_error(const char * _Message, HRESULT _Hresult) throw();

    /// <summary>
    ///     Constructs a <c>scheduler_resource_allocation_error</c> object.
    /// </summary>
    /// <param name="_Hresult">
    ///     The <c>HRESULT</c> value of the error that caused the exception.
    /// </param>
    /**/
    explicit _CRTIMP scheduler_resource_allocation_error(HRESULT _Hresult) throw();

    /// <summary>
    ///     Returns the error code that caused the exception.
    /// </summary>
    /// <returns>
    ///     The <c>HRESULT</c> value of the error that caused the exception.
    /// </returns>
    /**/
    _CRTIMP HRESULT get_error_code() const throw();

private:
    HRESULT _Hresult;
};

/// <summary>
///     This class describes an exception that is thrown whenever an unsupported operating system is used.
///     The Concurrency Runtime does not support operating systems earlier than Windows XP with Service Pack 3.
/// </summary>
/**/
class unsupported_os  : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>unsupported_os</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP unsupported_os(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>unsupported_os</c> object.
    /// </summary>
    /**/
    _CRTIMP unsupported_os() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever an operation is performed which requires a scheduler
///     to be attached to the current context and one is not.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class scheduler_not_attached  : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>scheduler_not_attached</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP scheduler_not_attached(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>scheduler_not_attached</c> object.
    /// </summary>
    /**/
    _CRTIMP scheduler_not_attached() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Attach</c> method is called on a <c>Scheduler</c>
///     object which is already attached to the current context.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class improper_scheduler_attach : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>improper_scheduler_attach</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_scheduler_attach(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_scheduler_attach</c> object.
    /// </summary>
    /**/
    _CRTIMP improper_scheduler_attach() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>CurrentScheduler::Detach</c> method is called on
///     a context which has not been attached to any scheduler via the <c>Attach</c> method of a <c>Scheduler</c> object.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="CurrentScheduler::Detach Method"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class improper_scheduler_detach : public std::exception
{
public:

    /// <summary>
    ///     Constructs an <c>improper_scheduler_detach</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_scheduler_detach(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_scheduler_detach</c> object.
    /// </summary>
    /**/
    _CRTIMP improper_scheduler_detach() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Reference</c> method is called on a <c>Scheduler</c>
///     object that is shutting down, from a context that is not part of that scheduler.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Scheduler::Reference Method"/>
/**/
class improper_scheduler_reference : public std::exception
{
public:

    /// <summary>
    ///     Constructs an <c>improper_scheduler_reference</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_scheduler_reference(const char* _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_scheduler_reference</c> object.
    /// </summary>
    /**/
    _CRTIMP improper_scheduler_reference() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Scheduler::SetDefaultSchedulerPolicy</c> method is
///     called when a default scheduler already exists within the process.
/// </summary>
/// <seealso cref="Scheduler::SetDefaultSchedulerPolicy Method"/>
/**/
class default_scheduler_exists : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>default_scheduler_exists</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP default_scheduler_exists(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>default_scheduler_exists</c> object.
    /// </summary>
    /**/
    _CRTIMP default_scheduler_exists() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever calls to the <c>Block</c> and <c>Unblock</c> methods of a
///     <c>Context</c> object are not properly paired.
/// </summary>
/// <remarks>
///     Calls to the <c>Block</c> and <c>Unblock</c> methods of a <c>Context</c> object must always be properly paired.
///     The Concurrency Runtime allows the operations to happen in either order. For example, a call to <c>Block</c>
///     may followed by a call to <c>Unblock</c>, or vice-versa.  This exception would be thrown if, for instance, two calls to the
///     <c>Unblock</c> method were made in a row, on a <c>Context</c> object which was not blocked.
/// </remarks>
/// <seealso cref="Context Class"/>
/// <seealso cref="Context::Unblock Method"/>
/// <seealso cref="Context::Block Method"/>
/**/
class context_unblock_unbalanced : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>context_unblock_unbalanced</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP context_unblock_unbalanced(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>context_unblock_unbalanced</c> object.
    /// </summary>
    /**/
    _CRTIMP context_unblock_unbalanced() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Unblock</c> method of a <c>Context</c> object is called
///     from the same context.  This would indicate an attempt by a given context to unblock itself.
/// </summary>
/// <seealso cref="Context Class"/>
/// <seealso cref="Context::Unblock Method"/>
/**/
class context_self_unblock : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>context_self_unblock</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP context_self_unblock(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>context_self_unblock</c> object.
    /// </summary>
    /**/
    _CRTIMP context_self_unblock() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever there are tasks still scheduled to a <c>task_group</c> or
///     <c>structured_task_group</c> object at the time that object's destructor executes.  This exception will never be thrown
///     if the destructor is reached due to stack unwinding as the result of an exception.
/// </summary>
/// <remarks>
///     Absent exception flow, you are responsible for calling either the <c>wait</c> or <c>run_and_wait</c> method of a <c>task_group</c> or
///     <c>structured_task_group</c> object before allowing that object to destruct.  The runtime throws this exception as an
///     indication that you forgot to call the <c>wait</c> or <c>run_and_wait</c> method.
/// </remarks>
/// <seealso cref="task_group Class"/>
/// <seealso cref="task_group::wait Method"/>
/// <seealso cref="task_group::run_and_wait Method"/>
/// <seealso cref="structured_task_group Class"/>
/// <seealso cref="structured_task_group::wait Method"/>
/// <seealso cref="structured_task_group::run_and_wait Method"/>
/**/
class missing_wait : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>missing_wait</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP missing_wait(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>missing_wait</c> object.
    /// </summary>
    /**/
    _CRTIMP missing_wait() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a messaging block is given a pointer to a target which is
///     invalid for the operation being performed.
/// </summary>
/// <remarks>
///     This exception is typically thrown for reasons such as a target attempting to consume a message which is reserved
///     for a different target or releasing a reservation that it does not hold.
/// </remarks>
/// <seealso cref="Asynchronous Message Blocks"/>
/**/
class bad_target : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>bad_target</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP bad_target(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>bad_target</c> object.
    /// </summary>
    /**/
    _CRTIMP bad_target() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a messaging block is unable to find a requested message.
/// </summary>
/// <seealso cref="Asynchronous Message Blocks"/>
/**/
class message_not_found : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>message_not_found</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP message_not_found(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>message_not_found</c> object.
    /// </summary>
    /**/
    _CRTIMP message_not_found() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>link_target</c> method of a messaging block is
///     called and the messaging block is unable to link to the target.  This may be the result of exceeding the number of
///     links the messaging block is allowed or attempting to link a specific target twice to the same source.
/// </summary>
/// <seealso cref="Asynchronous Message Blocks"/>
/**/
class invalid_link_target : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_link_target</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_link_target(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_link_target</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_link_target() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever an invalid or unknown key is passed to a <c>SchedulerPolicy</c>
///     object constructor, or the <c>SetPolicyValue</c> method of a <c>SchedulerPolicy</c> object is passed a key that must
///     be changed via other means such as the <c>SetConcurrencyLimits</c> method.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
/// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
/**/
class invalid_scheduler_policy_key : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_key</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_scheduler_policy_key(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_key</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_scheduler_policy_key() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a policy key of a <c>SchedulerPolicy</c> object is
///     set to an invalid value for that key.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
/// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
/**/
class invalid_scheduler_policy_value : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_scheduler_policy_value(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_scheduler_policy_value() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever an attempt is made to set the concurrency limits of a
///     <c>SchedulerPolicy</c> object such that the value of the <c>MinConcurrency</c> key is less than the value of the
///     <c>MaxConcurrency</c> key.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
/**/
class invalid_scheduler_policy_thread_specification : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_scheduler_policy_thread_specification(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_scheduler_policy_thread_specification() throw();
};

/// <summary>
///     This class describes an exception that is thrown when an invalid operation is performed that is not more accurately
///     described by another exception type thrown by the Concurrency Runtime.
/// </summary>
/// <remarks>
///     The various methods which throw this exception will generally document under what circumstances they will throw it.
/// </remarks>
/**/
class invalid_operation : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_operation</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_operation(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_operation</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_operation() throw();
};

/// <summary>
///     This class describes an exception that is thrown when the Concurrency Runtime detects that you neglected to call the
///     <c>CurrentScheduler::Detach</c> method on a context that attached to a second scheduler via the <c>Attach</c> method
///     of the <c>Scheduler</c> object.
/// </summary>
/// <remarks>
///     This exception is only thrown when you nest one scheduler inside another by calling the <c>Attach</c> method of a
///     <c>Scheduler</c> object on a context that is already owned by or attached to another scheduler.  The Concurrency Runtime
///     throws this exception opportunistically when it can detect the scenario as an aid to locating the problem.  Not every
///     instance of neglecting to call the <c>CurrentScheduler::Detach</c> method is guaranteed to throw this exception.
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="CurrentScheduler::Detach Method"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class nested_scheduler_missing_detach : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>nested_scheduler_missing_detach</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP nested_scheduler_missing_detach(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>nested_scheduler_missing_detach</c> object.
    /// </summary>
    /**/
    _CRTIMP nested_scheduler_missing_detach() throw();
};

/// <summary>
///     This class describes an exception that is thrown when an operation has timed out.
/// </summary>
/**/
class operation_timed_out : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>operation_timed_out</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP operation_timed_out(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>operation_timed_out</c> object.
    /// </summary>
    /**/
    _CRTIMP operation_timed_out() throw();
};

/// <summary>
///     This class describes an exception that is thrown when a <c>task_handle</c> object is scheduled multiple times
///     via the <c>run</c> method of a <c>task_group</c> or <c>structured_task_group</c> object without an intervening
///     call to either the <c>wait</c> or <c>run_and_wait</c> methods.
/// </summary>
/// <seealso cref="task_handle Class"/>
/// <seealso cref="task_group Class"/>
/// <seealso cref="task_group::run Method"/>
/// <seealso cref="task_group::wait Method"/>
/// <seealso cref="task_group::run_and_wait Method"/>
/// <seealso cref="structured_task_group Class"/>
/// <seealso cref="structured_task_group::run Method"/>
/// <seealso cref="structured_task_group::wait Method"/>
/// <seealso cref="structured_task_group::run_and_wait Method"/>
/**/
class invalid_multiple_scheduling : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_multiple_scheduling</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_multiple_scheduling(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_multiple_scheduling</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_multiple_scheduling() throw();
};

/// <summary>
///     This class describes an exception that is thrown when the <c>Context::Oversubscribe</c> method is called with
///     the <paramref name="_BeginOversubscription"/> parameter set to <c>false</c> without a prior call to the
///     <c>Context::Oversubscribe</c> method with the <paramref name="_BeginOversubscription"/> parameter set to <c>true</c>.
/// </summary>
/// <seealso cref="Context::Oversubscribe Method"/>
/**/
class invalid_oversubscribe_operation : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_oversubscribe_operation</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_oversubscribe_operation(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_oversubscribe_operation</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_oversubscribe_operation() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a lock is acquired improperly.
/// </summary>
/// <remarks>
///     Typically, this exception is thrown when an attempt is made to acquire a non-reentrant lock
///     recursively on the same context.
/// </remarks>
/// <seealso cref="critical_section Class"/>
/// <seealso cref="reader_writer_lock Class"/>
/**/
class improper_lock : public std::exception
{
public:

    /// <summary>
    ///     Constructs an <c>improper_lock exception</c>.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_lock(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_lock</c> exception.
    /// </summary>
    /**/
    _CRTIMP improper_lock() throw();
};

/// <summary>
///     An elementary abstraction for a task, defined as <c>void (__cdecl * TaskProc)(void *)</c>. A <c>TaskProc</c> is called to
///     invoke the body of a task.
/// </summary>
/**/
typedef void (__cdecl * TaskProc)(void *);

/// <summary>
///     Represents an abstraction for a schedule group.  Schedule groups organize a set of related work that benefits from being
///     scheduled close together either temporally, by executing another task in the same group before moving to another group, or
///     spatially, by executing multiple items within the same group on the same NUMA node or physical socket.
/// </summary>
/// <seealso cref="CurrentScheduler Class"/>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class ScheduleGroup
{
public:

    /// <summary>
    ///     Schedules a light-weight task within the schedule group.
    /// </summary>
    /// <param name="_Proc">
    ///     A pointer to the function to execute to perform the body of the light-weight task.
    /// </param>
    /// <param name="_Data">
    ///     A void pointer to the data that will be passed as a parameter to the body of the task.
    /// </param>
    /// <remarks>
    ///     Calling the <c>ScheduleTask</c> method implicitly places a reference count on the schedule group which is removed by the runtime
    ///     at an appropriate time after the task executes.
    /// </remarks>
    /// <seealso cref="ScheduleGroup::Reference Method"/>
    /**/
    virtual void ScheduleTask(TaskProc _Proc, void * _Data) =0;

    /// <summary>
    ///     Returns an identifier for the schedule group that is unique within the scheduler to which the group belongs.
    /// </summary>
    /// <returns>
    ///     An identifier for the schedule group that is unique within the scheduler to which the group belongs.
    /// </returns>
    /**/
    virtual unsigned int Id() const =0;

    /// <summary>
    ///     Increments the schedule group's reference count.
    /// </summary>
    /// <returns>
    ///     The newly incremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the schedule group for composition.  When the reference count of a schedule
    ///     group falls to zero, the schedule group is deleted by the runtime. A schedule group created using either the 
    ///     <see cref="CurrentScheduler::CreateScheduleGroup Method">CurrentScheduler::CreateScheduleGroup</see> method, or the
    ///     <see cref="Scheduler::CreateScheduleGroup Method">Scheduler::CreateScheduleGroup</see> method starts out with a reference
    ///     count of one.
    /// </remarks>
    /// <seealso cref="ScheduleGroup::Release Method"/>
    /// <seealso cref="CurrentScheduler::CreateScheduleGroup Method"/>
    /// <seealso cref="Scheduler::CreateScheduleGroup Method"/>
    /**/
    virtual unsigned int Reference() =0;

    /// <summary>
    ///     Decrements this scheduler group's reference count.
    /// </summary>
    /// <returns>
    ///     The newly decremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the schedule group for composition.  When the reference count of a schedule
    ///     group falls to zero, the schedule group is deleted by the runtime.  Once you have called the <c>Release</c> method the specific number
    ///     of times to remove the creation reference count and any additional references placed via the <c>Reference</c> method, you may not
    ///     utilize the schedule group further.  Doing so will result in undefined behavior.
    ///     <para>A schedule group is associated with a particular scheduler instance.  You must ensure that all references to the
    ///     schedule group are released before all references to the scheduler are released, since the latter could result in the scheduler
    ///     being destroyed.  Doing otherwise results in undefined behavior.</para>
    /// </remarks>
    /// <seealso cref="ScheduleGroup::Reference Method"/>
    /// <seealso cref="CurrentScheduler::CreateScheduleGroup Method"/>
    /// <seealso cref="Scheduler::CreateScheduleGroup Method"/>
    /**/
    virtual unsigned int Release() =0;

protected:

    //
    // Privatize operator delete.  Clients should utilize Release to relinquish a schedule group.
    //
    template<class _T> friend void Concurrency::details::_InternalDeleteHelper(_T * _PObject);

    /// <summary>
    ///     A <c>ScheduleGroup</c> object is destroyed internally by the runtime when all external references to it are released.
    ///     It may not be explicitly deleted.
    /// </summary>
    /// <param name="_PObject">
    ///     A pointer to the object to be deleted.
    /// </param>
    /**/
    void operator delete(void * _PObject)
    {
        ::operator delete(_PObject);
    }
};

/// <summary>
///     Special value for the policy keys <c>MinConcurrency</c> and <c>MaxConcurrency</c>.  Defaults to the number of hardware
///     threads on the machine in the absence of other constraints.
/// </summary>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
const unsigned int MaxExecutionResources = 0xFFFFFFFF; 

/// <summary>
///     Special value for the policy key <c>ContextPriority</c> indicating that the thread priority of all contexts in the scheduler
///     should be the same as that of the thread which created the scheduler.
/// </summary>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
const unsigned int INHERIT_THREAD_PRIORITY = 0x0000F000;

/// <summary>
///     Policy keys describing aspects of scheduler behavior.  Each policy element is described by a key-value pair.  For more information
///     about scheduler policies and their impact on schedulers, see <see cref="Task Scheduler (Concurrency Runtime)"/>.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="CurrentScheduler Class"/>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
enum PolicyElementKey
{
    /// <summary>
    ///     The type of threads that the scheduler will utilize for underlying execution contexts.  For more information, see
    ///     <see cref="SchedulerType Enumeration"/>.
    ///     <para>Valid values  : A member of the <c>SchedulerType</c> enumeration, either <c>ThreadScheduler</c> or <c>UmsThreadDefault</c></para>
    ///     <para>Default value : <c>ThreadScheduler</c>.  This translates to Win32 threads on all operating systems.</para>
    /// </summary>
    /**/
    SchedulerKind,

    /// <summary>
    ///     The maximum concurrency level desired by the scheduler.  The resource manager will try to initially allocate this many virtual processors.
    ///     The special value <see cref="MaxExecutionResources Constant">MaxExecutionResources</see> indicates that the desired concurrency level
    ///     is same as the number of hardware threads on the machine.  If the value specified for <c>MinConcurrency</c> is greater than the number
    ///     of hardware threads on the machine and <c>MaxConcurrency</c> is specified as <c>MaxExecutionResources</c>, the value for <c>MaxConcurrency</c>
    ///     is raised to match what is set for <c>MinConcurrency</c>.
    ///     <para>Valid values  : Positive integers and the special value <c>MaxExecutionResources</c></para>
    ///     <para>Default value : <c>MaxExecutionResources</c></para>
    /// </summary>
    /**/
    MaxConcurrency,

    /// <summary>
    ///     The minimum concurrency level that must be provided to the scheduler by the resource manager.  The number of virtual processors assigned
    ///     to a scheduler will never go below the minimum.  The special value <see cref="MaxExecutionResources Constant">MaxExecutionResources</see>
    ///     indicates that the minimum concurrency level is same as the number of hardware threads on the machine.  If the value specified for
    ///     <c>MaxConcurrency</c> is less than the number of hardware threads on the machine and <c>MinConcurrency</c> is specified as
    ///     <c>MaxExecutionResources</c>, the value for <c>MinConcurrency</c> is lowered to match what is set for <c>MaxConcurrency</c>.
    ///     <para>Valid values  : Non-negative integers and the special value <c>MaxExecutionResources</c>.  Note that for scheduler policies
    ///     used for the construction of Concurrency Runtime schedulers or any policy with the <c>SchedulerKind</c> policy key set to the value
    ///     <c>UMSThreadDefault</c>, the value <c>0</c> is invalid.</para>
    ///     <para>Default value : <c>1</c></para>
    /// </summary>
    /**/
    MinConcurrency,

    /// <summary>
    ///     Tentative number of virtual processors per hardware thread.  The target oversubscription factor may be increased by the Resource Manager,
    ///     if necessary, to satisfy <c>MaxConcurrency</c> with the hardware threads on the machine.
    ///     <para>Valid values  : Positive integers</para>
    ///     <para>Default value : <c>1</c></para>
    /// </summary>
    /**/
    TargetOversubscriptionFactor,

    /// <summary>
    ///     When the <c>SchedulingProtocol</c> policy key is set to the value <c>EnhanceScheduleGroupLocality</c>, this specifies the maximum number 
    ///     of runnable contexts allowed to be cached in per virtual processor local queues.  Such contexts will typically run in last-in-first-out
    ///     (LIFO) order on the virtual processor that caused them to become runnable.  Note that this policy key has no meaning when the
    ///     <c>SchedulingProtocol</c> key is set to the value <c>EnhanceForwardProgress</c>.
    ///     <para>Valid values  : Non-negative integers</para>
    ///     <para>Default value : <c>8</c></para>
    /// </summary>
    /**/
    LocalContextCacheSize,

    /// <summary>
    ///     The reserved stack size of each context in the scheduler in kilobytes.
    ///     <para>Valid values  : Positive integers</para>
    ///     <para>Default value : <c>0</c>, indicating that the process' default value for stack size be used.</para>
    /// </summary>
    /**/
    ContextStackSize,

    /// <summary>
    ///     The operating system thread priority of each context in the scheduler.  If this key is set to the value <see cref="INHERIT_THREAD_PRIORITY Constant">
    ///     INHERIT_THREAD_PRIORITY</see> the contexts in the scheduler will inherit the priority of the thread that created the scheduler.
    ///     <para>Valid values  : Any of the valid values for the Windows <c>SetThreadPriority</c> function and the special value
    ///     <c>INHERIT_THREAD_PRIORITY</c></para>
    ///     <para>Default value : <c>THREAD_PRIORITY_NORMAL</c></para>
    /// </summary>
    /**/
    ContextPriority,

    /// <summary>
    ///     Describes which scheduling algorithm will be used by the scheduler.  For more information, see <see cref="SchedulingProtocolType Enumeration"/>.
    ///     <para>Valid values  : A member of the <c>SchedulingProtocolType</c> enumeration, either <c>EnhanceScheduleGroupLocality</c> 
    ///     or <c>EnhanceForwardProgress</c></para>
    ///     <para>Default value : <c>EnhanceScheduleGroupLocality</c></para>
    /// </summary>
    /**/
    SchedulingProtocol,

    /// <summary>
    ///     Determines whether the resources for the scheduler will be rebalanced according to statistical information gathered from the
    ///     scheduler or only based on the subscription level of underlying hardware threads. For more information, see 
    ///     <see cref="DynamicProgressFeedbackType Enumeration"/>.
    ///     <para>Valid values  : A member of the <c>DynamicProgressFeedbackType</c> enumeration, either <c>ProgressFeedbackEnabled</c> or
    ///     <c>ProgressFeedbackDisabled</c></para>
    ///     <para>Default value : <c>ProgressFeedbackEnabled</c></para>
    /// </summary>
    /**/
    DynamicProgressFeedback,

    /// <summary>
    ///     The maximum policy element key.  Not a valid element key.
    /// </summary>
    /**/
    MaxPolicyElementKey
};

/// <summary>
///     Used by the <c>SchedulerKind</c> policy to describe the type of threads that the scheduler should utilize for underlying execution contexts.
///     For more information on available scheduler policies, see <see cref="PolicyElementKey Enumeration"/>.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
enum SchedulerType
{
    /// <summary>
    ///     Indicates an explicit request of regular Win32 threads.
    /// </summary>
    /**/
    ThreadScheduler,

    /// <summary>
    ///     Indicates a request for UMS threads if available on the underlying platform; otherwise, regular Win32 threads.  Note that if
    ///     you call the <c>GetPolicyValue</c> method of a <c>SchedulerPolicy</c> object and this value is returned, it is an indication
    ///     that the underlying platform supports UMS threads and that the policy will create a scheduler utilizing UMS threads.
    /// </summary>
    /**/
    UmsThreadDefault
};

/// <summary>
///     Used by the <c>SchedulingProtocol</c> policy to describe which scheduling algorithm will be utilized for the scheduler.  For more
///     information on available scheduler policies, see <see cref="PolicyElementKey Enumeration"/>.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
enum SchedulingProtocolType
{
    /// <summary>
    ///     The scheduler prefers to continue to work on tasks within the current schedule group before moving to another schedule group.
    ///     Unblocked contexts are cached per virtual-processor and are typically scheduled in a last-in-first-out (LIFO) fashion by the 
    ///     virtual processor which unblocked them.
    /// </summary>
    /**/
    EnhanceScheduleGroupLocality,

    /// <summary>
    ///     The scheduler prefers to round-robin through schedule groups after executing each task.  Unblocked contexts are typically
    ///     scheduled in a first-in-first-out (FIFO) fashion.  Virtual processors do not cache unblocked contexts.
    /// </summary>
    /**/
    EnhanceForwardProgress 
};

/// <summary>
///     Used by the <c>DynamicProgressFeedback</c> policy to describe whether resources for the scheduler will be rebalanced according to
///     statistical information gathered from the scheduler or only based on virtual processors going in and out of the idle state through
///     calls to the <c>Activate</c> and <c>Deactivate</c> methods on the <c>IVirtualProcessorRoot</c> interface.  For more information
///     on available scheduler policies, see <see cref="PolicyElementKey Enumeration"/>.
/// </summary>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
enum DynamicProgressFeedbackType
{
    /// <summary>
    ///     The scheduler does not gather progress information.  Rebalancing is done based solely on the subscription level of the underlying
    ///     hardware thread.  For more information on subscription levels, see 
    ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method">IExecutionResource::CurrentSubscriptionLevel</see>.
    /// </summary>
    /**/
    ProgressFeedbackDisabled,

    /// <summary>
    ///     The scheduler gathers progress information and passes it to the resource manager.  The resource manager will utilize this statistical
    ///     information to rebalance resources on behalf of the scheduler in addition to the subscription level of the underlying
    ///     hardware thread.  For more information on subscription levels, see
    ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method">IExecutionResource::CurrentSubscriptionLevel</see>.
    /// </summary>
    /**/
    ProgressFeedbackEnabled
};

/// <summary>
///     The <c>SchedulerPolicy</c> class contains a set of key/value pairs, one for each policy element, that control the behavior of a
///     scheduler instance.
/// </summary>
/// <remarks>
///     For more information about the policies which can be controlled via the <c>SchedulerPolicy</c> class, see
///     <see cref="PolicyElementKey Enumeration"/>.
/// </remarks>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="CurrentScheduler Class"/>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class SchedulerPolicy
{
public:

    /// <summary>
    ///     Constructs a new scheduler policy and populates it with values for <see cref="PolicyElementKey Enumeration">policy keys</see>
    ///     supported by Concurrency Runtime schedulers and the Resource Manager.
    /// </summary>
    /// <remarks>
    ///     <para>The first constructor creates a new scheduler policy where all policies will be initialized to their default values.</para>
    ///     <para>The second constructor creates a new scheduler policy that uses a named-parameter style of initialization. Values after
    ///     the <paramref name="_PolicyKeyCount"/> parameter are supplied as key/value pairs.  Any policy key which is not specified in this
    ///     constructor will have its default value. This constructor could throw the exceptions <see cref="invalid_scheduler_policy_key Class">
    ///     invalid_scheduler_policy_key</see>, <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> or
    ///     <see cref="invalid_scheduler_policy_thread_specification Class"> invalid_scheduler_policy_thread_specification</see>.</para>
    ///     <para>The third constructor is a copy constructor. Often, the most convenient way to define a new scheduler policy is to copy an 
    ///     existing policy and modify it via the <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy();

    /// <summary>
    ///     Constructs a new scheduler policy and populates it with values for <see cref="PolicyElementKey Enumeration">policy keys</see>
    ///     supported by Concurrency Runtime schedulers and the Resource Manager.
    /// </summary>
    /// <param name="_PolicyKeyCount">
    ///     The number of key/value pairs that follow the <paramref name="_PolicyKeyCount"/> parameter.
    /// </param>
    /// <remarks>
    ///     <para>The first constructor creates a new scheduler policy where all policies will be initialized to their default values.</para>
    ///     <para>The second constructor creates a new scheduler policy that uses a named-parameter style of initialization. Values after </para>
    ///     the <paramref name="_PolicyKeyCount"/> parameter are supplied as key/value pairs.  Any policy key which is not specified in this
    ///     constructor will have its default value. This constructor could throw the exceptions <see cref="invalid_scheduler_policy_key Class">
    ///     invalid_scheduler_policy_key</see>, <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> or
    ///     <see cref="invalid_scheduler_policy_thread_specification Class"> invalid_scheduler_policy_thread_specification</see>.
    ///     <para>The third constructor is a copy constructor. Often, the most convenient way to define a new scheduler policy is to copy an 
    ///     existing policy and modify it via the <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy(size_t _PolicyKeyCount, ...);

    /// <summary>
    ///     Constructs a new scheduler policy and populates it with values for <see cref="PolicyElementKey Enumeration">policy keys</see>
    ///     supported by Concurrency Runtime schedulers and the Resource Manager.
    /// </summary>
    /// <param name="_SrcPolicy">
    ///     The source policy to copy.
    /// </param>
    /// <remarks>
    ///     <para>The first constructor creates a new scheduler policy where all policies will be initialized to their default values.</para>
    ///     <para>The second constructor creates a new scheduler policy that uses a named-parameter style of initialization. Values after </para>
    ///     the <paramref name="_PolicyKeyCount"/> parameter are supplied as key/value pairs.  Any policy key which is not specified in this
    ///     constructor will have its default value. This constructor could throw the exceptions <see cref="invalid_scheduler_policy_key Class">
    ///     invalid_scheduler_policy_key</see>, <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> or
    ///     <see cref="invalid_scheduler_policy_thread_specification Class"> invalid_scheduler_policy_thread_specification</see>.
    ///     <para>The third constructor is a copy constructor. Often, the most convenient way to define a new scheduler policy is to copy an 
    ///     existing policy and modify it via the <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy(const SchedulerPolicy& _SrcPolicy);

    /// <summary>
    ///     Assigns the scheduler policy from another scheduler policy.
    /// </summary>
    /// <param name="_RhsPolicy">
    ///     The policy to assign to this policy.
    /// </param>
    /// <returns>
    ///     A reference to the scheduler policy.
    /// </returns>
    /// <remarks>
    ///     Often, the most convenient way to define a new scheduler policy is to copy an existing policy and modify it via the
    ///     <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy& operator=(const SchedulerPolicy& _RhsPolicy);

    /// <summary>
    ///     Destroys a scheduler policy.
    /// </summary>
    /**/
    _CRTIMP ~SchedulerPolicy();
    
    /// <summary>
    ///     Retrieves the value of the policy key supplied as the <paramref name="_Key"/> parameter.
    /// </summary>
    /// <param name="_Key">
    ///     The policy key to retrieve a value for.
    /// </param>
    /// <returns>
    ///     If the key specified by the <paramref name="_Key"/> parameter is supported, the policy value for the key cast to an <c>unsigned int</c>.
    /// </returns>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_key Class">invalid_scheduler_policy_key</see> for an invalid policy key.
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP unsigned int GetPolicyValue(PolicyElementKey _Key) const;

    /// <summary>
    ///     Sets the value of the policy key supplied as the <paramref name="_Key"/> parameter and returns the old value.
    /// </summary>
    /// <param name="_Key">
    ///     The policy key to set a value for.
    /// </param>
    /// <param name="_Value">
    ///     The value to set the policy key to.
    /// </param>
    /// <returns>
    ///     If the key specified by the <paramref name="_Key"/> parameter is supported, the old policy value for the key cast to an <c>unsigned int</c>.
    /// </returns>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_key Class">invalid_scheduler_policy_key </see> for an invalid policy key
    ///     or any policy key whose value cannot be set by the <c>SetPolicyValue</c> method.
    ///     <para>The method will throw <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value</see> for a value that
    ///     is not supported for the key specified by the <paramref name="_Key"/> parameter.</para>
    ///     <para>Note that this method is not allowed to set the <c>MinConcurrency</c> or <c>MaxConcurrency</c> policies.  To set these values, use
    ///     the <see cref="SchedulerPolicy::SetConcurrencyLimits Method">SetConcurrencyLimits</see> method.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP unsigned int SetPolicyValue(PolicyElementKey _Key, unsigned int _Value);

    /// <summary>
    ///     Simultaneously sets the <c>MinConcurrency</c> and <c>MaxConcurrency</c> policies on the <c>SchedulerPolicy</c> object.
    /// </summary>
    /// <param name="_MinConcurrency">
    ///     The value for the <c>MinConcurrency</c> policy key.
    /// </param>
    /// <param name="_MaxConcurrency">
    ///     The value for the <c>MaxConcurrency</c> policy key.
    /// </param>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_thread_specification Class">invalid_scheduler_policy_thread_specification
    ///     </see> if the value specified for the <c>MinConcurrency</c> policy is greater than that specified for the <c>MaxConcurrency</c> policy.
    ///     <para>The method may also throw <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> for other
    ///     invalid values.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP void SetConcurrencyLimits(unsigned int _MinConcurrency, unsigned int _MaxConcurrency = MaxExecutionResources);

    /// <summary>
    ///     Checks if this policy is a valid policy for a Concurrency Runtime scheduler.  If it is not, an appropriate exception will be thrown.
    /// </summary>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> if a policy value supplied
    ///     in the <c>SchedulerPolicy</c> object cannot be used to create a Concurrency Runtime scheduler.  Note that such a policy is not necessarily
    ///     invalid.  The Concurrency Runtime's Resource Manager also utilizes the <c>SchedulerPolicy</c> class to describe requirements.
    /// </remarks>
    /**/
    void _ValidateConcRTPolicy() const;

private:

    struct _PolicyBag
    {
        union
        {
            unsigned int _M_pPolicyBag[MaxPolicyElementKey];
            struct
            {
                SchedulerType _M_schedulerKind;
                unsigned int _M_maxConcurrency;
                unsigned int _M_minConcurrency;
                unsigned int _M_targetOversubscriptionFactor;
                unsigned int _M_localContextCacheSize;
                unsigned int _M_contextStackSize;
                unsigned int _M_contextPriority;
                SchedulingProtocolType _M_schedulingProtocol;
                DynamicProgressFeedbackType _M_dynamicProgressFeedback;
            } _M_specificValues;
        } _M_values;
    } *_M_pPolicyBag;

    /// <summary>
    ///     Initializes the scheduler policy. 
    /// </summary>
    /**/
    void _Initialize(size_t _PolicyKeyCount, va_list * _PArgs);

    /// <summary>
    ///     Make this policy a copy of the source policy. 
    /// </summary>
    /**/
    void _Assign(const SchedulerPolicy& _SrcPolicy);

    /// <summary>
    ///     Returns true if the key supplied is a supported key. 
    /// </summary>
    /**/
    static bool __cdecl _ValidPolicyKey(PolicyElementKey _Key);

    /// <summary>
    ///     Returns true if a policy value is in a valid range. 
    /// </summary>
    /**/
    static bool __cdecl _ValidPolicyValue(PolicyElementKey _Key, unsigned int _Value);

    /// <summary>
    ///     Returns true if concurrency limit combinations are valid. 
    /// </summary>
    /**/
    static bool __cdecl _AreConcurrencyLimitsValid(unsigned int _MinConcurrency, unsigned int _MaxConcurrency);
    bool _AreConcurrencyLimitsValid() const;

    /// <summary>
    ///     Test a policy's concurrency combinations. 
    /// </summary>
    /**/
    bool _ArePolicyCombinationsValid() const;

    /// <summary>
    ///     Resolves some of the policy keys that are set to defaults, based on the characteristics of the underlying system. 
    /// </summary>
    /**/
    void _ResolvePolicyValues();

    /// <summary>
    ///     Stringify policy keys. 
    /// </summary>
    /**/
    static char * __cdecl _StringFromPolicyKey(unsigned int _Index);
};

/// <summary>
///     Represents an abstraction for the current scheduler associated with the calling context.
/// </summary>
/// <remarks>
///     If there is no scheduler (see <see cref="Scheduler Class">Scheduler</see>) associated with the calling context, many
///     methods within the <c>CurrentScheduler</c> class will result in attachment of the process' default scheduler.  This may
///     also imply that the process' default scheduler is created during such a call.
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class CurrentScheduler
{
private:
    CurrentScheduler() {}

public:
    /// <summary>
    ///     Returns a unique identifier for the current scheduler.
    /// </summary>
    /// <returns>
    ///     If a scheduler is associated with the calling context, a unique identifier for that scheduler; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     This method will not result in scheduler attachment if the calling context is not already associated with a scheduler.
    /// </remarks>
    /**/
    _CRTIMP static unsigned int __cdecl Id();

    /// <summary>
    ///     Returns a copy of the policy that the current scheduler was created with.
    /// </summary>
    /// <returns>
    ///     A copy of the policy that that the current scheduler was created with.
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /// <seealso cref="SchedulerPolicy Class"/>
    /**/
    _CRTIMP static SchedulerPolicy __cdecl GetPolicy();

    /// <summary>
    ///     Returns a pointer to the scheduler associated with the calling context, also referred to as the current scheduler.
    /// </summary>
    /// <returns>
    ///     A pointer to the scheduler associated with the calling context (the current scheduler).
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context. No additional reference is placed on the <c>Scheduler</c> object
    ///     returned by this method.
    /// </remarks>
    /**/
    _CRTIMP static Scheduler * __cdecl Get();
    
    /// <summary>
    ///     Returns the current number of virtual processors for the scheduler associated with the calling context. 
    /// </summary> 
    /// <returns>
    ///     If a scheduler is associated with the calling context, the current number of virtual processors for that scheduler; otherwise,
    ///     the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     This method will not result in scheduler attachment if the calling context is not already associated with a scheduler.
    ///     <para>The return value from this method is an instantaneous sampling of the number of virtual processors for the scheduler associated
    ///     with the calling context.  This value may be stale the moment it is returned.</para>
    /// </remarks>
    /**/
    _CRTIMP static unsigned int __cdecl GetNumberOfVirtualProcessors();

    /// <summary>
    ///     Creates a new scheduler whose behavior is described by the <paramref name="_Policy"/> parameter and attaches it to the calling context.
    ///     The newly created scheduler will become the current scheduler for the calling context.
    /// </summary>
    /// <param name="_Policy">
    ///     The scheduler policy that describes the behavior of the newly created scheduler.
    /// </param>
    /// <remarks>
    ///     The attachment of the scheduler to the calling context implicitly places a reference count on the scheduler.
    ///     <para>After a scheduler is created with the <c>Create</c> method, you must call the <see cref="CurrentScheduler::Detach Method">
    ///     CurrentScheduler::Detach</see> method at some point in the future in order to allow the scheduler to shut down.</para>
    ///     <para>If this method is called from a context that is already attached to a different scheduler, the existing scheduler is remembered
    ///     as the previous scheduler, and the newly created scheduler becomes the current scheduler. When you call the <c>CurrentScheduler::Detach</c>
    ///     method at a later point, the previous scheduler is restored as the current scheduler.</para>
    ///     <para>This method may throw a variety of exceptions, including <see cref="scheduler_resource_allocation_error Class">
    ///     scheduler_resource_allocation_error</see> and <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value</see>.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="CurrentScheduler::Detach Method"/>
    /// <seealso cref="Scheduler::Reference Method"/>
    /// <seealso cref="Scheduler::Release Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl Create(const SchedulerPolicy& _Policy);

    /// <summary>
    ///     Detaches the current scheduler from the calling context and restores the previously attached scheduler as the current
    ///     scheduler, if one exists.  After this method returns, the calling context is then managed by the scheduler that was previously
    ///     attached to the context via either the <c>CurrentScheduler::Create</c> or <c>Scheduler::Attach</c> method.
    /// </summary>
    /// <remarks>
    ///     The <c>Detach</c> method implicitly removes a reference count from the scheduler.
    ///     <para>If there is no scheduler attached to the calling context, calling this method will result in an <see cref="improper_scheduler_detach Class">
    ///     improper_scheduler_detach</see> exception being thrown.</para>
    /// </remarks>
    /// <seealso cref="Scheduler::Attach Method"/>
    /// <seealso cref="CurrentScheduler::Create Method"/>
    /**/
    _CRTIMP static void __cdecl Detach();

    /// <summary>
    ///     Causes the Windows event handle passed in the <paramref name="_ShutdownEvent"/> parameter to be signaled when the scheduler associated with
    ///     the current context shuts down and destroys itself.  At the time the event is signaled, all work that had been scheduled to the
    ///     scheduler is complete.  Multiple shutdown events may be registered through this method.
    /// </summary>
    /// <param name="_ShutdownEvent">
    ///     A handle to a Windows event object which will be signaled by the runtime when the scheduler associated with the current context
    ///     shuts down and destroys itself.
    /// </param>
    /// <remarks>
    ///     If there is no scheduler attached to the calling context, calling this method will result in a <see cref="scheduler_not_attached Class">
    ///     scheduler_not_attached </see> exception being thrown.
    /// </remarks>
    /**/
    _CRTIMP static void __cdecl RegisterShutdownEvent(HANDLE _ShutdownEvent);

    /// <summary>
    ///     Creates a new schedule group within the scheduler associated with the calling context.
    /// </summary>
    /// <returns>
    ///     A pointer to the newly created schedule group.  This <c>ScheduleGroup</c> object has an initial reference count placed on it.
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    ///     <para>You must invoke the <see cref="ScheduleGroup::Release Method">Release</see> method on a schedule group when you are
    ///     done scheduling work to it. The scheduler will destroy the schedule group when all work queued to it has completed.</para>
    ///     <para>Note that if you explicitly created this scheduler, you must release all references to schedule groups within it, before
    ///     you release your reference on the scheduler, via detaching the current context from it.</para>
    /// </remarks>
    /// <seealso cref="ScheduleGroup Class"/>
    /// <seealso cref="ScheduleGroup::Release Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static ScheduleGroup * __cdecl CreateScheduleGroup();

    /// <summary>
    ///     Schedules a light-weight task within the scheduler associated with the calling context.  The light-weight task will be placed
    ///     in a schedule group of the runtime's choosing.
    /// </summary>
    /// <param name="_Proc">
    ///     A pointer to the function to execute to perform the body of the light-weight task.
    /// </param>
    /// <param name="_Data">
    ///     A void pointer to the data that will be passed as a parameter to the body of the task.
    /// </param>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP static void __cdecl ScheduleTask(TaskProc _Proc, void * _Data);
};

/// <summary>
///     Represents an abstraction for a Concurrency Runtime scheduler.
/// </summary>
/// <remarks>
///     The Concurrency Runtime scheduler uses execution contexts, which map to the operating system's execution contexts, such as a thread or a UMS thread,
///     to execute the work queued to it by your application.  At any time, the concurrency level of a scheduler is equal to the number of virtual processor
///     granted to it by the Resource Manager.  A virtual processor is an abstraction for a processing resource and maps to a hardware thread on the
///     underlying system. Only a single scheduler context may execute on a virtual processor at a given time.
///     <para> The Concurrency Runtime will create a default scheduler per process to execute parallel work.  In addition you may create your own scheduler
///     instances and manipulate it using this class.</para>
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class Scheduler
{
protected:
    /// <summary>
    ///     An object of the <c>Scheduler</c> class can only created using factory methods, or implicitly.
    /// </summary>
    /// <remarks>
    ///     The process' default scheduler is created implicitly when you utilize many of the runtime functions which require a scheduler
    ///     to be attached to the calling context.  Methods within the <c>CurrentScheduler</c> class and features of the PPL and agents layers
    ///     typically perform implicit attachment.
    ///     <para>You can also create a scheduler explicitly through either the <c>CurrentScheduler::Create</c> method or the <c>Scheduler::Create</c>
    ///     method.</para>
    /// </remarks>
    /// <seealso cref="CurrentScheduler Class"/>
    /// <seealso cref="CurrentScheduler::Create Method"/>
    /// <seealso cref="Scheduler::Create Method"/>
    /**/
    Scheduler() {}

    /// <summary>
    ///     An object of the <c>Scheduler</c> class is implicitly destroyed when all external references to it cease to exist.
    /// </summary>
    /**/
    virtual ~Scheduler() {}

public:

    /// <summary>
    ///     Creates a new scheduler whose behavior is described by the <paramref name="_Policy"/> parameter, places an initial reference on
    ///     the scheduler, and returns a pointer to it.
    /// </summary>
    /// <param name="_Policy">
    ///     The scheduler policy that describes behavior of the newly created scheduler.
    /// </param>
    /// <returns>
    ///     A pointer to a newly created scheduler.  This <c>Scheduler</c> object has an initial reference count placed on it.
    /// </returns>
    /// <remarks>
    ///     After a scheduler is created with the <c>Create</c> method, you must call the <see cref="Release Method">Release</see> method at some point
    ///     in the future in order to remove the initial reference count and allow the scheduler to shut down.
    ///     <para>A scheduler created with this method is not attached to the calling context. It may be attached to a context via the
    ///     <see cref="Scheduler::Attach Method">Attach</see> method.</para>
    ///     <para>This method may throw a variety of exceptions, including <see cref="scheduler_resource_allocation_error Class">
    ///     scheduler_resource_allocation_error</see> and <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value</see>.</para>
    /// </remarks>
    /// <seealso cref="Scheduler::Release Method"/>
    /// <seealso cref="Scheduler::Attach Method"/>
    /// <seealso cref="CurrentScheduler::Create Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static Scheduler * __cdecl Create(const SchedulerPolicy& _Policy);

    /// <summary>
    ///     Returns a unique identifier for the scheduler.
    /// </summary> 
    /// <returns>
    ///     A unique identifier for the scheduler.
    /// </returns>
    /**/
    virtual unsigned int Id() const =0;

    /// <summary>
    ///     Returns the current number of virtual processors for the scheduler.
    /// </summary> 
    /// <returns>
    ///     The current number of virtual processors for the scheduler.
    ///     <para>The return value from this method is an instantaneous sampling of the number of virtual processors for the scheduler.
    ///     This value may be stale the moment it is returned.</para>
    /// </returns>
    /**/
    virtual unsigned int GetNumberOfVirtualProcessors() const =0;

    /// <summary>
    ///     Returns a copy of the policy that the scheduler was created with.
    /// </summary>
    /// <returns>
    ///     A copy of the policy that the scheduler was created with.
    /// </returns>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    virtual SchedulerPolicy GetPolicy() const =0;

    /// <summary>
    ///     Increments the scheduler's reference count.
    /// </summary>
    /// <returns>
    ///     The newly incremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the scheduler for composition.  When the reference count of a scheduler
    ///     falls to zero, the scheduler will shut down and destruct itself once all work on the scheduler has completed.
    ///     <para>The method will throw an <see cref="improper_scheduler_reference Class">improper_scheduler_reference</see> exception if the reference
    ///     count prior to calling the <c>Reference</c> method was zero and the call is made from a context that is not owned by the scheduler.</para>
    /// </remarks>
    /// <seealso cref="Scheduler::Release Method"/>
    /// <seealso cref="Scheduler::Create Method"/>
    /**/
    virtual unsigned int Reference() =0 ;

    /// <summary>
    ///     Decrements this scheduler's reference count.
    /// </summary>
    /// <returns>
    ///     The newly decremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the scheduler for composition.  When the reference count of a scheduler
    ///     falls to zero, the scheduler will shut down and destruct itself once all work on the scheduler has completed.
    /// </remarks>
    /// <seealso cref="Scheduler::Reference Method"/>
    /// <seealso cref="Scheduler::Create Method"/>
    /**/
    virtual unsigned int Release() =0;

    /// <summary>
    ///     Causes the Windows event handle passed in the <paramref name="_Event"/> parameter to be signaled when the scheduler
    ///     shuts down and destroys itself.  At the time the event is signaled, all work that had been scheduled to the
    ///     scheduler is complete.  Multiple shutdown events may be registered through this method.
    /// </summary>
    /// <param name="_Event">
    ///     A handle to a Windows event object which will be signaled by the runtime when the scheduler shuts down and destroys itself.
    /// </param>
    /**/
    virtual void RegisterShutdownEvent(HANDLE _Event) =0;

    /// <summary>
    ///     Attaches the scheduler to the calling context.  After this method returns, the calling context is managed by the scheduler and
    ///     the scheduler becomes the current scheduler.
    /// </summary>
    /// <remarks> 
    ///     Attaching a scheduler implicitly places a reference on the scheduler.
    ///     <para>At some point in the future, you must call the <see cref="CurrentScheduler::Detach Method">CurrentScheduler::Detach</see>
    ///     method in order to allow the scheduler to shut down.</para>
    ///     <para>If this method is called from a context that is already attached to a different scheduler, the existing scheduler is remembered
    ///     as the previous scheduler, and the newly created scheduler becomes the current scheduler. When you call the <c>CurrentScheduler::Detach</c>
    ///     method at a later point, the previous scheduler is restored as the current scheduler.</para>
    ///     <para>This method will throw an <see cref="improper_scheduler_attach Class">improper_scheduler_attach</see> exception if this scheduler
    ///     is the current scheduler of the calling context.</para>
    /// </remarks>
    /// <seealso cref="CurrentScheduler::Detach Method"/>
    /**/
    virtual void Attach() =0;

    /// <summary>
    ///     Allows a user defined policy to be used to create the default scheduler.  This method may only be called when no default
    ///     scheduler exists within the process.  Once a default policy has been set, it remains in effect until the next valid call
    ///     to either the <c>SetDefaultSchedulerPolicy</c> or the <see cref="Scheduler::ResetDefaultSchedulerPolicy Method">ResetDefaultSchedulerPolicy
    ///     </see> method.
    /// </summary>
    /// <param name="_Policy">
    ///     The policy to be set as the default scheduler policy.
    /// </param>
    /// <remarks>
    ///     If the <c>SetDefaultSchedulerPolicy</c> method is called when a default scheduler already exists within the process, the runtime
    ///     will throw a <see cref="default_scheduler_exists Class">default_scheduler_exists</see> exception.
    /// </remarks>
    /// <seealso cref="Scheduler::ResetDefaultSchedulerPolicy Method"/>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl SetDefaultSchedulerPolicy(const SchedulerPolicy& _Policy);

    /// <summary>
    ///     Resets the default scheduler policy to the runtime's default.  The next time a default scheduler is created, it will use the
    ///     runtime's default policy settings.
    /// </summary>
    /// <remarks>
    ///     This method may be called while a default scheduler exists within the process. It will not affect the policy of the existing
    ///     default scheduler. However, if the default scheduler were to shutdown, and a new default were to be created at a later
    ///     point, the new scheduler would use the runtime's default policy settings.
    /// </remarks>
    /// <seealso cref="Scheduler::SetDefaultSchedulerPolicy Method"/>
    /// <seealso cref="SchedulerPolicy Class"/>
    /**/
    _CRTIMP static void __cdecl ResetDefaultSchedulerPolicy();

    /// <summary>
    ///     Creates a new schedule group within the scheduler.
    /// </summary>
    /// <returns>
    ///     A pointer to the newly created schedule group.  This <c>ScheduleGroup</c> object has an initial reference count placed on it.
    /// </returns>
    /// <remarks>
    ///     You must invoke the <see cref="ScheduleGroup::Release Method">Release</see> method on a schedule group when you are
    ///     done scheduling work to it. The scheduler will destroy the schedule group when all work queued to it has completed.
    ///     <para>Note that if you explicitly created this scheduler, you must release all references to schedule groups within it, before
    ///     you release your references on the scheduler.</para>
    /// </remarks>
    /// <seealso cref="ScheduleGroup Class"/>
    /// <seealso cref="ScheduleGroup::Release Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    virtual ScheduleGroup * CreateScheduleGroup() =0;

    /// <summary>
    ///     Schedules a light-weight task within the scheduler.  The light-weight task will be placed in a schedule group of the runtime's choosing.
    /// </summary>
    /// <param name="proc">
    ///     A pointer to the function to execute to perform the body of the light-weight task.
    /// </param>
    /// <param name="_Data">
    ///     A void pointer to the data that will be passed as a parameter to the body of the task.
    /// </param>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    virtual void ScheduleTask(TaskProc proc, void * _Data) =0;
};

/// <summary>
///     Represents an abstraction for an execution context.
/// </summary>
/// <remarks>
///     The Concurrency Runtime scheduler (see <see cref="Scheduler Class">Scheduler</see>) uses execution contexts to execute the work queued
///     to it by your application.  A Win32 thread and a user mode schedulable (UMS) thread are examples of execution contexts on a Windows
///     operating system. UMS threads are supported only on 64-bit operating systems with version Windows 7 and higher.
///     <para>At any time, the concurrency level of a scheduler is equal to the number of virtual processors granted to it by the Resource Manager.
///     A virtual processor is an abstraction for a processing resource and maps to a hardware thread on the underlying system. Only a single scheduler
///     context may execute on a virtual processor at a given time.</para>
///     <para> The scheduler is cooperative in nature and an executing context may yield its virtual processor to a different context at any time if
///     it wishes to enter a wait state. When its wait it satisfied, it cannot resume until an available virtual processor from the scheduler begins
///     executing it.</para>
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class Context
{
public:

    /// <summary>
    ///     Returns an identifier for the context that is unique within the scheduler to which the context belongs.
    /// </summary>
    /// <returns>
    ///     An identifier for the context that is unique within the scheduler to which the context belongs.
    /// </returns>
    /**/
    virtual unsigned int GetId() const =0;

    /// <summary>
    ///     Returns an identifier for the virtual processor that the context is currently executing on.
    /// </summary>
    /// <returns>
    ///     If the context is currently executing on a virtual processor, an identifier for the virtual processor that the context
    ///     is currently executing on; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     The return value from this method is an instantaneous sampling of the virtual processor that the context is executing
    ///     on.  This value may be stale the moment it is returned and cannot be relied upon.  Typically, this method is used
    ///     for debugging or tracing purposes only.
    /// </remarks>
    /**/
    virtual unsigned int GetVirtualProcessorId() const =0;

    /// <summary>
    ///     Returns an identifier for the schedule group that the context is currently working on.
    /// </summary>
    /// <returns>
    ///     An identifier for the schedule group the context is currently working on.
    /// </returns>
    /// <remarks>
    ///     The return value from this method is an instantaneous sampling of the schedule group that the context is executing
    ///     on.  If this method is called on a context other than the current context, the value may be stale the moment it is
    ///     returned and cannot be relied upon.  Typically, this method is used for debugging or tracing purposes only.
    /// </remarks>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    virtual unsigned int GetScheduleGroupId() const =0;

    /// <summary>
    ///     Returns an identifier for the current context that is unique within the scheduler to which the current context belongs.
    /// </summary>
    /// <returns>
    ///     If the current context is attached to a scheduler, an identifier for the current context that is unique within the scheduler
    ///     to which the current context belongs; otherwise, the value <c>-1</c>.
    /// </returns>
    /**/
    _CRTIMP static unsigned int __cdecl Id();

    /// <summary>
    ///     Returns an identifier for the virtual processor that the current context is executing on.
    /// </summary>
    /// <returns>
    ///     If the current context is attached to a scheduler, an identifier for the virtual processor that the current context is
    ///     executing on; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     The return value from this method is an instantaneous sampling of the virtual processor that the current context is executing
    ///     on.  This value may be stale the moment it is returned and cannot be relied upon.  Typically, this method is used
    ///     for debugging or tracing purposes only.
    /// </remarks>
    /**/
    _CRTIMP static unsigned int __cdecl VirtualProcessorId();

    /// <summary>
    ///     Returns an identifier for the schedule group that the current context is working on.
    /// </summary>
    /// <returns>
    ///     If the current context is attached to a scheduler and working on a schedule group, an identifier for the scheduler group that the
    ///     current context is working on; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP static unsigned int __cdecl ScheduleGroupId();

    /// <summary>
    ///     Blocks the current context.
    /// </summary>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    ///     <para>If the calling context is running on a virtual processor, the virtual processor will find another runnable context to
    ///     execute or may potentially create a new one.</para>
    ///     <para>Once the <c>Block</c> method has been called or will be called, you must pair it with a call to the <see cref="Context::Unblock Method">
    ///     Unblock</see> method from another execution context in order for it to run again.  Be aware that there is a critical period between
    ///     the point where your code publishes its context for another thread to be able to call the <c>Unblock</c> method and the point
    ///     where the actual method call to <c>Block</c> is made.  During this period, it is imperative that you not call any method which
    ///     may in turn block and unblock for its own reasons (e.g.: acquiring a lock).  Calls to the <c>Block</c> and <c>Unblock</c> method
    ///     do not track the reason for the blocking and unblocking.  Only one object should have ownership of a <c>Block</c>-<c>Unblock</c>
    ///     pair.</para>
    ///     <para>This method may throw a variety of exceptions, including <see cref="scheduler_resource_allocation_error Class">
    ///     scheduler_resource_allocation_error</see>.</para>
    /// </remarks>
    /// <seealso cref="Context::Unblock Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl Block();

    /// <summary>
    ///     Unblocks the context and causes it to become runnable.
    /// </summary>
    /// <remarks>
    ///     It is perfectly legal for a call to the <c>Unblock</c> method to come before a corresponding call to the <see cref="Context::Block Method">
    ///     Block</see> method. As long as calls to the <c>Block</c> and <c>Unblock</c> methods are properly paired, the runtime properly handles the natural race of
    ///     either ordering.  An <c>Unblock</c> call coming before a <c>Block</c> call simply negates the effect of the <c>Block</c> call.
    ///     <para>There are several exceptions which can be thrown from this method.  If a context attempts to call the <c>Unblock</c> method on
    ///     itself, a <see cref="context_self_unblock Class">context_self_unblock</see> exception will be thrown.  If calls to <c>Block</c> and
    ///     <c>Unblock</c> are not properly paired (e.g.: two calls to <c>Unblock</c> are made for a context which is currently running), a
    ///     <see cref="context_unblock_unbalanced Class">context_unblock_unbalanced</see> exception will be thrown.</para>
    ///
    ///     <para>Be aware that there is a critical period between the point where your code publishes its context for another thread to
    ///     be able to call the <c>Unblock</c> method and the point where the actual method call to <c>Block</c> is made.  During this period,
    ///     it is imperative that you not call any method which may in turn block and unblock for its own reasons (e.g.: acquiring a lock).
    ///     Calls to the <c>Block</c> and <c>Unblock</c> method do not track the reason for the blocking and unblocking.  Only one object should have
    ///     ownership of a <c>Block</c> and <c>Unblock</c> pair.</para>
    /// </remarks>
    /// <seealso cref="Context::Block Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    virtual void Unblock() =0;

    /// <summary>
    ///     Determines whether or not the context is synchronously blocked.  A context is considered to be synchronously
    ///     blocked if it explicitly performed an action which led to blocking.
    /// </summary>
    /// <returns>
    ///     Whether the context is synchronously blocked.
    /// </returns>
    /// <remarks>
    ///     A context is considered to be synchronously blocked if it explicitly performed an action which led to blocking.  On the thread scheduler,
    ///     this would indicate a call to the <c>Context::Block</c> method or a synchronization object which was built using the runtime's
    ///     <c>Context::Block</c> method.  On the UMS scheduler, this could also indicate a call to a Windows method which explicitly blocked
    ///     using Windows synchronization primitives.  Page faults, thread suspensions, and other asynchronous events which the UMS scheduler is aware
    ///     of do not constitute synchronous blocking.
    ///     <para>The return value from this method is an instantaneous sample of whether the context is synchronously blocked.  This value may
    ///     be stale the moment it is returned and can only be used under very specific circumstances.</para>
    /// </remarks>
    /// <seealso cref="Context::Block Method"/>
    /**/
    virtual bool IsSynchronouslyBlocked() const =0;

    /// <summary>
    ///     Yields execution so that another context may execute.  If no other context is available to yield to,
    ///     the method simply returns.
    /// </summary>
    /// <remarks>
    ///     This yield variant is intended for use within spin loops.
    ///     <para>This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.</para>
    /// </remarks>
    /**/
    _CRTIMP static void __cdecl _SpinYield();

    /// <summary>
    ///     Yields execution so that another context may execute.  If no other context is available to yield to, the scheduler
    ///     may yield to another operating system thread.
    /// </summary>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /// <seealso cref="Context::Block Method"/>
    /// <seealso cref="Context::Unblock Method"/>
    /**/
    _CRTIMP static void __cdecl Yield();

    /// <summary>
    ///     Returns an indication of whether the task collection which is currently executing inline on the current context
    ///     is in the midst of an active cancellation (or will be shortly).
    /// </summary>
    /// <returns>
    ///     If a scheduler is attached to the calling context and a task group is executing a task inline on that context,
    ///     an indication of whether that task group is in the midst of an active cancellation (or will be shortly); otherwise,
    ///     the value <c>false</c>.
    ///     <para>This method will not result in scheduler attachment if the calling context is not already associated with a scheduler.</para>
    /// </returns>
    /**/
    _CRTIMP static bool __cdecl IsCurrentTaskCollectionCanceling();

    /// <summary>
    ///     Returns a pointer to the current context.
    /// </summary>
    /// <returns>
    ///     A pointer to the current context.
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /**/
    _CRTIMP static Context * __cdecl CurrentContext();

    /// <summary>
    ///     Injects an additional virtual processor into a scheduler for the duration of a block of code when invoked on a context executing
    ///     on one of the virtual processors in that scheduler.
    /// </summary>
    /// <param name="_BeginOversubscription">
    ///     If <c>true</c>, an indication that an extra virtual processor should be added for the duration of the oversubscription.
    ///     If <c>false</c>, an indication that the oversubscription should end and the previously added virtual processor should be removed.
    /// </param>
    /// <remarks>
    ///     Note that on a scheduler which utilizes user mode schedulable (UMS) threads, this method does not inject a new virtual processor.  The
    ///     UMS scheduler can detect kernel blocking and choose to run a new context on a virtual processor whose executing context blocked.
    ///     <para>For more information on using oversubscription in your application, see <see cref="Task Scheduler (Concurrency Runtime)"/>.</para>
    /// </remarks>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl Oversubscribe(bool _BeginOversubscription);

protected:

    //
    // Privatize operator delete.  The scheduler internally manages contexts.
    //
    template<class _T> friend void Concurrency::details::_InternalDeleteHelper(_T * _PObject);

    /// <summary>
    ///     A <c>Context</c> object is destroyed internally by the runtime. It may not be explicitly deleted.
    /// </summary>
    /// <param name="_PObject">
    ///     A pointer to the object to be deleted.
    /// </param>
    /**/
    void operator delete(void * _PObject)
    {
        ::operator delete(_PObject);
    }
};

/// <summary>
///     A non-reentrant mutex which is explicitly aware of the Concurrency Runtime.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Synchronization Data Structures"/>.
/// </remarks>
/// <seealso cref="reader_writer_lock Class"/>
/**/
class critical_section
{
public:

    /// <summary>
    ///     Constructs a new critical section.
    /// </summary>
    /**/
    _CRTIMP critical_section();

    /// <summary>
    ///     Destroys a critical section.
    /// </summary>
    /// <remarks>
    ///     It is expected that the lock is no longer held when the destructor runs.  Allowing the critical section to destruct with the lock
    ///     still held results in undefined behavior.
    /// </remarks>
    /**/
    _CRTIMP ~critical_section();

    /// <summary>
    ///     Acquires this critical section.
    /// </summary>
    /// <remarks>
    ///     It is often safer to utilize the <see cref="critical_section::scoped_lock Class">scoped_lock</see> construct to acquire and release
    ///     a <c>critical_section</c> object in an exception safe way.
    ///     <para>If the lock is already held by the calling context, an <see cref="improper_lock Class">improper_lock</see> exception will be
    ///     thrown.</para>
    /// </remarks>
    /// <seealso cref="critical_section::unlock Method"/>
    /// <seealso cref="critical_section::scoped_lock Class"/>
    /**/
    _CRTIMP void lock();

    /// <summary>
    ///     Tries to acquire the lock without blocking.
    /// </summary>
    /// <returns>
    ///     If the lock was acquired, the value <c>true</c>; otherwise, the value <c>false</c>.
    /// </returns>
    /// <seealso cref="critical_section::unlock Method"/>
    /**/
    _CRTIMP bool try_lock();

    /// <summary>
    ///     Unlocks the critical section.
    /// </summary>
    /// <remarks>
    ///     If the lock is not held by the calling thread, an <see cref="improper_unlock Class">improper_unlock</see> exception will be thrown.
    /// </remarks>
    /// <seealso cref="critical_section::lock Method"/>
    /// <seealso cref="critical_section::try_lock Method"/>
    /**/
    _CRTIMP void unlock();

    /// <summary>
    ///     A reference to a <c>critical_section</c> object.
    /// </summary>
    /**/
    typedef critical_section& native_handle_type;

    /// <summary>
    ///     Returns a platform specific native handle, if one exists.
    /// </summary>
    /// <returns>
    ///     A reference to the critical section.
    /// </returns>
    /// <remarks>
    ///     A <c>critical_section</c> object is not associated with a platform specific native handle for the Windows operating system.
    ///     The method simply returns a reference to the object itself.
    /// </remarks>
    /**/
    _CRTIMP native_handle_type native_handle();

    /// <summary>
    ///     Guarantees that if any context holds the lock at the time the method is called, that context has released
    ///     the lock before this method returns.
    /// </summary>
    /// <remarks>
    ///     If no context holds the lock at the instant this method is called, it returns instantly.
    /// </remarks>
    /**/
    void _Flush_current_owner();

    /// <summary>
    ///     Acquires this critical section given a specific node to lock.
    /// </summary>
    /// <param name="_PLockingNode">
    ///     The node that needs to own the lock.
    /// </param>
    /// <param name="_FHasExternalNode">
    ///     An indication if the node being locked is external to the critical_section.
    /// </param>
    /// <remarks>
    ///     If the lock is already held by the calling context, an <see cref="improper_lock Class">.improper_lock</see> exception will be thrown.
    /// </remarks>
    /**/
    void _Acquire_lock(void * _PLockingNode, bool _FHasExternalNode);

    /// <summary>
    ///     An exception safe RAII wrapper for a <c>critical_section</c> object.
    /// </summary>
    /**/
    class scoped_lock
    {
    public:

        /// <summary>
        ///     Constructs a <c>scoped_lock</c> object and acquires the <c>critical_section</c> object passed in the <paramref name="_Critical_section"/> 
        ///     parameter.  If the critical section is held by another thread, this call will block.
        /// </summary>
        /// <param name="_Critical_section">
        ///     The critical section to lock.
        /// </param>
        /// <seealso cref="critical_section Class"/>
        /**/
        explicit _CRTIMP scoped_lock(critical_section& _Critical_section);

        /// <summary>
        ///     Destroys a <c>scoped_lock</c> object and releases the critical section supplied in its constructor.
        /// </summary>
        /// <seealso cref="critical_section Class"/>
        /**/
        _CRTIMP ~scoped_lock();

    private:

        critical_section& _M_critical_section;
        _CONCRT_BUFFER _M_node[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        scoped_lock(const scoped_lock&);                    // no copy constructor
        scoped_lock const & operator=(const scoped_lock&);  // no assignment operator
    };

private:
    /// <summary>
    ///     The node allocated on the stack never really owns the lock. The reason for that is that
    ///     it would go out of scope and its insides would not be visible in unlock() where it would potentially
    ///     need to unblock the next in the queue. Instead, its state is transferred to the internal
    ///     node which is used as a scratch node.
    /// </summary>
    /// <param name="_PLockingNode">
    ///     The node that needs to own the lock.
    /// </param>
    /**/
    void _Switch_to_active(void * _PLockingNode);

    _CONCRT_BUFFER  _M_activeNode[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    void * volatile _M_pHead;
    void * volatile _M_pTail;

    /// <summary>
    ///     Hide copy constructor for a critical section
    /// </summary>
    /**/
    critical_section(const critical_section&);

    /// <summary>
    ///     Hide assignment operator for a critical section
    /// </summary>
    /**/
    critical_section& operator=(const critical_section&);
};

/// <summary>
///    A writer-preference queue-based reader-writer lock with local only spinning.  The lock grants first in - first out (FIFO) access to writers
///    and starves readers under a continuous load of writers.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Synchronization Data Structures"/>.
/// </remarks>
/// <seealso cref="critical_section Class"/>
/**/
class reader_writer_lock
{
public:

    /// <summary>
    ///     Constructs a new <c>reader_writer_lock</c> object.
    /// </summary>
    /**/
    _CRTIMP reader_writer_lock();

    /// <summary>
    ///     Destroys the <c>reader_writer_lock</c> object.
    /// </summary>
    /// <remarks>
    ///     It is expected that the lock is no longer held when the destructor runs.  Allowing the reader writer lock to destruct with the lock
    ///     still held results in undefined behavior.
    /// </remarks>
    /**/
    _CRTIMP ~reader_writer_lock();

    /// <summary>
    ///     Acquires the reader-writer lock as a writer.
    /// </summary>
    /// <remarks> 
    ///     It is often safer to utilize the <see cref="reader_writer_lock::scoped_lock Class">scoped_lock</see> construct to acquire and release
    ///     a <c>reader_writer_lock</c> object as a writer in an exception safe way.
    ///     <para>Once a writer attempts to acquire the lock, any future readers will block until the writers have successfully acquired
    ///     and released the lock. This lock is biased towards writers and can starve readers under a continuous load of writers.</para>
    ///     <para>Writers are chained so that a writer exiting the lock releases the next writer in line.</para>
    ///     <para>If the lock is already held by the calling context, an <see cref="improper_lock Class">improper_lock</see> exception will be
    ///     thrown.</para>
    /// </remarks> 
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP void lock();

    /// <summary>
    ///     Attempts to acquire the reader-writer lock as a writer without blocking.
    /// </summary>
    /// <returns>
    ///     If the lock was acquired, the value <c>true</c>; otherwise, the value <c>false</c>.
    /// </returns>
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP bool try_lock();

    /// <summary>
    ///     Acquires the reader-writer lock as a reader. If there are writers, active readers have to wait until they are done.
    ///     The reader simply registers an interest in the lock and waits for writers to release it.
    /// </summary>
    /// <remarks> 
    ///     It is often safer to utilize the <see cref="reader_writer_lock::scoped_lock_read Class">scoped_lock_read</see> construct to acquire
    ///     and release a <c>reader_writer_lock</c> object as a reader in an exception safe way.
    ///     <para>If there are writers waiting on the lock, the reader will wait until all writers in line have acquired
    ///     and released the lock.  This lock is biased towards writers and can starve readers under a continuous load of writers.</para>
    /// </remarks> 
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP void lock_read();

    /// <summary>
    ///     Attempts to acquire the reader-writer lock as a reader without blocking.
    /// </summary>
    /// <returns>
    ///     If the lock was acquired, the value <c>true</c>; otherwise, the value <c>false</c>.
    /// </returns>
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP bool try_lock_read();

    /// <summary>
    ///     Unlocks the reader-writer lock based on who locked it, reader or writer.
    /// </summary>
    /// <remarks>
    ///     If there are writers waiting on the lock, the release of the lock will always go to the next writer in FIFO
    ///     order.   This lock is biased towards writers and can starve readers under a continuous load of writers.
    /// </remarks>
    /// <seealso cref="reader_writer_lock::lock Method"/>
    /// <seealso cref="reader_writer_lock::lock_read Method"/>
    /// <seealso cref="reader_writer_lock::try_lock Method"/>
    /// <seealso cref="reader_writer_lock::try_lock_read Method"/>
    /**/
    _CRTIMP void unlock();

    /// <summary>
    ///     Acquires a write lock given a specific write node to lock.
    /// </summary>
    /// <param name="_PLockingNode">
    ///     The node that needs to own the lock.
    /// </param>
    /// <param name="_FHasExternalNode">
    ///     An indication if the node being locked is external to the <c>reader_writer_lock</c> object.
    /// </param>
    /// <remarks>
    ///     If the lock is already held by the calling context, an <see cref="improper_lock Class">.improper_lock</see> exception will be
    ///     thrown.
    /// </remarks>
    /**/
    void _Acquire_lock(void * _PLockingNode, bool _FHasExternalNode);

    /// <summary>
    ///     An exception safe RAII wrapper that can be used to acquire <c>reader_writer_lock</c> lock objects as a writer.
    /// </summary>
    /**/
    class scoped_lock
    {
    public:
        /// <summary>
        ///     Constructs a <c>scoped_lock</c> object and acquires the <c>reader_writer_lock</c> object passed in the 
        ///     <paramref name="_Reader_writer_lock"/> parameter as a writer.  If the lock is held by another thread, this call will block.
        /// </summary>
        /// <param name="_Reader_writer_lock">
        ///     The <c>reader_writer_lock</c> object to acquire as a writer.
        /// </param>
        /**/
        explicit _CRTIMP scoped_lock(reader_writer_lock& _Reader_writer_lock);

        /// <summary>
        ///     Destroys a <c>reader_writer_lock</c> object and releases the lock supplied in its constructor.
        /// </summary>
        /**/
        _CRTIMP ~scoped_lock();

    private:

        reader_writer_lock& _M_reader_writer_lock;
        _CONCRT_BUFFER _M_writerNode[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        scoped_lock(const scoped_lock&);                    // no copy constructor
        scoped_lock const & operator=(const scoped_lock&);  // no assignment operator
    };

    /// <summary>
    ///     An exception safe RAII wrapper that can be used to acquire <c>reader_writer_lock</c> lock objects as a reader.
    /// </summary>
    /**/
    class scoped_lock_read
    {
    public:
        /// <summary>
        ///     Constructs a <c>scoped_lock_read</c> object and acquires the <c>reader_writer_lock</c> object passed in the
        ///     <paramref name="_Reader_writer_lock"/> parameter as a reader.  If the lock is held by another thread as a writer or there
        ///     are pending writers, this call will block.
        /// </summary>
        /// <param name="_Reader_writer_lock">
        ///     The <c>reader_writer_lock</c> object to acquire as a reader.
        /// </param>
        /**/
        explicit _CRTIMP scoped_lock_read(reader_writer_lock& _Reader_writer_lock);

        /// <summary>
        ///     Destroys a <c>scoped_lock_read</c> object and releases the lock supplied in its constructor.
        /// </summary>
        /**/
        _CRTIMP ~scoped_lock_read();

    private:

        reader_writer_lock& _M_reader_writer_lock;

        scoped_lock_read(const scoped_lock_read&);                    // no copy constructor
        scoped_lock_read const & operator=(const scoped_lock_read&);  // no assignment operator
    };

private:

    /// <summary>
    ///     Called for the first context in the writer queue. It sets the queue head and it tries to
    ///     claim the lock if readers are not active.
    /// </summary>
    /// <param name="_PWriter">
    ///     The first writer in the queue.
    /// </param>
    /**/
    bool _Set_next_writer(void * _PWriter);

    /// <summary>
    ///     Called when writers are done with the lock, or when lock was free for claiming by
    ///     the first reader coming in. If in the meantime there are more writers interested
    ///     the list of readers is finalized and they are convoyed, while head of the list
    ///     is reset to NULL.
    /// </summary>
    /// <returns>
    ///     Pointer to the head of the reader list.
    /// </returns>
    /**/
    void * _Get_reader_convoy();

    /// <summary>
    ///     Called from unlock() when a writer is holding the lock. Writer unblocks the next writer in the list
    ///     and is being retired. If there are no more writers, but there are readers interested, then readers
    ///     are unblocked.
    /// </summary>
    /**/
    void _Unlock_writer();

    /// <summary>
    ///     Called from unlock() when a reader is holding the lock. Reader count is decremented and if this
    ///     is the last reader it checks whether there are interested writers that need to be unblocked.
    /// </summary>
    /**/
    void _Unlock_reader();

    /// <summary>
    ///     When the last writer leaves the lock, it needs to reset the tail to NULL so that the next coming
    ///     writer would know to try to grab the lock. If the CAS to NULL fails, then some other writer
    ///     managed to grab the tail before the reset, so this writer needs to wait until the link to
    ///     the next writer is complete before trying to release the next writer.
    /// </summary>
    /// <param name="_PWriter">
    ///     Last writer in the queue.
    /// </param>
    /**/
    void _Remove_last_writer(void * _PWriter);

    /// <summary>
    ///     The writer node allocated on the stack never really owns the lock. The reason for that is that
    ///     it would go out of scope and its insides would not be visible in unlock() where it would potentially
    ///     need to unblock the next writer in the queue. Instead, its state is transferred to the internal
    ///     writer node which is used as a scratch node.
    /// </summary>
    /// <param name="_PWriter">
    ///     The writer that needs to own the lock.
    /// </param>
    /**/
    void _Switch_to_active(void * _PWriter);

    _CONCRT_BUFFER _M_activeWriter[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    void *         _M_pReaderHead;
    void *         _M_pWriterHead;
    void *         _M_pWriterTail;
    volatile long  _M_lockState;

    /// <summary>
    ///     Hide copy constructor for a reader_writer_lock
    /// </summary>
    /**/
    reader_writer_lock (const reader_writer_lock& _Lock);

    /// <summary>
    ///     Hide assignment operator for a reader_writer_lock
    /// </summary>
    /**/
    reader_writer_lock& operator=(const reader_writer_lock& _Lock);
};

/// <summary>
///     Value indicating that a wait timed out.
/// </summary>
/// <seealso cref="event Class"/>
/// <seealso cref="event::wait Method"/>
/// <seealso cref="event::wait_for_multiple Method"/>
/**/
const size_t COOPERATIVE_WAIT_TIMEOUT = SIZE_MAX;

/// <summary>
///     Value indicating that a wait should never time out.
/// </summary>
/// <seealso cref="event Class"/>
/// <seealso cref="event::wait Method"/>
/// <seealso cref="event::wait_for_multiple Method"/>
/**/
const unsigned int COOPERATIVE_TIMEOUT_INFINITE = (unsigned int)-1;

/// <summary>
///     A manual reset event which is explicitly aware of the Concurrency Runtime.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Synchronization Data Structures"/>.
/// </remarks>
/**/
class event
{
public:

    /// <summary>
    ///     Constructs a new event.
    /// </summary>
    /**/
    _CRTIMP event();

    /// <summary>
    ///     Destroys an event.
    /// </summary>
    /// <remarks>
    ///     It is expected that there are no threads waiting on the event when the destructor runs.  Allowing the event to destruct with threads
    ///     still waiting upon it results in undefined behavior.
    /// </remarks>
    /**/
    _CRTIMP ~event();

    /// <summary>
    ///     Waits for the event to become signaled.
    /// </summary>
    /// <param name="_Timeout">
    ///     Indicates the number of milliseconds before the wait times out.  The value <c>COOPERATIVE_TIMEOUT_INFINITE</c> signifies that 
    ///     there is no timeout.
    /// </param>
    /// <returns>
    ///     If the wait was satisfied, the value <c>0</c> is returned; otherwise, the value <c>COOPERATIVE_WAIT_TIMEOUT</c> to indicate that
    ///     the wait timed out without the event becoming signaled.
    /// </returns>
    /// <seealso cref="event::set Method"/>
    /// <seealso cref="COOPERATIVE_TIMEOUT_INFINITE Variable">COOPERATIVE_TIMEOUT_INFINITE</seealso>
    /// <seealso cref="COOPERATIVE_WAIT_TIMEOUT Variable">COOPERATIVE_WAIT_TIMEOUT</seealso>
    /**/
    _CRTIMP size_t wait(unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    /// <summary>
    ///     Signals the event.
    /// </summary>
    /// <remarks>
    ///     Signaling the event may cause an arbitrary number of contexts which are waiting on the event to become runnable.
    /// </remarks>
    /// <seealso cref="event::wait Method"/>
    /// <seealso cref="event::reset Method"/>
    /**/
    _CRTIMP void set();

    /// <summary>
    ///     Resets the event to a non-signaled state.
    /// </summary>
    /// <seealso cref="event::set Method"/>
    /// <seealso cref="event::wait Method"/>
    /**/
    _CRTIMP void reset();

    /// <summary>
    ///     Waits for multiple events to become signaled.
    /// </summary>
    /// <param name="_PPEvents">
    ///     An array of events to wait on.  The number of events within the array is indicated by the <paramref name="_Count"/> parameter.
    /// </param>
    /// <param name="_Count">
    ///     The count of events within the array supplied in the <paramref name="_PPEvents"/> parameter.
    /// </param>
    /// <param name="_FWaitAll">
    ///     If set to the value <c>true</c>, the parameter specifies that all events within the array supplied in the <paramref name="_PPEvents"/>
    ///     parameter must become signaled in order to satisfy the wait.  If set to the value <c>false</c>, it specifies that any event within the
    ///     array supplied in the <paramref name="_PPEvents"/>  parameter becoming signaled will satisfy the wait.
    /// </param>
    /// <param name="_Timeout">
    ///     Indicates the number of milliseconds before the wait times out.  The value <c>COOPERATIVE_TIMEOUT_INFINITE</c> signifies that
    ///     there is no timeout.
    /// </param>
    /// <returns>
    ///     If the wait was satisfied, the index within the array supplied in the <paramref name="_PPEvents"/> parameter which satisfied
    ///     the wait condition; otherwise, the value <c>COOPERATIVE_WAIT_TIMEOUT</c> to indicate that the wait timed out without the condition
    ///     being satisfied.
    /// </returns>
    /// <remarks>
    ///     If the parameter <paramref name="_FWaitAll"/> is set to the value <c>true</c> to indicate that all events must become signaled to satisfy
    ///     the wait, the index returned by the function carries no special significance other than the fact that it is not the value
    ///     <c>COOPERATIVE_WAIT_TIMEOUT</c>.
    /// </remarks>
    /// <seealso cref="event::wait Method"/>
    /// <seealso cref="COOPERATIVE_TIMEOUT_INFINITE Variable">COOPERATIVE_TIMEOUT_INFINITE</seealso>
    /// <seealso cref="COOPERATIVE_WAIT_TIMEOUT Variable">COOPERATIVE_WAIT_TIMEOUT</seealso>
    /**/
    _CRTIMP static size_t __cdecl wait_for_multiple(event ** _PPEvents, size_t _Count, bool _FWaitAll, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

private:

    // Prevent bad usage of copy-constructor and copy-assignment
    event(const event& _Event);
    event& operator=(const event& _Event);

    void * volatile _M_pWaitChain;
    void * _M_pResetChain;
    Concurrency::critical_section _M_lock;
};

namespace details
{
    // This is a non-reentrant lock wrapper around the ConcRT critical-section
    // and used by agents/messaging
    class _NonReentrantPPLLock
    {
    public:

        // Constructor for _NonReentrantPPLLock
        _CRTIMP _NonReentrantPPLLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire(void * _Lock_node);

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            _CRTIMP explicit _Scoped_lock(_NonReentrantPPLLock& _Lock);

            // Destroys the holder and releases the lock
            _CRTIMP ~_Scoped_lock();

        private:
            _NonReentrantPPLLock& _M_lock;
            _CONCRT_BUFFER  _M_lockNode[(3 * sizeof(void *) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // critical_section
        Concurrency::critical_section _M_criticalSection;
    };

    // This is a reentrant lock implemented using the ConcRT critical section
    class _ReentrantPPLLock
    {
    public:
        // Constructor for _ReentrantPPLLock
        _CRTIMP _ReentrantPPLLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire(void * _Lock_node);

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            _CRTIMP explicit _Scoped_lock(_ReentrantPPLLock& _Lock);

            // Destroys the holder and releases the lock
            _CRTIMP ~_Scoped_lock();

        private:
            _ReentrantPPLLock& _M_lock;
            _CONCRT_BUFFER  _M_lockNode[(3 * sizeof(void *) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // critical_section
        Concurrency::critical_section _M_criticalSection;

        // The number of times this lock has been taken recursively
        long _M_recursionCount;

        // The current owner of the lock
        volatile long _M_owner;
    };

    struct _Chore
    {
    protected:
        // Constructors.
        explicit _Chore(TaskProc _PFunction) : m_pFunction(_PFunction)
        {
        }

        _Chore()
        {
        }

        virtual ~_Chore()
        {
        }

    public:

        // The function which invokes the work of the chore.
        TaskProc m_pFunction;
    };

    // _UnrealizedChore represents an unrealized chore -- a unit of work that scheduled in a work
    // stealing capacity.  Some higher level construct (language or library) will map atop this to provide
    // an usable abstraction to clients.
    class _UnrealizedChore : public _Chore, public _AllocBase
    {
    public:
        // Constructor for an unrealized chore.
        _UnrealizedChore() :
            _M_pTaskCollection(NULL)
        {
        }

        // Method that executes the unrealized chore.
        void _Invoke() 
        {
            _M_pChoreFunction(this);
        }

        // Sets the attachment state of the chore at the time of stealing.
        void _SetDetached(bool _FDetached);

        // Returns the owning collection of the chore.
        Concurrency::details::_TaskCollectionBase* _OwningCollection() const
        {
            return _M_pTaskCollection;
        }

        // Set flag that indicates whether the scheduler owns the lifetime of the object and is responsible for freeing it.
        // The flag is ignored by _StructuredTaskCollection
        void _SetRuntimeOwnsLifetime(bool fValue) 
        { 
            _M_fRuntimeOwnsLifetime = fValue; 
        }

        // Returns the flag that indicates whether the scheduler owns the lifetime of the object and is responsible for freeing it.
        // The flag is ignored by _StructuredTaskCollection
        bool _GetRuntimeOwnsLifetime() const
        {
            return _M_fRuntimeOwnsLifetime;
        }

        // Allocator to be used when runtime owns lifetime.
        template <typename _ChoreType, typename _Function>
        static _ChoreType * _InternalAlloc(const _Function& _Func)
        {
            _ChoreType * _Chore = new _ChoreType(_Func);
            _Chore->_M_fRuntimeOwnsLifetime = true;
            return _Chore;
        }

    protected:
        // Invocation bridge between the _UnrealizedChore and PPL.
        template <typename _ChoreType>
        static void __cdecl _InvokeBridge(_ChoreType * _PChore)
        {
            (*_PChore)();
        }

        // Place associated task collection in a safe state.
        _CRTIMP void _CheckTaskCollection();

    private:

        friend class _StructuredTaskCollection;
        friend class _TaskCollection;
        typedef void (__cdecl * CHOREFUNC)(_UnrealizedChore * _PChore);

        // The collection of work to which this particular chore belongs.
        Concurrency::details::_TaskCollectionBase * _M_pTaskCollection;

        // Internal invocation inside the scheduler.
        CHOREFUNC _M_pChoreFunction;

        // Indicates whether the scheduler owns the lifetime of the object and is responsible for freeing it.
        // This flag is ignored by _StructuredTaskCollection
        bool _M_fRuntimeOwnsLifetime;

        // An indication of whether the chore (if stolen) was detached.
        bool _M_fDetached;

        // The internal wrapper around invocation of stolen structured chores.
        __declspec(noinline)
        static void __cdecl _StructuredChoreWrapper(_UnrealizedChore * _PChore);

        // The internal wrapper around invocation of stolen unstructured chores.
        __declspec(noinline)
        static void __cdecl _UnstructuredChoreWrapper(_UnrealizedChore * _PChore);

        // To free memory allocated with _InternalAlloc.
        static void _InternalFree(_UnrealizedChore * _PChore);
    };

    // Represents possible results of waiting on a task collection.
    enum _TaskCollectionStatus
    {
        _NotComplete,
        _Completed,
        _Canceled
    };

    // _TaskCollectionBase represents an abstract set of work and provides shared waiting semantics for stolen work.
    class _TaskCollectionBase
    {
    public:
        // Constructs a new task collection.
        _TaskCollectionBase() :
            _M_completedStolenChores(_CollectionNotInitialized),
            _M_unpoppedChores(0),
            _M_pException(NULL),
            _M_inliningDepth(_S_notInlined)
        {
        }

        // Returns the owning context of the task collection.
        void * _OwningContext() const
        {
            return _M_pOwningContext;
        }

        // Returns the inlining depth.
        int _InliningDepth() const
        {
            return _M_inliningDepth;
        }

        // Returns whether this is a structured collection or not.
        bool _IsStructured()
        {
            return (_M_inlineFlags & _S_structured) != 0;
        }

    protected:

        friend class Concurrency::details::_UnrealizedChore;

        enum _TaskCollectionBaseState
        {
            _CollectionNotInitialized = LONG_MIN,
            _CollectionInitializationInProgress = LONG_MIN+1,
            _CollectionInitialized = 0
        };

        // Returns the exception portion of _M_pException.
        std::exception_ptr * _Exception() const
        {
            return (std::exception_ptr *) ((size_t)_M_pException & ~_S_cancelBitsMask);
        }

        // Indicates whether or not this task collection has an abnormal exit.
        bool _IsAbnormalExit() const
        {
            return _M_pException != NULL;
        }

        // Returns the cancel flags.
        size_t _CancelState() const
        {
            return (size_t) _M_pException & _S_cancelBitsMask;
        }

        // Returns whether or not the collection is marked for cancellation.
        bool _IsMarkedForCancellation() const
        {
            return (_CancelState() & _S_cancelBitsMask) != 0;
        }

        // Returns whether an inline cancellation was performed.
        bool _PerformedInlineCancel() const
        {
            _ASSERTE(_CancelState() != _S_cancelStarted);
            return _CancelState() == _S_cancelShotdownOwner;
        }

        // Returns the parent collection safely.
        _TaskCollectionBase *_SafeGetParent()
        {
            return ((_M_inliningDepth != _S_notInlined) ? _M_pParent : NULL);
        }

        // Called in order to execute a supposed interruption point.
        void _Interrupt(bool _FLocalCondition, int _LocalFlags = 0);

        // Called in order to determine whether this task collection will interrupt for a pending cancellation at or above it.
        bool _WillInterruptForPendingCancel();

        // Called when an exception is raised on a chore on a given task collection, this makes a determination of what to do with the exception
        // and squirrels it away for potential transport back to the thread performing a join on a chore collection.
        void _RaisedException();

        // Potentially rethrows the exception which was set with _RaisedException.  The caller has responsibility to ensure that _RaisedException 
        //  was called prior to calling this and that _M_pException has progressed beyond the _S_nonNull state.
        void _RethrowException();

        // Marks the collection for cancellation and returns whether the collection was thus marked.
        bool _MarkCancellation();

        // Finishes the cancellation state (changing from _S_cancelStarted to one of the other states).  Note that only the 
        // thread which successfully marked cancellation may call this.
        void _FinishCancelState(size_t _NewCancelState);

        // Called when a cancellation is raised on a chore on a given task collection.  This makes a determination of what to do with the exception
        // and squirrels it away for potential transport back to the thread performing a join on a chore collection.  Note that every other exception
        // has precedence over a cancellation.
        void _RaisedCancel();

        // Tracks the parent collection.  (e.g.: A task collection B created during execution of a chore C on task collection A is
        // considered a child of A).
        _TaskCollectionBase * _M_pParent;

        // Tracks the inlining depth of this collection for cancellation purposes and packs a series of definition bits.
        int _M_inliningDepth : 28;
        int _M_inlineFlags : 4;

        // The context which owns the task collection.  This is the context where the collection is created.
        void * _M_pOwningContext;

        // The number of unpopped chores associated with the task collection (set by the derived
        // class during chore association.
        long _M_unpoppedChores;

        // The number of stolen chores executed so far.
        volatile long _M_completedStolenChores;

        // The stored exception which has been marshaled from the thread a stolen chore ran upon to the thread that is waiting on the
        // task collection.
        //
        // The lower two bits of _M_pException are utilized for the cancellation state machine.  The upper 30 are the exception pointer.  This implies
        // that the excepiton pointer must be 4-byte aligned.  Because of intermediate states, the exception pointer cannot be between 0x8 and 0xF.  The heap should
        // not be allocating such...
        //
        std::exception_ptr * _M_pException;

        // Cancellation states
        static const size_t _S_cancelBitsMask = 0x3;
        static const size_t _S_cancelNone = 0x0;
        static const size_t _S_cancelStarted = 0x1;
        static const size_t _S_cancelDeferredShootdownOwner = 0x2;
        static const size_t _S_cancelShotdownOwner = 0x3;

        // Intermediate exceptions.
        static const size_t _S_nonNull = 0x8;
        static const size_t _S_cancelException = 0xC; 

        // initialization state for inlining depth.
        static const int _S_notInlined = -1;

        // Inline flags.
        static const int _S_structured = 0x00000001;
        static const int _S_localCancel = 0x00000002;
        static const int _S_reserved = 0x0000000C;

    private:

        // Prevent bad usage of copy-constructor and copy-assignment
        _TaskCollectionBase(const _TaskCollectionBase& _Collection);
        _TaskCollectionBase& operator=(const _TaskCollectionBase& _Collection);
    };

    /// <summary>
    ///     Structured task collections represent groups of work which follow a strictly LIFO ordered paradigm
    ///     queueing and waiting respectively.  They can only be waited upon once (via object destructor)
    ///     and can only be used from a single thread of execution.
    /// </summary>
    /**/
    class _StructuredTaskCollection : public _TaskCollectionBase
    {
    public:
        
        /// <summary>
        ///     Construct a new structured task collection.
        /// </summary>
        /**/
        _StructuredTaskCollection()
        {
            _M_pOwningContext = NULL;
            _M_inlineFlags = _S_structured;
        }

        /// <summary>
        ///     Destruct a task collection and wait on all associated work to finish. Clients must call '_StructuredTaskCollection::Wait' 
        ///     or '_StructuredTaskCollection::Cancel' prior to destructing the object.  If there are chores remaining in the queues, an
        ///     exception (missing_wait) is thrown. If the destructor is running due to exception unwinding, it will abort any scheduled work.
        ///     If another exception occurs because work is aborted, the process will terminate (C++ semantics).
        /// </summary>
        /**/
        ~_StructuredTaskCollection()
        {
            if (!_TaskCleanup())
            {
                throw missing_wait();
            }
        }

        /// <summary>
        ///     Schedules a chore that may potentially run in parallel.  The chore is pushed onto the associated workstealing queue, and
        ///     will be executed in a LIFO order.Note that the specified chore may only be scheduled upon a single task collection at a given time.
        ///     Any attempt to schedule the same chore multiple times on one or more task collection will result in an invalid_multiple_scheduling
        ///     exception.  Once the chore is guaranteed to have been executed (via calling the Wait method), it can be rescheduled to an
        ///     arbitrary task collection.
        /// </summary>
        /// <param name="_PChore">
        ///     The new unrealized chore to schedule
        /// </param>
        /**/
        _CRTIMP void _Schedule(_UnrealizedChore * _PChore);

        /// <summary>
        ///     Cancels work on the task collection.
        /// </summary>
        /**/
        _CRTIMP void _Cancel();

        /// <summary>
        ///     Informs the caller whether or not the task collection is currently in the midst of cancellation.  Note that this
        ///     does not necessarily indicate that Cancel was called on the collection (although such certainly qualifies this function
        ///     to return true).  It may be the case that the task collection is executing inline and a task collection further up in the work
        ///     tree was canceled.  In cases such as these where we can determine ahead of time that cancellation will flow through
        ///     this collection, true will be returned as well.
        /// </summary>
        /// <returns>
        ///     An indication of whether the task collection is in the midst of a cancellation (or is guaranteed to be shortly).
        /// </returns>
        /**/
        _CRTIMP bool _IsCanceling();

        /// <summary>
        ///     A cancellation friendly wrapper with which to execute _PChore and then
        ///     waits for all chores running in the _StructuredTaskCollection to finish (normally or abnormally). This method encapsulates
        ///     all the running tasks in an exception handling block, and will re-throw any exceptions that occur in any of it tasks
        ///     (if those exceptions occur on another thread, they are marshaled from that thread to the thread where the _StructuredTaskCollection
        ///     was created, and re-thrown). After this function returns, the _StructuredTaskCollection cannot be used for scheduling further work.
        /// </summary>
        /// <param name="_PChore">
        ///     An _UnrealizedChore which when non-null will be called to invoke the chore in a cancelation friendly manner.
        /// </param>
        /// <returns>
        ///     An indication of the status of the wait.
        /// </returns>
        /**/
        _CRTIMP _TaskCollectionStatus __stdcall _RunAndWait(_UnrealizedChore * _PChore = NULL);

        /// <summary>
        ///     Waits for all chores running in the _StructuredTaskCollection to finish (normally or abnormally). This method encapsulates
        ///     all the running tasks in an exception handling block, and will re-throw any exceptions that occur in any of it tasks
        ///     (if those exceptions occur on another thread, they are marshaled from that thread to the thread where the _StructuredTaskCollection
        ///     was created, and re-thrown). After this function returns, the _StructuredTaskCollection cannot be used for scheduling further work.
        /// </summary>
        /// <returns>
        ///     An indication of the status of the wait.
        /// </returns>
        /**/
        _TaskCollectionStatus _Wait()
        {
            return _RunAndWait();
        }

        /// <summary>
        ///     Called to cancel any contexts which stole chores from the given collection.
        /// </summary>
        /**/
        void _CancelStolenContexts();

    private:

        friend class _UnrealizedChore;

        /// <summary>
        ///     Internal routine to abort work on the task collection.
        /// </summary>
        /**/
        _CRTIMP void _Abort();

        /// <summary>
        ///     Performs task cleanup normally done at destruction time.
        /// </summary>
        /**/
        bool _TaskCleanup()
        {
            //
            // Users are required to call Wait() before letting the destructor run.  Otherwise, throw.  Note that before throwing,
            // we must actually wait on the tasks since they contain pointers into stack frames and unwinding without the wait is
            // instant stack corruption.
            //
            if (_M_unpoppedChores > 0)
            {
                _Abort();

                if (!__uncaught_exception())
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        ///     Internal initialization of the structured task collection
        /// </summary>
        /**/
        void _Initialize();

        /// <summary>
        ///     Waits on a specified number of stolen chores.
        /// </summary>
        /// <param name="_StolenChoreCount">
        ///     The number of stolen chores to wait upon
        /// </param>
        /**/
        void _WaitOnStolenChores(long _StolenChoreCount);

        /// <summary>
        ///     Indicates that a stolen chore has completed.
        /// </summary>
        /**/
        void _CountUp();

        //
        // _StructuredTaskCollection::_M_event is used to construct an structured event object only when it is needed to block.  The structured event object 
        //  has no state to cleanup, therefore no dtor code is required.
        //
        _CONCRT_BUFFER _M_event[(sizeof(void*) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    /// <summary>
    ///     Task collections represent groups of work which step outside the strict structuring of the
    ///     _StructuredTaskCollection definition.  Any groups of work which do not follow LIFO ordering, are waited
    ///     upon multiple times, or are passed between arbitrary threads require utilization of this definition
    ///     of a task collection.  It has additional overhead over the _StructuredTaskCollection.
    /// </summary>
    /**/
    class _TaskCollection : public _TaskCollectionBase
    {
    public:

        /// <summary>
        ///     Constructs a new task collection.
        /// </summary>
        /**/
        _CRTIMP _TaskCollection();

        /// <summary>
        ///     Destroys a task collection.  Clients must call '_TaskCollection::Wait' or '_TaskCollection::Cancel' prior to destructing
        ///     the object.  If there are chores remaining in the queues, an exception (missing_wait) is thrown. If the destructor
        ///     is running due to exception unwinding, it will abort any scheduled work.  If another exception occurs because work
        ///     is aborted, the process will terminate (C++ semantics).
        /// </summary>
        /**/
        _CRTIMP ~_TaskCollection();

        /// <summary>
        ///     Schedules a chore that may potentially run in parallel.  The chore is pushed onto the associated workstealing queue, and
        ///     will be executed in a LIFO order. The tasks scheduled into a _TaskCollection are scheduled into the current scheduler.
        ///     Note that the specified chore may only be scheduled upon a single task collection at a given time.  Any attempt to schedule the same
        ///     chore multiple times on one or more task collections will result in an invalid_multiple_scheduling exception.  Once the chore is
        ///     guaranteed to have been executed (via calling the Wait method), it can be rescheduled to an arbitrary task collection.
        /// </summary>
        /// <param name="_PChore">
        ///     The new unrealized chore to schedule
        /// </param>
        /**/
        _CRTIMP void _Schedule(_UnrealizedChore * _PChore);

        /// <summary>
        ///     Cancels work on the task collection.
        /// </summary>
        /**/
        _CRTIMP void _Cancel();

        /// <summary>
        ///     Informs the caller whether or not the task collection is currently in the midst of a cancellation.  Note that this
        ///     does not necessarily indicate that Cancel was called on the collection (although such certainly qualifies this function
        ///     to return true).  It may be the case that the task collection is executing inline and a task collection further up in the work
        ///     tree was canceled.  In cases such as these where we can determine ahead of time that cancellation will flow through
        ///     this collection, true will be returned as well.
        /// </summary>
        /// <returns>
        ///     An indication of whether the task collection is in the midst of a cancellation (or is guaranteed to be shortly).
        /// </returns>
        /**/
        _CRTIMP bool _IsCanceling();

        /// <summary>
        ///     A cancellation friendly wrapper with which to execute _PChore and then
        ///     waits for all chores running in the _TaskCollection to finish (normally or abnormally). This method encapsulates
        ///     all the running tasks in an exception handling block, and will re-throw any exceptions that occur in any of it tasks
        ///     (if those exceptions occur on another thread, they are marshaled from that thread to the thread where the _TaskCollection
        ///     was created, and re-thrown). After this function returns, the  _TaskCollection cannot be used for scheduling further work.
        /// </summary>
        /// <param name="_PChore">
        ///     An _UnrealizedChore which when non-null will be called to invoke the chore in a cancelation friendly manner.
        /// </param>
        /// <returns>
        ///     An indication of the status of the wait.
        /// </returns>
        /// </summary>
        /**/
        _CRTIMP _TaskCollectionStatus __stdcall _RunAndWait(_UnrealizedChore * _PChore = NULL);

        /// <summary>
        ///     Waits for all chores running in the _TaskCollection to finish (normally or abnormally). This method encapsulates
        ///     all the running tasks in an exception handling block, and will re-throw any exceptions that occur in any of it tasks
        ///     (if those exceptions occur on another thread, they are marshaled from that thread to the thread where the _TaskCollection
        ///     was created, and re-thrown). After this function returns, the  _TaskCollection cannot be used for scheduling further work.
        /// </summary>
        /// <returns>
        ///     An indication of the status of the wait.
        /// </returns>
        /// </summary>
        /**/
        _TaskCollectionStatus _Wait()
        {
            return _RunAndWait();
        }

        /// <summary>
        ///     Returns whether this task collection is marked for abnormal exit.
        /// </summary>
        /**/
        bool _IsMarkedForAbnormalExit() const;

    private:

        friend class _UnrealizedChore;
        friend class Concurrency::details::ContextBase;

        /// <summary>
        ///     Determines if the task collection is a stale alias (an object which was left over from a deferred delete
        ///     of a direct alias but which happens to match the hash key for a newly allocated task collection)
        /// </summary>
        /**/
        bool _IsStaleAlias() const;

        /// <summary>
        ///     Releases an alias -- this will free it if the release is the last man out.
        /// </summary>
        /**/
        void _ReleaseAlias();

        /// <summary>
        ///     Returns the object which this is an alias for.
        /// </summary>
        /**/
        _TaskCollection * _OriginalCollection() const;

        /// <summary>
        ///     Constructs an alias collection based on a specifed origin collection
        /// </summary>
        /// <param name="_POriginCollection">
        ///     Specifies which collection the newly constructed one will alias
        /// </param>
        /// <param name="_FDirectAlias">
        ///     Specifies whether the newly constructed collection is a direct alias
        /// </param>
        /**/
        _TaskCollection(_TaskCollection * _POriginCollection, bool _FDirectAlias);

        /// <summary>
        ///     Returns the local alias of a task collection on the current context.
        /// </summary>
        /**/
        _TaskCollection * _Alias();

        /// <summary>
        ///     Internal routine to abort work on the task collection.
        /// </summary>
        /// <param name="fLeaveCanceled">
        ///     An indication as to whether or not to leave the task collection canceled after the abort.
        /// </param>
        /**/
        void _Abort(bool fLeaveCanceled = false);

        /// <summary>
        ///     Returns whether the task collection is an alias.
        /// </summary>
        /**/
        bool _IsAlias() const;

        /// <summary>
        ///     Returns whether the task collection is an indirect alias.
        /// </summary>
        /**/
        bool _IsIndirectAlias() const;

        /// <summary>
        ///     Returns whether the task collection is a direct alias.
        /// </summary>
        /**/
        bool _IsDirectAlias() const;

        /// <summary>
        ///     Returns whether this task collection has a direct alias.
        /// </summary>
        /**/
        bool _HasDirectAlias() const;

        /// <summary>
        ///     Cancels work on the task collection.  This is an internal version.
        /// </summary>
        /// <param name="_InsideException">
        ///     Indicates whether the cancellation is taking place due to
        ///     exception unwinding within the runtime
        /// </param>
        /// <param name="_PSnapPoint">
        ///     A snapshot of the direct alias list which is what the call will effect
        /// </param>
        /**/
        void _Cancel(bool _InsideException, _TaskCollection * _PSnapPoint);

        /// <summary>
        ///     Called for every new chore put into the task collection.  Assures appropriate synchronization with waiters.
        /// </summary>
        /**/
        void _NotifyNewChore();

        /// <summary>
        ///     Called for every completed chore from the task collection.  Assures appropriate synchronization with waiters.
        /// </summary>
        /**/
        void _NotifyCompletedChore();

        /// <summary>
        ///     Waits on the given task collection and every alias.
        /// </summary>
        /// <param name="_PSnapPoint">
        ///     A snapshot of the direct alias list which is what the call will effect
        /// </param>
        /**/
        void _FullAliasWait(_TaskCollection * _PSnapPoint);

        /// <summary>
        ///     Resets the task collection for future usage.
        /// </summary>
        /// <param name="_PSnapPoint">
        ///     A snapshot of the direct alias list which is what the call will effect
        /// </param>
        /**/
        void _Reset(_TaskCollection * _PSnapPoint);

        /// <summary>
        ///     Called when an exception is raised on a chore on an unstructured task collection, this makes a determination of what to do with the exception
        ///     and squirrels it away for potential transport back to the thread performing a join on a task collection.  This specifically handles situations
        ///     on for unstructured task collections before calling _TaskCollectionBase::_RaisedException.
        /// </summary>
        /**/
        void _RaisedException();

        /// <summary>
        ///     Called in order to set the cancellation status of the collection.
        /// </summary>
        /// <param name="_Status">
        ///     The cancellation status to set
        /// </param>
        /// <param name="_DisallowIfNotClear">
        ///     Indicates whether the set should be disallowed if there is previous cancellation state
        /// </param>
        /// <returns>
        ///     An indication of whether the set succeeded
        /// </returns>
        /**/
        bool _SetCancelState(long _Status, bool _DisallowIfNotClear);

        /// <summary>
        ///     Called to cancel a single alias of a task collection from an arbitrary thread.
        /// </summary>
        /// <param name="_InsideException">
        ///     Indicates whether the cancellation is taking place due to
        ///     exception unwinding within the runtime
        /// </param>
        /**/
        void _CancelFromArbitraryThread(bool _InsideException);

        /// <summary>
        ///     Cancels all direct aliases of the task collection.
        /// </summary>
        /// <param name="_InsideException">
        ///     Indicates whether the cancellation is taking place due to
        ///     exception unwinding within the runtime
        /// </param>
        /// <param name="_PSnapPoint">
        ///     A snapshot of the direct alias list which is what the call will effect
        /// </param>
        /**/
        void _CancelDirectAliases(bool _InsideException, _TaskCollection * _PSnapPoint);

        /// <summary>
        ///     Called to cancel any contexts which stole chores from the given collection.  This is *PART* of a cancellation
        ///     scheme.  The remainder must be handled by the derived class in particular.  This should be called last.
        /// </summary>
        /// <param name="_InsideException">
        ///     Indicates whether the cancellation is taking place due to
        ///     exception unwinding within the runtime
        /// </param>
        /// <param name="_FInlineGated">
        ///     Indicates whether the inline context is safe and blocked from becoming inaccessible during
        ///     the duration of the call
        /// </param>
        /**/
        void _CancelStolenContexts(bool _InsideException, bool _FInlineGated); 

        /// <summary>
        ///     Returns the steal tracking list.
        /// </summary>
        /**/
        void *_GetStealTrackingList() const;

        /// <summary>
        ///     Internal initialization of the task collection
        /// </summary>
        /**/
        void _Initialize();

        /// <summary>
        ///     Performs an abortive sweep of the WSQ for inline stack overflow.
        /// </summary>
        /// <param name="_PCtx">
        ///     The context to sweep
        /// </param>
        /**/
        void _AbortiveSweep(void *_PCtx);

        /// <summary>
        ///     A predicate function checking whether a given chore belongs to a given collection.
        /// </summary>
        /// <param name="_PChore">
        ///     The chore to check
        /// </param>
        /// <param name="_PData">
        ///     The data to check against
        /// </param>
        /// <returns>
        ///     Whether or not the chore belongs to the collection
        /// </returns>
        /**/
        static bool __cdecl _CollectionMatchPredicate(_UnrealizedChore *_PChore, void *_PData);

        /// <summary>
        ///     Called to sweep an aborted chore in the case of inline stack overflow.
        /// </summary>
        /// <param name="_PChore">
        ///     The chore to sweep
        /// </param>
        /// <param name="_PData">
        ///     The data that was passed to the sweep predicate
        /// </param>
        /// <returns>
        ///     An indication of whether the chore is now gone
        /// </returns>
        /**/
        static bool __cdecl _SweepAbortedChore(_UnrealizedChore *_PChore, void *_PData);

        /// <summary>
        ///     Performs task cleanup normally done at destruction time.
        /// </summary>
        /// <param name="fExceptional">
        ///     An indication if the cleanup is exceptional and the collection should be left in a canceled state.
        /// </param>
        /**/
        bool _TaskCleanup(bool fExceptional);

        /// <summary>
        ///     Tracks contexts that have stolen chores from this collection.  This is storage for an internal list and lock.  Note that this list is only
        ///     used for detached schedule groups.
        /// </summary>
        /**/
        _CONCRT_BUFFER _M_stealTracker[(3 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        /// <summary>
        ///     A count of active stealers for *CANCELLATION PURPOSES ONLY*.  This is non-interlocked and guarded by the same lock as the
        ///     stealers list on this task collection.
        /// </summary>
        /**/
        long _M_activeStealersForCancellation;

        /// <summary>
        ///     An indication of the exit code of the chore.  Anything non-zero here indicates cancellation of one
        ///     form or another.
        /// </summary>
        /**/
        volatile long _M_exitCode;

        /// <summary>
        ///     The status of the task collection.
        /// </summary>
        /**/
        volatile long _M_executionStatus;

        /// <summary>
        ///     An event on which to wait for stolen chores to complete.
        /// </summary>
        /**/
        event _M_event;

        _TaskCollection * _M_pOriginalCollection;
        _TaskCollection * _M_pNextAlias;
        void * _M_pTaskExtension;

        int _M_taskCookies[2];

        volatile long _M_flags;
        volatile long _M_chaining;

        DWORD _M_boundQueueId;
        int _M_stackPos;
    };

    //
    // Internal stub class.
    //
    class _TimerStub;

    //
    // Internal wrapper around timers in order to allow timer messaging blocks to share implementation with internal ConcRT runtime
    // timers.
    //
    class _Timer
    {
    protected:
        // Constructs a new timer.
        //
        // _Ms: The duration and period of the timer in milliseconds.
        // _FRepeating: An indication of whether the timer is repeating (periodic) or not.
        _CRTIMP _Timer(unsigned int _Ms, bool _FRepeating);

        // Destroys the timer.
        _CRTIMP ~_Timer();

        // Starts the timer.
        _CRTIMP void _Start();

        // Stops the timer.
        _CRTIMP void _Stop();

    private:
        friend class _TimerStub;

        // Called when the timer fires.
        virtual void _Fire() =0;

        // The actual timer
        HANDLE _M_hTimer;

        // The duration and period of the timer.
        unsigned int _M_ms;

        // Whether the timer is repeating (periodic by _M_ms)
        bool _M_fRepeating;
    };
} // namespace details


/// <summary>
///     Enables tracing in the Concurrency Runtime.
/// </summary>
/// <returns>
///     If tracing was correctly initiated, <c>S_OK</c> is returned; otherwise, <c>E_NOT_STARTED</c> is returned.
/// </returns>
/**/
_CRTIMP HRESULT __cdecl EnableTracing();

/// <summary>
///     Disab