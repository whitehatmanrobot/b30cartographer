, hr );
            return hr;          
        }
        hr = hContentTask.Continue(); 
    }  
    while ( hr == XONLINETASK_S_RUNNING );
    
    if( SUCCEEDED( hr ) )
    {
        SetStatus( L"Verification Succeeded" );
        DisplayStatus( TRUE );
    }
    else
    {
        SetStatus( L"Verification Failed (error 0x%x)", hr );
    }
    
    
    return hr;
    
} 




//-----------------------------------------------------------------------------
// Name: RemoveContent
// Desc: Remove Downloaded Content
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RemoveContent()
{
    CXBOnlineTask hContentTask;
    
    XONLINEOFFERING_ID id = m_ContentList[ m_dwContentIndex ].GetId();
    
    SetStatus( L"Removing Content..." );
    DisplayStatus();
    
    // Initiate the removal the selected content
    HRESULT hr = XOnlineContentRemove( id, NULL,  &hContentTask );
    
    if( SUCCEEDED( hr ) )
    {
        do
        {
            hr = m_hLogonTask.Continue();
            if( FAILED( hr ) )
            {
                SetStatus( L"Connection was lost (error 0x%x)", hr );
                return hr;          
            }
            hr = hContentTask.Continue(); 
        }  
        while ( hr == XONLINETASK_S_RUNNING );
        
        if( SUCCEEDED( hr ) )
        {
            SetStatus( L"Removal Succeeded" );
            DisplayStatus( TRUE );
        }
    }
    else
    {
        SetStatus( L"Content Removal Failed (error 0x%x)", hr );
    }
    
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    HRESULT hr;
    
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }
    
    
    if(m_bIsDone)
    {
        // If we are logged on, pump the task
        if( m_hLogonTask.IsOpen() )
        {           
            
            hr = m_hLogonTask.Continue();
            if( FAILED( hr ) )
            {
                SetStatus( L"Connection was lost (0x%x)", hr );
            }
            
        }
        
        return S_OK;
    }
    
    hr = Logon();
    
    if( SUCCEEDED( hr ) )
    {
        hr = EnumerateContent();
    }
    
    if( SUCCEEDED( hr ) )
    {
        hr = DownloadContent();
    }
    
    if( SUCCEEDED( hr ) )
    {
        hr = VerifyContent();
    }
    
    if( SUCCEEDED( hr ) )
    {
        hr = RemoveContent();
    }
    
    if( FAILED( hr ) )
    {
        // clean up
        m_hLogonTask.Close();
    }
    
    // Toggle flag so that we don't attempt another logon
    m_bIsDone = TRUE;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, 
        D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    m_Font.Begin();
    m_Font.DrawText(  64, 50, CXBOnlineUI::COLOR_NORMAL, 
        L"SimpleContentDownload" );
    m_Font.DrawText( 450, 50, CXBOnlineUI::COLOR_HIGHLIGHT, m_strFrameRate );
    m_Font.DrawText(  64, 80, CXBOnlineUI::COLOR_NORMAL, 
        m_strStatus );
    m_Font.End();
    
    // draw help
    if(m_bDrawHelp)
    {
        m_Help.Render(&m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS);
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\twowayvoice\TwoWayVoice.cpp ===
//-----------------------------------------------------------------------------
// File: TwoWayVoice.cpp
//
// Desc: Extends the WinsockPeer sample to allow
//       simple communication between two people on
//       two separate Xboxes using Xbox communicators
//
// Hist: 08.11.01 - New for August M1 Online XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "TwoWayVoice.h"

const WORD  BROADCAST_PORT    = 10983;  // could be any port
const WORD  DIRECT_PORT       = 10984;  // any port other than BROADCAST_PORT

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
: 
    CXBApplication(),
    m_xprResource (),
    m_ptMenuSel   ( NULL ),
    m_hLogFile    ( INVALID_HANDLE_VALUE ),
    m_Font        (),
    m_Help        (),
    m_State       ( STATE_MENU ),
    m_LastState   ( STATE_MENU ),
    m_CurrItem    ( 0 ),
    m_GameNames   (),
    m_Games       (),
    m_Players     (),
    m_strError    (),
    m_strStatus   (),
    m_LinkStatusTimer     ( FALSE ),
    m_GameSearchTimer     ( FALSE ),
    m_GameJoinTimer       ( FALSE ),
    m_HeartbeatTimer      ( FALSE ),
    m_bIsOnline           ( FALSE ),
    m_bXnetStarted        ( FALSE ),
    m_bIsHost             ( FALSE ),
    m_bIsSessionRegistered( FALSE ),
    m_bHaveLocalAddress   ( FALSE ),
    m_xnHostKeyID         (),
    m_xnHostKeyExchange   (),
    m_xnTitleAddress      (),
    m_inHostAddr          (),
    m_BroadSock           (),
    m_DirectSock          (),
    m_strGameName         (),
    m_strPlayerName       (),
    m_strHostName         (),
    m_Nonce               (),
    m_pVoiceUnit          (NULL),
    m_hVoiceThread        (NULL),
    m_dwVoiceThreadId     (0),
    m_hVoiceDeleteEvent   (NULL)
{
    srand( GetTickCount() ); // for generating game/player names

    Init();
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our textures
    if( FAILED( m_xprResource.Create( g_pd3dDevice, "Resource.xpr", 
                                      Resource_NUM_RESOURCES ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load textures\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Set up texture ptrs
    m_ptMenuSel = m_xprResource.GetTexture( Resource_MenuSelect_OFFSET );

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Set view position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 40.0f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // TCR 2-16 Lost Link
    // Check network status periodically
    if( !m_LinkStatusTimer.IsRunning() ||
        m_LinkStatusTimer.GetElapsedSeconds() > CHECK_LINK_STATUS )
    {
        m_LinkStatusTimer.StartZero();
        DWORD dwStatus = XNetGetEthernetLinkStatus();
        m_bIsOnline = ( dwStatus & XNET_ETHERNET_LINK_ACTIVE ) != 0;
    }

    Event ev = GetEvent();

    switch( m_State )
    {
        case STATE_MENU:            FrameMoveMenu( ev );        break;
        case STATE_GAME:            FrameMoveGame( ev );        break;
        case STATE_HELP:            FrameMoveHelp( ev );        break;
        case STATE_SELECT_NAME:     FrameMoveSelectName( ev );  break;
        case STATE_START_NEW_GAME:  FrameMoveStartGame( ev );   break;
        case STATE_GAME_SEARCH:     FrameMoveGameSearch( ev );  break;
        case STATE_SELECT_GAME:     FrameMoveSelectGame( ev );  break;
        case STATE_REQUEST_JOIN:    FrameMoveRequestJoin( ev ); break;
        case STATE_ERROR:           FrameMoveError( ev );       break;
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000A0A6A, 1.0f, 0L );

    switch( m_State )
    {
        case STATE_MENU:            RenderMenu();        break;
        case STATE_GAME:            RenderGame();        break;
        case STATE_HELP:            RenderHelp();        break;
        case STATE_SELECT_NAME:     RenderSelectName();  break;
        case STATE_START_NEW_GAME:  RenderStartGame();   break;
        case STATE_GAME_SEARCH:     RenderGameSearch();  break;
        case STATE_SELECT_GAME:     RenderSelectGame();  break;
        case STATE_REQUEST_JOIN:    RenderRequestJoin(); break;
        case STATE_ERROR:           RenderError();       break;
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent()
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }

    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;

    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;

    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
        return EV_LEFT;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        return EV_RIGHT;

    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveMenu()
// Desc: Animate menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveMenu( Event ev )
{
    switch( ev )
    {
        case EV_BUTTON_A:

            // Prepare networking
            switch( InitXNet() )
            {
                case Success:
                    break;
                case NotConnected:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"This Xbox is not connected to\n"
                                           L"a hub or another Xbox",
                                           MAX_ERROR_STR );
                    return;
                case InitFailed:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"Failure initializing network\n"
                                           L"connections", 
                                           MAX_ERROR_STR );
                    return;
                default: assert( FALSE ); break;
            }

            switch( m_CurrItem )
            {
                case MAIN_MENU_START_GAME:
                {    
                    assert( !m_bIsSessionRegistered );

                    // Create the session key ID and exchange key
                    INT iKeyCreated = XNetCreateKey( &m_xnHostKeyID, 
                                                     &m_xnHostKeyExchange );

                    // Register the session
                    INT iKeyRegistered = XNetRegisterKey( &m_xnHostKeyID, 
                                                          &m_xnHostKeyExchange );
                    if( iKeyCreated != NO_ERROR || iKeyRegistered != NO_ERROR )
                    {
                        m_State = STATE_ERROR;
                        lstrcpynW( m_strError, L"Unable to start game session",
                                   MAX_ERROR_STR );

                        if( iKeyCreated != NO_ERROR )
                            LogXNetError( "XNetCreateKey", iKeyCreated );
                        if( iKeyRegistered != NO_ERROR )
                            LogXNetError( "XNetRegisterKey", iKeyRegistered );

                        break;
                    }

                    m_bIsSessionRegistered = TRUE;

                    // We're the host
                    m_bIsHost = TRUE;

                    // TCR 3-58 Naming of Game Sessions
                    // Build a list of potential game names
                    assert( m_GameNames.empty() );
                    for( DWORD i = 0; i < MAX_GAME_NAMES; ++i )
                    {
                        WCHAR strGameName[ MAX_GAME_NAME ];
                        GenRandom( strGameName, MAX_GAME_NAME );
                        m_GameNames.push_back( strGameName );
                    }

                    // Start at the top of the list
                    m_CurrItem = 0;

                    m_State = STATE_SELECT_NAME;
                    break;
                }
                case MAIN_MENU_JOIN_GAME:

                    // Begin searching for games on the network
                    SendFindGame();
                    m_GameSearchTimer.StartZero();
                    m_State = STATE_GAME_SEARCH;

                    break;
            }
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = MAIN_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == MAIN_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGame()
// Desc: Animate game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGame( Event ev )
{
    if( !m_bIsOnline )
    {
        // TCR 2-16 Lost Link
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"This Xbox has lost its System Link connection",
                               MAX_ERROR_STR );
        return;
    }

    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Send keep-alives
    if( m_HeartbeatTimer.GetElapsedSeconds() > PLAYER_HEARTBEAT )
    {
        Heartbeat();
        m_HeartbeatTimer.StartZero();
    }

    // Handle other players dropping
    if( ProcessPlayerDropouts() )
        return;

    switch( ev )
    {
        case EV_BUTTON_A:
            switch( m_CurrItem )
            {
                case GAME_MENU_WAVE:
                    Wave();
                    break;
                case GAME_MENU_VOICE:
                    StartVoiceProcessing();
                    break;
                case GAME_MENU_LEAVE_GAME:
                    Init();
                    break;
            }
            break;
        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = GAME_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == GAME_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveHelp()
// Desc: Animate help
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveHelp( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    if( ev != EV_NULL )
        m_State = m_LastState;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectName()
// Desc: Animate game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectName( Event ev )
{
    // TCR 3-58 Naming of Game Sessions

    // Allow the player to cancel out of game name selection
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:

            // Use the selected namne
            lstrcpyW( m_strGameName, m_GameNames[ m_CurrItem ].c_str() );

            // Destroy the name list; we don't need it anymore
            m_GameNames.clear();

            // Set the default game item to "wave"
            m_CurrItem = 0;

            // Display when game begins
            lstrcpynW( m_strStatus, L"Game started", MAX_STATUS_STR );

            // If we have the local address, begin the game.
            // Otherwise, acquire the local address.
            if( m_bHaveLocalAddress )
            {
                m_State = STATE_GAME;
                m_HeartbeatTimer.StartZero();
            }
            else
                m_State = STATE_START_NEW_GAME;
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_GameNames.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_GameNames.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveStartGame()
// Desc: Animate start game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveStartGame( Event ev )
{
    // Allow the player to cancel out of game startup
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // Asynchronous local address acquisition
    DWORD dwStatus = XNetGetTitleXnAddr( &m_xnTitleAddress );
    assert( dwStatus != XNET_GET_XNADDR_NONE );

    // If we've retrieved the local address, we're done
    m_bHaveLocalAddress = ( dwStatus != XNET_GET_XNADDR_PENDING );

    // When startup is complete, enter the game
    if( m_bHaveLocalAddress )
    {   
        m_HeartbeatTimer.StartZero();
        m_State = STATE_GAME;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGameSearch()
// Desc: Animate game search
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGameSearch( Event ev )
{
    // Allow the player to cancel out of game search
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // See if any games have replied
    if( ProcessBroadcastMessage() )
        return;

    // We search for up to GAME_SEARCH_TIME seconds. If the game 
    // search is complete, display the list of available games. If no games
    // were found, display an error message
    if( m_GameSearchTimer.GetElapsedSeconds() > GAME_SEARCH_TIME )
    {
        m_GameSearchTimer.Stop();
        if( m_Games.empty() )
        {
            m_State = STATE_ERROR;
            lstrcpynW( m_strError, L"No games available", MAX_ERROR_STR );
        }
        else if( m_Games.size() == 1 )
        {
            // TCR 3-57 Default Choices for System Link Play
            // One game; join automatically
            InitiateJoin( 0 );
        }
        else // at least two games
        {
            // at least two games; allow player selection
            m_State = STATE_SELECT_GAME;
            m_CurrItem = 0;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectGame()
// Desc: Animate game selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectGame( Event ev )
{
    if( !m_bIsOnline )
    {
        // TCR 2-16 Lost Link
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"This Xbox has lost its System Link connection",
                               MAX_ERROR_STR );
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:
            InitiateJoin( m_CurrItem );
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_Games.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_Games.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveRequestJoin()
// Desc: Animate join request
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveRequestJoin( Event ev )
{
    // Allow the player to cancel out of join request
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // See if the game has replied
    ProcessDirectMessage();

    // We wait for up to GAME_JOIN_TIME seconds. If the game didn't
    // respond, display an error message
    if( m_GameJoinTimer.GetElapsedSeconds() > GAME_JOIN_TIME )
    {
        m_GameJoinTimer.Stop();
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Game did not respond", MAX_ERROR_STR );
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveError()
// Desc: Animate error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveError( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Any button exits
    if( ev != EV_NULL )
        Init();
}





//-----------------------------------------------------------------------------
// Name: RenderMenu()
// Desc: Display menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenu()
{
    RenderHeader();

    const WCHAR* const strMenu[] =
    {
        L"Start New Game",
        L"Join Existing Game",
    };

    FLOAT fYtop = 200.0f;
    FLOAT fYdelta = 50.0f;

    // TCR 3-44 System Link Play Menu Option
    for( DWORD i = 0; i < MAIN_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i && m_bIsOnline ) ? COLOR_HIGHLIGHT : 
                                                             COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    if( m_bIsOnline )
        RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );

    m_Font.DrawText( 320, 400, COLOR_NORMAL, m_bIsOnline ? 
                     L"System Link Connected" :
                     L"System Link NOT Connected", XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderGame()
// Desc: Display game
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGame()
{
    RenderHeader();

    // Game name and player name
    WCHAR strGameInfo[ 32 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
    wsprintfW( strGameInfo, L"Game name: %.*s\nYour name: %.*s", 
               MAX_GAME_NAME, m_strGameName, MAX_PLAYER_NAME, m_strPlayerName );
    m_Font.DrawText( 220, 110, COLOR_GREEN, strGameInfo );

    // Number of players and current status
    wsprintfW( strGameInfo, L"Players in game: %lu", m_Players.size() + 1 );
    m_Font.DrawText( 220, 158, COLOR_GREEN, strGameInfo );
    m_Font.DrawText( 220, 184, COLOR_GREEN, m_strStatus );

    // Game options menu
    const WCHAR* const strMenu[] =
    {
        L"Wave To Other Players",
		    L"Voice",
        L"Leave Game",
    };

    FLOAT fYtop = 240.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( DWORD i = 0; i < GAME_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderHelp()
// Desc: Display help
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHelp()
{
    XBHELP_CALLOUT HelpCallouts[] =
    {
        { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
        { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Select menu\nitem" },
        { XBHELP_B_BUTTON, XBHELP_PLACEMENT_1, L"Cancel" },
        { XBHELP_DPAD, XBHELP_PLACEMENT_1, L"Menu navigation" },
    };
    m_Help.Render( &m_Font, HelpCallouts, 4 );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectName()
// Desc: Display game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectName()
{
    assert( !m_GameNames.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select a game name\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;

    // Show list of game names
    for( DWORD i = 0; i < m_GameNames.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 280, fYtop + (fYdelta * i), dwColor, 
                         m_GameNames[i].c_str() );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 240.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderStartGame()
// Desc: Display game startup sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderStartGame()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Starting Game\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderGameSearch()
// Desc: Display game search sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGameSearch()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Searching For Active Games\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectGame()
// Desc: Display list of available games
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectGame()
{
    assert( !m_Games.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select game to join\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 50.0f;

    // Show list of games
    for( DWORD i = 0; i < m_Games.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        WCHAR strGameInfo[ 64 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
        wsprintfW( strGameInfo, L"\"%.*s\" hosted by \"%.*s\"; players: %d",
                   MAX_GAME_NAME, m_Games[i].strGameName,
                   MAX_PLAYER_NAME, m_Games[i].strHostName,
                   INT(m_Games[i].byNumPlayers) );

        // Denote full games
        if( m_Games[i].byNumPlayers == MAX_PLAYERS )
            lstrcatW( strGameInfo, L" (full)" );

        m_Font.DrawText( 140, fYtop + (fYdelta * i), dwColor, strGameInfo );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 100.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderRequestJoin()
// Desc: Display join request sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderRequestJoin()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Joining game", 
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderError()
{
    RenderHeader();
    m_Font.DrawText( 320, 200, 0xffffffff, m_strError, XBFONT_CENTER_X );
    m_Font.DrawText( 320, 260, 0xffffffff, L"Press A to continue", 
                     XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderHeader()
// Desc: Display standard text
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHeader()
{
    WCHAR strName[32];
    lstrcpyW( strName, L"TwoWayVoice" );
    if( m_bIsHost )
        lstrcatW( strName, L" (host)" );

    m_Font.DrawText(  64, 50, 0xffffffff, strName );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
}




//-----------------------------------------------------------------------------
// Name: RenderMenuSelector()
// Desc: Display menu selector
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenuSelector( FLOAT fLeft, FLOAT fTop )
{
    D3DXVECTOR4 rc( fLeft, fTop, fLeft + 20.0f, fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: InitiateJoin()
// Desc: Send a join request to the specified game
//-----------------------------------------------------------------------------
VOID CXBoxSample::InitiateJoin( DWORD iCurrGame )
{
    // Determine which game the player wants to join
    GameInfo gameInfo = m_Games[ iCurrGame ];

    // Establish a session with the host game
    INT iResult = XNetRegisterKey( &gameInfo.xnHostKeyID, 
                                   &gameInfo.xnHostKey );
    assert( iResult == NO_ERROR );
    if( iResult == NO_ERROR )
    {
        assert( m_bIsSessionRegistered == FALSE );
        m_bIsSessionRegistered = TRUE;

        // Save the key ID because we need to unregister it
        // Note that we don't need the key itself once it's been registered.
        CopyMemory( &m_xnHostKeyID, &gameInfo.xnHostKeyID, sizeof( XNKID ) );

        // Save the game and player name of the host
        lstrcpynW( m_strGameName, gameInfo.strGameName, MAX_GAME_NAME );
        lstrcpynW( m_strHostName, gameInfo.strHostName, MAX_PLAYER_NAME );

        // Convert the XNADDR of the host to the INADDR we'll use to
        // join the game
        iResult = XNetXnAddrToInAddr( &gameInfo.xnHostAddr,
                                      &m_xnHostKeyID, &m_inHostAddr );
        assert( iResult == NO_ERROR );

        // Request join approval from the game and await a response
        SendJoinGame( CXBSockAddr( m_inHostAddr, DIRECT_PORT ) );
        m_GameJoinTimer.StartZero();
        m_State = STATE_REQUEST_JOIN;
    }
    else
    {
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Unable to establish session with game",
                   MAX_ERROR_STR );
        LogXNetError( "XNetRegisterKey", iResult );
    }

    // Don't need the game list anymore
    DestroyGameList();
}




//-----------------------------------------------------------------------------
// Name: Wave()
// Desc: Wave to other players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Wave()
{
    // Indicate that you waved
    lstrcpynW( m_strStatus, L"You waved", MAX_STATUS_STR );

    // Send a "wave" message to each of the other players in the game
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendWave( CXBSockAddr( i->inAddr, DIRECT_PORT ) );

}




//-----------------------------------------------------------------------------
// Name: FindHeadsetPort()
// Desc: Returns the controller port of the first hawk device found
//-----------------------------------------------------------------------------
int CXBoxSample::FindHeadsetPort()
{
    DWORD dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    DWORD dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);

    if(dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("CXBoxSample::Voice()...dwConnectedMicrophones != dwConnectedHeadphone\n");
        return -1;
    }

    if(!dwConnectedMicrophones || !dwConnectedHeadphones)
    {
        DebugPrint("CXBoxSample::FindHeadsetPort()... No hawk found!\n");
        return -1;
    }

    // Go through each port and see if there's a headset on it
    for(int i = 0; i < XGetPortCount(); ++i)
    {
        if(dwConnectedMicrophones & (1 << i))
        {
            return i;
        }
    }

    return -1;
}




//-----------------------------------------------------------------------------
// Name: StartVoiceProcessing()
// Desc: Enables voice chat
//-----------------------------------------------------------------------------
VOID CXBoxSample::StartVoiceProcessing()
{
    // Initialize the headset
    // Note that, in this sample, MAX_PLAYERS = 2,
    // so use the first connected player (not myself)
    // or don't initialize at all if there are no other players.
    if(NULL == m_pVoiceUnit && m_Players.size() > 0 && !m_hVoiceThread)
    {
        int iPortNum = FindHeadsetPort();

        if(iPortNum >= 0)
        {
            m_pVoiceUnit = new CNetVoiceUnit;
            m_pVoiceUnit->Init(iPortNum);
            if(SUCCEEDED(m_pVoiceUnit->Inserted()))
            {
                m_pVoiceUnit->SetSockAddr(CXBSockAddr(m_Players[0].inAddr, VOICE_PORT).GetInAddr());

                m_hVoiceThread = CreateThread(NULL, 0, StaticVoiceThreadProc, this, 0, &m_dwVoiceThreadId);
                if(!m_hVoiceThread)
                {
                    DebugPrint("CXBoxSample::StartVoiceProcessing()... Thread creation failed\n");
                    lstrcpynW(m_strStatus, L"Error initializing voice processing\n", MAX_STATUS_STR);
                    delete m_pVoiceUnit;
                    m_pVoiceUnit = NULL;
                }
                else
                {
                    lstrcpynW(m_strStatus, L"Voice chat enabled!", MAX_STATUS_STR);
                }
            }
            else
            {
                DebugPrint("CXBoxSample::Voice()... Init() did not succeed!\n");
                lstrcpynW(m_strStatus, L"Error initializing headset!\n", MAX_STATUS_STR);
                delete m_pVoiceUnit;
                m_pVoiceUnit = NULL;
            }
        }
        else
        {
            lstrcpynW(m_strStatus, L"No communicator headset found!\n", MAX_STATUS_STR);
        }
    }
}




//-----------------------------------------------------------------------------
// Name: KillVoiceProcessing()
// Desc: Kills the voice processing thread and does some cleanup
//-----------------------------------------------------------------------------
VOID CXBoxSample::KillVoiceProcessing()
{
    if(m_hVoiceDeleteEvent)
    {
        SetEvent(m_hVoiceDeleteEvent);
    }

    if(m_hVoiceThread)
    {
        WaitForSingleObject(m_hVoiceThread, INFINITE);
        CloseHandle(m_hVoiceThread);
        m_hVoiceThread = NULL;
    }

    assert(m_dwVoiceThreadId == 0);

    if(NULL != m_pVoiceUnit)
    {
	      delete m_pVoiceUnit;
	      m_pVoiceUnit = NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: StaticVoiceThreadProc()
// Desc: "Bootstrap" for the voice processing thread
//-----------------------------------------------------------------------------
DWORD WINAPI CXBoxSample::StaticVoiceThreadProc(LPVOID pParameter)
{
    CXBoxSample *pThis = (CXBoxSample *)pParameter;
    return pThis->VoiceThreadProc();
}



//-----------------------------------------------------------------------------
// Name: VoiceThreadProc()
// Desc: Voice processing thread's main function
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::VoiceThreadProc()
{
    int iPortNum;

    DebugPrint("CXBoxSample::VoiceThreadProc()...Built on %s at %s\n", __DATE__, __TIME__);

    while(TRUE)
    {
        // Check for device removal/insertion
        iPortNum = FindHeadsetPort();

        if(iPortNum == -1)
        {
          DebugPrint("CXBoxSample::VoiceThreadProc()... Communicator was removed; Exiting Thread\n");
          break;
        }

        if(iPortNum != m_pVoiceUnit->GetPortNumber())
        {
            m_pVoiceUnit->Removed();
            m_pVoiceUnit->Init(iPortNum);
            m_pVoiceUnit->Inserted();
        }

        // Process some voice data (if there is any)
        m_pVoiceUnit->Process();

        // Check if the parent wants us to quit voice processing
        // Wait at most 16 ms (about one frame)

        DebugPrint("CXBoxSample::VoiceThreadProc()... Waiting for Delete Event");
        DWORD dwReason = WaitForSingleObject(m_hVoiceDeleteEvent, 16);
        if(WAIT_OBJECT_0 == dwReason)
        {
            DebugPrint("CXBoxSample::VoiceThreadProc()... Exiting Thread\n");
            break;
        }
    }

    m_dwVoiceThreadId = 0;
    ExitThread(0);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Heartbeat()
// Desc: Send heartbeat to players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Heartbeat()
{
    // Send a "heartbeat" message to each of the other players in the game
    // to let them know we're alive
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendHeartbeat( CXBSockAddr( i->inAddr, DIRECT_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Teardown any active games and player lists and return to main menu
//       Unregisters any active sessions.
//-----------------------------------------------------------------------------
VOID CXBoxSample::Init()
{
    // Don't clear m_bXnetStarted. We don't need to reinitialize Xnet once
    // it's been started.

    // Don't clear m_bHaveLocalAddress or m_xnTitleAddress. We don't need to 
    // reacquire the address once we have it.

    m_State     = STATE_MENU;
    m_LastState = STATE_MENU;
    m_CurrItem  = 0;

    m_GameNames.clear();
    DestroyGameList();
    DestroyPlayerList();

    *m_strError = 0;
    *m_strStatus = 0;

    m_LinkStatusTimer.Stop();
    m_GameSearchTimer.Stop();
    m_GameJoinTimer.Stop();
    m_HeartbeatTimer.Stop();

    m_bIsHost = FALSE;

    // Unregister the game session key
    if( m_bIsSessionRegistered )
    {
        INT iResult = XNetUnregisterKey( &m_xnHostKeyID );
        assert( iResult == NO_ERROR );
        (VOID)iResult;
        m_bIsSessionRegistered = FALSE;
    }

    // Obliterate old keys and XNADDR
    ZeroMemory( &m_xnHostKeyID,       sizeof( XNKID ) );
    ZeroMemory( &m_xnHostKeyExchange, sizeof( XNKEY ) );
    m_inHostAddr.s_addr = 0;

    // Close down the sockets
    m_BroadSock.Close();
    m_DirectSock.Close();

    *m_strGameName   = 0;
    *m_strPlayerName = 0;
    *m_strHostName   = 0;

    ZeroMemory( &m_Nonce, sizeof(m_Nonce) );

    // Initialize synchronization stuff
    m_hVoiceDeleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Generate random player name
    // A real Xbox game would get this information from the player
    GenRandom( m_strPlayerName, MAX_PLAYER_NAME );
}




//-----------------------------------------------------------------------------
// Name: InitXNet()
// Desc: Initialize the network stack. Returns FALSE if Xbox is not connected.
//-----------------------------------------------------------------------------
CXBoxSample::InitStatus CXBoxSample::InitXNet()
{
    if( !m_bIsOnline )
        return NotConnected;

    // Only need to initialize network stack one time
    if( !m_bXnetStarted )
    {
        // Initialize network stack
        INT iResult = XNetStartup( NULL );
        if( iResult != NO_ERROR )
        {
            LogXNetError( "XNetStartup", iResult );
            return InitFailed;
        }

        // Standard WinSock startup
        WSADATA WsaData;
        iResult = WSAStartup( MAKEWORD(2,2), &WsaData );
        if( iResult != NO_ERROR )
        {
            LogXNetError( "WSAStartup", iResult );
            return InitFailed;
        }

        m_bXnetStarted = TRUE;
    }

    // The broadcast socket is a non-blocking socket on port BROADCAST_PORT.
    // All broadcast messages are automatically always encrypted.
    BOOL bSuccess = m_BroadSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Broadcast socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr broadAddr( INADDR_ANY, BROADCAST_PORT );
    INT iResult = m_BroadSock.Bind( broadAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    DWORD dwNonBlocking = 1;
    iResult = m_BroadSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );
    BOOL bBroadcast = TRUE;
    iResult = m_BroadSock.SetSockOpt( SOL_SOCKET, SO_BROADCAST,
                                      &bBroadcast, sizeof(bBroadcast) );
    assert( iResult != SOCKET_ERROR );

    // The direct socket is a non-blocking socket on port DIRECT_PORT.
    // Sockets are encrypted by default, but can have encryption disabled
    // as an optimization for non-secure messaging
    bSuccess = m_DirectSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Direct socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr directAddr( INADDR_ANY, DIRECT_PORT );
    iResult = m_DirectSock.Bind( directAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    iResult = m_DirectSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );

    // Note that this sample does not call either WSACleanup() or 
    // XNetCleanup(). These functions should be called by your game to
    // free system resources when the player is no longer online but
    // is still playing the game (e.g. switched to single-player mode).

    return Success;
}




//-----------------------------------------------------------------------------
// Name: SendFindGame()
// Desc: Broadcast a MSG_FIND_GAME from our client to any available host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendFindGame()
{
    assert( !m_bIsHost );
    Message msgFindGame( MSG_FIND_GAME );
    MsgFindGame& msg = msgFindGame.GetFindGame();

    // Generate a nonce (random bytes). When a potential host responds with
    // information about a game, he must respond via a broadcast message
    // since a secure session hasn't been established. The broadcast message
    // will contain the same nonce so we can verify that message is really
    // for us. If we receive a broadcast "found game" message with a different
    // nonce, we ignore it, because it was broadcast to a different client
    // than us.
    INT iResult = XNetRandom( (BYTE*)(&msg.nonce), sizeof(msg.nonce) );
    assert( iResult == NO_ERROR );
    (VOID)iResult;

    // Save the nonce for comparison later
    CopyMemory( &m_Nonce, &msg.nonce, sizeof(msg.nonce) );

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgFindGame, msgFindGame.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgFindGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendGameFound()
// Desc: Broadcast a MSG_GAME_FOUND from our host to the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendGameFound( const Nonce& nonceClient )
{
    assert( m_bIsHost );
    Message msgGameFound( MSG_GAME_FOUND );
    MsgGameFound& msg = msgGameFound.GetGameFound();

    // Resend the nonce that we received from the client so he can verify
    // that this message is really for him
    CopyMemory( &msg.nonce, &nonceClient, sizeof(nonceClient) );

    // Send information about the session that we're hosting
    CopyMemory( &msg.xnHostKeyID, &m_xnHostKeyID,       sizeof(XNKID) );
    CopyMemory( &msg.xnHostKey,   &m_xnHostKeyExchange, sizeof(XNKEY) );
    CopyMemory( &msg.xnHostAddr,  &m_xnTitleAddress,    sizeof(XNADDR) );

    // Send the current information about the game
    msg.byNumPlayers = BYTE( m_Players.size() + 1 );
    lstrcpynW( msg.strGameName, m_strGameName, MAX_GAME_NAME );
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // We don't have the XNADDR of the requesting client, so we
    // can't send this message directly back. Instead, we broadcast the
    // message to everybody on the net. The requesting client can
    // check the nonce to verify that the response is really for them.
    // Broadcast messages are automatically encrypted.

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgGameFound, msgGameFound.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgGameFound.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinGame()
// Desc: Issue a MSG_JOIN_GAME from our client to the game host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinGame( const CXBSockAddr& saGameHost )
{
    assert( !m_bIsHost );
    Message msgJoinGame( MSG_JOIN_GAME );
    MsgJoinGame& msg = msgJoinGame.GetJoinGame();

    // Include our player name
    lstrcpynW( msg.strPlayerName, m_strPlayerName, MAX_PLAYER_NAME );

    // We can send this message directly to the host
    INT nBytes = m_DirectSock.SendTo( &msgJoinGame, msgJoinGame.GetSize(),
                                      saGameHost.GetPtr() );
    assert( nBytes == msgJoinGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinApproved()
// Desc: Issue a MSG_JOIN_APPROVED from our host to the requesting client.
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinApproved( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinApproved( MSG_JOIN_APPROVED );
    MsgJoinApproved& msg = msgJoinApproved.GetJoinApproved();

    // The host is us
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // Send the list of all the current players to the new player.
    // We don't send the host player info, since the new player 
    // already has all of the information it needs about the host player.
    msg.byNumPlayers = BYTE( m_Players.size() );
    BYTE j = 0;
    for( PlayerList::const_iterator i = m_Players.begin(); 
         i != m_Players.end(); ++i, ++j )
    {
        PlayerInfo playerInfo = *i;
        CopyMemory( &msg.PlayerList[j].xnAddr, &playerInfo.xnAddr, 
                    sizeof( XNADDR ) );
        lstrcpynW( msg.PlayerList[j].strPlayerName, 
                   playerInfo.strPlayerName, MAX_PLAYER_NAME );
    }

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinApproved, msgJoinApproved.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinApproved.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinDenied()
// Desc: Issue a MSG_JOIN_DENIED from our host to the requesting client
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinDenied( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinDenied( MSG_JOIN_DENIED );

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinDenied, msgJoinDenied.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinDenied.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendPlayerJoined()
// Desc: Issue a MSG_PLAYER_JOINED from our host to a player in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendPlayerJoined( const Player& player, const CXBSockAddr& saPlayer )
{
    assert( m_bIsHost );
    Message msgPlayerJoined( MSG_PLAYER_JOINED );
    MsgPlayerJoined& msg = msgPlayerJoined.GetPlayerJoined();

    // The payload is the information about the player who just joined
    CopyMemory( &msg.player, &player, sizeof(player) );

    // We send this message directly to the player
    INT nBytes = m_DirectSock.SendTo( &msgPlayerJoined, msgPlayerJoined.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgPlayerJoined.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Issue a MSG_WAVE from ourself (either a host or player) to another
//       player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendWave( const CXBSockAddr& saPlayer )
{
    Message msgWave( MSG_WAVE );
    INT nBytes = m_DirectSock.SendTo( &msgWave, msgWave.GetSize(), 
                                      saPlayer.GetPtr() );
    assert( nBytes == msgWave.GetSize() );
    (VOID)nBytes;
}


//-----------------------------------------------------------------------------
// Name: SendHeartbeat()
// Desc: Issue a MSG_HEARTBEAT from ourself (either a host or player) to
//       another player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendHeartbeat( const CXBSockAddr& saPlayer )
{
    Message msgHeartbeat( MSG_HEARTBEAT );

    // No need to encrypt this message, since it contains no information that
    // requires security. For optimization purposes, we turn off encryption
    // for this data.
    BOOL bEncrypt = FALSE;
    INT iResult = m_DirectSock.SetSockOpt( SOL_SOCKET, SO_ENCRYPT, 
                                           &bEncrypt, sizeof(bEncrypt) );
    assert( iResult != SOCKET_ERROR );
    (VOID)iResult;

    // Send the unencrypted heartbeat
    INT nBytes = m_DirectSock.SendTo( &msgHeartbeat, msgHeartbeat.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgHeartbeat.GetSize() );
    (VOID)nBytes;

    // Restore encryption on the socket for other messages
    bEncrypt = TRUE;
    iResult = m_DirectSock.SetSockOpt( SOL_SOCKET, SO_ENCRYPT,
                                       &bEncrypt, sizeof(bEncrypt) );
    assert( iResult != SOCKET_ERROR );
}




//-----------------------------------------------------------------------------
// Name: ProcessBroadcastMessage()
// Desc: Checks to see if any broadcast messages are waiting on the broadcast
//       socket. If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessBroadcastMessage()
{
    if( !m_BroadSock.IsOpen() )
        return FALSE;

    // See if a network broadcast message is waiting for us
    Message msg;
    INT iResult = m_BroadSock.Recv( &msg, msg.GetMaxSize() );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessDirectMessage()
// Desc: Checks to see if any direct messages are waiting on the direct socket.
//       If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessDirectMessage()
{
    if( !m_DirectSock.IsOpen() )
        return FALSE;

    // See if a network message is waiting for us
    Message msg;
    SOCKADDR_IN saFromIn;
    INT iResult = m_DirectSock.RecvFrom( &msg, msg.GetMaxSize(), &saFromIn );
    CXBSockAddr saFrom( saFromIn );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg, saFrom );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes broadcast messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_FIND_GAME:  ProcessFindGame( msg.GetFindGame() );   break;

        // From host to client: processed by client
        case MSG_GAME_FOUND: ProcessGameFound( msg.GetGameFound() ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes any direct messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg, const CXBSockAddr& saFrom )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_JOIN_GAME:     ProcessJoinGame( msg.GetJoinGame(), saFrom ); break;

        // From host to client: processed by client
        case MSG_JOIN_APPROVED: ProcessJoinApproved( msg.GetJoinApproved(), saFrom ); break;
        case MSG_JOIN_DENIED:   ProcessJoinDenied( saFrom ); break;
        case MSG_PLAYER_JOINED: ProcessPlayerJoined( msg.GetPlayerJoined(), saFrom ); break;

        // From player to player: processed by client player
        case MSG_WAVE:          ProcessWave( saFrom ); break;
        case MSG_HEARTBEAT:     ProcessHeartbeat( saFrom ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessFindGame()
// Desc: Process the find game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessFindGame( const MsgFindGame& findGame )
{
    // If we're not hosting a game, we don't care about receiving "find game"
    // messages. Only hosts respond to "find game" messages
    if( !m_bIsHost )
        return;

    // We're hosting a game
    // Respond with the game information
    SendGameFound( findGame.nonce );
}




//-----------------------------------------------------------------------------
// Name: ProcessGameFound()
// Desc: Process the game found message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessGameFound( const MsgGameFound& gameFound )
{
    // If we're hosting, we don't care about receiving "game found" messages.
    // Only potential clients care about "game found" messages.
    if( m_bIsHost )
        return;

    // If we didn't send the corresponding "find game" message, we don't
    // care about this particular "game found" message
    if( memcmp( &gameFound.nonce, &m_Nonce, NONCE_BYTES ) != 0 )
        return;

    // We found a game!
    // Add it to our list of potential games
    GameInfo gameInfo;
    CopyMemory( &gameInfo.xnHostKeyID, &gameFound.xnHostKeyID, sizeof( XNKID ) );
    CopyMemory( &gameInfo.xnHostKey,   &gameFound.xnHostKey,   sizeof( XNKEY ) );
    CopyMemory( &gameInfo.xnHostAddr,  &gameFound.xnHostAddr,  sizeof( XNADDR ) );
    gameInfo.byNumPlayers = gameFound.byNumPlayers;
    lstrcpynW( gameInfo.strGameName, gameFound.strGameName, MAX_GAME_NAME );
    lstrcpynW( gameInfo.strHostName, gameFound.strHostName, MAX_PLAYER_NAME );

    m_Games.push_back( gameInfo );
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinGame()
// Desc: Process the join game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinGame( const MsgJoinGame& joinGame,
                                   const CXBSockAddr& saFrom )
{
    // Only hosts should receive "join game" messages
    assert( m_bIsHost );

    // If for some reason we receive a "join game" message and we're not a
    // host, ignore it. Only hosts respond to "join game" messages
    if( !m_bIsHost )
        return;

    // We're hosting

    // A session exists between us (the host) and the client. We can now
    // convert the incoming IP address (saFrom) into a valid XNADDR.
    XNADDR xnAddrClient;
    INT iResult = XNetInAddrToXnAddr( saFrom.GetInAddr(), &xnAddrClient, 
                                      &m_xnHostKeyID );
    if( iResult == SOCKET_ERROR )
    {
        // If the client INADDR can't be converted to an XNADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetInAddrToXnAddr", iResult );
        assert( FALSE );
        return;
    }

    // A player may join if we haven't reached the player limit.
    // In a real game, you would need to "lock" the game during a join
    // or track the number of joins in progress so that if multiple
    // players were attempting to join at the same time, they wouldn't
    // all be granted access and then exceed the player maximum.
    if( m_Players.size() + 1 < MAX_PLAYERS )
    {
        SendJoinApproved( saFrom );

        // Notify the other players about the new guy
        Player player;
        CopyMemory( &player.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        lstrcpynW( player.strPlayerName, joinGame.strPlayerName, MAX_PLAYER_NAME );
        for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
            SendPlayerJoined( player, CXBSockAddr( i->inAddr, DIRECT_PORT ) );

        // Add this new player to our player list
        PlayerInfo playerInfo;
        CopyMemory( &playerInfo.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        playerInfo.inAddr = saFrom.GetInAddr();
        lstrcpynW( playerInfo.strPlayerName, joinGame.strPlayerName, 
                   MAX_PLAYER_NAME );
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );

        // Update status
        wsprintfW( m_strStatus, L"%.*s has joined the game", 
                   MAX_PLAYER_NAME, player.strPlayerName );
    }
    else
    {
        SendJoinDenied( saFrom );
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinApproved()
// Desc: Process the join approved message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinApproved( const MsgJoinApproved& joinApproved, 
                                       const CXBSockAddr& saFrom )
{
    // Only clients should receive "join approved" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join approved" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Add the host to the list of players (always at position 0 )
    PlayerInfo hostInfo;

    // Client doesn't need the XNADDR of the host, so we just leave it zero.
    // This data member is only used by hosts.
    ZeroMemory( &hostInfo.xnAddr, sizeof( XNADDR ) );
    hostInfo.inAddr = saFrom.GetInAddr();
    lstrcpynW( hostInfo.strPlayerName, joinApproved.strHostName, MAX_PLAYER_NAME );
    hostInfo.dwLastHeartbeat = GetTickCount();

    assert( m_Players.empty() );
    m_Players.push_back( hostInfo );

    // Build the list of the other players
    for( BYTE i = 0; i < joinApproved.byNumPlayers; ++i )
    {
        PlayerInfo playerInfo;

        // Convert the XNADDR of the player to the INADDR we'll use to wave
        // to the player
        INT iResult = XNetXnAddrToInAddr( &joinApproved.PlayerList[ i ].xnAddr,
                                          &m_xnHostKeyID, &playerInfo.inAddr );
        if( iResult == SOCKET_ERROR )
        {
            // If the client XNADDR can't be converted to an INADDR, then
            // the client does not have a valid session established, and
            // we ignore that client.
            assert( FALSE );
            LogXNetError( "XNetXnAddrToInAddr", iResult );
            continue;
        }

        // Client doesn't need the XNADDR of the host anymore, 
        // so we just leave it zero. This data member is only used by hosts.
        ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

        // Save the player name
        lstrcpynW( playerInfo.strPlayerName, 
                   joinApproved.PlayerList[ i ].strPlayerName, MAX_PLAYER_NAME );

        // Last heartbeat
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );
    }

    // Enter into the game UI
    m_State = STATE_GAME;

    // Set the default game item to "wave"
    m_CurrItem = 0;

    lstrcpynW( m_strStatus, L"You have joined the game", MAX_STATUS_STR );
    m_HeartbeatTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinDenied()
// Desc: Process the join denied message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinDenied( const CXBSockAddr& )
{
    // Only clients should receive "join denied" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join denied" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Only clients who are not currently playing should receive this message
    assert( m_State != STATE_GAME );

    // If for some reason we receive a "join denied" message and we're
    // already playing a game, ignore the message.
    if( m_State == STATE_GAME )
        return;

    // The game we wanted to join is full. Display error
    m_State = STATE_ERROR;
    lstrcpynW( m_strError, L"The game is full.\nChoose another game.",
               MAX_ERROR_STR );
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayerJoined()
// Desc: Process the player joined message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessPlayerJoined( const MsgPlayerJoined& playerJoined, 
                                       const CXBSockAddr& saFrom )
{
    // saFrom is the address of the host that sent this message, but we
    // we already have his address, so throw it away
    (VOID)saFrom;

    const Player& player = playerJoined.player;
    PlayerInfo playerInfo;

    // Convert the XNADDR of the player to the INADDR we'll use to wave
    // to the player
    INT iResult = XNetXnAddrToInAddr( &player.xnAddr, &m_xnHostKeyID,
                                      &playerInfo.inAddr );
    if( iResult == SOCKET_ERROR )
    {
        // If the client XNADDR can't be converted to an INADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetXnAddrToInAddr", iResult );
        assert( FALSE );
        return;
    }

    // Client doesn't need the XNADDR of the host anymore, 
    // so we just leave it zero. This data member is only used by hosts.
    ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

    // Save the player name
    lstrcpynW( playerInfo.strPlayerName, player.strPlayerName, MAX_PLAYER_NAME );

    // Last heartbeat
    playerInfo.dwLastHeartbeat = GetTickCount();

    // Add the new player to our list
    m_Players.push_back( playerInfo );

    // Update status
    wsprintfW( m_strStatus, L"%.*s has joined the game", 
               MAX_PLAYER_NAME, player.strPlayerName );
}




//-----------------------------------------------------------------------------
// Name: ProcessWave()
// Desc: Process the wave message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessWave( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who waved by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update status
    if( i != m_Players.end() )
    {
        wsprintfW( m_strStatus, L"%.*s waved", 
                   MAX_PLAYER_NAME, i->strPlayerName );
    }
}


//-----------------------------------------------------------------------------
// Name: ProcessHeartbeat()
// Desc: Process the heartbeat message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessHeartbeat( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who sent a heartbeat by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update that player's heartbeat time
    if( i != m_Players.end() )
        i->dwLastHeartbeat = GetTickCount();
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayersDropouts()
// Desc: Process players and determine if anybody has left the game
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessPlayerDropouts()
{
    DWORD dwTickCount = GetTickCount();
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
    {
        PlayerInfo playerInfo = *i;
        DWORD dwElapsed = dwTickCount - playerInfo.dwLastHeartbeat;
        if( dwElapsed > PLAYER_TIMEOUT )
        {
            // This player hasn't sent a heartbeat message in a long time.
            // Assume they left the game.

            wsprintfW( m_strStatus, L"%.*s left the game", 
                       MAX_PLAYER_NAME, playerInfo.strPlayerName );

            // Delete the player from the list
            m_Players.erase( i );

            //
            // Delete Voice units if you chatted.  Note that
            // since MAX_PLAYERS = 2, we can take the luxury of
            // stopping all voice processing.  In a more complex
            // scenario (with multiple players), one would have disable
            // voice processing only for those players that dropped out
            //
            KillVoiceProcessing();
            return TRUE;
        }
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: DestroyGameList()
// Desc: Clear the list of games
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyGameList()
{
    // Physically clear the list of games to obliterate the key and XNADDR info
    // from prying eyes. This particular method works because m_Games 
    // is a vector; if m_Games is not a vector each game must be 
    // cleared individually
    if( !m_Games.empty() )
    {
        GameInfo* pGameList = &m_Games[0];
        ZeroMemory( pGameList, m_Games.size() * sizeof( GameInfo ) );

        // Destroy the list of games
        m_Games.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: DestroyPlayerList()
// Desc: Clear the list of players
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyPlayerList()
{
    // Physically clear the list of players to obliterate the XNADDR info
    // from prying eyes. This particular method works because m_Players
    // is a vector; if m_Players is not a vector each player must be 
    // cleared individually
    if( !m_Players.empty() )
    {
        PlayerInfo* pPlayerList = &m_Players[0];
        ZeroMemory( pPlayerList, m_Players.size() * sizeof( PlayerInfo ) );

        // Destroy the list of players
        m_Players.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: GenRandom()
// Desc: Generate a random name
//-----------------------------------------------------------------------------
VOID CXBoxSample::GenRandom( WCHAR* strName, DWORD dwSize ) // static
{
    // Name consists of two to five parts.
    //
    // 1) consonant or consonant group (e.g. th, qu, st) [optional]
    // 2) vowel or vowel group (e.g. ea, ee, au)
    // 3) consonant or consonant group
    // 4) vowel or vowel group [optional]
    // 5) consonant or consonant group [optional]

    WCHAR strRandom[ 128 ];
    strRandom[ 0 ] = 0;
    if( ( rand() % 2 == 0 ) )
        AppendConsonant( strRandom, TRUE );
    AppendVowel( strRandom );
    AppendConsonant( strRandom, FALSE );
    if( ( rand() % 2 == 0 ) )
    {
        AppendVowel( strRandom );
        if( ( rand() % 2 == 0 ) )
            AppendConsonant( strRandom, FALSE );
    }

    *strRandom = towupper( *strRandom );
    lstrcpynW( strName, strRandom, dwSize );
}




//-----------------------------------------------------------------------------
// Name: GetRandVowel()
// Desc: Get a random vowel
//-----------------------------------------------------------------------------
WCHAR CXBoxSample::GetRandVowel() // static
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( rand() % 26 ) );
        if( wcschr( L"aeiou", c ) != NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: GetRandConsonant()
// Desc: Get a random consonant
//-----------------------------------------------------------------------------
WCHAR CXBoxSample::GetRandConsonant() // static
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( rand() % 26 ) );
        if( wcschr( L"aeiou", c ) == NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: AppendConsonant()
// Desc: Append consonant or consonant group to string
//-----------------------------------------------------------------------------
VOID CXBoxSample::AppendConsonant( WCHAR* strRandom, BOOL bLeading ) // static
{
    if( ( rand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandConsonant(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strLeadConGroup[32] = 
        {
            L"bl", L"br", L"cl", L"cr", L"dr", L"fl", L"fr", L"gh", L"gl", L"gn", 
            L"gr", L"kl", L"kn", L"kr", L"ph", L"pl", L"pr", L"ps", L"qu", L"sc", 
            L"sk", L"sl", L"sn", L"sp", L"st", L"sw", L"th", L"tr", L"vh", L"vl", 
            L"wh", L"zh"
        };
        WCHAR* strTrailConGroup[32] = 
        {
            L"rt", L"ng", L"bs", L"cs", L"ds", L"gs", L"hs", L"sh", L"ss", L"ks",
            L"ms", L"ns", L"ps", L"rs", L"ts", L"gh", L"ph", L"sk", L"st", L"tt",
            L"nd", L"nk", L"nt", L"nx", L"pp", L"rd", L"rg", L"rk", L"rn", L"rv",
            L"th", L"ys"
        };
        if( bLeading )
            lstrcatW( strRandom, strLeadConGroup[ rand() % 32 ] );
        else
            lstrcatW( strRandom, strTrailConGroup[ rand() % 32 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: AppendVowel()
// Desc: Append vowel or vowel group to string
//-----------------------------------------------------------------------------
VOID CXBoxSample::AppendVowel( WCHAR* strRandom ) // static
{
    if( ( rand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandVowel(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strVowelGroup[10] =
        {
            L"ai", L"au", L"ay", L"ea", L"ee", L"ie", L"oa", L"oi", L"oo", L"ou"
        };
        lstrcatW( strRandom, strVowelGroup[ rand() % 10 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: LogXNetError()
// Desc: Log errors to the hard drive. When testing xnets.lib, there's no
//       debugging channel, so it's useful to log failures to the hard drive.
//-----------------------------------------------------------------------------
VOID CXBoxSample::LogXNetError( const CHAR* strError, INT iError ) const
{

    // Make sure that we're not logging anything in the final release
#ifndef FINAL_BUILD

    if( m_hLogFile == INVALID_HANDLE_VALUE )
    {
        m_hLogFile = CreateFile( "U:\\XNetError.log", GENERIC_WRITE, 0, NULL,
                                 CREATE_ALWAYS, 0, NULL );
        if( m_hLogFile == INVALID_HANDLE_VALUE )
            return;
    }

    // Write out the error message
    CHAR strBuffer[256];
    wsprintfA( strBuffer, "%s error: %d\r\n", strError, iError );
    DWORD dwWritten;
    WriteFile( m_hLogFile, strBuffer, lstrlenA( strBuffer ), &dwWritten, NULL );

    // Make sure the message makes it to the disk
    FlushFileBuffers( m_hLogFile );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\twowayvoice\TwoWayVoice.h ===
#pragma warning( disable: 4786 )
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBStopWatch.h>
#include <XBSocket.h>
#include <cassert>
#include <vector>
#include <algorithm>
#include "Resource.h"
#include "Voice.h"





//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD COLOR_HIGHLIGHT   = 0xffffff00; // Yellow
const DWORD COLOR_GREEN       = 0xff00ff00;
const DWORD COLOR_NORMAL      = 0xffffffff;
const DWORD MAX_ERROR_STR     = 64;
const DWORD MAX_STATUS_STR    = 128;
const DWORD MAX_GAME_NAMES    = 6;      // Number of game names to choose from
const DWORD NONCE_BYTES       = 8;      // Larger means less chance of random matches
const DWORD MAX_GAME_NAME     = 12;     // Includes null
const DWORD MAX_PLAYER_NAME   = 12;     // Includes null
const DWORD PLAYER_TIMEOUT    = 2000;   // 2 seconds
const FLOAT CHECK_LINK_STATUS = 0.5f;   // Check status twice/sec
const FLOAT PLAYER_HEARTBEAT  = 0.3f;   // ~3 times per second
const FLOAT GAME_JOIN_TIME    = 2.0f;   // 2 seconds


// TCR 3-46 Maximum Number of Connected Xboxes
const DWORD MAX_PLAYERS = 2;            // Max players (may not exceed 16)

// TCR 3-59 Session Discovery Time
const FLOAT GAME_SEARCH_TIME = 2.0f;   // 2 seconds (may not exceed 3)



//-----------------------------------------------------------------------------
// Name: class GameInfo
// Desc: Game information used by clients to store available games
//-----------------------------------------------------------------------------
struct GameInfo
{
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // name of the game
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // name of the host player
};




//-----------------------------------------------------------------------------
// Name: class PlayerInfo
// Desc: Player information used by players to store list of other players
//       in the game
//-----------------------------------------------------------------------------
struct PlayerInfo
{
    XNADDR  xnAddr;                           // XNet address
    IN_ADDR inAddr;                           // Xbox IP (not a "real" IP)
    WCHAR   strPlayerName[ MAX_PLAYER_NAME ]; // player name
    DWORD   dwLastHeartbeat;                  // last heartbeat, in our clocks
};




//-----------------------------------------------------------------------------
// Name: class MatchInAddr
// Desc: Predicate functor used to match on IN_ADDRs in player lists
//-----------------------------------------------------------------------------
struct MatchInAddr
{
    IN_ADDR ia;
    explicit MatchInAddr( const CXBSockAddr& sa ) : ia( sa.GetInAddr() ) { }
    bool operator()( const PlayerInfo& playerInfo )
    {
        return playerInfo.inAddr.s_addr == ia.s_addr;
    }
};




//-----------------------------------------------------------------------------
// Message IDs
//
// A "host" is the player who started the game.
// A "client" is a potential player. A client is not currently playing a game.
// A "player" is anyone playing a game.
//-----------------------------------------------------------------------------
enum
{                       // From     To      Type        Expected response
                        //-----------------------------------------------------
    MSG_FIND_GAME,      // client   host    broadcast   MSG_GAME_FOUND
    MSG_GAME_FOUND,     // host     client  broadcast   <none>
    MSG_JOIN_GAME,      // client   host    direct      MSG_JOIN_APPROVED/DENIED
    MSG_JOIN_APPROVED,  // host     client  direct      <none>
    MSG_JOIN_DENIED,    // host     client  direct      <none>
    MSG_PLAYER_JOINED,  // host     player  direct      <none>
    MSG_WAVE,           // player   player  direct      <none>
    MSG_HEARTBEAT       // player   player  direct      <none>
	
};




//-----------------------------------------------------------------------------
// Message payloads
//-----------------------------------------------------------------------------
// Pack to minimize network traffic
#pragma pack( push )
#pragma pack( 1 )

//-----------------------------------------------------------------------------
// Local Player struct used by some messages
//-----------------------------------------------------------------------------
struct Player
{
    XNADDR xnAddr;                           // player's XNet address
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ]; // player's name
};

//-----------------------------------------------------------------------------
// Local Nonce struct used by some messages
//-----------------------------------------------------------------------------
struct Nonce
{
    // Used for client verification. The larger the number of NONCE_BYTES,
    // the less likely there is to be an accidental match between client & host
    BYTE byRandom[ NONCE_BYTES ]; 
};

//-----------------------------------------------------------------------------
// Broadcast by a client looking for available games
//-----------------------------------------------------------------------------
struct MsgFindGame
{
    Nonce nonce;    // Generated by client; used to verify host response
};

//-----------------------------------------------------------------------------
// Broadcast by a host in response to a MSG_FIND_GAME
//-----------------------------------------------------------------------------
struct MsgGameFound
{
    Nonce  nonce;                          // used for client verification
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // game name
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // game host player name
};

//-----------------------------------------------------------------------------
// Sent from a client to a host to join a game
//-----------------------------------------------------------------------------
struct MsgJoinGame
{
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ];  // player who wants to join
};

//-----------------------------------------------------------------------------
// Sent from a host to a client in response to a MSG_JOIN_GAME
//-----------------------------------------------------------------------------
struct MsgJoinApproved
{
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // host name
    BYTE   byNumPlayers;                   // Players in the game (not incl host)
    Player PlayerList[ MAX_PLAYERS ];      // List of players (not incl host)
};

//-----------------------------------------------------------------------------
// Sent from a host to other players to notify them that a new player has joined
//-----------------------------------------------------------------------------
struct MsgPlayerJoined
{
    Player player; // The latest player to join the game
};


#pragma pack( pop )




//-----------------------------------------------------------------------------
// Name: class Message
// Desc: Message object sent between players and hosts
//-----------------------------------------------------------------------------
class Message
{
    BYTE m_byMessageId;

    union
    {
        MsgFindGame     m_FindGame;
        MsgGameFound    m_GameFound;
        MsgJoinGame     m_JoinGame;
        MsgJoinApproved m_JoinApproved;
        MsgPlayerJoined m_PlayerJoined;
    };

public:

    explicit Message( BYTE byMessageId = 0 ) : m_byMessageId( byMessageId ) {}
    ~Message() {}

    BYTE GetId() const      { return m_byMessageId; }
    INT  GetMaxSize() const { return sizeof(*this); }

    MsgFindGame&     GetFindGame()     { return m_FindGame;     }
    MsgGameFound&    GetGameFound()    { return m_GameFound;    }
    MsgJoinGame&     GetJoinGame()     { return m_JoinGame;     }
    MsgJoinApproved& GetJoinApproved() { return m_JoinApproved; }
    MsgPlayerJoined& GetPlayerJoined() { return m_PlayerJoined; }

    INT GetSize() const
    { 
        switch( m_byMessageId )
        {
            case MSG_FIND_GAME:     return sizeof(BYTE) + sizeof(MsgFindGame);
            case MSG_GAME_FOUND:    return sizeof(BYTE) + sizeof(MsgGameFound);
            case MSG_JOIN_GAME:     return sizeof(BYTE) + sizeof(MsgJoinGame);
            case MSG_JOIN_APPROVED: return sizeof(BYTE) + sizeof(MsgJoinApproved);
            case MSG_JOIN_DENIED:   return sizeof(BYTE);
            case MSG_PLAYER_JOINED: return sizeof(BYTE) + sizeof(MsgPlayerJoined);
            case MSG_WAVE:          return sizeof(BYTE);
            case MSG_HEARTBEAT:     return sizeof(BYTE);
            default: assert( FALSE ); return 0;
        }
    }

private:

    // Disabled
    Message( const Message& );
    Message& operator=( const Message& );

};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_MENU,             // Main menu
        STATE_GAME,             // Game menu
        STATE_HELP,             // Help screen
        STATE_SELECT_NAME,      // Select game name screen
        STATE_START_NEW_GAME,   // Starting new game
        STATE_GAME_SEARCH,      // Searching for game
        STATE_SELECT_GAME,      // Game selection menu
        STATE_REQUEST_JOIN,     // Joining game
        STATE_ERROR             // Error screen
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_LEFT,
        EV_RIGHT,
        EV_DISCONNECT,
        EV_NULL
    };

    enum
    {
        // Main menu
        MAIN_MENU_START_GAME = 0,
        MAIN_MENU_JOIN_GAME  = 1,
        MAIN_MENU_MAX,

        // Game menu
        GAME_MENU_WAVE       = 0,
        GAME_MENU_VOICE      = 1,
        GAME_MENU_LEAVE_GAME = 2,
        GAME_MENU_MAX
    };

    enum InitStatus
    {
        Success,
        NotConnected,
        InitFailed
    };

    typedef std::vector< std::wstring > NameList;
    typedef std::vector< GameInfo >     GameList;
    typedef std::vector< PlayerInfo >   PlayerList;

	CXBPackedResource   m_xprResource;   // app resources
    LPDIRECT3DTEXTURE8  m_ptMenuSel;     // menu selection image
    mutable HANDLE      m_hLogFile;      // Log file
    CXBFont      m_Font;                 // game font
    CXBHelp      m_Help;                 // help screen
    State        m_State;                // game state
    State        m_LastState;            // last state
    DWORD        m_CurrItem;             // current menu item
    NameList     m_GameNames;            // list of potential game names
    GameList     m_Games;                // list of available games
    PlayerList   m_Players;              // list of current players (not incl self)
    WCHAR        m_strError[ MAX_ERROR_STR ];   // error message
    WCHAR        m_strStatus[ MAX_STATUS_STR ]; // status
    CXBStopWatch m_LinkStatusTimer;      // wait to check link status
    CXBStopWatch m_GameSearchTimer;      // wait for game search to complete
    CXBStopWatch m_GameJoinTimer;        // wait for game join to complete
    CXBStopWatch m_HeartbeatTimer;       // keep-alive timer
    BOOL         m_bIsOnline;            // TRUE if link status good
    BOOL         m_bXnetStarted;         // TRUE if networking initialized
    BOOL         m_bIsHost;              // TRUE if we're hosting the game
    BOOL         m_bIsSessionRegistered; // TRUE if session key registered
    BOOL         m_bHaveLocalAddress;    // TRUE if local address acquired
    XNKID        m_xnHostKeyID;          // Host key ID
    XNKEY        m_xnHostKeyExchange;    // Host key exchange key
    XNADDR       m_xnTitleAddress;       // The XNet address of this machine/game
    IN_ADDR      m_inHostAddr;           // The "IP" address of the the host
    CXBSocket    m_BroadSock;            // Broadcast socket for broadcast msgs
    CXBSocket    m_DirectSock;           // Direct socket for direct msgs
    WCHAR        m_strGameName[ MAX_GAME_NAME ];     // Game name
    WCHAR        m_strPlayerName[ MAX_PLAYER_NAME ]; // This player name
    WCHAR        m_strHostName[ MAX_PLAYER_NAME ];   // Host player name
    Nonce        m_Nonce;                            // Client identifier

    // Voice Related Data
    HANDLE       m_hVoiceThread;
    HANDLE       m_hVoiceMutex;
    HANDLE       m_hVoiceDeleteEvent;
    DWORD        m_dwVoiceThreadId;
    CNetVoiceUnit *m_pVoiceUnit;            // The single headset


public:
	HRESULT VoiceThreadProc();
	static DWORD WINAPI StaticVoiceThreadProc(LPVOID pParameter);

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

private:
    Event GetEvent();

    VOID FrameMoveMenu( Event );
    VOID FrameMoveGame( Event );
    VOID FrameMoveHelp( Event );
    VOID FrameMoveSelectName( Event );
    VOID FrameMoveStartGame( Event );
    VOID FrameMoveGameSearch( Event );
    VOID FrameMoveSelectGame( Event );
    VOID FrameMoveRequestJoin( Event );
    VOID FrameMoveError( Event );

    VOID RenderMenu();
    VOID RenderGame();
    VOID RenderHelp();
    VOID RenderSelectName();
    VOID RenderStartGame();
    VOID RenderGameSearch();
    VOID RenderSelectGame();
    VOID RenderRequestJoin();
    VOID RenderError();
    VOID RenderHeader();
    VOID RenderMenuSelector( FLOAT, FLOAT );

    VOID InitiateJoin( DWORD );
    VOID Wave();
    VOID Heartbeat();

    VOID Init();

    // Initialization
    InitStatus InitXNet();

    // Send messages
    VOID SendFindGame();
    VOID SendGameFound( const Nonce& );
    VOID SendJoinGame( const CXBSockAddr& );
    VOID SendJoinApproved( const CXBSockAddr& );
    VOID SendJoinDenied( const CXBSockAddr& );
    VOID SendPlayerJoined( const Player&, const CXBSockAddr& );
    VOID SendWave( const CXBSockAddr& );
    VOID SendHeartbeat( const CXBSockAddr& );
	

    // Receive messages
    BOOL ProcessBroadcastMessage();
    BOOL ProcessDirectMessage();
    VOID ProcessMessage( Message& );
    VOID ProcessMessage( Message&, const CXBSockAddr& );

    // Process incoming messages
    VOID ProcessFindGame( const MsgFindGame& );
    VOID ProcessGameFound( const MsgGameFound& );
    VOID ProcessJoinGame( const MsgJoinGame&, const CXBSockAddr& );
    VOID ProcessJoinApproved( const MsgJoinApproved&, const CXBSockAddr& );
    VOID ProcessJoinDenied( const CXBSockAddr& );
    VOID ProcessPlayerJoined( const MsgPlayerJoined&, const CXBSockAddr& );
    VOID ProcessWave( const CXBSockAddr& );
    VOID ProcessHeartbeat( const CXBSockAddr& );

    // Handle keep-alive
    BOOL ProcessPlayerDropouts();

    // Utility
    VOID DestroyGameList();
    VOID DestroyPlayerList();
    static VOID GenRandom( WCHAR*, DWORD );
    static WCHAR GetRandVowel();
    static WCHAR GetRandConsonant();
    static VOID AppendConsonant( WCHAR*, BOOL );
    static VOID AppendVowel( WCHAR* );

    VOID LogXNetError( const CHAR*, INT ) const;

    // Voice related functions
    VOID KillVoiceProcessing();
    int FindHeadsetPort();
    VOID StartVoiceProcessing();

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\twowayvoice\Voice.h ===
#ifndef VOICE_H_INCLUDED
#define VOICE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <XBSocket.h>
#include <XBSockAddr.h>
#include <cassert>
#include <stdio.h>
#include "xvoice.h"

const WORD  VOICE_PORT        = 10985;  // any port other than the first two

const int VOICE_SAMPLING_RATE = 8000;
const int CODEC_SAMPLING_RATE = 8000;

const int XVOICE_BYTES_PER_MS = (((ULONG)( VOICE_SAMPLING_RATE / 1000.0 )) * 2 );

const int XVOICE_BUFFER_REGION_TIME = 40; // initially 80, but changed in order to fit a network packet 
const int XVOICE_BUFFER_REGION_SIZE = ( XVOICE_BYTES_PER_MS * XVOICE_BUFFER_REGION_TIME );
const int XVOICE_PREBUFFER_REGIONS = 20;
const int XVOICE_TOTAL_REGIONS = ( XVOICE_PREBUFFER_REGIONS + 2 );
const int XVOICE_BUFFER_SIZE = ( XVOICE_BUFFER_REGION_SIZE * XVOICE_TOTAL_REGIONS );

const int HAWKS_COUNT = 4;
const int VOICE_DEVICES_COUNT = 2; //Microphone & Headphone
const int MICROPHONE = 0;
const int HEADPHONE = 1;



const int MAX_VOICE_TRANSFER_SIZE = XVOICE_BUFFER_REGION_SIZE + sizeof(VOICE_ENCODER_HEADER);
const int XVOICE_CODEC_BUFFER_SIZE = XVOICE_BUFFER_REGION_SIZE / 4 + sizeof(VOICE_ENCODER_HEADER);


//////////////////////////////////////////////////////////////////////////////
// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
//////////////////////////////////////////////////////////////////////////////

struct MEDIA_PACKET_LIST
{
	MEDIA_PACKET_LIST	*pNext;
	XMEDIAPACKET		MediaPacket;
	DWORD				dwStatus;
	DWORD				dwCompletedSize;

	MEDIA_PACKET_LIST(DWORD dwStatusIn) : pNext(NULL) , dwStatus(dwStatusIn) , dwCompletedSize(0)
	{
		MediaPacket.dwMaxSize = XVOICE_BUFFER_REGION_SIZE;
		MediaPacket.pvBuffer = new BYTE[XVOICE_BUFFER_REGION_SIZE];
		memset(MediaPacket.pvBuffer , 0 , XVOICE_BUFFER_REGION_SIZE);
		MediaPacket.pdwCompletedSize = NULL;
		MediaPacket.pdwStatus = NULL;
		MediaPacket.prtTimestamp = NULL;
		MediaPacket.hCompletionEvent = NULL;
	}
	~MEDIA_PACKET_LIST()
	{
		if( NULL !=  MediaPacket.pvBuffer)
        {
			delete [] MediaPacket.pvBuffer;
        }
	}
};

//
// CVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CVoiceUnit
{
public:
	virtual HRESULT PlayToHeadphone();
	virtual HRESULT OnMicrophoneReadComplete();
	
	virtual void SetSockAddr(const IN_ADDR &addrPlayer);

	virtual HRESULT Inserted();
	virtual void Removed();
	virtual void Process();
	virtual void Init(DWORD dwPortNumber);

	virtual void SendPacketToRenderer();
	virtual BOOL IsPacketPreparedForRender();

  CVoiceUnit();
  virtual ~CVoiceUnit();

  DWORD GetPortNumber() { return m_dwPortNumber; }


protected:
	void CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wSize , DWORD dwStatus);
	void DeleteQueue(MEDIA_PACKET_LIST *pQueue);
/*#ifdef _DEBUG
	void WriteToLogFile(HANDLE hFile , BYTE *pbBuffer , DWORD dwSize , LPOVERLAPPED lpOverlapped);
	void CloseFile(HANDLE hFile);
	void OpenFile(const char* szFileName , HANDLE *phFile);
#endif*/
	void QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pBuffer);
	void QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pBuffer);

    //
    // XMO objects created on call to Inserted()
    //
    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;

	//
    // Stuff given to us at init
    //
    DWORD m_dwPortNumber; // Port number for headset 


	//
    // The 2 queues for the buffers that are sent to the microphone/headphone
    //
	MEDIA_PACKET_LIST *m_pBeginMicrophoneQueuedBuffers;
	MEDIA_PACKET_LIST *m_pBeginHeadphoneQueuedBuffers;


 	//
    // Events for completion on microphone/headphone work
    //
	HANDLE m_hMicrophoneWorkEvent; 
	HANDLE m_hHeadphoneWorkEvent; 

	virtual void Cleanup();

/*#ifdef _DEBUG
	//
    // Diagnosis stuff
    //
	HANDLE m_hFileRawPCMData;
	HANDLE m_hFileCompressed;
	HANDLE m_hFileDecompressed;
#endif*/

	//
    //  Status
    //
    BOOL   m_fPreBuffering;
    DWORD  m_dwPreBufferRegions;

};

//
// CCompressedVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CCompressedVoiceUnit : public CVoiceUnit
{
public:
	HRESULT PlayToHeadphone();
	HRESULT OnMicrophoneReadComplete();
	
	HRESULT Inserted();
	void Removed();

    CCompressedVoiceUnit(); 
    ~CCompressedVoiceUnit();

protected:
	//
    // Specific codec stuff functions
    //
	HRESULT CompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst , BOOL *pvbVoiceDetected );
	HRESULT DecompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst);

    void SendPacketToRenderer();
	BOOL IsPacketPreparedForRender();

protected:
    //
    // XMO objects created on call to Inserted()
    //
    XMediaObject *m_pEncoder;
    XMediaObject *m_pDecoder;
	XMEDIAPACKET m_CodecMediaBuffer[VOICE_DEVICES_COUNT];

 	//
    // Events for completion on encode/decode work
    //
	HANDLE m_hEncodeWorkEvent; 
	HANDLE m_hDecodeWorkEvent; 

	//
	// Flag for correct use of the codec
	//
	BOOL   m_bInPlaceCodec;     


	void Cleanup();
};

//
// CNetVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CNetVoiceUnit : public CCompressedVoiceUnit
{
public:
    CNetVoiceUnit(); 
    ~CNetVoiceUnit();

	HRESULT Inserted();
	void Removed();

	//
    // Uses the voice queuing system
    //
	HRESULT PlayToHeadphone();

	void SetSockAddr(const IN_ADDR &addrPlayer);
	void SendVoicePacket( XMEDIAPACKET *pMediaPacket );
	BOOL RecvVoicePacket( XMEDIAPACKET *pMediaPacket );

	void SendPacketToRenderer();
	BOOL IsPacketPreparedForRender();

protected:
	void Cleanup();

	//
    // Network data
    //
	SOCKET		m_VoiceSock;
	SOCKADDR_IN m_SockAddrDest;

	//
    // Voice queuing XMO
    //
	XMediaObject *m_pVoiceQueuingXMO;

	//
    // Interval for output
    //
	DWORD      m_IntervalForOutput;
	DWORD      m_LastOutputTimeStamp;

};

#endif  // VOICE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\twowayvoice\Voice.cpp ===
#include "voice.h"

#define DSOUND_INCLUDE_XHAWK


//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////

CVoiceUnit::CVoiceUnit():
        m_pMicrophone(NULL),
        m_pHeadphone(NULL),
        m_dwPortNumber(0),
        m_hMicrophoneWorkEvent(NULL),
        m_hHeadphoneWorkEvent(NULL),
        m_pBeginMicrophoneQueuedBuffers(NULL),
        m_pBeginHeadphoneQueuedBuffers(NULL),
/*#ifdef _DEBUG
        m_hFileRawPCMData(NULL) ,
        m_hFileCompressed(NULL) ,
        m_hFileDecompressed(NULL) , 
#endif*/
        m_fPreBuffering(FALSE),
        m_dwPreBufferRegions(0)
{}

void CVoiceUnit::Cleanup()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
    }    

    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
        m_pHeadphone = NULL;
    }

    
    if (m_hMicrophoneWorkEvent) 
    {
        CloseHandle(m_hMicrophoneWorkEvent);
        m_hMicrophoneWorkEvent = NULL;
    }

    if (m_hHeadphoneWorkEvent) 
    {
        CloseHandle(m_hHeadphoneWorkEvent);
        m_hHeadphoneWorkEvent = NULL;
    }

    if( NULL != m_pBeginMicrophoneQueuedBuffers )
    {
		DeleteQueue(m_pBeginMicrophoneQueuedBuffers);
		m_pBeginMicrophoneQueuedBuffers = NULL;

    }

    if( NULL != m_pBeginHeadphoneQueuedBuffers )
    {
		DeleteQueue(m_pBeginHeadphoneQueuedBuffers);
        m_pBeginHeadphoneQueuedBuffers = NULL;
    }

/*#ifdef _DEBUG
	CloseFile(m_hFileRawPCMData);
	CloseFile(m_hFileCompressed);
	CloseFile(m_hFileDecompressed);
#endif*/
}

void CVoiceUnit::DeleteQueue(MEDIA_PACKET_LIST *pQueue)
{
	assert(pQueue->pNext != pQueue);

	MEDIA_PACKET_LIST *pTmpBuff = pQueue;

	pQueue = pQueue->pNext;
	pTmpBuff->pNext = NULL; //Break queue

	while(NULL != pQueue)
	{
		pTmpBuff = pQueue->pNext;
		delete pQueue;
		pQueue = pTmpBuff;
	}
}

CVoiceUnit::~CVoiceUnit()
{
    Cleanup();
}

void CVoiceUnit::CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wSize , DWORD dwStatus)
{
    MEDIA_PACKET_LIST *pTmp = NULL;
	MEDIA_PACKET_LIST *pHead = NULL;
	
    
	//
    // Create linked-list
    //
	for( int i = 0 ; i <  wSize ; i++ )
    {
		if( pTmp )
        {
			pTmp->pNext = new MEDIA_PACKET_LIST(dwStatus);
			pTmp = pTmp->pNext;
		}
		else
		{
			pTmp = new MEDIA_PACKET_LIST(dwStatus);
			pHead = pTmp;
		}
		if( NULL == pTmp )
		{
			break;
		}
    }

	if(NULL == pTmp)
	{
		//
        // Something went wrong, release allocated memory
        //
		pTmp = pHead;

		while(NULL != pTmp)
		{
			pHead = pTmp->pNext;
			delete pTmp;
			pTmp = pHead;
		}
		*pQueue = NULL;
	}
	else
	{
		//
        // Close queue
        //
		pTmp->pNext = pHead;
		*pQueue = pHead;
	}
	
}

void CVoiceUnit::Init(DWORD dwPortNumber)
{
	m_dwPortNumber = dwPortNumber;
}

void CVoiceUnit::Process()
{
    DWORD dwReason;
	HRESULT hr;

        if( NULL == m_hMicrophoneWorkEvent )
        {
            return; // No hawk inserted
        }

        do
        {
			dwReason = WaitForSingleObject( m_hMicrophoneWorkEvent, 16);

			switch (dwReason)
			{
			case WAIT_OBJECT_0://Microphone
				hr = OnMicrophoneReadComplete();
				if(FAILED(hr))
				{
					DebugPrint("Failure OnMicrophoneReadComplete = %d\n" , hr);
					return;
				}
				else
				{
					PlayToHeadphone();	
				}
				break;
			default: //Timeout
				return;
			}
        
        }
        while(TRUE);
    
}

void CVoiceUnit::SetSockAddr(const IN_ADDR &addrPlayer)
{
}

HRESULT CVoiceUnit::Inserted()
{
    HRESULT         hr;
    WAVEFORMATEX    wfxFormat;
    
    do
    {
        DebugPrint("CVoiceUnit::Inserted()...Hawk Inserted\n");

        //
        // The headset initialization
        //
        wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
        wfxFormat.nChannels = 1;
        wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
        wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
        wfxFormat.nBlockAlign = 2;
        wfxFormat.wBitsPerSample = 16;
        wfxFormat.cbSize = 0;

        //
        //  Create a microphone and a headphone
        //
        DebugPrint("CVoiceUnit::Inserted()...Creating microphone...\n");
        hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                     &wfxFormat, &m_pMicrophone);

        if( FAILED( hr ) )
        {
            DebugPrint("CVoiceUnit::Inserted()...Microphone failed with %x", hr);
            break;
        }

        DebugPrint("CVoiceUnit::Inserted()...Creating headphone...\n");
        hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                     &wfxFormat, &m_pHeadphone);

        if( FAILED( hr ) )
        {
            DebugPrint("CVoiceUnit::Inserted()...Headphone failed with %x", hr);
            m_pMicrophone->Release();
            m_pMicrophone = NULL;
            break;
        }

        //
        // Other member initializing...
        //
        m_hMicrophoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_hHeadphoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        
        m_fPreBuffering = TRUE;
        m_dwPreBufferRegions = 0;

/*#ifdef _DEBUG
		//
        // Log File for the converted signal 16kHz->8kHz
        //
		OpenFile("D:\\RawPCMData.log" , &m_hFileRawPCMData);
		
		//
        // Log File for the compressed signal
        //
		OpenFile("D:\\Compressed.log" , &m_hFileCompressed);

		//
        // Log File for the decompressed signal
        //
		OpenFile("D:\\Decompressed.log" , &m_hFileDecompressed);
#endif*/
        //
        // Create the buffers for microphone
        //
		CreateQueue(&m_pBeginMicrophoneQueuedBuffers , XVOICE_TOTAL_REGIONS , (DWORD)XMEDIAPACKET_STATUS_PENDING);
        if( NULL ==  m_pBeginMicrophoneQueuedBuffers)
        {
            DebugPrint("CVoiceUnit::Inserted()...Not enough memory for buffers!\n");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Create the buffers for headphone
        //
        CreateQueue(&m_pBeginHeadphoneQueuedBuffers , XVOICE_TOTAL_REGIONS , XMEDIAPACKET_STATUS_SUCCESS);
        if( NULL ==  m_pBeginHeadphoneQueuedBuffers)
        {
            DebugPrint("CVoiceUnit::Inserted()...Not enough memory for buffers!\n");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Feed the microphone with buffers; we enqueue all the buffers to the microphone which is going to fill 
		// them with data gradually
        //
		MEDIA_PACKET_LIST *pTmpMBuff = m_pBeginMicrophoneQueuedBuffers;
        
        for( int i = 0 ; i < XVOICE_TOTAL_REGIONS ; i++ )
        {
			
            QueueMicrophoneBuffer(pTmpMBuff);
			pTmpMBuff = pTmpMBuff->pNext;
        }

		//
        // We don't enqueue buffers to the headphone yet; this is going to be done when buffers from the microphone
		// start to arrive
        //

        hr = S_OK;
    }
    while( FALSE );

    return( hr );
}

void CVoiceUnit::Removed()
{
    CVoiceUnit::Cleanup();
}

void CVoiceUnit::QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event 
    //

    pMediaPacket->hCompletionEvent = m_hMicrophoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pMicrophone->Process(NULL, pMediaPacket));


}

void CVoiceUnit::QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event
    //
    pMediaPacket->hCompletionEvent = m_hHeadphoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pHeadphone->Process(pMediaPacket, NULL));

}

void CVoiceUnit::SendPacketToRenderer()
{
	memcpy((m_pBeginHeadphoneQueuedBuffers->MediaPacket).pvBuffer ,
		   (m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer , 
            XVOICE_BUFFER_REGION_SIZE);
	m_pBeginHeadphoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
}

BOOL CVoiceUnit::IsPacketPreparedForRender()
{
	return (XMEDIAPACKET_STATUS_PENDING == m_pBeginHeadphoneQueuedBuffers->dwStatus);
}

HRESULT CVoiceUnit::OnMicrophoneReadComplete()
{
/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/
	
	HRESULT hr;
    
    do
    {
        //
        // One microphone buffer is filled with data
        //
	    if(XMEDIAPACKET_STATUS_PENDING != m_pBeginMicrophoneQueuedBuffers->dwStatus)
        {
            if( SUCCEEDED( m_pBeginMicrophoneQueuedBuffers->dwStatus ) )
            {
/*#ifdef _DEBUG
				WriteToLogFile(m_hFileRawPCMData , (BYTE*)(m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer ,
				           XVOICE_BUFFER_REGION_SIZE , &overlapped);
#endif*/
                //
                // Send the packet to the headphone
                //
				SendPacketToRenderer();
                
            }

			if( XMEDIAPACKET_STATUS_FAILURE == m_pBeginMicrophoneQueuedBuffers->dwStatus )
            {
				hr = E_FAIL;
				break;
            }
			else
			{
				//
				// Requeue the packet
				//  
				m_pBeginMicrophoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
				QueueMicrophoneBuffer(m_pBeginMicrophoneQueuedBuffers);
				m_pBeginMicrophoneQueuedBuffers = m_pBeginMicrophoneQueuedBuffers->pNext;
			}

        }
   
        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );

}

HRESULT CVoiceUnit::PlayToHeadphone()
{
    if(IsPacketPreparedForRender())
	{
		QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
	}

    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

	return (S_OK);
}

/*#ifdef _DEBUG

void CVoiceUnit::OpenFile(const char *szFileName, HANDLE *phFile)
{
	*phFile = CreateFile(szFileName,
					  GENERIC_WRITE,                // open for writing 
					  0,                            // do not share 
					  NULL,                         // no security 
					  CREATE_ALWAYS,                // overwrite existing 
					  FILE_ATTRIBUTE_NORMAL |       // normal file 
					  FILE_FLAG_OVERLAPPED,         // asynchronous I/O 
					  NULL);                        // no attr. template 

	if (*phFile == INVALID_HANDLE_VALUE) 
	{ 
		DWORD dwErr = GetLastError();
		DebugPrint("Error: %d.\n" , dwErr);  // process error 
	} 
}

void CVoiceUnit::CloseFile(HANDLE hFile)
{
	if( NULL != hFile )
    {
		// Make sure the message makes it to the disk
		FlushFileBuffers( hFile );
		CloseHandle(hFile); 
    }
}

void CVoiceUnit::WriteToLogFile(HANDLE hFile, BYTE *pbBuffer, DWORD dwSize , LPOVERLAPPED lpOverlapped)
{
static DWORD dwBytesWritten = 0;

	WriteFile( hFile,				      // handle to output file
			   pbBuffer,                      // data buffer
			   dwSize,                // number of bytes to write
			   &dwBytesWritten ,
			   lpOverlapped);

	lpOverlapped->Offset += dwBytesWritten;
}
#endif*/

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CCompressedVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
CCompressedVoiceUnit::CCompressedVoiceUnit() : 
                        CVoiceUnit() , 
                        m_pEncoder(NULL) , 
                        m_pDecoder(NULL) ,
                        m_hEncodeWorkEvent(NULL),
                        m_hDecodeWorkEvent(NULL),
					    m_bInPlaceCodec(FALSE)
{
	for( int i = 0 ; i < VOICE_DEVICES_COUNT ; i++ )
    {
		m_CodecMediaBuffer[i].pvBuffer = NULL;
    }
}

void CCompressedVoiceUnit::Cleanup()
{
    if(m_pEncoder)
    {
        m_pEncoder->Release();
        m_pEncoder = NULL;
    }
    if(m_pDecoder)
    {
        m_pDecoder->Release();
        m_pDecoder = NULL;
    }

	for( int i = 0 ; i < VOICE_DEVICES_COUNT ; i++ )
    {
		if( NULL != m_CodecMediaBuffer[i].pvBuffer )
		{
			delete [] m_CodecMediaBuffer[i].pvBuffer;
			m_CodecMediaBuffer[i].pvBuffer = NULL;
		}
	}
    if (m_hEncodeWorkEvent) 
    {
        CloseHandle(m_hEncodeWorkEvent);
        m_hEncodeWorkEvent = NULL;
    }

    if (m_hDecodeWorkEvent) 
    {
        CloseHandle(m_hDecodeWorkEvent);
        m_hDecodeWorkEvent = NULL;
    }

}

CCompressedVoiceUnit::~CCompressedVoiceUnit()
{
    Cleanup();
}

void CCompressedVoiceUnit::Removed()
{
    CCompressedVoiceUnit::Cleanup();

    CVoiceUnit::Removed();
}

HRESULT CCompressedVoiceUnit::Inserted()
{
    HRESULT hr;
    XMEDIAINFO      xMediaInfo;

    WAVEFORMATEX wfxFormat;
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;
    
    do
    {
        hr = CVoiceUnit::Inserted();

        if( FAILED( hr ) )
        {
            DebugPrint("CCompressedVoiceUnit::Inserted()...Base class Inserted() failed!\n");
            break;
        }

        DebugPrint("Creating voice encoder...\n");

        hr = XVoiceEncoderCreateMediaObject( FALSE, // manual mode
                                             WAVE_FORMAT_VOXWARE_SC06,
                                             &wfxFormat,
                                             20, // voice activation threshold
                                             &m_pEncoder );

        if( FAILED( hr ) )
        {
            DebugPrint("CCompressedVoiceUnit::Inserted()...Voice encoder failed with %x", hr);
            break;
        }

        DebugPrint(("Creating voice decoder...\n"));

        hr = XVoiceDecoderCreateMediaObject( 0, // zero latency
                                             WAVE_FORMAT_VOXWARE_SC06,
                                             &wfxFormat,
                                             &m_pDecoder );
        if( FAILED( hr ) )
        {
            DebugPrint("CCompressedVoiceUnit::Inserted()...Voice decoder failed with %x", hr);
            m_pEncoder->Release();
            m_pEncoder = NULL;
            break;
        }
    
                    
        //
        // If the codec XMOs are in place don't pass a DST temp buffer...
        //

        m_pEncoder->GetInfo( &xMediaInfo );

        if (xMediaInfo.dwFlags & XMO_STREAMF_IN_PLACE) 
        {
            DebugPrint("CCompressedVoiceUnit::Inserted()...Encoder %x is in place\n", m_pEncoder);
			m_bInPlaceCodec = TRUE;

        } 
        else 
        {
			for( int i = 0 ; i < VOICE_DEVICES_COUNT ; i++ )
			{
				memset(&(m_CodecMediaBuffer[i]), 0, sizeof(XMEDIAPACKET));

				m_CodecMediaBuffer[i].dwMaxSize = XVOICE_CODEC_BUFFER_SIZE;
				m_CodecMediaBuffer[i].pvBuffer = new BYTE[XVOICE_CODEC_BUFFER_SIZE];
				assert(m_CodecMediaBuffer[i].pvBuffer);

			}
            DebugPrint("CCompressedVoiceUnit::Inserted()...Codec xmos are not in place, using temp buffer\n");
        }

        m_hEncodeWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_hDecodeWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);


        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}

HRESULT CCompressedVoiceUnit::OnMicrophoneReadComplete()
{
	BOOL bVoiceDetected = TRUE;

/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/


	HRESULT hr;
    
    do
    {
		//
		// One microphone buffer is filled with data
		//
		if(XMEDIAPACKET_STATUS_PENDING != m_pBeginMicrophoneQueuedBuffers->dwStatus)
		{
			if( SUCCEEDED( m_pBeginMicrophoneQueuedBuffers->dwStatus ) )
			{
/*#ifdef _DEBUG
				WriteToLogFile(m_hFileRawPCMData , (BYTE*)(m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer ,
							   XVOICE_BUFFER_REGION_SIZE , &overlapped);
#endif*/

				//
				// 1. Compress media buffer
				//
				CompressMediaBuffer(&m_pBeginMicrophoneQueuedBuffers->MediaPacket ,
					                &m_CodecMediaBuffer[MICROPHONE] , &bVoiceDetected);
				memset((m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer , 0 , XVOICE_BUFFER_REGION_SIZE); 


				if(bVoiceDetected)
				{
					//
					// 2. Prepare the packet for the output device (headphone)
					//
					SendPacketToRenderer();
				}
											
			}

			if( XMEDIAPACKET_STATUS_FAILURE == m_pBeginMicrophoneQueuedBuffers->dwStatus )
            {
				hr = E_FAIL;
				break;
            }
			else
			{
				//
				// Requeue the packet
				//  
				m_pBeginMicrophoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
				QueueMicrophoneBuffer(m_pBeginMicrophoneQueuedBuffers);
				m_pBeginMicrophoneQueuedBuffers = m_pBeginMicrophoneQueuedBuffers->pNext;
			}
		}
    
        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}

HRESULT CCompressedVoiceUnit::PlayToHeadphone()
{

	if(IsPacketPreparedForRender())    
	{
		//
		// 1. Decompress media buffer
		//
		DecompressMediaBuffer(&m_CodecMediaBuffer[HEADPHONE] , &m_pBeginHeadphoneQueuedBuffers->MediaPacket);

		//
		// 2. Send it to the headphone
		//
       	QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
	}

    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

	return (S_OK);
}

HRESULT CCompressedVoiceUnit::CompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst , BOOL *pvbVoiceDetected)
{
    HRESULT hr;
    DWORD dwSizeSrc = 0; 
    DWORD dwSizeDst = 0; 

/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/

    memset(pDst->pvBuffer, 0 , XVOICE_CODEC_BUFFER_SIZE);

    pDst->pdwCompletedSize = &dwSizeDst;
    pDst->hCompletionEvent = m_hEncodeWorkEvent;

    if( m_bInPlaceCodec )
    {
		//
		// Call encoding xmo
		//
		memcpy(pDst->pvBuffer , pSrc->pvBuffer , pSrc->dwMaxSize);
		hr = m_pEncoder->Process(NULL , pDst);

    }
	else
	{
	    //
	    // Call encoding xmo
		//
		pSrc->pdwCompletedSize = &dwSizeSrc;
		hr = m_pEncoder->Process( pSrc , pDst);
	}

    assert(!FAILED(hr));
    
    WaitForSingleObject(m_hEncodeWorkEvent , INFINITE);

/*#ifdef _DEBUG
	WriteToLogFile(m_hFileCompressed , (BYTE*)pDst->pvBuffer , dwSizeDst , &overlapped);
#endif*/

    if( dwSizeDst == sizeof(VOICE_ENCODER_HEADER) )
    {
		*pvbVoiceDetected = FALSE;
    }
	else
	{
		*pvbVoiceDetected = TRUE;
	}
    return( hr );
}

HRESULT CCompressedVoiceUnit::DecompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst)
{
    HRESULT hr;
    DWORD dwSizeSrc = 0; 
    DWORD dwSizeDst = 0; 

/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/
    
    memset(pDst->pvBuffer , 0 , pDst->dwMaxSize);


    pDst->pdwCompletedSize = &dwSizeDst;
    pDst->hCompletionEvent = m_hDecodeWorkEvent;

    if( m_bInPlaceCodec )
    {
		//
		// Call decoding xmo
		//
		memcpy(pDst->pvBuffer , pSrc->pvBuffer , pSrc->dwMaxSize);
		hr = m_pDecoder->Process(NULL , pDst);

    }
	else
	{
	    //
	    // Call decoding xmo
		//
		pSrc->pdwCompletedSize = &dwSizeSrc;
		hr = m_pDecoder->Process( pSrc , pDst);
	}
    
    assert(!FAILED(hr));

    WaitForSingleObject(m_hDecodeWorkEvent , INFINITE);

/*#ifdef _DEBUG
	WriteToLogFile(m_hFileDecompressed , (BYTE*)pDst->pvBuffer , dwSizeDst , &overlapped);
#endif*/

    return( hr );
}

void CCompressedVoiceUnit::SendPacketToRenderer()
{
	m_pBeginHeadphoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
	memcpy(m_CodecMediaBuffer[HEADPHONE].pvBuffer , m_CodecMediaBuffer[MICROPHONE].pvBuffer , XVOICE_CODEC_BUFFER_SIZE);
	memset(m_CodecMediaBuffer[MICROPHONE].pvBuffer , 0 , XVOICE_CODEC_BUFFER_SIZE);
}

BOOL CCompressedVoiceUnit::IsPacketPreparedForRender()
{
	return(XMEDIAPACKET_STATUS_PENDING == m_pBeginHeadphoneQueuedBuffers->dwStatus);
}

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CNetVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
CNetVoiceUnit::CNetVoiceUnit() : CCompressedVoiceUnit() ,
                                 m_VoiceSock(INVALID_SOCKET),
								 m_pVoiceQueuingXMO(NULL)
{
    m_SockAddrDest.sin_family = AF_INET;
    m_SockAddrDest.sin_addr.s_addr = htonl(INADDR_ANY);
    m_SockAddrDest.sin_port = htons( VOICE_PORT );
}

void CNetVoiceUnit::Cleanup()
{
    if( INVALID_SOCKET != m_VoiceSock )
    {
        closesocket( m_VoiceSock );
        m_VoiceSock = INVALID_SOCKET;
    }

	if( NULL != m_pVoiceQueuingXMO )
    {
		m_pVoiceQueuingXMO->Release();
		m_pVoiceQueuingXMO = NULL;
    }
}

CNetVoiceUnit::~CNetVoiceUnit()
{
    Cleanup();
}

void CNetVoiceUnit::SetSockAddr(const IN_ADDR &addrPlayer)
{
	m_SockAddrDest.sin_family = AF_INET;
    m_SockAddrDest.sin_addr = addrPlayer;
    m_SockAddrDest.sin_port = htons( VOICE_PORT );
	
}

void CNetVoiceUnit::Removed()
{
    CNetVoiceUnit::Cleanup();

    CCompressedVoiceUnit::Removed();
}


HRESULT CNetVoiceUnit::Inserted()
{
    HRESULT hr;
    
    do
    {
		//
        // Base class initialization
        //
        hr = CCompressedVoiceUnit::Inserted();

        if( FAILED( hr ) )
        {
            DebugPrint("CNetVoiceUnit::Inserted()...Base class Inserted() failed!\n");
            break;
        }

		//
        // Network stuff initialization
        //
        m_VoiceSock = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
        if( INVALID_SOCKET ==  m_VoiceSock )
        {
            hr = WSAGetLastError();
            DebugPrint("CNetVoiceUnit::Inserted()...Voice socket open; error = %x\n", hr);
            break;
        }

        SOCKADDR_IN voiceAddr;
		voiceAddr.sin_family = AF_INET;
		voiceAddr.sin_addr.s_addr = /*htonl(*/INADDR_ANY;
		voiceAddr.sin_port = htons( VOICE_PORT );
        int iResult = bind( m_VoiceSock, (const sockaddr*)(&voiceAddr), sizeof( SOCKADDR_IN ) );
        if(iResult == SOCKET_ERROR)
        {
           hr = WSAGetLastError();
           DebugPrint( "CNetVoiceUnit::Inserted()...Voice socket open; error = %x\n", hr);
           break;
        }

		DWORD dwNonBlocking = 1;
		iResult = ioctlsocket(m_VoiceSock , FIONBIO, &dwNonBlocking );
		if(iResult == SOCKET_ERROR)
		{
           hr = WSAGetLastError();
           DebugPrint( "CNetVoiceUnit::Inserted()...Voice socket open; error = %x\n", hr);
           break;
		}

		//
        // Voice queueing initialization
        //
		QueueXMOConfig config;
		config.cbSize = sizeof(config);
		config.dIdealQuality = 0.5;
		config.dInitialFrameStrength = 0.05;

		hr = XQueueCreateMediaObject(&config , &m_pVoiceQueuingXMO);
		
		if( FAILED( hr ) )
        {
			DebugPrint("CNetVoiceUnit::Inserted()...Voice queuing initialization failed; error = %x\n", hr);
			break;
        }

		//
        // Output is requested from the queuing XMO only if m_IntervalForOutput time has elapsed
		//
		m_IntervalForOutput = config.wMsOfDataPerPacket / 2;
		m_LastOutputTimeStamp = GetTickCount();

        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}


HRESULT CNetVoiceUnit::PlayToHeadphone()
{
	HRESULT hr = E_FAIL; // S_OK = Means decompression OK


	if(IsPacketPreparedForRender())    
	{
		//
		// 1. Call the queuing system with the codec buffer as input
		//
		hr = m_pVoiceQueuingXMO->Process(&m_CodecMediaBuffer[HEADPHONE] , &m_pBeginHeadphoneQueuedBuffers->MediaPacket);

	}
	else
	{
		//
        // 1. Call for output only if the interval elapsed
        //
		if(GetTickCount() - m_LastOutputTimeStamp >= m_IntervalForOutput)
		{
			hr = m_pVoiceQueuingXMO->Process(NULL , &m_pBeginHeadphoneQueuedBuffers->MediaPacket);
		}
	}
	m_LastOutputTimeStamp = GetTickCount();

	if( SUCCEEDED( hr ) )
    {
		//
		// 2. Send it to the headphone
		//
  		QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
    }


    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

	return (S_OK);
}


void CNetVoiceUnit::SendPacketToRenderer()
{
	SendVoicePacket( &m_CodecMediaBuffer[MICROPHONE] );
}

BOOL CNetVoiceUnit::IsPacketPreparedForRender()
{
	return RecvVoicePacket(&m_CodecMediaBuffer[HEADPHONE]);
}

void CNetVoiceUnit::SendVoicePacket( XMEDIAPACKET *pMediaPacket )
{

	int nBytes = sendto( m_VoiceSock , (const char*)pMediaPacket->pvBuffer, XVOICE_CODEC_BUFFER_SIZE , 
                         0, (const sockaddr*)(&m_SockAddrDest), sizeof( SOCKADDR_IN ) );

	DebugPrint("Sent: %d bytes\n" , nBytes);

    assert( nBytes == XVOICE_CODEC_BUFFER_SIZE );
}

BOOL CNetVoiceUnit::RecvVoicePacket( XMEDIAPACKET *pMediaPacket )
{

    // See if a voice message is waiting for us
    SOCKADDR_IN saFromIn;
	int iSize = sizeof( SOCKADDR_IN );
	memset(pMediaPacket->pvBuffer , 0 , XVOICE_CODEC_BUFFER_SIZE);
    int iResult = recvfrom( m_VoiceSock , (char*)pMediaPacket->pvBuffer, XVOICE_CODEC_BUFFER_SIZE, 
							0, (sockaddr*)(&saFromIn), &iSize );
    

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        DebugPrint("Recv: %d bytes\n" , iResult);
        return TRUE;
    }

	DebugPrint("Recv Error: %d \n" , WSAGetLastError());
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\voicechat.cpp ===
//-----------------------------------------------------------------------------
// File: VoiceChat.cpp
//
// Hist: 08.08.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "VoiceChat.h"

const WORD  BROADCAST_PORT    = 10983;  // could be any port
const WORD  DIRECT_PORT       = 10984;  // any port other than BROADCAST_PORT

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
: 
    CXBApplication(),
    m_xprResource (),
    m_ptMenuSel   ( NULL ),
    m_hLogFile    ( INVALID_HANDLE_VALUE ),
    m_Font        (),
    m_Help        (),
    m_State       ( STATE_MENU ),
    m_LastState   ( STATE_MENU ),
    m_CurrItem    ( 0 ),
    m_GameNames   (),
    m_Games       (),
    m_Players     (),
    m_strError    (),
    m_strStatus   (),
    m_LinkStatusTimer     ( FALSE ),
    m_GameSearchTimer     ( FALSE ),
    m_GameJoinTimer       ( FALSE ),
    m_HeartbeatTimer      ( FALSE ),
    m_bIsOnline           ( FALSE ),
    m_bXnetStarted        ( FALSE ),
    m_bIsHost             ( FALSE ),
    m_bIsSessionRegistered( FALSE ),
    m_bHaveLocalAddress   ( FALSE ),
    m_xnHostKeyID         (),
    m_xnHostKeyExchange   (),
    m_xnTitleAddress      (),
    m_inHostAddr          (),
    m_BroadSock           (),
    m_DirectSock          (),
    m_strGameName         (),
    m_strPlayerName       (),
    m_strHostName         (),
    m_Nonce               (),
    m_pCommunicatorMgr    (NULL)
{
    srand( GetTickCount() ); // for generating game/player names

    for( BYTE i = 0 ; i < COMMUNICATOR_COUNT ; i++)
    {
        m_msgCommunicatorStatus[i].action = NO_ACTION;
        m_msgCommunicatorStatus[i].wVoicePort = 0;
    }
    
    Init();
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our textures
    if( FAILED( m_xprResource.Create( g_pd3dDevice, "Resource.xpr", 
                                      Resource_NUM_RESOURCES ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load textures\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Set up texture ptrs
    m_ptMenuSel = m_xprResource.GetTexture( Resource_MenuSelect_OFFSET );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // TCR 2-16 Lost Link
    // Check network status periodically
    if( !m_LinkStatusTimer.IsRunning() ||
        m_LinkStatusTimer.GetElapsedSeconds() > CHECK_LINK_STATUS )
    {
        m_LinkStatusTimer.StartZero();
        DWORD dwStatus = XNetGetEthernetLinkStatus();
        m_bIsOnline = ( dwStatus & XNET_ETHERNET_LINK_ACTIVE ) != 0;
    }

    Event ev = GetEvent();

    switch( m_State )
    {
        case STATE_MENU:            FrameMoveMenu( ev );        break;
        case STATE_GAME:            FrameMoveGame( ev );        break;
        case STATE_HELP:            FrameMoveHelp( ev );        break;
        case STATE_SELECT_NAME:     FrameMoveSelectName( ev );  break;
        case STATE_START_NEW_GAME:  FrameMoveStartGame( ev );   break;
        case STATE_GAME_SEARCH:     FrameMoveGameSearch( ev );  break;
        case STATE_SELECT_GAME:     FrameMoveSelectGame( ev );  break;
        case STATE_REQUEST_JOIN:    FrameMoveRequestJoin( ev ); break;
        case STATE_ERROR:           FrameMoveError( ev );       break;
    }

    // Allow voice to be processed
    ProcessVoice();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000A0A6A, 1.0f, 0L );

    switch( m_State )
    {
        case STATE_MENU:            RenderMenu();        break;
        case STATE_GAME:            RenderGame();        break;
        case STATE_HELP:            RenderHelp();        break;
        case STATE_SELECT_NAME:     RenderSelectName();  break;
        case STATE_START_NEW_GAME:  RenderStartGame();   break;
        case STATE_GAME_SEARCH:     RenderGameSearch();  break;
        case STATE_SELECT_GAME:     RenderSelectGame();  break;
        case STATE_REQUEST_JOIN:    RenderRequestJoin(); break;
        case STATE_ERROR:           RenderError();       break;
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent()
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }

    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;

    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;

    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
        return EV_LEFT;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        return EV_RIGHT;

    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveMenu()
// Desc: Animate menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveMenu( Event ev )
{
    switch( ev )
    {
        case EV_BUTTON_A:

            // Prepare networking
            switch( InitXNet() )
            {
                case Success:
                    break;
                case NotConnected:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"This Xbox is not connected to\n"
                                           L"a hub or another Xbox",
                                           MAX_ERROR_STR );
                    return;
                case InitFailed:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"Failure initializing network\n"
                                           L"connections", 
                                           MAX_ERROR_STR );
                    return;
                default: assert( FALSE ); break;
            }

            switch( m_CurrItem )
            {
                case MAIN_MENU_START_GAME:
                {   

                    assert( !m_bIsSessionRegistered );

                    // Create the session key ID and exchange key
                    INT iKeyCreated = XNetCreateKey( &m_xnHostKeyID, 
                                                     &m_xnHostKeyExchange );

                    // Register the session
                    INT iKeyRegistered = XNetRegisterKey( &m_xnHostKeyID, 
                                                          &m_xnHostKeyExchange );
                    if( iKeyCreated != NO_ERROR || iKeyRegistered != NO_ERROR )
                    {
                        m_State = STATE_ERROR;
                        lstrcpynW( m_strError, L"Unable to start game session",
                                   MAX_ERROR_STR );

                        if( iKeyCreated != NO_ERROR )
                            LogXNetError( "XNetCreateKey", iKeyCreated );
                        if( iKeyRegistered != NO_ERROR )
                            LogXNetError( "XNetRegisterKey", iKeyRegistered );

                        break;
                    }

                    m_bIsSessionRegistered = TRUE;

                    // We're the host
                    m_bIsHost = TRUE;

                    // TCR 3-58 Naming of Game Sessions
                    // Build a list of potential game names
                    assert( m_GameNames.empty() );
                    for( DWORD i = 0; i < MAX_GAME_NAMES; ++i )
                    {
                        WCHAR strGameName[ MAX_GAME_NAME ];
                        GenRandom( strGameName, MAX_GAME_NAME );
                        m_GameNames.push_back( strGameName );
                    }

                    // Start at the top of the list
                    m_CurrItem = 0;

                    m_State = STATE_SELECT_NAME;

                    break;
                }
                case MAIN_MENU_JOIN_GAME:
                    // Begin searching for games on the network
                    SendFindGame();
                    m_GameSearchTimer.StartZero();
                    m_State = STATE_GAME_SEARCH;


                    break;
            }
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = MAIN_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == MAIN_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGame()
// Desc: Animate game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGame( Event ev )
{
    if( !m_bIsOnline )
    {
        // TCR 2-16 Lost Link
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"This Xbox has lost its System Link connection",
                               MAX_ERROR_STR );
        return;
    }

    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Send keep-alives
    if( m_HeartbeatTimer.GetElapsedSeconds() > PLAYER_HEARTBEAT )
    {
        Heartbeat();
        m_HeartbeatTimer.StartZero();
    }

    // Handle other players dropping
    if( ProcessPlayerDropouts() )
        return;

    switch( ev )
    {
        case EV_BUTTON_A:
            switch( m_CurrItem )
            {
                case GAME_MENU_WAVE:
                    Wave();
                    break;
                case GAME_MENU_VOICE:
                    StartVoice();
                    break;
                case GAME_MENU_LEAVE_GAME:
                    Init();
                    break;
            }
            break;
        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = GAME_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == GAME_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveHelp()
// Desc: Animate help
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveHelp( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    if( ev != EV_NULL )
        m_State = m_LastState;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectName()
// Desc: Animate game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectName( Event ev )
{
    // TCR 3-58 Naming of Game Sessions

    // Allow the player to cancel out of game name selection
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:

            // Use the selected namne
            lstrcpyW( m_strGameName, m_GameNames[ m_CurrItem ].c_str() );

            // Destroy the name list; we don't need it anymore
            m_GameNames.clear();

            // Set the default game item to "wave"
            m_CurrItem = 0;

            // Display when game begins
            lstrcpynW( m_strStatus, L"Game started", MAX_STATUS_STR );

            // If we have the local address, begin the game.
            // Otherwise, acquire the local address.
            if( m_bHaveLocalAddress )
            {
                m_State = STATE_GAME;
                m_HeartbeatTimer.StartZero();
            }
            else
                m_State = STATE_START_NEW_GAME;
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_GameNames.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_GameNames.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveStartGame()
// Desc: Animate start game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveStartGame( Event ev )
{
    // Allow the player to cancel out of game startup
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // Asynchronous local address acquisition
    DWORD dwStatus = XNetGetTitleXnAddr( &m_xnTitleAddress );
    assert( dwStatus != XNET_GET_XNADDR_NONE );

    // If we've retrieved the local address, we're done
    m_bHaveLocalAddress = ( dwStatus != XNET_GET_XNADDR_PENDING );

    // When startup is complete, enter the game
    if( m_bHaveLocalAddress )
    {   
        m_HeartbeatTimer.StartZero();
        m_State = STATE_GAME;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGameSearch()
// Desc: Animate game search
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGameSearch( Event ev )
{
    // Allow the player to cancel out of game search
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // See if any games have replied
    if( ProcessBroadcastMessage() )
        return;

    // We search for up to GAME_SEARCH_TIME seconds. If the game 
    // search is complete, display the list of available games. If no games
    // were found, display an error message
    if( m_GameSearchTimer.GetElapsedSeconds() > GAME_SEARCH_TIME )
    {
        m_GameSearchTimer.Stop();
        if( m_Games.empty() )
        {
            m_State = STATE_ERROR;
            lstrcpynW( m_strError, L"No games available", MAX_ERROR_STR );
        }
        else if( m_Games.size() == 1 )
        {
            // TCR 3-57 Default Choices for System Link Play
            // One game; join automatically
            InitiateJoin( 0 );
        }
        else // at least two games
        {
            // at least two games; allow player selection
            m_State = STATE_SELECT_GAME;
            m_CurrItem = 0;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectGame()
// Desc: Animate game selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectGame( Event ev )
{
    if( !m_bIsOnline )
    {
        // TCR 2-16 Lost Link
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"This Xbox has lost its System Link connection",
                               MAX_ERROR_STR );
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:
            InitiateJoin( m_CurrItem );
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_Games.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_Games.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveRequestJoin()
// Desc: Animate join request
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveRequestJoin( Event ev )
{
    // Allow the player to cancel out of join request
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // See if the game has replied
    ProcessDirectMessage();

    // We wait for up to GAME_JOIN_TIME seconds. If the game didn't
    // respond, display an error message
    if( m_GameJoinTimer.GetElapsedSeconds() > GAME_JOIN_TIME )
    {
        m_GameJoinTimer.Stop();
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Game did not respond", MAX_ERROR_STR );
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveError()
// Desc: Animate error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveError( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Any button exits
    if( ev != EV_NULL )
        Init();
}





//-----------------------------------------------------------------------------
// Name: RenderMenu()
// Desc: Display menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenu()
{
    RenderHeader();

    const WCHAR* const strMenu[] =
    {
        L"Start New Game",
        L"Join Existing Game",
    };

    FLOAT fYtop = 200.0f;
    FLOAT fYdelta = 50.0f;

    // TCR 3-44 System Link Play Menu Option
    for( DWORD i = 0; i < MAIN_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i && m_bIsOnline ) ? COLOR_HIGHLIGHT : 
                                                             COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    if( m_bIsOnline )
        RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );

    m_Font.DrawText( 320, 400, COLOR_NORMAL, m_bIsOnline ? 
                     L"System Link Connected" :
                     L"System Link NOT Connected", XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderGame()
// Desc: Display game
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGame()
{
    RenderHeader();

    // Game name and player name
    WCHAR strGameInfo[ 32 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
    wsprintfW( strGameInfo, L"Game name: %.*s\nYour name: %.*s", 
               MAX_GAME_NAME, m_strGameName, MAX_PLAYER_NAME, m_strPlayerName );
    m_Font.DrawText( 220, 110, COLOR_GREEN, strGameInfo );

    // Number of players and current status
    wsprintfW( strGameInfo, L"Players in game: %lu", m_Players.size() + 1 );
    m_Font.DrawText( 220, 158, COLOR_GREEN, strGameInfo );
    m_Font.DrawText( 220, 184, COLOR_GREEN, m_strStatus );

    // Game options menu
    const WCHAR* const strMenu[] =
    {
        L"Wave To Other Players",
        L"Voice",
        L"Leave Game",
    };

    FLOAT fYtop = 240.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( DWORD i = 0; i < GAME_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderHelp()
// Desc: Display help
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHelp()
{
    XBHELP_CALLOUT HelpCallouts[] =
    {
        { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
        { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Select menu\nitem" },
        { XBHELP_B_BUTTON, XBHELP_PLACEMENT_1, L"Cancel" },
        { XBHELP_DPAD, XBHELP_PLACEMENT_1, L"Menu navigation" },
    };
    m_Help.Render( &m_Font, HelpCallouts, 4 );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectName()
// Desc: Display game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectName()
{
    assert( !m_GameNames.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select a game name\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;

    // Show list of game names
    for( DWORD i = 0; i < m_GameNames.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 280, fYtop + (fYdelta * i), dwColor, 
                         m_GameNames[i].c_str() );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 240.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderStartGame()
// Desc: Display game startup sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderStartGame()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Starting Game\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderGameSearch()
// Desc: Display game search sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGameSearch()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Searching For Active Games\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectGame()
// Desc: Display list of available games
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectGame()
{
    assert( !m_Games.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select game to join\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 50.0f;

    // Show list of games
    for( DWORD i = 0; i < m_Games.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        WCHAR strGameInfo[ 64 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
        wsprintfW( strGameInfo, L"\"%.*s\" hosted by \"%.*s\"; players: %d",
                   MAX_GAME_NAME, m_Games[i].strGameName,
                   MAX_PLAYER_NAME, m_Games[i].strHostName,
                   INT(m_Games[i].byNumPlayers) );

        // Denote full games
        if( m_Games[i].byNumPlayers == MAX_PLAYERS )
            lstrcatW( strGameInfo, L" (full)" );

        m_Font.DrawText( 140, fYtop + (fYdelta * i), dwColor, strGameInfo );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 100.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderRequestJoin()
// Desc: Display join request sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderRequestJoin()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Joining game", 
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderError()
{
    RenderHeader();
    m_Font.DrawText( 320, 200, 0xffffffff, m_strError, XBFONT_CENTER_X );
    m_Font.DrawText( 320, 260, 0xffffffff, L"Press A to continue", 
                     XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderHeader()
// Desc: Display standard text
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHeader()
{
    WCHAR strName[32];
    lstrcpyW( strName, L"VoiceChat" );
    if( m_bIsHost )
        lstrcatW( strName, L" (host)" );

    m_Font.DrawText(  64, 50, 0xffffffff, strName );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
}




//-----------------------------------------------------------------------------
// Name: RenderMenuSelector()
// Desc: Display menu selector
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenuSelector( FLOAT fLeft, FLOAT fTop )
{
    D3DXVECTOR4 rc( fLeft, fTop, fLeft + 20.0f, fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: InitiateJoin()
// Desc: Send a join request to the specified game
//-----------------------------------------------------------------------------
VOID CXBoxSample::InitiateJoin( DWORD iCurrGame )
{
    // Determine which game the player wants to join
    GameInfo gameInfo = m_Games[ iCurrGame ];

    // Establish a session with the host game
    INT iResult = XNetRegisterKey( &gameInfo.xnHostKeyID, 
                                   &gameInfo.xnHostKey );
    assert( iResult == NO_ERROR );
    if( iResult == NO_ERROR )
    {
        assert( m_bIsSessionRegistered == FALSE );
        m_bIsSessionRegistered = TRUE;

        // Save the key ID because we need to unregister it
        // Note that we don't need the key itself once it's been registered.
        CopyMemory( &m_xnHostKeyID, &gameInfo.xnHostKeyID, sizeof( XNKID ) );

        // Save the game and player name of the host
        lstrcpynW( m_strGameName, gameInfo.strGameName, MAX_GAME_NAME );
        lstrcpynW( m_strHostName, gameInfo.strHostName, MAX_PLAYER_NAME );

        // Convert the XNADDR of the host to the INADDR we'll use to
        // join the game
        iResult = XNetXnAddrToInAddr( &gameInfo.xnHostAddr,
                                      &m_xnHostKeyID, &m_inHostAddr );
        assert( iResult == NO_ERROR );

        // Request join approval from the game and await a response
        SendJoinGame( CXBSockAddr( m_inHostAddr, DIRECT_PORT ) );
        m_GameJoinTimer.StartZero();
        m_State = STATE_REQUEST_JOIN;
    }
    else
    {
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Unable to establish session with game",
                   MAX_ERROR_STR );
        LogXNetError( "XNetRegisterKey", iResult );
    }

    // Don't need the game list anymore
    DestroyGameList();
}




//-----------------------------------------------------------------------------
// Name: Wave()
// Desc: Wave to other players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Wave()
{
    // Indicate that you waved
    lstrcpynW( m_strStatus, L"You waved", MAX_STATUS_STR );

    // Send a "wave" message to each of the other players in the game
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendWave( CXBSockAddr( i->inAddr, DIRECT_PORT ) );

}

//-----------------------------------------------------------------------------
// Name: Voice()
// Desc: Send voice to other players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessVoice()
{
    if( NULL != m_pCommunicatorMgr )
    {
        HRESULT hr = m_pCommunicatorMgr->Process(m_msgCommunicatorStatus);
        if( FAILED( hr ) )
        {
            //
            // Disable voice
            //
            DebugPrint("CXBoxSample::Exit voice...\n");

            delete m_pCommunicatorMgr;
            m_pCommunicatorMgr =  NULL;

            // Indicate that voice is disabled
            lstrcpynW( m_strStatus, L"Voice chat disabled!", MAX_STATUS_STR );
        }
        else
        {
            AdvertiseVoicePorts();
        }
    }
}

//-----------------------------------------------------------------------------
// Name: StartVoice()
// Desc: Initialize voice
//-----------------------------------------------------------------------------
VOID CXBoxSample::StartVoice()
{
    // Initialize the headset
    if(NULL == m_pCommunicatorMgr)
    {
        m_pCommunicatorMgr = new CCommunicatorMgr;
        HRESULT hr = m_pCommunicatorMgr->Initialize(m_Players , WAVE_FORMAT_VOXWARE_SC06 , m_msgCommunicatorStatus);
        
        if( FAILED( hr ) )
        {
            delete m_pCommunicatorMgr;
            m_pCommunicatorMgr = NULL;
            lstrcpynW( m_strStatus, L"Could not detect headset!", MAX_STATUS_STR );
        }
        else
        {
            // Indicate that you sent voice
            lstrcpynW( m_strStatus, L"Voice chat enabled!", MAX_STATUS_STR );
            AdvertiseVoicePorts();
        }
    }
}

//-----------------------------------------------------------------------------
// Name: AdvertiseVoicePorts()
// Desc: Send the voiceports to players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::AdvertiseVoicePorts()
{
    for( BYTE k = 0; k < COMMUNICATOR_COUNT ; k++ )
    {
        if( NO_ACTION != m_msgCommunicatorStatus[k].action )
        {
            for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
            {
                SendVoicePort((ACTION)m_msgCommunicatorStatus[k].action ,
                               m_msgCommunicatorStatus[k].wVoicePort , CXBSockAddr( i->inAddr, DIRECT_PORT ) );
        
            }
            if(DELETE_PORT == m_msgCommunicatorStatus[k].action)
            {
                m_msgCommunicatorStatus[k].wVoicePort = 0;
            }
            m_msgCommunicatorStatus[k].action = NO_ACTION;
        }
    }
}


//-----------------------------------------------------------------------------
// Name: RespondToVoicePorts()
// Desc: Respond to a request of advertising my voice ports
//-----------------------------------------------------------------------------
VOID CXBoxSample::RespondToVoicePorts(const CXBSockAddr& saFrom)
{
    for( BYTE k = 0; k < COMMUNICATOR_COUNT ; k++ )
    {
        if( 0 != m_msgCommunicatorStatus[k].wVoicePort )
        {
            SendVoicePort(ADD_PORT , m_msgCommunicatorStatus[k].wVoicePort , saFrom );
        }
    }
}

//-----------------------------------------------------------------------------
// Name: Heartbeat()
// Desc: Send heartbeat to players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Heartbeat()
{
    // Send a "heartbeat" message to each of the other players in the game
    // to let them know we're alive
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendHeartbeat( CXBSockAddr( i->inAddr, DIRECT_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Teardown any active games and player lists and return to main menu
//       Unregisters any active sessions.
//-----------------------------------------------------------------------------
VOID CXBoxSample::Init()
{
    //Turn off headsets
    if(NULL != m_pCommunicatorMgr)
    {

        for( BYTE i = 0 ; i < COMMUNICATOR_COUNT ; i++)
        {
            if( 0 != m_msgCommunicatorStatus[i].wVoicePort )
            {
                m_msgCommunicatorStatus[i].action = DELETE_PORT;
            }
        }

        AdvertiseVoicePorts();
        delete m_pCommunicatorMgr;
        m_pCommunicatorMgr =  NULL;
    }   


    // Don't clear m_bXnetStarted. We don't need to reinitialize Xnet once
    // it's been started.

    // Don't clear m_bHaveLocalAddress or m_xnTitleAddress. We don't need to 
    // reacquire the address once we have it.

    m_State     = STATE_MENU;
    m_LastState = STATE_MENU;
    m_CurrItem  = 0;

    m_GameNames.clear();
    DestroyGameList();
    DestroyPlayerList();

    *m_strError = 0;
    *m_strStatus = 0;

    m_LinkStatusTimer.Stop();
    m_GameSearchTimer.Stop();
    m_GameJoinTimer.Stop();
    m_HeartbeatTimer.Stop();

    m_bIsHost = FALSE;

 

    // Unregister the game session key
    if( m_bIsSessionRegistered )
    {
        INT iResult = XNetUnregisterKey( &m_xnHostKeyID );
        assert( iResult == NO_ERROR );
        (VOID)iResult;
        m_bIsSessionRegistered = FALSE;
    }

    // Obliterate old keys and XNADDR
    ZeroMemory( &m_xnHostKeyID,       sizeof( XNKID ) );
    ZeroMemory( &m_xnHostKeyExchange, sizeof( XNKEY ) );
    m_inHostAddr.s_addr = 0;

    // Close down the sockets
    m_BroadSock.Close();
    m_DirectSock.Close();

    *m_strGameName   = 0;
    *m_strPlayerName = 0;
    *m_strHostName   = 0;

    ZeroMemory( &m_Nonce, sizeof(m_Nonce) );

    // Generate random player name
    // A real Xbox game would get this information from the player
    GenRandom( m_strPlayerName, MAX_PLAYER_NAME );


}




//-----------------------------------------------------------------------------
// Name: InitXNet()
// Desc: Initialize the network stack. Returns FALSE if Xbox is not connected.
//-----------------------------------------------------------------------------
CXBoxSample::InitStatus CXBoxSample::InitXNet()
{
    if( !m_bIsOnline )
        return NotConnected;

    // Only need to initialize network stack one time
    if( !m_bXnetStarted )
    {
        // Initialize the network stack
        INT iResult = XNetStartup( NULL );
        if( iResult != NO_ERROR )
        {
            LogXNetError( "XNetStartup", iResult );
            return InitFailed;
        }

        // Standard WinSock startup
        WSADATA WsaData;
        iResult = WSAStartup( MAKEWORD(2,2), &WsaData );
        if( iResult != NO_ERROR )
        {
            LogXNetError( "WSAStartup", iResult );
            return InitFailed;
        }

        m_bXnetStarted = TRUE;
    }

    // The broadcast socket is a non-blocking socket on port BROADCAST_PORT.
    // All broadcast messages are automatically always encrypted.
    BOOL bSuccess = m_BroadSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Broadcast socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr broadAddr( INADDR_ANY, BROADCAST_PORT );
    INT iResult = m_BroadSock.Bind( broadAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    DWORD dwNonBlocking = 1;
    iResult = m_BroadSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );
    BOOL bBroadcast = TRUE;
    iResult = m_BroadSock.SetSockOpt( SOL_SOCKET, SO_BROADCAST,
                                      &bBroadcast, sizeof(bBroadcast) );
    assert( iResult != SOCKET_ERROR );

    // The direct socket is a non-blocking socket on port DIRECT_PORT.
    // Sockets are encrypted by default, but can have encryption disabled
    // as an optimization for non-secure messaging
    bSuccess = m_DirectSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Direct socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr directAddr( INADDR_ANY, DIRECT_PORT );
    iResult = m_DirectSock.Bind( directAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    iResult = m_DirectSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );

    // Note that this sample does not call either WSACleanup() or 
    // XNetCleanup(). These functions should be called by your game to
    // free system resources when the player is no longer online but
    // is still playing the game (e.g. switched to single-player mode).

    return Success;
}




//-----------------------------------------------------------------------------
// Name: SendFindGame()
// Desc: Broadcast a MSG_FIND_GAME from our client to any available host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendFindGame()
{
    assert( !m_bIsHost );
    Message msgFindGame( MSG_FIND_GAME );
    MsgFindGame& msg = msgFindGame.GetFindGame();

    // Generate a nonce (random bytes). When a potential host responds with
    // information about a game, he must respond via a broadcast message
    // since a secure session hasn't been established. The broadcast message
    // will contain the same nonce so we can verify that message is really
    // for us. If we receive a broadcast "found game" message with a different
    // nonce, we ignore it, because it was broadcast to a different client
    // than us.
    INT iResult = XNetRandom( (BYTE*)(&msg.nonce), sizeof(msg.nonce) );
    assert( iResult == NO_ERROR );
    (VOID)iResult;

    // Save the nonce for comparison later
    CopyMemory( &m_Nonce, &msg.nonce, sizeof(msg.nonce) );

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgFindGame, msgFindGame.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgFindGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendGameFound()
// Desc: Broadcast a MSG_GAME_FOUND from our host to the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendGameFound( const Nonce& nonceClient )
{
    assert( m_bIsHost );
    Message msgGameFound( MSG_GAME_FOUND );
    MsgGameFound& msg = msgGameFound.GetGameFound();

    // Resend the nonce that we received from the client so he can verify
    // that this message is really for him
    CopyMemory( &msg.nonce, &nonceClient, sizeof(nonceClient) );

    // Send information about the session that we're hosting
    CopyMemory( &msg.xnHostKeyID, &m_xnHostKeyID,       sizeof(XNKID) );
    CopyMemory( &msg.xnHostKey,   &m_xnHostKeyExchange, sizeof(XNKEY) );
    CopyMemory( &msg.xnHostAddr,  &m_xnTitleAddress,    sizeof(XNADDR) );

    // Send the current information about the game
    msg.byNumPlayers = BYTE( m_Players.size() + 1 );
    lstrcpynW( msg.strGameName, m_strGameName, MAX_GAME_NAME );
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // We don't have the XNADDR of the requesting client, so we
    // can't send this message directly back. Instead, we broadcast the
    // message to everybody on the net. The requesting client can
    // check the nonce to verify that the response is really for them.
    // Broadcast messages are automatically encrypted.

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgGameFound, msgGameFound.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgGameFound.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinGame()
// Desc: Issue a MSG_JOIN_GAME from our client to the game host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinGame( const CXBSockAddr& saGameHost )
{
    assert( !m_bIsHost );
    Message msgJoinGame( MSG_JOIN_GAME );
    MsgJoinGame& msg = msgJoinGame.GetJoinGame();

    // Include our player name
    lstrcpynW( msg.strPlayerName, m_strPlayerName, MAX_PLAYER_NAME );

    // We can send this message directly to the host
    INT nBytes = m_DirectSock.SendTo( &msgJoinGame, msgJoinGame.GetSize(),
                                      saGameHost.GetPtr() );
    assert( nBytes == msgJoinGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinApproved()
// Desc: Issue a MSG_JOIN_APPROVED from our host to the requesting client.
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinApproved( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinApproved( MSG_JOIN_APPROVED );
    MsgJoinApproved& msg = msgJoinApproved.GetJoinApproved();

    // The host is us
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // Send the list of all the current players to the new player.
    // We don't send the host player info, since the new player 
    // already has all of the information it needs about the host player.
    msg.byNumPlayers = BYTE( m_Players.size() );
    BYTE j = 0;
    for( PlayerList::const_iterator i = m_Players.begin(); 
         i != m_Players.end(); ++i, ++j )
    {
        PlayerInfo playerInfo = *i;
        CopyMemory( &msg.PlayerList[j].xnAddr, &playerInfo.xnAddr, 
                    sizeof( XNADDR ) );
        lstrcpynW( msg.PlayerList[j].strPlayerName, 
                   playerInfo.strPlayerName, MAX_PLAYER_NAME );
    }

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinApproved, msgJoinApproved.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinApproved.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinDenied()
// Desc: Issue a MSG_JOIN_DENIED from our host to the requesting client
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinDenied( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinDenied( MSG_JOIN_DENIED );

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinDenied, msgJoinDenied.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinDenied.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendPlayerJoined()
// Desc: Issue a MSG_PLAYER_JOINED from our host to a player in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendPlayerJoined( const Player& player, const CXBSockAddr& saPlayer )
{
    assert( m_bIsHost );
    Message msgPlayerJoined( MSG_PLAYER_JOINED );
    MsgPlayerJoined& msg = msgPlayerJoined.GetPlayerJoined();

    // The payload is the information about the player who just joined
    CopyMemory( &msg.player, &player, sizeof(player) );

    // We send this message directly to the player
    INT nBytes = m_DirectSock.SendTo( &msgPlayerJoined, msgPlayerJoined.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgPlayerJoined.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Issue a MSG_WAVE from ourself (either a host or player) to another
//       player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendWave( const CXBSockAddr& saPlayer )
{
    Message msgWave( MSG_WAVE );
    INT nBytes = m_DirectSock.SendTo( &msgWave, msgWave.GetSize(), 
                                      saPlayer.GetPtr() );
    assert( nBytes == msgWave.GetSize() );
    (VOID)nBytes;
}

//-----------------------------------------------------------------------------
// Name: SendVoicePort()
// Desc: Issue a MSG_VOICEPORT from ourself (either a host or player) to another
//       player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendVoicePort( ACTION action , WORD wVoicePort , const CXBSockAddr& saPlayer )
{
    Message msgVoicePort( MSG_VOICEPORT );
    MsgVoicePort& msg = msgVoicePort.GetMsgVoicePort();
    msg.action = action;
    msg.wVoicePort = wVoicePort;

    INT nBytes = m_DirectSock.SendTo( &msgVoicePort, msgVoicePort.GetSize(), 
                                      saPlayer.GetPtr() );
    assert( nBytes == msgVoicePort.GetSize() );
    (VOID)nBytes;
}

//-----------------------------------------------------------------------------
// Name: SendHeartbeat()
// Desc: Issue a MSG_HEARTBEAT from ourself (either a host or player) to
//       another player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendHeartbeat( const CXBSockAddr& saPlayer )
{
    // Send the heartbeat
    Message msgHeartbeat( MSG_HEARTBEAT );
    INT nBytes = m_DirectSock.SendTo( &msgHeartbeat, msgHeartbeat.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgHeartbeat.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: ProcessBroadcastMessage()
// Desc: Checks to see if any broadcast messages are waiting on the broadcast
//       socket. If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessBroadcastMessage()
{
    if( !m_BroadSock.IsOpen() )
        return FALSE;

    // See if a network broadcast message is waiting for us
    Message msg;
    INT iResult = m_BroadSock.Recv( &msg, msg.GetMaxSize() );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessDirectMessage()
// Desc: Checks to see if any direct messages are waiting on the direct socket.
//       If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessDirectMessage()
{
    if( !m_DirectSock.IsOpen() )
        return FALSE;

    // See if a network message is waiting for us
    Message msg;
    SOCKADDR_IN saFromIn;
    INT iResult = m_DirectSock.RecvFrom( &msg, msg.GetMaxSize(), &saFromIn );
    CXBSockAddr saFrom( saFromIn );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg, saFrom );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes broadcast messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_FIND_GAME:  ProcessFindGame( msg.GetFindGame() );   break;

        // From host to client: processed by client
        case MSG_GAME_FOUND: ProcessGameFound( msg.GetGameFound() ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes any direct messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg, const CXBSockAddr& saFrom )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_JOIN_GAME:     ProcessJoinGame( msg.GetJoinGame(), saFrom ); break;

        // From host to client: processed by client
        case MSG_JOIN_APPROVED: ProcessJoinApproved( msg.GetJoinApproved(), saFrom ); break;
        case MSG_JOIN_DENIED:   ProcessJoinDenied( saFrom ); break;
        case MSG_PLAYER_JOINED: ProcessPlayerJoined( msg.GetPlayerJoined(), saFrom ); break;

        // From player to player: processed by client player
        case MSG_WAVE:          ProcessWave( saFrom ); break;
        case MSG_HEARTBEAT:     ProcessHeartbeat( saFrom ); break;
        case MSG_VOICEPORT:     ProcessVoicePort( msg.GetMsgVoicePort() , saFrom ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessFindGame()
// Desc: Process the find game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessFindGame( const MsgFindGame& findGame )
{
    // If we're not hosting a game, we don't care about receiving "find game"
    // messages. Only hosts respond to "find game" messages
    if( !m_bIsHost )
        return;

    // We're hosting a game
    // Respond with the game information
    SendGameFound( findGame.nonce );
}




//-----------------------------------------------------------------------------
// Name: ProcessGameFound()
// Desc: Process the game found message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessGameFound( const MsgGameFound& gameFound )
{
    // If we're hosting, we don't care about receiving "game found" messages.
    // Only potential clients care about "game found" messages.
    if( m_bIsHost )
        return;

    // If we didn't send the corresponding "find game" message, we don't
    // care about this particular "game found" message
    if( memcmp( &gameFound.nonce, &m_Nonce, NONCE_BYTES ) != 0 )
        return;

    // We found a game!
    // Add it to our list of potential games
    GameInfo gameInfo;
    CopyMemory( &gameInfo.xnHostKeyID, &gameFound.xnHostKeyID, sizeof( XNKID ) );
    CopyMemory( &gameInfo.xnHostKey,   &gameFound.xnHostKey,   sizeof( XNKEY ) );
    CopyMemory( &gameInfo.xnHostAddr,  &gameFound.xnHostAddr,  sizeof( XNADDR ) );
    gameInfo.byNumPlayers = gameFound.byNumPlayers;
    lstrcpynW( gameInfo.strGameName, gameFound.strGameName, MAX_GAME_NAME );
    lstrcpynW( gameInfo.strHostName, gameFound.strHostName, MAX_PLAYER_NAME );

    m_Games.push_back( gameInfo );
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinGame()
// Desc: Process the join game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinGame( const MsgJoinGame& joinGame,
                                   const CXBSockAddr& saFrom )
{
    // Only hosts should receive "join game" messages
    assert( m_bIsHost );

    // If for some reason we receive a "join game" message and we're not a
    // host, ignore it. Only hosts respond to "join game" messages
    if( !m_bIsHost )
        return;

    // We're hosting

    // A session exists between us (the host) and the client. We can now
    // convert the incoming IP address (saFrom) into a valid XNADDR.
    XNADDR xnAddrClient;
    INT iResult = XNetInAddrToXnAddr( saFrom.GetInAddr(), &xnAddrClient, 
                                      &m_xnHostKeyID );
    if( iResult == SOCKET_ERROR )
    {
        // If the client INADDR can't be converted to an XNADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetInAddrToXnAddr", iResult );
        assert( FALSE );
        return;
    }

    // A player may join if we haven't reached the player limit.
    // In a real game, you would need to "lock" the game during a join
    // or track the number of joins in progress so that if multiple
    // players were attempting to join at the same time, they wouldn't
    // all be granted access and then exceed the player maximum.
    if( m_Players.size() + 1 < MAX_PLAYERS )
    {
        SendJoinApproved( saFrom );

        // Notify the other players about the new guy
        Player player;
        CopyMemory( &player.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        lstrcpynW( player.strPlayerName, joinGame.strPlayerName, MAX_PLAYER_NAME );
        
        for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
            SendPlayerJoined( player, CXBSockAddr( i->inAddr, DIRECT_PORT ) );

        // Add this new player to our player list
        PlayerInfo playerInfo;
        CopyMemory( &playerInfo.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        playerInfo.inAddr = saFrom.GetInAddr();
        lstrcpynW( playerInfo.strPlayerName, joinGame.strPlayerName, 
                   MAX_PLAYER_NAME );
        playerInfo.dwLastHeartbeat = GetTickCount();
        
        m_Players.push_back( playerInfo );

        // Update status
        wsprintfW( m_strStatus, L"%.*s has joined the game", 
                   MAX_PLAYER_NAME, player.strPlayerName );
    }
    else
    {
        SendJoinDenied( saFrom );
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinApproved()
// Desc: Process the join approved message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinApproved( const MsgJoinApproved& joinApproved, 
                                       const CXBSockAddr& saFrom )
{
    // Only clients should receive "join approved" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join approved" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Add the host to the list of players (always at position 0 )
    PlayerInfo hostInfo;

    // Client doesn't need the XNADDR of the host, so we just leave it zero.
    // This data member is only used by hosts.
    ZeroMemory( &hostInfo.xnAddr, sizeof( XNADDR ) );
    hostInfo.inAddr = saFrom.GetInAddr();
    lstrcpynW( hostInfo.strPlayerName, joinApproved.strHostName, MAX_PLAYER_NAME );
    hostInfo.dwLastHeartbeat = GetTickCount();

    assert( m_Players.empty() );
    m_Players.push_back( hostInfo );

    // Build the list of the other players
    for( BYTE i = 0; i < joinApproved.byNumPlayers; ++i )
    {
        PlayerInfo playerInfo;

        // Convert the XNADDR of the player to the INADDR we'll use to wave
        // to the player
        INT iResult = XNetXnAddrToInAddr( &joinApproved.PlayerList[ i ].xnAddr,
                                          &m_xnHostKeyID, &playerInfo.inAddr );
        if( iResult == SOCKET_ERROR )
        {
            // If the client XNADDR can't be converted to an INADDR, then
            // the client does not have a valid session established, and
            // we ignore that client.
            assert( FALSE );
            LogXNetError( "XNetXnAddrToInAddr", iResult );
            continue;
        }

        // Client doesn't need the XNADDR of the host anymore, 
        // so we just leave it zero. This data member is only used by hosts.
        ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

        // Save the player name
        lstrcpynW( playerInfo.strPlayerName, 
                   joinApproved.PlayerList[ i ].strPlayerName, MAX_PLAYER_NAME );

        // Last heartbeat
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );
    }

    // Enter into the game UI
    m_State = STATE_GAME;

    // Set the default game item to "wave"
    m_CurrItem = 0;

    lstrcpynW( m_strStatus, L"You have joined the game", MAX_STATUS_STR );
    m_HeartbeatTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinDenied()
// Desc: Process the join denied message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinDenied( const CXBSockAddr& )
{
    // Only clients should receive "join denied" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join denied" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Only clients who are not currently playing should receive this message
    assert( m_State != STATE_GAME );

    // If for some reason we receive a "join denied" message and we're
    // already playing a game, ignore the message.
    if( m_State == STATE_GAME )
        return;

    // The game we wanted to join is full. Display error
    m_State = STATE_ERROR;
    lstrcpynW( m_strError, L"The game is full.\nChoose another game.",
               MAX_ERROR_STR );
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayerJoined()
// Desc: Process the player joined message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessPlayerJoined( const MsgPlayerJoined& playerJoined, 
                                       const CXBSockAddr& saFrom )
{
    // saFrom is the address of the host that sent this message, but we
    // we already have his address, so throw it away
    (VOID)saFrom;

    const Player& player = playerJoined.player;
    PlayerInfo playerInfo;

    // Convert the XNADDR of the player to the INADDR we'll use to wave
    // to the player
    INT iResult = XNetXnAddrToInAddr( &player.xnAddr, &m_xnHostKeyID,
                                      &playerInfo.inAddr );
    if( iResult == SOCKET_ERROR )
    {
        // If the client XNADDR can't be converted to an INADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetXnAddrToInAddr", iResult );
        assert( FALSE );
        return;
    }

    // Client doesn't need the XNADDR of the host anymore, 
    // so we just leave it zero. This data member is only used by hosts.
    ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

    // Save the player name
    lstrcpynW( playerInfo.strPlayerName, player.strPlayerName, MAX_PLAYER_NAME );

    // Last heartbeat
    playerInfo.dwLastHeartbeat = GetTickCount();

    // Add the new player to our list
    m_Players.push_back( playerInfo );

    // Update status
    wsprintfW( m_strStatus, L"%.*s has joined the game", 
               MAX_PLAYER_NAME, player.strPlayerName );
}




//-----------------------------------------------------------------------------
// Name: ProcessWave()
// Desc: Process the wave message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessWave( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who waved by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update status
    if( i != m_Players.end() )
    {
        wsprintfW( m_strStatus, L"%.*s waved", 
                   MAX_PLAYER_NAME, i->strPlayerName );
    }
}

//-----------------------------------------------------------------------------
// Name: ProcessVoicePort()
// Desc: Process the voiceport message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessVoicePort(const MsgVoicePort& msg,  const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who waved by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update 
    if( i != m_Players.end() )
    {
        if( NULL !=  m_pCommunicatorMgr)
        {
            switch(msg.action)
            {
            case ADD_AND_RESPOND:
                RespondToVoicePorts(saFrom);
            case ADD_PORT:
                m_pCommunicatorMgr->UpdateChatList( TRUE , saFrom.GetInAddr() , msg.wVoicePort);
                break;
            case DELETE_PORT:
                m_pCommunicatorMgr->UpdateChatList( FALSE , saFrom.GetInAddr() , msg.wVoicePort);
                break;
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Name: ProcessHeartbeat()
// Desc: Process the heartbeat message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessHeartbeat( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who sent a heartbeat by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update that player's heartbeat time
    if( i != m_Players.end() )
        i->dwLastHeartbeat = GetTickCount();
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayersDropouts()
// Desc: Process players and determine if anybody has left the game
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessPlayerDropouts()
{
    DWORD dwTickCount = GetTickCount();
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
    {
        PlayerInfo playerInfo = *i;
        DWORD dwElapsed = dwTickCount - playerInfo.dwLastHeartbeat;
        if( dwElapsed > PLAYER_TIMEOUT )
        {
            // This player hasn't sent a heartbeat message in a long time.
            // Assume they left the game.

            wsprintfW( m_strStatus, L"%.*s left the game", 
                       MAX_PLAYER_NAME, playerInfo.strPlayerName );

            // Delete the player from the list
            if( NULL !=  m_pCommunicatorMgr)
            {
                m_pCommunicatorMgr->UpdateChatList(FALSE , playerInfo.inAddr);
            }

            m_Players.erase( i );


            return TRUE;
        }
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: DestroyGameList()
// Desc: Clear the list of games
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyGameList()
{
    // Physically clear the list of games to obliterate the key and XNADDR info
    // from prying eyes. This particular method works because m_Games 
    // is a vector; if m_Games is not a vector each game must be 
    // cleared individually
    if( !m_Games.empty() )
    {
        GameInfo* pGameList = &m_Games[0];
        ZeroMemory( pGameList, m_Games.size() * sizeof( GameInfo ) );

        // Destroy the list of games
        m_Games.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: DestroyPlayerList()
// Desc: Clear the list of players
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyPlayerList()
{
    // Physically clear the list of players to obliterate the XNADDR info
    // from prying eyes. This particular method works because m_Players
    // is a vector; if m_Players is not a vector each player must be 
    // cleared individually
    if( !m_Players.empty() )
    {
        PlayerInfo* pPlayerList = &m_Players[0];
        ZeroMemory( pPlayerList, m_Players.size() * sizeof( PlayerInfo ) );

        // Destroy the list of players
        m_Players.clear();
    }
}

//-----------------------------------------------------------------------------
// Name: GenRandom()
// Desc: Generate a random name
//-----------------------------------------------------------------------------
VOID CXBoxSample::GenRandom( WCHAR* strName, DWORD dwSize ) // static
{
    // Name consists of two to five parts.
    //
    // 1) consonant or consonant group (e.g. th, qu, st) [optional]
    // 2) vowel or vowel group (e.g. ea, ee, au)
    // 3) consonant or consonant group
    // 4) vowel or vowel group [optional]
    // 5) consonant or consonant group [optional]

    WCHAR strRandom[ 128 ];
    strRandom[ 0 ] = 0;
    if( ( rand() % 2 == 0 ) )
        AppendConsonant( strRandom, TRUE );
    AppendVowel( strRandom );
    AppendConsonant( strRandom, FALSE );
    if( ( rand() % 2 == 0 ) )
    {
        AppendVowel( strRandom );
        if( ( rand() % 2 == 0 ) )
            AppendConsonant( strRandom, FALSE );
    }

    *strRandom = towupper( *strRandom );
    lstrcpynW( strName, strRandom, dwSize );
}




//-----------------------------------------------------------------------------
// Name: GetRandVowel()
// Desc: Get a random vowel
//-----------------------------------------------------------------------------
WCHAR CXBoxSample::GetRandVowel() // static
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( rand() % 26 ) );
        if( wcschr( L"aeiou", c ) != NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: GetRandConsonant()
// Desc: Get a random consonant
//-----------------------------------------------------------------------------
WCHAR CXBoxSample::GetRandConsonant() // static
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( rand() % 26 ) );
        if( wcschr( L"aeiou", c ) == NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: AppendConsonant()
// Desc: Append consonant or consonant group to string
//-----------------------------------------------------------------------------
VOID CXBoxSample::AppendConsonant( WCHAR* strRandom, BOOL bLeading ) // static
{
    if( ( rand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandConsonant(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strLeadConGroup[32] = 
        {
            L"bl", L"br", L"cl", L"cr", L"dr", L"fl", L"fr", L"gh", L"gl", L"gn", 
            L"gr", L"kl", L"kn", L"kr", L"ph", L"pl", L"pr", L"ps", L"qu", L"sc", 
            L"sk", L"sl", L"sn", L"sp", L"st", L"sw", L"th", L"tr", L"vh", L"vl", 
            L"wh", L"zh"
        };
        WCHAR* strTrailConGroup[32] = 
        {
            L"rt", L"ng", L"bs", L"cs", L"ds", L"gs", L"hs", L"sh", L"ss", L"ks",
            L"ms", L"ns", L"ps", L"rs", L"ts", L"gh", L"ph", L"sk", L"st", L"tt",
            L"nd", L"nk", L"nt", L"nx", L"pp", L"rd", L"rg", L"rk", L"rn", L"rv",
            L"th", L"ys"
        };
        if( bLeading )
            lstrcatW( strRandom, strLeadConGroup[ rand() % 32 ] );
        else
            lstrcatW( strRandom, strTrailConGroup[ rand() % 32 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: AppendVowel()
// Desc: Append vowel or vowel group to string
//-----------------------------------------------------------------------------
VOID CXBoxSample::AppendVowel( WCHAR* strRandom ) // static
{
    if( ( rand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandVowel(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strVowelGroup[10] =
        {
            L"ai", L"au", L"ay", L"ea", L"ee", L"ie", L"oa", L"oi", L"oo", L"ou"
        };
        lstrcatW( strRandom, strVowelGroup[ rand() % 10 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: LogXNetError()
// Desc: Log errors to the hard drive. When testing xnets.lib, there's no
//       debugging channel, so it's useful to log failures to the hard drive.
//-----------------------------------------------------------------------------
VOID CXBoxSample::LogXNetError( const CHAR* strError, INT iError ) const
{

    // Make sure that we're not logging anything in the final release
#ifndef FINAL_BUILD

    if( m_hLogFile == INVALID_HANDLE_VALUE )
    {
        m_hLogFile = CreateFile( "U:\\XNetError.log", GENERIC_WRITE, 0, NULL,
                                 CREATE_ALWAYS, 0, NULL );
        if( m_hLogFile == INVALID_HANDLE_VALUE )
            return;
    }

    // Write out the error message
    CHAR strBuffer[256];
    wsprintfA( strBuffer, "%s error: %d\r\n", strError, iError );
    DWORD dwWritten;
    WriteFile( m_hLogFile, strBuffer, lstrlenA( strBuffer ), &dwWritten, NULL );

    // Make sure the message makes it to the disk
    FlushFileBuffers( m_hLogFile );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\Player.h ===
#ifndef _PLAYER_H_
#define _PLAYER_H_


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD COLOR_HIGHLIGHT   = 0xffffff00; // Yellow
const DWORD COLOR_GREEN       = 0xff00ff00;
const DWORD COLOR_NORMAL      = 0xffffffff;
const DWORD MAX_ERROR_STR     = 64;
const DWORD MAX_STATUS_STR    = 128;
const DWORD MAX_GAME_NAMES    = 6;      // Number of game names to choose from
const DWORD NONCE_BYTES       = 8;      // Larger means less chance of random matches
const DWORD MAX_GAME_NAME     = 12;     // Includes null
const DWORD PLAYER_TIMEOUT    = 2000;   // 2 seconds
const FLOAT CHECK_LINK_STATUS = 0.5f;   // Check status twice/sec
const FLOAT PLAYER_HEARTBEAT  = 0.3f;   // ~3 times per second
const FLOAT GAME_JOIN_TIME    = 2.0f;   // 2 seconds


// TCR 3-46 Maximum Number of Connected Xboxes
const DWORD MAX_PLAYERS = 4;            // Max players (may not exceed 16)

// TCR 3-59 Session Discovery Time
const FLOAT GAME_SEARCH_TIME = 2.0f;   // 2 seconds (may not exceed 3)

const DWORD MAX_PLAYER_NAME   = 12;     // Includes null

//-----------------------------------------------------------------------------
// Name: class PlayerInfo
// Desc: Player information used by players to store list of other players
//       in the game
//-----------------------------------------------------------------------------
struct PlayerInfo
{
    XNADDR  xnAddr;                           // XNet address
    IN_ADDR inAddr;                           // Xbox IP (not a "real" IP)
    WCHAR   strPlayerName[ MAX_PLAYER_NAME ]; // player name
    DWORD   dwLastHeartbeat;                  // last heartbeat, in our clocks
};

//-----------------------------------------------------------------------------
// Local Player struct used by some messages
//-----------------------------------------------------------------------------
struct Player
{
    XNADDR xnAddr;                           // player's XNet address
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ]; // player's name
};

typedef std::vector< PlayerInfo >   PlayerList;

//-----------------------------------------------------------------------------
// Name: class GameInfo
// Desc: Game information used by clients to store available games
//-----------------------------------------------------------------------------
struct GameInfo
{
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // name of the game
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // name of the host player
};


//-----------------------------------------------------------------------------
// Name: class MatchInAddr
// Desc: Predicate functor used to match on IN_ADDRs in player lists
//-----------------------------------------------------------------------------
struct MatchInAddr
{
    IN_ADDR ia;
    explicit MatchInAddr( const CXBSockAddr& sa ) : ia( sa.GetInAddr() ) { }
    bool operator()( const PlayerInfo& playerInfo )
    {
        return playerInfo.inAddr.s_addr == ia.s_addr;
    }
};

//-----------------------------------------------------------------------------
// Message IDs
//
// A "host" is the player who started the game.
// A "client" is a potential player. A client is not currently playing a game.
// A "player" is anyone playing a game.
//-----------------------------------------------------------------------------
enum
{                       // From     To      Type        Expected response
                        //-----------------------------------------------------
    MSG_FIND_GAME,      // client   host    broadcast   MSG_GAME_FOUND
    MSG_GAME_FOUND,     // host     client  broadcast   <none>
    MSG_JOIN_GAME,      // client   host    direct      MSG_JOIN_APPROVED/DENIED
    MSG_JOIN_APPROVED,  // host     client  direct      <none>
    MSG_JOIN_DENIED,    // host     client  direct      <none>
    MSG_PLAYER_JOINED,  // host     player  direct      <none>
    MSG_WAVE,           // player   player  direct      <none>
    MSG_HEARTBEAT,      // player   player  direct      <none>
	MSG_VOICEPORT       // player   player  direct      <MSG_VOICE_PORT> if requested 
    
};

//-----------------------------------------------------------------------------
// Message payloads
//-----------------------------------------------------------------------------
// Pack to minimize network traffic
#pragma pack( push )
#pragma pack( 1 )


//-----------------------------------------------------------------------------
// Local Nonce struct used by some messages
//-----------------------------------------------------------------------------
struct Nonce
{
    // Used for client verification. The larger the number of NONCE_BYTES,
    // the less likely there is to be an accidental match between client & host
    BYTE byRandom[ NONCE_BYTES ]; 
};

//-----------------------------------------------------------------------------
// Broadcast by a client looking for available games
//-----------------------------------------------------------------------------
struct MsgFindGame
{
    Nonce nonce;    // Generated by client; used to verify host response
};

//-----------------------------------------------------------------------------
// Broadcast by a host in response to a MSG_FIND_GAME
//-----------------------------------------------------------------------------
struct MsgGameFound
{
    Nonce  nonce;                          // used for client verification
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // game name
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // game host player name
};

//-----------------------------------------------------------------------------
// Sent from a client to a host to join a game
//-----------------------------------------------------------------------------
struct MsgJoinGame
{
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ];  // player who wants to join
};

//-----------------------------------------------------------------------------
// Sent from a host to a client in response to a MSG_JOIN_GAME
//-----------------------------------------------------------------------------
struct MsgJoinApproved
{
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // host name
    BYTE   byNumPlayers;                   // Players in the game (not incl host)
    Player PlayerList[ MAX_PLAYERS ];      // List of players (not incl host)
};

//-----------------------------------------------------------------------------
// Sent from a host to other players to notify them that a new player has joined
//-----------------------------------------------------------------------------
struct MsgPlayerJoined
{
    Player player; // The latest player to join the game
};

enum ACTION
{
	NO_ACTION , 
	ADD_PORT , 
	DELETE_PORT , 
	ADD_AND_RESPOND
};

struct MsgVoicePort
{
	int  action;      // Action requested from the other player     
	WORD    wVoicePort;  // Port to which the chatter is bound ; 0 means no port for that communicator
};
#pragma pack( pop )



#endif // _PLAYER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\Voice.cpp ===
//-----------------------------------------------------------------------------
// File: Voice.cpp
//
// Hist: 08.08.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Voice.h"

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CCommunicator - abstract base class 
//
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Name: CCommunicator
// Desc: Constructor
//-----------------------------------------------------------------------------
CCommunicator::CCommunicator(
            WORD    wHeadsetPort,
            HANDLE  hEvtMicInput,
            WORD    wCodecTag,
            WORD    wVoiceSamplingRate,
            WORD    wCodecSamplingRate,
            WORD    wVoiceBufferTime,
            WORD    wVoiceBufferCount )
{
#ifdef _WRITE_LOG
    m_hFileRawPCMData   = NULL;
    m_hFileCompressed   = NULL;
    m_hFileDecompressed = NULL; 
#endif

    m_wHeadsetPort                  = wHeadsetPort;
    m_pMicrophone                   = NULL;
    m_pHeadphone                    = NULL;
    m_bCreateMicrophoneEvent        = FALSE;
    m_pEncoder                      = NULL;
    m_hHeadphoneWorkEvent           = INVALID_HANDLE_VALUE;
    m_pBeginMicrophoneQueuedBuffers = NULL;
    m_pBeginHeadphoneQueuedBuffers  = NULL;
    m_hMicrophoneWorkEvent          = hEvtMicInput;
    m_wVoiceSamplingRate            = wVoiceSamplingRate;
    m_wCodecSamplingRate            = wCodecSamplingRate;

    assert( (WAVE_FORMAT_VOXWARE_SC06 == wCodecTag) || (WAVE_FORMAT_VOXWARE_SC03 == wCodecTag));
    m_wCodecTag = wCodecTag;

    m_wVoiceBufferTime      = wVoiceBufferTime;
    m_wVoiceBufferSize      = wVoiceBufferTime * (((WORD)( wVoiceSamplingRate / 1000.0 )) * 2 );
    m_wVoiceBuffersCount    = wVoiceBufferCount;
    m_wCodecBufferSize      = 0;

    m_CodecMediaBuffer.pvBuffer = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CCommunicator
// Desc: Destructor
//-----------------------------------------------------------------------------
CCommunicator::~CCommunicator()
{
    CCommunicator::Cleanup();
}




//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Called at destruction time or when the communicator is removed
//-----------------------------------------------------------------------------
void CCommunicator::Cleanup()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
    }    

    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
        m_pHeadphone = NULL;
    }

    if(m_pEncoder)
    {
        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    if ((m_bCreateMicrophoneEvent) && (INVALID_HANDLE_VALUE != m_hMicrophoneWorkEvent)) 
    {
        CloseHandle(m_hMicrophoneWorkEvent);
        m_hMicrophoneWorkEvent = INVALID_HANDLE_VALUE;
        m_bCreateMicrophoneEvent = FALSE;
    }

    if (INVALID_HANDLE_VALUE != m_hHeadphoneWorkEvent) 
    {
        CloseHandle(m_hHeadphoneWorkEvent);
        m_hHeadphoneWorkEvent = INVALID_HANDLE_VALUE;
    }

    if( NULL != m_pBeginMicrophoneQueuedBuffers )
    {
        DeleteQueue(m_pBeginMicrophoneQueuedBuffers);
        m_pBeginMicrophoneQueuedBuffers = NULL;

    }

    if( NULL != m_pBeginHeadphoneQueuedBuffers )
    {
        DeleteQueue(m_pBeginHeadphoneQueuedBuffers);
        m_pBeginHeadphoneQueuedBuffers = NULL;
    }

    if( NULL != m_CodecMediaBuffer.pvBuffer )
    {
        delete [] m_CodecMediaBuffer.pvBuffer;
        m_CodecMediaBuffer.pvBuffer = NULL;
    }

#ifdef _WRITE_LOG
    CloseFile(&m_hFileRawPCMData);
    CloseFile(&m_hFileCompressed);
    CloseFile(&m_hFileDecompressed);
#endif
}




//-----------------------------------------------------------------------------
// Name: CreateQueue
// Desc: Create a queue of MEDIA_PACKET_LIST of a given size and initialize it
//-----------------------------------------------------------------------------
void CCommunicator::CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wBufferSize, WORD wCount , DWORD dwStatus)
{
    MEDIA_PACKET_LIST *pTmp = NULL;
    MEDIA_PACKET_LIST *pHead = NULL;
    
    // Create linked-list
    for( WORD i = 0 ; i <  wCount ; i++ )
    {
        if( pTmp )
        {
            // Tacking on to end...
            pTmp->pNext = new MEDIA_PACKET_LIST(wBufferSize , dwStatus);
            pTmp = pTmp->pNext;
        }
        else
        {
            // First node
            pTmp = new MEDIA_PACKET_LIST(wBufferSize , dwStatus);
            pHead = pTmp;
        }

        // Check for memory allocation failures
        if( NULL == pTmp )
        {
            break;
        }
        if( NULL == (pTmp->MediaPacket).pvBuffer )
        {
            delete pTmp;
            pTmp = NULL;
            break;
        }
    }

    if(NULL == pTmp)
    {
        // Something went wrong, release allocated memory
        pTmp = pHead;

        while(NULL != pTmp)
        {
            pHead = pTmp->pNext;
            delete pTmp;
            pTmp = pHead;
        }
        *pQueue = NULL;
    }
    else
    {
        // Close the loop
        pTmp->pNext = pHead;
        *pQueue = pHead;
    }
}




//-----------------------------------------------------------------------------
// Name: DeleteQueue
// Desc: Delete a queue of MEDIA_PACKET_LIST 
//-----------------------------------------------------------------------------
void CCommunicator::DeleteQueue(MEDIA_PACKET_LIST *pQueue)
{
    assert(pQueue->pNext != pQueue);

    MEDIA_PACKET_LIST *pTmpBuff = pQueue;

    // Break the loop
    pQueue = pQueue->pNext;
    pTmpBuff->pNext = NULL;

    while(NULL != pQueue)
    {
        pTmpBuff = pQueue->pNext;
        delete pQueue;
        pQueue = pTmpBuff;
    }

}




//-----------------------------------------------------------------------------
// Name: Inserted
// Desc: Called when a communicator is newly detected in this slot, does all initializations
//-----------------------------------------------------------------------------
HRESULT CCommunicator::Inserted()
{
    HRESULT         hr;
    WAVEFORMATEX    wfxFormat;
    
    OUTPUT_DEBUG_STRING( "CCommunicator::Inserted() - Xbox Communicator Inserted\n" );

    // Initialize wave format
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = m_wVoiceSamplingRate;
    wfxFormat.nAvgBytesPerSec = 2 * m_wVoiceSamplingRate;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    //  Create a microphone and a headphone
    hr = XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_MICROPHONE, 
                                  m_wHeadsetPort, 
                                  m_wVoiceBuffersCount,
                                  &wfxFormat, 
                                  &m_pMicrophone );
    if( FAILED( hr ) )
    {
        OUTPUT_DEBUG_STRING( "CCommunicator::Inserted() - Microphone creation failed\n" );
        return hr;
    }

    hr = XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_HEADPHONE, 
                                  m_wHeadsetPort, 
                                  m_wVoiceBuffersCount,
                                  &wfxFormat, 
                                  &m_pHeadphone );

    if( FAILED( hr ) )
    {
        OUTPUT_DEBUG_STRING( "CCommunicator::Inserted() - Headphone creation failed\n" );
        return hr;
    }

    hr = XVoiceEncoderCreateMediaObject( FALSE,         // manual mode
                                         m_wCodecTag,
                                         &wfxFormat,
                                         20,            // voice activation threshold (0 - 255)
                                         &m_pEncoder );

    if( FAILED( hr ) )
    {
        OUTPUT_DEBUG_STRING( "CCommunicator::Inserted() - Voice encoder creation failed\n" );
        return hr;
    }

    // Set the codec buffer size taking into account the codec
    XVoiceGetCodecBufferSize( m_pEncoder, m_wVoiceBufferSize , &m_wCodecBufferSize);

    // Events for microphone and headphone working...
    if(INVALID_HANDLE_VALUE == m_hMicrophoneWorkEvent)
    {
        m_hMicrophoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_bCreateMicrophoneEvent = TRUE;
    }
    m_hHeadphoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    

    // Create the buffers for microphone
    CreateQueue( &m_pBeginMicrophoneQueuedBuffers, 
                 m_wVoiceBufferSize, 
                 m_wVoiceBuffersCount, 
                 (DWORD)XMEDIAPACKET_STATUS_PENDING );
    if( NULL ==  m_pBeginMicrophoneQueuedBuffers)
    {
        OUTPUT_DEBUG_STRING( "CCommunicator::Inserted() - Not enough memory for microphone buffers!\n" );
        return E_OUTOFMEMORY;
    }

    // Create the buffers for headphone
    CreateQueue( &m_pBeginHeadphoneQueuedBuffers, 
                 m_wVoiceBufferSize, 
                 m_wVoiceBuffersCount, 
                 (DWORD)XMEDIAPACKET_STATUS_SUCCESS );
    if( NULL ==  m_pBeginHeadphoneQueuedBuffers)
    {
        OUTPUT_DEBUG_STRING( "CCommunicator::Inserted() - Not enough memory for headphone buffers!\n" );
        return E_OUTOFMEMORY;
    }

    // Create the buffer used by the codec for compression
    memset(&m_CodecMediaBuffer, 0, sizeof(XMEDIAPACKET));
    m_CodecMediaBuffer.dwMaxSize = m_wCodecBufferSize;
    m_CodecMediaBuffer.pvBuffer = new BYTE[m_wCodecBufferSize];
    if( NULL == m_CodecMediaBuffer.pvBuffer )
    {
        OUTPUT_DEBUG_STRING( "CCommunicator::Inserted()...Not enough memory for Codec buffer!\n" );
        return E_OUTOFMEMORY;
    }

    // Feed the microphone with buffers; we enqueue all the buffers to the 
    // microphone which is going to fill them with data gradually
    // We don't enqueue buffers to the headphone yet; this is going to be done 
    // when buffers from the microphonestart to arrive
    MEDIA_PACKET_LIST *pTmpMBuff = m_pBeginMicrophoneQueuedBuffers;
    for( DWORD i = 0 ; i < m_wVoiceBuffersCount ; i++ )
    {
        QueueMicrophoneBuffer(pTmpMBuff);
        pTmpMBuff = pTmpMBuff->pNext;
    }


#ifdef _WRITE_LOG
    static int index = 0;
    char szFileName[30];
    //
    // Log File for the input PCM data from the microphone
    //
    sprintf(szFileName , "D:\\RawPCMData0%d.log" , index);
    OpenFile(szFileName , &m_hFileRawPCMData);
    
    //
    // Log File for the compressed signal
    //
    sprintf(szFileName , "D:\\Compressed0%d.log" , index);
    OpenFile(szFileName , &m_hFileCompressed);

    //
    // Log File for the decompressed signal
    //
    sprintf(szFileName , "D:\\Decompressed0%d.log" , index);
    OpenFile(szFileName , &m_hFileDecompressed);

    index++;

#endif

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Removed
// Desc: Called when the communicator is unplugged
//-----------------------------------------------------------------------------
void CCommunicator::Removed()
{
    CCommunicator::Cleanup();
    OUTPUT_DEBUG_STRING("Communicator removed!\n");
}




//-----------------------------------------------------------------------------
// Name: QueueMicrophoneBuffer
// Desc: Prepare a packet for the microphone and call Process on it
//-----------------------------------------------------------------------------
void CCommunicator::QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //  Initialize the event 
    pMediaPacket->hCompletionEvent = m_hMicrophoneWorkEvent;

    //  Submit the buffer
    VERIFY_SUCCESS(m_pMicrophone->Process(NULL, pMediaPacket));
}




//-----------------------------------------------------------------------------
// Name: QueueHeadphoneBuffer 
// Desc: Prepare a packet for the headphone and call Process on it
//-----------------------------------------------------------------------------
void CCommunicator::QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //  Initialize the event
    pMediaPacket->hCompletionEvent = m_hHeadphoneWorkEvent;

    //  Submit the buffer
    VERIFY_SUCCESS(m_pHeadphone->Process(pMediaPacket, NULL));

}




//-----------------------------------------------------------------------------
// Name: CompressMediaBuffer 
// Desc: Compress a PCM buffer and return the encoded buffer and a status on voice detected
//-----------------------------------------------------------------------------
HRESULT CCommunicator::CompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst , BOOL *pvbVoiceDetected)
{
    HRESULT hr;
    DWORD dwSizeDst = 0; 

    assert( pDst->dwMaxSize == m_wCodecBufferSize );

    memset( pDst->pvBuffer, 0, pDst->dwMaxSize );

    pDst->pdwCompletedSize = &dwSizeDst;
    pDst->hCompletionEvent = NULL;

    // Encode the packet
    hr = m_pEncoder->Process( pSrc, pDst );

    assert( !FAILED(hr) );
    
#ifdef _WRITE_LOG
    WriteToLogFile(m_hFileCompressed , (BYTE*)pDst->pvBuffer , pDst->dwMaxSize);
#endif

    if( dwSizeDst < m_wCodecBufferSize )
    {
        *pvbVoiceDetected = FALSE;
    }
    else
    {
        *pvbVoiceDetected = TRUE;
    }

    pDst->pdwCompletedSize = NULL;

    return( hr );
}




//-----------------------------------------------------------------------------
// Name: OnMicrophoneInput 
// Desc: Called when a microphone event is set; take the buffer from the microphone 
//       and compress it, then sent it to the output
//-----------------------------------------------------------------------------
HRESULT CCommunicator::OnMicrophoneInput()
{
    HRESULT hr;
    BOOL bVoiceDetected = TRUE;
    
    if( NULL != m_pMicrophone )
    {
        // One microphone buffer is filled with data
        if(XMEDIAPACKET_STATUS_PENDING != m_pBeginMicrophoneQueuedBuffers->dwStatus)
        {
            if( SUCCEEDED( m_pBeginMicrophoneQueuedBuffers->dwStatus ) )
            {
#ifdef _WRITE_LOG
                WriteToLogFile(m_hFileRawPCMData,
                               (BYTE*)(m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer,
                               m_wVoiceBufferSize );
#endif
                // 1. Compress the buffer buffer
                CompressMediaBuffer( &m_pBeginMicrophoneQueuedBuffers->MediaPacket,
                                     &m_CodecMediaBuffer, 
                                     &bVoiceDetected );
            
                // 2. Expose compressed data to any derived classes
                OnCompressedInput( &m_CodecMediaBuffer, bVoiceDetected );
            }

            if( XMEDIAPACKET_STATUS_FAILURE == m_pBeginMicrophoneQueuedBuffers->dwStatus )
            {
                hr = E_FAIL;
                return hr;
            }
            else
            {
                // 3. Submit the packet back to the microphone
                m_pBeginMicrophoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
                QueueMicrophoneBuffer(m_pBeginMicrophoneQueuedBuffers);
                m_pBeginMicrophoneQueuedBuffers = m_pBeginMicrophoneQueuedBuffers->pNext;
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: QueuePCMForOutput
// Desc: Send a PCM buffer to the headphone and reuse the buffer
//-----------------------------------------------------------------------------
HRESULT CCommunicator::QueuePCMForOutput( XMEDIAPACKET *pOutput )
{
    // Validate input data
    assert(pOutput->dwMaxSize == m_wVoiceBufferSize);

#ifdef _WRITE_LOG
    WriteToLogFile(m_hFileDecompressed ,
                   (BYTE*)(m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer ,
                   m_wVoiceBufferSize);
#endif

    // Send PCM data to the headphone
    memcpy(m_pBeginHeadphoneQueuedBuffers->MediaPacket.pvBuffer , pOutput->pvBuffer , pOutput->dwMaxSize);
    m_pBeginHeadphoneQueuedBuffers->MediaPacket.dwMaxSize = pOutput->dwMaxSize;
    QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
    
    // Requeue the packet
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

    return S_OK;
}




//////////////////////////////////////////////////////////////////////////////
// Implementation of CVoiceChatCommunicator - Voice chat between xboxes
//////////////////////////////////////////////////////////////////////////////



//-----------------------------------------------------------------------------
// Name: CVoiceChatCommunicator
// Desc: Constructor
//-----------------------------------------------------------------------------
CVoiceChatCommunicator::CVoiceChatCommunicator( WORD   wHeadsetPort,
                                                HANDLE hEvtMicInput,
                                                WORD   wCodecTag,
                                                WORD   wVoicePort,
                                                WORD   wVoiceSamplingRate,
                                                WORD   wCodecSamplingRate,
                                                WORD   wVoiceBufferTime,
                                                WORD   wVoiceBufferCount ) :
    CCommunicator( wHeadsetPort,
                   hEvtMicInput,
                   wCodecTag,
                   wVoiceSamplingRate,
                   wCodecSamplingRate,
                   wVoiceBufferTime,
                   wVoiceBufferCount )
{
    m_VoiceQueueXMOList                 = NULL;
    m_nChattersCount                    = 0;
    m_fMixingBuffer                     = NULL;
    m_pResumePoint                      = NULL;
    m_nMixedPacketsCount                = 0;
    m_VoiceSock                         = INVALID_SOCKET;
    m_wVoicePort                        = wVoicePort;
    m_MixedSoundMediaBuffer.pvBuffer    = NULL;
    m_NetworkMediaBuffer.pvBuffer       = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CVoiceChatCommunicator
// Desc: Destructor
//-----------------------------------------------------------------------------
CVoiceChatCommunicator::~CVoiceChatCommunicator()
{
    CVoiceChatCommunicator::Cleanup();
}




//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Called at destruction time or when the communicator is removed
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::Cleanup()
{
    DeleteQueueXMOList();

    if( NULL != m_MixedSoundMediaBuffer.pvBuffer )
    {
        delete [] m_MixedSoundMediaBuffer.pvBuffer;
        m_MixedSoundMediaBuffer.pvBuffer = NULL;
    }

    if( NULL != m_NetworkMediaBuffer.pvBuffer )
    {
        delete [] m_NetworkMediaBuffer.pvBuffer;
        m_NetworkMediaBuffer.pvBuffer = NULL;
    }

    if( NULL != m_fMixingBuffer )
    {
        delete [] m_fMixingBuffer;
        m_fMixingBuffer = NULL;
    }


    if( INVALID_SOCKET != m_VoiceSock )
    {
        closesocket( m_VoiceSock );
        m_VoiceSock = INVALID_SOCKET;
    }
}




//-----------------------------------------------------------------------------
// Name: Inserted
// Desc: Called when a communicator is newly detected in this slot, 
//          performs all initialization
//-----------------------------------------------------------------------------
HRESULT CVoiceChatCommunicator::Inserted()
{
    HRESULT hr;
    
    // Base class initialization
    hr = CCommunicator::Inserted();
    if( FAILED( hr ) )
    {
        OUTPUT_DEBUG_STRING( "CVoiceChatCommunicator::Inserted() - Base class Inserted() failed!\n" );
        return hr;
    }

    // Create the buffer used by the queue output
    memset( &m_MixedSoundMediaBuffer, 0, sizeof( XMEDIAPACKET ) );
    m_MixedSoundMediaBuffer.dwMaxSize = m_wVoiceBufferSize;
    m_MixedSoundMediaBuffer.pvBuffer = new BYTE[ m_wVoiceBufferSize ];

    if( NULL == m_MixedSoundMediaBuffer.pvBuffer )
    {
        DebugPrint("CVoiceChatCommunicator::Inserted()...Not enough memory for queue output buffer!\n");
        return E_OUTOFMEMORY;
    }
    else
    {
        // This buffer may be used for first output for headphone if nothing comes from network,
        // so we initialize it with silence
        memset( m_MixedSoundMediaBuffer.pvBuffer, 0, m_wVoiceBufferSize );
    }

    // Create the buffer used by the network input
    memset(&m_NetworkMediaBuffer, 0, sizeof(XMEDIAPACKET));
    m_NetworkMediaBuffer.dwMaxSize = m_wCodecBufferSize;
    m_NetworkMediaBuffer.pvBuffer = new BYTE[m_wCodecBufferSize];

    if( NULL == m_NetworkMediaBuffer.pvBuffer )
    {
        OUTPUT_DEBUG_STRING( "CVoiceChatCommunicator::Inserted()...Not enough memory for network input buffer!\n" );
        return E_OUTOFMEMORY;
    }

    // Create the buffer used for mixing sounds - size is /sizeof(short) because we are mixing 16 bits/sample
    m_wMixingBufferSize = m_wVoiceBufferSize / sizeof(short);
    m_fMixingBuffer = new float[m_wMixingBufferSize];

    if( NULL ==  m_fMixingBuffer)
    {
        OUTPUT_DEBUG_STRING("CVoiceChatCommunicator::Inserted()...Not enough memory for mixing buffer!\n");
        return E_OUTOFMEMORY;
    }

    // Network stuff initialization
    m_VoiceSock = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if( INVALID_SOCKET ==  m_VoiceSock )
    {
        hr = WSAGetLastError();
        OUTPUT_DEBUG_STRING( "CVoiceChatCommunicator::Inserted() - Voice socket open failed\n" );
        return hr;
    }

    SOCKADDR_IN voiceAddr;
    voiceAddr.sin_family = AF_INET;
    voiceAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    voiceAddr.sin_port = htons( m_wVoicePort );

    int iResult = bind( m_VoiceSock, (const sockaddr*)(&voiceAddr), sizeof( SOCKADDR_IN ) );
    if(iResult == SOCKET_ERROR)
    {
       hr = WSAGetLastError();
       OUTPUT_DEBUG_STRING( "CVoiceChatCommunicator::Inserted()...Voice socket binding failed\n" );
       return hr;
    }

    DWORD dwNonBlocking = 1;
    iResult = ioctlsocket(m_VoiceSock , FIONBIO, &dwNonBlocking );
    if(iResult == SOCKET_ERROR)
    {
       hr = WSAGetLastError();
       OUTPUT_DEBUG_STRING( "CVoiceChatCommunicator::Inserted() - ioctlsocket failed\n" );
       return hr;
    }

    // Output is requested from the queuing XMO only if m_IntervalForOutput time has elapsed
    m_IntervalForOutput = m_wVoiceBufferTime / 2;
    m_LastOutputTimeStamp = GetTickCount();


    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Removed
// Desc: Called when the communicator is unplugged
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::Removed()
{
    CVoiceChatCommunicator::Cleanup();

    CCommunicator::Removed();
}




//-----------------------------------------------------------------------------
// Name: OnCompressedInput
// Desc: Pure function in CCommunicator, implemented here.
//       Send the encoded voice packet when voice is detected in it.
//-----------------------------------------------------------------------------
HRESULT CVoiceChatCommunicator::OnCompressedInput( XMEDIAPACKET *pInput , BOOL bVoiceDetected )
{
    if( bVoiceDetected )
    {
        SendVoicePacket(pInput);
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CheckForOutputData
// Desc: Pure function in CCommunicator, implemented here.
//       Read the network and insert any incoming buffer in its corresponding
//       queueXMO. If enough time elapses, process the existing queues.
//       If valid PCM buffer is returned, send it to the headphone.
//-----------------------------------------------------------------------------
HRESULT CVoiceChatCommunicator::CheckForOutputData()
{
    HRESULT hr = E_FAIL; 

    if( NULL != m_pMicrophone )
    {
        ReadNetwork();

        // Call for output only if the interval elapsed and the oldest headphone buffer has been processed
        if((GetTickCount() - m_LastOutputTimeStamp >= m_IntervalForOutput) &&
            (m_pBeginHeadphoneQueuedBuffers->dwStatus == XMEDIAPACKET_STATUS_SUCCESS))
        {         
            hr = ProcessQueues(); 

            m_LastOutputTimeStamp = GetTickCount();
        }
        

        if( SUCCEEDED( hr ) )
        {
            // Send it to the headphone
            QueuePCMForOutput(&m_MixedSoundMediaBuffer);
        }
    }

    return hr;


}

//-----------------------------------------------------------------------------
// Name: SendVoicePacket
// Desc: Send a voice packet to all the chatters
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::SendVoicePacket( XMEDIAPACKET *pMediaPacket )
{
    int nBytes = 0;
    QUEUEXMO_PER_CHATTER *pTmp = NULL;

    // Send the voice packet to each remote chatter
    for( pTmp = m_VoiceQueueXMOList ; NULL != pTmp ; pTmp = pTmp->m_pNext)
    {
        nBytes = sendto( m_VoiceSock , (const char*)pMediaPacket->pvBuffer, pMediaPacket->dwMaxSize , 
                         0, (const sockaddr*)(&(pTmp->m_SockAddrDest)), sizeof( SOCKADDR_IN ) );

        assert( nBytes == m_wCodecBufferSize );
    }
}




//-----------------------------------------------------------------------------
// Name: ReadNetwork
// Desc: Read the network and insert any incoming buffer in its corresponding
//       queueXMO.
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::ReadNetwork()
{
    HRESULT hr = S_OK;
    WORD i;
    SOCKADDR_IN saFromIn;
    BOOL bReadOK = TRUE;

    for( i = 0 ; (i < m_nChattersCount ) && (SUCCEEDED(hr)) && (bReadOK) ; i++ )
    {
        // See if a voice message is waiting for us
        int iSize = sizeof( SOCKADDR_IN );

        memset(m_NetworkMediaBuffer.pvBuffer , 0 , m_NetworkMediaBuffer.dwMaxSize);
        int iResult = recvfrom( m_VoiceSock , (char*)m_NetworkMediaBuffer.pvBuffer, m_NetworkMediaBuffer.dwMaxSize, 
                            0, (sockaddr*)(&saFromIn), &iSize );
    

        if( iResult != SOCKET_ERROR && iResult > 0 )
        {
            // TBD: analyze iResult and see if a whole packet has come....
            QUEUEXMO_PER_CHATTER *pQueue = FindInQueueXMOList(saFromIn);

            if( NULL != pQueue )
            {
                hr = pQueue->m_pVoiceQueueXMO->Process(&m_NetworkMediaBuffer , NULL);
            }
        }
        else
        {
            bReadOK = FALSE;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessQueues
// Desc: Ask all the queues for output and if more than one, mix the PCM buffers 
//       that have voice.
//-----------------------------------------------------------------------------
HRESULT CVoiceChatCommunicator::ProcessQueues()
{
    HRESULT hr = S_OK;

    // Get output from the queues and mix the sound if necessary
    switch( m_nChattersCount )
    {
    case 0:
        hr = E_FAIL;
        break;

    case 1:
        // With only one remote chatter, we don't have to mix output
        hr = (m_VoiceQueueXMOList->m_pVoiceQueueXMO)->Process(NULL , &m_MixedSoundMediaBuffer);
        if( SUCCEEDED( hr ) )
        {
            m_VoiceQueueXMOList->m_bProvidedOutput = TRUE;
        }
        break;

    default:
        // Default case with multiple chatters means we have to mix output
        QUEUEXMO_PER_CHATTER *pTmp;
        PCM_INFO outputInfo;
        if( NULL == m_pResumePoint )
        {
            pTmp = m_VoiceQueueXMOList;
            memset(m_fMixingBuffer , 0 , m_wMixingBufferSize * sizeof(float) );
            m_nMixedPacketsCount = 0;
        }
        else
        {
            pTmp = m_pResumePoint;
        }
        
        for( ; NULL != pTmp; pTmp = pTmp->m_pNext )
        { 
            hr = (pTmp->m_pVoiceQueueXMO)->Process(NULL , &m_MixedSoundMediaBuffer);
            if( SUCCEEDED(hr) )
            {
                m_pResumePoint = NULL;

                // We'll mix in only the packets that have voice inside
                (pTmp->m_pVoiceQueueXMO)->GetLastOutputInfo(&outputInfo);
                if( outputInfo.nMaxPower > 0  )
                {
                    pTmp->m_bProvidedOutput = TRUE;
                    SumUpPacket(&m_MixedSoundMediaBuffer);
                    m_nMixedPacketsCount++;
                }
            }
            else
            {
                // Syncronization
                if(pTmp->m_bProvidedOutput)
                {
                    m_pResumePoint = pTmp;
                    break;
                }
            }
        }

        if( NULL != m_pResumePoint )
        {
            hr = E_FAIL;
        }
        else
        {
            // If m_nMixedPacketsCount == 0 we'll return the last of the queues' output
            // (it's silence, anyway)
            if( 0 != m_nMixedPacketsCount )
            {
                short *pBuffer = (short*)m_MixedSoundMediaBuffer.pvBuffer;
                for( WORD k = 0 ; k < m_wMixingBufferSize ; k++ )
                {
                    pBuffer[k] = (short)(m_fMixingBuffer[k] / m_nMixedPacketsCount);
                }
            }

            m_pResumePoint = NULL;
            hr = S_OK;
        }
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: SumUpPacket
// Desc: Mixing 
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::SumUpPacket( XMEDIAPACKET *pMediaPacket )
{
    // This function is adding the samples in the mixing buffer 
    assert(pMediaPacket->dwMaxSize == m_wVoiceBufferSize);
    short *pBuffer = (short*)pMediaPacket->pvBuffer;

    for( WORD k = 0 ; k <  m_wMixingBufferSize ; k++)
    {
        m_fMixingBuffer[k] += (float)pBuffer[k];
    }
}




//-----------------------------------------------------------------------------
// Name: RemoveChatters
// Desc: Called when one of the xboxes left the chat(if it has multiple communicators
//       plugged in, remove all of them from the chat)
//-----------------------------------------------------------------------------
HRESULT CVoiceChatCommunicator::RemoveChatters(const IN_ADDR &inAddr)
{
    QUEUEXMO_PER_CHATTER *pTmp = m_VoiceQueueXMOList;
    QUEUEXMO_PER_CHATTER *pPrev = NULL;

    while( NULL != pTmp )
    {
        if( pTmp->IsSameXbox(inAddr) )
        {
            if( NULL == pPrev )
            {
                m_VoiceQueueXMOList = m_VoiceQueueXMOList->m_pNext;
                delete pTmp;
                pTmp = m_VoiceQueueXMOList;
            }
            else
            {
                pPrev->m_pNext = pTmp->m_pNext;
                delete pTmp;
                pTmp = pPrev->m_pNext;
            }
            
            m_nChattersCount--;
        }
        else
        {
            pPrev = pTmp;
            pTmp = pTmp->m_pNext;
        }
    }

    return (S_OK);
}




//-----------------------------------------------------------------------------
// Name: UpdateChatList
// Desc: Add one chatter, or, if no VoicePort provided and delete requested,
//       remove all the chatters from that IP address
//-----------------------------------------------------------------------------
HRESULT CVoiceChatCommunicator::UpdateChatList( BOOL bAdd, 
                                                const IN_ADDR &inAddr, 
                                                WORD wVoicePort )
{
    HRESULT hr = S_OK;
    QUEUEXMO_PER_CHATTER *pQueue = NULL;

    if( NULL != m_pMicrophone )
    {
        if( 0 == wVoicePort )
        {
            if( !bAdd )
            {
                RemoveChatters(inAddr);
                return (hr); 
            }
        }
        
        pQueue = FindInQueueXMOList(inAddr , wVoicePort);
        
        if( bAdd )
        {
            if(NULL == pQueue)
            {
                // Voice queueing initialization
                QUEUE_XMO_CONFIG config;
                QUEUEXMO_PER_CHATTER queuePerPlayer;
    
                // Set up the queue configuration
                memset(&config , 0 , sizeof(config));
                config.cbSize = sizeof(config);
                config.wMsOfDataPerPacket = m_wVoiceBufferTime;
                config.wInitialHighWaterMark = 2 * m_wVoiceBufferTime;
                config.wMinDelay = 2 * m_wVoiceBufferTime;
                config.wMaxDelay = 2 * m_wVoiceBuffersCount * m_wVoiceBufferTime;
                config.dwCodecTag = (DWORD)m_wCodecTag;

                hr = XVoiceQueueCreateMediaObject(&config , &(queuePerPlayer.m_pVoiceQueueXMO));
                if( FAILED( hr ) )
                {
                    OUTPUT_DEBUG_STRING( "CVoiceChatCommunicator::UpdateChatList() - Add player failed!\n" );
                    return hr;
                }

                queuePerPlayer.m_SockAddrDest.sin_family = AF_INET;
                queuePerPlayer.m_SockAddrDest.sin_addr = inAddr;
                queuePerPlayer.m_SockAddrDest.sin_port = htons(wVoicePort);

                AddToQueueXMOList(queuePerPlayer);
                queuePerPlayer.m_pVoiceQueueXMO = NULL;
            }
        }
        else 
        {
            if( NULL != pQueue)
            {
                DeleteFromQueueXMOList(pQueue);
            }
        }
    }

    return S_OK;
}


//
// The methods for QueueXMO list handling
//

//-----------------------------------------------------------------------------
// Name: AddToQueueXMOList
// Desc: Insert one queue in the queue list
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::AddToQueueXMOList(const QUEUEXMO_PER_CHATTER& queue)
{
    QUEUEXMO_PER_CHATTER *pTmp = NULL;
    QUEUEXMO_PER_CHATTER *pAux = NULL;
    
    if( NULL == m_VoiceQueueXMOList )
    {
        pAux = m_VoiceQueueXMOList = new QUEUEXMO_PER_CHATTER(queue);
    }
    else
    {
        for(pTmp = m_VoiceQueueXMOList ; NULL != pTmp->m_pNext ; pTmp = pTmp->m_pNext){}
        pAux = pTmp->m_pNext = new QUEUEXMO_PER_CHATTER(queue);

    }
    if( NULL != pAux )
    {
        m_nChattersCount++;
    }
}

//-----------------------------------------------------------------------------
// Name: FindInQueueXMOList
// Desc: Find a particular queue in the queue list
//-----------------------------------------------------------------------------
QUEUEXMO_PER_CHATTER* CVoiceChatCommunicator::FindInQueueXMOList( const IN_ADDR &inAddr , WORD wVoicePort)
{
    QUEUEXMO_PER_CHATTER *pTmp = NULL;

    for( pTmp = m_VoiceQueueXMOList ; NULL != pTmp ; pTmp = pTmp->m_pNext)
    {
        if( pTmp->IsSameCommunicator(inAddr , wVoicePort) )
        {
            break;
        }
    }

    return pTmp;
}

//-----------------------------------------------------------------------------
// Name: FindInQueueXMOList
// Desc: Find a particular queue in the queue list
//-----------------------------------------------------------------------------
QUEUEXMO_PER_CHATTER* CVoiceChatCommunicator::FindInQueueXMOList( const SOCKADDR_IN &addr)
{
    QUEUEXMO_PER_CHATTER *pTmp = NULL;

    for( pTmp = m_VoiceQueueXMOList ; NULL != pTmp ; pTmp = pTmp->m_pNext)
    {
        if( pTmp->IsSameCommunicator(addr) )
        {
            break;
        }
    }

    return pTmp;
}

//-----------------------------------------------------------------------------
// Name: DeleteFromQueueXMOList
// Desc: Delete a queue from the queue list
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::DeleteFromQueueXMOList(QUEUEXMO_PER_CHATTER *pQueue)
{

    QUEUEXMO_PER_CHATTER *pTmp = m_VoiceQueueXMOList;
    QUEUEXMO_PER_CHATTER *pPrev = NULL;

    DebugPrint("Delete from queue list...\n");

    for(  ; NULL != pTmp ; pPrev = pTmp , pTmp = pTmp->m_pNext )
    {
        if( pTmp == pQueue)
        {
            if( NULL == pPrev )
            {
                m_VoiceQueueXMOList = m_VoiceQueueXMOList->m_pNext;
            }
            else
            {
                pPrev->m_pNext = pTmp->m_pNext;
            }

            if( pTmp == m_pResumePoint )
            {
                //
                // If the resume point for mixing is deleted...
                //
                m_pResumePoint = pTmp->m_pNext;
            }

            delete pQueue;
            m_nChattersCount--;

            break;
        }
    }
}

//-----------------------------------------------------------------------------
// Name: DeleteQueueXMOList
// Desc: Delete the entire queue list
//-----------------------------------------------------------------------------
void CVoiceChatCommunicator::DeleteQueueXMOList()
{
    
    QUEUEXMO_PER_CHATTER *pTmp = NULL;

    DebugPrint("Delete queue list...\n");

    while(NULL != m_VoiceQueueXMOList)
    {
        pTmp = m_VoiceQueueXMOList;
        m_VoiceQueueXMOList = m_VoiceQueueXMOList->m_pNext;
        delete pTmp;
    }
    m_VoiceQueueXMOList = NULL;
    m_nChattersCount = 0;

}



//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CCommunicatorMgr that tracks multiple Xbox Communicators
//
//////////////////////////////////////////////////////////////////////////////


//-----------------------------------------------------------------------------
// Name: CCommunicatorMgr
// Desc: Constructor
//-----------------------------------------------------------------------------
CCommunicatorMgr::CCommunicatorMgr()
{   
}




//-----------------------------------------------------------------------------
// Name: ~CCommunicatorMgr
// Desc: Destructor
//-----------------------------------------------------------------------------
CCommunicatorMgr::~CCommunicatorMgr()
{
    for(BYTE k = 0 ; k < COMMUNICATOR_COUNT  ; k++)
    {
        if( NULL != m_pVoiceUnits[k] )
        {
            delete m_pVoiceUnits[k];
            m_pVoiceUnits[k] = NULL;
        }
    }

    if (m_hCommunicatorWorkEvent) 
    {
        CloseHandle(m_hCommunicatorWorkEvent);
        m_hCommunicatorWorkEvent = INVALID_HANDLE_VALUE;
    }
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Called when the voice chat is initiated on this xbox
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::Initialize( PlayerList& playerList, 
                                      WORD wCodecTag, 
                                      MsgVoicePort *msgCommunicatorStatus )
{
    HRESULT hr = S_OK;
    WORD i , j;

    assert(NULL != msgCommunicatorStatus);

    // Create the work event for the voice units
    m_hCommunicatorWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( NULL ==  m_hCommunicatorWorkEvent)
    {
        return E_FAIL;
    }

    // Create one communicator for each port
    for(i = 0 ; i < COMMUNICATOR_COUNT ; i++)
    {
        m_pVoiceUnits[i] = new CVoiceChatCommunicator(i , m_hCommunicatorWorkEvent , wCodecTag , VOICE_PORT  + i );
        if( NULL ==  m_pVoiceUnits[i])
        {
            return E_OUTOFMEMORY;
        }
    }        
    
    // Verify the initial state of the voice devices
    hr = CheckInitialState();

    // Tell the communicator manager which slots are active
    BOOL bFirst = TRUE;
    for( i = 0; i < COMMUNICATOR_COUNT; i++ )
    {
        if( m_pVoiceUnits[i]->IsCommunicatorActive() )
        {
            if( bFirst )
            {
                msgCommunicatorStatus[i].action = ADD_AND_RESPOND;
                bFirst = FALSE;
            }
            else
            {
                msgCommunicatorStatus[i].action = ADD_PORT;
            }
            msgCommunicatorStatus[i].wVoicePort = m_pVoiceUnits[i]->GetVoicePort();
        }
    }
        
    // Initialize queues for the players on the same xbox
    for( i = 0 ; i < COMMUNICATOR_COUNT ; i++ )
    {
        if( m_pVoiceUnits[i]->IsCommunicatorActive() )
        {
            for( j = 0; j <  COMMUNICATOR_COUNT; j++ )
            {
                if( i != j )
                {
                    IN_ADDR inAddr;
                    inAddr.s_addr = htonl(INADDR_LOOPBACK);
                    hr = m_pVoiceUnits[j]->UpdateChatList( TRUE  , inAddr , m_pVoiceUnits[i]->GetVoicePort() );
                    if( FAILED( hr ) )
                    {
                        OUTPUT_DEBUG_STRING("CVoiceChatCommunicator::Initialize() - Failed to initialize queues!\n");
                        break;
                    }
                }
            }
         }
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Process 
// Desc: The engine of the whole voice chat, called in the main infinite loop
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::Process(MsgVoicePort *msgCommunicatorStatus)
{
    BYTE i;
    HRESULT hr;

    assert(NULL != msgCommunicatorStatus);

    DWORD dwReason = WaitForSingleObject(m_hCommunicatorWorkEvent ,  0);


    // One of the voice units has microphone input
    if( WAIT_OBJECT_0 == dwReason )
    {
        for( i = 0 ; i <  COMMUNICATOR_COUNT ; i++ )
        {
            hr = m_pVoiceUnits[i]->OnMicrophoneInput();
            if(FAILED(hr))
            {
                OUTPUT_DEBUG_STRING( "CCommunicatorMgr::Process() - Error OnMicrophoneInput\n" );
                return (hr);
            }
        }
    }
            
    // Check for output data even if no microphone input(read the network for example)
    for( i = 0 ; i <  COMMUNICATOR_COUNT ; i++ )
    {
        m_pVoiceUnits[i]->CheckForOutputData();
    }
    
    //  Always check for hot-plugs
    return CheckForHotPlugs(msgCommunicatorStatus);
}




//-----------------------------------------------------------------------------
// Name: CheckInitialState
// Desc: Get the initial state of the devices plugged in, called in Initialize()
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::CheckInitialState()
{
    HRESULT hr = S_OK;
    
    //  Get the initial connected state of the devices
    m_dwConnectedCommunicators = 0;
    m_dwMicrophoneState = XGetDevices( XDEVICE_TYPE_VOICE_MICROPHONE );
    m_dwHeadphoneState  = XGetDevices( XDEVICE_TYPE_VOICE_HEADPHONE );

    for( INT i = 0; i < COMMUNICATOR_COUNT; i++ )
    {
        if( m_dwMicrophoneState & ( 1 << i ) &&
            m_dwHeadphoneState  & ( 1 << i ) )
        {
            if(!SUCCEEDED(m_pVoiceUnits[i]->Inserted()))
            {
                OUTPUT_DEBUG_STRING( "CCommunicatorMgr::CheckInitialState() - Voice unit initialization failed!\n" );
                return E_FAIL;
            }
            m_dwConnectedCommunicators |= ( 1 << i );
        }
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: CheckForHotPlugs
// Desc: Called in Process to check if new inserts/removes occured
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::CheckForHotPlugs(MsgVoicePort *msgCommunicatorStatus)
{
    DWORD dwMicrophoneInsertions;
    DWORD dwMicrophoneRemovals;
    DWORD dwHeadphoneInsertions;
    DWORD dwHeadphoneRemovals;

    HRESULT hr;
    IN_ADDR inAddr;

    inAddr.s_addr = htonl(INADDR_LOOPBACK);

    // Must call XGetDevice changes to track possible removal and insertion
    // in one frame
    XGetDeviceChanges( XDEVICE_TYPE_VOICE_MICROPHONE,
                       &dwMicrophoneInsertions,
                       &dwMicrophoneRemovals );
    XGetDeviceChanges( XDEVICE_TYPE_VOICE_HEADPHONE,
                       &dwHeadphoneInsertions,
                       &dwHeadphoneRemovals );

    // Update state for removals
    m_dwMicrophoneState &= ~( dwMicrophoneRemovals );
    m_dwHeadphoneState  &= ~( dwHeadphoneRemovals );

    // Then update state for new insertions
    m_dwMicrophoneState |= ( dwMicrophoneInsertions );
    m_dwHeadphoneState  |= ( dwHeadphoneInsertions );

    // Check each communicator for possible removal and
    // then for insertion
    for(BYTE i = 0 ; i < COMMUNICATOR_COUNT ; i++ )
    {
        // If either the microphone or the headphone was
        // removed since last call, remove the communicator
        if( m_dwConnectedCommunicators & ( 1 << i ) &&
            ( ( dwMicrophoneRemovals & ( 1 << i ) ) ||
              ( dwHeadphoneRemovals  & ( 1 << i ) ) ) )
        {
            m_dwConnectedCommunicators &= ~( 1 << i );
            m_pVoiceUnits[i]->Removed();

            msgCommunicatorStatus[i].action = DELETE_PORT;
            hr = UpdateChatList( FALSE  , inAddr , msgCommunicatorStatus[i].wVoicePort );
            if( FAILED( hr ) )
                return hr;
        }

        // If both microphone and headphone are present, and
        // we didn't have a communicator here last frame,
        // register the insertion
        if( ( m_dwMicrophoneState & ( 1 << i ) ) &&
            ( m_dwHeadphoneState  & ( 1 << i ) ) &&
            !( m_dwConnectedCommunicators & ( 1 << i ) ) )
        {
            hr = m_pVoiceUnits[i]->Inserted();
            if( FAILED( hr ) )
                return hr;

            msgCommunicatorStatus[i].action = ADD_AND_RESPOND;
            msgCommunicatorStatus[i].wVoicePort = m_pVoiceUnits[i]->GetVoicePort();

            for( BYTE k = 0 ; k < COMMUNICATOR_COUNT ; k++)
            {
                if( k != i )
                {
                    if( m_pVoiceUnits[k]->IsCommunicatorActive() )
                    {
                        m_pVoiceUnits[k]->UpdateChatList(TRUE , inAddr , m_pVoiceUnits[i]->GetVoicePort());
                        m_pVoiceUnits[i]->UpdateChatList(TRUE , inAddr , m_pVoiceUnits[k]->GetVoicePort());
                    }
                }
            }

            // Note that the communicator has been added
            m_dwConnectedCommunicators |= ( 1 << i );
        }
    } 
         
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateChatList
// Desc: Tell the communicators to perform this update
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::UpdateChatList(BOOL bAdd , const IN_ADDR &inAddr , WORD wVoicePort)
{
    HRESULT hr = S_OK;

    for( BYTE i = 0 ; i <  COMMUNICATOR_COUNT ; i++ )
    {
        hr = m_pVoiceUnits[i]->UpdateChatList(bAdd , inAddr , wVoicePort);
    }

    return (hr);
    
}




//////////////////////////////////////////////////////////////////////////////
//
// Debug help functions implementation
//
//////////////////////////////////////////////////////////////////////////////
#ifdef _WRITE_LOG

void OpenFile(const char *szFileName, HANDLE *phFile)
{
    *phFile = CreateFile(szFileName,
                      GENERIC_WRITE,                // open for writing 
                      0,                            // do not share 
                      NULL,                         // no security 
                      CREATE_ALWAYS,                // overwrite existing 
                      0,                            // normal file 
                      NULL);                        // no attr. template 

    
    if (*phFile == INVALID_HANDLE_VALUE) 
    { 
        DWORD dwErr = GetLastError();
        DebugPrint("Error: %d.\n" , dwErr);  // process error 
    } 
}

void CloseFile(HANDLE *phFile)
{
    if( NULL != *phFile )
    {
        // Make sure the message makes it to the disk
        FlushFileBuffers( *phFile );
        CloseHandle(*phFile); 
        *phFile = NULL;
    }
}

void WriteToLogFile(HANDLE hFile, BYTE *pbBuffer, DWORD dwSize)
{
DWORD dwBytesWritten = 0;

    WriteFile( hFile,                     // handle to output file
               pbBuffer,                  // data buffer
               dwSize,                    // number of bytes to write
               &dwBytesWritten ,
               NULL);

    assert(dwSize == dwBytesWritten);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\voicechat.h ===
//-----------------------------------------------------------------------------
// File: VoiceChat.h
//
// Hist: 08.08.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#pragma warning( disable: 4786 )
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBStopWatch.h>
#include <XBSocket.h>
#include <XBSockAddr.h>
#include <cassert>
#include <vector>
#include <algorithm>
#include "Resource.h"
#include "Voice.h"


//-----------------------------------------------------------------------------
// Name: class Message
// Desc: Message object sent between players and hosts
//-----------------------------------------------------------------------------
class Message
{
    BYTE m_byMessageId;

    union
    {
        MsgFindGame     m_FindGame;
        MsgGameFound    m_GameFound;
        MsgJoinGame     m_JoinGame;
        MsgJoinApproved m_JoinApproved;
        MsgPlayerJoined m_PlayerJoined;
        MsgVoicePort    m_VoicePort;
    };

public:

    explicit Message( BYTE byMessageId = 0 ) : m_byMessageId( byMessageId ) {}
    ~Message() {}

    BYTE GetId() const      { return m_byMessageId; }
    INT  GetMaxSize() const { return sizeof(*this); }

    MsgFindGame&     GetFindGame()     { return m_FindGame;     }
    MsgGameFound&    GetGameFound()    { return m_GameFound;    }
    MsgJoinGame&     GetJoinGame()     { return m_JoinGame;     }
    MsgJoinApproved& GetJoinApproved() { return m_JoinApproved; }
    MsgPlayerJoined& GetPlayerJoined() { return m_PlayerJoined; }
    MsgVoicePort&    GetMsgVoicePort() { return m_VoicePort;    }

    INT GetSize() const
    { 
        switch( m_byMessageId )
        {
            case MSG_FIND_GAME:     return sizeof(BYTE) + sizeof(MsgFindGame);
            case MSG_GAME_FOUND:    return sizeof(BYTE) + sizeof(MsgGameFound);
            case MSG_JOIN_GAME:     return sizeof(BYTE) + sizeof(MsgJoinGame);
            case MSG_JOIN_APPROVED: return sizeof(BYTE) + sizeof(MsgJoinApproved);
            case MSG_JOIN_DENIED:   return sizeof(BYTE);
            case MSG_PLAYER_JOINED: return sizeof(BYTE) + sizeof(MsgPlayerJoined);
            case MSG_WAVE:          return sizeof(BYTE);
            case MSG_HEARTBEAT:     return sizeof(BYTE);
            case MSG_VOICEPORT:     return sizeof(BYTE) + sizeof(MsgVoicePort);
            default: assert( FALSE ); return 0;
        }
    }

private:

    // Disabled
    Message( const Message& );
    Message& operator=( const Message& );

};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_MENU,             // Main menu
        STATE_GAME,             // Game menu
        STATE_HELP,             // Help screen
        STATE_SELECT_NAME,      // Select game name screen
        STATE_START_NEW_GAME,   // Starting new game
        STATE_GAME_SEARCH,      // Searching for game
        STATE_SELECT_GAME,      // Game selection menu
        STATE_REQUEST_JOIN,     // Joining game
        STATE_ERROR             // Error screen
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_LEFT,
        EV_RIGHT,
        EV_DISCONNECT,
        EV_NULL
    };

    enum
    {
        // Main menu
        MAIN_MENU_START_GAME = 0,
        MAIN_MENU_JOIN_GAME  = 1,
        MAIN_MENU_MAX,

        // Game menu
        GAME_MENU_WAVE       = 0,
        GAME_MENU_VOICE      = 1,
        GAME_MENU_LEAVE_GAME = 2,
        GAME_MENU_MAX
    };

    enum InitStatus
    {
        Success,
        NotConnected,
        InitFailed
    };

    typedef std::vector< std::wstring > NameList;
    typedef std::vector< GameInfo >     GameList;
    typedef std::vector< PlayerInfo >   PlayerList;

    CXBPackedResource   m_xprResource;   // app resources
    LPDIRECT3DTEXTURE8  m_ptMenuSel;     // menu selection image
    mutable HANDLE      m_hLogFile;      // Log file
    CXBFont      m_Font;                 // game font
    CXBHelp      m_Help;                 // help screen
    State        m_State;                // game state
    State        m_LastState;            // last state
    DWORD        m_CurrItem;             // current menu item
    NameList     m_GameNames;            // list of potential game names
    GameList     m_Games;                // list of available games
    PlayerList   m_Players;              // list of current players (not incl self)
    WCHAR        m_strError[ MAX_ERROR_STR ];   // error message
    WCHAR        m_strStatus[ MAX_STATUS_STR ]; // status
    CXBStopWatch m_LinkStatusTimer;      // wait to check link status
    CXBStopWatch m_GameSearchTimer;      // wait for game search to complete
    CXBStopWatch m_GameJoinTimer;        // wait for game join to complete
    CXBStopWatch m_HeartbeatTimer;       // keep-alive timer
    BOOL         m_bIsOnline;            // TRUE if link status good
    BOOL         m_bXnetStarted;         // TRUE if networking initialized
    BOOL         m_bIsHost;              // TRUE if we're hosting the game
    BOOL         m_bIsSessionRegistered; // TRUE if session key registered
    BOOL         m_bHaveLocalAddress;    // TRUE if local address acquired
    XNKID        m_xnHostKeyID;          // Host key ID
    XNKEY        m_xnHostKeyExchange;    // Host key exchange key
    XNADDR       m_xnTitleAddress;       // The XNet address of this machine/game
    IN_ADDR      m_inHostAddr;           // The "IP" address of the the host
    CXBSocket    m_BroadSock;            // Broadcast socket for broadcast msgs
    CXBSocket    m_DirectSock;           // Direct socket for direct msgs
    WCHAR        m_strGameName[ MAX_GAME_NAME ];     // Game name
    WCHAR        m_strPlayerName[ MAX_PLAYER_NAME ]; // This player name
    WCHAR        m_strHostName[ MAX_PLAYER_NAME ];   // Host player name
    Nonce        m_Nonce;                            // Client identifier


    CCommunicatorMgr      *m_pCommunicatorMgr; // The headset 
    MsgVoicePort           m_msgCommunicatorStatus[COMMUNICATOR_COUNT]; // The voiceports for each of the communicators

public:

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

private:

    Event GetEvent();

    VOID FrameMoveMenu( Event );
    VOID FrameMoveGame( Event );
    VOID FrameMoveHelp( Event );
    VOID FrameMoveSelectName( Event );
    VOID FrameMoveStartGame( Event );
    VOID FrameMoveGameSearch( Event );
    VOID FrameMoveSelectGame( Event );
    VOID FrameMoveRequestJoin( Event );
    VOID FrameMoveError( Event );

    VOID RenderMenu();
    VOID RenderGame();
    VOID RenderHelp();
    VOID RenderSelectName();
    VOID RenderStartGame();
    VOID RenderGameSearch();
    VOID RenderSelectGame();
    VOID RenderRequestJoin();
    VOID RenderError();
    VOID RenderHeader();
    VOID RenderMenuSelector( FLOAT, FLOAT );

    VOID InitiateJoin( DWORD );
    VOID Wave();
    VOID StartVoice();
    VOID ProcessVoice();
    VOID Heartbeat();
    VOID AdvertiseVoicePorts();
    VOID RespondToVoicePorts(const CXBSockAddr&);

    VOID Init();

    // Initialization
    InitStatus InitXNet();

    // Send messages
    VOID SendFindGame();
    VOID SendGameFound( const Nonce& );
    VOID SendJoinGame( const CXBSockAddr& );
    VOID SendJoinApproved( const CXBSockAddr& );
    VOID SendJoinDenied( const CXBSockAddr& );
    VOID SendPlayerJoined( const Player&, const CXBSockAddr& );
    VOID SendWave( const CXBSockAddr& );
    VOID SendHeartbeat( const CXBSockAddr& );
    VOID SendVoicePort( ACTION action , WORD wVoicePort , const CXBSockAddr& );
    

    // Receive messages
    BOOL ProcessBroadcastMessage();
    BOOL ProcessDirectMessage();
    VOID ProcessMessage( Message& );
    VOID ProcessMessage( Message&, const CXBSockAddr& );

    // Process incoming messages
    VOID ProcessFindGame( const MsgFindGame& );
    VOID ProcessGameFound( const MsgGameFound& );
    VOID ProcessJoinGame( const MsgJoinGame&, const CXBSockAddr& );
    VOID ProcessJoinApproved( const MsgJoinApproved&, const CXBSockAddr& );
    VOID ProcessJoinDenied( const CXBSockAddr& );
    VOID ProcessPlayerJoined( const MsgPlayerJoined&, const CXBSockAddr& );
    VOID ProcessWave( const CXBSockAddr& );
    VOID ProcessHeartbeat( const CXBSockAddr& );
    VOID ProcessVoicePort( const MsgVoicePort& , const CXBSockAddr& );

    // Handle keep-alive
    BOOL ProcessPlayerDropouts();

    // Utility
    VOID DestroyGameList();
    VOID DestroyPlayerList();
    static VOID GenRandom( WCHAR*, DWORD );
    static WCHAR GetRandVowel();
    static WCHAR GetRandConsonant();
    static VOID AppendConsonant( WCHAR*, BOOL );
    static VOID AppendVowel( WCHAR* );

    VOID LogXNetError( const CHAR*, INT ) const;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\VoiceChat\Voice.h ===
//-----------------------------------------------------------------------------
// File: Voice.h
//
// Hist: 08.08.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VOICE_H_INCLUDED
#define VOICE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <XBSocket.h>
#include <XBSockAddr.h>
#include <XBUtil.h> 
#include <cassert>
#include <vector>
#include "xvoice.h"
#include "Player.h"

const WORD  VOICE_PORT        = 10985;  // any port other than the first two
const BYTE  COMMUNICATOR_COUNT = 4;

//-----------------------------------------------------------------------------
// Utility functions and macros
//-----------------------------------------------------------------------------
extern "C" { ULONG DebugPrint( PCHAR Format, ... ); }

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}

#ifdef _WRITE_LOG
    void OpenFile(const char* szFileName , HANDLE *phFile);
    void CloseFile(HANDLE *phFile);
    void WriteToLogFile(HANDLE hFile , BYTE *pbBuffer , DWORD dwSize);
#endif




//-----------------------------------------------------------------------------
// Structures & classes
//-----------------------------------------------------------------------------


    
//-----------------------------------------------------------------------------
// Name: struct MEDIA_PACKET_LIST
// Desc: Linked list of XMEDIAPACKET structures to help manage packet
//          management between XMOs
//-----------------------------------------------------------------------------
struct MEDIA_PACKET_LIST
{
    MEDIA_PACKET_LIST   *pNext;
    XMEDIAPACKET        MediaPacket;
    DWORD               dwStatus;
    DWORD               dwCompletedSize;

    MEDIA_PACKET_LIST(DWORD dwSize , DWORD dwStatusIn) : pNext(NULL) , dwStatus(dwStatusIn) , dwCompletedSize(0)
    {
        MediaPacket.dwMaxSize = dwSize;

        MediaPacket.pvBuffer = new BYTE[dwSize];
        if( NULL != MediaPacket.pvBuffer )
        {
            memset(MediaPacket.pvBuffer , 0 , dwSize);
            MediaPacket.pdwStatus = &dwStatus;
            MediaPacket.pdwCompletedSize = &dwCompletedSize;
        }
        else
        {
            MediaPacket.pdwStatus = NULL;
            MediaPacket.pdwCompletedSize = NULL;
        }
        MediaPacket.prtTimestamp = NULL;
        MediaPacket.hCompletionEvent = NULL;

    }
    ~MEDIA_PACKET_LIST()
    {
        if( NULL !=  MediaPacket.pvBuffer)
        {
            delete [] MediaPacket.pvBuffer;
        }
    }
};



//-----------------------------------------------------------------------------
// Name: struct QUEUEXMO_PER_CHATTER
// Desc: Handles queueing incoming voice packets from other voice 
//          communicators.  Each listener has one queue for each remotespeaker
//          and then output is mixed from each queue
//-----------------------------------------------------------------------------
struct QUEUEXMO_PER_CHATTER
{

    // Voice queuing XMO
    XVoiceQueueMediaObject         *m_pVoiceQueueXMO;

    // The IP address for the chatter
    SOCKADDR_IN                     m_SockAddrDest;

    // If the queue ever provided output
    BOOL                            m_bProvidedOutput;

    // Pointer to next node in list
    QUEUEXMO_PER_CHATTER            *m_pNext;

    QUEUEXMO_PER_CHATTER() : m_pVoiceQueueXMO(NULL) , m_bProvidedOutput(FALSE) , m_pNext(NULL) {}
    QUEUEXMO_PER_CHATTER(const QUEUEXMO_PER_CHATTER& queue)
    {
        m_pVoiceQueueXMO = queue.m_pVoiceQueueXMO;

        m_SockAddrDest.sin_family = AF_INET;
        m_SockAddrDest.sin_addr = queue.m_SockAddrDest.sin_addr;
        m_SockAddrDest.sin_port = queue.m_SockAddrDest.sin_port;

        m_bProvidedOutput = FALSE;
        m_pNext = NULL;
    }

    ~QUEUEXMO_PER_CHATTER()
    {
        if( NULL != m_pVoiceQueueXMO )
        {
            m_pVoiceQueueXMO->Release();
            m_pVoiceQueueXMO = NULL;
        }
    }


    BOOL IsSameCommunicator(const IN_ADDR &inAddr , WORD wVoicePort)
    {
        if( (!memcmp(&m_SockAddrDest.sin_addr , &inAddr , sizeof(in_addr))) &&
                (m_SockAddrDest.sin_port == htons(wVoicePort)))
        {
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsSameCommunicator(const SOCKADDR_IN &addr)
    {
        if( (!memcmp(&m_SockAddrDest.sin_addr , &addr.sin_addr , sizeof(in_addr))) &&
                (m_SockAddrDest.sin_port == addr.sin_port))
        {
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsSameXbox(const IN_ADDR &inAddr)
    {
        if( (!memcmp(&m_SockAddrDest.sin_addr , &inAddr , sizeof(in_addr))))
        {
            return TRUE;
        }
        return FALSE;
    }

};




//-----------------------------------------------------------------------------
// Name: class CCommunicator
// Desc: Abstract base class - Derived from to provide Xbox Communicator
//          functionality
//-----------------------------------------------------------------------------
class CCommunicator
{
public:
    //
    // Constructor / destructor
    //
    CCommunicator(
                WORD   wHeadsetPort = 0,
                HANDLE hEvtMicInput = INVALID_HANDLE_VALUE,
                WORD   wCodecTag = WAVE_FORMAT_VOXWARE_SC06,
                WORD   wVoiceSamplingRate = 8000,
                WORD   wCodecSamplingRate = 8000,
                WORD   wVoiceBufferTime = 40,
                WORD   wVoiceBufferCount = 4
                );

    virtual ~CCommunicator();

    virtual HRESULT Inserted(); // Handle insertion
    virtual void Removed();     // Handle removal

    // Input code
    virtual HRESULT OnMicrophoneInput();
    virtual HRESULT OnCompressedInput( XMEDIAPACKET *pInput , BOOL bVoiceDetected = TRUE) = 0;

    // This routine gets called every voice loop , to give derived classes a
    // place to look for new output data (e.g. read from the network)
    virtual HRESULT CheckForOutputData() = 0;

    virtual HRESULT QueuePCMForOutput( XMEDIAPACKET *pOutput );

    // Status function
    virtual BOOL IsCommunicatorActive()
    {
        return (NULL != m_pMicrophone);
    }

protected:

    // These functions manage the queues of XMEDIAPACKETS for the XMOs
    void CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wBufferSize, WORD wCount , DWORD dwStatus);
    void DeleteQueue(MEDIA_PACKET_LIST *pQueue);
    void QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pBuffer);
    void QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pBuffer);

    HRESULT CompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst , BOOL *pvbVoiceDetected );
    
    virtual void Cleanup();

    // The following XMO objects are created on call to Inserted()
    XMediaObject             *m_pMicrophone;
    XMediaObject             *m_pHeadphone;
    XMediaObject             *m_pEncoder;

    // Port number for headset - 0 , 1 , 2 , 3
    WORD                     m_wHeadsetPort; 

    // The 2 queues for the buffers that are sent to the microphone/headphone
    MEDIA_PACKET_LIST        *m_pBeginMicrophoneQueuedBuffers;
    MEDIA_PACKET_LIST        *m_pBeginHeadphoneQueuedBuffers;

    // The Media packet used by the codec
    XMEDIAPACKET             m_CodecMediaBuffer;
    
    // Events for completion on microphone/headphone work
    HANDLE                   m_hMicrophoneWorkEvent; 
    HANDLE                   m_hHeadphoneWorkEvent; 
    BOOL                     m_bCreateMicrophoneEvent;


    // Settings for the headset and codecs
    WORD                     m_wVoiceSamplingRate;
    WORD                     m_wCodecSamplingRate;
    WORD                     m_wVoiceBufferTime;
    WORD                     m_wVoiceBufferSize;
    WORD                     m_wCodecBufferSize;
    WORD                     m_wVoiceBuffersCount;
    WORD                     m_wCodecTag;


#ifdef _WRITE_LOG
    // Diagnosis stuff
    HANDLE                   m_hFileRawPCMData;
    HANDLE                   m_hFileCompressed;
    HANDLE                   m_hFileDecompressed;
#endif

};




//-----------------------------------------------------------------------------
// Name: class CVoiceChatCommunicator
// Desc: Class definition for Communicator to be used for chat between
//          several boxes
//-----------------------------------------------------------------------------
class CVoiceChatCommunicator : public CCommunicator
{
public:
    CVoiceChatCommunicator(
                WORD   wHeadsetPort = 0,
                HANDLE hEvtMicInput = INVALID_HANDLE_VALUE,
                WORD   wCodecTag = WAVE_FORMAT_VOXWARE_SC06,
                WORD   wVoicePort = VOICE_PORT,
                WORD   wVoiceSamplingRate = 8000,
                WORD   wCodecSamplingRate = 8000,
                WORD   wVoiceBufferTime = 40,
                WORD   wVoiceBufferCount = 4
                );
    virtual ~CVoiceChatCommunicator();

    virtual HRESULT Inserted();
    virtual void Removed();

    virtual HRESULT OnCompressedInput( XMEDIAPACKET *pInput , BOOL bVoiceDetected = TRUE);
    virtual HRESULT CheckForOutputData();

    HRESULT UpdateChatList(BOOL bAdd  , const IN_ADDR &inAddr , WORD wVoicePort = 0);
    HRESULT RemoveChatters(const IN_ADDR &inAddr);

    WORD    GetVoicePort(){return m_wVoicePort;}

protected:
    void Cleanup();

    // Routines to handle sending and receiving voice packets over
    // the network
    void SendVoicePacket( XMEDIAPACKET *pMediaPacket );
    void ReadNetwork( );

    // Routines for mixing output from multiple remote chatters
    HRESULT ProcessQueues();
    void SumUpPacket( XMEDIAPACKET *pMediaPacket );


    // Queue handling functions
    void AddToQueueXMOList(const QUEUEXMO_PER_CHATTER& queue);
    QUEUEXMO_PER_CHATTER* FindInQueueXMOList( const IN_ADDR &inAddr , WORD wVoicePort);
    QUEUEXMO_PER_CHATTER* FindInQueueXMOList( const SOCKADDR_IN &addr);
    void DeleteFromQueueXMOList(QUEUEXMO_PER_CHATTER *pQueue);
    void DeleteQueueXMOList();

    // Voice queuing XMOs - one for each chatter in the game
    QUEUEXMO_PER_CHATTER     *m_VoiceQueueXMOList;
    WORD                     m_nChattersCount;


    // Media packet for getting the output from the queuing XMO
    XMEDIAPACKET             m_MixedSoundMediaBuffer;

    // MediaPacket for getting the input from the network
    XMEDIAPACKET             m_NetworkMediaBuffer;

    // Buffer for mixing the sound packets
    float                    *m_fMixingBuffer;
    WORD                     m_wMixingBufferSize;

    // The point where the mixing was resumed
    QUEUEXMO_PER_CHATTER     *m_pResumePoint;

    // Count of mixed packets
    WORD                     m_nMixedPacketsCount;


    // Network data
    SOCKET                   m_VoiceSock;
    WORD                     m_wVoicePort;

    // Interval for output
    DWORD                    m_IntervalForOutput;
    DWORD                    m_LastOutputTimeStamp;


};




//-----------------------------------------------------------------------------
// Name: class CCommunicatorMgr
// Desc: Manages the array of CCommunicators on an Xbox
//-----------------------------------------------------------------------------
class CCommunicatorMgr
{
public:
    CCommunicatorMgr();
    ~CCommunicatorMgr();

    HRESULT Process(MsgVoicePort *msgCommunicatorStatus);

    HRESULT Initialize(PlayerList& playerlist , WORD wCodecTag , MsgVoicePort *msgCommunicatorStatus);
    HRESULT UpdateChatList(BOOL bAdd  , const IN_ADDR &inAddr , WORD wVoicePort = 0);

private:
    // Check status for the voice units
    HRESULT CheckForHotPlugs(MsgVoicePort *msgCommunicatorStatus);
    HRESULT CheckInitialState();

    // The array of voice units
    CVoiceChatCommunicator* m_pVoiceUnits[COMMUNICATOR_COUNT];

    // Events for the voice units
    HANDLE                  m_hCommunicatorWorkEvent; 

    DWORD                   m_dwMicrophoneState;
    DWORD                   m_dwHeadphoneState;
    DWORD                   m_dwConnectedCommunicators;
};

#endif  // VOICE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\DelayVoice.cpp ===
//-----------------------------------------------------------------------------
// File: DelayVoice.cpp
//
// Hist: 08.08.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "DelayVoice.h"

#define DSOUND_INCLUDE_XHAWK


//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CDelayVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////

CDelayVoiceUnit::CDelayVoiceUnit():
        m_pMicrophone(NULL),
        m_pHeadphone(NULL),
        m_dwPortNumber(0),
        m_hMicrophoneWorkEvent(NULL),
        m_hHeadphoneWorkEvent(NULL),
        m_pBeginMicrophoneQueuedBuffers(NULL),
        m_pBeginHeadphoneQueuedBuffers(NULL),
        m_fPreBuffering(FALSE),
        m_dwPreBufferRegions(0)
{}

void CDelayVoiceUnit::Cleanup()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
    }    

    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
        m_pHeadphone = NULL;
    }

    
    if (m_hMicrophoneWorkEvent) 
    {
        CloseHandle(m_hMicrophoneWorkEvent);
        m_hMicrophoneWorkEvent = NULL;
    }

    if (m_hHeadphoneWorkEvent) 
    {
        CloseHandle(m_hHeadphoneWorkEvent);
        m_hHeadphoneWorkEvent = NULL;
    }

    if( NULL != m_pBeginMicrophoneQueuedBuffers )
    {
        DeleteQueue(m_pBeginMicrophoneQueuedBuffers);
        m_pBeginMicrophoneQueuedBuffers = NULL;

    }

    if( NULL != m_pBeginHeadphoneQueuedBuffers )
    {
        DeleteQueue(m_pBeginHeadphoneQueuedBuffers);
        m_pBeginHeadphoneQueuedBuffers = NULL;
    }
}

void CDelayVoiceUnit::DeleteQueue(MEDIA_PACKET_LIST *pQueue)
{
    assert(pQueue->pNext != pQueue);

    MEDIA_PACKET_LIST *pTmpBuff = pQueue;

    pQueue = pQueue->pNext;
    pTmpBuff->pNext = NULL; //Break queue

    while(NULL != pQueue)
    {
        pTmpBuff = pQueue->pNext;
        delete pQueue;
        pQueue = pTmpBuff;
    }
}

CDelayVoiceUnit::~CDelayVoiceUnit()
{
    Cleanup();
}

void CDelayVoiceUnit::CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wSize , DWORD dwStatus)
{
    MEDIA_PACKET_LIST *pTmp = NULL;
    MEDIA_PACKET_LIST *pHead = NULL;
    
    
    //
    // Create linked-list
    //
    for( int i = 0 ; i <  wSize ; i++ )
    {
        if( pTmp )
        {
            pTmp->pNext = new MEDIA_PACKET_LIST(dwStatus);
            pTmp = pTmp->pNext;
        }
        else
        {
            pTmp = new MEDIA_PACKET_LIST(dwStatus);
            pHead = pTmp;
        }
        if( NULL == pTmp )
        {
            break;
        }
    }

    if(NULL == pTmp)
    {
        //
        // Something went wrong, release allocated memory
        //
        pTmp = pHead;

        while(NULL != pTmp)
        {
            pHead = pTmp->pNext;
            delete pTmp;
            pTmp = pHead;
        }
        *pQueue = NULL;
    }
    else
    {
        //
        // Close queue
        //
        pTmp->pNext = pHead;
        *pQueue = pHead;
    }
    
}

void CDelayVoiceUnit::Init(DWORD dwPortNumber)
{
    m_dwPortNumber = dwPortNumber;
}

void CDelayVoiceUnit::Process()
{
    DWORD dwReason;
    HRESULT hr;

        if( NULL == m_hMicrophoneWorkEvent )
        {
            return; // No Xbox Communicator inserted
        }

        for( ;; )
        {
            dwReason = WaitForSingleObject( m_hMicrophoneWorkEvent, 16);

            switch (dwReason)
            {
            case WAIT_OBJECT_0://Microphone
                hr = OnMicrophoneReadComplete();
                if(FAILED(hr))
                {
                    DebugPrint("Failure OnMicrophoneReadComplete = %d\n" , hr);
                    return;
                }
                else
                {
                    PlayToHeadphone();  
                }
                break;
            default: //Timeout
                return;
            }
        
        }
}

void CDelayVoiceUnit::SetSockAddr(const IN_ADDR &addrPlayer)
{
}

HRESULT CDelayVoiceUnit::Inserted()
{
    HRESULT         hr;
    WAVEFORMATEX    wfxFormat;
    
    DebugPrint("CDelayVoiceUnit::Inserted()...Xbox Communicator Inserted\n");

    //
    // The headset initialization
    //
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    //
    //  Create a microphone and a headphone
    //
    DebugPrint("CDelayVoiceUnit::Inserted()...Creating microphone...\n");
    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                 &wfxFormat, &m_pMicrophone);

    if( FAILED( hr ) )
    {
        DebugPrint("CDelayVoiceUnit::Inserted()...Microphone failed with %x", hr);
        return hr;
    }

    DebugPrint("CDelayVoiceUnit::Inserted()...Creating headphone...\n");
    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                 &wfxFormat, &m_pHeadphone);

    if( FAILED( hr ) )
    {
        DebugPrint("CDelayVoiceUnit::Inserted()...Headphone failed with %x", hr);
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
        return hr;
    }

    //
    // Other member initializing...
    //
    m_hMicrophoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hHeadphoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    
    m_fPreBuffering = TRUE;
    m_dwPreBufferRegions = 0;

/*#ifdef _DEBUG
    //
    // Log File for the converted signal 16kHz->8kHz
    //
    OpenFile("D:\\RawPCMData.log" , &m_hFileRawPCMData);
    
    //
    // Log File for the compressed signal
    //
    OpenFile("D:\\Compressed.log" , &m_hFileCompressed);

    //
    // Log File for the decompressed signal
    //
    OpenFile("D:\\Decompressed.log" , &m_hFileDecompressed);
#endif*/
    //
    // Create the buffers for microphone
    //
    CreateQueue(&m_pBeginMicrophoneQueuedBuffers , XVOICE_TOTAL_REGIONS , (DWORD)XMEDIAPACKET_STATUS_PENDING);
    if( NULL ==  m_pBeginMicrophoneQueuedBuffers)
    {
        DebugPrint("CDelayVoiceUnit::Inserted()...Not enough memory for buffers!\n");
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // Create the buffers for headphone
    //
    CreateQueue(&m_pBeginHeadphoneQueuedBuffers , XVOICE_TOTAL_REGIONS , XMEDIAPACKET_STATUS_SUCCESS);
    if( NULL ==  m_pBeginHeadphoneQueuedBuffers)
    {
        DebugPrint("CDelayVoiceUnit::Inserted()...Not enough memory for buffers!\n");
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // Feed the microphone with buffers; we enqueue all the buffers to the microphone which is going to fill 
    // them with data gradually
    //
    MEDIA_PACKET_LIST *pTmpMBuff = m_pBeginMicrophoneQueuedBuffers;
    
    for( int i = 0 ; i < XVOICE_TOTAL_REGIONS ; i++ )
    {
        
        QueueMicrophoneBuffer(pTmpMBuff);
        pTmpMBuff = pTmpMBuff->pNext;
    }

    //
    // We don't enqueue buffers to the headphone yet; this is going to be done when buffers from the microphone
    // start to arrive
    //

    return S_OK;
}

void CDelayVoiceUnit::Removed()
{
    CDelayVoiceUnit::Cleanup();
}

void CDelayVoiceUnit::QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event 
    //

    pMediaPacket->hCompletionEvent = m_hMicrophoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pMicrophone->Process(NULL, pMediaPacket));


}

void CDelayVoiceUnit::QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event
    //
    pMediaPacket->hCompletionEvent = m_hHeadphoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pHeadphone->Process(pMediaPacket, NULL));

}

void CDelayVoiceUnit::SendPacketToRenderer()
{
    memcpy((m_pBeginHeadphoneQueuedBuffers->MediaPacket).pvBuffer ,
           (m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer , 
            XVOICE_BUFFER_REGION_SIZE);
    m_pBeginHeadphoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
}

BOOL CDelayVoiceUnit::IsPacketPreparedForRender()
{
    return (XMEDIAPACKET_STATUS_PENDING == m_pBeginHeadphoneQueuedBuffers->dwStatus);
}

HRESULT CDelayVoiceUnit::OnMicrophoneReadComplete()
{
    HRESULT hr;
    
    //
    // One microphone buffer is filled with data
    //
    if(XMEDIAPACKET_STATUS_PENDING != m_pBeginMicrophoneQueuedBuffers->dwStatus)
    {
        if( SUCCEEDED( m_pBeginMicrophoneQueuedBuffers->dwStatus ) )
        {
            //
            // Send the packet to the headphone
            //
            SendPacketToRenderer();
            
        }

        if( XMEDIAPACKET_STATUS_FAILURE == m_pBeginMicrophoneQueuedBuffers->dwStatus )
        {
            hr = E_FAIL;
            return hr;
        }
        else
        {
            //
            // Requeue the packet
            //  
            m_pBeginMicrophoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
            QueueMicrophoneBuffer(m_pBeginMicrophoneQueuedBuffers);
            m_pBeginMicrophoneQueuedBuffers = m_pBeginMicrophoneQueuedBuffers->pNext;
        }

    }

    return S_OK;
}

HRESULT CDelayVoiceUnit::PlayToHeadphone()
{
    if(IsPacketPreparedForRender())
    {
        QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
    }

    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\DelayVoice.h ===
//-----------------------------------------------------------------------------
// File: DelayVoice.h
//
// Hist: 08.08.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VOICE_H_INCLUDED
#define VOICE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <xtl.h>
#include <cassert>
#include <stdio.h>
#include "xvoice.h"

const int VOICE_SAMPLING_RATE = 8000;
const int XVOICE_BYTES_PER_MS = (((ULONG)( VOICE_SAMPLING_RATE / 1000.0 )) * 2 );

const int XVOICE_BUFFER_REGION_TIME = 40; 
const int XVOICE_BUFFER_REGION_SIZE = ( XVOICE_BYTES_PER_MS * XVOICE_BUFFER_REGION_TIME );
const int XVOICE_PREBUFFER_REGIONS = 20;
const int XVOICE_TOTAL_REGIONS = ( XVOICE_PREBUFFER_REGIONS + 2 );
const int XVOICE_BUFFER_SIZE = ( XVOICE_BUFFER_REGION_SIZE * XVOICE_TOTAL_REGIONS );

const int VOICE_DEVICES_COUNT = 2; //Microphone & Headphone
const int MICROPHONE = 0;
const int HEADPHONE = 1;


//////////////////////////////////////////////////////////////////////////////
// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
    ULONG
    DebugPrint(
        PCHAR Format,
        ...
        );
}

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
//////////////////////////////////////////////////////////////////////////////

struct MEDIA_PACKET_LIST
{
    MEDIA_PACKET_LIST   *pNext;
    XMEDIAPACKET        MediaPacket;
    DWORD               dwStatus;
    DWORD               dwCompletedSize;

    MEDIA_PACKET_LIST(DWORD dwStatusIn) : pNext(NULL) , dwStatus(dwStatusIn) , dwCompletedSize(0)
    {
        MediaPacket.dwMaxSize = XVOICE_BUFFER_REGION_SIZE;
        MediaPacket.pvBuffer = new BYTE[XVOICE_BUFFER_REGION_SIZE];
        memset(MediaPacket.pvBuffer , 0 , XVOICE_BUFFER_REGION_SIZE);
        MediaPacket.pdwCompletedSize = NULL;
        MediaPacket.pdwStatus = NULL;
        MediaPacket.prtTimestamp = NULL;
        MediaPacket.hCompletionEvent = NULL;
    }
    ~MEDIA_PACKET_LIST()
    {
        if( NULL !=  MediaPacket.pvBuffer)
        {
            delete [] MediaPacket.pvBuffer;
        }
    }
};

//
// CVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CDelayVoiceUnit
{
public:
    virtual HRESULT PlayToHeadphone();
    virtual HRESULT OnMicrophoneReadComplete();
    
    virtual void SetSockAddr(const IN_ADDR &addrPlayer);

    virtual HRESULT Inserted();
    virtual void Removed();
    virtual void Process();
    virtual void Init(DWORD dwPortNumber);

    virtual void SendPacketToRenderer();
    virtual BOOL IsPacketPreparedForRender();

  CDelayVoiceUnit();
  virtual ~CDelayVoiceUnit();

  DWORD GetPortNumber() { return m_dwPortNumber; }


protected:
    void CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wSize , DWORD dwStatus);
    void DeleteQueue(MEDIA_PACKET_LIST *pQueue);
    void QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pBuffer);
    void QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pBuffer);

    //
    // XMO objects created on call to Inserted()
    //
    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;

    //
    // Stuff given to us at init
    //
    DWORD m_dwPortNumber; // Port number for headset 


    //
    // The 2 queues for the buffers that are sent to the microphone/headphone
    //
    MEDIA_PACKET_LIST *m_pBeginMicrophoneQueuedBuffers;
    MEDIA_PACKET_LIST *m_pBeginHeadphoneQueuedBuffers;


    //
    // Events for completion on microphone/headphone work
    //
    HANDLE m_hMicrophoneWorkEvent; 
    HANDLE m_hHeadphoneWorkEvent; 

    virtual void Cleanup();

    //
    //  Status
    //
    BOOL   m_fPreBuffering;
    DWORD  m_dwPreBufferRegions;

};

#endif  // VOICE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\VoiceLoopBack.h ===
//-----------------------------------------------------------------------------
// File: VoiceLoopBack.h
//
// Desc: Demonstrates the usage of the Xbox communicator.
//       This sample naively sends any input from the first
//       headset it finds connected to the system out to the
//       same headset with a 1 second delay.
//
// Hist: 08.14.01 - New for Aug M1 release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBStopWatch.h>
#include <cassert>
#include <algorithm>
#include "DelayVoice.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD COLOR_HIGHLIGHT   = 0xffffff00; // Yellow
const DWORD COLOR_GREEN       = 0xff00ff00;
const DWORD COLOR_NORMAL      = 0xffffffff;
const DWORD MAX_ERROR_STR     = 64;
const DWORD MAX_STATUS_STR    = 128;


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont             m_Font;                         // game font
    WCHAR               m_strError[ MAX_ERROR_STR ];    // error message
    WCHAR               m_strStatus[ MAX_STATUS_STR ];  // status

    // Voice Related Data
    HANDLE              m_hVoiceThread;
    HANDLE              m_hVoiceDeleteEvent;
    DWORD               m_dwVoiceThreadId;
    CDelayVoiceUnit    *m_pVoiceUnit;                   // The single headset

public:
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

    // Voice Related
    HRESULT VoiceThreadProc();
    static DWORD WINAPI StaticVoiceThreadProc(LPVOID pParameter);

private:
    VOID Init();

    // Voice related functions
    VOID  KillVoiceProcessing();
    int   FindHeadsetPort();
    VOID  StartVoiceProcessing();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\voiceloopback\VoiceLoopBack.cpp ===
//-----------------------------------------------------------------------------
// File: VoiceLoopBack.cpp
//
// Desc: Demonstrates basic usage of the Xbox communicator.
//       This sample just monitors the microphone of each connected
//       communicator and routes the data directly to that communicator's
//       headphone
//
// Hist: 08.14.01 - New for August M1 Online XDK release
//       02.18.02 - Cleaned up for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XButil.h>
#include <XBFont.h>
#include <XBStopWatch.h>
#include <cassert>
#include <algorithm>
#include <xvoice.h>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD COLOR_HIGHLIGHT     = 0xffffff00;     // Yellow
const DWORD COLOR_GREEN         = 0xff00ff00;     // Green
const DWORD COLOR_NORMAL        = 0xffffffff;     // White
const DWORD MAX_ERROR_STR       = 64;
const DWORD MAX_STATUS_STR      = 128;


// Voice processing: 8kHz, 16 bit samples, 10 packets, 40ms each 
const DWORD VOICE_SAMPLE_RATE   = 8000;
const DWORD BYTES_PER_SAMPLE    = 2;
const DWORD NUM_PACKETS         = 1000;
const DWORD PACKET_SIZE         = VOICE_SAMPLE_RATE * BYTES_PER_SAMPLE / 25;



//-----------------------------------------------------------------------------
// Name: class CLoopbackCommunicator
// Desc: This class represents one instance of a Xbox Communicator performing
//          basic loopback from the microphone to the headphone
//-----------------------------------------------------------------------------
class CLoopbackCommunicator
{
public:
    CLoopbackCommunicator();
    ~CLoopbackCommunicator();

    HRESULT Initialize( DWORD dwPort );
    HRESULT Inserted();
    HRESULT Removed();
    HRESULT Process();

private:
    DWORD           m_dwControllerPort;

    // Microphone-related data
    BYTE*           m_pMicrophoneBuffer;
    DWORD           m_adwMicrophoneStatus[NUM_PACKETS];
    DWORD           m_dwMicrophonePacket;
    XMediaObject*   m_pMicrophoneXMO;
    
    // Headphone-related data
    BYTE*           m_pHeadphoneBuffer;
    DWORD           m_adwHeadphoneStatus[NUM_PACKETS];
    DWORD           m_dwHeadphonePacket;
    XMediaObject*   m_pHeadphoneXMO;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont             m_Font;                         // game font

    CLoopbackCommunicator m_aCommunicators[ XGetPortCount() ];
    DWORD               m_dwMicrophoneState;
    DWORD               m_dwHeadphoneState;
    DWORD               m_dwConnectedCommunicators;

public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    HRESULT CheckCommunicatorStatus();  // Handle device insertion/removal
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
{
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // In order to handle an Xbox Communicator being inserted between the two
    // calls to XGetDevices (or XGetDeviceChanges), we track the state of
    // microphone devices and headphone devices separately.
    m_dwConnectedCommunicators = 0;
    m_dwMicrophoneState = XGetDevices( XDEVICE_TYPE_VOICE_MICROPHONE );
    m_dwHeadphoneState  = XGetDevices( XDEVICE_TYPE_VOICE_HEADPHONE );

    for( int i = 0; i < XGetPortCount(); i++ )
    {
        // Tell the CLoopbackCommunicator which port it owns.  This doesn't
        // mean that a Communicator is inserted there - we'll call Inserted() 
        // when that happens in CheckCommunicatorStatus
        m_aCommunicators[i].Initialize( i );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Check for insertion and removal of communicators
    CheckCommunicatorStatus();

    // For each active communicator, process I/O
    for( int i = 0; i < XGetPortCount(); i++ )
    {
        if( m_dwConnectedCommunicators & ( 1 << i ) )
        {
            m_aCommunicators[i].Process();
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000A0A6A, 1.0f, 0L );

    m_Font.DrawText(  64, 50, 0xffffffff, L"VoiceLoopBack" );

    // Display a status message
    if( m_dwConnectedCommunicators == 0 )
    {
        m_Font.DrawText( 100, 184, COLOR_GREEN, L"Please insert an Xbox Communicator\ninto one or more controllers." );
    }
    else
    {
        m_Font.DrawText( 100, 184, COLOR_GREEN, L"Speak into the microphone of your Xbox\nCommunicator, and you should hear your\nvoice through the headphone." );
        for( int i = 0; i < XGetPortCount(); i++ )
        {
            if( m_dwConnectedCommunicators & ( 1 << i ) )
            {
                WCHAR str[100];
                swprintf( str, L"Communicator connected to port %d", i );
                m_Font.DrawText( 100.0f, 300.0f + 30 * i, COLOR_GREEN, str );
            }
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CheckCommunicatorStatus()
// Desc: Handles any changes in the status of Xbox Communicators.  In order
//          to handle the possibility that a device could be inserted 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CheckCommunicatorStatus()
{
    // Check the microphones
    DWORD dwMicrophoneInsertions;
    DWORD dwMicrophoneRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_VOICE_MICROPHONE, 
                       &dwMicrophoneInsertions,
                       &dwMicrophoneRemovals );

    // Check the headphones
    DWORD dwHeadphoneInsertions;
    DWORD dwHeadphoneRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_VOICE_HEADPHONE, 
                       &dwHeadphoneInsertions,
                       &dwHeadphoneRemovals );

    // Update our internal state for removals
    m_dwMicrophoneState &= ~( dwMicrophoneRemovals );
    m_dwHeadphoneState  &= ~( dwHeadphoneRemovals );

    // Update state for new insertions
    m_dwMicrophoneState |= dwMicrophoneInsertions;
    m_dwHeadphoneState  |= dwHeadphoneInsertions;

    for( int i = 0; i < XGetPortCount(); i++ )
    {
        // If either the microphone or the headphone was
        // removed since last call, remove the communicator
        if( ( m_dwConnectedCommunicators & ( 1 << i ) ) &&
            ( ( dwMicrophoneRemovals & ( 1 << i ) ) ||
              ( dwHeadphoneRemovals  & ( 1 << i ) ) ) )
        {
            // Remove the Communicator
            m_aCommunicators[i].Removed();
            m_dwConnectedCommunicators &= ~( 1 << i );
        }

        // If both microphone and headphone are present, and
        // we didn't have a communicator here last frame,
        // register the insertion
        if( ( m_dwMicrophoneState & ( 1 << i ) ) &&
            ( m_dwHeadphoneState  & ( 1 << i ) ) &&
            !( m_dwConnectedCommunicators & ( 1 << i ) ) )
        {
            // Insert the headset
            if( SUCCEEDED( m_aCommunicators[i].Inserted() ) )
                m_dwConnectedCommunicators |= ( 1 << i );
        }
    }

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: CLoopbackCommunicator (ctor)
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CLoopbackCommunicator::CLoopbackCommunicator()
{
    m_dwControllerPort = -1;
    m_pMicrophoneBuffer= NULL;
    m_pHeadphoneBuffer= NULL;
    m_pMicrophoneXMO   = NULL;
    m_pHeadphoneXMO    = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CLoopbackCommunicator (Dtor)
// Desc: Frees up any resources
//-----------------------------------------------------------------------------
CLoopbackCommunicator::~CLoopbackCommunicator()
{
    Removed();
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Initializes the communicator to a specific port
//-----------------------------------------------------------------------------
HRESULT CLoopbackCommunicator::Initialize( DWORD dwPort )
{
    m_dwControllerPort = dwPort;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Inserted
// Desc: Handles insertion of a communicator
//-----------------------------------------------------------------------------
HRESULT CLoopbackCommunicator::Inserted()
{
    HRESULT hr;

    OUTPUT_DEBUG_STRING( "Detected communicator insertion\n" );

    // Allocate a buffer for PCM sample data
    m_pMicrophoneBuffer = new BYTE[ PACKET_SIZE * NUM_PACKETS ];
    if( !m_pMicrophoneBuffer )
    {
        Removed();
        return E_OUTOFMEMORY;
    }

    // Allocate a buffer for PCM sample data
    m_pHeadphoneBuffer = new BYTE[ PACKET_SIZE * NUM_PACKETS ];
    if( !m_pHeadphoneBuffer )
    {
        Removed();
        return E_OUTOFMEMORY;
    }

    // Fill out a waveformat structure
    WAVEFORMATEX wfx;
    wfx.wFormatTag      = WAVE_FORMAT_PCM;
    wfx.cbSize          = 0;
    wfx.nChannels       = 1;
    wfx.nSamplesPerSec  = VOICE_SAMPLE_RATE;
    wfx.wBitsPerSample  = BYTES_PER_SAMPLE * 8;
    wfx.nBlockAlign     = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;

    //  Create the microphone device
    hr = XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_MICROPHONE, 
                                  m_dwControllerPort, 
                                  NUM_PACKETS,
                                  &wfx, 
                                  &m_pMicrophoneXMO );
    if( FAILED( hr ) )
    {
        OUTPUT_DEBUG_STRING( "Couldn't create microphone device\n" );
        Removed();
        return hr;
    }

    // Create the headphone device
    hr = XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_HEADPHONE, 
                                  m_dwControllerPort, 
                                  NUM_PACKETS,
                                  &wfx, 
                                  &m_pHeadphoneXMO );
    if( FAILED( hr ) )
    {
        OUTPUT_DEBUG_STRING( "Couldn't create headphone device\n" );
        Removed();
        return hr;
    }

    for( int i = 0; i < NUM_PACKETS; i++ )
    {
        // Seed the microphone device with all our media packets
        XMEDIAPACKET xmp;
        xmp.dwMaxSize           = PACKET_SIZE;
        xmp.pdwCompletedSize    = NULL;
        xmp.pContext            = NULL;
        xmp.prtTimestamp        = NULL;
        xmp.pvBuffer            = m_pMicrophoneBuffer + i * PACKET_SIZE;
        xmp.pdwStatus           = &m_adwMicrophoneStatus[i];
        *(xmp.pdwStatus)        = XMEDIAPACKET_STATUS_PENDING;

        m_pMicrophoneXMO->Process( NULL, &xmp );

        // Initialize all the headphone packets to be available
        m_adwHeadphoneStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;
    }

    m_dwMicrophonePacket = 0;
    m_dwHeadphonePacket = 0;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Removed
// Desc: Handles removal (or failed insertion) of a communicator
//-----------------------------------------------------------------------------
HRESULT CLoopbackCommunicator::Removed()
{
    OUTPUT_DEBUG_STRING( "Detected communicator removal or failed insertion.\n" );

    delete[] m_pMicrophoneBuffer;
    m_pMicrophoneBuffer = NULL;

    delete[] m_pHeadphoneBuffer;
    m_pHeadphoneBuffer = NULL;

    if( m_pMicrophoneXMO )
    {
        m_pMicrophoneXMO->Release();
        m_pMicrophoneXMO = NULL;
    }

    if( m_pHeadphoneXMO )
    {
        m_pHeadphoneXMO->Release();
        m_pHeadphoneXMO = NULL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process
// Desc: Processes the Microphone and Headphone XMOs to handle loopback voice
//          communication
//-----------------------------------------------------------------------------
HRESULT CLoopbackCommunicator::Process()
{
    while( m_adwMicrophoneStatus[ m_dwMicrophonePacket ] != XMEDIAPACKET_STATUS_PENDING &&
           m_adwHeadphoneStatus[ m_dwHeadphonePacket ] != XMEDIAPACKET_STATUS_PENDING )
    {
        // Copy the data into the headphone buffer
        memcpy( m_pHeadphoneBuffer + m_dwHeadphonePacket * PACKET_SIZE,
                m_pMicrophoneBuffer + m_dwMicrophonePacket * PACKET_SIZE,
                PACKET_SIZE );

        // Set the basic packet fields
        XMEDIAPACKET xmp;
        xmp.dwMaxSize           = PACKET_SIZE;
        xmp.pdwCompletedSize    = NULL;
        xmp.pContext            = NULL;
        xmp.prtTimestamp        = NULL;

        // Resubmit the microphone packet
        xmp.pvBuffer            = m_pMicrophoneBuffer + m_dwMicrophonePacket * PACKET_SIZE;
        xmp.pdwStatus           = &m_adwMicrophoneStatus[ m_dwMicrophonePacket ];
        (*xmp.pdwStatus)        = XMEDIAPACKET_STATUS_PENDING;
        m_pMicrophoneXMO->Process( NULL, &xmp );

        // Submit the copied data to the headphone
        xmp.pvBuffer            = m_pHeadphoneBuffer + m_dwHeadphonePacket * PACKET_SIZE;
        xmp.pdwStatus           = &m_adwHeadphoneStatus[ m_dwHeadphonePacket ];
        (*xmp.pdwStatus)        = XMEDIAPACKET_STATUS_PENDING;
        m_pHeadphoneXMO->Process( &xmp, NULL );

        m_dwMicrophonePacket = ( m_dwMicrophonePacket + 1 ) % NUM_PACKETS ;
        m_dwHeadphonePacket = ( m_dwHeadphonePacket + 1 ) % NUM_PACKETS ;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\coll.h ===
#ifndef __COLL_H
#define __COLL_H

#include <xtl.h>
#include "xobj.h"

#define COLLOBJ_ARENA (CXObject *)1
CXObject *CollCheck(D3DXVECTOR3 *pos, float radius);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\coll.cpp ===
#include "xarena.h"
#include "coll.h"

//-----------------------------------------------------------------------------
// Name: CollCheck
// Desc: Basic collision detection
//       For the walls, we just check absolute positions based on defined
//       size of the floor.
//       For tanks, we do a radius check. We could miss a few collisions
//         with this method due to the speed of some of the weapons, but
//         thats ok for our simpleton purposes.
//       For obstacle objects, we do a check based on the type of the object.
//-----------------------------------------------------------------------------
CXObject *CollCheck(D3DXVECTOR3 *pos, float radius)
{
	CXObject *collobj = NULL;
	float rad2, orad2, d2;
	D3DXVECTOR3 *opos, v;
	DWORD i;

	// check against walls
	if(pos->x < (-FLOORX/2.0f+radius))
	{
		pos->x = -FLOORX/2.0f+radius;
		collobj = COLLOBJ_ARENA;
	}
	else if(pos->x > (FLOORX/2.0f-radius))
	{
		pos->x = FLOORX/2.0f-radius;
		collobj = COLLOBJ_ARENA;
	}

	if(pos->z < (-FLOORZ/2.0f+radius))
	{
		pos->z = -FLOORZ/2.0f+radius;
		collobj = COLLOBJ_ARENA;
	}
	else if(pos->z > (FLOORZ/2.0f-radius))
	{
		pos->z = FLOORZ/2.0f-radius;
		collobj = COLLOBJ_ARENA;
	}

	// check against other tanks
	for(i=0; i<g_dwNumTanks; i++)
	{
		opos = &g_pTank[i]->m_pObj->m_vPosition;

		// if this is us, just bail
		if(pos==opos)
			continue;

		// not us, get radius of object
		orad2 = g_pTank[i]->m_pObj->GetRadius2();
		rad2 = radius*radius;							// get square of our radius

		d2 = (pos->x-opos->x)*(pos->x-opos->x) + 
				(pos->y-opos->y)*(pos->y-opos->y) + 
				(pos->z-opos->z)*(pos->z-opos->z);

		if(d2<(rad2+orad2))
		{
			collobj = g_pTank[i]->m_pObj;

			v = *pos - *opos;							// get position delta
			D3DXVec3Normalize(&v, &v);					// normalize it
			*pos = *opos + (float)sqrt(orad2+rad2)*v;	// separate us by combined radius
		}
	}

	return collobj;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\net.h ===
#ifndef __NET_H
#define __NET_H

#include "xtank.h"
#include "xmenu.h"

#ifdef __cplusplus
extern "C" {
#endif
			
#define MAX_PLAYER_NAME 14
struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    WCHAR wstrPlayerName[MAX_PLAYER_NAME];	// Player name

	CXTank *pTank;							// tank pointer
	DWORD dwTankIdx;						// index in tank list
};

extern DWORD g_dwBytesSent;
extern DWORD g_dwBytesReceived;

HRESULT Net_Init();
DWORD Net_Menu(DWORD cmd, XMenuItem *mi);

void Net_SendUpdateTank(CXTank *pTank);
void Net_SendFireWeapon(CXObject *pObj, BYTE bType);
void Net_SendKill(DPNID dpnidKiller);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\net.cpp ===
//-----------------------------------------------------------------------------
// Notes: This attempts to show a basic usage of networking on
//        the XBox with DPlay. It absolutely does *NOT* illustrate
//        an adequate implementation of game useable networking
//        over a WAN. Much better dead-reckoning and prediction
//        would be necessary for reliable gameplay over a WAN.
//        Further releases will attempt to improve this, but 
//        this one does not.
//
//        It also does not handle arbitration at all. There needs
//        to be a final arbiter of events like getting hit, picking
//        up powerups, etc.
//
//        Time synchronization is also not handled. This would improve
//        prediction ability as well. The lack of synchronization will
//        cause large inconsistancies in the locations of 
//        weapons from client to client.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <assert.h>

#include "xmenu.h"
#include "xtextbox.h"
#include "xdppeer.h"
#include "net.h"

#include "xarena.h"

extern XTextBox *XBox;

//-----------------------------------------------------------------------------
// dplay message handler
//-----------------------------------------------------------------------------
HRESULT WINAPI Net_DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg);

//-----------------------------------------------------------------------------
// GUID & port (fake guid)
//-----------------------------------------------------------------------------
GUID g_AppGUID = {0x2ae835e, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 }};
DWORD g_dwPort = 2399;								// game port

//-----------------------------------------------------------------------------
// multiplayer menu
//-----------------------------------------------------------------------------
XMenu *g_MPMenu;									// multiplayer menu
DWORD Net_Create(DWORD cmd, XMenuItem *mi);			// host a game
DWORD Net_Connect(DWORD cmd, XMenuItem *mi);		// connect to an existing game
DWORD Net_Disconnect(DWORD cmd, XMenuItem *mi);		// disconnect from current game

//-----------------------------------------------------------------------------
// game menu
//-----------------------------------------------------------------------------
XMenu *g_GameMenu;									// game menu
DWORD Net_FindGames(DWORD cmd, XMenuItem *mi);		// find game to join
DWORD Net_AbortFindGames(DWORD cmd, XMenuItem *mi);	// stop finding games to join
void Net_AddGame(ActiveGame *pGame);				// add an active game to game menu
void Net_DeleteGame(ActiveGame *pGame);				// removes an active game from the game menu

//-----------------------------------------------------------------------------
// App specific Player information 
//-----------------------------------------------------------------------------
#define PLAYER_ADDREF(a)    if(a) a->lRefCount++;
#define PLAYER_RELEASE(a)   if(a) {a->lRefCount--; if(a->lRefCount<=0) delete a;} a = NULL;

HRESULT Net_CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg);
void Net_DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg);

//-----------------------------------------------------------------------------
// App specific DirectPlay messages and structures 
//-----------------------------------------------------------------------------
#define MSGID_TANKUPDATE	0x01		// tank update
#define MSGID_FIRE			0x02		// weapon fire
#define MSGID_KILL			0x03		// someone was killed

#pragma pack(push, 1)
struct MSG_TYPE
{
    BYTE bType;
};

struct MSG_TANKUPDATE
{
	BYTE bType;

	WORD wPosx, wPosy, wPosz;
	WORD wVelx, wVely, wVelz;
	WORD wAccx, wAccz;
	WORD wYRot;
	WORD wRotVel;
};

void Net_AddTank(APP_PLAYER_INFO *pPlayerInfo);
void Net_UpdateTank(MSG_TANKUPDATE *tu, CXTank *tank);

struct MSG_FIRE
{
	BYTE bType;
	BYTE bWeaponType;
	WORD wPosx, wPosy, wPosz;
	float fRot;
};

CXObject *Net_FireWeapon(MSG_FIRE *fw, CXTank *tank);

struct MSG_KILL
{
	BYTE bType;
	DPNID dpnidKiller;
};

void Net_ShowKill(MSG_KILL *km, APP_PLAYER_INFO *pPlayerInfo);		// show kill message

#pragma pack(pop)


//-----------------------------------------------------------------------------
// Helper routines to minimize bandwidth usage
//-----------------------------------------------------------------------------
DWORD g_dwBytesSent=0;
DWORD g_dwBytesReceived=0;

void Net_VPosToWPos(D3DXVECTOR3 *pPos, WORD *wPosx, WORD *wPosy, WORD *wPosz);
void Net_WPosToVPos(WORD wPosx, WORD wPosy, WORD wPosz, D3DXVECTOR3 *pPos);


//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT Net_Init()
{
	// init dplay
	XDPInit(Net_DPMsgHandler);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT WINAPI Net_DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
    DPNMSG_RECEIVE *pReceiveMsg;
	DPNMSG_CREATE_PLAYER *pCreatePlayerMsg;
	DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg;
	
	MSG_TYPE *msg;

	APP_PLAYER_INFO *pPlayerInfo;
	ActiveGame *pGame;
	WCHAR s[80];

    switch(dwMsgType)
    {
		// handle adding and deleting games
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			pGame = XDPAddGame((DPNMSG_ENUM_HOSTS_RESPONSE *)pMsg);
			Net_AddGame(pGame);
			break;
		case DPPEER_MSGID_DELETE_GAME:
			Net_DeleteGame((ActiveGame *)pMsg);
			break;

		// handle player messages
        case DPN_MSGID_CREATE_PLAYER:
			pCreatePlayerMsg = (DPNMSG_CREATE_PLAYER *)pMsg;
			Net_CreatePlayer(pCreatePlayerMsg);
			pPlayerInfo = (APP_PLAYER_INFO *)pCreatePlayerMsg->pvPlayerContext;
			swprintf(s, L"%s joined the game.", pPlayerInfo->wstrPlayerName);
			XTextBox_AddItem(XBox, s);
			break;
        case DPN_MSGID_DESTROY_PLAYER:
			pDestroyPlayerMsg = (DPNMSG_DESTROY_PLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
			swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
			Net_DeletePlayer(pDestroyPlayerMsg);
			XTextBox_AddItem(XBox, s);
			break;

		// handle incoming game messages
        case DPN_MSGID_RECEIVE:
		    pReceiveMsg = (PDPNMSG_RECEIVE)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pReceiveMsg->pvPlayerContext;
            msg = (MSG_TYPE *)pReceiveMsg->pReceiveData;
			
			switch(msg->bType)
			{
				case MSGID_TANKUPDATE:
					g_dwBytesReceived += sizeof(MSG_TANKUPDATE);

					Net_UpdateTank((MSG_TANKUPDATE *)pReceiveMsg->pReceiveData, pPlayerInfo->pTank);
					break;

				case MSGID_FIRE:
					g_dwBytesReceived += sizeof(MSG_FIRE);

					CXObject *obj;
					obj = Net_FireWeapon((MSG_FIRE *)pReceiveMsg->pReceiveData, pPlayerInfo->pTank);
					obj->m_pvInfo = (void *)pPlayerInfo->dpnidPlayer;
					break;

				case MSGID_KILL:
					g_dwBytesReceived += sizeof(MSG_KILL);

					Net_ShowKill((MSG_KILL *)pReceiveMsg->pReceiveData, pPlayerInfo);
					break;

			}
			break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Net_Menu
// Desc: Builds multiplayer menu
//-----------------------------------------------------------------------------
DWORD Net_Menu(DWORD cmd, XMenuItem *mi)
{
	XMenuItem *mitem;

	if(g_MPMenu)
		delete g_MPMenu;

	g_MPMenu = XMenu_Init(320.0f, 120.0f, 4, 0, NULL);
	XMenu_SetTitle(g_MPMenu, L"Multiplayer Menu", 0xffffff00);

	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"CREATE GAME", Net_Create);
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR XBOX GAMES", Net_FindGames);
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR PC GAMES", Net_FindGames);
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"DISCONNECT FROM GAME", Net_Disconnect);

	XMenu_Activate(g_MPMenu);

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: Create
// Desc: Host a game
//-----------------------------------------------------------------------------
DWORD Net_Create(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before creating a new game.");
		return MROUTINE_DIE;
	}

	// create the game
	XDPCreate(g_dwPort, &g_AppGUID, 6, 0);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: Disconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
DWORD Net_Disconnect(DWORD cmd, XMenuItem *mi)
{
	// dont try to disconnect if we are not in a game
	if(!XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Not connected to a game.");
		return MROUTINE_DIE;
	}

	if(g_dwConnectStatus==GAME_HOSTING)
		XDPTerminate();
	else
		XDPDisconnect();

	XTextBox_AddItem(XBox, L"Disconnected from the game.");

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: FindGames
// Desc: Finds active games on the network.
//-----------------------------------------------------------------------------
DWORD Net_FindGames(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before searching for new games.");
		return MROUTINE_DIE;
	}

	// init game menu
	if(g_GameMenu)
		XMenu_Delete(g_GameMenu);

	g_GameMenu = XMenu_Init(320.0f, 140.0f, 20, 0, Net_AbortFindGames);
	XMenu_SetTitle(g_GameMenu, L"Game Menu", 0xffffff00);
	g_GameMenu->w = 440.0f;
	XMenu_SetMaxShow(g_GameMenu, 6);

	XMenu_AddItem(g_GameMenu, 0, L"ABORT", NULL);
	XMenu_Activate(g_GameMenu);

	XDPEnumHosts(g_dwPort, &g_AppGUID);

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: AbortFindGames
// Desc: Aborts finding active games on the network.
//-----------------------------------------------------------------------------
DWORD Net_AbortFindGames(DWORD cmd, XMenuItem *mi)
{
	XDPCancelEnumHosts();
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: AddGame
// Desc: Adds to the menu of currently active games.
//-----------------------------------------------------------------------------
void Net_AddGame(ActiveGame *pGame)
{
	XMenuItem *mi;
	const DPN_APPLICATION_DESC *pApp;
	WCHAR name[80], s[80];
	DWORD i;

	assert(pGame);

	pApp = &pGame->AppDesc;

	// see if this item already in the menu
	mi = NULL;
	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			mi = &g_GameMenu->items[i];
			break;
		}

	// build menu item string
	wcscpy(name, pApp->pwszSessionName);
	swprintf(s, L"%s (%d, %d/%d)", name, pGame->dwPing, pApp->dwCurrentPlayers, pApp->dwMaxPlayers);

	// add new item to menu or update existing item
	if(!mi)
	{
		mi = XMenu_AddItem(g_GameMenu, MITEM_ROUTINE, s, Net_Connect);
		mi->val1 = (DWORD)pGame;		// save pointer to this game
	}
	else
		XMenu_SetItemText(mi, s);
}

//-----------------------------------------------------------------------------
// Name: DeleteGame
// Desc: Deletes from the menu of currently active games.
//-----------------------------------------------------------------------------
void Net_DeleteGame(ActiveGame *pGame)
{
	DWORD i;

	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			XMenu_DeleteItem(&g_GameMenu->items[i]);
			break;
		}
}

//-----------------------------------------------------------------------------
// Name: Connect
// Desc: Connect to an existing game
//-----------------------------------------------------------------------------
DWORD Net_Connect(DWORD cmd, XMenuItem *mi)
{
	ActiveGame *pGame;

	// dont try to connect if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before connecting to a new game.");
		return MROUTINE_DIE;
	}

	pGame = (ActiveGame *)mi->val1;			// get pointer to desired game
	XDPConnect(&pGame->AppDesc, pGame->pHostAddr, pGame->pDevAddr);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: CreatePlayer
// Desc: Add a player to the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_CREATE_PLAYER
//-----------------------------------------------------------------------------
HRESULT Net_CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg)
{
    HRESULT hr;
    DWORD dwSize = 0;
    DPN_PLAYER_INFO *pdpPlayerInfo = NULL;

    // Get the peer info and extract its name
    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr) && hr!=DPNERR_BUFFERTOOSMALL)
        return hr;

    pdpPlayerInfo = (DPN_PLAYER_INFO *) new BYTE[dwSize];
    ZeroMemory(pdpPlayerInfo, dwSize);
    pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr))
        return hr;

    // Create a new and fill in a APP_PLAYER_INFO
    APP_PLAYER_INFO *pPlayerInfo = new APP_PLAYER_INFO;
    ZeroMemory(pPlayerInfo, sizeof(APP_PLAYER_INFO));
    pPlayerInfo->lRefCount = 1;				   
    pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

	// copy players name
	wcsncpy(pPlayerInfo->wstrPlayerName, pdpPlayerInfo->pwszName, MAX_PLAYER_NAME);

	// check for local player dpnid
	if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL)
		g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;
	else
		Net_AddTank(pPlayerInfo);		// if not local, add the tank

	// check for host player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_HOST)
        g_dpnidHost = pPlayerInfo->dpnidPlayer;

    // Tell DirectPlay to store this pPlayerInfo pointer in the pvPlayerContext.
    pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

	// increment number of players
	g_dwNumPlayers++;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: DeletePlayer
// Desc: Deletes a player from the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_DELETE_PLAYER
//-----------------------------------------------------------------------------
void Net_DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg)
{
    APP_PLAYER_INFO *pPlayerInfo;
	DWORD dwTankIdx;

	// get a pointer to the context of the player being deleted
	pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
	dwTankIdx = pPlayerInfo->dwTankIdx;

	// only delete tank if its remotely controlled
	if(g_pTank[dwTankIdx]->m_dwFlags&TANK_REMOTE)
	{
		delete g_pTank[dwTankIdx];
		g_dwNumTanks--;

		if(dwTankIdx<g_dwNumTanks)
		{
			g_pTank[dwTankIdx] = g_pTank[g_dwNumTanks];
			g_pTank[dwTankIdx]->m_dwTankIdx = dwTankIdx;
		}
	}

	// release player info
	PLAYER_RELEASE(pPlayerInfo);  

	// decrement # of players
	g_dwNumPlayers--;
}


//-----------------------------------------------------------------------------
// Name: VPosToWPos & WPosToVPos
// Desc: Convert 96 bit floating point position to 48 bit word position.
//       Used to minimize bandwidth usage.
//-----------------------------------------------------------------------------
void Net_VPosToWPos(D3DXVECTOR3 *pPos, WORD *wPosx, WORD *wPosy, WORD *wPosz)
{
	*wPosx = (WORD)((pPos->x+(FLOORX/2.0f)) * (float)(1<<(16-POSXBITS)));
	*wPosy = (WORD)((pPos->y+(FLOORY/2.0f)) * (float)(1<<(16-POSYBITS)));
	*wPosz = (WORD)((pPos->z+(FLOORZ/2.0f)) * (float)(1<<(16-POSZBITS)));
}

void Net_WPosToVPos(WORD wPosx, WORD wPosy, WORD wPosz, D3DXVECTOR3 *pPos)
{
	pPos->x = (float)wPosx / (float)(1<<(16-POSXBITS)) - (FLOORX/2.0f);
	pPos->y = (float)wPosy / (float)(1<<(16-POSYBITS)) - (FLOORY/2.0f);
	pPos->z = (float)wPosz / (float)(1<<(16-POSZBITS)) - (FLOORZ/2.0f);
}

void Net_FToW(float f, WORD *w, float lo, float hi)
{
	assert(f>=lo);
	assert(f<=hi);

	*w = (WORD)((f-lo)/(hi-lo)*65535.0f);
}

void Net_WToF(WORD w, float *f, float lo, float hi)
{
	*f = (float)w/65535.0f * (hi-lo) + lo;
}

void Net_FVecToWVec(D3DXVECTOR3 *v, WORD *wx, WORD *wy, WORD *wz, float lo, float hi)
{
	float d;

	d = 65535.0f/(hi-lo);

	*wx = (WORD)((v->x-lo)*d);
	*wy = (WORD)((v->y-lo)*d);
	*wz = (WORD)((v->z-lo)*d);
}

void Net_WVecToFVec(WORD wx, WORD wy, WORD wz, D3DXVECTOR3 *v, float lo, float hi)
{
	float d;

	d = (hi-lo)/65535.0f;

	v->x = (float)wx*d + lo;
	v->y = (float)wy*d + lo;
	v->z = (float)wz*d + lo;
}


//-----------------------------------------------------------------------------
// Name: Game Routines
// Desc: These routines handle the sending and receiving of the primary
//       data that makes up the game state.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Name: AddTank
// Desc: Called when another player enters the game.
//-----------------------------------------------------------------------------
void Net_AddTank(APP_PLAYER_INFO *pPlayerInfo)
{
	D3DXVECTOR3 v1;

	v1 = D3DXVECTOR3(100.0f, 0.0f, 100.0f);
	pPlayerInfo->pTank = new CXTank(&v1, D3DX_PI);
	pPlayerInfo->dwTankIdx = g_dwNumTanks;
	g_pTank[g_dwNumTanks] = pPlayerInfo->pTank;
	g_pTank[g_dwNumTanks]->m_dwTankIdx = g_dwNumTanks;
	g_pTank[g_dwNumTanks]->m_dwFlags |= TANK_REMOTE;
	g_dwNumTanks++;
}

//-----------------------------------------------------------------------------
// Name: SendUpdateTank
// Desc: Sends tank information to other clients.
//-----------------------------------------------------------------------------
void Net_SendUpdateTank(CXTank *tank)
{
	MSG_TANKUPDATE tu;
	WORD w;	// dummy

	tu.bType = MSGID_TANKUPDATE;

	Net_FVecToWVec(&tank->m_pObj->m_vPosition,
					&tu.wPosx, &tu.wPosy, &tu.wPosz,
					-FLOORX/2.0f, FLOORX/2.0f);

	Net_FVecToWVec(&tank->m_vVel, &tu.wVelx, &tu.wVely, &tu.wVelz,
					-100.0f, 100.0f);
	Net_FVecToWVec(&tank->m_vAcc, &tu.wAccx, &w, &tu.wAccz,
					-100.0f, 100.0f);

	Net_FToW(tank->m_pObj->m_vRotation.y, &tu.wYRot, -10.0f, 10.0f);
	Net_FToW(tank->m_fRotVel, &tu.wRotVel, -10.0f, 10.0f);

	DPN_BUFFER_DESC bufferDesc;
	bufferDesc.dwBufferSize = sizeof(MSG_TANKUPDATE);
	bufferDesc.pBufferData = (BYTE *)&tu;

	DPNHANDLE hAsync;
	g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
				   0, NULL, &hAsync, DPNSEND_NOLOOPBACK);

	g_dwBytesSent += sizeof(MSG_TANKUPDATE);
}

//-----------------------------------------------------------------------------
// Name: UpdateTank
// Desc: Updates tanks based on information received from other clients.
//-----------------------------------------------------------------------------
void Net_UpdateTank(MSG_TANKUPDATE *tu, CXTank *tank)
{
	D3DXVECTOR3 vPos;

	Net_WVecToFVec(tu->wPosx, tu->wPosy, tu->wPosz, &vPos, -FLOORX/2.0f, FLOORX/2.0f);

	// check for warp
	D3DXVECTOR3 dp = vPos - tank->m_pObj->m_vPosition;
	float dist = D3DXVec3Length(&dp);
	if((dist>10.0f) || (dist<1.0f))
	{
		tank->m_dwNumWarpFrames = 0;
		tank->m_pObj->m_vPosition = vPos;
	}
	else
	{
		tank->m_dwNumWarpFrames = (DWORD)dist;
		tank->m_vWarpDist = dp/(float)tank->m_dwNumWarpFrames;
	}

	Net_WVecToFVec(tu->wVelx, tu->wVely, tu->wVelz, &tank->m_vVel, -100.0f, 100.0f);
	Net_WVecToFVec(tu->wAccx, 0, tu->wAccz, &tank->m_vAcc, -100.0f, 100.0f);

	Net_WToF(tu->wYRot, &tank->m_pObj->m_vRotation.y, -10.0f, 10.0f);
	Net_WToF(tu->wRotVel, &tank->m_fRotVel, -10.0f, 10.0f);
}



//-----------------------------------------------------------------------------
// Name: SendFireWeapon
// Desc: Sends weapon fire event to other clients.
//-----------------------------------------------------------------------------
void Net_SendFireWeapon(CXObject *pObj, BYTE bType)
{
	MSG_FIRE fw;

	fw.bType = MSGID_FIRE;
	fw.bWeaponType = bType;
	Net_VPosToWPos(&pObj->m_vPosition, &fw.wPosx, &fw.wPosy, &fw.wPosz);
	fw.fRot = pObj->m_vRotation.y;

	DPN_BUFFER_DESC bufferDesc;
	bufferDesc.dwBufferSize = sizeof(MSG_FIRE);
	bufferDesc.pBufferData = (BYTE *)&fw;

	DPNHANDLE hAsync;
	g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
				   0, NULL, &hAsync, DPNSEND_NOLOOPBACK);

	g_dwBytesSent += sizeof(MSG_FIRE);
}

//-----------------------------------------------------------------------------
// Name: FireWeapon
// Desc: Fires weapons locally based on messages received from other clients.
//-----------------------------------------------------------------------------
CXObject *Net_FireWeapon(MSG_FIRE *fw, CXTank *tank)
{
	D3DXVECTOR3 vPos;

	Net_WPosToVPos(fw->wPosx, fw->wPosy, fw->wPosz, &vPos);

	return Weapon_Fire(&vPos, fw->fRot, fw->bWeaponType, WF_REMOTE);
}


//-----------------------------------------------------------------------------
// Name: SendKill
// Desc: Tell everyone we were killed. Dont use NOLOOPBACK flag so we 
//       get the message too.
//-----------------------------------------------------------------------------
void Net_SendKill(DPNID dpnidKiller)
{
	MSG_KILL km;

	km.bType = MSGID_KILL;
	km.dpnidKiller = dpnidKiller;

	DPN_BUFFER_DESC bufferDesc;
	bufferDesc.dwBufferSize = sizeof(MSG_KILL);
	bufferDesc.pBufferData = (BYTE *)&km;

	DPNHANDLE hAsync;
	g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1, 
					0, NULL, &hAsync, 0);

	g_dwBytesSent += sizeof(MSG_KILL);
}

//-----------------------------------------------------------------------------
// Name: ShowKill
// Desc: Display a humiliating kill message.
//-----------------------------------------------------------------------------
void Net_ShowKill(MSG_KILL *km, APP_PLAYER_INFO *pPlayerInfo)
{
	WCHAR s[80];
	APP_PLAYER_INFO *pKiller;
	DPNID Killed, Killer;

	Killer = km->dpnidKiller;
	g_pDP->GetPlayerContext(Killer, (VOID **)&pKiller, 0);
	Killed = pPlayerInfo->dpnidPlayer;

	if(Killed==g_dpnidLocalPlayer)
	{
		// local player was killed, check if he killed himself
		if(Killed==Killer)
			swprintf(s, L"You killed yourself");
		else
			swprintf(s, L"You were killed by %s", pKiller->wstrPlayerName);
	}
	else if(Killer==g_dpnidLocalPlayer)
		swprintf(s, L"You killed %s", pPlayerInfo->wstrPlayerName);
	else
	{
		if(Killed==Killer)
			swprintf(s, L"%s killed himself", pPlayerInfo->wstrPlayerName);
		else
			swprintf(s, L"%s killed %s", pKiller->wstrPlayerName, pPlayerInfo->wstrPlayerName);
	}

	XTextBox_AddItem(XBox, s);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\winsockpeer\WinsockPeer.cpp ===
//-----------------------------------------------------------------------------
// File: WinsockPeer.cpp
//
// Desc: Illustrates Winsock peer-to-peer networking on Xbox.
//       Based on the DX8 SimplePeer sample.
//       Allows player to start/host a new multiplayer game, connect
//       to an existing multiplayer game, and send simple messages
//       to other players. Uses the secure Xbox network stack. Properly
//       handles player disconnects. Meets System Link certification 
//       requirements. Does not include host migration.
//
// Hist: 05.14.01 - New for June XDK release 
//       10.10.01 - Updated for Nov XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#pragma warning( disable: 4786 )
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBStopWatch.h>
#include <XBSocket.h>
#include <XBSockAddr.h>
#include <XBNet.h>
#include <XBRandName.h>
#include <cassert>
#include <vector>
#include <algorithm>
#include "Resource.h"





//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD COLOR_HIGHLIGHT   = 0xffffff00; // Yellow
const DWORD COLOR_GREEN       = 0xff00ff00;
const DWORD COLOR_NORMAL      = 0xffffffff;
const DWORD MAX_ERROR_STR     = 64;
const DWORD MAX_STATUS_STR    = 128;
const DWORD MAX_GAME_NAMES    = 6;      // Number of game names to choose from
const DWORD NONCE_BYTES       = 8;      // Larger means less chance of random matches
const DWORD MAX_GAME_NAME     = 12;     // Includes null
const DWORD MAX_PLAYER_NAME   = 12;     // Includes null
const DWORD PLAYER_TIMEOUT    = 2000;   // 2 seconds
const FLOAT CHECK_LINK_STATUS = 0.5f;   // Check status twice/sec
const FLOAT PLAYER_HEARTBEAT  = 0.3f;   // ~3 times per second
const FLOAT GAME_JOIN_TIME    = 2.0f;   // 2 seconds
const WORD  BROADCAST_PORT    = 10983;  // could be any port
const WORD  DIRECT_PORT       = 10984;  // any port other than BROADCAST_PORT

// TCR 3-46 Maximum Number of Connected Xboxes
const DWORD MAX_PLAYERS = 4;            // Max players (may not exceed 16)

// TCR 3-59 Session Discovery Time
const FLOAT GAME_SEARCH_TIME = 2.0f;   // 2 seconds (may not exceed 3)

const WCHAR* const strLOST_CONNECTION = L"This Xbox has lost its "
                                        L"System Link connection";




//-----------------------------------------------------------------------------
// Name: class GameInfo
// Desc: Game information used by clients to store available games
//-----------------------------------------------------------------------------
struct GameInfo
{
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // name of the game
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // name of the host player
};




//-----------------------------------------------------------------------------
// Name: class PlayerInfo
// Desc: Player information used by players to store list of other players
//       in the game
//-----------------------------------------------------------------------------
struct PlayerInfo
{
    XNADDR  xnAddr;                           // XNet address
    IN_ADDR inAddr;                           // Xbox IP (not a "real" IP)
    WCHAR   strPlayerName[ MAX_PLAYER_NAME ]; // player name
    DWORD   dwLastHeartbeat;                  // last heartbeat, in our clocks
};




//-----------------------------------------------------------------------------
// Name: class MatchInAddr
// Desc: Predicate functor used to match on IN_ADDRs in player lists
//-----------------------------------------------------------------------------
struct MatchInAddr
{
    IN_ADDR ia;
    explicit MatchInAddr( const CXBSockAddr& sa ) : ia( sa.GetInAddr() ) { }
    bool operator()( const PlayerInfo& playerInfo )
    {
        return playerInfo.inAddr.s_addr == ia.s_addr;
    }
};




//-----------------------------------------------------------------------------
// Message IDs
//
// A "host" is the player who started the game.
// A "client" is a potential player. A client is not currently playing a game.
// A "player" is anyone playing a game.
//-----------------------------------------------------------------------------
enum
{                       // From     To      Type        Expected response
                        //-----------------------------------------------------
    MSG_FIND_GAME,      // client   host    broadcast   MSG_GAME_FOUND
    MSG_GAME_FOUND,     // host     client  broadcast   <none>
    MSG_JOIN_GAME,      // client   host    direct      MSG_JOIN_APPROVED/DENIED
    MSG_JOIN_APPROVED,  // host     client  direct      <none>
    MSG_JOIN_DENIED,    // host     client  direct      <none>
    MSG_PLAYER_JOINED,  // host     player  direct      <none>
    MSG_WAVE,           // player   player  direct      <none>
    MSG_HEARTBEAT       // player   player  direct      <none>
};




//-----------------------------------------------------------------------------
// Message payloads
//-----------------------------------------------------------------------------
// Pack to minimize network traffic
#pragma pack( push )
#pragma pack( 1 )

//-----------------------------------------------------------------------------
// Local Player struct used by some messages
//-----------------------------------------------------------------------------
struct Player
{
    XNADDR xnAddr;                           // player's XNet address
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ]; // player's name
};

//-----------------------------------------------------------------------------
// Local Nonce struct used by some messages
//-----------------------------------------------------------------------------
struct Nonce
{
    // Used for client verification. The larger the number of NONCE_BYTES,
    // the less likely there is to be an accidental match between client & host
    BYTE byRandom[ NONCE_BYTES ]; 
};

//-----------------------------------------------------------------------------
// Broadcast by a client looking for available games
//-----------------------------------------------------------------------------
struct MsgFindGame
{
    Nonce nonce;    // Generated by client; used to verify host response
};

//-----------------------------------------------------------------------------
// Broadcast by a host in response to a MSG_FIND_GAME
//-----------------------------------------------------------------------------
struct MsgGameFound
{
    Nonce  nonce;                          // used for client verification
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // game name
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // game host player name
};

//-----------------------------------------------------------------------------
// Sent from a client to a host to join a game
//-----------------------------------------------------------------------------
struct MsgJoinGame
{
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ];  // player who wants to join
};

//-----------------------------------------------------------------------------
// Sent from a host to a client in response to a MSG_JOIN_GAME
//-----------------------------------------------------------------------------
struct MsgJoinApproved
{
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // host name
    BYTE   byNumPlayers;                   // Players in the game (not incl host)
    Player PlayerList[ MAX_PLAYERS ];      // List of players (not incl host)
};

//-----------------------------------------------------------------------------
// Sent from a host to other players to notify them that a new player has joined
//-----------------------------------------------------------------------------
struct MsgPlayerJoined
{
    Player player; // The latest player to join the game
};

#pragma pack( pop )




//-----------------------------------------------------------------------------
// Name: class Message
// Desc: Message object sent between players and hosts
//-----------------------------------------------------------------------------
class Message
{
    BYTE m_byMessageId;

    union
    {
        MsgFindGame     m_FindGame;
        MsgGameFound    m_GameFound;
        MsgJoinGame     m_JoinGame;
        MsgJoinApproved m_JoinApproved;
        MsgPlayerJoined m_PlayerJoined;
    };

public:

    explicit Message( BYTE byMessageId = 0 ) : m_byMessageId( byMessageId ) {}
    ~Message() {}

    BYTE GetId() const      { return m_byMessageId; }
    INT  GetMaxSize() const { return sizeof(*this); }

    MsgFindGame&     GetFindGame()     { return m_FindGame;     }
    MsgGameFound&    GetGameFound()    { return m_GameFound;    }
    MsgJoinGame&     GetJoinGame()     { return m_JoinGame;     }
    MsgJoinApproved& GetJoinApproved() { return m_JoinApproved; }
    MsgPlayerJoined& GetPlayerJoined() { return m_PlayerJoined; }

    INT GetSize() const
    { 
        switch( m_byMessageId )
        {
            case MSG_FIND_GAME:     return sizeof(BYTE) + sizeof(MsgFindGame);
            case MSG_GAME_FOUND:    return sizeof(BYTE) + sizeof(MsgGameFound);
            case MSG_JOIN_GAME:     return sizeof(BYTE) + sizeof(MsgJoinGame);
            case MSG_JOIN_APPROVED: return sizeof(BYTE) + sizeof(MsgJoinApproved);
            case MSG_JOIN_DENIED:   return sizeof(BYTE);
            case MSG_PLAYER_JOINED: return sizeof(BYTE) + sizeof(MsgPlayerJoined);
            case MSG_WAVE:          return sizeof(BYTE);
            case MSG_HEARTBEAT:     return sizeof(BYTE);
            default: assert( FALSE ); return 0;
        }
    }

private:

    // Disabled
    Message( const Message& );
    Message& operator=( const Message& );

};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_MENU,             // Main menu
        STATE_GAME,             // Game menu
        STATE_HELP,             // Help screen
        STATE_SELECT_NAME,      // Select game name screen
        STATE_START_NEW_GAME,   // Starting new game
        STATE_GAME_SEARCH,      // Searching for game
        STATE_SELECT_GAME,      // Game selection menu
        STATE_REQUEST_JOIN,     // Joining game
        STATE_ERROR             // Error screen
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_LEFT,
        EV_RIGHT,
        EV_DISCONNECT,
        EV_NULL
    };

    enum
    {
        // Main menu
        MAIN_MENU_START_GAME = 0,
        MAIN_MENU_JOIN_GAME  = 1,
        MAIN_MENU_MAX,

        // Game menu
        GAME_MENU_WAVE       = 0,
        GAME_MENU_LEAVE_GAME = 1,
        GAME_MENU_MAX
    };

    enum InitStatus
    {
        Success,
        NotConnected,
        InitFailed
    };

    typedef std::vector< std::wstring > NameList;
    typedef std::vector< GameInfo >     GameList;
    typedef std::vector< PlayerInfo >   PlayerList;

	CXBPackedResource   m_xprResource;   // app resources
    LPDIRECT3DTEXTURE8  m_ptMenuSel;     // menu selection image
    mutable HANDLE      m_hLogFile;      // Log file
    CXBFont      m_Font;                 // game font
    CXBHelp      m_Help;                 // help screen
    State        m_State;                // game state
    State        m_LastState;            // last state
    DWORD        m_CurrItem;             // current menu item
    NameList     m_GameNames;            // list of potential game names
    GameList     m_Games;                // list of available games
    PlayerList   m_Players;              // list of current players (not incl self)
    WCHAR        m_strError[ MAX_ERROR_STR ];   // error message
    WCHAR        m_strStatus[ MAX_STATUS_STR ]; // status
    CXBStopWatch m_LinkStatusTimer;      // wait to check link status
    CXBStopWatch m_GameSearchTimer;      // wait for game search to complete
    CXBStopWatch m_GameJoinTimer;        // wait for game join to complete
    CXBStopWatch m_HeartbeatTimer;       // keep-alive timer
    BOOL         m_bIsOnline;            // TRUE if link status good
    BOOL         m_bXnetStarted;         // TRUE if networking initialized
    BOOL         m_bIsHost;              // TRUE if we're hosting the game
    BOOL         m_bIsSessionRegistered; // TRUE if session key registered
    BOOL         m_bHaveLocalAddress;    // TRUE if local address acquired
    XNKID        m_xnHostKeyID;          // Host key ID
    XNKEY        m_xnHostKeyExchange;    // Host key exchange key
    XNADDR       m_xnTitleAddress;       // The XNet address of this machine/game
    IN_ADDR      m_inHostAddr;           // The "IP" address of the the host
    CXBSocket    m_BroadSock;            // Broadcast socket for broadcast msgs
    CXBSocket    m_DirectSock;           // Direct socket for direct msgs
    WCHAR        m_strGameName[ MAX_GAME_NAME ];     // Game name
    WCHAR        m_strPlayerName[ MAX_PLAYER_NAME ]; // This player name
    WCHAR        m_strHostName[ MAX_PLAYER_NAME ];   // Host player name
    Nonce        m_Nonce;                            // Client identifier
    CXBRandName  m_rand;                             // Random name generator

public:

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

private:

    Event GetEvent();

    VOID FrameMoveMenu( Event );
    VOID FrameMoveGame( Event );
    VOID FrameMoveHelp( Event );
    VOID FrameMoveSelectName( Event );
    VOID FrameMoveStartGame( Event );
    VOID FrameMoveGameSearch( Event );
    VOID FrameMoveSelectGame( Event );
    VOID FrameMoveRequestJoin( Event );
    VOID FrameMoveError( Event );

    VOID RenderMenu();
    VOID RenderGame();
    VOID RenderHelp();
    VOID RenderSelectName();
    VOID RenderStartGame();
    VOID RenderGameSearch();
    VOID RenderSelectGame();
    VOID RenderRequestJoin();
    VOID RenderError();
    VOID RenderHeader();
    VOID RenderMenuSelector( FLOAT, FLOAT );

    VOID InitiateJoin( DWORD );
    VOID Wave();
    VOID Heartbeat();

    VOID Init();

    // Initialization
    InitStatus InitXNet();

    // Send messages
    VOID SendFindGame();
    VOID SendGameFound( const Nonce& );
    VOID SendJoinGame( const CXBSockAddr& );
    VOID SendJoinApproved( const CXBSockAddr& );
    VOID SendJoinDenied( const CXBSockAddr& );
    VOID SendPlayerJoined( const Player&, const CXBSockAddr& );
    VOID SendWave( const CXBSockAddr& );
    VOID SendHeartbeat( const CXBSockAddr& );

    // Receive messages
    BOOL ProcessBroadcastMessage();
    BOOL ProcessDirectMessage();
    VOID ProcessMessage( Message& );
    VOID ProcessMessage( Message&, const CXBSockAddr& );

    // Process incoming messages
    VOID ProcessFindGame( const MsgFindGame& );
    VOID ProcessGameFound( const MsgGameFound& );
    VOID ProcessJoinGame( const MsgJoinGame&, const CXBSockAddr& );
    VOID ProcessJoinApproved( const MsgJoinApproved&, const CXBSockAddr& );
    VOID ProcessJoinDenied( const CXBSockAddr& );
    VOID ProcessPlayerJoined( const MsgPlayerJoined&, const CXBSockAddr& );
    VOID ProcessWave( const CXBSockAddr& );
    VOID ProcessHeartbeat( const CXBSockAddr& );

    // Handle keep-alive
    BOOL ProcessPlayerDropouts();

    // Utility
    VOID DestroyGameList();
    VOID DestroyPlayerList();

    VOID LogXNetError( const CHAR*, INT ) const;

};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
: 
    CXBApplication(),
    m_xprResource (),
    m_ptMenuSel   ( NULL ),
    m_hLogFile    ( INVALID_HANDLE_VALUE ),
    m_Font        (),
    m_Help        (),
    m_State       ( STATE_MENU ),
    m_LastState   ( STATE_MENU ),
    m_CurrItem    ( 0 ),
    m_GameNames   (),
    m_Games       (),
    m_Players     (),
    m_strError    (),
    m_strStatus   (),
    m_LinkStatusTimer     ( FALSE ),
    m_GameSearchTimer     ( FALSE ),
    m_GameJoinTimer       ( FALSE ),
    m_HeartbeatTimer      ( FALSE ),
    m_bIsOnline           ( FALSE ),
    m_bXnetStarted        ( FALSE ),
    m_bIsHost             ( FALSE ),
    m_bIsSessionRegistered( FALSE ),
    m_bHaveLocalAddress   ( FALSE ),
    m_xnHostKeyID         (),
    m_xnHostKeyExchange   (),
    m_xnTitleAddress      (),
    m_inHostAddr          (),
    m_BroadSock           (),
    m_DirectSock          (),
    m_strGameName         (),
    m_strPlayerName       (),
    m_strHostName         (),
    m_Nonce               (),
    m_rand                ( GetTickCount() )
{
    Init();
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our textures
    if( FAILED( m_xprResource.Create( g_pd3dDevice, "Resource.xpr", 
                                      Resource_NUM_RESOURCES ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load textures\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Set up texture ptrs
    m_ptMenuSel = m_xprResource.GetTexture( Resource_MenuSelect_OFFSET );

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Set view position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 40.0f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // TCR 2-16 Lost Link
    // Check network status periodically
    if( !m_LinkStatusTimer.IsRunning() ||
        m_LinkStatusTimer.GetElapsedSeconds() > CHECK_LINK_STATUS )
    {
        m_LinkStatusTimer.StartZero();
        DWORD dwStatus = XNetGetEthernetLinkStatus();
        m_bIsOnline = ( dwStatus & XNET_ETHERNET_LINK_ACTIVE ) != 0;
    }

    Event ev = GetEvent();

    // Handle lost link errors
    switch( m_State )
    {
        case STATE_MENU: break;  // main menu handles lost link differently
        case STATE_HELP: break;  // help screen doesn't need to handle
        case STATE_ERROR: break; // error screen doesn't need to handle

        default:
            if( !m_bIsOnline )
            {
                // TCR 2-16 Lost Link
                m_State = STATE_ERROR;
                lstrcpynW( m_strError, strLOST_CONNECTION, MAX_ERROR_STR );
            }
            break;
    }

    switch( m_State )
    {
        case STATE_MENU:            FrameMoveMenu( ev );        break;
        case STATE_GAME:            FrameMoveGame( ev );        break;
        case STATE_HELP:            FrameMoveHelp( ev );        break;
        case STATE_SELECT_NAME:     FrameMoveSelectName( ev );  break;
        case STATE_START_NEW_GAME:  FrameMoveStartGame( ev );   break;
        case STATE_GAME_SEARCH:     FrameMoveGameSearch( ev );  break;
        case STATE_SELECT_GAME:     FrameMoveSelectGame( ev );  break;
        case STATE_REQUEST_JOIN:    FrameMoveRequestJoin( ev ); break;
        case STATE_ERROR:           FrameMoveError( ev );       break;
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000A0A6A, 1.0f, 0L );

    switch( m_State )
    {
        case STATE_MENU:            RenderMenu();        break;
        case STATE_GAME:            RenderGame();        break;
        case STATE_HELP:            RenderHelp();        break;
        case STATE_SELECT_NAME:     RenderSelectName();  break;
        case STATE_START_NEW_GAME:  RenderStartGame();   break;
        case STATE_GAME_SEARCH:     RenderGameSearch();  break;
        case STATE_SELECT_GAME:     RenderSelectGame();  break;
        case STATE_REQUEST_JOIN:    RenderRequestJoin(); break;
        case STATE_ERROR:           RenderError();       break;
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent()
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }

    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;

    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;

    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
        return EV_LEFT;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        return EV_RIGHT;

    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveMenu()
// Desc: Animate menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveMenu( Event ev )
{
    switch( ev )
    {
        case EV_BUTTON_A:

            // Prepare networking
            switch( InitXNet() )
            {
                case Success:
                    break;
                case NotConnected:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"This Xbox is not connected to\n"
                                           L"a hub or another Xbox",
                                           MAX_ERROR_STR );
                    return;
                case InitFailed:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"Failure initializing network\n"
                                           L"connections", 
                                           MAX_ERROR_STR );
                    return;
                default: assert( FALSE ); break;
            }

            switch( m_CurrItem )
            {
                case MAIN_MENU_START_GAME:
                {    
                    assert( !m_bIsSessionRegistered );

                    // Create the session key ID and exchange key
                    INT iKeyCreated = XNetCreateKey( &m_xnHostKeyID, 
                                                     &m_xnHostKeyExchange );

                    // Register the session
                    INT iKeyRegistered = XNetRegisterKey( &m_xnHostKeyID, 
                                                          &m_xnHostKeyExchange );
                    if( iKeyCreated != NO_ERROR || iKeyRegistered != NO_ERROR )
                    {
                        m_State = STATE_ERROR;
                        lstrcpynW( m_strError, L"Unable to start game session",
                                   MAX_ERROR_STR );

                        if( iKeyCreated != NO_ERROR )
                            LogXNetError( "XNetCreateKey", iKeyCreated );
                        if( iKeyRegistered != NO_ERROR )
                            LogXNetError( "XNetRegisterKey", iKeyRegistered );

                        break;
                    }

                    m_bIsSessionRegistered = TRUE;

                    // We're the host
                    m_bIsHost = TRUE;

                    // TCR 3-58 Naming of Game Sessions
                    // Build a list of potential game names
                    assert( m_GameNames.empty() );
                    for( DWORD i = 0; i < MAX_GAME_NAMES; ++i )
                    {
                        WCHAR strGameName[ MAX_GAME_NAME ];
                        m_rand.GetName( strGameName, MAX_GAME_NAME );
                        m_GameNames.push_back( strGameName );
                    }

                    // Start at the top of the list
                    m_CurrItem = 0;

                    m_State = STATE_SELECT_NAME;
                    break;
                }
                case MAIN_MENU_JOIN_GAME:

                    // Begin searching for games on the network
                    SendFindGame();
                    m_GameSearchTimer.StartZero();
                    m_State = STATE_GAME_SEARCH;

                    break;
            }
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = MAIN_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == MAIN_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGame()
// Desc: Animate game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGame( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Send keep-alives
    if( m_HeartbeatTimer.GetElapsedSeconds() > PLAYER_HEARTBEAT )
    {
        Heartbeat();
        m_HeartbeatTimer.StartZero();
    }

    // Handle other players dropping
    if( ProcessPlayerDropouts() )
        return;

    switch( ev )
    {
        case EV_BUTTON_A:
            switch( m_CurrItem )
            {
                case GAME_MENU_WAVE:
                    Wave();
                    break;
                case GAME_MENU_LEAVE_GAME:
                    Init();
                    break;
            }
            break;
        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = GAME_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == GAME_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveHelp()
// Desc: Animate help
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveHelp( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    if( ev != EV_NULL )
        m_State = m_LastState;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectName()
// Desc: Animate game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectName( Event ev )
{
    // TCR 3-58 Naming of Game Sessions

    // Allow the player to cancel out of game name selection
    if( ev == EV_BUTTON_B )
    {
        Init();
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:

            // Use the selected namne
            lstrcpyW( m_strGameName, m_GameNames[ m_CurrItem ].c_str() );

            // Destroy the name list; we don't need it anymore
            m_GameNames.clear();

            // Set the default game item to "wave"
            m_CurrItem = 0;

            // Display when game begins
            lstrcpynW( m_strStatus, L"Game started", MAX_STATUS_STR );

            // If we have the local address, begin the game.
            // Otherwise, acquire the local address.
            if( m_bHaveLocalAddress )
            {
                m_State = STATE_GAME;
                m_HeartbeatTimer.StartZero();
            }
            else
                m_State = STATE_START_NEW_GAME;
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_GameNames.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_GameNames.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveStartGame()
// Desc: Animate start game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveStartGame( Event ev )
{
    // Allow the player to cancel out of game startup
    if( ev == EV_BUTTON_B )
    {
        Init();
        return;
    }

    // Asynchronous local address acquisition
    DWORD dwStatus = XNetGetTitleXnAddr( &m_xnTitleAddress );
    assert( dwStatus != XNET_GET_XNADDR_NONE );

    // If we've retrieved the local address, we're done
    m_bHaveLocalAddress = ( dwStatus != XNET_GET_XNADDR_PENDING );

    // When startup is complete, enter the game
    if( m_bHaveLocalAddress )
    {   
        m_HeartbeatTimer.StartZero();
        m_State = STATE_GAME;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGameSearch()
// Desc: Animate game search
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGameSearch( Event ev )
{
    // Allow the player to cancel out of game search
    if( ev == EV_BUTTON_B )
    {
        Init();
        return;
    }

    // See if any games have replied
    if( ProcessBroadcastMessage() )
        return;

    // We search for up to GAME_SEARCH_TIME seconds. If the game 
    // search is complete, display the list of available games. If no games
    // were found, display an error message
    if( m_GameSearchTimer.GetElapsedSeconds() > GAME_SEARCH_TIME )
    {
        m_GameSearchTimer.Stop();
        if( m_Games.empty() )
        {
            m_State = STATE_ERROR;
            lstrcpynW( m_strError, L"No games available", MAX_ERROR_STR );
        }
        else if( m_Games.size() == 1 )
        {
            // TCR 3-57 Default Choices for System Link Play
            // One game; join automatically
            InitiateJoin( 0 );
        }
        else // at least two games
        {
            // at least two games; allow player selection
            m_State = STATE_SELECT_GAME;
            m_CurrItem = 0;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectGame()
// Desc: Animate game selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectGame( Event ev )
{
    switch( ev )
    {
        case EV_BUTTON_A:
            InitiateJoin( m_CurrItem );
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_Games.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_Games.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveRequestJoin()
// Desc: Animate join request
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveRequestJoin( Event ev )
{
    // Allow the player to cancel out of join request
    if( ev == EV_BUTTON_B )
    {
        Init();
        return;
    }

    // See if the game has replied
    ProcessDirectMessage();

    // We wait for up to GAME_JOIN_TIME seconds. If the game didn't
    // respond, display an error message
    if( m_GameJoinTimer.GetElapsedSeconds() > GAME_JOIN_TIME )
    {
        m_GameJoinTimer.Stop();
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Game did not respond", MAX_ERROR_STR );
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveError()
// Desc: Animate error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveError( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Any button exits
    if( ev != EV_NULL )
        Init();
}





//-----------------------------------------------------------------------------
// Name: RenderMenu()
// Desc: Display menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenu()
{
    RenderHeader();

    const WCHAR* const strMenu[] =
    {
        L"Start New Game",
        L"Join Existing Game",
    };

    FLOAT fYtop = 200.0f;
    FLOAT fYdelta = 50.0f;

    // TCR 3-44 System Link Play Menu Option
    for( DWORD i = 0; i < MAIN_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i && m_bIsOnline ) ? COLOR_HIGHLIGHT : 
                                                             COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    if( m_bIsOnline )
        RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );

    m_Font.DrawText( 320, 400, COLOR_NORMAL, m_bIsOnline ? 
                     L"System Link Connected" :
                     L"System Link NOT Connected", XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderGame()
// Desc: Display game
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGame()
{
    RenderHeader();

    // Game name and player name
    WCHAR strGameInfo[ 32 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
    wsprintfW( strGameInfo, L"Game name: %.*s\nYour name: %.*s", 
               MAX_GAME_NAME, m_strGameName, MAX_PLAYER_NAME, m_strPlayerName );
    m_Font.DrawText( 220, 120, COLOR_GREEN, strGameInfo );

    // Number of players and current status
    wsprintfW( strGameInfo, L"Players in game: %lu", m_Players.size() + 1 );
    m_Font.DrawText( 220, 168, COLOR_GREEN, strGameInfo );
    m_Font.DrawText( 320, 214, COLOR_GREEN, m_strStatus, XBFONT_CENTER_X );

    // Game options menu
    const WCHAR* const strMenu[] =
    {
        L"Wave To Other Players",
        L"Leave Game",
    };

    FLOAT fYtop = 270.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( DWORD i = 0; i < GAME_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderHelp()
// Desc: Display help
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHelp()
{
    XBHELP_CALLOUT HelpCallouts[] =
    {
        { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
        { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Select menu\nitem" },
        { XBHELP_B_BUTTON, XBHELP_PLACEMENT_1, L"Cancel" },
        { XBHELP_DPAD, XBHELP_PLACEMENT_1, L"Menu navigation" },
    };
    m_Help.Render( &m_Font, HelpCallouts, 4 );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectName()
// Desc: Display game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectName()
{
    assert( !m_GameNames.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select a game name\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;

    // Show list of game names
    for( DWORD i = 0; i < m_GameNames.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 280, fYtop + (fYdelta * i), dwColor, 
                         m_GameNames[i].c_str() );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 240.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderStartGame()
// Desc: Display game startup sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderStartGame()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Starting Game\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderGameSearch()
// Desc: Display game search sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGameSearch()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Searching For Active Games\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectGame()
// Desc: Display list of available games
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectGame()
{
    assert( !m_Games.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select game to join\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 50.0f;

    // Show list of games
    for( DWORD i = 0; i < m_Games.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        WCHAR strGameInfo[ 64 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
        wsprintfW( strGameInfo, L"\"%.*s\" hosted by \"%.*s\"; players: %d",
                   MAX_GAME_NAME, m_Games[i].strGameName,
                   MAX_PLAYER_NAME, m_Games[i].strHostName,
                   INT(m_Games[i].byNumPlayers) );

        // Denote full games
        if( m_Games[i].byNumPlayers == MAX_PLAYERS )
            lstrcatW( strGameInfo, L" (full)" );

        m_Font.DrawText( 140, fYtop + (fYdelta * i), dwColor, strGameInfo );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 100.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderRequestJoin()
// Desc: Display join request sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderRequestJoin()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Joining game", 
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderError()
{
    RenderHeader();
    m_Font.DrawText( 320, 200, 0xffffffff, m_strError, XBFONT_CENTER_X );
    m_Font.DrawText( 320, 260, 0xffffffff, L"Press A to continue", 
                     XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderHeader()
// Desc: Display standard text
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHeader()
{
    WCHAR strName[32];
    lstrcpyW( strName, L"WinsockPeer" );
    if( m_bIsHost )
        lstrcatW( strName, L" (host)" );

    m_Font.DrawText(  64, 50, 0xffffffff, strName );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
}




//-----------------------------------------------------------------------------
// Name: RenderMenuSelector()
// Desc: Display menu selector
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenuSelector( FLOAT fLeft, FLOAT fTop )
{
    D3DXVECTOR4 rc( fLeft, fTop, fLeft + 20.0f, fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: InitiateJoin()
// Desc: Send a join request to the specified game
//-----------------------------------------------------------------------------
VOID CXBoxSample::InitiateJoin( DWORD iCurrGame )
{
    // Determine which game the player wants to join
    GameInfo gameInfo = m_Games[ iCurrGame ];

    // Establish a session with the host game
    INT iResult = XNetRegisterKey( &gameInfo.xnHostKeyID, 
                                   &gameInfo.xnHostKey );
    assert( iResult == NO_ERROR );
    if( iResult == NO_ERROR )
    {
        assert( m_bIsSessionRegistered == FALSE );
        m_bIsSessionRegistered = TRUE;

        // Save the key ID because we need to unregister it
        // Note that we don't need the key itself once it's been registered.
        CopyMemory( &m_xnHostKeyID, &gameInfo.xnHostKeyID, sizeof( XNKID ) );

        // Save the game and player name of the host
        lstrcpynW( m_strGameName, gameInfo.strGameName, MAX_GAME_NAME );
        lstrcpynW( m_strHostName, gameInfo.strHostName, MAX_PLAYER_NAME );

        // Convert the XNADDR of the host to the INADDR we'll use to
        // join the game
        iResult = XNetXnAddrToInAddr( &gameInfo.xnHostAddr,
                                      &m_xnHostKeyID, &m_inHostAddr );
        assert( iResult == NO_ERROR );

        // Request join approval from the game and await a response
        SendJoinGame( CXBSockAddr( m_inHostAddr, DIRECT_PORT ) );
        m_GameJoinTimer.StartZero();
        m_State = STATE_REQUEST_JOIN;
    }
    else
    {
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Unable to establish session with game",
                   MAX_ERROR_STR );
        LogXNetError( "XNetRegisterKey", iResult );
    }

    // Don't need the game list anymore
    DestroyGameList();
}




//-----------------------------------------------------------------------------
// Name: Wave()
// Desc: Wave to other players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Wave()
{
    // Indicate that you waved
    lstrcpynW( m_strStatus, L"You waved", MAX_STATUS_STR );

    // Send a "wave" message to each of the other players in the game
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendWave( CXBSockAddr( i->inAddr, DIRECT_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: Heartbeat()
// Desc: Send heartbeat to players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Heartbeat()
{
    // Send a "heartbeat" message to each of the other players in the game
    // to let them know we're alive
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendHeartbeat( CXBSockAddr( i->inAddr, DIRECT_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Teardown any active games and player lists and return to main menu
//       Unregisters any active sessions.
//-----------------------------------------------------------------------------
VOID CXBoxSample::Init()
{
    // Don't clear m_bXnetStarted. We don't need to reinitialize Xnet once
    // it's been started.

    // Don't clear m_bHaveLocalAddress or m_xnTitleAddress. We don't need to 
    // reacquire the address once we have it.

    m_State     = STATE_MENU;
    m_LastState = STATE_MENU;
    m_CurrItem  = 0;

    m_GameNames.clear();
    DestroyGameList();
    DestroyPlayerList();

    *m_strError = 0;
    *m_strStatus = 0;

    m_LinkStatusTimer.Stop();
    m_GameSearchTimer.Stop();
    m_GameJoinTimer.Stop();
    m_HeartbeatTimer.Stop();

    m_bIsHost = FALSE;

    // Unregister the game session key
    if( m_bIsSessionRegistered )
    {
        INT iResult = XNetUnregisterKey( &m_xnHostKeyID );
        assert( iResult == NO_ERROR );
        (VOID)iResult;
        m_bIsSessionRegistered = FALSE;
    }

    // Obliterate old keys and XNADDR
    ZeroMemory( &m_xnHostKeyID,       sizeof( XNKID ) );
    ZeroMemory( &m_xnHostKeyExchange, sizeof( XNKEY ) );
    m_inHostAddr.s_addr = 0;

    // Close down the sockets
    m_BroadSock.Close();
    m_DirectSock.Close();

    *m_strGameName   = 0;
    *m_strPlayerName = 0;
    *m_strHostName   = 0;

    ZeroMemory( &m_Nonce, sizeof(m_Nonce) );

    // Generate random player name
    // A real Xbox game would get this information from the player
    m_rand.GetName( m_strPlayerName, MAX_PLAYER_NAME );
}




//-----------------------------------------------------------------------------
// Name: InitXNet()
// Desc: Initialize the network stack. Returns FALSE if Xbox is not connected.
//-----------------------------------------------------------------------------
CXBoxSample::InitStatus CXBoxSample::InitXNet()
{
    if( !m_bIsOnline )
        return NotConnected;

    // Only need to initialize network stack one time
    if( !m_bXnetStarted )
    {
        // XBNet_Init in XbNet.cpp handles standard Xbox socket startup
        HRESULT hr = XBNet_Init( 0 );
        if( FAILED(hr) )
        {
            LogXNetError( "XNetStartup/WSAStartup", hr );
            return InitFailed;
        }
        m_bXnetStarted = TRUE;
    }

    // The broadcast socket is a non-blocking socket on port BROADCAST_PORT.
    // All broadcast messages are automatically always encrypted.
    BOOL bSuccess = m_BroadSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Broadcast socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr broadAddr( INADDR_ANY, BROADCAST_PORT );
    INT iResult = m_BroadSock.Bind( broadAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    DWORD dwNonBlocking = 1;
    iResult = m_BroadSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );
    BOOL bBroadcast = TRUE;
    iResult = m_BroadSock.SetSockOpt( SOL_SOCKET, SO_BROADCAST,
                                      &bBroadcast, sizeof(bBroadcast) );
    assert( iResult != SOCKET_ERROR );

    // The direct socket is a non-blocking socket on port DIRECT_PORT.
    // Sockets are encrypted by default, but can have encryption disabled
    // as an optimization for non-secure messaging
    bSuccess = m_DirectSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Direct socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr directAddr( INADDR_ANY, DIRECT_PORT );
    iResult = m_DirectSock.Bind( directAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    iResult = m_DirectSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );

    // Note that this sample does not call either WSACleanup() or 
    // XNetCleanup(). These functions should be called by your game to
    // free system resources when the player is no longer online but
    // is still playing the game (e.g. switched to single-player mode).

    return Success;
}




//-----------------------------------------------------------------------------
// Name: SendFindGame()
// Desc: Broadcast a MSG_FIND_GAME from our client to any available host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendFindGame()
{
    assert( !m_bIsHost );
    Message msgFindGame( MSG_FIND_GAME );
    MsgFindGame& msg = msgFindGame.GetFindGame();

    // Generate a nonce (random bytes). When a potential host responds with
    // information about a game, he must respond via a broadcast message
    // since a secure session hasn't been established. The broadcast message
    // will contain the same nonce so we can verify that message is really
    // for us. If we receive a broadcast "found game" message with a different
    // nonce, we ignore it, because it was broadcast to a different client
    // than us.
    INT iResult = XNetRandom( (BYTE*)(&msg.nonce), sizeof(msg.nonce) );
    assert( iResult == NO_ERROR );
    (VOID)iResult;

    // Save the nonce for comparison later
    CopyMemory( &m_Nonce, &msg.nonce, sizeof(msg.nonce) );

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgFindGame, msgFindGame.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgFindGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendGameFound()
// Desc: Broadcast a MSG_GAME_FOUND from our host to the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendGameFound( const Nonce& nonceClient )
{
    assert( m_bIsHost );
    Message msgGameFound( MSG_GAME_FOUND );
    MsgGameFound& msg = msgGameFound.GetGameFound();

    // Resend the nonce that we received from the client so he can verify
    // that this message is really for him
    CopyMemory( &msg.nonce, &nonceClient, sizeof(nonceClient) );

    // Send information about the session that we're hosting
    CopyMemory( &msg.xnHostKeyID, &m_xnHostKeyID,       sizeof(XNKID) );
    CopyMemory( &msg.xnHostKey,   &m_xnHostKeyExchange, sizeof(XNKEY) );
    CopyMemory( &msg.xnHostAddr,  &m_xnTitleAddress,    sizeof(XNADDR) );

    // Send the current information about the game
    msg.byNumPlayers = BYTE( m_Players.size() + 1 );
    lstrcpynW( msg.strGameName, m_strGameName, MAX_GAME_NAME );
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // We don't have the XNADDR of the requesting client, so we
    // can't send this message directly back. Instead, we broadcast the
    // message to everybody on the net. The requesting client can
    // check the nonce to verify that the response is really for them.
    // Broadcast messages are automatically encrypted.

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgGameFound, msgGameFound.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgGameFound.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinGame()
// Desc: Issue a MSG_JOIN_GAME from our client to the game host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinGame( const CXBSockAddr& saGameHost )
{
    assert( !m_bIsHost );
    Message msgJoinGame( MSG_JOIN_GAME );
    MsgJoinGame& msg = msgJoinGame.GetJoinGame();

    // Include our player name
    lstrcpynW( msg.strPlayerName, m_strPlayerName, MAX_PLAYER_NAME );

    // We can send this message directly to the host
    INT nBytes = m_DirectSock.SendTo( &msgJoinGame, msgJoinGame.GetSize(),
                                      saGameHost.GetPtr() );
    assert( nBytes == msgJoinGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinApproved()
// Desc: Issue a MSG_JOIN_APPROVED from our host to the requesting client.
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinApproved( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinApproved( MSG_JOIN_APPROVED );
    MsgJoinApproved& msg = msgJoinApproved.GetJoinApproved();

    // The host is us
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // Send the list of all the current players to the new player.
    // We don't send the host player info, since the new player 
    // already has all of the information it needs about the host player.
    msg.byNumPlayers = BYTE( m_Players.size() );
    BYTE j = 0;
    for( PlayerList::const_iterator i = m_Players.begin(); 
         i != m_Players.end(); ++i, ++j )
    {
        PlayerInfo playerInfo = *i;
        CopyMemory( &msg.PlayerList[j].xnAddr, &playerInfo.xnAddr, 
                    sizeof( XNADDR ) );
        lstrcpynW( msg.PlayerList[j].strPlayerName, 
                   playerInfo.strPlayerName, MAX_PLAYER_NAME );
    }

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinApproved, msgJoinApproved.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinApproved.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinDenied()
// Desc: Issue a MSG_JOIN_DENIED from our host to the requesting client
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinDenied( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinDenied( MSG_JOIN_DENIED );

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinDenied, msgJoinDenied.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinDenied.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendPlayerJoined()
// Desc: Issue a MSG_PLAYER_JOINED from our host to a player in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendPlayerJoined( const Player& player, const CXBSockAddr& saPlayer )
{
    assert( m_bIsHost );
    Message msgPlayerJoined( MSG_PLAYER_JOINED );
    MsgPlayerJoined& msg = msgPlayerJoined.GetPlayerJoined();

    // The payload is the information about the player who just joined
    CopyMemory( &msg.player, &player, sizeof(player) );

    // We send this message directly to the player
    INT nBytes = m_DirectSock.SendTo( &msgPlayerJoined, msgPlayerJoined.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgPlayerJoined.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Issue a MSG_WAVE from ourself (either a host or player) to another
//       player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendWave( const CXBSockAddr& saPlayer )
{
    Message msgWave( MSG_WAVE );
    INT nBytes = m_DirectSock.SendTo( &msgWave, msgWave.GetSize(), 
                                      saPlayer.GetPtr() );
    assert( nBytes == msgWave.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendHeartbeat()
// Desc: Issue a MSG_HEARTBEAT from ourself (either a host or player) to
//       another player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendHeartbeat( const CXBSockAddr& saPlayer )
{
    // Send the heartbeat
    Message msgHeartbeat( MSG_HEARTBEAT );
    INT nBytes = m_DirectSock.SendTo( &msgHeartbeat, msgHeartbeat.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgHeartbeat.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: ProcessBroadcastMessage()
// Desc: Checks to see if any broadcast messages are waiting on the broadcast
//       socket. If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessBroadcastMessage()
{
    if( !m_BroadSock.IsOpen() )
        return FALSE;

    // See if a network broadcast message is waiting for us
    Message msg;
    INT iResult = m_BroadSock.Recv( &msg, msg.GetMaxSize() );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessDirectMessage()
// Desc: Checks to see if any direct messages are waiting on the direct socket.
//       If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessDirectMessage()
{
    if( !m_DirectSock.IsOpen() )
        return FALSE;

    // See if a network message is waiting for us
    Message msg;
    SOCKADDR_IN saFromIn;
    INT iResult = m_DirectSock.RecvFrom( &msg, msg.GetMaxSize(), &saFromIn );
    CXBSockAddr saFrom( saFromIn );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg, saFrom );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes broadcast messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_FIND_GAME:  ProcessFindGame( msg.GetFindGame() );   break;

        // From host to client: processed by client
        case MSG_GAME_FOUND: ProcessGameFound( msg.GetGameFound() ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes any direct messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg, const CXBSockAddr& saFrom )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_JOIN_GAME:     ProcessJoinGame( msg.GetJoinGame(), saFrom ); break;

        // From host to client: processed by client
        case MSG_JOIN_APPROVED: ProcessJoinApproved( msg.GetJoinApproved(), saFrom ); break;
        case MSG_JOIN_DENIED:   ProcessJoinDenied( saFrom ); break;
        case MSG_PLAYER_JOINED: ProcessPlayerJoined( msg.GetPlayerJoined(), saFrom ); break;

        // From player to player: processed by client player
        case MSG_WAVE:          ProcessWave( saFrom ); break;
        case MSG_HEARTBEAT:     ProcessHeartbeat( saFrom ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessFindGame()
// Desc: Process the find game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessFindGame( const MsgFindGame& findGame )
{
    // If we're not hosting a game, we don't care about receiving "find game"
    // messages. Only hosts respond to "find game" messages
    if( !m_bIsHost )
        return;

    // We're hosting a game
    // Respond with the game information
    SendGameFound( findGame.nonce );
}




//-----------------------------------------------------------------------------
// Name: ProcessGameFound()
// Desc: Process the game found message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessGameFound( const MsgGameFound& gameFound )
{
    // If we're hosting, we don't care about receiving "game found" messages.
    // Only potential clients care about "game found" messages.
    if( m_bIsHost )
        return;

    // If we didn't send the corresponding "find game" message, we don't
    // care about this particular "game found" message
    if( memcmp( &gameFound.nonce, &m_Nonce, NONCE_BYTES ) != 0 )
        return;

    // We found a game!
    // Add it to our list of potential games
    GameInfo gameInfo;
    CopyMemory( &gameInfo.xnHostKeyID, &gameFound.xnHostKeyID, sizeof( XNKID ) );
    CopyMemory( &gameInfo.xnHostKey,   &gameFound.xnHostKey,   sizeof( XNKEY ) );
    CopyMemory( &gameInfo.xnHostAddr,  &gameFound.xnHostAddr,  sizeof( XNADDR ) );
    gameInfo.byNumPlayers = gameFound.byNumPlayers;
    lstrcpynW( gameInfo.strGameName, gameFound.strGameName, MAX_GAME_NAME );
    lstrcpynW( gameInfo.strHostName, gameFound.strHostName, MAX_PLAYER_NAME );

    m_Games.push_back( gameInfo );
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinGame()
// Desc: Process the join game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinGame( const MsgJoinGame& joinGame,
                                   const CXBSockAddr& saFrom )
{
    // Only hosts should receive "join game" messages
    assert( m_bIsHost );

    // If for some reason we receive a "join game" message and we're not a
    // host, ignore it. Only hosts respond to "join game" messages
    if( !m_bIsHost )
        return;

    // We're hosting

    // A session exists between us (the host) and the client. We can now
    // convert the incoming IP address (saFrom) into a valid XNADDR.
    XNADDR xnAddrClient;
    INT iResult = XNetInAddrToXnAddr( saFrom.GetInAddr(), &xnAddrClient, NULL );
    if( iResult == SOCKET_ERROR )
    {
        // If the client INADDR can't be converted to an XNADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetInAddrToXnAddr", iResult );
        assert( FALSE );
        return;
    }

    // A player may join if we haven't reached the player limit.
    // In a real game, you would need to "lock" the game during a join
    // or track the number of joins in progress so that if multiple
    // players were attempting to join at the same time, they wouldn't
    // all be granted access and then exceed the player maximum.
    if( m_Players.size() + 1 < MAX_PLAYERS )
    {
        SendJoinApproved( saFrom );

        // Notify the other players about the new guy
        Player player;
        CopyMemory( &player.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        lstrcpynW( player.strPlayerName, joinGame.strPlayerName, MAX_PLAYER_NAME );
        for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
            SendPlayerJoined( player, CXBSockAddr( i->inAddr, DIRECT_PORT ) );

        // Add this new player to our player list
        PlayerInfo playerInfo;
        CopyMemory( &playerInfo.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        playerInfo.inAddr = saFrom.GetInAddr();
        lstrcpynW( playerInfo.strPlayerName, joinGame.strPlayerName, 
                   MAX_PLAYER_NAME );
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );

        // Update status
        wsprintfW( m_strStatus, L"%.*s has joined the game", 
                   MAX_PLAYER_NAME, player.strPlayerName );
    }
    else
    {
        SendJoinDenied( saFrom );
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinApproved()
// Desc: Process the join approved message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinApproved( const MsgJoinApproved& joinApproved, 
                                       const CXBSockAddr& saFrom )
{
    // Only clients should receive "join approved" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join approved" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Add the host to the list of players (always at position 0 )
    PlayerInfo hostInfo;

    // Client doesn't need the XNADDR of the host, so we just leave it zero.
    // This data member is only used by hosts.
    ZeroMemory( &hostInfo.xnAddr, sizeof( XNADDR ) );
    hostInfo.inAddr = saFrom.GetInAddr();
    lstrcpynW( hostInfo.strPlayerName, joinApproved.strHostName, MAX_PLAYER_NAME );
    hostInfo.dwLastHeartbeat = GetTickCount();

    assert( m_Players.empty() );
    m_Players.push_back( hostInfo );

    // Build the list of the other players
    for( BYTE i = 0; i < joinApproved.byNumPlayers; ++i )
    {
        PlayerInfo playerInfo;

        // Convert the XNADDR of the player to the INADDR we'll use to wave
        // to the player
        INT iResult = XNetXnAddrToInAddr( &joinApproved.PlayerList[ i ].xnAddr,
                                          &m_xnHostKeyID, &playerInfo.inAddr );
        if( iResult == SOCKET_ERROR )
        {
            // If the client XNADDR can't be converted to an INADDR, then
            // the client does not have a valid session established, and
            // we ignore that client.
            assert( FALSE );
            LogXNetError( "XNetXnAddrToInAddr", iResult );
            continue;
        }

        // Client doesn't need the XNADDR of the host anymore, 
        // so we just leave it zero. This data member is only used by hosts.
        ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

        // Save the player name
        lstrcpynW( playerInfo.strPlayerName, 
                   joinApproved.PlayerList[ i ].strPlayerName, MAX_PLAYER_NAME );

        // Last heartbeat
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );
    }

    // Enter into the game UI
    m_State = STATE_GAME;

    // Set the default game item to "wave"
    m_CurrItem = 0;

    lstrcpynW( m_strStatus, L"You have joined the game", MAX_STATUS_STR );
    m_HeartbeatTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinDenied()
// Desc: Process the join denied message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinDenied( const CXBSockAddr& )
{
    // Only clients should receive "join denied" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join denied" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Only clients who are not currently playing should receive this message
    assert( m_State != STATE_GAME );

    // If for some reason we receive a "join denied" message and we're
    // already playing a game, ignore the message.
    if( m_State == STATE_GAME )
        return;

    // The game we wanted to join is full. Display error
    m_State = STATE_ERROR;
    lstrcpynW( m_strError, L"The game is full.\nChoose another game.",
               MAX_ERROR_STR );
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayerJoined()
// Desc: Process the player joined message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessPlayerJoined( const MsgPlayerJoined& playerJoined, 
                                       const CXBSockAddr& saFrom )
{
    // saFrom is the address of the host that sent this message, but we
    // we already have his address, so throw it away
    (VOID)saFrom;

    const Player& player = playerJoined.player;
    PlayerInfo playerInfo;

    // Convert the XNADDR of the player to the INADDR we'll use to wave
    // to the player
    INT iResult = XNetXnAddrToInAddr( &player.xnAddr, &m_xnHostKeyID,
                                      &playerInfo.inAddr );
    if( iResult == SOCKET_ERROR )
    {
        // If the client XNADDR can't be converted to an INADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetXnAddrToInAddr", iResult );
        assert( FALSE );
        return;
    }

    // Client doesn't need the XNADDR of the host anymore, 
    // so we just leave it zero. This data member is only used by hosts.
    ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

    // Save the player name
    lstrcpynW( playerInfo.strPlayerName, player.strPlayerName, MAX_PLAYER_NAME );

    // Last heartbeat
    playerInfo.dwLastHeartbeat = GetTickCount();

    // Add the new player to our list
    m_Players.push_back( playerInfo );

    // Update status
    wsprintfW( m_strStatus, L"%.*s has joined the game", 
               MAX_PLAYER_NAME, player.strPlayerName );
}




//-----------------------------------------------------------------------------
// Name: ProcessWave()
// Desc: Process the wave message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessWave( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who waved by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update status
    if( i != m_Players.end() )
    {
        wsprintfW( m_strStatus, L"%.*s waved", 
                   MAX_PLAYER_NAME, i->strPlayerName );
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessHeartbeat()
// Desc: Process the heartbeat message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessHeartbeat( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who sent a heartbeat by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update that player's heartbeat time
    if( i != m_Players.end() )
        i->dwLastHeartbeat = GetTickCount();
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayersDropouts()
// Desc: Process players and determine if anybody has left the game
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessPlayerDropouts()
{
    DWORD dwTickCount = GetTickCount();
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
    {
        PlayerInfo playerInfo = *i;
        DWORD dwElapsed = dwTickCount - playerInfo.dwLastHeartbeat;
        if( dwElapsed > PLAYER_TIMEOUT )
        {
            // This player hasn't sent a heartbeat message in a long time.
            // Assume they left the game.

            if( !m_bIsHost && i == m_Players.begin() )
            {
                wsprintfW( m_strStatus, L"Host %.*s left game. "
                                        L"Game closed to new players.",
                           MAX_PLAYER_NAME, playerInfo.strPlayerName );
            }
            else
            {
                wsprintfW( m_strStatus, L"%.*s left the game", 
                           MAX_PLAYER_NAME, playerInfo.strPlayerName );
            }

            // Delete the player from the list
            m_Players.erase( i );
            return TRUE;
        }
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: DestroyGameList()
// Desc: Clear the list of games
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyGameList()
{
    // Physically clear the list of games to obliterate the key and XNADDR info
    // from prying eyes. This particular method works because m_Games 
    // is a vector; if m_Games is not a vector each game must be 
    // cleared individually
    if( !m_Games.empty() )
    {
        GameInfo* pGameList = &m_Games[0];
        ZeroMemory( pGameList, m_Games.size() * sizeof( GameInfo ) );

        // Destroy the list of games
        m_Games.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: DestroyPlayerList()
// Desc: Clear the list of players
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyPlayerList()
{
    // Physically clear the list of players to obliterate the XNADDR info
    // from prying eyes. This particular method works because m_Players
    // is a vector; if m_Players is not a vector each player must be 
    // cleared individually
    if( !m_Players.empty() )
    {
        PlayerInfo* pPlayerList = &m_Players[0];
        ZeroMemory( pPlayerList, m_Players.size() * sizeof( PlayerInfo ) );

        // Destroy the list of players
        m_Players.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: LogXNetError()
// Desc: Log errors to the hard drive. When testing xnets.lib, there's no
//       debugging channel, so it's useful to log failures to the hard drive.
//-----------------------------------------------------------------------------
VOID CXBoxSample::LogXNetError( const CHAR* strError, INT iError ) const
{

    // Make sure that we're not logging anything in the final release
#ifndef FINAL_BUILD

    if( m_hLogFile == INVALID_HANDLE_VALUE )
    {
        m_hLogFile = CreateFile( "U:\\XNetError.log", GENERIC_WRITE, 0, NULL,
                                 CREATE_ALWAYS, 0, NULL );
        if( m_hLogFile == INVALID_HANDLE_VALUE )
            return;
    }

    // Write out the error message
    CHAR strBuffer[256];
    wsprintfA( strBuffer, "%s error: %d\r\n", strError, iError );
    DWORD dwWritten;
    WriteFile( m_hLogFile, strBuffer, lstrlenA( strBuffer ), &dwWritten, NULL );

    // Make sure the message makes it to the disk
    FlushFileBuffers( m_hLogFile );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\xarena.cpp ===
//-----------------------------------------------------------------------------
// File: xarena.cpp
//
// Desc: Sample game to illustrate online functionality for the xbox.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <assert.h>

#include "xdppeer.h"
#include "xpath.h"
#include "xmenu.h"
#include "xtextbox.h"
#include "xobj.h"
#include "xpart.h"

#include "xarena.h"
#include "net.h"
#include "xtank.h"

extern CXModel Weapon_GunModel;
CXParticleSystem *XAPart = NULL;

// UI Stuff
XTextBox *XBox;									// pun intended
DWORD g_dwMenuCommand;
XMenu *g_MainMenu;								// main menu
XMenu *g_NameMenu;								// choose name menu

D3DXMATRIX g_mView;								// view matrix

// tanks
CXTank *g_pTank[MAX_TANKS];
DWORD g_dwNumTanks;

CXObject g_objArena;
CXBMesh *g_pxbmArena;

//-----------------------------------------------------------------------------
// help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_LEFTSTICK,  XBHELP_PLACEMENT_1, L"Move Tank"},
    { XBHELP_RIGHTSTICK,  XBHELP_PLACEMENT_1, L"Rotate Tank"},
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle Help\nMenu Back"},
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_1, L"Menu Activate\nMenu Select"},
	{ XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_1, L"Left Trigger: Switch Weapons\nRight Trigger: Fire Weapon"}
};
#define MAX_NORMAL_HELP_CALLOUTS 5

BOOL g_bDrawHelp = FALSE;
DWORD Help(DWORD cmd, XMenuItem *mi);		// help activate menu item

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont m_Font;
    CXBHelp m_Help;

	D3DXVECTOR3	m_vCameraPos;
	D3DXVECTOR3	m_vCameraRot;

	D3DLIGHT8 m_Light;

	DWORD m_dwBytesSentPerSecond;
	DWORD m_dwBytesReceivedPerSecond;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();
	void InitNameMenu();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
	m_vCameraPos = D3DXVECTOR3(0.0f, 10.0f, -15.0f);
	m_vCameraRot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;
	D3DXVECTOR3 v;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// Initialize the help system
    if(FAILED(hr = m_Help.Create(m_pd3dDevice, "Gamepad.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	XMenu_SetFont(&m_Font);
	XTextBox_SetFont(&m_Font);

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI/4, 640.0f/480.0f, 1.0f, 200.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &matProj);

	m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);

	// init a directional light
	XBUtil_InitLight(m_Light, D3DLIGHT_DIRECTIONAL, 1.0f, 0.0f, 1.0f);
	m_pd3dDevice->SetLight(0, &m_Light);
	m_pd3dDevice->LightEnable(0, TRUE);
	m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0x80808080);

	// init the 'choose player name' menu
	InitNameMenu();

	// init a menu
	g_MainMenu = XMenu_Init(320.0f, 120.0f, 5, 0, NULL);
	XMenu_AddItem(g_MainMenu, 0, L"SINGLE PLAYER", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"MULTIPLAYER", Net_Menu);
	XMenu_AddItem(g_MainMenu, MITEM_SEPARATOR, NULL, NULL);
	XMenu_AddItem(g_MainMenu, 0, L"OPTIONS", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"HELP", Help);

	// init a textbox
	XBox = XTextBox_Init(64, 480.0f-50.0f-(float)m_Font.GetFontHeight()*4.0f,
						640.0f-128.0f, 3, TBOX_POPUP);
	XBox->expiretime = 2000;		// keep messages up for 2 seconds

	// set base path to point to our data
	// all the _FNA commands use this
	XPath_SetBasePath(_T("d:\\media\\"));

	// arena
	g_pxbmArena = new CXBMesh;
	g_pxbmArena->Create(g_pd3dDevice, "models\\arena.xbg" );
	g_objArena.SetXBMesh(g_pxbmArena);
	g_objArena.SetRotation(-1.57f, 0.0f, 0.0f);

	// tanks
	srand(GetTickCount());
	v = D3DXVECTOR3(frand(80.0f)-40.0f, 0.0f, frand(80.0f)-40.0f);
	g_pTank[0] = new CXTank(&v, 0.0f);
	g_dwNumTanks = 1;

	// weapons
	Weapon_Init();

	// particle system
	XAPart = new CXParticleSystem(500, "textures\\bullet2.bmp");

	// networking
	Net_Init();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	DWORD i;

	XMenu_Delete(g_MainMenu);

	for(i=0; i<g_dwNumTanks; i++)
		delete g_pTank[0];

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	D3DXMATRIX m;
	static float fUpdateTime = 0.0f;
	static float fStatTime = 0.0f;
	static DWORD dwBytesSentBase = 0;
	static DWORD dwBytesReceivedBase = 0;
	float time;

	// do DPlay processing
	XDPDoWork(0);

	// process menu input
	if(!g_bDrawHelp)
	{
		g_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
		if(g_dwMenuCommand==MENU_ACTIVATE)
			XMenu_Activate(g_MainMenu);
		if(XMenu_IsActive())
			return S_OK;
	}

	// toggle help menu
	if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
		g_bDrawHelp = !g_bDrawHelp;
	if(g_bDrawHelp)
		return S_OK;

	// update local tank
	g_pTank[0]->Update(&m_DefaultGamepad, m_fElapsedTime);

	// update remote tanks
	for(DWORD i=1; i<g_dwNumTanks; i++)
		g_pTank[i]->Update(NULL, m_fElapsedTime);

	// send update if we are in a game
	// also do bandwidth calcs every second
	if(XDPIsConnected())
	{
		time = XBUtil_Timer(TIMER_GETAPPTIME);
		if(time>fUpdateTime)
		{
			Net_SendUpdateTank(g_pTank[0]);
			fUpdateTime += 0.1f;			// 100msec
		}

		if(time>fStatTime)
		{
			m_dwBytesSentPerSecond = g_dwBytesSent - dwBytesSentBase;
			m_dwBytesReceivedPerSecond = g_dwBytesReceived - dwBytesReceivedBase;

			dwBytesSentBase = g_dwBytesSent;
			dwBytesReceivedBase = g_dwBytesReceived;

			fStatTime += 1.0f;
		}
	}

	// camerapos = tank pos
	m_vCameraPos = g_pTank[0]->m_pObj->m_vPosition;
	D3DXMatrixTranslation(&g_mView, -m_vCameraPos.x, -m_vCameraPos.y, -m_vCameraPos.z);

	// camera rotation = tank rotation
	D3DXMatrixRotationY(&m, -g_pTank[0]->m_pObj->m_vRotation.y);
	D3DXMatrixMultiply(&g_mView, &g_mView, &m);

	m_pd3dDevice->SetTransform(D3DTS_VIEW, &g_mView);

	// weapon update
	Weapon_Update(m_fElapsedTime);

	// particle update
	XAPart->Update(m_fElapsedTime);

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	DWORD i;

    // clear the viewport
    m_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0xff400000, 1.0f, 0L );

	// restore state that text clobbers
    m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	// render objects with modulate tex/diffuse
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	m_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

	g_objArena.Render(0);				// render arena

	Weapon_Render();					// render weapons
	
	for(i=1; i<g_dwNumTanks; i++)		// render all tanks but local
		g_pTank[i]->m_pObj->Render(0);

	XAPart->Render();					// render particles

	g_pTank[0]->Hud(&m_Font);			// show tank hud

	// process the menu
	XMenu_Routine(g_dwMenuCommand);
	XTextBox_Display(XBox);

	// show game title
	m_Font.DrawText(64, 50, 0xffffffff, L"X-ARENA");
	m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

	// show our current status
	switch(g_dwConnectStatus)
	{
		case GAME_HOSTING:
			m_Font.DrawText(640-64, 70, 0xff00ff00, L"HOSTING", XBFONT_RIGHT);
			break;
		case GAME_ENUMERATING:
			m_Font.DrawText(640-64, 70, 0xffffff00, L"ENUMERATING", XBFONT_RIGHT);
			break;
		case GAME_CONNECTED:
			m_Font.DrawText(640-64, 70, 0xff00ff00, L"CONNECTED", XBFONT_RIGHT);
			break;
		case GAME_NOTCONNECTED:
			m_Font.DrawText(640-64, 70, 0xffff0000, L"NOT CONNECTED", XBFONT_RIGHT);
			break;
		case GAME_CONNECTING:
			m_Font.DrawText(640-64, 70, 0xffffff00, L"CONNECTING", XBFONT_RIGHT);
			break;
	}

	// show # of players & bandwidth usage
	if(XDPIsConnected())
	{
		WCHAR s[40];
		swprintf(s, L"%d PLAYERS", g_dwNumPlayers);
		m_Font.DrawText(640-64, 90, 0xffffffff, s, XBFONT_RIGHT);

		swprintf(s, L"SENT: %d, RECV: %d", m_dwBytesSentPerSecond, m_dwBytesReceivedPerSecond);
		m_Font.DrawText(640-64, 110, 0xffffffff, s, XBFONT_RIGHT);
	}

	// draw help
	if(g_bDrawHelp)
		m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Help
// Desc: Activates help screen from main menu.
//-----------------------------------------------------------------------------
DWORD Help(DWORD cmd, XMenuItem *mi)
{
	g_bDrawHelp = TRUE;
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: GotName and InitNameMenu
// Desc: Creates a menu of names to choose from. Since we dont have a
//       virtual keyboard, this lets us have clients with different names.
//       Also assembles the host session name to be "playername - XArena"
//-----------------------------------------------------------------------------
DWORD GotName(DWORD cmd, XMenuItem *mi)
{
	WCHAR s[80];

	// set player name
	wcscpy(g_wszXDPPlayerName, mi->string);

	// set session name
	wcscpy(g_wszXDPSessionName, g_wszXDPPlayerName);
	wcscat(g_wszXDPSessionName, L" - XArena");

	// welcome our new player!
	swprintf(s, L"Welcome to X-ARENA %s", mi->string);
	XTextBox_AddItem(XBox, s);

	XMenu_Delete(g_NameMenu);
	XMenu_Activate(g_MainMenu);

	return MROUTINE_RETURN;
}

void CXBoxSample::InitNameMenu()
{
	// init the choose player name menu
	g_NameMenu = XMenu_Init(320.0f, 120.0f, 4, MENU_NOBACK, NULL);
	XMenu_SetTitle(g_NameMenu, L"Choose Name", 0xffffff00);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Maximus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Minimus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Animus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Haxor", GotName);
	XMenu_Activate(g_NameMenu);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xsimplepeer\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\xarena.h ===
#ifndef __XARENA_H
#define __XARENA_H

#include "xtank.h"

#define FLOORX 90.0f					// size of floor
#define FLOORY 90.0f
#define FLOORZ 90.0f					// position range is +- SIZE/2
#define POSXBITS 7						// # of integer bits needed 
#define POSZBITS 7						// to represent a position. 
#define POSYBITS 7

#define OBJ_TANK		0x0001			// object is a tank
#define OBJ_OBSTACLE	0x0002			// object is an obstacle

#define MAX_TANKS 16					// max 16 players
extern CXTank *g_pTank[MAX_TANKS];
extern DWORD g_dwNumTanks;

#define frand(a) ((float)rand()*(a)/32768.0f)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xstagedpeer\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\xpart.h ===
//-----------------------------------------------------------------------------
// File: xpart.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>


//-----------------------------------------------------------------------------
// particle vertex type
//-----------------------------------------------------------------------------
#define PS_FVF D3DFVF_XYZ | D3DFVF_DIFFUSE
struct PS_FVFT
{
	D3DXVECTOR3 vPos;
	DWORD dwDiffuse;
};


//-----------------------------------------------------------------------------
// particle structure
//-----------------------------------------------------------------------------
struct XParticle
{
	DWORD dwFlags;					// particle flags
	float fLife;					// # of seconds to live
	D3DXVECTOR3 vPos;				// particle position
	DWORD dwCurColor;				// current color
	DWORD dwDestColor;				// destination color
	D3DXVECTOR3 vVel;				// velocity
	D3DXVECTOR3 vAcc;				// acceleration
};


//-----------------------------------------------------------------------------
// particle system class
//-----------------------------------------------------------------------------
class CXParticleSystem
{
	XParticle *m_Particles;			// array of particles
    LPDIRECT3DVERTEXBUFFER8 m_pVB;	// vertex buffer for particles
    LPDIRECT3DTEXTURE8 m_pTexture;	// guess what this is...

	DWORD m_dwNumParticles;			// # of active particles
	DWORD m_dwMaxParticles;			// max # of particles

public:
	CXParticleSystem(DWORD dwMax, char *texname);
	~CXParticleSystem();

	XParticle *AddParticle();
	void Update(float fElapsedTime);
	void Render();

	void Burst(D3DXVECTOR3 *pos, DWORD dwNumParticles);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\xpart.cpp ===
//-----------------------------------------------------------------------------
// File: xpart.cpp
//
// Desc: mini particle system for xarena
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xpath.h"
#include "xpart.h"

//-----------------------------------------------------------------------------
// misc
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define frand(a) ((float)rand()*(a)/32768.0f)
inline DWORD ftodw(FLOAT f) {return *((DWORD*)&f);}


//-----------------------------------------------------------------------------
// Name: CXParticleSystem
// Desc: Particle system constructor
//-----------------------------------------------------------------------------
CXParticleSystem::CXParticleSystem(DWORD dwMax, char *texname)
{
	m_Particles = new XParticle[dwMax];
	m_dwMaxParticles = dwMax;
	m_dwNumParticles = 0;

	// create vertex buffer
	g_pd3dDevice->CreateVertexBuffer(dwMax*sizeof(PS_FVFT), D3DUSAGE_WRITEONLY,
            PS_FVF, D3DPOOL_DEFAULT, &m_pVB);

    D3DXCreateTextureFromFileA(g_pd3dDevice, _FNA(texname), &m_pTexture);
}


//-----------------------------------------------------------------------------
// Name: ~CXParticleSystem
// Desc: Particle system destructor
//-----------------------------------------------------------------------------
CXParticleSystem::~CXParticleSystem()
{
	delete m_Particles;
	m_pVB->Release();
}


//-----------------------------------------------------------------------------
// Name: Update
// Desc: Update all particles
//-----------------------------------------------------------------------------
void CXParticleSystem::Update(float fElapsedTime)
{
	PS_FVFT *vert;
	DWORD i;
	XParticle *part;

	if(!m_dwNumParticles)				// no particles to update
		return;

	// lock the vertex buffer
	m_pVB->Lock(0, 0, (BYTE **)&vert, 0);

	// update the particles and stuff em into the VB
	for(i=0; i<m_dwNumParticles; i++)
	{
next:
		part = &m_Particles[i];

		part->vVel += part->vAcc;
		part->vPos += part->vVel*fElapsedTime;

		part->fLife -= fElapsedTime;
		if(part->fLife<0.0f || part->vPos.y<0.0f)
		{
			m_dwNumParticles--;
			m_Particles[i] = m_Particles[m_dwNumParticles];
			if(m_dwNumParticles>i)
				goto next;
		}

		vert[i].vPos = part->vPos;
		vert[i].dwDiffuse = part->dwCurColor;
	}

	m_pVB->Unlock();
}


//-----------------------------------------------------------------------------
// Name: AddParticle
// Desc: Yeah... Just adds a particle.
//-----------------------------------------------------------------------------
XParticle *CXParticleSystem::AddParticle()
{
	XParticle *part;

	if(m_dwNumParticles==m_dwMaxParticles)
		return NULL;

	part = &m_Particles[m_dwNumParticles++];

	return part;
}


//-----------------------------------------------------------------------------
// Name: Burst
// Desc: Do a particle system burst
//-----------------------------------------------------------------------------
void CXParticleSystem::Burst(D3DXVECTOR3 *pos, DWORD dwNumParticles)
{
	DWORD i;
	XParticle *part;

	for(i=0; i<dwNumParticles; i++)
	{
		part = AddParticle();
		if(!part)
			return;

		part->dwFlags = 0;

		// init position and movement parameters
		part->vPos = *pos;
		part->vVel.x = frand(1.0f)-0.5f;
		part->vVel.y = frand(1.0f)-0.5f;
		part->vVel.z = frand(1.0f)-0.5f;
		D3DXVec3Normalize(&part->vVel, &part->vVel);
		part->vVel.x *= 6.0f;
		part->vVel.y *= 6.0f;
		part->vVel.z *= 6.0f;
		part->vAcc = D3DXVECTOR3(0.0f, -0.3f, 0.0f);

		// init color params
		part->dwCurColor = 0xffff7f00 + ((rand()&0x7f)<<8);
		part->dwDestColor = 0;

		// init life
		part->fLife = frand(0.75f) + 0.4f;
	}
}


//-----------------------------------------------------------------------------
// Name: Render
// Desc: Render the particles
//-----------------------------------------------------------------------------
void CXParticleSystem::Render()
{
	D3DXMATRIX m;

	if(!m_dwNumParticles)
		return;

	D3DXMatrixIdentity(&m);
	g_pd3dDevice->SetTransform(D3DTS_WORLD, &m);

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

    g_pd3dDevice->SetTexture(3, m_pTexture);
	g_pd3dDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	g_pd3dDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);

    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(3, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

	g_pd3dDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE, ftodw(0.1f));
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MIN, ftodw(0.02f));
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_A, ftodw(0.0f));
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_B, ftodw(3.0f));
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_C, ftodw(0.0f));

    g_pd3dDevice->SetStreamSource(0, m_pVB, sizeof(PS_FVFT));
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE);
    g_pd3dDevice->DrawPrimitive(D3DPT_POINTLIST, 0, m_dwNumParticles);

    g_pd3dDevice->SetTexture(3, NULL);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

    g_pd3dDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
    g_pd3dDevice->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\xtank.h ===
//-----------------------------------------------------------------------------
// File: xtank.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XTANK_H
#define __XTANK_H

#include "xbapp.h"
#include "xbfont.h"
#include "xobj.h"
#include "xbinput.h"

//-----------------------------------------------------------------------------
// weapons
//-----------------------------------------------------------------------------
#define MAX_WEAPONOBJS	32

#define WEAPON_GUN		0
#define WEAPON_ROCKET	1
#define MAX_WEAPONS		2

// fire flags
#define WF_REMOTE		0x01		// fired by remote player

// weapon structure
struct CXWeapon
{
	WCHAR m_wstrDesc[32];			// weapon name
	DWORD m_dwType;					// weapon type
	float m_fSpeed;					// weapon speed
	float m_fFireRate;				// seconds till can fire again
	float m_fDamage;				// damage caused
};

// weapon routines
void Weapon_Init();
CXObject *Weapon_Fire(D3DXVECTOR3 *pPos, float fYRot, BYTE bType, DWORD dwFlags);
void Weapon_Update(float fElapsedTime);
void Weapon_Render();

//-----------------------------------------------------------------------------
// tanks
//-----------------------------------------------------------------------------

// tank flags
#define TANK_REMOTE		0x0001		// this tank controlled remotely

// tank class
class CXTank
{
public:

	CXObject *m_pObj;				// display object
	DWORD m_dwFlags;				// tank flags
	DWORD m_dwTankIdx;				// index in g_pTank[] array

	// characteristics
	float m_fWidth;					// width of tank
	float m_fLength;				// length of tank
	float m_fHeight;				// height of tank
	float m_fMoveSpeed;				// movement speed
	float m_fRotSpeed;				// rotation speed

	// movement state
	D3DXVECTOR3 m_vVel;				// current velocity
	D3DXVECTOR3 m_vAcc;				// current acceleration
	float m_fRotVel;				// y rotational velocity

	DWORD m_dwNumWarpFrames;		// # of frames to do warp adjustment
	D3DXVECTOR3 m_vWarpDist;		// distance to adjust each frame

	// statistics
	DWORD m_dwShots;				// # shots fired
	DWORD m_dwHits;					// # times we hit opponent
	DWORD m_dwOppHits;				// # times opponent hit us

	// life
	float m_fArmor;					// current armor protection
	float m_fLife;					// current life level
	void *m_pvKillPlayer;			// player who killed me

	// weapons
	DWORD m_dwCurWeapon;			// current weapon
	float m_fAmmo[MAX_WEAPONS];		// weapon ammo
	float m_fLastShotTime;			// last time we shot

	CXTank(D3DXVECTOR3 *pos, float yrot);
	~CXTank();

	void Update(XBGAMEPAD *gamepad, float etime);
	void Hud(CXBFont *font);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xarena\xtank.cpp ===
//-----------------------------------------------------------------------------
// File: xtank.cpp
//
// Desc: hovertank code for xarena
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xbapp.h"
#include "xbinput.h"
#include "xdppeer.h"

#include "xtank.h"
#include "xarena.h"
#include "coll.h"
#include "xpart.h"
#include "net.h"

//-----------------------------------------------------------------------------
// misc
//-----------------------------------------------------------------------------
CXBMesh *g_pTankMesh = NULL;					// tank model
extern CXParticleSystem *XAPart;				// particle system pointer


//-----------------------------------------------------------------------------
// weapons
//-----------------------------------------------------------------------------
CXModel Weapon_GunModel, Weapon_RocketModel;	// weapon models
CXWeapon Weapons[MAX_WEAPONS] =
{
	{L"BLASTER", WEAPON_GUN, 75.0f, 0.1f, 5},
	{L"ROCKET", WEAPON_ROCKET, 50.0f, 1.0f, 30},
};

CXObject WeaponObjs[MAX_WEAPONOBJS];
DWORD g_dwNumWeaponObjs = 0;


//-----------------------------------------------------------------------------
// Name: CXTank
// Desc: Tank object constructor
//-----------------------------------------------------------------------------
CXTank::CXTank(D3DXVECTOR3 *pos, float yrot)
{
	D3DXMATRIX *m;
	D3DXVECTOR4 v;

	ZeroMemory(this, sizeof(CXTank));

	// get new object and set position and rotation
	m_pObj = new CXObject;
	m_pObj->m_dwFlags = OBJ_TANK;
	m_pObj->m_pvInfo = this;		// point to tank info

	m_pObj->m_vPosition = *pos;
	m_pObj->m_vRotation.y = yrot;

	// init misc parameters
	m_fMoveSpeed = 20.0f;
	m_fRotSpeed = 1.5f;
	m_fWidth = 1.5f;
	m_fHeight = 1.0f;

	m_fArmor = 100.0f;
	m_fLife = 100.0f;

	// calc new matrix
	m = &m_pObj->m_matOrientation;
	D3DXMatrixRotationY(m, yrot);

	// load the tank mesh if not already loaded
	if(g_pTankMesh==NULL)
	{
		g_pTankMesh = new CXBMesh();
		g_pTankMesh->Create(g_pd3dDevice, "models\\tank.xbg" );
	}

	// set the mesh for our tank object
	m_pObj->SetXBMesh(g_pTankMesh);

	// init weapon info
	m_dwCurWeapon = WEAPON_GUN;
	m_fAmmo[WEAPON_GUN] = 1000.0f;
	m_fAmmo[WEAPON_ROCKET] = 100.0f;
	m_fLastShotTime = 0.0f;

	// init movement state
	m_vVel = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_vAcc = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fRotVel = 0.0f;
}

//-----------------------------------------------------------------------------
// Name: ~CXTank
// Desc: Tank object destructor
//-----------------------------------------------------------------------------
CXTank::~CXTank()
{
	delete m_pObj;
}


//-----------------------------------------------------------------------------
// Name: Update
// Desc: Updates a tanks position, orientation, and firing
//       If it is a local tank, this information is taken from the joypad,
//       if the tank is remotely controlled, it is updated with dead-reckoning.
//-----------------------------------------------------------------------------
void CXTank::Update(XBGAMEPAD *gamepad, float etime)
{
	D3DXMATRIX *m;
	D3DXVECTOR3 pos, v;

	m = &m_pObj->m_matOrientation;			// get current matrix

	float xacc, zacc;
	float xvel, zvel, rvel;
	float sinry, cosry;

	if(m_dwFlags&TANK_REMOTE)
	{
		// this is a remotely controlled tank,
		// so do warp processing if necessary
		if(m_dwNumWarpFrames>0)
		{
			m_pObj->m_vPosition += m_vWarpDist;
			m_dwNumWarpFrames--;
		}
	}
	else
	{
		// this is a locally controlled tank

		// check if we were killed
		if(m_fLife<=0.0f)
		{
			// we're dead, teleport to some new location
			m_pObj->m_vPosition.x = frand(80.0f)-40.0f;
			m_pObj->m_vPosition.y = 0.0f;
			m_pObj->m_vPosition.z = frand(80.0f)-40.0f;
			m_pObj->m_vRotation.y = frand(3.14159f*2.0f);
			Net_SendUpdateTank(this);

			// reset statistics
			m_fArmor = 100.0f;
			m_fLife = 100.0f;
			m_fAmmo[WEAPON_GUN] = 1000.0f;
			m_fAmmo[WEAPON_ROCKET] = 100.0f;
			m_fLastShotTime = 0.0f;
		}
		else
		{
			// not dead, get acceleration from gamepad
			m_vAcc.x = gamepad->fX1*m_fMoveSpeed*4.0f;
			m_vAcc.z = gamepad->fY1*m_fMoveSpeed*4.0f;
		}
	}

	xacc = m_vAcc.x;
	zacc = m_vAcc.z;

	// if no acceleration, decelerate the tank
	if((xacc<0.1f) && (xacc>-0.1f))
		xacc = -(m_vVel.x*4.0f);
	if((zacc<0.1f) && (zacc>-0.1f))
		zacc = -(m_vVel.z*4.0f);

	// adjust velocity
	m_vVel.x += xacc*etime;
	m_vVel.z += zacc*etime;

	// clamp speed
	if(D3DXVec3LengthSq(&m_vVel)>(m_fMoveSpeed*m_fMoveSpeed))
	{
		D3DXVec3Normalize(&m_vVel, &m_vVel);
		m_vVel.x *= m_fMoveSpeed;
		m_vVel.z *= m_fMoveSpeed;
	}

	// calc new position
	sinry = (float)sin(m_pObj->m_vRotation.y);
	cosry = (float)cos(m_pObj->m_vRotation.y);
	xvel = m_vVel.x*cosry + m_vVel.z*sinry;
	zvel = m_vVel.z*cosry - m_vVel.x*sinry;
	m_pObj->m_vPosition.x += xvel*etime;
	m_pObj->m_vPosition.y = m_fHeight;
	m_pObj->m_vPosition.z += zvel*etime;

	// get new y rotation
	if(!(m_dwFlags&TANK_REMOTE))
	{
		rvel = gamepad->fX2;
		if(rvel>=0.0f)
			rvel *= rvel*m_fRotSpeed;
		else
			rvel = -(rvel*rvel)*m_fRotSpeed;

		if((rvel<0.1f) && (rvel>-0.1f))
			m_fRotVel *= 0.8f;
		else
			m_fRotVel = rvel;
	}
	m_pObj->m_vRotation.y += m_fRotVel*etime;

	// keep yrot in 0-TWOPI range
	if(m_pObj->m_vRotation.y>(D3DX_PI*2.0f))
		m_pObj->m_vRotation.y -= (D3DX_PI*2.0f);
	if(m_pObj->m_vRotation.y<0.0f)
		m_pObj->m_vRotation.y += (D3DX_PI*2.0f);

	// calc new matrix
	D3DXMatrixRotationY(m, m_pObj->m_vRotation.y);

	// keep in bounds
	CollCheck(&m_pObj->m_vPosition, m_fWidth/2.0f);

	// do weapon processing on local tank
	if(!(m_dwFlags&TANK_REMOTE))
	{
		// check for weapon change
		if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER])
		{
			m_dwCurWeapon++;
			if(m_dwCurWeapon==MAX_WEAPONS)
				m_dwCurWeapon = 0;
		}

		// check for weapon fire
		if(gamepad->bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
		{
			if(m_fAmmo[m_dwCurWeapon]>0.0f)
			{
				// place starting position of projectile at gun
				pos = m_pObj->m_vPosition;
				pos.x += m_pObj->m_matOrientation._31*2.0f;
				pos.z += m_pObj->m_matOrientation._33*2.0f;
				pos.x += m_pObj->m_matOrientation._11*0.475f;
				pos.z += m_pObj->m_matOrientation._13*0.475f;

				switch(m_dwCurWeapon)
				{
					case WEAPON_GUN:
					case WEAPON_ROCKET:
						if((m_fLastShotTime+Weapons[m_dwCurWeapon].m_fFireRate)<XBUtil_Timer(TIMER_GETABSOLUTETIME))
						{
							m_fAmmo[m_dwCurWeapon]--;
							m_fLastShotTime = XBUtil_Timer(TIMER_GETABSOLUTETIME);
							CXObject *obj;
							obj = Weapon_Fire(&pos, m_pObj->m_vRotation.y, (BYTE)m_dwCurWeapon, 0);
							obj->m_pvInfo = (void *)g_dpnidLocalPlayer;		// tell who fired
						}
						break;

					// add additional weapons here
				}
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Name: Hud
// Desc: Show the tanks main heads up display.
//-----------------------------------------------------------------------------
void CXTank::Hud(CXBFont *font)
{
	WCHAR s[80];
	DWORD color;

	swprintf(s, L"WEAPON: %s", Weapons[m_dwCurWeapon].m_wstrDesc);
    font->DrawText(64, 80, 0xffffffff, s);
	swprintf(s, L"AMMO: %3.1f", m_fAmmo[m_dwCurWeapon]);
    font->DrawText(64, 100, 0xffffffff, s);

	color = 0xff00ff00;
	if(m_fArmor<60.0f)
		color = 0xffffff00;
	if(m_fArmor<30.0f)
		color = 0xffff0000;
	swprintf(s, L"ARMOR: %3.0f", m_fArmor);
    font->DrawText(64, 120, color, s);

	color = 0xff00ff00;
	if(m_fLife<60.0f)
		color = 0xffffff00;
	if(m_fLife<30.0f)
		color = 0xffff0000;
	swprintf(s, L"LIFE: %3.0f", m_fLife);
    font->DrawText(64, 140, color, s);
}

//-----------------------------------------------------------------------------
// Weapon Code
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Name: Weapon_Init
// Desc: Initialize the weapons subsystem
//-----------------------------------------------------------------------------
void Weapon_Init()
{
	Weapon_GunModel.Sphere(0.1f, 8, 8, FVF_XYZNORMTEX1, "textures\\bullet.bmp", 1.0f);
}


//-----------------------------------------------------------------------------
// Name: Weapon_Fire
// Desc: Fire a weapon
//-----------------------------------------------------------------------------
CXObject *Weapon_Fire(D3DXVECTOR3 *pPos, float fYRot, BYTE bType, DWORD dwFlags)
{
	CXObject *obj;

	if(g_dwNumWeaponObjs==MAX_WEAPONOBJS)
	{
		OUTPUT_DEBUG_STRING( "MAX_WEAPONOBJS exceeded in Weapon_Fire" );
		return NULL;
	}

	obj = &WeaponObjs[g_dwNumWeaponObjs];

	// set position so it is outside of firing tanks radius
	obj->m_vPosition = *pPos;
	obj->m_vRotation.y = fYRot;
	D3DXMatrixRotationY(&obj->m_matOrientation, fYRot);
	obj->m_dwType = (DWORD)bType;
	obj->SetModel(&Weapon_GunModel);

	if(!(dwFlags&WF_REMOTE))
		if(XDPIsConnected())
			Net_SendFireWeapon(obj, bType);

	g_dwNumWeaponObjs++;

	return obj;
}


//-----------------------------------------------------------------------------
// Name: Weapon_Update
// Desc: Update all weapon objects
//-----------------------------------------------------------------------------
void Weapon_Update(float fElapsedTime)
{
	DWORD i;
	CXObject *obj, *collobj;
	CXTank *tank;
	float speed;

	for(i=0; i<g_dwNumWeaponObjs; i++)
	{
next:
		obj = &WeaponObjs[i];
		speed = Weapons[obj->m_dwType].m_fSpeed * fElapsedTime;

		obj->m_vPosition.x += obj->m_matOrientation._31*speed;
		obj->m_vPosition.y += obj->m_matOrientation._32*speed;
		obj->m_vPosition.z += obj->m_matOrientation._33*speed;

		obj->m_matOrientation._41 = obj->m_vPosition.x;
		obj->m_matOrientation._42 = obj->m_vPosition.y;
		obj->m_matOrientation._43 = obj->m_vPosition.z;

		collobj = CollCheck(&obj->m_vPosition, 1.0f);

		if(collobj)
		{
			// register damage on object we hit
			if(collobj!=COLLOBJ_ARENA)
			{
				// only damage other tanks
				if(collobj->m_dwFlags&OBJ_TANK)
				{
					tank = (CXTank *)collobj->m_pvInfo;

					// only do damage processing if this tank is
					// not already dead (for counting death)
					if(tank->m_fLife>0.0f)
					{
						tank->m_fArmor -= Weapons[obj->m_dwType].m_fDamage;
						if(tank->m_fArmor<0)
						{
							tank->m_fLife += tank->m_fArmor;
							tank->m_fArmor = 0;

							if(tank->m_fLife<=0.0f && !(tank->m_dwFlags&TANK_REMOTE))
							{
								// send a humiliating message that we were killed
								DPNID dpnidKiller;
								dpnidKiller = (DPNID)obj->m_pvInfo;
								Net_SendKill(dpnidKiller);
							}
						}
					}
				}
			}

			XAPart->Burst(&obj->m_vPosition, 100);

			// got a collision, delete this object
			obj->SetModel(NULL);

			g_dwNumWeaponObjs--;

			// move last object into deleted objects spot
			WeaponObjs[i] = WeaponObjs[g_dwNumWeaponObjs];

			// clear out the last object (so we dont mess up refcounts)
			memset(&WeaponObjs[g_dwNumWeaponObjs], 0, sizeof(CXObject));
			if(g_dwNumWeaponObjs>i)
				goto next;
		}
	}
}


//-----------------------------------------------------------------------------
// Name: Weapon_Render
// Desc: Render all the weapon objects
//-----------------------------------------------------------------------------
void Weapon_Render()
{
	DWORD i;

	for(i=0; i<g_dwNumWeaponObjs; i++)
		WeaponObjs[i].Render(OBJ_NOMCALCS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xstagedpeer\xstage.h ===
#ifndef __XSTAGE_H
#define __XSTAGE_H

#ifdef __cplusplus
extern "C" {
#endif

void XStage_Init();
void XStage_Shutdown();
void XStage_DoMPStage(WCHAR *hostname);
void XStage_AddPlayer(WCHAR *pName, DPNID dpnidPlayer);
void XStage_DeletePlayer(DPNID dpnid);
DWORD XStage_MsgHandler(void *msg);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xstagedpeer\xstage.cpp ===
//-----------------------------------------------------------------------------
// File: xstage.cpp
//
// Desc: staging routines for xstagedpeer
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "xdppeer.h"
#include "xmenu.h"
#include "xstage.h"
#include "xstagedpeer.h"

// slot info
#define SLOT_CLOSED		0
#define SLOT_OPEN		1
#define SLOT_OCCUPIED	2
#define SLOT_READY		3
#define SLOTCOLOR_CLOSED	0xffff0000
#define SLOTCOLOR_OPEN		0xffffffff
#define SLOTCOLOR_OCCUPIED	0xffffff00
#define SLOTCOLOR_READY		0xff00ff00

#define MAX_SLOTS 6
struct SlotData
{
	DWORD dwStatus;
	WCHAR wstrPlayerName[MAX_PLAYER_NAME];
	DWORD dpnidPlayer;
};

// mp stage messages
#define STAGEMSG_BASE			100
#define STAGEMSG_REJECT			STAGEMSG_BASE+0
#define STAGEMSG_SLOTNUMBER		STAGEMSG_BASE+1
#define STAGEMSG_SLOTREADY		STAGEMSG_BASE+2
#define STAGEMSG_SLOTOCCUPIED	STAGEMSG_BASE+3
#define STAGEMSG_SLOTUPDATE		STAGEMSG_BASE+4
#define STAGEMSG_SLOTOPEN		STAGEMSG_BASE+5
#define STAGEMSG_SLOTCLOSED		STAGEMSG_BASE+6
#define STAGEMSG_STARTGAME		STAGEMSG_BASE+7

#pragma pack(push, 1)
// mp message structures
struct STAGEMSG_GENERIC
{
	DWORD dwType;
};
struct STAGEMSG_SLOTINFO
{
	DWORD dwType;
	DWORD dwSlot;
};
struct STAGEMSG_SLOTDATA
{
    DWORD dwType;
	SlotData Slots[MAX_SLOTS];
};
#pragma pack(pop)

XMenu *MPStageMenu = NULL;			// multiplayer stage menu
BOOL g_bAllowJoin;
XMenuItem *g_MPSlots[8];
DWORD g_dwLocalSlot;
extern DWORD g_dwGameState;			// defined in app

// local functions
int XStage_FindSlot();
DWORD XStage_SlotFunction(DWORD cmd, XMenuItem *mi);
DWORD XStage_StartGame(DWORD cmd, XMenuItem *mi);
HRESULT XStage_SendSlotData();
void XStage_SlotUpdate(STAGEMSG_SLOTDATA *msg);
void XStage_SendReject(DWORD dpnidPlayer);
void XStage_SendSlotStatus(DWORD sendto, DWORD slot, DWORD msgtype);

//-----------------------------------------------------------------------------
// Name: XStage_FindSlot
// Desc: Finds an open slot in the MP stage
//-----------------------------------------------------------------------------
int XStage_FindSlot()
{
	DWORD i;

	for(i=1; i<8; i++)
		if(g_MPSlots[i]->val1==SLOT_OPEN)
			return i;

	return -1;
}

//-----------------------------------------------------------------------------
// Name: XStage_SlotFunction
// Desc: Called when a slot is chosen by a player
//-----------------------------------------------------------------------------
DWORD XStage_SlotFunction(DWORD cmd, XMenuItem *mi)
{
	DWORD slot, i;

	// figure out which MP slot was chosen
	slot = -1;
	for(i=0; i<MAX_SLOTS; i++)
		if(g_MPSlots[i]==mi)
		{
			slot = i;
			break;
		}

	if(g_dwConnectStatus==GAME_HOSTING)
	{
		// if we clicked on ourself, just return
		if(slot==0)
			return MROUTINE_RETURN;

		// otherwise toggle slot status
		switch(mi->val1)
		{
			// if slot was closed, open it
			case SLOT_CLOSED:
				XMenu_SetItemText(mi, L"Open");
				mi->color = SLOTCOLOR_OPEN;
				mi->val1 = SLOT_OPEN;
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, slot, STAGEMSG_SLOTOPEN);
				break;

			// if slot was open, close it
			case SLOT_OPEN:
				XMenu_SetItemText(mi, L"Closed");
				mi->color = SLOTCOLOR_CLOSED;
				mi->val1 = SLOT_CLOSED;
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, slot, STAGEMSG_SLOTCLOSED);
				break;

			// if slot was occupied or ready, just kick the player
			case SLOT_READY:
			case SLOT_OCCUPIED:
				XMenu_SetItemText(mi, L"Open");
				mi->color = SLOTCOLOR_OPEN;
				mi->val1 = SLOT_OPEN;
				XStage_SendReject(mi->val2);
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, slot, STAGEMSG_SLOTOPEN);
				break;
		}
	}
	else	
	{		
		// otherwise, we connected to an existing game
		// and all we can do is toggle our readiness

		// make sure we are on our own slot
		if(g_dwLocalSlot==slot)
		{
			// when we toggle our status, all we do is send a message
			// to the server so we wont show ready until the server
			// acks it
			if(mi->val1==SLOT_READY)
				XStage_SendSlotStatus(g_dpnidHost, g_dwLocalSlot, STAGEMSG_SLOTOCCUPIED);
			else
				XStage_SendSlotStatus(g_dpnidHost, g_dwLocalSlot, STAGEMSG_SLOTREADY);
		}
	}

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: XStage_AbortMPStage
// Desc: Called when a the game is aborted for any reason.
//       Calls terminate if player was the host otherwise
//       calls disconnect.
//-----------------------------------------------------------------------------
DWORD XStage_AbortMPStage(DWORD cmd, XMenuItem *mi)
{
	// if we are hosting, terminate the game
	// otherwise, just disconnect
	if(g_dwConnectStatus==GAME_HOSTING)
		XDPTerminate();
	else
		XDPDisconnect();

	g_dwGameState = GAMESTATE_ATTRACT;

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: XStage_DoMPStage
// Desc: Builds the multiplayer staging menu.
//       If the player is the host, start game item is included.
//-----------------------------------------------------------------------------
void XStage_DoMPStage(WCHAR *hostname)
{
	DWORD i;
	XMenuItem *mi;

	// create stage menu
	if(MPStageMenu)
		XMenu_Delete(MPStageMenu);

	// if hostname is defined, we are the host so do the host menu
	if(hostname)
	{
		MPStageMenu = XMenu_Init(200.0f, 100.0f, MAX_SLOTS+3, 0, XStage_AbortMPStage);
		XMenu_AddItem(MPStageMenu, MITEM_ROUTINE, L"Start Game", XStage_StartGame);
		XMenu_AddItem(MPStageMenu, MITEM_ROUTINE, L"Abort Game", XStage_AbortMPStage);
		XMenu_AddItem(MPStageMenu, MITEM_SEPARATOR, NULL, NULL);

		// add host player
		g_MPSlots[0] = XMenu_AddItem(MPStageMenu, MITEM_ROUTINE, hostname, XStage_SlotFunction);
		g_MPSlots[0]->val1 = SLOT_READY;
		g_MPSlots[0]->color = SLOTCOLOR_READY;

		// flag join allowed
		g_bAllowJoin = TRUE;

		// set our local slot number
		g_dwLocalSlot = 0;
	}
	else
	{
		MPStageMenu = XMenu_Init(200.0f, 100.0f, MAX_SLOTS+2, 0, XStage_AbortMPStage);
		XMenu_AddItem(MPStageMenu, MITEM_ROUTINE, L"Abort Game", XStage_AbortMPStage);
		XMenu_AddItem(MPStageMenu, MITEM_SEPARATOR, NULL, NULL);
		g_MPSlots[0] = XMenu_AddItem(MPStageMenu, MITEM_ROUTINE, L"HOST", XStage_SlotFunction);
		g_MPSlots[0]->color = SLOTCOLOR_OCCUPIED;

		// flag join not allowed
		g_bAllowJoin = FALSE;

		// set our local slot number
		g_dwLocalSlot = -1;
	}

	// add player slots
	for(i=1; i<MAX_SLOTS; i++)
	{
		mi = XMenu_AddItem(MPStageMenu, MITEM_ROUTINE, L"Open", XStage_SlotFunction);
		mi->color = SLOTCOLOR_OPEN;
		mi->val1 = SLOT_OPEN;
		mi->val2 = 0;

		g_MPSlots[i] = mi;
	}

	MPStageMenu->w = 240.0f;	
	MPStageMenu->flags |= MENU_LEFT;
	XMenu_Activate(MPStageMenu);

	g_dwGameState = GAMESTATE_STAGING;
}

//-----------------------------------------------------------------------------
// Name: XStage_SendSlotData
// Desc: Sends updated slot data to all players.
//       Called by host whenever a player enters or leaves the game.
//-----------------------------------------------------------------------------
HRESULT XStage_SendSlotData()
{
	DWORD i;
	XMenuItem *mi;
    STAGEMSG_SLOTDATA msg;
    DPN_BUFFER_DESC buf;
    DPNHANDLE hAsync;

    if(g_dwConnectStatus!=GAME_HOSTING)
        return E_FAIL;

	// fill in slot update message
    msg.dwType = STAGEMSG_SLOTUPDATE;

	for(i=0; i<MAX_SLOTS; i++)
	{
		mi = g_MPSlots[i];
	
		wcsncpy(msg.Slots[i].wstrPlayerName, mi->string, MAX_PLAYER_NAME);
		msg.Slots[i].dwStatus = mi->val1;
		msg.Slots[i].dpnidPlayer = mi->val2;
	}

    buf.dwBufferSize = sizeof(STAGEMSG_SLOTDATA);
    buf.pBufferData = (BYTE *)&msg;

    g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &buf, 1, 0, NULL, &hAsync, 0 );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XStage_SlotUpdate
// Desc: Updates slot information from network message.
//       Called from DPMsgHandler in response to MSG_SLOTUPDATE
//-----------------------------------------------------------------------------
void XStage_SlotUpdate(STAGEMSG_SLOTDATA *msg)
{
	DWORD i;
	XMenuItem *mi;

	for(i=0; i<MAX_SLOTS; i++)
	{
		mi = g_MPSlots[i];
		XMenu_SetItemText(mi, msg->Slots[i].wstrPlayerName);
		mi->val1 = msg->Slots[i].dwStatus;
		mi->val2 = msg->Slots[i].dpnidPlayer;

		switch(mi->val1)
		{
			case SLOT_CLOSED:
				mi->color = SLOTCOLOR_CLOSED;
				break;
			case SLOT_OPEN:
				mi->color = SLOTCOLOR_OPEN;
				break;
			case SLOT_OCCUPIED:
				mi->color = SLOTCOLOR_OCCUPIED;
				break;
			case SLOT_READY:
				mi->color = SLOTCOLOR_READY;
				break;
		}
	}
}

//-----------------------------------------------------------------------------
// Name: XStage_SendReject
// Desc: Sends a message to a player indicating they were rejected
//-----------------------------------------------------------------------------
void XStage_SendReject(DWORD dpnidPlayer)
{
	STAGEMSG_GENERIC msg;
    DPN_BUFFER_DESC buf;
    DPNHANDLE hAsync;

	msg.dwType = STAGEMSG_REJECT;
	buf.dwBufferSize = sizeof(STAGEMSG_GENERIC);
	buf.pBufferData = (BYTE *)&msg;
	g_pDP->SendTo(dpnidPlayer, &buf, 1, 0, NULL, &hAsync, 0);
}

//-----------------------------------------------------------------------------
// Name: XStage_SendSlotStatus
// Desc: Sends a message to the specified recipient indicating
//       the status of a particular slot.
//-----------------------------------------------------------------------------
void XStage_SendSlotStatus(DWORD sendto, DWORD slot, DWORD msgtype)
{
	STAGEMSG_SLOTINFO msg;
    DPN_BUFFER_DESC buf;
    DPNHANDLE hAsync;

	msg.dwType = msgtype;
	msg.dwSlot = slot;
	buf.dwBufferSize = sizeof(STAGEMSG_SLOTINFO);
	buf.pBufferData = (BYTE *)&msg;
	g_pDP->SendTo(sendto, &buf, 1, 0, NULL, &hAsync, DPNSEND_NOLOOPBACK);
}

//-----------------------------------------------------------------------------
// Name: XStage_StartGame
// Desc: Sends a message to all players indicating the start of the game
//-----------------------------------------------------------------------------
DWORD XStage_StartGame(DWORD cmd, XMenuItem *mi)
{
	DWORD i;
	BOOL flag;
	STAGEMSG_GENERIC msg;
    DPN_BUFFER_DESC buf;
    DPNHANDLE hAsync;

	// make sure everyone is ready
	flag = TRUE;
	for(i=1; i<MAX_SLOTS; i++)
		if(g_MPSlots[i]->val1==SLOT_OCCUPIED)
		{
			flag = FALSE;
			break;
		}

	// if everyone not ready, just return
	if(flag==FALSE)
		return MROUTINE_RETURN;

	// everyone was ready
	g_bAllowJoin = FALSE;				// dont allow anyone else to join
	g_dwGameState = GAMESTATE_PLAYING;

	// send start game message
	msg.dwType = STAGEMSG_STARTGAME;
	buf.dwBufferSize = sizeof(STAGEMSG_GENERIC);
	buf.pBufferData = (BYTE *)&msg;
	g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &buf, 1, 0, NULL, &hAsync, 0);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: XStage_AddPlayer
// Desc: Add a player to the MP stage
//-----------------------------------------------------------------------------
void XStage_AddPlayer(WCHAR *pName, DPNID dpnidPlayer)
{
	int slot;
	XMenuItem *mi;
	DPN_BUFFER_DESC buf;
	DPNHANDLE hAsync;

	slot = XStage_FindSlot();
	if(slot!=-1 && g_bAllowJoin)	// if we found a slot & join allowed
	{
		// fill in slot with new player info
		mi = g_MPSlots[slot];
		XMenu_SetItemText(mi, pName);
		mi->color = SLOTCOLOR_OCCUPIED;
		mi->val1 = SLOT_OCCUPIED;
		mi->val2 = dpnidPlayer;

		// send slot data to all players
		XStage_SendSlotData();

		// send slot number to the new player
		STAGEMSG_SLOTINFO msg;
		msg.dwType = STAGEMSG_SLOTNUMBER;
		msg.dwSlot = slot;
		buf.dwBufferSize = sizeof(STAGEMSG_SLOTINFO);
		buf.pBufferData = (BYTE *)&msg;
		g_pDP->SendTo(dpnidPlayer, &buf, 1, 0, NULL, &hAsync, 0);
	}
	else
	{
		XStage_SendReject(dpnidPlayer);
	}
}

//-----------------------------------------------------------------------------
// Name: XStage_MsgHandler
// Desc: Handles messages for mp staging menu
//       Note that the parameter is a message which is different
//       than a regular DPlay message handler
//-----------------------------------------------------------------------------
DWORD XStage_MsgHandler(void *pMsg)
{
	STAGEMSG_SLOTINFO *simsg;
	STAGEMSG_GENERIC *msg;

	msg = (STAGEMSG_GENERIC *)pMsg;

	switch(msg->dwType)
	{
		case STAGEMSG_STARTGAME:
			g_dwGameState = GAMESTATE_PLAYING;
			XMenu_Activate(NULL);				// kill mp stage menu
			break;

		// the following messages:
		//    SLOTOPEN, SLOTCLOSED, SLOTREADY, SLOTOCCUPIED
		// are sent from player to host, then propagated to
		// all other players to indicate slot status
		// 
		case STAGEMSG_SLOTOPEN:
			simsg = (STAGEMSG_SLOTINFO *)msg;
			g_MPSlots[simsg->dwSlot]->color = SLOTCOLOR_OPEN;
			g_MPSlots[simsg->dwSlot]->val1 = SLOT_OPEN;
			XMenu_SetItemText(g_MPSlots[simsg->dwSlot], L"Open");
			if(g_dwConnectStatus==GAME_HOSTING)
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, simsg->dwSlot, STAGEMSG_SLOTOPEN);
			break;

		case STAGEMSG_SLOTCLOSED:
			simsg = (STAGEMSG_SLOTINFO *)msg;
			g_MPSlots[simsg->dwSlot]->color = SLOTCOLOR_CLOSED;
			g_MPSlots[simsg->dwSlot]->val1 = SLOT_CLOSED;
			XMenu_SetItemText(g_MPSlots[simsg->dwSlot], L"Closed");
			if(g_dwConnectStatus==GAME_HOSTING)
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, simsg->dwSlot, STAGEMSG_SLOTCLOSED);
			break;

		case STAGEMSG_SLOTREADY:
			simsg = (STAGEMSG_SLOTINFO *)msg;
			g_MPSlots[simsg->dwSlot]->color = SLOTCOLOR_READY;
			g_MPSlots[simsg->dwSlot]->val1 = SLOT_READY;
			if(g_dwConnectStatus==GAME_HOSTING)
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, simsg->dwSlot, STAGEMSG_SLOTREADY);
			break;

		case STAGEMSG_SLOTOCCUPIED:
			simsg = (STAGEMSG_SLOTINFO *)msg;
			g_MPSlots[simsg->dwSlot]->color = SLOTCOLOR_OCCUPIED;
			g_MPSlots[simsg->dwSlot]->val1 = SLOT_OCCUPIED;
			if(g_dwConnectStatus==GAME_HOSTING)
				XStage_SendSlotStatus(DPNID_ALL_PLAYERS_GROUP, simsg->dwSlot, STAGEMSG_SLOTOCCUPIED);
			break;

		// sent from host to a specific player to indicate
		// which slot we have been assigned
		case STAGEMSG_SLOTNUMBER:
			simsg = (STAGEMSG_SLOTINFO *)msg;
			g_dwLocalSlot = simsg->dwSlot;
			break;

		// update our table with the incoming slot data
		// sent from host to all players to perform a full
		// table update
		case STAGEMSG_SLOTUPDATE:
			if(g_dwConnectStatus!=GAME_HOSTING)
				XStage_SlotUpdate((STAGEMSG_SLOTDATA *)msg);
			break;

		// if we were rejected, disconnect
		case STAGEMSG_REJECT:
			g_dwConnectStatus = GAME_DISCONNECTING;		// flag DPlay disconnect
			g_dwGameState = GAMESTATE_ATTRACT;
			XMenu_Activate(NULL);						// kill mp stage menu
			break;
	}

	return 0;
}


void XStage_DeletePlayer(DPNID dpnid)
{
	XMenuItem *mi;
	DWORD i;

	// only do delete player if we are still staging
	if(g_dwGameState!=GAMESTATE_STAGING)
		return;

	// find this players slot
	for(i=0; i<MAX_SLOTS; i++)
	{
		mi = g_MPSlots[i];

		if(mi->val2==dpnid)
		{
			mi->color = SLOTCOLOR_OPEN;
			mi->val1 = SLOT_OPEN;
			wcscpy(mi->string, L"Open");
		}
	}

	// update everyones slot data
	XStage_SendSlotData();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceconnect\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xsimplepeer\xsimplepeer.cpp ===
//-----------------------------------------------------------------------------
// File: xsimplepeer.cpp
//
// Desc: Simple peer to peer networking sample.
//
// Note: Port choices should be in the range 2302-2400 as these are
//       reserved for DPlay applications.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <assert.h>

#include "xmenu.h"
#include "xtextbox.h"
#include "xdppeer.h"

// UI Stuff
XTextBox *XBox;									// pun intended
DWORD g_dwMenuCommand;
XMenu *g_MainMenu;								// main menu
XMenu *g_NameMenu;								// choose name menu

// dplay message handler
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg);

// GUID & port
GUID g_AppGUID = {0x2ae835d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 }};
DWORD g_dwPort = 2399;							// game port - see comment above
#define PCPORT 6073								// port for PC game search

// multiplayer menu
XMenu *g_MPMenu;								// multiplayer menu
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi);		// init & display MP menu
DWORD Create(DWORD cmd, XMenuItem *mi);			// host a game
DWORD Connect(DWORD cmd, XMenuItem *mi);		// connect to an existing game
DWORD Disconnect(DWORD cmd, XMenuItem *mi);		// disconnect from current game

// game menu
XMenu *g_GameMenu;								// game menu
DWORD FindGames(DWORD cmd, XMenuItem *mi);		// find game to join
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi);	// stop finding games to join
void AddGame(ActiveGame *pGame);				// add an active game to game menu
void DeleteGame(ActiveGame *pGame);				// removes an active game from the game menu

//-----------------------------------------------------------------------------
// App specific Player information 
//-----------------------------------------------------------------------------
#define MAX_PLAYER_NAME 14
struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    WCHAR wstrPlayerName[MAX_PLAYER_NAME];	// Player name
};
#define PLAYER_ADDREF(a)    if(a) a->lRefCount++;
#define PLAYER_RELEASE(a)   if(a) { a->lRefCount--; if(a->lRefCount<=0) delete a; } a = NULL;

HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg);
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg);

//-----------------------------------------------------------------------------
// App specific DirectPlay messages and structures 
//-----------------------------------------------------------------------------
#define GAME_MSGID_WAVE 1

#pragma pack(push, 1)
struct GAMEMSG_GENERIC
{
    DWORD dwType;
};
#pragma pack(pop)

//-----------------------------------------------------------------------------
// help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_A_BUTTON,  XBHELP_PLACEMENT_1, L"Wave to Players"},
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle Help\nMenu Back"},
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_1, L"Menu Activate\nMenu Select"},
};
#define MAX_NORMAL_HELP_CALLOUTS 3

BOOL g_bDrawHelp = FALSE;
DWORD Help(DWORD cmd, XMenuItem *mi);		// help activate menu item

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font for rendering stats and help
    CXBFont m_Font;
    CXBHelp m_Help;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();
	void InitNameMenu();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// Initialize the help system
    if(FAILED(hr = m_Help.Create(m_pd3dDevice, "Gamepad.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// set menu and text box fonts
	XMenu_SetFont(&m_Font);
	XTextBox_SetFont(&m_Font);

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 1000.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &matProj);

	// init the 'choose player name' menu
	InitNameMenu();

	// init the main menu
	g_MainMenu = XMenu_Init(320.0f, 120.0f, 5, 0, NULL);
	XMenu_SetTitle(g_MainMenu, L"Main Menu", 0xffffff00);
	XMenu_AddItem(g_MainMenu, 0, L"SINGLE PLAYER", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"MULTIPLAYER", DoMPMenu);
	XMenu_AddItem(g_MainMenu, MITEM_SEPARATOR, NULL, NULL);
	XMenu_AddItem(g_MainMenu, 0, L"OPTIONS", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"HELP", Help);

	// init a textbox
	XBox = XTextBox_Init(64, 480.0f-50.0f-(float)m_Font.GetFontHeight()*5.0f,
						640.0f-128.0f, 4, 0);
	XBox->expiretime = 3000;		// keep messages up for 3 seconds
	XBox->topcolor = 0xff000000;
	XBox->bottomcolor = 0xff0000c0;
	XTextBox_AddItem(XBox, L"Welcome to XSimplePeer.");

	// init dplay
	XDPInit(DPMsgHandler);

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	XMenu_Delete(g_MainMenu);
	if(g_MPMenu)
		XMenu_Delete(g_MPMenu);

	// shut down dplay
	XDPShutdown();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// do DPlay processing
	XDPDoWork(0);

	// process menu input
	if(!g_bDrawHelp)
	{
		g_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
		if(g_dwMenuCommand==MENU_ACTIVATE)
			XMenu_Activate(g_MainMenu);
		if(XMenu_IsActive())
			return S_OK;
	}

	// toggle help menu
	if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
		g_bDrawHelp = !g_bDrawHelp;
	if(g_bDrawHelp)
		return S_OK;

	// process game input
	if(XDPIsConnected())
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
		{
			// Send a message to all of the players
			GAMEMSG_GENERIC msgWave;
			msgWave.dwType = GAME_MSGID_WAVE;

			DPN_BUFFER_DESC bufferDesc;
			bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
			bufferDesc.pBufferData = (BYTE *)&msgWave;

			DPNHANDLE hAsync;
			g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
						   0, NULL, &hAsync, DPNSEND_NOLOOPBACK);

			XTextBox_AddItem(XBox, L"You waved to everyone.");
		}

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	WCHAR s[80];

    // clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0, 1.0f, 0L );

	// process the menu
	XMenu_Routine(g_dwMenuCommand);
	XTextBox_Display(XBox);

	// show game title
    m_Font.DrawText(64, 50, 0xffffffff, L"SIMPLE PEER");
    m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

	// show our current status
	switch(g_dwConnectStatus)
	{
		case GAME_HOSTING:
			m_Font.DrawText(64, 70, 0xff00ff00, L"HOSTING");
			break;
		case GAME_ENUMERATING:
			m_Font.DrawText(64, 70, 0xffffff00, L"ENUMERATING");
			break;
		case GAME_CONNECTED:
			m_Font.DrawText(64, 70, 0xff00ff00, L"CONNECTED");
			break;
		case GAME_NOTCONNECTED:
			m_Font.DrawText(64, 70, 0xffff0000, L"NOT CONNECTED");
			break;
		case GAME_CONNECTING:
			m_Font.DrawText(64, 70, 0xffffff00, L"CONNECTING");
			break;
	}

	// show # of players
	if(XDPIsConnected())
	{
		swprintf(s, L"%d PLAYERS", g_dwNumPlayers);
		m_Font.DrawText(640-64, 70, 0xffffffff, s, XBFONT_RIGHT);
	}		

	// draw help
	if(g_bDrawHelp)
		m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Help
// Desc: Activates help screen from main menu.
//-----------------------------------------------------------------------------
DWORD Help(DWORD cmd, XMenuItem *mi)
{
	g_bDrawHelp = TRUE;
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: GotName and InitNameMenu
// Desc: Creates a menu of names to choose from. Since we dont have a
//       virtual keyboard, this lets us have clients with different names.
//       Also assembles the host session name to be "playername - XSimplePeer"
//-----------------------------------------------------------------------------
DWORD GotName(DWORD cmd, XMenuItem *mi)
{
	// set player name
	wcscpy(g_wszXDPPlayerName, mi->string);

	// set session name
	wcscpy(g_wszXDPSessionName, g_wszXDPPlayerName);
	wcscat(g_wszXDPSessionName, L" - XSimplePeer");

	XMenu_Delete(g_NameMenu);
	XMenu_Activate(g_MainMenu);

	return MROUTINE_RETURN;
}

void CXBoxSample::InitNameMenu()
{
	// init the choose player name menu
	g_NameMenu = XMenu_Init(320.0f, 120.0f, 4, MENU_NOBACK, NULL);
	XMenu_SetTitle(g_NameMenu, L"Choose Name", 0xffffff00);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Maximus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Minimus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Animus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Haxor", GotName);
	XMenu_Activate(g_NameMenu);
}

//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
    DPNMSG_RECEIVE *pReceiveMsg;
	DPNMSG_CREATE_PLAYER *pCreatePlayerMsg;
	DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg;
	GAMEMSG_GENERIC *msg;

	APP_PLAYER_INFO *pPlayerInfo;
	ActiveGame *pGame;
	WCHAR s[80];

    switch(dwMsgType)
    {
		// handle adding and deleting games
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			pGame = XDPAddGame((DPNMSG_ENUM_HOSTS_RESPONSE *)pMsg);
			AddGame(pGame);
			break;
		case DPPEER_MSGID_DELETE_GAME:
			DeleteGame((ActiveGame *)pMsg);
			break;

		// handle player messages
        case DPN_MSGID_CREATE_PLAYER:
			pCreatePlayerMsg = (DPNMSG_CREATE_PLAYER *)pMsg;
			CreatePlayer(pCreatePlayerMsg);
			pPlayerInfo = (APP_PLAYER_INFO *)pCreatePlayerMsg->pvPlayerContext;
			swprintf(s, L"%s joined the game.", pPlayerInfo->wstrPlayerName);
			XTextBox_AddItem(XBox, s);
			break;
        case DPN_MSGID_DESTROY_PLAYER:
			pDestroyPlayerMsg = (DPNMSG_DESTROY_PLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
			swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
			DeletePlayer(pDestroyPlayerMsg);
			XTextBox_AddItem(XBox, s);
			break;

		// handle incoming game messages
        case DPN_MSGID_RECEIVE:
		    pReceiveMsg = (PDPNMSG_RECEIVE)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pReceiveMsg->pvPlayerContext;
            msg = (GAMEMSG_GENERIC *)pReceiveMsg->pReceiveData;
            if(msg->dwType == GAME_MSGID_WAVE)
			{
				swprintf(s, L"%s waved to you.", pPlayerInfo->wstrPlayerName);
				XTextBox_AddItem(XBox, s);
			}
			break;

		default:
			break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DoMPMenu
// Desc: Builds multiplayer menu
//-----------------------------------------------------------------------------
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi)
{
	XMenuItem *mitem;

	if(g_MPMenu)
		delete g_MPMenu;

	g_MPMenu = XMenu_Init(320.0f, 120.0f, 4, 0, NULL);
	XMenu_SetTitle(g_MPMenu, L"Multiplayer", 0xffffff00);
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"CREATE GAME", Create);
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR XBOX GAMES", FindGames);
	mitem->val1 = g_dwPort;
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR PC GAMES", FindGames);
	mitem->val1 = PCPORT;
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"DISCONNECT FROM GAME", Disconnect);

	XMenu_Activate(g_MPMenu);

	return MROUTINE_RETURN;
}


//-----------------------------------------------------------------------------
// Name: Create
// Desc: Host a game
//-----------------------------------------------------------------------------
DWORD Create(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before creating a new game.");
		return MROUTINE_DIE;
	}

	// create the game
	XDPCreate(g_dwPort, &g_AppGUID, 6, 0);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: Disconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
DWORD Disconnect(DWORD cmd, XMenuItem *mi)
{
	// dont try to disconnect if we are not in a game
	if(!XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"You are not connected to a game.");
		return MROUTINE_DIE;
	}

	if(g_dwConnectStatus==GAME_HOSTING)
		XDPTerminate();
	else
		XDPDisconnect();

	XTextBox_AddItem(XBox, L"Disconnected from the game.");

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: FindGames
// Desc: Finds active games on the network.
//-----------------------------------------------------------------------------
DWORD FindGames(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before searching for new games.");
		return MROUTINE_DIE;
	}

	// init game menu
	if(g_GameMenu)
		XMenu_Delete(g_GameMenu);

	g_GameMenu = XMenu_Init(320.0f, 140.0f, 20, 0, AbortFindGames);
	XMenu_SetTitle(g_GameMenu, L"Games", 0xffffff00);
	g_GameMenu->w = 440.0f;
	XMenu_SetMaxShow(g_GameMenu, 6);

	XMenu_AddItem(g_GameMenu, 0, L"ABORT", NULL);
	XMenu_Activate(g_GameMenu);

	// search for game on port specified in mi->val1
	// this is so we can find games on g_dwPort (other xboxes) and
	// PCPORT (pc's running dx8 dplay)
	// normally you would use g_dwPort value here
	XDPEnumHosts(mi->val1, &g_AppGUID);

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: AbortFindGames
// Desc: Aborts finding active games on the network.
//-----------------------------------------------------------------------------
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi)
{
	XDPCancelEnumHosts();
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: AddGame
// Desc: Adds to the menu of currently active games.
//-----------------------------------------------------------------------------
void AddGame(ActiveGame *pGame)
{
	XMenuItem *mi;
	const DPN_APPLICATION_DESC *pApp;
	WCHAR name[80], s[80];
	DWORD i;

	assert(pGame);

	pApp = &pGame->AppDesc;

	// see if this item already in the menu
	mi = NULL;
	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			mi = &g_GameMenu->items[i];
			break;
		}

	// build menu item string
	wcscpy(name, pApp->pwszSessionName);
	swprintf(s, L"%s (%d, %d/%d)", name, pGame->dwPing, pApp->dwCurrentPlayers, pApp->dwMaxPlayers);

	// add new item to menu or update existing item
	if(!mi)
	{
		mi = XMenu_AddItem(g_GameMenu, MITEM_ROUTINE, s, Connect);
		mi->val1 = (DWORD)pGame;		// save pointer to this game
	}
	else
		XMenu_SetItemText(mi, s);
}

//-----------------------------------------------------------------------------
// Name: DeleteGame
// Desc: Deletes from the menu of currently active games.
//-----------------------------------------------------------------------------
void DeleteGame(ActiveGame *pGame)
{
	DWORD i;

	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			XMenu_DeleteItem(&g_GameMenu->items[i]);
			break;
		}
}

//-----------------------------------------------------------------------------
// Name: Connect
// Desc: Connect to an existing game
//-----------------------------------------------------------------------------
DWORD Connect(DWORD cmd, XMenuItem *mi)
{
	ActiveGame *pGame;

	// dont try to connect if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before connecting to a new game.");
		return MROUTINE_DIE;
	}

	pGame = (ActiveGame *)mi->val1;			// get pointer to desired game
	XDPConnect(&pGame->AppDesc, pGame->pHostAddr, pGame->pDevAddr);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: CreatePlayer
// Desc: Add a player to the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_CREATE_PLAYER
//-----------------------------------------------------------------------------
HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg)
{
    HRESULT hr;
    DWORD dwSize = 0;
    DPN_PLAYER_INFO *pdpPlayerInfo = NULL;

    // Get the peer info and extract its name
    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr) && hr!=DPNERR_BUFFERTOOSMALL)
        return hr;

    pdpPlayerInfo = (DPN_PLAYER_INFO *) new BYTE[dwSize];
    ZeroMemory(pdpPlayerInfo, dwSize);
    pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr))
        return hr;

    // Create a new and fill in a APP_PLAYER_INFO
    APP_PLAYER_INFO *pPlayerInfo = new APP_PLAYER_INFO;
    ZeroMemory(pPlayerInfo, sizeof(APP_PLAYER_INFO));
    pPlayerInfo->lRefCount = 1;				   
    pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

	// copy players name
	wcsncpy(pPlayerInfo->wstrPlayerName, pdpPlayerInfo->pwszName, MAX_PLAYER_NAME);

	// check for local player dpnid
	if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL)
		g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

	// check for host player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_HOST)
        g_dpnidHost = pPlayerInfo->dpnidPlayer;

    // Tell DirectPlay to store this pPlayerInfo pointer in the pvPlayerContext.
    pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

	// increment number of players
	g_dwNumPlayers++;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: DeletePlayer
// Desc: Deletes a player from the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_DELETE_PLAYER
//-----------------------------------------------------------------------------
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg)
{
    APP_PLAYER_INFO *pPlayerInfo;

	// get a pointer to the context of the player being deleted
	pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;

	// release player info
	PLAYER_RELEASE(pPlayerInfo);  

	// decrement # of players
	g_dwNumPlayers--;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xstagedpeer\xstagedpeer.cpp ===
//-----------------------------------------------------------------------------
// File: xstagedpeer.cpp
//
// Desc: Peer to peer networking sample that demonstrates staging.
//
// Note: Port choices should be in the range 2302-2400 as these are
//       reserved for DPlay applications.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <assert.h>

#include "xdppeer.h"
#include "xmenu.h"
#include "xtextbox.h"
#include "xstagedpeer.h"
#include "xstage.h"

// UI Stuff
XTextBox *XBox;									// pun intended
DWORD g_dwMenuCommand;
XMenu *g_MainMenu;								// main menu
XMenu *g_NameMenu;								// choose name menu

// dplay message handler
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg);

//  GUID, & port
GUID g_AppGUID = {0x2d6d17ec, 0x2e22, 0x499a, {0xb4, 0xf0, 0x7d, 0x40, 0x88, 0x64, 0xe5, 0xc8}};
DWORD g_dwPort = 2399;							// game port - see note above
#define PCPORT 6073								// port for PC game search

// multiplayer menu
XMenu *g_MPMenu;								// multiplayer menu
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi);		// init & display MP menu
DWORD Create(DWORD cmd, XMenuItem *mi);			// host a game
DWORD Connect(DWORD cmd, XMenuItem *mi);		// connect to an existing game
DWORD Disconnect(DWORD cmd, XMenuItem *mi);		// disconnect from current game

// game menu
XMenu *g_GameMenu;								// game menu
DWORD FindGames(DWORD cmd, XMenuItem *mi);		// find game to join
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi);	// stop finding games to join
void AddGame(ActiveGame *pGame);				// add an active game to game menu
void DeleteGame(ActiveGame *pGame);				// removes an active game from the game menu

// game state
DWORD g_dwGameState = GAMESTATE_ATTRACT;

//-----------------------------------------------------------------------------
// App specific Player information 
//-----------------------------------------------------------------------------
HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg);
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg);

//-----------------------------------------------------------------------------
// App specific DirectPlay messages and structures 
//-----------------------------------------------------------------------------
#define GAME_MSGID_WAVE 1

#pragma pack(push, 1)
struct GAMEMSG_GENERIC
{
    DWORD dwType;
};
#pragma pack(pop)

//-----------------------------------------------------------------------------
// help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_A_BUTTON,  XBHELP_PLACEMENT_1, L"Wave to Players"},
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle Help\nMenu Back"},
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_1, L"Menu Activate\nMenu Select"},
};
#define MAX_NORMAL_HELP_CALLOUTS 3

BOOL g_bDrawHelp = FALSE;
DWORD Help(DWORD cmd, XMenuItem *mi);		// help activate menu item

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font for rendering stats and help
    CXBFont m_Font;
    CXBHelp m_Help;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();
	void InitNameMenu();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// Initialize the help system
    if(FAILED(hr = m_Help.Create(m_pd3dDevice, "Gamepad.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// set menu and text box fonts
	XMenu_SetFont(&m_Font);
	XTextBox_SetFont(&m_Font);

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// init the 'choose player name' menu
	InitNameMenu();

	// init the main menu
	g_MainMenu = XMenu_Init(320.0f, 120.0f, 5, 0, NULL);
	XMenu_SetTitle(g_MainMenu, L"Main Menu", 0xffffff00);
	XMenu_AddItem(g_MainMenu, 0, L"SINGLE PLAYER", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"MULTIPLAYER", DoMPMenu);
	XMenu_AddItem(g_MainMenu, MITEM_SEPARATOR, NULL, NULL);
	XMenu_AddItem(g_MainMenu, 0, L"OPTIONS", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"HELP", Help);

	// init a textbox
	XBox = XTextBox_Init(64, 480.0f-50.0f-(float)m_Font.GetFontHeight()*5.0f,
						640.0f-128.0f, 4, 0);
	XBox->expiretime = 3000;		// keep messages up for 3 seconds
	XBox->topcolor = 0xff000000;
	XBox->bottomcolor = 0xff0000c0;
	XTextBox_AddItem(XBox, L"Welcome to XStagedPeer.");

	// init dplay
	XDPInit(DPMsgHandler);

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	XMenu_Delete(g_MainMenu);
	if(g_MPMenu)
		XMenu_Delete(g_MPMenu);

	// shut down dplay
	XDPShutdown();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// do DPlay processing
	XDPDoWork(0);

	// process menu input
	if(!g_bDrawHelp)
	{
		g_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
		if(g_dwMenuCommand==MENU_ACTIVATE)
			XMenu_Activate(g_MainMenu);
		if(XMenu_IsActive())
			return S_OK;
	}

	// toggle help menu
	if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
		g_bDrawHelp = !g_bDrawHelp;
	if(g_bDrawHelp)
		return S_OK;

	// process game messages
	if(XDPIsConnected() && g_dwGameState==GAMESTATE_PLAYING)
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
		{
			// Send a message to all of the players
			GAMEMSG_GENERIC msgWave;
			msgWave.dwType = GAME_MSGID_WAVE;

			DPN_BUFFER_DESC bufferDesc;
			bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
			bufferDesc.pBufferData = (BYTE *)&msgWave;

			DPNHANDLE hAsync;
			g_pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
						   0, NULL, &hAsync, DPNSEND_NOLOOPBACK);

			XTextBox_AddItem(XBox, L"You waved to everyone.");
		}

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	WCHAR s[80];

    // clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0, 1.0f, 0L );

	// process the menu
	XMenu_Routine(g_dwMenuCommand);

	// display our textbox if we're not in the staging menu
	if(g_dwGameState != GAMESTATE_STAGING)
		XTextBox_Display(XBox);

	// show game title
    m_Font.DrawText(64, 50, 0xffffffff, L"STAGED PEER");
    m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

	// show our current status
	switch(g_dwConnectStatus)
	{
		case GAME_HOSTING:
			m_Font.DrawText(64, 70, 0xff00ff00, L"HOSTING");
			break;
		case GAME_ENUMERATING:
			m_Font.DrawText(64, 70, 0xffffff00, L"ENUMERATING");
			break;
		case GAME_CONNECTED:
			m_Font.DrawText(64, 70, 0xff00ff00, L"CONNECTED");
			break;
		case GAME_NOTCONNECTED:
			m_Font.DrawText(64, 70, 0xffff0000, L"NOT CONNECTED");
			break;
		case GAME_DISCONNECTING:
			m_Font.DrawText(64, 70, 0xffffff00, L"DISCONNECTING");
			break;
		case GAME_CONNECTING:
			m_Font.DrawText(64, 70, 0xffffff00, L"CONNECTING");
			break;
	}
	if(XDPIsConnected())
	{
		swprintf(s, L"%d PLAYERS", g_dwNumPlayers);
		m_Font.DrawText(640-64, 70, 0xffffffff, s, XBFONT_RIGHT);
	}		

	// draw help
	if(g_bDrawHelp)
		m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Help
// Desc: Activates help screen from main menu.
//-----------------------------------------------------------------------------
DWORD Help(DWORD cmd, XMenuItem *mi)
{
	g_bDrawHelp = TRUE;
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: GotName and InitNameMenu
// Desc: Creates a menu of names to choose from. Since we dont have a
//       virtual keyboard, this lets us have clients with different names.
//       Also assembles the host session name to be "playername - XSimplePeer"
//-----------------------------------------------------------------------------
DWORD GotName(DWORD cmd, XMenuItem *mi)
{
	// set player name
	wcscpy(g_wszXDPPlayerName, (WCHAR *)mi->string);

	// set session name
	wcscpy(g_wszXDPSessionName, g_wszXDPPlayerName);
	wcscat(g_wszXDPSessionName, L" - XStagedPeer");

	XMenu_Delete(g_NameMenu);
	XMenu_Activate(g_MainMenu);

	return MROUTINE_RETURN;
}

void CXBoxSample::InitNameMenu()
{
	// init the choose player name menu
	g_NameMenu = XMenu_Init(320.0f, 120.0f, 4, MENU_NOBACK, NULL);
	XMenu_SetTitle(g_NameMenu, L"Choose Name", 0xffffff00);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Maximus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Minimus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Animus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Haxor", GotName);
	XMenu_Activate(g_NameMenu);
}

//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
    DPNMSG_RECEIVE *pReceiveMsg;
	DPNMSG_CREATE_PLAYER *pCreatePlayerMsg;
	DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg;
	GAMEMSG_GENERIC *msg;

	APP_PLAYER_INFO *pPlayerInfo;
	ActiveGame *pGame;
	WCHAR s[80];

    switch(dwMsgType)
    {
		// check if the host bailed on us
		case DPN_MSGID_TERMINATE_SESSION:
			if(g_dwGameState==GAMESTATE_STAGING)		// if we were staging, nuke the menu
				XMenu_Activate(NULL);
			g_dwGameState = GAMESTATE_ATTRACT;			// return us to attract mode
			g_dwConnectStatus = GAME_DISCONNECTING;		// flag dplay disconnect
			break;

		// handle adding and deleting games
        case DPN_MSGID_ENUM_HOSTS_QUERY:
			if(g_dwGameState==GAMESTATE_PLAYING)		// if we are playing already
				return E_FAIL;							// dont respond to the enum
			break;
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			pGame = XDPAddGame((DPNMSG_ENUM_HOSTS_RESPONSE *)pMsg);
			AddGame(pGame);
			break;
		case DPPEER_MSGID_DELETE_GAME:
			DeleteGame((ActiveGame *)pMsg);
			break;

		// handle player messages
        case DPN_MSGID_CREATE_PLAYER:
			pCreatePlayerMsg = (DPNMSG_CREATE_PLAYER *)pMsg;
			CreatePlayer(pCreatePlayerMsg);
			pPlayerInfo = (APP_PLAYER_INFO *)pCreatePlayerMsg->pvPlayerContext;
			swprintf(s, L"%s joined the game.", pPlayerInfo->wstrPlayerName);
			XTextBox_AddItem(XBox, s);
			break;
        case DPN_MSGID_DESTROY_PLAYER:
			pDestroyPlayerMsg = (DPNMSG_DESTROY_PLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
			swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
			DeletePlayer(pDestroyPlayerMsg);
			XTextBox_AddItem(XBox, s);
			break;

		// handle incoming game messages
        case DPN_MSGID_RECEIVE:
		    pReceiveMsg = (PDPNMSG_RECEIVE)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pReceiveMsg->pvPlayerContext;
            msg = (GAMEMSG_GENERIC *)pReceiveMsg->pReceiveData;

			switch(msg->dwType)
			{
				// actual game messages
				case GAME_MSGID_WAVE:
					if(g_dwGameState==GAMESTATE_PLAYING)
					{
						swprintf(s, L"%s waved to you.", pPlayerInfo->wstrPlayerName);
						XTextBox_AddItem(XBox, s);
					}
					break;

				default:
					XStage_MsgHandler((void *)msg);
					break;
			}
			break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DoMPMenu
// Desc: Builds multiplayer menu
//-----------------------------------------------------------------------------
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi)
{
	XMenuItem *mitem;

	if(g_MPMenu)
		delete g_MPMenu;

	g_MPMenu = XMenu_Init(320.0f, 120.0f, 4, 0, NULL);
	XMenu_SetTitle(g_MPMenu, L"Multiplayer", 0xffffff00);
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"CREATE GAME", Create);
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR XBOX GAMES", FindGames);
	mitem->val1 = g_dwPort;
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR PC GAMES", FindGames);
	mitem->val1 = PCPORT;
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"DISCONNECT FROM GAME", Disconnect);

	XMenu_Activate(g_MPMenu);

	return MROUTINE_RETURN;
}


//-----------------------------------------------------------------------------
// Name: Create
// Desc: Host a game
//-----------------------------------------------------------------------------
DWORD Create(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before creating a new game.");
		return MROUTINE_DIE;
	}

	// build the staging menu
	XStage_DoMPStage(g_wszXDPPlayerName);

	// create the game
	XDPCreate(g_dwPort, &g_AppGUID, 6, 0);

	return MROUTINE_RETURN;					// keep mpstage menu alive
}

//-----------------------------------------------------------------------------
// Name: Disconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
DWORD Disconnect(DWORD cmd, XMenuItem *mi)
{
	// dont try to disconnect if we are not in a game
	if(!XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"You are not connected to a game.");
		return MROUTINE_DIE;
	}

	XDPDisconnect();
	XTextBox_AddItem(XBox, L"Disconnected from the game.");
	g_dwGameState = GAMESTATE_ATTRACT;

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: FindGames
// Desc: Finds active games on the network.
//-----------------------------------------------------------------------------
DWORD FindGames(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before searching for new games.");
		return MROUTINE_DIE;
	}

	// init game menu
	if(g_GameMenu)
		XMenu_Delete(g_GameMenu);

	g_GameMenu = XMenu_Init(320.0f, 140.0f, 20, 0, AbortFindGames);
	XMenu_SetTitle(g_GameMenu, L"Games", 0xffffff00);
	g_GameMenu->w = 440.0f;
	XMenu_SetMaxShow(g_GameMenu, 6);

	XMenu_AddItem(g_GameMenu, 0, L"ABORT", NULL);
	XMenu_Activate(g_GameMenu);

	// search for game on port specified in mi->val1
	// this is so we can find games on g_dwPort (other xboxes) and
	// PCPORT (pc's running dx8 dplay)
	// normally you would use g_dwPort value here
	XDPEnumHosts(mi->val1, &g_AppGUID);

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: AbortFindGames
// Desc: Aborts finding active games on the network.
//-----------------------------------------------------------------------------
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi)
{
	XDPCancelEnumHosts();
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: AddGame
// Desc: Adds to the menu of currently active games.
//-----------------------------------------------------------------------------
void AddGame(ActiveGame *pGame)
{
	XMenuItem *mi;
	const DPN_APPLICATION_DESC *pApp;
	WCHAR name[80], s[80];
	DWORD i;

	assert(pGame);

	pApp = &pGame->AppDesc;

	// see if this item already in the menu
	mi = NULL;
	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			mi = &g_GameMenu->items[i];
			break;
		}

	// build menu item string
	wcscpy(name, pApp->pwszSessionName);

	swprintf(s, L"%s (%d, %d/%d)", name, pGame->dwPing, pApp->dwCurrentPlayers, pApp->dwMaxPlayers);

	// add new item to menu or update existing item
	if(!mi)
	{
		mi = XMenu_AddItem(g_GameMenu, MITEM_ROUTINE, s, Connect);
		mi->val1 = (DWORD)pGame;		// save pointer to this game
	}
	else
		XMenu_SetItemText(mi, s);
}

//-----------------------------------------------------------------------------
// Name: DeleteGame
// Desc: Deletes from the menu of currently active games.
//-----------------------------------------------------------------------------
void DeleteGame(ActiveGame *pGame)
{
	DWORD i;

	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			XMenu_DeleteItem(&g_GameMenu->items[i]);
			break;
		}
}

//-----------------------------------------------------------------------------
// Name: Connect
// Desc: Connect to an existing game
//-----------------------------------------------------------------------------
DWORD Connect(DWORD cmd, XMenuItem *mi)
{
	ActiveGame *pGame;

	// dont try to connect if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before connecting to a new game.");
		return MROUTINE_DIE;
	}

	// init the mp staging menu
	XStage_DoMPStage(NULL);

	pGame = (ActiveGame *)mi->val1;			// get pointer to desired game
	XDPConnect(&pGame->AppDesc, pGame->pHostAddr, pGame->pDevAddr);

	return MROUTINE_RETURN;					// keep mpstage menu alive
}

//-----------------------------------------------------------------------------
// Name: CreatePlayer
// Desc: Add a player to the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_CREATE_PLAYER
//-----------------------------------------------------------------------------
HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg)
{
    HRESULT hr;
    DWORD dwSize = 0;
    DPN_PLAYER_INFO *pdpPlayerInfo = NULL;

    // Get the peer info and extract its name
    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr) && hr!=DPNERR_BUFFERTOOSMALL)
        return hr;

    pdpPlayerInfo = (DPN_PLAYER_INFO *) new BYTE[dwSize];
    ZeroMemory(pdpPlayerInfo, dwSize);
    pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr))
        return hr;

    // Create a new and fill in a APP_PLAYER_INFO
    APP_PLAYER_INFO *pPlayerInfo = new APP_PLAYER_INFO;
    ZeroMemory(pPlayerInfo, sizeof(APP_PLAYER_INFO));
    pPlayerInfo->lRefCount = 1;				   
    pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

	// copy players name
	wcsncpy(pPlayerInfo->wstrPlayerName, pdpPlayerInfo->pwszName, MAX_PLAYER_NAME);

	// check for local player dpnid
	if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL)
		g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

	// check for host player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_HOST)
        g_dpnidHost = pPlayerInfo->dpnidPlayer;

    // Tell DirectPlay to store this pPlayerInfo pointer in the pvPlayerContext.
    pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

	// increment number of players
	g_dwNumPlayers++;

	// if we are host, add player to mp staging menu
	if(g_dwConnectStatus==GAME_HOSTING && !(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL))
		XStage_AddPlayer(pPlayerInfo->wstrPlayerName, pPlayerInfo->dpnidPlayer);

	return hr;
}

//-----------------------------------------------------------------------------
// Name: DeletePlayer
// Desc: Deletes a player from the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_DELETE_PLAYER
//-----------------------------------------------------------------------------
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg)
{
    APP_PLAYER_INFO *pPlayerInfo;

	// get a pointer to the context of the player being deleted
	pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;

	// remove from multiplayer stage
	XStage_DeletePlayer(pPlayerInfo->dpnidPlayer);

	// release player info
	PLAYER_RELEASE(pPlayerInfo);  

	// decrement # of players
	g_dwNumPlayers--;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xstagedpeer\xstagedpeer.h ===
#ifndef __XSTAGEDPEER_H
#define __XSTAGEDPEER_H

// game state
#define GAMESTATE_ATTRACT 0						// in attract mode (not playing)
#define GAMESTATE_STAGING 1						// game is in multiplayer stage
#define GAMESTATE_PLAYING 2						// game is active
extern DWORD g_dwGameState;

// app specific Player information 
#define MAX_PLAYER_NAME 14
struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    WCHAR wstrPlayerName[MAX_PLAYER_NAME];	// Player name
};
#define PLAYER_ADDREF(a)    if(a) a->lRefCount++;
#define PLAYER_RELEASE(a)   if(a) { a->lRefCount--; if(a->lRefCount<=0) delete a; } a = NULL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceeffect\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceconnect\xvoiceconnect.cpp ===
//-----------------------------------------------------------------------------
// File: xvoiceconnect.cpp
//
// Desc: DirectPlay Voice sample
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <assert.h>

#include "xmenu.h"
#include "xtextbox.h"
#include "xdppeer.h"
#include "xdpvoice.h"


//-----------------------------------------------------------------------------
// UI Stuff
//-----------------------------------------------------------------------------
XTextBox *XBox;									// pun intended
DWORD g_dwMenuCommand;
XMenu *g_MainMenu;								// main menu
XMenu *g_NameMenu;								// choose name menu


//-----------------------------------------------------------------------------
// player status information
//-----------------------------------------------------------------------------
#define VSTATUS_EMPTY		0					// slot is empty
#define VSTATUS_OCCUPIED	1					// slot is occupied
#define VSTATUS_TALKING		2					// slot is talking

#define MAX_STATUS			8					// max # of players in status
XTextBox *StatusBox;							// player status box (talking/not)
XTextBoxItem *g_pStatus[MAX_STATUS];			// status box items

void UpdateSlot(DWORD slot, WCHAR *tstrName);	// update status line


//-----------------------------------------------------------------------------
// dplay message handler
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg);


//-----------------------------------------------------------------------------
// GUID & port
//-----------------------------------------------------------------------------
GUID g_AppGUID = { 0xfcd4761e, 0x2b9c, 0x4478, { 0xb7, 0xea, 0xd9, 0xe1, 0x8e, 0x6e, 0x2a, 0xac } };
DWORD g_dwPort = 2399;							// game port
#define PCPORT 6073								// port for PC game search


//-----------------------------------------------------------------------------
// multiplayer menu
//-----------------------------------------------------------------------------
XMenu *g_MPMenu;								// multiplayer menu
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi);		// init & display MP menu
DWORD Create(DWORD cmd, XMenuItem *mi);			// host a game
DWORD Connect(DWORD cmd, XMenuItem *mi);		// connect to an existing game
DWORD Disconnect(DWORD cmd, XMenuItem *mi);		// disconnect from current game


//-----------------------------------------------------------------------------
// game menu
//-----------------------------------------------------------------------------
XMenu *g_GameMenu;								// game menu
DWORD FindGames(DWORD cmd, XMenuItem *mi);		// find game to join
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi);	// stop finding games to join
void AddGame(ActiveGame *pGame);				// add an active game to game menu
void DeleteGame(ActiveGame *pGame);				// removes an active game from the game menu


//-----------------------------------------------------------------------------
// App specific Player information 
//-----------------------------------------------------------------------------
#define MAX_PLAYER_NAME 14
struct APP_PLAYER_INFO
{
    LONG  lRefCount;							// Ref count so we can cleanup when all threads 
												// are done w/ this object
    DPNID dpnidPlayer;							// DPNID of player
    WCHAR wstrPlayerName[MAX_PLAYER_NAME];		// Player name
	DWORD dwIndex;								// index in textbox
};

#define PLAYER_ADDREF(a)    if(a) a->lRefCount++;
#define PLAYER_RELEASE(a)   if(a) { a->lRefCount--; if(a->lRefCount<=0) delete a; } a = NULL;

HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg);
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg);


//-----------------------------------------------------------------------------
// help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle Help\nMenu Back"},
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_1, L"Menu Activate\nMenu Select"},
};
#define MAX_NORMAL_HELP_CALLOUTS 2

BOOL g_bDrawHelp = FALSE;
DWORD Help(DWORD cmd, XMenuItem *mi);		// help activate menu item


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font for rendering stats and help
    CXBFont m_Font;
    CXBHelp m_Help;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();
	void InitNameMenu();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// Initialize the help system
    if(FAILED(hr = m_Help.Create(m_pd3dDevice, "Gamepad.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// set menu and text box fonts
	XMenu_SetFont(&m_Font);
	XTextBox_SetFont(&m_Font);

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 10000.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &matProj);

	// init the 'choose player name' menu
	InitNameMenu();

	// init a menu
	g_MainMenu = XMenu_Init(320.0f, 120.0f, 5, 0, NULL);
	XMenu_SetTitle(g_MainMenu, L"Main Menu", 0xffffff00);
	XMenu_AddItem(g_MainMenu, 0, L"SINGLE PLAYER", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"MULTIPLAYER", DoMPMenu);
	XMenu_AddItem(g_MainMenu, MITEM_SEPARATOR, NULL, NULL);
	XMenu_AddItem(g_MainMenu, 0, L"OPTIONS", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"HELP", Help);

	// init a textbox
	XBox = XTextBox_Init(64, 480.0f-50.0f-(float)m_Font.GetFontHeight()*4.0f,
						640.0f-128.0f, 3, TBOX_POPUP);
	XBox->expiretime = 2000;		// keep messages up for 2 seconds
	XTextBox_AddItem(XBox, L"Welcome to XVoiceConnect.");

	// init status textbox
	StatusBox = XTextBox_Init(128.0f, 110.0f, 640.0f-256.0f, 8, 0);
	StatusBox->topcolor = 0xff000000;
	StatusBox->bottomcolor = 0xffc0c000;
	for(DWORD i=0; i<8; i++)
	{
		g_pStatus[i] = XTextBox_AddItem(StatusBox, L" ");
		g_pStatus[i]->val1 = VSTATUS_EMPTY;
	}

	// init dplay & dvoice
	XDPInit(DPMsgHandler);
	XDVInit(DPMsgHandler);

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	XMenu_Delete(g_MainMenu);
	if(g_MPMenu)
		XMenu_Delete(g_MPMenu);

	// shut down dplay
	XDPShutdown();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// do our dplay and dvoice work
	XDPDoWork(0);
	XDVDoWork();

	// process menu input
	if(!g_bDrawHelp)
	{
		g_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
		if(g_dwMenuCommand==MENU_ACTIVATE)
			XMenu_Activate(g_MainMenu);
		if(XMenu_IsActive())
			return S_OK;
	}

	// toggle help menu
	if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
		g_bDrawHelp = !g_bDrawHelp;
	if(g_bDrawHelp)
		return S_OK;

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	WCHAR s[80];

    // clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0, 1.0f, 0L );

	// process the menu
	XMenu_Routine(g_dwMenuCommand);
	XTextBox_Display(XBox);

	if(!XMenu_IsActive())
		XTextBox_Display(StatusBox);

	// show game title
    m_Font.DrawText(64, 50, 0xffffffff, L"VOICE CONNECT");
    m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

	// show our current status
	switch(g_dwConnectStatus)
	{
		case GAME_HOSTING:
			m_Font.DrawText(64, 70, 0xff00ff00, L"HOSTING");
			break;
		case GAME_ENUMERATING:
			m_Font.DrawText(64, 70, 0xffffff00, L"ENUMERATING");
			break;
		case GAME_CONNECTED:
			m_Font.DrawText(64, 70, 0xff00ff00, L"CONNECTED");
			break;
		case GAME_NOTCONNECTED:
			m_Font.DrawText(64, 70, 0xffff0000, L"NOT CONNECTED");
			break;
		case GAME_CONNECTING:
			m_Font.DrawText(64, 70, 0xffffff00, L"CONNECTING");
			break;
	}

	// show # of players
	if(XDPIsConnected())
	{
		swprintf(s, L"%d PLAYERS", g_dwNumPlayers);
		m_Font.DrawText(640-64, 70, 0xffffffff, s, XBFONT_RIGHT);
	}		

	// draw help
	if(g_bDrawHelp)
		m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Help
// Desc: Activates help screen from main menu.
//-----------------------------------------------------------------------------
DWORD Help(DWORD cmd, XMenuItem *mi)
{
	g_bDrawHelp = TRUE;
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: GotName and InitNameMenu
// Desc: Creates a menu of names to choose from. Since we dont have a
//       virtual keyboard, this lets us have clients with different names.
//       Also assembles the host session name to be "playername - XVoiceConnect"
//-----------------------------------------------------------------------------
DWORD GotName(DWORD cmd, XMenuItem *mi)
{
	// set player name
	wcscpy(g_wszXDPPlayerName, mi->string);

	// set session name
	wcscpy(g_wszXDPSessionName, g_wszXDPPlayerName);
	wcscat(g_wszXDPSessionName, L" - XVoiceConnect");

	XMenu_Delete(g_NameMenu);
	XMenu_Activate(g_MainMenu);

	return MROUTINE_RETURN;
}

void CXBoxSample::InitNameMenu()
{
	// init the choose player name menu
	g_NameMenu = XMenu_Init(320.0f, 100.0f, 4, MENU_NOBACK, NULL);
	XMenu_SetTitle(g_NameMenu, L"Choose Name", 0xffffff00);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Maximus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Minimus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Animus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Haxor", GotName);
	XMenu_Activate(g_NameMenu);
}

//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
	DPNMSG_CREATE_PLAYER *pCreatePlayerMsg;
	DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg;
	DVMSG_CREATEVOICEPLAYER *pCreateDVPlayerMsg;
	DVMSG_DELETEVOICEPLAYER *pDeleteDVPlayerMsg;
	DVMSG_RECORDSTART *pRecStartMsg;
	DVMSG_RECORDSTOP *pRecStopMsg;
	DVMSG_PLAYERVOICESTART *pVoiceStartMsg;
	DVMSG_PLAYERVOICESTOP *pVoiceStopMsg;

	APP_PLAYER_INFO *pPlayerInfo;
	ActiveGame *pGame;
	WCHAR s[80];

    switch(dwMsgType)
    {
		// handle connecting to the DVoice session after
		// dplay connect is complete
        case DPN_MSGID_CONNECT_COMPLETE:
			if(g_dwConnectStatus!=GAME_HOSTING)
				XDVConnect(DVCLIENTCONFIG_MANUALVOICEACTIVATED);
			break;

		// handle adding and deleting games
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			pGame = XDPAddGame((DPNMSG_ENUM_HOSTS_RESPONSE *)pMsg);
			AddGame(pGame);
			break;
		case DPPEER_MSGID_DELETE_GAME:
			DeleteGame((ActiveGame *)pMsg);
			break;

		// handle player create
        case DPN_MSGID_CREATE_PLAYER:
			pCreatePlayerMsg = (DPNMSG_CREATE_PLAYER *)pMsg;
			CreatePlayer(pCreatePlayerMsg);
			pPlayerInfo = (APP_PLAYER_INFO *)pCreatePlayerMsg->pvPlayerContext;
			swprintf(s, L"%s joined the game.", pPlayerInfo->wstrPlayerName);
			XTextBox_AddItem(XBox, s);
			break;
		case DVMSGID_CREATEVOICEPLAYER:
			pCreateDVPlayerMsg = (DVMSG_CREATEVOICEPLAYER *)pMsg;
			g_pDP->GetPlayerContext(pCreateDVPlayerMsg->dvidPlayer, (void **)&pPlayerInfo, 0);
			PLAYER_ADDREF(pPlayerInfo);
			pCreateDVPlayerMsg->pvPlayerContext = pPlayerInfo;

			// find an open slot in the status table
			pPlayerInfo->dwIndex = -1;
			for(int i=0; i<8; i++)
				if(g_pStatus[i]->val1==VSTATUS_EMPTY)
				{
					pPlayerInfo->dwIndex = i;
					break;
				}

			assert(pPlayerInfo->dwIndex!=-1);

			g_pStatus[pPlayerInfo->dwIndex]->val1 = VSTATUS_OCCUPIED;
			wcsncpy(g_pStatus[pPlayerInfo->dwIndex]->string, pPlayerInfo->wstrPlayerName, TBOX_STRINGLEN);
			break;

		// handle player destroy
        case DPN_MSGID_DESTROY_PLAYER:
			pDestroyPlayerMsg = (DPNMSG_DESTROY_PLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
			swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
			DeletePlayer(pDestroyPlayerMsg);
			XTextBox_AddItem(XBox, s);
			break;

		case DVMSGID_DELETEVOICEPLAYER:
			pDeleteDVPlayerMsg = (DVMSG_DELETEVOICEPLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDeleteDVPlayerMsg->pvPlayerContext;
            swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
            XTextBox_AddItem(XBox, s);

			// free slot in the status table
			g_pStatus[pPlayerInfo->dwIndex]->val1 = VSTATUS_EMPTY;
			wcscpy(g_pStatus[pPlayerInfo->dwIndex]->string, L" ");

			PLAYER_RELEASE(pPlayerInfo);
			break;

		// update player talking/not talking display in 
		// response to these messages
		case DVMSGID_RECORDSTART:
			pRecStartMsg = (DVMSG_RECORDSTART *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pRecStartMsg->pvLocalPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->color = 0xff00ff00;
			swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s is talking", pPlayerInfo->wstrPlayerName);
			break;

		case DVMSGID_RECORDSTOP:
			pRecStopMsg = (DVMSG_RECORDSTOP *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pRecStopMsg->pvLocalPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->color = 0xffffffff;
			swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s", pPlayerInfo->wstrPlayerName);
			break;

		case DVMSGID_PLAYERVOICESTART:
			pVoiceStartMsg = (DVMSG_PLAYERVOICESTART *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pVoiceStartMsg->pvPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->color = 0xff00ff00;
			swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s is talking", pPlayerInfo->wstrPlayerName);
			break;

		case DVMSGID_PLAYERVOICESTOP:
			pVoiceStopMsg = (DVMSG_PLAYERVOICESTOP *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pVoiceStopMsg->pvPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->color = 0xffffffff;
			swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s", pPlayerInfo->wstrPlayerName);
			break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DoMPMenu
// Desc: Builds multiplayer menu
//-----------------------------------------------------------------------------
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi)
{
	XMenuItem *mitem;

	if(g_MPMenu)
		delete g_MPMenu;

	g_MPMenu = XMenu_Init(320.0f, 100.0f, 4, 0, NULL);
	XMenu_SetTitle(g_MPMenu, L"Multiplayer", 0xffffff00);

	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"CREATE GAME", Create);
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR XBOX GAMES", FindGames);
	mitem->val1 = g_dwPort;
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR PC GAMES", FindGames);
	mitem->val1 = PCPORT;
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"DISCONNECT FROM GAME", Disconnect);

	XMenu_Activate(g_MPMenu);

	return MROUTINE_RETURN;
}


//-----------------------------------------------------------------------------
// Name: Create
// Desc: Host a game
//-----------------------------------------------------------------------------
DWORD Create(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before creating a new game.");
		return MROUTINE_DIE;
	}

	// create the game
	XDPCreate(g_dwPort, &g_AppGUID, 8, 0);
	XDVCreate(DVSESSIONTYPE_PEER, DSCTID_SC06);

	// connect to the dvoice session we just started serving
	XDVConnect(DVCLIENTCONFIG_MANUALVOICEACTIVATED);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: Disconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
DWORD Disconnect(DWORD cmd, XMenuItem *mi)
{
	// dont try to disconnect if we are not in a game
	if(!XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"You are not connected to a game.");
		return MROUTINE_DIE;
	}

	// disconnect from dplay session
	if(g_dwConnectStatus==GAME_HOSTING)
	{
		XDVStopSession();
		XDVDisconnect();
		XDPTerminate();
	}
	else
	{
		XDVDisconnect();
		XDPDisconnect();
	}

	XTextBox_AddItem(XBox, L"Disconnected from the game.");

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: FindGames
// Desc: Finds active games on the network.
//-----------------------------------------------------------------------------
DWORD FindGames(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before searching for new games.");
		return MROUTINE_DIE;
	}

	// init game menu
	if(g_GameMenu)
		XMenu_Delete(g_GameMenu);

	g_GameMenu = XMenu_Init(320.0f, 100.0f, 20, 0, AbortFindGames);
	XMenu_SetTitle(g_GameMenu, L"Games", 0xffffff00);
	g_GameMenu->w = 440.0f;
	XMenu_SetMaxShow(g_GameMenu, 8);

	XMenu_AddItem(g_GameMenu, 0, L"ABORT", NULL);
	XMenu_Activate(g_GameMenu);

	// search for game on port specified in mi->val1
	// this is so we can find games on 2399 (other xboxes) and
	// 6073 (pc's running dx8 dplay)
	// normally you would use g_dwPort value here
	XDPEnumHosts(mi->val1, &g_AppGUID);

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: AbortFindGames
// Desc: Aborts finding active games on the network.
//-----------------------------------------------------------------------------
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi)
{
	XDPCancelEnumHosts();
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: AddGame
// Desc: Adds to the menu of currently active games.
//-----------------------------------------------------------------------------
void AddGame(ActiveGame *pGame)
{
	XMenuItem *mi;
	const DPN_APPLICATION_DESC *pApp;
	WCHAR s[80], name[80];
	DWORD i;

	assert(pGame);

	pApp = &pGame->AppDesc;

	// see if this item already in the menu
	mi = NULL;
	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			mi = &g_GameMenu->items[i];
			break;
		}

	// build menu item string
	wcscpy(name, pApp->pwszSessionName);
	swprintf(s, L"%s (%d, %d/%d)", name, pGame->dwPing, pApp->dwCurrentPlayers, pApp->dwMaxPlayers);

	// add new item to menu or update existing item
	if(!mi)
	{
		mi = XMenu_AddItem(g_GameMenu, MITEM_ROUTINE, s, Connect);
		mi->val1 = (DWORD)pGame;		// save pointer to this game
	}
	else
		XMenu_SetItemText(mi, s);
}

//-----------------------------------------------------------------------------
// Name: DeleteGame
// Desc: Deletes from the menu of currently active games.
//-----------------------------------------------------------------------------
void DeleteGame(ActiveGame *pGame)
{
	DWORD i;

	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			XMenu_DeleteItem(&g_GameMenu->items[i]);
			break;
		}
}

//-----------------------------------------------------------------------------
// Name: Connect
// Desc: Connect to an existing game
//-----------------------------------------------------------------------------
DWORD Connect(DWORD cmd, XMenuItem *mi)
{
	ActiveGame *pGame;

	// dont try to connect if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before connecting to a new game.");
		return MROUTINE_DIE;
	}

	pGame = (ActiveGame *)mi->val1;			// get pointer to desired game
	XDPConnect(&pGame->AppDesc, pGame->pHostAddr, pGame->pDevAddr);

	// we still need to connect to the dvoice session
	// however, we wait until we receive a CONNECT_COMPLETE
	// message. see the CONNECT_COMPLETE message in the message
	// handler for this processing.

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: CreatePlayer
// Desc: Add a player to the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_CREATE_PLAYER
//-----------------------------------------------------------------------------
HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg)
{
    HRESULT hr;
    DWORD dwSize = 0;
    DPN_PLAYER_INFO *pdpPlayerInfo = NULL;

    // Get the peer info and extract its name
    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr) && hr!=DPNERR_BUFFERTOOSMALL)
        return hr;

    pdpPlayerInfo = (DPN_PLAYER_INFO *) new BYTE[dwSize];
    ZeroMemory(pdpPlayerInfo, dwSize);
    pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr))
        return hr;

    // Create a new and fill in a APP_PLAYER_INFO
    APP_PLAYER_INFO *pPlayerInfo = new APP_PLAYER_INFO;
    ZeroMemory(pPlayerInfo, sizeof(APP_PLAYER_INFO));
    pPlayerInfo->lRefCount = 1;				   
    pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

	// copy players name
	wcsncpy(pPlayerInfo->wstrPlayerName, pdpPlayerInfo->pwszName, MAX_PLAYER_NAME);

	// check for local player dpnid
	if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL)
		g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

	// check for host player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_HOST)
        g_dpnidHost = pPlayerInfo->dpnidPlayer;

    // Tell DirectPlay to store this pPlayerInfo pointer in the pvPlayerContext.
    pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

	// increment number of players
	g_dwNumPlayers++;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: DeletePlayer
// Desc: Deletes a player from the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_DELETE_PLAYER
//-----------------------------------------------------------------------------
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg)
{
    APP_PLAYER_INFO *pPlayerInfo;

	// get a pointer to the context of the player being deleted
	pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;

	// release player info
	PLAYER_RELEASE(pPlayerInfo);  

	// decrement # of players
	g_dwNumPlayers--;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceeffect\echo.h ===
//-----------------------------------------------------------------------------
// File: Echo.h
//
// Desc: Implements an XMO filter to add an echo effect.
//
// Hist: 01.06.00 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: XCreateEchoFxMediaObject()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT XCreateEchoFxMediaObject( XMediaObject** ppMediaObject, DWORD dwDelay,
                                  DWORD dwSampleSize );




//-----------------------------------------------------------------------------
// Name: class CEchoXMO
// Desc: 
//-----------------------------------------------------------------------------
class CEchoXMO : public XMediaObject 
{
    SHORT* m_pPreviousPacket;
    ULONG  m_cRef;
    DWORD  m_dwDelay;
    DWORD  m_dwSampleSize;

public:
    CEchoXMO()
    {
        m_cRef            = 0;
        m_dwDelay         = 0;
        m_dwSampleSize    = 0;
        m_pPreviousPacket = NULL;
    }

    ~CEchoXMO() {}

    STDMETHODIMP_(ULONG)      AddRef() 
    { 
        return InterlockedIncrement((long*)&m_cRef); 
    }
    
    STDMETHODIMP_(ULONG)      Release() 
    {
        long l = InterlockedDecrement( (long*)&m_cRef );
        if( l == 0 )
           delete this;
        return l;
    }
    
    HRESULT STDMETHODCALLTYPE Initialize( DWORD dwDelay, DWORD dwSampleSize );
    HRESULT STDMETHODCALLTYPE GetInfo( XMEDIAINFO* pInfo );
    HRESULT STDMETHODCALLTYPE Process( const XMEDIAPACKET* pSrcBuffer, const XMEDIAPACKET* pDstBuffer );
    HRESULT STDMETHODCALLTYPE GetStatus( DWORD* pdwFlags );
    HRESULT STDMETHODCALLTYPE Flush()         { return S_OK; }
    HRESULT STDMETHODCALLTYPE Discontinuity() { return S_OK; }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoicegroup\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceeffect\XMOFilter.cpp ===
//-----------------------------------------------------------------------------
// File: XMOFilter.cpp
//
// Desc: A sample to show:
//       (1) How to stream data between 3 xmos( 1 async sources, one sychronous 
//           in the middle, one async target.
//       (2) How to write a synchronous  effect or codec using XMOs and use it
//           in a graph.
//
//       Note: This sample requires a Hawk device to run.
//
// Hist: 01.06.00 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdlib.h>
#include <stdio.h>
#include "Echo.h"
#include "xmofilter.h"
#include "xdpvoice.h"

// Debug macros
#define ASSERT(w) {if(w){}}
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp)
#define DBG_ERROR(_exp)
#define DBG_WARN(_exp)

//-----------------------------------------------------------------------------
// Name: AttachPacketToSourceXMO()
// Desc: Helper function that prepares a packet context and attaches it to the
//       source XMO
//-----------------------------------------------------------------------------
VOID CFilterGraph::AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;

    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    XMEDIAPACKET xmb;
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;            
    xmb.dwMaxSize        = pCtx->dwCompletedSize;
    xmb.hCompletionEvent = NULL;
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;
    xmb.pdwStatus        = &pCtx->dwStatus;

    // Attach to the source XMO (first xmo in the chain)
    hr = m_pSourceXMO->Process( NULL, &xmb );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }
    m_SourcePendingList.Add( &pCtx->ListEntry );
}




//-----------------------------------------------------------------------------
// Name: AttachPacketToTargetXMO()
// Desc: Helper function that prepares a packet context and attaches it to the
//       target XMO
//-----------------------------------------------------------------------------
VOID CFilterGraph::AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;

    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    XMEDIAPACKET xmb;
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;            
    xmb.dwMaxSize        = pCtx->dwCompletedSize;
    xmb.hCompletionEvent = NULL;
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;
    xmb.pdwStatus        = &pCtx->dwStatus;

    // Attach to the target XMO (first xmo in the chain)
    hr = m_pTargetXMO->Process( &xmb, NULL );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }
    m_TargetPendingList.Add( &pCtx->ListEntry );
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Creates a streaming graph between 3 XMOs: a source, a in-between
//       (codec in this case) and a target. We only support one intermediate
//       xmo, but you could actually have multiple ones that manipulate the
//       same stream passing packets between them
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::Init(PWAVEFORMATEX pwfx,
                           XMediaObject *pSourceXmo,
                           XMediaObject *pIntermediateXmo,
                           XMediaObject *pTargetXmo)
                           
{
    HRESULT        hr = S_OK;
    DWORD          dwMinSize;

    XMEDIAINFO xMediaInfo;
    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    m_dwPacketSize     = PACKET_SIZE;
    m_dwMaxBufferCount = PACKET_CNT;

    if (pwfx) {

        memcpy(&m_wfxAudioFormat,pwfx,sizeof(WAVEFORMATEX));

    }


    if (pSourceXmo) {

        m_pSourceXMO = pSourceXmo;

    } else {

        //
        // default source is wmadecoder in async mode
        //

        hr = WmaCreateDecoder("D:\\MEDIA\\AUDIO\\test.wma",
                              NULL,
                              TRUE,
                              4096*16,
                              PACKET_CNT,
                              &m_wfxAudioFormat,
                              (XFileMediaObject **)&m_pSourceXMO );
        if( FAILED(hr) ) 
        {          
            DBG_ERROR( ("XmoFilter: WmaCreateDecoder failed with %x", hr) );
            return hr;
        }


    }

    if (pIntermediateXmo) {

        m_pIntermediateXMO = pIntermediateXmo;

    } else {

        // Now create a default in-between XMO (echo)
        hr = XCreateEchoFxMediaObject( &m_pIntermediateXMO,
                                       m_dwPacketSize,        // Length in bytes of delay line
                                       m_wfxAudioFormat.wBitsPerSample >> 3 ); // dwSampleSize in bytes
        if( FAILED(hr) ) 
        {          
            DBG_ERROR( ("XmoFilter: XcreateEchoFxMediaObject failed with %x", hr) );
            return hr;
        }

    }

    if (pTargetXmo) {

        m_pTargetXMO = pTargetXmo;

    } else {

        // create the default target XMO, the end part of the streaming chain
        DSSTREAMDESC dssd;
        ZeroMemory( &dssd, sizeof(dssd) );
        dssd.dwFlags              = 0;
        dssd.dwMaxAttachedPackets = PACKET_CNT;
        dssd.lpwfxFormat          = &m_wfxAudioFormat;
    
        hr = DirectSoundCreateStream( &dssd, (LPDIRECTSOUNDSTREAM*)&m_pTargetXMO );
        if( FAILED(hr) ) 
        {          
            DBG_ERROR( ("XmoFilter: DirectSoundCreateXMOStream failed with %x", hr) );
            DBG_ERROR( ("Init: Could not open a target audio XMO\n") );
            return hr;
        }

    }

#if DBG
    // At this point we should have all the XMOs.
    // Figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned.
    // As a last check we make sure its also larger than the maxLookahead
    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    m_pSourceXMO->GetInfo( &xMediaInfo );
    m_dwMinPacketSize = xMediaInfo.dwOutputSize;

    XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );

    m_pIntermediateXMO->GetInfo( &xMediaInfo );
    m_dwMinPacketSize = max( xMediaInfo.dwInputSize, m_dwMinPacketSize );

    XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );

    m_pTargetXMO->GetInfo( &xMediaInfo );
    m_dwMinPacketSize = max( xMediaInfo.dwOutputSize, m_dwMinPacketSize );

    XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
#endif

    ASSERT( m_pTargetXMO );
    ASSERT( m_pSourceXMO );

    // Initialize the linked lists
    m_SourcePendingList.Initialize();
    m_TargetPendingList.Initialize();

    // Allocate one large buffer for incoming/outgoing data. The buffer is
    // going to be split in small packet segments that will be used to stream
    // data between XMOs
    dwMinSize = MAXBUFSIZE;
    m_pTransferBuffer = new BYTE[dwMinSize];
    ZeroMemory( m_pTransferBuffer, dwMinSize );

    // Allocate a context pool. A context is associated with a packet buffer
    // and used to track the pending packets attached to the source or target
    // XMO.
    dwMinSize = ( PACKET_CNT * sizeof(MEDIA_PACKET_CTX) ) + 10;
    m_pPacketContextPool = new BYTE[dwMinSize];
    memset( m_pPacketContextPool, 8, dwMinSize );

    // We attach all available packet buffers in the beginning to prime the
    // graph: As each packet is completed by the source XMO, the event is
    // signalled in its packet context and we pass the packet to the next XMO.
    for( DWORD i = 0; i < PACKET_CNT; i++ ) 
    {
        MEDIA_PACKET_CTX* pCtx = &((MEDIA_PACKET_CTX*)m_pPacketContextPool)[i];

        ZeroMemory( pCtx, sizeof(MEDIA_PACKET_CTX) );
        pCtx->dwCompletedSize = m_dwPacketSize;
        pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;
        pCtx->pBuffer         = &m_pTransferBuffer[i*PACKET_SIZE];

        AttachPacketToSourceXMO( pCtx );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: TransferData()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::TransferData()
{
    HRESULT        hr=S_OK;
    DWORD          index = 0;
    XMEDIAPACKET   xmb;
    MEDIA_PACKET_CTX* pSrcCtx = NULL;
    MEDIA_PACKET_CTX* pDstCtx = NULL;
    DWORD             dwSize  = 0;

    // Setup media buffer
    ZeroMemory( &xmb, sizeof(xmb) );

    // Wait for the oldest buffers submitted to the source and target xmo
    // oldest buffers are at the head, since we insert at the tail, remove from head
    if( !m_SourcePendingList.IsListEmpty() ) 
    {
        pSrcCtx = (MEDIA_PACKET_CTX*)m_SourcePendingList.pNext; // Head
    }

    if( !m_TargetPendingList.IsListEmpty() ) 
    {
        pDstCtx = (MEDIA_PACKET_CTX*)m_TargetPendingList.pNext; // Head
    }        

    if( pSrcCtx )
    {
        if( pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING ) 
        {
            // A src buffer completed.
            // Remove this context from the Src pending list.
            // Send it to a codec, if present, then send it to the Target xmo
            pSrcCtx->ListEntry.Remove();

            // Before we pass it on, set the context packet to amount of data we received
            xmb.pvBuffer         = pSrcCtx->pBuffer;            
            xmb.dwMaxSize        = pSrcCtx->dwCompletedSize;        
            xmb.hCompletionEvent = NULL;

            DBG_SPAM(("Context %x received %x bytes, xmb %x\n",pSrcCtx, xmb.dwMaxSize, &xmb));
            ASSERT( xmb.dwMaxSize );

            pSrcCtx->dwCompletedSize = 0;
            pSrcCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

            dwSize = xmb.dwMaxSize;

            if( m_pIntermediateXMO ) 
            {
                // NOTE: its ok to pass a pointer to a stack variable since
                // middle XMO is sync!!! Never do this with async XMOs!!!
                // Note that we pass the same media packet description twice
                // THis is  because the particular intermediate effect XMO is in place
                // and it operates on a single buffer

                xmb.pdwCompletedSize = &dwSize;

                hr = m_pIntermediateXMO->Process( &xmb, &xmb );

                ASSERT(SUCCEEDED(hr));
                ASSERT(dwSize <=PACKET_SIZE);

                pSrcCtx->dwCompletedSize = dwSize;

            } 
            else // If intermediate xmo
            { 
                pSrcCtx->dwCompletedSize = m_dwPacketSize;
            }

            if (dwSize < PACKET_SIZE) {
        
                //
                // the source xmo produced less than asked. this signals end of file for wma xmo
                // flush it so it starts at the begininning again...
                // Pass at least a sample worth of data to dsound so it will not RIP
                //
        
                m_pSourceXMO->Flush();
                pSrcCtx->dwCompletedSize = max(4,dwSize);

            }

            // Pass media buffer to the target xmo.
            AttachPacketToTargetXMO( pSrcCtx );
        }


    }

    // Check if destination buffer xmo was also done..
    if( pDstCtx )
    {
        if( pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING )
        {       
            DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));

            pDstCtx->ListEntry.Remove();

            ASSERT(pDstCtx->dwCompletedSize != 0);

            // The target XMO is done with a buffer.
            pDstCtx->dwCompletedSize = PACKET_SIZE;
            AttachPacketToSourceXMO( pDstCtx );
        } 
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceeffect\xvoiceeffect.cpp ===
//-----------------------------------------------------------------------------
// File: xvoiceeffect.cpp
//
// Desc: DirectPlay Voice sample
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <assert.h>

#include "xmenu.h"
#include "xtextbox.h"
#include "xdppeer.h"
#include "xdpvoice.h"
#include "xmofilter.h"


//-----------------------------------------------------------------------------
// UI Stuff
//-----------------------------------------------------------------------------
XTextBox *XBox;                                 // pun intended
DWORD g_dwMenuCommand;
XMenu *g_MainMenu;                              // main menu
XMenu *g_NameMenu;                              // choose name menu


//-----------------------------------------------------------------------------
// player status information
//-----------------------------------------------------------------------------
#define VSTATUS_EMPTY		0					// slot is empty
#define VSTATUS_OCCUPIED	1					// slot is occupied
#define VSTATUS_TALKING		2					// slot is talking

#define MAX_STATUS			8					// max # of players in status
XTextBox *StatusBox;							// player status box (talking/not)
XTextBoxItem *g_pStatus[MAX_STATUS];			// status box items


//-----------------------------------------------------------------------------
// dplay message handler
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg);


//-----------------------------------------------------------------------------
// GUID & port
//-----------------------------------------------------------------------------
GUID g_AppGUID = { 0xfcd4761e, 0x2b9c, 0x4478, { 0xb7, 0xea, 0xd9, 0xe1, 0x8e, 0x6e, 0x2a, 0xac } };
DWORD g_dwPort = 2399;                          // game port
#define PCPORT 6073                             // port for PC game search


//-----------------------------------------------------------------------------
// multiplayer menu
//-----------------------------------------------------------------------------
XMenu *g_MPMenu;                                // multiplayer menu
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi);       // init & display MP menu
DWORD Create(DWORD cmd, XMenuItem *mi);         // host a game
DWORD Connect(DWORD cmd, XMenuItem *mi);        // connect to an existing game
DWORD Disconnect(DWORD cmd, XMenuItem *mi);     // disconnect from current game


//-----------------------------------------------------------------------------
// game menu
//-----------------------------------------------------------------------------
XMenu *g_GameMenu;                              // game menu
DWORD FindGames(DWORD cmd, XMenuItem *mi);      // find game to join
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi); // stop finding games to join
void AddGame(ActiveGame *pGame);                // add an active game to game menu
void DeleteGame(ActiveGame *pGame);             // removes an active game from the game menu


//-----------------------------------------------------------------------------
// App specific Player information 
//-----------------------------------------------------------------------------
#define MAX_PLAYER_NAME 14
struct APP_PLAYER_INFO
{
    LONG  lRefCount;                            // Ref count so we can cleanup when all threads 
                                                // are done w/ this object
    DPNID dpnidPlayer;                          // DPNID of player
    WCHAR wstrPlayerName[MAX_PLAYER_NAME];      // Player name
    DWORD dwIndex;                              // index in textbox

    XMediaObject *pSourceXmo;                   // target media object for incoming voice
    CFilterGraph *pFilterGraph;
};

#define PLAYER_ADDREF(a)    if(a) a->lRefCount++;
#define PLAYER_RELEASE(a)   if(a) { a->lRefCount--; if(a->lRefCount<=0) delete a; } a = NULL;

APP_PLAYER_INFO *g_pActivePlayer;

HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg);
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg);

//-----------------------------------------------------------------------------
// help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle Help\nMenu Back"},
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_1, L"Menu Activate\nMenu Select"},
};
#define MAX_NORMAL_HELP_CALLOUTS 2

BOOL g_bDrawHelp = FALSE;
DWORD Help(DWORD cmd, XMenuItem *mi);       // help activate menu item


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font for rendering stats and help
    CXBFont m_Font;
    CXBHelp m_Help;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    HRESULT Cleanup();
    void InitNameMenu();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// Initialize the help system
    if(FAILED(hr = m_Help.Create(m_pd3dDevice, "Gamepad.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

    // set menu and text box fonts
    XMenu_SetFont(&m_Font);
    XTextBox_SetFont(&m_Font);

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 10000.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &matProj);

    // init the 'choose player name' menu
    InitNameMenu();

    // init a menu
    g_MainMenu = XMenu_Init(320.0f, 120.0f, 5, 0, NULL);
	XMenu_SetTitle(g_MainMenu, L"Main Menu", 0xffffff00);
    XMenu_AddItem(g_MainMenu, 0, L"SINGLE PLAYER", NULL);
    XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"MULTIPLAYER", DoMPMenu);
    XMenu_AddItem(g_MainMenu, MITEM_SEPARATOR, NULL, NULL);
    XMenu_AddItem(g_MainMenu, 0, L"OPTIONS", NULL);
    XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"HELP", Help);

    // init a textbox
    XBox = XTextBox_Init(64, 480.0f-50.0f-(float)m_Font.GetFontHeight()*4.0f,
                        640.0f-128.0f, 3, TBOX_POPUP);
    XBox->expiretime = 2000;        // keep messages up for 2 seconds
    XTextBox_AddItem(XBox, L"Welcome to XVoiceEffect.");

    // init status textbox
    StatusBox = XTextBox_Init(128.0f, 110.0f, 640.0f-256.0f, 8, 0);
    StatusBox->topcolor = 0xff000000;
    StatusBox->bottomcolor = 0xffc0c000;
    for(DWORD i=0; i<MAX_STATUS; i++)
    {
        g_pStatus[i] = XTextBox_AddItem(StatusBox, L" ");
        g_pStatus[i]->val1 = VSTATUS_EMPTY;
        g_pStatus[i]->val2 = 0;
    }

    // init dplay & dvoice
    XDPInit(DPMsgHandler);
    XDVInit(DPMsgHandler);

	// clear active player pointer
	g_pActivePlayer = NULL;

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
    XMenu_Delete(g_MainMenu);
    if(g_MPMenu)
        XMenu_Delete(g_MPMenu);

    // shut down dplay
    XDPShutdown();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	DWORD i;
	APP_PLAYER_INFO *pPlayerInfo;

    // do our dplay and dvoice work
    XDPDoWork(0);
    XDVDoWork();

    // jog the filter graph for all active players
	for(i=0; i<MAX_STATUS; i++)
		if(g_pStatus[i]->val1&VSTATUS_OCCUPIED)
		{
			pPlayerInfo = (APP_PLAYER_INFO *)g_pStatus[i]->val2;
			if(pPlayerInfo->pFilterGraph)
				pPlayerInfo->pFilterGraph->TransferData();
		}

    // process menu input
    if(!g_bDrawHelp)
    {
        g_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
        if(g_dwMenuCommand==MENU_ACTIVATE)
            XMenu_Activate(g_MainMenu);
        if(XMenu_IsActive())
            return S_OK;
    }

    // toggle help menu
    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
        g_bDrawHelp = !g_bDrawHelp;
    if(g_bDrawHelp)
        return S_OK;

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    WCHAR s[80];

    // clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0, 1.0f, 0L );

    // process the menu
    XMenu_Routine(g_dwMenuCommand);
    XTextBox_Display(XBox);

    if(!XMenu_IsActive())
        XTextBox_Display(StatusBox);

    // show game title
    m_Font.DrawText(64, 50, 0xffffffff, L"VOICE EFFECT");
    m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

    // show our current status
    switch(g_dwConnectStatus)
    {
        case GAME_HOSTING:
            m_Font.DrawText(64, 70, 0xff00ff00, L"HOSTING");
            break;
        case GAME_ENUMERATING:
            m_Font.DrawText(64, 70, 0xffffff00, L"ENUMERATING");
            break;
        case GAME_CONNECTED:
            m_Font.DrawText(64, 70, 0xff00ff00, L"CONNECTED");
            break;
        case GAME_NOTCONNECTED:
            m_Font.DrawText(64, 70, 0xffff0000, L"NOT CONNECTED");
            break;
        case GAME_CONNECTING:
            m_Font.DrawText(64, 70, 0xffffff00, L"CONNECTING");
            break;
    }

	// show # of players
    if(XDPIsConnected())
    {
        swprintf(s, L"%d PLAYERS", g_dwNumPlayers);
        m_Font.DrawText(640-64, 70, 0xffffffff, s, XBFONT_RIGHT);
    }       

    // draw help
    if(g_bDrawHelp)
        m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Help
// Desc: Activates help screen from main menu.
//-----------------------------------------------------------------------------
DWORD Help(DWORD cmd, XMenuItem *mi)
{
    g_bDrawHelp = TRUE;
    return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: GotName and InitNameMenu
// Desc: Creates a menu of names to choose from. Since we dont have a
//       virtual keyboard, this lets us have clients with different names.
//       Also assembles the host session name to be "playername - XVoiceEffect"
//-----------------------------------------------------------------------------
DWORD GotName(DWORD cmd, XMenuItem *mi)
{
    // set player name
	wcscpy(g_wszXDPPlayerName, mi->string);

    // set session name
    wcscpy(g_wszXDPSessionName, g_wszXDPPlayerName);
    wcscat(g_wszXDPSessionName, L" - XVoiceEffect");

    XMenu_Delete(g_NameMenu);
    XMenu_Activate(g_MainMenu);

    return MROUTINE_RETURN;
}

void CXBoxSample::InitNameMenu()
{
    // init the choose player name menu
    g_NameMenu = XMenu_Init(320.0f, 100.0f, 4, MENU_NOBACK, NULL);
    XMenu_SetTitle(g_NameMenu, L"Choose Name", 0xffffff00);
    XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Maximus", GotName);
    XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Minimus", GotName);
    XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Animus", GotName);
    XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Haxor", GotName);
    XMenu_Activate(g_NameMenu);
}

//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
    DPNMSG_CREATE_PLAYER *pCreatePlayerMsg;
    DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg;
    DVMSG_CREATEVOICEPLAYER *pCreateDVPlayerMsg;
    DVMSG_DELETEVOICEPLAYER *pDeleteDVPlayerMsg;
    DVMSG_RECORDSTART *pRecStartMsg;
    DVMSG_RECORDSTOP *pRecStopMsg;
    DVMSG_PLAYERVOICESTART *pVoiceStartMsg;
    DVMSG_PLAYERVOICESTOP *pVoiceStopMsg;
    PWAVEFORMATEX pwfx;
    HRESULT hr;

    APP_PLAYER_INFO *pPlayerInfo;
    ActiveGame *pGame;
    WCHAR s[80];

    switch(dwMsgType)
    {
        // handle connecting to the DVoice session after
        // dplay connect is complete
        case DPN_MSGID_CONNECT_COMPLETE:
            if(g_dwConnectStatus!=GAME_HOSTING)
                XDVConnect(DVCLIENTCONFIG_MANUALVOICEACTIVATED);
            break;

        // handle adding and deleting games
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
            pGame = XDPAddGame((DPNMSG_ENUM_HOSTS_RESPONSE *)pMsg);
            AddGame(pGame);
            break;
        case DPPEER_MSGID_DELETE_GAME:
            DeleteGame((ActiveGame *)pMsg);
            break;

        // handle player create
        case DPN_MSGID_CREATE_PLAYER:
            pCreatePlayerMsg = (DPNMSG_CREATE_PLAYER *)pMsg;
            CreatePlayer(pCreatePlayerMsg);
            pPlayerInfo = (APP_PLAYER_INFO *)pCreatePlayerMsg->pvPlayerContext;
            swprintf(s, L"%s joined the game.", pPlayerInfo->wstrPlayerName);
            XTextBox_AddItem(XBox, s);
            break;
        case DVMSGID_CREATEVOICEPLAYER:
            pCreateDVPlayerMsg = (DVMSG_CREATEVOICEPLAYER *)pMsg;
            g_pDP->GetPlayerContext(pCreateDVPlayerMsg->dvidPlayer, (void **)&pPlayerInfo, 0);
            PLAYER_ADDREF(pPlayerInfo);
            pCreateDVPlayerMsg->pvPlayerContext = pPlayerInfo;

            // find an open slot in the status table
            pPlayerInfo->dwIndex = -1;
            for(int i=0; i<8; i++)
                if(g_pStatus[i]->val1==VSTATUS_EMPTY)
                {
                    pPlayerInfo->dwIndex = i;
                    break;
                }

            assert(pPlayerInfo->dwIndex!=-1);

            g_pStatus[pPlayerInfo->dwIndex]->val1 = VSTATUS_OCCUPIED;
			g_pStatus[pPlayerInfo->dwIndex]->val2 = (DWORD)pPlayerInfo;
            wcsncpy(g_pStatus[pPlayerInfo->dwIndex]->string, pPlayerInfo->wstrPlayerName, TBOX_STRINGLEN);

            //
            // create a sound target for this player
            //
			assert(pPlayerInfo->pSourceXmo==NULL);
            if(g_dpnidLocalPlayer!=pPlayerInfo->dpnidPlayer)
			{
				// create a sound target for this player
                hr = g_pDVClient->CreateSoundTarget(pPlayerInfo->dpnidPlayer,
									&pwfx, &pPlayerInfo->pSourceXmo);
				assert(SUCCEEDED(hr));
    
                // init the streaming filter graph
                pPlayerInfo->pFilterGraph = new CFilterGraph();
                hr = pPlayerInfo->pFilterGraph->Init(pwfx, pPlayerInfo->pSourceXmo, NULL, NULL);
				assert(SUCCEEDED(hr));
            }
            break;

        // handle player destroy
        case DPN_MSGID_DESTROY_PLAYER:
            pDestroyPlayerMsg = (DPNMSG_DESTROY_PLAYER *)pMsg;
            pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
            swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
            DeletePlayer(pDestroyPlayerMsg);
            XTextBox_AddItem(XBox, s);
            break;

        case DVMSGID_DELETEVOICEPLAYER:
            pDeleteDVPlayerMsg = (DVMSG_DELETEVOICEPLAYER *)pMsg;
            pPlayerInfo = (APP_PLAYER_INFO *)pDeleteDVPlayerMsg->pvPlayerContext;
            swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
            XTextBox_AddItem(XBox, s);

            // free slot in the status table
            g_pStatus[pPlayerInfo->dwIndex]->val1 = VSTATUS_EMPTY;
			wcscpy(g_pStatus[pPlayerInfo->dwIndex]->string, L" ");

            PLAYER_RELEASE(pPlayerInfo);
            break;


		// update player talking/not talking display in 
		// response to these messages
        case DVMSGID_RECORDSTART:
            pRecStartMsg = (DVMSG_RECORDSTART *)pMsg;
            pPlayerInfo = (APP_PLAYER_INFO *)pRecStartMsg->pvLocalPlayerContext;
            g_pStatus[pPlayerInfo->dwIndex]->color = 0xff00ff00;
            swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s is talking", pPlayerInfo->wstrPlayerName);
            break;

        case DVMSGID_RECORDSTOP:
            pRecStopMsg = (DVMSG_RECORDSTOP *)pMsg;
            pPlayerInfo = (APP_PLAYER_INFO *)pRecStopMsg->pvLocalPlayerContext;
            g_pStatus[pPlayerInfo->dwIndex]->color = 0xffffffff;
            swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s", pPlayerInfo->wstrPlayerName);
            break;

        case DVMSGID_PLAYERVOICESTART:
            pVoiceStartMsg = (DVMSG_PLAYERVOICESTART *)pMsg;
            pPlayerInfo = (APP_PLAYER_INFO *)pVoiceStartMsg->pvPlayerContext;
            g_pStatus[pPlayerInfo->dwIndex]->color = 0xff00ff00;
            swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s is talking", pPlayerInfo->wstrPlayerName);
            break;

        case DVMSGID_PLAYERVOICESTOP:
            pVoiceStopMsg = (DVMSG_PLAYERVOICESTOP *)pMsg;
            pPlayerInfo = (APP_PLAYER_INFO *)pVoiceStopMsg->pvPlayerContext;
            g_pStatus[pPlayerInfo->dwIndex]->color = 0xffffffff;
            swprintf(g_pStatus[pPlayerInfo->dwIndex]->string, L"%s", pPlayerInfo->wstrPlayerName);
            break;
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DoMPMenu
// Desc: Builds multiplayer menu
//-----------------------------------------------------------------------------
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi)
{
    XMenuItem *mitem;

    if(g_MPMenu)
        delete g_MPMenu;

    g_MPMenu = XMenu_Init(320.0f, 100.0f, 4, 0, NULL);
	XMenu_SetTitle(g_MPMenu, L"Multiplayer", 0xffffff00);

    XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"CREATE GAME", Create);
    mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR XBOX GAMES", FindGames);
    mitem->val1 = g_dwPort;
    mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR PC GAMES", FindGames);
    mitem->val1 = PCPORT;
    XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"DISCONNECT FROM GAME", Disconnect);

    XMenu_Activate(g_MPMenu);

    return MROUTINE_RETURN;
}


//-----------------------------------------------------------------------------
// Name: Create
// Desc: Host a game
//-----------------------------------------------------------------------------
DWORD Create(DWORD cmd, XMenuItem *mi)
{
    // dont try to create if we are already in a game
    if(XDPIsConnected())
    {
        XTextBox_AddItem(XBox, L"Disconnect before creating a new game.");
        return MROUTINE_DIE;
    }

    // create the game
    XDPCreate(g_dwPort, &g_AppGUID, 8, 0);
    XDVCreate(DVSESSIONTYPE_PEER, DSCTID_SC06);

    // connect to the dvoice session we just started serving
    XDVConnect(DVCLIENTCONFIG_MANUALVOICEACTIVATED);

    return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: Disconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
DWORD Disconnect(DWORD cmd, XMenuItem *mi)
{
    // dont try to disconnect if we are not in a game
    if(!XDPIsConnected())
    {
        XTextBox_AddItem(XBox, L"You are not connected to a game.");
        return MROUTINE_DIE;
    }

	// disconnect from dplay session
	if(g_dwConnectStatus==GAME_HOSTING)
	{
		XDVStopSession();
		XDVDisconnect();
		XDPTerminate();
	}
	else
	{
		XDVDisconnect();
		XDPDisconnect();
	}

    XTextBox_AddItem(XBox, L"Disconnected from the game.");

    return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: FindGames
// Desc: Finds active games on the network.
//-----------------------------------------------------------------------------
DWORD FindGames(DWORD cmd, XMenuItem *mi)
{
    // dont try to create if we are already in a game
    if(XDPIsConnected())
    {
        XTextBox_AddItem(XBox, L"Disconnect before searching for new games.");
        return MROUTINE_DIE;
    }

    // init game menu
    if(g_GameMenu)
        XMenu_Delete(g_GameMenu);

    g_GameMenu = XMenu_Init(320.0f, 100.0f, 20, 0, AbortFindGames);
	XMenu_SetTitle(g_GameMenu, L"Games", 0xffffff00);
    g_GameMenu->w = 440.0f;
    XMenu_SetMaxShow(g_GameMenu, 8);

    XMenu_AddItem(g_GameMenu, 0, L"ABORT", NULL);
    XMenu_Activate(g_GameMenu);

    // search for game on port specified in mi->val1
    // this is so we can find games on 2399 (other xboxes) and
    // 6073 (pc's running dx8 dplay)
    // normally you would use g_dwPort value here
    XDPEnumHosts(mi->val1, &g_AppGUID);

    return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: AbortFindGames
// Desc: Aborts finding active games on the network.
//-----------------------------------------------------------------------------
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi)
{
    XDPCancelEnumHosts();
    return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: AddGame
// Desc: Adds to the menu of currently active games.
//-----------------------------------------------------------------------------
void AddGame(ActiveGame *pGame)
{
    XMenuItem *mi;
    const DPN_APPLICATION_DESC *pApp;
    WCHAR s[80], name[80];
    DWORD i;

    assert(pGame);

    pApp = &pGame->AppDesc;

    // see if this item already in the menu
    mi = NULL;
    for(i=0; i<g_GameMenu->nitems; i++)
        if((DWORD)pGame==g_GameMenu->items[i].val1)
        {
            mi = &g_GameMenu->items[i];
            break;
        }

    // build menu item string
	wcscpy(name, pApp->pwszSessionName);
    swprintf(s, L"%s (%d, %d/%d)", name, pGame->dwPing, pApp->dwCurrentPlayers, pApp->dwMaxPlayers);

    // add new item to menu or update existing item
    if(!mi)
    {
        mi = XMenu_AddItem(g_GameMenu, MITEM_ROUTINE, s, Connect);
        mi->val1 = (DWORD)pGame;        // save pointer to this game
    }
    else
        XMenu_SetItemText(mi, s);
}

//-----------------------------------------------------------------------------
// Name: DeleteGame
// Desc: Deletes from the menu of currently active games.
//-----------------------------------------------------------------------------
void DeleteGame(ActiveGame *pGame)
{
    DWORD i;

    for(i=0; i<g_GameMenu->nitems; i++)
        if((DWORD)pGame==g_GameMenu->items[i].val1)
        {
            XMenu_DeleteItem(&g_GameMenu->items[i]);
            break;
        }
}

//-----------------------------------------------------------------------------
// Name: Connect
// Desc: Connect to an existing game
//-----------------------------------------------------------------------------
DWORD Connect(DWORD cmd, XMenuItem *mi)
{
    ActiveGame *pGame;

    // dont try to connect if we are already in a game
    if(g_dwConnectStatus==GAME_CONNECTED || g_dwConnectStatus==GAME_HOSTING)
    {
        XTextBox_AddItem(XBox, L"Disconnect before connecting to a new game.");
        return MROUTINE_DIE;
    }

    pGame = (ActiveGame *)mi->val1;         // get pointer to desired game
    XDPConnect(&pGame->AppDesc, pGame->pHostAddr, pGame->pDevAddr);

    // we still need to connect to the dvoice session
    // however, we wait until we receive a CONNECT_COMPLETE
    // message. see the CONNECT_COMPLETE message in the message
    // handler for this processing.

    return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: CreatePlayer
// Desc: Add a player to the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_CREATE_PLAYER
//-----------------------------------------------------------------------------
HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg)
{
    HRESULT hr;
    DWORD dwSize = 0;
    DPN_PLAYER_INFO *pdpPlayerInfo = NULL;

    // Get the peer info and extract its name
    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr) && hr!=DPNERR_BUFFERTOOSMALL)
        return hr;

    pdpPlayerInfo = (DPN_PLAYER_INFO *) new BYTE[dwSize];
    ZeroMemory(pdpPlayerInfo, dwSize);
    pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr))
        return hr;

    // Create a new and fill in a APP_PLAYER_INFO
    APP_PLAYER_INFO *pPlayerInfo = new APP_PLAYER_INFO;
    ZeroMemory(pPlayerInfo, sizeof(APP_PLAYER_INFO));
    pPlayerInfo->lRefCount = 1;                
    pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

    // copy players name
	wcsncpy(pPlayerInfo->wstrPlayerName, pdpPlayerInfo->pwszName, MAX_PLAYER_NAME);

    // check for local player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL)
        g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

    // check for host player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_HOST)
        g_dpnidHost = pPlayerInfo->dpnidPlayer;

    // Tell DirectPlay to store this pPlayerInfo pointer in the pvPlayerContext.
    pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

    // increment number of players
    g_dwNumPlayers++;

    return hr;
}

//-----------------------------------------------------------------------------
// Name: DeletePlayer
// Desc: Deletes a player from the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_DELETE_PLAYER
//-----------------------------------------------------------------------------
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg)
{
    APP_PLAYER_INFO *pPlayerInfo;

    // get a pointer to the context of the player being deleted
    pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;

    // release player info
    PLAYER_RELEASE(pPlayerInfo);  

	// decrement # of players
	g_dwNumPlayers--;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceeffect\echo.cpp ===
//-----------------------------------------------------------------------------
// File: Echo.cpp
//
// Desc: Implements an XMO filter to add an echo effect.
//
// Hist: 01.06.00 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "echo.h"




//-----------------------------------------------------------------------------
// Name: XCreateEchoFxMediaObject()
// Desc: Implements a simple synchronous XMO and in-place
//-----------------------------------------------------------------------------
HRESULT XCreateEchoFxMediaObject( XMediaObject** ppMediaObject, DWORD dwDelay,
                                  DWORD dwSampleSize )
{   
    // Create echo filter XMO
    CEchoXMO* pXmo = new CEchoXMO();
    if( NULL == pXmo )
        return E_OUTOFMEMORY;

    if( FAILED( pXmo->Initialize( dwDelay, dwSampleSize ) ) )
    {
        delete pXmo;
        (*ppMediaObject) = NULL;
        return E_FAIL;
    }
    (*ppMediaObject) = pXmo;
    (*ppMediaObject)->AddRef();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CEchoXMO::Initialize( DWORD dwDelay, DWORD dwSampleSize )
{
    // This simple XMO only supports 16 bit samples (2 bytes).
    // However arbitrary sample size can be supported if the Process routine
    // treats input/dst buffers as arrays with proper size element size.
    if( dwSampleSize != (16>>3) )
        return E_INVALIDARG;
    
    m_dwSampleSize = dwSampleSize;
    m_dwDelay      = dwDelay;

    // Allocate a buffer used as the delay line. Caches the previous packet..
    m_pPreviousPacket = new SHORT[dwDelay/dwSampleSize];
    if( NULL == m_pPreviousPacket )
        return E_OUTOFMEMORY;

    ZeroMemory( m_pPreviousPacket, dwDelay/dwSampleSize );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetInfo()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoXMO::GetInfo( XMEDIAINFO* pInfo )
{
    if( NULL==pInfo )
        return E_INVALIDARG;

    // We are a synchronous, in-place XMO
    pInfo->dwFlags = XMO_STREAMF_IN_PLACE;

    // Because we are synchronous and not in place the buffers they pass
    // must be large enough to implement the echo effect. For a synchronous 
    // XMO, maxlookahead is irrelevant
    pInfo->dwInputSize  = m_dwDelay;
    pInfo->dwOutputSize = m_dwDelay;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetStatus()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoXMO::GetStatus( DWORD* pdwFlags )
{
    // Let the caller know if we can accept any more data
    if( pdwFlags )
        (*pdwFlags) = XMO_STATUSF_ACCEPT_INPUT_DATA;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoXMO::Process( const XMEDIAPACKET* pSrcBuffer,
                                             const XMEDIAPACKET* pDstBuffer )
{
    // We need both a destination and source buffer to operate
    if( NULL==pSrcBuffer || NULL==pDstBuffer )
        return E_INVALIDARG;
    if( NULL==pSrcBuffer->pvBuffer || NULL==pDstBuffer->pvBuffer )
        return E_INVALIDARG;

    // Make sure we have enough data to implement the echo effect
    if( ( pSrcBuffer->dwMaxSize < m_dwDelay ) || ( pDstBuffer->dwMaxSize < m_dwDelay ) )
        return E_INVALIDARG;

    SHORT* pDstBufferData = (SHORT*)pDstBuffer->pvBuffer;
    SHORT* pSrcBufferData = (SHORT*)pSrcBuffer->pvBuffer;
    DWORD  dwDelayOffset  = m_dwDelay/m_dwSampleSize;

    // Echo effect
    for( DWORD i=0; i<pDstBuffer->dwMaxSize/m_dwSampleSize; i++ ) 
    {
        SHORT sample = pSrcBufferData[i];

        // Assume 16 bit samples. See comment in Initialize function.
        LONG temp32 = m_pPreviousPacket[i]/2 + (LONG)sample;

        // Clip to avoid noise
        if( temp32 > +32767 )   temp32 = +32767;
        if( temp32 < -32767 )   temp32 = -32767;

        pDstBufferData[i] = (SHORT)temp32;

        // Cache the current src packet for the next call to process
        m_pPreviousPacket[i] = sample;
    }

    if( pDstBuffer->pdwCompletedSize )   *(pDstBuffer->pdwCompletedSize) = pSrcBuffer->dwMaxSize;
    if( pDstBuffer->pdwStatus )          *(pSrcBuffer->pdwStatus)        = XMEDIAPACKET_STATUS_SUCCESS;
    if( pSrcBuffer->pdwCompletedSize )   *(pSrcBuffer->pdwCompletedSize) = pSrcBuffer->dwMaxSize;
    if( pSrcBuffer->pdwStatus )          *(pSrcBuffer->pdwStatus)        = XMEDIAPACKET_STATUS_SUCCESS;

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Font9.h ===
// Automatically generated by the bundler tool from Font9.rdf

#define Font9_NUM_RESOURCES 2UL

#define Font9_Font_OFFSET 0UL
#define Font9_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoiceeffect\xmofilter.h ===
#ifndef XMOFILTER_H_
#define XMOFILTER_H_

// Simple macro to verify that the packet size is OK for a particular XMO
inline HRESULT XMOFILTER_VERIFY_PACKET_SIZE( XMEDIAINFO& xMediaInfo, DWORD dwPacketSize )
{
    if( xMediaInfo.dwOutputSize > dwPacketSize )
        return E_FAIL;
    if( xMediaInfo.dwOutputSize ) 
        if( dwPacketSize%xMediaInfo.dwOutputSize != 0 )
            return E_FAIL;
    if( dwPacketSize < xMediaInfo.dwMaxLookahead )
        return E_FAIL;

    return S_OK;
}




struct LINKED_LIST 
{
    LINKED_LIST* pNext;
    LINKED_LIST* pPrev;

    inline VOID Initialize()         { pNext = pPrev = this; }
    inline BOOL IsListEmpty()        { return pNext == this; }
    inline LINKED_LIST* RemoveHead() { pNext->Remove(); }
    inline LINKED_LIST* RemoveTail() { pPrev->Remove(); }

    inline VOID Remove() 
    {
        LINKED_LIST* pOldNext = pNext;
        LINKED_LIST* pOldPrev = pPrev;
        pOldPrev->pNext = pOldNext;
        pOldNext->pPrev = pOldPrev;
    }

    inline VOID Add( LINKED_LIST* pEntry ) 
    {
        LINKED_LIST* pOldHead = this;
        LINKED_LIST* pOldPrev = this->pPrev;
        pEntry->pNext   = pOldHead;
        pEntry->pPrev   = pOldPrev;
        pOldPrev->pNext = pEntry;
        pOldHead->pPrev = pEntry;
    }
};




// We arrived at this value based on the requirements of the XMOs.
// The idea is to pick an arbitrary packet size, go through the Init function
// once and then if any asserts fires while verifying the packet sizes, change
// the packet to satisfy all requirements
#define PACKET_CNT      10
#define PACKET_SIZE     0x140
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)


struct MEDIA_PACKET_CTX
{
    LINKED_LIST ListEntry;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};

#define INVALID_PORT        0xFFFFFFFF

class CFilterGraph
{
public:
    XMediaObject* m_pSourceXMO;
    XMediaObject* m_pIntermediateXMO;
    XMediaObject* m_pTargetXMO;

    DWORD         m_dwMinPacketSize;
    DWORD         m_dwPacketSize;
    DWORD         m_dwMaxBufferCount;

    WAVEFORMATEX  m_wfxAudioFormat;

    LINKED_LIST   m_SourcePendingList;
    LINKED_LIST   m_TargetPendingList;

    BYTE*         m_pTransferBuffer;
    BYTE*         m_pPacketContextPool;

    ULONGLONG     m_dwReserved;

    HRESULT Init(PWAVEFORMATEX pwfx,
                               XMediaObject *pSourceXmo,
                               XMediaObject *pIntermediateXmo,
                               XMediaObject *pTargetXmo);

    VOID    AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx );
    VOID    AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx );
    HRESULT TransferData();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\LoadSaveResource.h ===
// Automatically generated by the bundler tool from LoadSaveResource.rdf

#define LoadSaveResource_NUM_RESOURCES 11UL

#define LoadSaveResource_Background_OFFSET 0UL
#define LoadSaveResource_PlainBack_OFFSET 20UL
#define LoadSaveResource_Up_OFFSET 40UL
#define LoadSaveResource_Down_OFFSET 60UL
#define LoadSaveResource_MsgBox_OFFSET 80UL
#define LoadSaveResource_MU_OFFSET 100UL
#define LoadSaveResource_MUWide_OFFSET 120UL
#define LoadSaveResource_MU_Sel_OFFSET 140UL
#define LoadSaveResource_Xbox_OFFSET 160UL
#define LoadSaveResource_Xbox_Sel_OFFSET 180UL
#define LoadSaveResource_MU_Bad_OFFSET 200UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Xboxdings_24.h ===
// Automatically generated by the bundler tool from Xboxdings_24.rdf

#define Xboxdings_24_NUM_RESOURCES 2UL

#define Xboxdings_24_Font_OFFSET 0UL
#define Xboxdings_24_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\xvoicegroup\xvoicegroup.cpp ===
//-----------------------------------------------------------------------------
// File: xvoicegroup.cpp
//
// Desc: DirectPlay Voice sample
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <assert.h>

#include "xmenu.h"
#include "xtextbox.h"
#include "xdppeer.h"
#include "xdpvoice.h"


//-----------------------------------------------------------------------------
// UI Stuff
//-----------------------------------------------------------------------------
XTextBox *XBox;									// pun intended
DWORD g_dwMenuCommand;
XMenu *g_MainMenu;								// main menu
XMenu *g_NameMenu;								// choose name menu


//-----------------------------------------------------------------------------
// player status information
//-----------------------------------------------------------------------------
#define VSTATUS_EMPTY		0					// slot is empty
#define VSTATUS_OCCUPIED	1					// slot is occupied
#define VSTATUS_TALKING		2					// slot is talking
#define VSTATUS_INGROUP		4					// slot is member of transmit group

#define MAX_STATUS			8					// max # of players in status
XTextBox *StatusBox;							// player status box (talking/not)
XTextBoxItem *g_pStatus[MAX_STATUS];			// status box items

void UpdateSlot(DWORD slot, WCHAR *tstrName);	// update status line


//-----------------------------------------------------------------------------
// dplay message handler
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg);


//-----------------------------------------------------------------------------
// GUID & port
//-----------------------------------------------------------------------------
GUID g_AppGUID = { 0x9f2da206, 0xd197, 0x4871, { 0xad, 0x1d, 0xd1, 0x2f, 0x59, 0x5, 0x8b, 0x5b } };
DWORD g_dwPort = 2399;							// game port
#define PCPORT 6073								// port for PC game search


//-----------------------------------------------------------------------------
// multiplayer menu
//-----------------------------------------------------------------------------
XMenu *g_MPMenu;								// multiplayer menu
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi);		// init & display MP menu
DWORD Create(DWORD cmd, XMenuItem *mi);			// host a game
DWORD Connect(DWORD cmd, XMenuItem *mi);		// connect to an existing game
DWORD Disconnect(DWORD cmd, XMenuItem *mi);		// disconnect from current game


//-----------------------------------------------------------------------------
// game menu
//-----------------------------------------------------------------------------
XMenu *g_GameMenu;								// game menu
DWORD FindGames(DWORD cmd, XMenuItem *mi);		// find game to join
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi);	// stop finding games to join
void AddGame(ActiveGame *pGame);				// add an active game to game menu
void DeleteGame(ActiveGame *pGame);				// removes an active game from the game menu


//-----------------------------------------------------------------------------
// group menu
//-----------------------------------------------------------------------------
void BuildGroupMenu();							// builds the add/remove menu
DWORD AddToGroup(DWORD cmd, XMenuItem *mi);		// add player to group
DWORD RemoveFromGroup(DWORD cmd, XMenuItem *mi); // remove player from group


//-----------------------------------------------------------------------------
// App specific Player information 
//-----------------------------------------------------------------------------
#define MAX_PLAYER_NAME 14
struct APP_PLAYER_INFO
{
    LONG  lRefCount;							// Ref count so we can cleanup when all threads 
												// are done w/ this object
    DPNID dpnidPlayer;							// DPNID of player
    WCHAR wstrPlayerName[MAX_PLAYER_NAME];		// Player name
	DWORD dwIndex;								// index in textbox
};

#define PLAYER_ADDREF(a)    if(a) a->lRefCount++;
#define PLAYER_RELEASE(a)   if(a) { a->lRefCount--; if(a->lRefCount<=0) delete a; } a = NULL;

HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg);
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg);


//-----------------------------------------------------------------------------
// help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle Help\nMenu Back"},
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_1, L"Menu Activate\nMenu Select"},
    { XBHELP_X_BUTTON,  XBHELP_PLACEMENT_1, L"Group Menu"},
};
#define MAX_NORMAL_HELP_CALLOUTS 3

BOOL g_bDrawHelp = FALSE;
DWORD Help(DWORD cmd, XMenuItem *mi);		// help activate menu item


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font for rendering stats and help
    CXBFont m_Font;
    CXBHelp m_Help;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();
	void InitNameMenu();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// Initialize the help system
    if(FAILED(hr = m_Help.Create(m_pd3dDevice, "Gamepad.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// set menu and text box fonts
	XMenu_SetFont(&m_Font);
	XTextBox_SetFont(&m_Font);

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 10000.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &matProj);

	// init the 'choose player name' menu
	InitNameMenu();

	// init the main menu
	g_MainMenu = XMenu_Init(320.0f, 120.0f, 5, 0, NULL);
	XMenu_SetTitle(g_MainMenu, L"Main Menu", 0xffffff00);
	XMenu_AddItem(g_MainMenu, 0, L"SINGLE PLAYER", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"MULTIPLAYER", DoMPMenu);
	XMenu_AddItem(g_MainMenu, MITEM_SEPARATOR, NULL, NULL);
	XMenu_AddItem(g_MainMenu, 0, L"OPTIONS", NULL);
	XMenu_AddItem(g_MainMenu, MITEM_ROUTINE, L"HELP", Help);

	// init a textbox
	XBox = XTextBox_Init(64, 480.0f-50.0f-(float)m_Font.GetFontHeight()*4.0f,
						640.0f-128.0f, 3, TBOX_POPUP);
	XBox->expiretime = 2000;		// keep messages up for 2 seconds
	XTextBox_AddItem(XBox, L"Welcome to XVoiceGroup");

	// init status textbox
	StatusBox = XTextBox_Init(128.0f, 110.0f, 640.0f-256.0f, 8, 0);
	StatusBox->topcolor = 0xff000000;
	StatusBox->bottomcolor = 0xffc0c000;
	for(DWORD i=0; i<MAX_STATUS; i++)
	{
		g_pStatus[i] = XTextBox_AddItem(StatusBox, L" ");
		g_pStatus[i]->val1 = VSTATUS_EMPTY;
	}

	// init dplay & dvoice
	XDPInit(DPMsgHandler);
	XDVInit(DPMsgHandler);

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	XMenu_Delete(g_MainMenu);
	if(g_MPMenu)
		XMenu_Delete(g_MPMenu);

	// shut down dplay
	XDPShutdown();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// do our dplay and dvoice work
	XDPDoWork(0);
	XDVDoWork();

	// process menu input
	if(!g_bDrawHelp)
	{
		g_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);

		// check for main menu
		if(g_dwMenuCommand==MENU_ACTIVATE && !XMenu_IsActive())
			XMenu_Activate(g_MainMenu);

		// check for group menu
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] && !XMenu_IsActive())
			BuildGroupMenu();
	}

	// check for help screen
	if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK && !XMenu_IsActive())
	{
		g_bDrawHelp = !g_bDrawHelp;
		if(g_bDrawHelp)
			return S_OK;
	}

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	WCHAR s[80];

    // clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0, 1.0f, 0L );

	// process the menu
	XMenu_Routine(g_dwMenuCommand);
	XTextBox_Display(XBox);

	if(!XMenu_IsActive())
		XTextBox_Display(StatusBox);

	// show game title
    m_Font.DrawText(64, 50, 0xffffffff, L"VOICE GROUP");
    m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

	// show our current status
	switch(g_dwConnectStatus)
	{
		case GAME_HOSTING:
			m_Font.DrawText(64, 70, 0xff00ff00, L"HOSTING");
			break;
		case GAME_ENUMERATING:
			m_Font.DrawText(64, 70, 0xffffff00, L"ENUMERATING");
			break;
		case GAME_CONNECTED:
			m_Font.DrawText(64, 70, 0xff00ff00, L"CONNECTED");
			break;
		case GAME_NOTCONNECTED:
			m_Font.DrawText(64, 70, 0xffff0000, L"NOT CONNECTED");
			break;
		case GAME_CONNECTING:
			m_Font.DrawText(64, 70, 0xffffff00, L"CONNECTING");
			break;
	}

	// show # of players
	if(XDPIsConnected())
	{
		swprintf(s, L"%d PLAYERS", g_dwNumPlayers);
		m_Font.DrawText(640-64, 70, 0xffffffff, s, XBFONT_RIGHT);
	}		

	// draw help
	if(g_bDrawHelp)
		m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Help
// Desc: Activates help screen from main menu.
//-----------------------------------------------------------------------------
DWORD Help(DWORD cmd, XMenuItem *mi)
{
	g_bDrawHelp = TRUE;
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: GotName and InitNameMenu
// Desc: Creates a menu of names to choose from. Since we dont have a
//       virtual keyboard, this lets us have clients with different names.
//       Also assembles the host session name to be "playername - XVoiceGroup"
//-----------------------------------------------------------------------------
DWORD GotName(DWORD cmd, XMenuItem *mi)
{
	// set player name
	wcscpy(g_wszXDPPlayerName, mi->string);

	// set session name
	wcscpy(g_wszXDPSessionName, g_wszXDPPlayerName);
	wcscat(g_wszXDPSessionName, L" - XVoiceGroup");

	XMenu_Delete(g_NameMenu);
	XMenu_Activate(g_MainMenu);

	return MROUTINE_RETURN;
}

void CXBoxSample::InitNameMenu()
{
	// init the choose player name menu
	g_NameMenu = XMenu_Init(320.0f, 100.0f, 4, MENU_NOBACK, NULL);
	XMenu_SetTitle(g_NameMenu, L"Choose Name", 0xffffff00);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Maximus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Minimus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Animus", GotName);
	XMenu_AddItem(g_NameMenu, MITEM_ROUTINE, L"Haxor", GotName);
	XMenu_Activate(g_NameMenu);
}

//-----------------------------------------------------------------------------
// Name: DPMsgHandler
// Desc: Direct Play message handler callback routine.
//-----------------------------------------------------------------------------
HRESULT WINAPI DPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
	DPNMSG_CREATE_PLAYER *pCreatePlayerMsg;
	DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg;
	DVMSG_CREATEVOICEPLAYER *pCreateDVPlayerMsg;
	DVMSG_DELETEVOICEPLAYER *pDeleteDVPlayerMsg;
	DVMSG_RECORDSTART *pRecStartMsg;
	DVMSG_RECORDSTOP *pRecStopMsg;
	DVMSG_PLAYERVOICESTART *pVoiceStartMsg;
	DVMSG_PLAYERVOICESTOP *pVoiceStopMsg;

	APP_PLAYER_INFO *pPlayerInfo;
	ActiveGame *pGame;
	WCHAR s[80];

    switch(dwMsgType)
    {
		// handle connecting to the DVoice session after
		// dplay connect is complete
        case DPN_MSGID_CONNECT_COMPLETE:
			if(g_dwConnectStatus!=GAME_HOSTING)
				XDVConnect(DVCLIENTCONFIG_MANUALVOICEACTIVATED);
			break;

		// set transmit targets to nobody when dvoice
		// has finished connecting
		case DVMSGID_CONNECTRESULT:
			XDVClearTransmitTargets();
			break;

		// handle adding and deleting games
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			pGame = XDPAddGame((DPNMSG_ENUM_HOSTS_RESPONSE *)pMsg);
			AddGame(pGame);
			break;
		case DPPEER_MSGID_DELETE_GAME:
			DeleteGame((ActiveGame *)pMsg);
			break;

		// handle player create
        case DPN_MSGID_CREATE_PLAYER:
			pCreatePlayerMsg = (DPNMSG_CREATE_PLAYER *)pMsg;
			CreatePlayer(pCreatePlayerMsg);
			pPlayerInfo = (APP_PLAYER_INFO *)pCreatePlayerMsg->pvPlayerContext;
			swprintf(s, L"%s joined the game.", pPlayerInfo->wstrPlayerName);
			XTextBox_AddItem(XBox, s);
			break;
		case DVMSGID_CREATEVOICEPLAYER:
			pCreateDVPlayerMsg = (DVMSG_CREATEVOICEPLAYER *)pMsg;
			g_pDP->GetPlayerContext(pCreateDVPlayerMsg->dvidPlayer, (void **)&pPlayerInfo, 0);
			PLAYER_ADDREF(pPlayerInfo);
			pCreateDVPlayerMsg->pvPlayerContext = pPlayerInfo;

			// find an open slot in the status table
			pPlayerInfo->dwIndex = -1;
			for(int i=0; i<MAX_STATUS; i++)
				if(g_pStatus[i]->val1==VSTATUS_EMPTY)
				{
					pPlayerInfo->dwIndex = i;
					break;
				}

			assert(pPlayerInfo->dwIndex!=-1);

			// update display slot
			g_pStatus[pPlayerInfo->dwIndex]->val1 = VSTATUS_OCCUPIED;
			g_pStatus[pPlayerInfo->dwIndex]->val2 = (DWORD)pPlayerInfo;
			UpdateSlot(pPlayerInfo->dwIndex, pPlayerInfo->wstrPlayerName);
			break;

		// handle player destroy
        case DPN_MSGID_DESTROY_PLAYER:
			pDestroyPlayerMsg = (DPNMSG_DESTROY_PLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;
			swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
			DeletePlayer(pDestroyPlayerMsg);
			XTextBox_AddItem(XBox, s);
			break;

		case DVMSGID_DELETEVOICEPLAYER:
			pDeleteDVPlayerMsg = (DVMSG_DELETEVOICEPLAYER *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pDeleteDVPlayerMsg->pvPlayerContext;
            swprintf(s, L"%s left the game.", pPlayerInfo->wstrPlayerName);
            XTextBox_AddItem(XBox, s);

			// free slot in the status table
			g_pStatus[pPlayerInfo->dwIndex]->val1 = VSTATUS_EMPTY;
			UpdateSlot(pPlayerInfo->dwIndex, L" ");

			PLAYER_RELEASE(pPlayerInfo);
			break;


		// update player talking/not talking display in 
		// response to these messages
		case DVMSGID_RECORDSTART:
			pRecStartMsg = (DVMSG_RECORDSTART *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pRecStartMsg->pvLocalPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->val1 |= VSTATUS_TALKING;
			UpdateSlot(pPlayerInfo->dwIndex, pPlayerInfo->wstrPlayerName);
			break;

		case DVMSGID_RECORDSTOP:
			pRecStopMsg = (DVMSG_RECORDSTOP *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pRecStopMsg->pvLocalPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->val1 &= ~VSTATUS_TALKING;
			UpdateSlot(pPlayerInfo->dwIndex, pPlayerInfo->wstrPlayerName);
			break;

		case DVMSGID_PLAYERVOICESTART:
			pVoiceStartMsg = (DVMSG_PLAYERVOICESTART *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pVoiceStartMsg->pvPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->val1 |= VSTATUS_TALKING;
			UpdateSlot(pPlayerInfo->dwIndex, pPlayerInfo->wstrPlayerName);
			break;

		case DVMSGID_PLAYERVOICESTOP:
			pVoiceStopMsg = (DVMSG_PLAYERVOICESTOP *)pMsg;
			pPlayerInfo = (APP_PLAYER_INFO *)pVoiceStopMsg->pvPlayerContext;
			g_pStatus[pPlayerInfo->dwIndex]->val1 &= ~VSTATUS_TALKING;
			UpdateSlot(pPlayerInfo->dwIndex, pPlayerInfo->wstrPlayerName);
			break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DoMPMenu
// Desc: Builds multiplayer menu
//-----------------------------------------------------------------------------
DWORD DoMPMenu(DWORD cmd, XMenuItem *mi)
{
	XMenuItem *mitem;

	if(g_MPMenu)
		delete g_MPMenu;

	g_MPMenu = XMenu_Init(320.0f, 100.0f, 4, 0, NULL);
	XMenu_SetTitle(g_MPMenu, L"Multiplayer", 0xffffff00);

	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"CREATE GAME", Create);
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR XBOX GAMES", FindGames);
	mitem->val1 = g_dwPort;
	mitem = XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"SEARCH FOR PC GAMES", FindGames);
	mitem->val1 = PCPORT;
	XMenu_AddItem(g_MPMenu, MITEM_ROUTINE, L"DISCONNECT FROM GAME", Disconnect);

	XMenu_Activate(g_MPMenu);

	return MROUTINE_RETURN;
}


//-----------------------------------------------------------------------------
// Name: Create
// Desc: Host a game
//-----------------------------------------------------------------------------
DWORD Create(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before creating a new game.");
		return MROUTINE_DIE;
	}

	// create the game
	XDPCreate(g_dwPort, &g_AppGUID, 8, 0);
	XDVCreate(DVSESSIONTYPE_PEER, DSCTID_SC06);

	// connect to the dvoice session we just started serving
	XDVConnect(DVCLIENTCONFIG_MANUALVOICEACTIVATED);

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: Disconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
DWORD Disconnect(DWORD cmd, XMenuItem *mi)
{
	// dont try to disconnect if we are not in a game
	if(!XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"You are not connected to a game.");
		return MROUTINE_DIE;
	}

	// disconnect from session
	if(g_dwConnectStatus==GAME_HOSTING)
	{
		XDVStopSession();
		XDVDisconnect();
		XDPTerminate();
	}
	else
	{
		XDVDisconnect();
		XDPDisconnect();
	}

	XTextBox_AddItem(XBox, L"Disconnected from the game.");

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: FindGames
// Desc: Finds active games on the network.
//-----------------------------------------------------------------------------
DWORD FindGames(DWORD cmd, XMenuItem *mi)
{
	// dont try to create if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before searching for new games.");
		return MROUTINE_DIE;
	}

	// init game menu
	if(g_GameMenu)
		XMenu_Delete(g_GameMenu);

	g_GameMenu = XMenu_Init(320.0f, 100.0f, 20, 0, AbortFindGames);
	XMenu_SetTitle(g_GameMenu, L"Games", 0xffffff00);
	g_GameMenu->w = 440.0f;
	XMenu_SetMaxShow(g_GameMenu, 8);

	XMenu_AddItem(g_GameMenu, 0, L"ABORT", NULL);
	XMenu_Activate(g_GameMenu);

	// search for game on port specified in mi->val1
	// this is so we can find games on 2399 (other xboxes) and
	// 6073 (pc's running dx8 dplay)
	// normally you would use g_dwPort value here
	XDPEnumHosts(mi->val1, &g_AppGUID);

	return MROUTINE_RETURN;
}

//-----------------------------------------------------------------------------
// Name: AbortFindGames
// Desc: Aborts finding active games on the network.
//-----------------------------------------------------------------------------
DWORD AbortFindGames(DWORD cmd, XMenuItem *mi)
{
	XDPCancelEnumHosts();
	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: AddGame
// Desc: Adds to the menu of currently active games.
//-----------------------------------------------------------------------------
void AddGame(ActiveGame *pGame)
{
	XMenuItem *mi;
	const DPN_APPLICATION_DESC *pApp;
	WCHAR s[80], name[80];
	DWORD i;

	assert(pGame);

	pApp = &pGame->AppDesc;

	// see if this item already in the menu
	mi = NULL;
	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			mi = &g_GameMenu->items[i];
			break;
		}

	// build menu item string
	wcscpy(name, pApp->pwszSessionName);
	swprintf(s, L"%s (%d, %d/%d)", name, pGame->dwPing, pApp->dwCurrentPlayers, pApp->dwMaxPlayers);

	// add new item to menu or update existing item
	if(!mi)
	{
		mi = XMenu_AddItem(g_GameMenu, MITEM_ROUTINE, s, Connect);
		mi->val1 = (DWORD)pGame;		// save pointer to this game
	}
	else
		XMenu_SetItemText(mi, s);
}

//-----------------------------------------------------------------------------
// Name: DeleteGame
// Desc: Deletes from the menu of currently active games.
//-----------------------------------------------------------------------------
void DeleteGame(ActiveGame *pGame)
{
	DWORD i;

	for(i=0; i<g_GameMenu->nitems; i++)
		if((DWORD)pGame==g_GameMenu->items[i].val1)
		{
			XMenu_DeleteItem(&g_GameMenu->items[i]);
			break;
		}
}

//-----------------------------------------------------------------------------
// Name: Connect
// Desc: Connect to an existing game
//-----------------------------------------------------------------------------
DWORD Connect(DWORD cmd, XMenuItem *mi)
{
	ActiveGame *pGame;

	// dont try to connect if we are already in a game
	if(XDPIsConnected())
	{
		XTextBox_AddItem(XBox, L"Disconnect before connecting to a new game.");
		return MROUTINE_DIE;
	}

	pGame = (ActiveGame *)mi->val1;			// get pointer to desired game
	XDPConnect(&pGame->AppDesc, pGame->pHostAddr, pGame->pDevAddr);

	// we still need to connect to the dvoice session
	// however, we wait until we receive a CONNECT_COMPLETE
	// message. see the CONNECT_COMPLETE message in the message
	// handler for this processing.

	return MROUTINE_DIE;
}

//-----------------------------------------------------------------------------
// Name: CreatePlayer
// Desc: Add a player to the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_CREATE_PLAYER
//-----------------------------------------------------------------------------
HRESULT CreatePlayer(DPNMSG_CREATE_PLAYER *pCreatePlayerMsg)
{
    HRESULT hr;
    DWORD dwSize = 0;
    DPN_PLAYER_INFO *pdpPlayerInfo = NULL;

    // Get the peer info and extract its name
    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr) && hr!=DPNERR_BUFFERTOOSMALL)
        return hr;

    pdpPlayerInfo = (DPN_PLAYER_INFO *) new BYTE[dwSize];
    ZeroMemory(pdpPlayerInfo, dwSize);
    pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

    hr = g_pDP->GetPeerInfo(pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0);
    if(FAILED(hr))
        return hr;

    // Create a new and fill in a APP_PLAYER_INFO
    APP_PLAYER_INFO *pPlayerInfo = new APP_PLAYER_INFO;
    ZeroMemory(pPlayerInfo, sizeof(APP_PLAYER_INFO));
    pPlayerInfo->lRefCount = 1;				   
    pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

	// copy players name
	wcsncpy(pPlayerInfo->wstrPlayerName, pdpPlayerInfo->pwszName, MAX_PLAYER_NAME);

	// check for local player dpnid
	if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_LOCAL)
		g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

	// check for host player dpnid
    if(pdpPlayerInfo->dwPlayerFlags&DPNPLAYER_HOST)
        g_dpnidHost = pPlayerInfo->dpnidPlayer;

    // Tell DirectPlay to store this pPlayerInfo pointer in the pvPlayerContext.
    pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

	// increment number of players
	g_dwNumPlayers++;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: DeletePlayer
// Desc: Deletes a player from the current game.
//       Called from DPMsgHandler in response to DPN_MSGID_DELETE_PLAYER
//-----------------------------------------------------------------------------
void DeletePlayer(DPNMSG_DESTROY_PLAYER *pDestroyPlayerMsg)
{
    APP_PLAYER_INFO *pPlayerInfo;

	// get a pointer to the context of the player being deleted
	pPlayerInfo = (APP_PLAYER_INFO *)pDestroyPlayerMsg->pvPlayerContext;

	// release player info
	PLAYER_RELEASE(pPlayerInfo);  

	// decrement number of players
	g_dwNumPlayers--;
}

//-----------------------------------------------------------------------------
// Name: BuildGroupMenu & related routines
// Desc: Builds the menu of players that can be added to or
//       removed from the group.
//-----------------------------------------------------------------------------
DWORD AddToGroup(DWORD cmd, XMenuItem *mi)
{
	APP_PLAYER_INFO *pPlayerInfo;

	pPlayerInfo = (APP_PLAYER_INFO *)mi->val2;

	g_pStatus[mi->val1]->val1 |= VSTATUS_INGROUP;
	UpdateSlot(mi->val1, pPlayerInfo->wstrPlayerName);

	XDVAddTransmitTarget((DVID)pPlayerInfo->dpnidPlayer);

	return MROUTINE_DIE;
}

DWORD RemoveFromGroup(DWORD cmd, XMenuItem *mi)
{
	APP_PLAYER_INFO *pPlayerInfo;

	pPlayerInfo = (APP_PLAYER_INFO *)mi->val2;

	g_pStatus[mi->val1]->val1 &= ~VSTATUS_INGROUP;
	UpdateSlot(mi->val1, pPlayerInfo->wstrPlayerName);

	XDVRemoveTransmitTarget(pPlayerInfo->dpnidPlayer);

	return MROUTINE_DIE;
}

void BuildGroupMenu()
{
	XMenu *pGroupMenu;
	XMenuItem *mi;
	APP_PLAYER_INFO *pPlayerInfo;
	DWORD i, val;
	WCHAR tstr[80];

	// init the group menu
	pGroupMenu = XMenu_Init(320.0f, 120.0f, MAX_STATUS, 0, NULL);
	XMenu_SetTitle(pGroupMenu, L"Group", 0xffffff00);

	// scan for players to add
	for(i=0; i<MAX_STATUS; i++)
	{
		val = g_pStatus[i]->val1;

		if(val&VSTATUS_OCCUPIED)
		{
			if(!(val&VSTATUS_INGROUP))
			{
				pPlayerInfo = (APP_PLAYER_INFO *)g_pStatus[i]->val2;

				// only add non-local players
				if(pPlayerInfo->dpnidPlayer!=g_dpnidLocalPlayer)
				{
					swprintf(tstr, L"Add %s", pPlayerInfo->wstrPlayerName);

					mi = XMenu_AddItem(pGroupMenu, MITEM_ROUTINE, tstr, AddToGroup);
					mi->val1 = i;
					mi->val2 = (DWORD)pPlayerInfo;
				}
			}
		}
	}

	// scan for players to remove
	for(i=0; i<MAX_STATUS; i++)
	{
		val = g_pStatus[i]->val1;

		if(val&VSTATUS_OCCUPIED)
		{
			if(val&VSTATUS_INGROUP)
			{
				pPlayerInfo = (APP_PLAYER_INFO *)g_pStatus[i]->val2;
				swprintf(tstr, L"Remove %s", pPlayerInfo->wstrPlayerName);

				mi = XMenu_AddItem(pGroupMenu, MITEM_ROUTINE, tstr, RemoveFromGroup);
				mi->val2 = (DWORD)pPlayerInfo;
				mi->val1 = i;
			}
		}
	}

	XMenu_Activate(pGroupMenu);
}


//-----------------------------------------------------------------------------
// Name: UpdateSlot
// Desc: Update player talking information
//-----------------------------------------------------------------------------
void UpdateSlot(DWORD slot, WCHAR *tstrName)
{
	assert(slot>=0 && slot<MAX_STATUS);

	if(g_pStatus[slot]->val1&VSTATUS_INGROUP)
		swprintf(g_pStatus[slot]->string, L"[%s]", tstrName);
	else
		wcsncpy(g_pStatus[slot]->string, tstrName, TBOX_STRINGLEN);

	if(g_pStatus[slot]->val1&VSTATUS_TALKING)
	{
		g_pStatus[slot]->color = 0xff00ff00;
		wcscat(g_pStatus[slot]->string, L" is talking");
	}
	else
		g_pStatus[slot]->color = 0xffffffff;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\LoadSave.cpp ===
//-----------------------------------------------------------------------------
// File: LoadSave.cpp
//
// Desc: Load and save game reference UI
//
// Hist: 02.06.01 - New for March XDK release 
//       03.12.01 - Updated for April XDK release
//       04.13.01 - Updated for May XDK release -- full localization, more
//                  accurate file size calculation
//       05.21.01 - Updated for June XDK release -- new signature calculations,
//                  buttons, text revisions, UI updates
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// This sample is intended to show appropriate functionality only. Please do 
// not lift the graphics for use in your game. A description of the user 
// research that went into the creation of this sample is located in the 
// XDK documentation at Developing for Xbox - Reference User Interface.
// For functionality ideas see the Technical Certification game
//
//-----------------------------------------------------------------------------
#include "LoadSave.h"
#include <XbConfig.h>
#include <cassert>
#include <algorithm>
#include "Text.h"

// The following header file is generated from "LoadSaveResource.rdf" file
// using the Bundler tool. In addition to the header, the tool outputs a binary
// file (LoadSaveResource.xpr) which contains compiled (i.e. bundled) resources
// and is loaded at runtime using the CXBPackedResource class.
#include "LoadSaveResource.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
// Interesting regions of screen UI
const D3DXVECTOR4 g_avUIRects[] = 
{
    // VSafe:    > 40   > 30   < 600  < 450
    //           Left,  Top,   Right, Bottom
    D3DXVECTOR4( 210,   126,   430,   176 ),  // Main: "Save"
    D3DXVECTOR4( 210,   200,   430,   252 ),  // Main: "Load"
    D3DXVECTOR4( 100,   319,   388,   366 ),  // Device: Big description
    D3DXVECTOR4( 225,   305,   516,   378 ),  // Device: Blocks box
    D3DXVECTOR4(  80,    36,   560,    86 ),  // Device: Title box
    D3DXVECTOR4( 229,    43,   458,    93 ),  // Game: Big description
    D3DXVECTOR4( 352,    34,   576,   105 ),  // Game: Blocks box
    D3DXVECTOR4(  64,    34,   220,   103 ),  // Game: Device Image
    D3DXVECTOR4( 340,   111,   576,   366 ),  // Game: Meta desc
    D3DXVECTOR4( 393,   130,   523,   260 ),  // Game: Meta img
    D3DXVECTOR4( 350,   270,   566,   370 ),  // Game: Meta text
    D3DXVECTOR4(  80,   121,   320,   366 ),  // Game: Game listing area
    D3DXVECTOR4( 228,    93,   272,   116 ),  // Game: Up arrow
    D3DXVECTOR4( 228,   371,   272,   394 ),  // Game: Down arrow
    D3DXVECTOR4( 170,   146,   470,   306 ),  // MsgBox: Box
    D3DXVECTOR4( 190,   276,   450,   296 ),  // MsgBox: Progress
    D3DXVECTOR4( 220,   266,   300,   286 ),  // MsgBox: "Yes"
    D3DXVECTOR4( 340,   266,   420,   286 ),  // MsgBox: "No"
};

// Must be this far from center on 0.0 - 1.0 scale
const FLOAT fTHUMB_DEADZONE = 0.35f;

// 2 MUs per port
const DWORD MAX_MEMORY_UNITS = 2 * XGetPortCount();

// Maximum number of storage devices: HD plus all MUs
const DWORD MAX_STORAGE_DEVICES = 1 + MAX_MEMORY_UNITS;

// Maximum number of saved games displayed on screen at any one time
const INT MAX_GAMES_DISPLAYED = 7;

// Maximum number of characters displayed in MU name during error message
// TCR 3-10 Memory Unit Personalization requires we display at least 10 
// characters of the personalized name. The name is formatted 
// "Xbox MU xx (PersonalName)", which includes 12 leading characters.
const DWORD MAX_MU_DISPLAY = 12 + 10;

// Maximum number of saved games per device for cert requirements
const DWORD MAX_SAVED_GAMES = 4096;

// Maximum number of blocks ever displayed for cert requirments
const DWORD MAX_BLOCKS = 50000;

// Name of saved game data file
const CHAR* const strSAVE_FILE = "game.xsv";

// Ellipses
const WCHAR* const strELLIPSES = L"...";

// For maximum read/write efficiency, we choose a large chunk size.
// 128K is the maximum IDE buffer, which should provide the best performance.
const DWORD FILE_CHUNK_BYTES = 128 * 1024;
const DWORD FILE_CHUNK_DWORDS = FILE_CHUNK_BYTES / sizeof(DWORD);

// This sample generates fake saved game data that is some random 
// size between MIN and MAX
const DWORD MIN_SAVE_DATA_CHUNKS = 1;  // 128K
const DWORD MAX_SAVE_DATA_CHUNKS = 16; // 2 MB

// Meta data image sizes
const DWORD IMAGE_META_HDR_SIZE = 2048;             // 2K
const DWORD IMAGE_META_DATA_SIZE = (64 * 64) / 2; // DXT1 is 4 bits per pixel

// Controller repeat values
const FLOAT fINITIAL_REPEAT = 0.333f; // 333 mS
const FLOAT fSTD_REPEAT = 0.04f;      // 40 mS

// Used bar color values
const FLOAT fBAR_FULL = 0.95f;
const FLOAT fBAR_WARN = 0.85f;

// Maximum message box time for status messages
const FLOAT fSTATUS_SECONDS = 0.5f;

// Minimum message box time for device activity messages
const FLOAT fDEVICE_SECONDS = 3.0f;
const FLOAT fHD_DEVICE_SECONDS = 1.0f;

const D3DCOLOR BARCOLOR_NORMAL   = 0xFF00FF00; // Green
const D3DCOLOR BARCOLOR_WARNING  = 0xFFFFFF00; // Yellow
const D3DCOLOR BARCOLOR_FULL     = 0xFFFF0000; // Red
const D3DCOLOR BARCOLOR_PROGRESS = 0xFF00FF00; // Green
const D3DCOLOR BARBORDER         = 0xFF000000; // Black
const D3DCOLOR MB_TEXT_COLOR     = 0xFF000000; // Black

// Space between text and message box border
const FLOAT MB_TEXT_OFFSET = 8.0f;

// Ratio between game and inter-game space
const FLOAT GAME_SPACE_MULTIPLE = 5.0f;

// Selection offset / inter-game space
const FLOAT GAME_SELECTION_RATIO = 3.0f / 4.0f;

// Selection offset for main menu
const FLOAT MAIN_MENU_OFFSET = 20.0f;

const FLOAT BUTTON_Y = 400.0f;          // button text line
const FLOAT BUTTON_OFFSET = 40.0f;      // space between button and text
const D3DCOLOR BUTTON_COLOR = 0xFFFFFFFF;
const D3DCOLOR BUTTON_TEXT  = 0xF0000000;

// Xboxdings font button mappings
const WCHAR BTN_A = L'A';
const WCHAR BTN_B = L'B';
const WCHAR BTN_Y = L'D';

const DWORD FVF_CUSTOMVERTEX = D3DFVF_XYZRHW | D3DFVF_TEX1; // see CUSTOMVERTEX
const DWORD FVF_BARVERTEX = D3DFVF_XYZRHW;




//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: For background vertex buffer
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
};




//-----------------------------------------------------------------------------
// Name: struct XValidationHeader
// Desc: Header information from saved game data file
//-----------------------------------------------------------------------------
struct XValidationHeader
{
    // Length of the file, including header, in bytes
    DWORD dwFileLength;

    // File signature (secure hash of file data)
    XCALCSIG_SIGNATURE Signature;
};




//-----------------------------------------------------------------------------
// Name: class File
// Desc: Helper class for common file operations
//-----------------------------------------------------------------------------
class File
{

    HANDLE m_hFile;

public:

    //-------------------------------------------------------------------------
    // Name: File()
    // Desc: Construct file object
    //-------------------------------------------------------------------------
    File() : m_hFile( INVALID_HANDLE_VALUE )
    {
    }


    //-------------------------------------------------------------------------
    // Name: ~File()
    // Desc: Close file object
    //-------------------------------------------------------------------------
    ~File()
    {
        Close();
    }


    //-------------------------------------------------------------------------
    // Name: Open()
    // Desc: Open the given file; fails if file doesn't exist
    //-------------------------------------------------------------------------
    BOOL Open( const CHAR* strFile, DWORD dwAccess, DWORD dwAttributes = 0 )
    {
        Close();
        m_hFile = CreateFile( strFile, dwAccess, 0, NULL, OPEN_EXISTING,
                              dwAttributes, NULL );
        return( m_hFile != INVALID_HANDLE_VALUE );
    }


    //-------------------------------------------------------------------------
    // Name: Create()
    // Desc: Create the given file
    //-------------------------------------------------------------------------
    BOOL Create( const CHAR* strFile, DWORD dwAccess = GENERIC_WRITE | GENERIC_READ,
                 DWORD dwAttributes = 0 )
    {
        Close();
        m_hFile = CreateFile( strFile, dwAccess, 0, NULL, CREATE_ALWAYS,
                              dwAttributes, NULL );
        return( m_hFile != INVALID_HANDLE_VALUE );
    }


    //-------------------------------------------------------------------------
    // Name: Close()
    // Desc: Close the file handle
    //-------------------------------------------------------------------------
    VOID Close()
    {
        if( m_hFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( m_hFile );
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }


    //-------------------------------------------------------------------------
    // Name: IsOpen()
    // Desc: TRUE if file is open
    //-------------------------------------------------------------------------
    BOOL IsOpen() const
    {
        return( m_hFile != INVALID_HANDLE_VALUE );
    }


    //-------------------------------------------------------------------------
    // Name: GetSize()
    // Desc: Returns the file size in bytes
    //-------------------------------------------------------------------------
    DWORD GetSize() const
    {
        assert( IsOpen() );
        return GetFileSize( m_hFile, NULL );
    }


    //-------------------------------------------------------------------------
    // Name: SetPos()
    // Desc: Set the file pointer to the given position (relative to the
    //       beginning of the file)
    //-------------------------------------------------------------------------
    VOID SetPos( DWORD dwFilePos ) const
    {
        assert( IsOpen() );
        assert( LONG(dwFilePos) >= 0 );
        SetFilePointer( m_hFile, LONG(dwFilePos), NULL, FILE_BEGIN );
    }


    //-------------------------------------------------------------------------
    // Name: Read()
    // Desc: Read data from an open file
    //-------------------------------------------------------------------------
    BOOL Read( VOID* pBuffer, DWORD dwBytesToRead, DWORD& dwBytesRead ) const
    {
        assert( IsOpen() );
        return ReadFile( m_hFile, pBuffer, dwBytesToRead, &dwBytesRead, NULL );
    }


    //-------------------------------------------------------------------------
    // Name: Write()
    // Desc: Write data to an open file
    //-------------------------------------------------------------------------
    BOOL Write( const VOID* pBuffer, DWORD dwBytesToWrite ) const
    {
        assert( IsOpen() );
        DWORD dwBytesWritten;
        BOOL bSuccess = WriteFile( m_hFile, pBuffer, dwBytesToWrite,
                                   &dwBytesWritten, NULL );
        return( bSuccess && dwBytesToWrite == dwBytesWritten );
    }

}; // end File class




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBLoadSave xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBLoadSave::StorageDev()
// Desc: Construct private storage device object
//-----------------------------------------------------------------------------
CXBLoadSave::StorageDev::StorageDev( CHAR chDriveLetter, BOOL bIsMu )
:
    CXBStorageDevice( chDriveLetter ),
    fPercentUsed    ( 0.0f ),
    strTotalBlocks  (),
    strFreeBlocks   (),
    dwState         ( 0 ),
    bIsMU           ( bIsMu ),
    pTextureGood    ( NULL ),
    pTextureBad     ( NULL ),
    pWideTexture    ( NULL ),
    pTexSel         ( NULL ),
    rcRegion        (),
    rcImage         (),
    rcUsed          ()
{
    Refresh();
}




//-----------------------------------------------------------------------------
// Name: CXBLoadSave::StorageDev::SetDevice()
// Desc: Update the storage device to the given logical drive
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StorageDev::SetDevice( CHAR chDriveLetter, BOOL bIsMu )
{
    SetDrive( chDriveLetter );
    bIsMU = bIsMu;
    Refresh();
    dwState = 0;
}




//-----------------------------------------------------------------------------
// Name: CXBLoadSave::StorageDev::SetDeviceState()
// Desc: Mark the device as unusable/full
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StorageDev::SetDeviceState( DWORD dwState )
{
    SetDevice( 0, bIsMU );
    CXBLoadSave::StorageDev::dwState = dwState;
    fPercentUsed = 0.0f;
    if( dwState == StorageDev::MU_FULL )
        fPercentUsed = 1.0f;
}




//-----------------------------------------------------------------------------
// Name: CXBLoadSave::StorageDev::Refresh()
// Desc: Cache device data in printable strings
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StorageDev::Refresh()
{
    // Clear the strings
    *strTotalBlocks = 0;
    *strFreeBlocks = 0;

    // Get the total and used bytes
    ULONGLONG qwTotalBytes;
    ULONGLONG qwUsedBytes;
    ULONGLONG qwFreeBytes;
    if( GetSize( qwTotalBytes, qwUsedBytes, qwFreeBytes ) )
    {
        // Convert to blocks
        DWORD dwBlockSize   = CXBStorageDevice::GetBlockSize();
        DWORD dwTotalBlocks = DWORD( qwTotalBytes / dwBlockSize );
        DWORD dwUsedBlocks  = DWORD( qwUsedBytes / dwBlockSize );
        DWORD dwFreeBlocks  = dwTotalBlocks - dwUsedBlocks;

        // TCR 3-65 Computation of Total MU Capacity
        // Must allow one block for file system data
        /*
           This requirement is currently being reconsidered...
           Contact xboxds@xbox.com for additional information.

        if( bIsMU )
        {
            if( dwTotalBlocks > 1 )
                dwTotalBlocks -= 1;
            else
                dwTotalBlocks = 0;
        }
        */

        // Format with thousands separators

        // To meet cert requirements, any amount over 50,000 blocks is
        // formatted "50,000+"
        if( dwTotalBlocks > MAX_BLOCKS )
            lstrcpyA( strTotalBlocks, strMAX_BLOCKS[ CXBConfig::GetLanguage() ] );
        else
            CXBConfig::FormatInt( dwTotalBlocks, strTotalBlocks );

        if( dwFreeBlocks > MAX_BLOCKS )            
            lstrcpyA( strFreeBlocks, strMAX_BLOCKS[ CXBConfig::GetLanguage() ] );
        else
            CXBConfig::FormatInt( dwFreeBlocks,  strFreeBlocks );

        // Graphical representation must only account for the high 50,000
        // block range. If the device has more than 50,000 blocks, adjust
        // total to 50,000, and scale "used" into the 50,000 section.
        if( dwTotalBlocks > MAX_BLOCKS )
        {
            dwTotalBlocks = MAX_BLOCKS;
            dwUsedBlocks = ( dwFreeBlocks > MAX_BLOCKS ) ? 0 : 
                                                    MAX_BLOCKS - dwFreeBlocks;
        }

        fPercentUsed = FLOAT( dwUsedBlocks ) / FLOAT( dwTotalBlocks );
    }
}




//-----------------------------------------------------------------------------
// Name: StorageDev::Render
// Desc: Renders the storage device image
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StorageDev::Render( BOOL bSelected, 
                                      const CXBLoadSave* pContext ) const
{
    // Selection highlight
    if( bSelected )
        pContext->RenderSelection( rcRegion, 0 );

    // MU or Xbox image
    pContext->RenderTile( rcImage, ( dwState != 0 ) ? pTextureBad : pTextureGood );

    // Used bar
    DWORD dwColor = BARCOLOR_NORMAL;
    if( fPercentUsed > fBAR_FULL )
        dwColor = BARCOLOR_FULL;
    else if( fPercentUsed > fBAR_WARN )
        dwColor = BARCOLOR_WARNING;
    pContext->RenderBar( rcUsed, fPercentUsed, dwColor );
}




//-----------------------------------------------------------------------------
// Name: CXBLoadSave()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBLoadSave::CXBLoadSave()
:
    CXBApplication     (),
    m_xprResource      (),
    m_iLang            ( 0 ),
    m_FontBig          (),
    m_FontMed          (),
    m_FontSmall        (),
    m_FontBtn          (),
    m_Mode             ( MODE_SAVE ),
    m_State            ( START_SCREEN ),
    m_MemUnitList      (),
    m_DeviceList       (),
    m_GameList         (),
    m_iCurrDev         ( 0 ),
    m_iLastMu          ( 1 ),
    m_iCurrGame        ( 0 ),
    m_iTopGame         ( 0 ),
    m_dwSavedGameBytes ( 0 ),
    m_bOverwriteMode   ( FALSE ),
    m_RepeatTimer      ( FALSE ),
    m_fRepeatDelay     ( fINITIAL_REPEAT ),
    m_MsgBoxTimer      ( FALSE ),
    m_fMsgBoxSeconds   ( 0.0f ),
    m_strMessage       (),
    m_Answer           ( ANSWER_YES ),
    m_NextState        ( MENU_MAIN ),
    m_pvbBackground    ( NULL ),
    m_ptBackground     ( NULL ),
    m_ptMsgBox         ( NULL ),
    m_ptPlainBack      ( NULL ),
    m_ptXbox           ( NULL ),
    m_ptMU             ( NULL ),
    m_ptWideMU         ( NULL ),
    m_ptXboxSel        ( NULL ),
    m_ptMUSel          ( NULL ),
    m_ptUp             ( NULL ),
    m_ptDown           ( NULL ),
    m_dwFileErr        ( 0 )
{
    *m_strMessage = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Sets up the load save example
//-----------------------------------------------------------------------------
HRESULT CXBLoadSave::Initialize()
{
    // We support a subset of available languages. If the language
    // isn't supported, switch to English in this sample
    m_iLang = CXBConfig::GetLanguage();
    switch( m_iLang )
    {
        // These languages are supported
        case XC_LANGUAGE_ENGLISH:
        case XC_LANGUAGE_GERMAN:
        case XC_LANGUAGE_FRENCH:
        case XC_LANGUAGE_SPANISH:
        case XC_LANGUAGE_ITALIAN : break;

        // These languages are not
        case XC_LANGUAGE_JAPANESE:
        default: m_iLang = XC_LANGUAGE_ENGLISH; break;
    }

    // Set the matrices
    D3DXVECTOR3 vEye(-2.5f, 2.0f, -4.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEye,&vAt, &vUp );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Create the fonts
    if( FAILED( m_FontBig.Create( m_pd3dDevice, "Font16.xpr" ) ) ||
        FAILED( m_FontMed.Create( m_pd3dDevice, "Font12.xpr" ) ) ||
        FAILED( m_FontSmall.Create( m_pd3dDevice, "Font9.xpr" ) ) ||
        FAILED( m_FontBtn.Create( m_pd3dDevice, "Xboxdings_24.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Reserve memory for the lists. These lists always hold the maximum
    // elements. Valid devices are considered IsMounted() for MUs and
    // IsValid() for storage devices.
    m_MemUnitList.resize( MAX_MEMORY_UNITS );
    m_DeviceList.resize( MAX_STORAGE_DEVICES );

    // Load our textures
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "LoadSaveResource.xpr", 
                                      LoadSaveResource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our textures from the bundled resource
    m_ptXbox       = m_xprResource.GetTexture( (DWORD)LoadSaveResource_Xbox_OFFSET );
    m_ptXboxSel    = m_xprResource.GetTexture( (DWORD)LoadSaveResource_Xbox_Sel_OFFSET );
    m_ptMU         = m_xprResource.GetTexture( (DWORD)LoadSaveResource_MU_OFFSET );
    m_ptWideMU     = m_xprResource.GetTexture( (DWORD)LoadSaveResource_MUWide_OFFSET );
    m_ptMUSel      = m_xprResource.GetTexture( (DWORD)LoadSaveResource_MU_Sel_OFFSET );
    m_ptBackground = m_xprResource.GetTexture( (DWORD)LoadSaveResource_Background_OFFSET );
    m_ptMsgBox     = m_xprResource.GetTexture( (DWORD)LoadSaveResource_MsgBox_OFFSET );
    m_ptPlainBack  = m_xprResource.GetTexture( (DWORD)LoadSaveResource_PlainBack_OFFSET );
    m_ptUp         = m_xprResource.GetTexture( (DWORD)LoadSaveResource_Up_OFFSET );
    m_ptDown       = m_xprResource.GetTexture( (DWORD)LoadSaveResource_Down_OFFSET );
    m_ptMUBad      = m_xprResource.GetTexture( (DWORD)LoadSaveResource_MU_Bad_OFFSET );

    // The first device is always the hard drive
    m_DeviceList[0].SetDevice( CXBStorageDevice::GetUserRegion().GetDrive(), FALSE );
    m_DeviceList[0].pWideTexture = m_ptXbox;
    m_DeviceList[0].pTextureGood = m_ptXbox;
    m_DeviceList[0].pTextureBad  = NULL;
    m_DeviceList[0].pTexSel      = m_ptXboxSel;

    // NOTE: The following rectangles are based off of locations on the background
    // image, and will need to be updated as that art changes
    m_DeviceList[0].rcRegion = D3DXVECTOR4( 154, 101, 490, 227 );
    m_DeviceList[0].rcImage  = D3DXVECTOR4( 193, 104, 447, 211 );
    m_DeviceList[0].rcUsed   = D3DXVECTOR4( 193, 214, 447, 224 );

    for( DWORD i = 0; i < MAX_MEMORY_UNITS; i++ )
    {
        DWORD j = i + 1;

        // Offset between controller regions is 114.0f
        // Offset within a controller region is 45.0f
        m_DeviceList[ j ].pWideTexture = m_ptWideMU;
        m_DeviceList[ j ].pTextureGood = m_ptMU;
        m_DeviceList[ j ].pTextureBad  = m_ptMUBad;
        m_DeviceList[ j ].pTexSel  = m_ptMUSel;
        m_DeviceList[ j ].rcRegion = D3DXVECTOR4( 151.0f + ( i / 2 ) * 91.0f + ( i % 2 ) * 38.0f,
                                                  249.0f,
                                                  181.0f + ( i / 2 ) * 91.0f + ( i % 2 ) * 38.0f,
                                                  296.0f );
        m_DeviceList[ j ].rcImage  = D3DXVECTOR4( 153.0f + ( i / 2 ) * 91.0f + ( i % 2 ) * 38.0f,
                                                  252.0f,
                                                  178.0f + ( i / 2 ) * 91.0f + ( i % 2 ) * 38.0f,
                                                  287.0f );
        m_DeviceList[ j ].rcUsed   = D3DXVECTOR4( 153.0f + ( i / 2 ) * 91.0f + ( i % 2 ) * 38.0f,
                                                  289.0f,
                                                  178.0f + ( i / 2 ) * 91.0f + ( i % 2 ) * 38.0f,
                                                  294.0f );
    }

    // Create our background vertex buffer
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), D3DUSAGE_WRITEONLY, FVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &m_pvbBackground );
    CUSTOMVERTEX* pVertices;
    m_pvbBackground->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Lower left
    pVertices[1].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Upper left
    pVertices[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Lower right
    pVertices[3].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Upper right
    m_pvbBackground->Unlock();

    // Initialize RNG for random game size and random game name.
    // Your game does not need to do this
    srand( GetTickCount() );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame; the entry point for animating the scene
//-----------------------------------------------------------------------------
HRESULT CXBLoadSave::FrameMove()
{
    ValidateState();

    // Process the current state
    switch( m_State )
    {
        case GAME_SAVE:
            if( !SaveGame() )
            {
                m_State = MENU_GAMELIST;

                // See if an MU was pulled...
                if( m_iCurrDev > 0 &&
                    m_dwFileErr == ERROR_DEVICE_NOT_CONNECTED )
                {
                    // TCR 6-1 Surprise MU Removal
                    WCHAR strErr[256];
                    WCHAR strName[ MAX_DEVNAME ];
                    m_MemUnitList[ m_iCurrDev-1 ].GetName( strName );

                    // Truncate long names to fit in message box
                    if( lstrlenW( strName ) > MAX_MU_DISPLAY )
                    {
                        strName[MAX_MU_DISPLAY] = 0;
                        lstrcatW( strName, strELLIPSES );
                    }

                    wsprintfW( strErr, strMU_REMOVED[ m_iLang ], strName,
                               strACTION_SAVE[ m_iLang ] );
                    StartMsgBox( strErr, MENU_GAMELIST );
                }
                else
                {
                    // Generic error
                    StartMsgBox( strSAVE_FAILED[ m_iLang ], MENU_GAMELIST );
                }
            }
            else
            {
                // Leave the save message up for a while to meet 
                // cert requirements.
                // Technically, this box doesn't have to be displayed at all,
                // since these save games can be written in less than 500 mS,
                // but the code is included to show a method of making
                // the message linger for titles that have large save games.
                if( m_MsgBoxTimer.IsRunning() )
                {
                    while( m_MsgBoxTimer.GetElapsedSeconds() < m_fMsgBoxSeconds )
                        ;
                }

                m_State = MENU_GAMELIST;
                StartMsgBox( strGAME_SAVED[ m_iLang ], MENU_GAMELIST, 
                             fSTATUS_SECONDS );

                // Put the cursor where the new game was saved. Your game
                // would probably return to the game proper at this point.
                m_iCurrGame = 1;
                m_iTopGame = 0;
            }
            m_bOverwriteMode = FALSE;
            break;
        case GAME_LOAD:
            if( !LoadGame() )
            {
                // See if an MU was pulled...
                if( m_iCurrDev > 0 &&
                    m_dwFileErr == ERROR_DEVICE_NOT_CONNECTED )
                {
                    WCHAR strErr[256];
                    WCHAR strName[ MAX_DEVNAME ];
                    m_MemUnitList[ m_iCurrDev-1 ].GetName( strName );

                    // Truncate long names to fit in message box
                    if( lstrlenW( strName ) > MAX_MU_DISPLAY )
                    {
                        strName[MAX_MU_DISPLAY] = 0;
                        lstrcatW( strName, strELLIPSES );
                    }

                    wsprintfW( strErr, strMU_REMOVED[ m_iLang ], strName,
                               strACTION_LOAD[ m_iLang ] );
                    m_State = MENU_GAMELIST;
                    StartMsgBox( strErr, MENU_GAMELIST );
                }
                else
                {
                    m_State = MENU_GAMELIST;
                    StartMsgBox( strLOAD_FAILED[ m_iLang ], MENU_GAMELIST );
                }
            }
            else
            {
                // Leave the load message up for a while to meet 
                // cert requirements.
                // Technically, this box doesn't have to be displayed at all,
                // since these save games can be written in less than 500 mS,
                // but the code is included to show a method of making
                // the message linger for titles that have large save games.
                if( m_MsgBoxTimer.IsRunning() )
                {
                    while( m_MsgBoxTimer.GetElapsedSeconds() < m_fMsgBoxSeconds )
                        ;
                }

                m_State = MENU_GAMELIST;
                StartMsgBox( strGAME_LOADED[ m_iLang ], MENU_GAMELIST, 
                             fSTATUS_SECONDS );
            }
            break;
    }

    // Poll the system for events
    Event ev = GetEvent();

    // Update the current state
    UpdateState( ev );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d rendering.
//       This function sets up render states, clears the viewport, and renders
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBLoadSave::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x000000ff, 1.0f, 0L );

    switch( m_State )
    {
        case START_SCREEN:     RenderStartScreen(); break;
        case MENU_GAMELIST:    RenderGameList();    break;
        case MENU_DEVICE:      RenderDevice();      break;
        case MENU_MAIN:        RenderMainMenu();    break;
        case BOX_OVERWRITE:    RenderOverwrite();   break;
        case BOX_DELETE:       RenderDelete();      break;
        case GAME_SAVE:        RenderGameList();    break;
        case GAME_LOAD:        RenderGameList();    break;
        default:               assert( FALSE );     break;
    }
    
    // If we have a message box to display on top of everything, do that now
    if( *m_strMessage != 0 )
    {
        DrawMsgBox( g_avUIRects[MB_MESSAGE], m_strMessage, m_FontBig, 
                    XBFONT_CENTER_X | XBFONT_CENTER_Y );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ValidateState()
// Desc: Check object invariants
//-----------------------------------------------------------------------------
VOID CXBLoadSave::ValidateState() const
{
    assert( m_Mode < MODE_MAX );
    assert( m_State < STATE_MAX );
    assert( m_NextState < STATE_MAX );
    assert( m_iCurrDev < m_DeviceList.size() );
    assert( IsDeviceInserted( m_iCurrDev ) );
    if( m_iCurrDev > 0 )
    {
        // If we're currently sitting on an MU
        assert( m_MemUnitList[ m_iCurrDev - 1 ].IsValid() ||
                m_DeviceList[ m_iCurrDev ].dwState != 0 );
    }
    assert( m_GameList.empty() || m_iCurrGame < m_GameList.size() );
    assert( m_iTopGame <= m_iCurrGame );
    assert( m_iCurrGame < m_iTopGame + MAX_GAMES_DISPLAYED );
    assert( m_Answer < ANSWER_MAX );
}




//-----------------------------------------------------------------------------
// Name: SaveGame()
// Desc: Writes the save game image, the saved game data, and handles 
//       deleting in the overwrite scenario.
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::SaveGame()
{
    // Generate a save game name. Your game would generate its own name based 
    // on the current level, character, or other context information. We 
    // guarantee a unique name by appending a "version"
    WCHAR strGameName[ MAX_GAMENAME ];
    GenerateSavedGameName( strGameName );

    while( GameExists( strGameName ) )
        lstrcatW( strGameName, L" I" );

    // Get the current device drive letter
    StorageDev& CurrDev = m_DeviceList[ m_iCurrDev ];
    CHAR chDestDrive = CurrDev.GetDrive();

    // If we're overwriting and we need the room, delete the container we're
    // overwriting
    BOOL bCurrGameGone = FALSE;
    DWORD dwBytesNeeded;
    if( m_bOverwriteMode && !IsSpaceAvail( &dwBytesNeeded ) )
        bCurrGameGone = m_GameList[ m_iCurrGame ].DeleteGame();

    // Create the saved game container (directory)
    CXBSavedGame SavedGame;
    if( !SavedGame.CreateGame( chDestDrive, strGameName ) )
    {
        // It's possible that there was enough room on the device, but
        // we hit the directory limit. If we're in overwrite mode, then
        // we can delete the old container and try again.
        BOOL bCreate = FALSE;
        if( m_bOverwriteMode && GetLastError() == ERROR_DISK_FULL &&
            !bCurrGameGone )
        {
            bCurrGameGone = m_GameList[ m_iCurrGame ].DeleteGame();
            bCreate = SavedGame.CreateGame( chDestDrive, strGameName );
        }

        if( !bCreate )
        {
            m_dwFileErr = GetLastError();

            // If we were overwriting and the original game is gone, need
            // to update the list
            if( bCurrGameGone )
                DeleteGameFromList();

            // Update the device to account for deleted games
            CurrDev.Refresh();
            return FALSE;
        }
    }

    // Write the game image to disk
    LPDIRECT3DTEXTURE8 pGameImage = GetGameImage( strGameName );
    if( pGameImage != NULL )
    {
        SavedGame.SaveImage( pGameImage );
        pGameImage->Release();
    }

    // Build the saved game data file name
    CHAR strSaveFile[ MAX_PATH ];
    lstrcpynA( strSaveFile, SavedGame.GetDirectory(), MAX_PATH );
    lstrcatA( strSaveFile, strSAVE_FILE );

    // Save the data
    if( !SaveGame( strSaveFile ) )
    {
        m_dwFileErr = GetLastError();

        // If there's a failure writing the data, attempt to
        // remove the entire container
        SavedGame.DeleteGame();

        // If we were overwriting and the original game is gone, need
        // to update the list
        if( bCurrGameGone )
            DeleteGameFromList();

        // Update the device to account for deleted games
        CurrDev.Refresh();

        return FALSE;
    }

    if( m_bOverwriteMode )
    {
        // If we're overwriting and we haven't deleted the container
        // already, do it now. Otherwise the container has been deleted
        // and we just need to adjust the list.
        if( !bCurrGameGone )
            DeleteGame();
        else
            DeleteGameFromList();
    }

    // Update the device to account for the newly saved game
    CurrDev.Refresh();

    // Update the list
    m_GameList.pop_front(); // remove "empty slot"
    m_GameList.push_front( SavedGame ); // add new game
    m_GameList.push_front( CXBSavedGame() ); // replace "empty slot"

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: GetGameImage()
// Desc: Create a texture that represents the game. Your game would get a game-
//       appropriate image, like the current screen shot. This sample simply
//       generates a texture with the name of the save in random colors.
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBLoadSave::GetGameImage( const WCHAR* strGameName ) const
{
    // Generate random colors for meta data image
    BYTE rb = BYTE( rand() % 255 );
    BYTE gb = BYTE( rand() % 255 );
    BYTE bb = BYTE( rand() % 255 );
    BYTE rt = BYTE( rb - 128 );
    BYTE gt = BYTE( gb - 128 );
    BYTE bt = BYTE( bb - 128 );
    D3DCOLOR dwBackgroundColor = D3DCOLOR_RGBA( rb, gb, bb, 0xFF );
    D3DCOLOR dwTextColor = D3DCOLOR_RGBA( rt, gt, bt, 0xFF );

    // Generate a colorful texture with the game name
    return m_FontBig.CreateTexture( strGameName, dwBackgroundColor, dwTextColor );
}




//-----------------------------------------------------------------------------
// Name: SaveGame()
// Desc: Write the saved game data to the current device in file strFile
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::SaveGame( const CHAR* strFile )
{
    // Create the file
    File SavedGameFile;
    if( !SavedGameFile.Create( strFile ) )
        return FALSE;

    // Write the header (we write the official data later)
    XValidationHeader ValHeader;
    ZeroMemory( &ValHeader, sizeof(ValHeader) );
    if( !SavedGameFile.Write( &ValHeader, sizeof(ValHeader) ) )
        return FALSE;

    // Allocate chunk memory
    std::auto_ptr< DWORD > Chunk( new DWORD [ FILE_CHUNK_DWORDS ] );
    DWORD* pChunk = Chunk.get();

    // Generate some bogus save data. Your game would have less than bogus data.
    for( DWORD i = 0; i < FILE_CHUNK_DWORDS; ++i )
        pChunk[ i ] = DWORD( rand() );

    // Start the signature hash
    HANDLE hSignature = XCalculateSignatureBegin( 0 );
    if( hSignature == INVALID_HANDLE_VALUE )
        return FALSE;

    // Save the data a chunk at a time
    BOOL bShowProgress = FALSE;
    CXBStopWatch stopWatch( TRUE );
    DWORD dwSavedGameChunks = m_dwSavedGameBytes / FILE_CHUNK_BYTES;
    for( DWORD i = 0; i < dwSavedGameChunks; ++i )
    {
        // If an MU is removed during the save, this is the most
        // common location for failure
        if( !SavedGameFile.Write( pChunk, FILE_CHUNK_BYTES ) )
        {
            // Release signature resources
            XCalculateSignatureEnd( hSignature, NULL );
            return FALSE;
        }

        // Keep a running file signature (secure hash)
        DWORD dwSuccess = XCalculateSignatureUpdate( hSignature, (BYTE*)(pChunk), 
                                                     FILE_CHUNK_BYTES );
        assert( dwSuccess == ERROR_SUCCESS );
        (VOID)dwSuccess; // avoid compiler warning

        // Avoid showing the progress bar if we're writing to a fast device
        // (e.g. hard drive)
        if( stopWatch.GetElapsedSeconds() > 0.5f )
            bShowProgress = TRUE;

        // Only update twice per second to avoid Present() bottleneck
        if( bShowProgress && stopWatch.GetElapsedSeconds() > 0.5f )
        {
            stopWatch.Reset();

            // Render a progress bar by first rendering the normal screen
            CXBLoadSave::Render();

            // Then draw the bar on top
            FLOAT fProgress = FLOAT(i) / FLOAT( dwSavedGameChunks );
            RenderBar( g_avUIRects[MB_PROGRESS], fProgress, BARCOLOR_PROGRESS );

            // We're in a tight loop here, so we have to call present ourselves
            m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
        }
    }

    // Update the validation header
    ValHeader.dwFileLength = SavedGameFile.GetSize();
    DWORD dwSuccess = XCalculateSignatureEnd( hSignature, 
                                              &ValHeader.Signature );
    assert( dwSuccess == ERROR_SUCCESS );
    (VOID)dwSuccess; // avoid compiler warning
    SavedGameFile.SetPos( 0 );
    if( !SavedGameFile.Write( &ValHeader, sizeof(ValHeader) ) )
        return FALSE;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: LoadGame()
// Desc: Load the selected game data into memory
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::LoadGame()
{
    m_dwFileErr = 0;

    // Get the name of the file
    CHAR strFile[ MAX_PATH ];
    GetSavedGameFileName( strFile );

    // Open the data file
    File SavedGameFile;
    if( !SavedGameFile.Open( strFile, GENERIC_READ ) )
    {
        m_dwFileErr = GetLastError();
        return FALSE;
    }

    // Read the file header
    XValidationHeader ValHeader;
    DWORD dwBytesRead;
    if( !SavedGameFile.Read( &ValHeader, sizeof(ValHeader), dwBytesRead ) )
    {
        m_dwFileErr = GetLastError();
        return FALSE;
    }
    if( dwBytesRead != sizeof(ValHeader) )
        return FALSE;

    // If the MU was removed while the file was being written, dwFileLength
    // will be zero and will not match the actual size
    DWORD dwTotalBytes = SavedGameFile.GetSize();
    if( ValHeader.dwFileLength != dwTotalBytes )
        return FALSE;

    // Allocate chunk memory
    std::auto_ptr< DWORD > Chunk( new DWORD [ FILE_CHUNK_DWORDS ] );
    DWORD* pChunk = Chunk.get();

    // Start the signature hash
    HANDLE hSignature = XCalculateSignatureBegin( 0 );
    if( hSignature == INVALID_HANDLE_VALUE )
        return FALSE;

    // Read the file a chunk at a time until we've read the whole thing.
    // This sample doesn't do anything with the data. Your game would load 
    // the data into game state memory.
    BOOL bShowProgress = FALSE;
    DWORD dwTotalBytesRead = 0;
    CXBStopWatch stopWatch( TRUE );
    for( ;; )
    {
        if( !SavedGameFile.Read( pChunk, FILE_CHUNK_BYTES, dwBytesRead ) )
        {
            m_dwFileErr = GetLastError();

            // Release signature resources
            XCalculateSignatureEnd( hSignature, NULL );
            return FALSE;
        }

        // See if we reached the end
        if( dwBytesRead == 0 )
            break;

        // Keep a running file signature (secure hash)
        DWORD dwSuccess = XCalculateSignatureUpdate( hSignature, (BYTE*)(pChunk),
                                                     dwBytesRead );
        assert( dwSuccess == ERROR_SUCCESS );
        (VOID)dwSuccess; // avoid compiler warning

        // Keep a running total for the progress bar
        dwTotalBytesRead += dwBytesRead;

        // Avoid showing the progress bar if we're reading from a fast device
        // (e.g. hard drive)
        if( stopWatch.GetElapsedSeconds() > 0.5f )
            bShowProgress = TRUE;

        // Only update twice per second to avoid Present() bottleneck
        if( bShowProgress && stopWatch.GetElapsedSeconds() > 0.5f )
        {
            stopWatch.Reset();

            // Render a progress bar by first rendering the normal screen
            CXBLoadSave::Render();

            // Then draw the bar on top
            FLOAT fProgress = FLOAT( dwTotalBytesRead ) / FLOAT( dwTotalBytes );
            RenderBar( g_avUIRects[MB_PROGRESS], fProgress, BARCOLOR_PROGRESS );

            // We're in a tight loop here, so we have to call present ourselves
            m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
        }
    }

    // Validate the signature
    XCALCSIG_SIGNATURE Signature;
    DWORD dwSuccess = XCalculateSignatureEnd( hSignature, &Signature );
    assert( dwSuccess == ERROR_SUCCESS );
    (VOID)dwSuccess; // avoid compiler warning
    if( memcmp( &Signature, &ValHeader.Signature, sizeof(XCALCSIG_SIGNATURE) ) != 0 )
        return FALSE;

    // File is OK
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: GameExists()
// Desc: TRUE if the saved game already exists
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::GameExists( const WCHAR* strGameName ) const
{
    for( SavedGameIndex i = 0; i < m_GameList.size(); ++i )
    {
        const CXBSavedGame& SavedGame = m_GameList[ i ];
        if( lstrcmpW( SavedGame.GetName(), strGameName ) == 0 )
            return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Polls the controller and MU for events. Returns EV_NULL if no event
//-----------------------------------------------------------------------------
CXBLoadSave::Event CXBLoadSave::GetEvent()
{
    // Query the primary controller
    Event evControllerClick = GetControllerEvent();

    // If the controller isn't doing anything, check MU status
    if( evControllerClick == EV_NULL )
        return GetMemoryUnitEvent();

    return evControllerClick;
}




//-----------------------------------------------------------------------------
// Name: IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            return TRUE;
    }

    // Check thumbsticks
    // Check thumbsticks
    if( pGamePad->fX1 >  fTHUMB_DEADZONE ||
        pGamePad->fX1 < -fTHUMB_DEADZONE ||
        pGamePad->fY1 >  fTHUMB_DEADZONE ||
        pGamePad->fY1 < -fTHUMB_DEADZONE )
    {
        return TRUE;
    }

    if( pGamePad->fX2 >  fTHUMB_DEADZONE ||
        pGamePad->fX2 < -fTHUMB_DEADZONE ||
        pGamePad->fY2 >  fTHUMB_DEADZONE ||
        pGamePad->fY2 < -fTHUMB_DEADZONE )
    {
        return TRUE;
    }

    // Nothing active
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: GetControllerEvent()
// Desc: Polls the controller for events. Handles button repeats.
//-----------------------------------------------------------------------------
CXBLoadSave::Event CXBLoadSave::GetControllerEvent()
{
    const XBGAMEPAD* pGamePad = GetPrimaryController();
    if( pGamePad != NULL )
    {
        // Handle button press and joystick hold repeats
        if( IsAnyButtonActive( pGamePad ) )
        {
            // If the timer is running, the button is being held. If it's
            // held long enough, it triggers a repeat. If the timer isn't
            // running, we start it.
            if( m_RepeatTimer.IsRunning() )
            {
                // If the timer is running but hasn't expired, bail out
                if( m_RepeatTimer.GetElapsedSeconds() < m_fRepeatDelay )
                    return EV_NULL;

                m_fRepeatDelay = fSTD_REPEAT;
                m_RepeatTimer.StartZero();
            }
            else
            {
                m_fRepeatDelay = fINITIAL_REPEAT;
                m_RepeatTimer.StartZero();
            }
        }
        else
        {
            // No buttons or joysticks active; kill the repeat timer
            m_fRepeatDelay = fINITIAL_REPEAT;
            m_RepeatTimer.Stop();
        }

        // Movement
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_UP ||
            pGamePad->fY1 > fTHUMB_DEADZONE )
            return EV_UP;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
            pGamePad->fY1 < -fTHUMB_DEADZONE )
            return EV_DOWN;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
            pGamePad->fX1 < -fTHUMB_DEADZONE )
            return EV_LEFT;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
            pGamePad->fX1 > fTHUMB_DEADZONE )
            return EV_RIGHT;

        // Only "cursor control" buttons allow repeats, so if
        // we get this far, we can kill the repeat timer
        m_fRepeatDelay = fINITIAL_REPEAT;
        m_RepeatTimer.Stop();

        // Primary buttons
        if( pGamePad->wPressedButtons & XINPUT_GAMEPAD_START )
            return EV_START_BUTTON;
        if( pGamePad->wPressedButtons & XINPUT_GAMEPAD_BACK )
            return EV_BACK_BUTTON;
        if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
            return EV_A_BUTTON;
        if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
            return EV_B_BUTTON;
        if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
            return EV_X_BUTTON;
        if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
            return EV_Y_BUTTON;
    }

    // No controllers inserted or no button presses
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: GetMemoryUnitEvent()
// Desc: Polls the controllers for MU insertions and removals.
//-----------------------------------------------------------------------------
CXBLoadSave::Event CXBLoadSave::GetMemoryUnitEvent()
{
    // If no MU updates, no event registered
    DWORD dwInsertions;
    DWORD dwRemovals;
    if( !CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        return EV_NULL;

    // Handle removals first
    for( DWORD i = 0; i < MAX_MEMORY_UNITS; ++i )
    {
        if( dwRemovals & CXBMemUnit::GetMemUnitMask( i ) )
        {
            // Invalidate the device and unmount the MU. Must be in this
            // order so that any XFindFirstSavedGame() search handle is closed
            // before the MU is unmounted.
            m_DeviceList[ i+1 ].SetDevice( 0, TRUE );
            m_MemUnitList[ i ].Remove();
        }
    }

    // Insertions
    for( DWORD i = 0; i < MAX_MEMORY_UNITS; ++i )
    {
        if( dwInsertions & CXBMemUnit::GetMemUnitMask( i ) )
        {
            // Mark the MU as inserted/valid
            DWORD dwPort = CXBMemUnit::GetMemUnitPort( i );
            DWORD dwSlot = CXBMemUnit::GetMemUnitSlot( i );
            m_MemUnitList[ i ].Insert( dwPort, dwSlot );

            // Attempt to mount the MU. If mount fails, get error condition
            // and set state appropriately
            DWORD dwError;
            if( m_MemUnitList[ i ].Mount( dwError ) )
                m_DeviceList[ i+1 ].SetDevice( m_MemUnitList[ i ].GetDrive(), TRUE );
            else
                m_DeviceList[ i+1 ].SetDeviceState( GetMuState( dwError ) );
        }
    }

    return EV_MU_CHANGE;
}




//-----------------------------------------------------------------------------
// Name: GetMuState()
// Desc: Translates the GetLastError() code into a state bitmask
//-----------------------------------------------------------------------------
DWORD CXBLoadSave::GetMuState( DWORD dwError ) // static
{
    // The MU failed to mount; check for error conditions.
    switch( dwError )
    {
        // MU is full (of other games)
        case ERROR_DISK_FULL:
            return StorageDev::MU_FULL;

        // MU is already mounted (should never happen in our code)
        case ERROR_ALREADY_ASSIGNED:
            assert( FALSE );
            return 0;

        // MU was removed during the XMountMU call. We ignore this
        // situation, because it will be detected the next time we
        // call XGetDeviceChanges
        case ERROR_DEVICE_NOT_CONNECTED:
            return 0;

        // Allocation failure (mark MU as "unusable").
        // The game is in big trouble at this point, because memory
        // is way too low. Note that ERROR_OUTOFMEMORY can also 
        // indicate mounting more devices than requested in XInitDevices().
        case ERROR_OUTOFMEMORY:
        case ERROR_NO_SYSTEM_RESOURCES:
            return StorageDev::MU_UNUSABLE;

        // Any other error indicates the the MU is probably unusable
        // and should be reformatted
        default:
            return StorageDev::MU_UNUSABLE;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateState()
// Desc: State machine updates the current context based on the incoming event
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateState( Event ev )
{
    if( *m_strMessage != 0 )
    {
        // Check the message box timer
        if( m_MsgBoxTimer.IsRunning() && 
            m_MsgBoxTimer.GetElapsedSeconds() > m_fMsgBoxSeconds )
        {
            // Timer expired; message box goes away
            m_MsgBoxTimer.Stop();
            m_State = m_NextState;
            *m_strMessage = 0;
        }

        // Check for events
        switch( ev )
        {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
        case EV_B_BUTTON:
        case EV_BACK_BUTTON:
            m_State = m_NextState;
            *m_strMessage = 0;
            break;
        case EV_MU_CHANGE:
            // If the current device was an MU and it was removed, we
            // set the current device to the HD and back out to the device
            // list for safety.
            if( !IsDeviceInserted( m_iCurrDev ) )
            {
                m_iCurrDev = 0;
                m_State = MENU_DEVICE;
                m_NextState = MENU_DEVICE;
            }
            break;
        }
    }
    else switch( m_State )
    {
        case START_SCREEN:     UpdateStateStartScreen( ev ); break;
        case MENU_MAIN:        UpdateStateMainMenu( ev );    break;
        case MENU_DEVICE:      UpdateStateDevice( ev );      break;
        case MENU_GAMELIST:    UpdateStateGameList( ev );    break;
        case BOX_OVERWRITE:    UpdateStateOverwrite( ev );   break;
        case BOX_DELETE:       UpdateStateDelete( ev );      break;
        default:               assert( FALSE );              break;
    }

}




//-----------------------------------------------------------------------------
// Name: UpdateStateStartScreen()
// Desc: Update start screen state
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateStateStartScreen( Event ev )
{
    switch( ev )
    {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
            m_State = MENU_MAIN;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateMainMenu()
// Desc: Update main menu state
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateStateMainMenu( Event ev )
{
    switch( ev )
    {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
            // If any MUs inserted, allow device selection, otherwise
            // go directly to the hard drive game list
            if( AnyMemoryUnitsInserted() )
                m_State = MENU_DEVICE;
            else
            {
                // If loading from hard drive and no games, error message
                if( m_Mode == MODE_LOAD && 
                    m_DeviceList[ 0 ].GetSavedGameCount() == 0 )
                {
                    StartMsgBox( strNO_SAVES[ m_iLang ], MENU_MAIN );
                }
                else
                {
                    BuildGameList();
                    m_State = MENU_GAMELIST;
                }
            }

            // Generate a random size for the save game data. It's always evenly
            // divisible by the FILE_CHUNK_BYTES to avoid read/write special cases.
            if( m_Mode == MODE_SAVE )
            {
                DWORD dwChunkRange = MAX_SAVE_DATA_CHUNKS - MIN_SAVE_DATA_CHUNKS;
                DWORD dwChunks = DWORD( rand() ) % dwChunkRange;
                m_dwSavedGameBytes = ( MIN_SAVE_DATA_CHUNKS + dwChunks ) 
                                     * FILE_CHUNK_BYTES;
            }
            break;
        case EV_UP:
        case EV_DOWN:
            // Toggle between save/load
            m_Mode = ( m_Mode == MODE_SAVE ) ? MODE_LOAD : MODE_SAVE;
            break;
        case EV_MU_CHANGE:
            // If the current device was an MU and it was removed, we
            // set the current device to the HD
            if( !IsDeviceInserted( m_iCurrDev ) )
                m_iCurrDev = 0;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateDevice()
// Desc: Update device menu state
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateStateDevice( Event ev )
{
    switch( ev )
    {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
        {
            // If we selected a memory unit, attempt to mount it
            StorageDev& CurrDev = m_DeviceList[ m_iCurrDev ];
            if( m_iCurrDev > 0 )
            {
                CXBMemUnit& CurrMu = m_MemUnitList[ m_iCurrDev-1 ];
                DWORD dwError;

                // This call won't do anything but return TRUE if the MU is
                // already mounted.
                if( CurrMu.Mount( dwError ) )
                    CurrDev.SetDevice( CurrMu.GetDrive(), TRUE );
                else
                    CurrDev.SetDeviceState( GetMuState( dwError ) );
            }


            // TCR 2-22 Unusable MUs
            if( CurrDev.dwState & StorageDev::MU_UNUSABLE )
            {
                StartMsgBox( strMU_UNUSABLE[ m_iLang ], MENU_DEVICE );
                break;
            }
            if( CurrDev.dwState & StorageDev::MU_FULL )
            {
                StartMsgBox( strMU_FULL[ m_iLang ], MENU_DEVICE );
                break;
            }

            BuildGameList();
            if( m_Mode == MODE_SAVE )
            {
                // Check for space. If there's any possibility that games
                // could be stored on the device (even if other games have
                // to be deleted), we go to the game list
                if( !IsSpaceAvail() )
                {
                    StartMsgBox( m_iCurrDev == 0 ? strNO_ROOM_HD[ m_iLang ] : 
                                                   strNO_ROOM_MU[ m_iLang ], 
                                 MENU_DEVICE );
                    break;
                }
            }
            else // MODE_LOAD
            {
                // Check for our games
                if( CurrDev.GetSavedGameCount() == 0 )
                {
                    StartMsgBox( strNO_SAVES[ m_iLang ], MENU_DEVICE );
                    break;
                }
            }

            // Good to go
            m_State = MENU_GAMELIST;
            break;
        }
        case EV_B_BUTTON:
        case EV_BACK_BUTTON:
            m_State = MENU_MAIN;
            break;
        case EV_MU_CHANGE:
            // Do nothing if the current device wasn't removed,
            // otherwise move to the hard drive
            if( IsDeviceInserted( m_iCurrDev ) )
                break;
            // fall thru
        case EV_UP:
            // If on HD, do nothing, else move to HD
            if( m_iCurrDev > 0 )
                m_iCurrDev = 0;
            break;
        case EV_DOWN:
            // If on MU, do nothing, else move to the last MU we were on.
            // If last MU invalid, move to first valid MU
            if( m_iCurrDev == 0 )
            {
                if( IsDeviceInserted( m_iLastMu ) )
                    m_iCurrDev = m_iLastMu;
                else
                {
                    for( StorageDevIndex i = 1; i < MAX_STORAGE_DEVICES; ++i )
                    {
                        if( IsDeviceInserted( i ) )
                        {
                            m_iLastMu = m_iCurrDev = i;
                            break;
                        }
                    }
                }
            }
            break;
        case EV_LEFT:
            // If on HD, do nothing, else move to previous valid MU
            if( m_iCurrDev > 0 )
            {
                for( StorageDevIndex i = m_iCurrDev-1; i > 0; --i )
                {
                    if( IsDeviceInserted( i ) )
                    {
                        m_iLastMu = m_iCurrDev = i;
                        break;
                    }
                }
            }
            break;
        case EV_RIGHT:
            // If on HD, do nothing, else move to next valid MU
            if( m_iCurrDev > 0 )
            {
                for( StorageDevIndex i = m_iCurrDev+1; i < MAX_STORAGE_DEVICES; ++i )
                {
                    if( IsDeviceInserted( i ) )
                    {
                        m_iCurrDev = i;
                        break;
                    }
                }
                // Remember the last MU we were on
                m_iLastMu = m_iCurrDev;
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateGameList()
// Desc: Update game list state
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateStateGameList( Event ev )
{
    switch( ev )
    {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
            if( m_Mode == MODE_LOAD )
            {
                WCHAR strLoad[256];
                m_State = GAME_LOAD;

                lstrcpyW( strLoad, strLOADING[ m_iLang ] );
                if( m_iCurrDev == 0 )
                    lstrcatW( strLoad, strDO_NOT_POWEROFF[ m_iLang ] );
                else
                {
                    lstrcatW( strLoad, L"\n" );
                    lstrcatW( strLoad, strDO_NOT_REMOVE_MU[ m_iLang ] );
                }

                StartMsgBox( strLoad, GAME_LOAD, fDEVICE_SECONDS );
            }
            else // MODE_SAVE
            {
                // If saving in the empty slot
                if( m_iCurrGame == 0 )
                {
                    // Is there room in the slot?
                    DWORD dwBytesNeeded;
                    if( !IsSpaceAvail( &dwBytesNeeded ) )
                    {
                        StartMsgBoxFree();
                    }
                    
                    // Have we reached the limit of saves?
                    // Note that m_GameList includes the empty slot, so
                    // we use > instead of >=.
                    else if( m_GameList.size() > MAX_SAVED_GAMES )
                    {
                        StartMsgBox( strMAX_SAVED_GAMES[ m_iLang ], 
                                     MENU_GAMELIST );
                    }

                    else
                    {
                        // Begin the save
                        m_State = GAME_SAVE;
                        StartMsgBoxSave();
                    }
                }
                else // overwrite
                {
                    // Is there room if existing game is deleted?
                    DWORD dwBytesNeeded;
                    if( !IsSpaceAvail( &dwBytesNeeded ) )
                    {
                        if( m_GameList[ m_iCurrGame ].GetSize() < dwBytesNeeded )
                        {
                            StartMsgBoxFree();
                            break;
                        }
                    }

                    // There's enough room
                    m_State = BOX_OVERWRITE;
                    m_Answer = ANSWER_NO;
                    m_NextState = GAME_SAVE;
                }
            }
            break;
        case EV_B_BUTTON:
        case EV_BACK_BUTTON:
            // If any MUs inserted, return to the device list,
            // otherwise go back to the main menu
            m_State = ( AnyMemoryUnitsInserted() ) ? MENU_DEVICE : MENU_MAIN;
            break;
        case EV_UP:
            // If we're at the top of the displayed list, shift the display
            if( m_iCurrGame == m_iTopGame )
            {
                if( m_iTopGame > 0 )
                    --m_iTopGame;
            }
            // Move to previous game
            if( m_iCurrGame > 0 )
                --m_iCurrGame;
            break;
        case EV_DOWN:
            // If we're at the bottom of the displayed list, shift the display
            if( m_iCurrGame == m_iTopGame + MAX_GAMES_DISPLAYED - 1 )
            {
                if( m_iTopGame + MAX_GAMES_DISPLAYED < m_GameList.size() )
                    ++m_iTopGame;
            }
            // Move to next game
            if( m_iCurrGame < m_GameList.size() - 1 )
                ++m_iCurrGame;
            break;
        case EV_MU_CHANGE:
            // If the current device was removed, back out
            if( !IsDeviceInserted( m_iCurrDev ) )
            {
                m_iCurrDev = 0;
                m_State = MENU_DEVICE;
            }
            break;
        case EV_Y_BUTTON:
            // If we're not on the empty slot, allow delete to proceed
            if( !m_GameList[ m_iCurrGame ].IsEmpty() )
            {
                m_State = BOX_DELETE;
                m_Answer = ANSWER_NO;
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateOverwrite()
// Desc: Update overwrite box state
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateStateOverwrite( Event ev )
{
    switch( ev )
    {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
            if( m_Answer == ANSWER_YES )
            {
                // Begin the save
                m_bOverwriteMode = TRUE;
                m_State = GAME_SAVE;
                StartMsgBoxSave();
            }
            else // ANSWER_NO
            {
                m_State = MENU_GAMELIST;
            }
            break;
            
        case EV_B_BUTTON:
        case EV_BACK_BUTTON:
            m_State = MENU_GAMELIST;
            break;

        case EV_UP:
        case EV_DOWN:
        case EV_LEFT:
        case EV_RIGHT:
            m_Answer = ( m_Answer == ANSWER_YES ) ? ANSWER_NO : ANSWER_YES;
            break;

        case EV_MU_CHANGE:
            // If the current device was removed, back out
            if( !IsDeviceInserted( m_iCurrDev ) )
            {
                m_iCurrDev = 0;
                m_State = MENU_DEVICE;
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateDelete()
// Desc: Update delete box state
//-----------------------------------------------------------------------------
VOID CXBLoadSave::UpdateStateDelete( Event ev )
{
    switch( ev )
    {
        case EV_A_BUTTON:
        case EV_START_BUTTON:
            if( m_Answer == ANSWER_YES )
            {
                DeleteGame();

                // Stay in the list unless we deleted the last game
                m_State = m_GameList.empty() ? MENU_MAIN : MENU_GAMELIST;

                // Refresh the device
                m_DeviceList[ m_iCurrDev ].Refresh();

            }
            else // ANSWER_NO
            {
                m_State = MENU_GAMELIST;
            }
            break;
            
        case EV_B_BUTTON:
        case EV_BACK_BUTTON:
            m_State = MENU_GAMELIST;
            break;

        case EV_UP:
        case EV_DOWN:
        case EV_LEFT:
        case EV_RIGHT:
            m_Answer = ( m_Answer == ANSWER_YES ) ? ANSWER_NO : ANSWER_YES;
            break;

        case EV_MU_CHANGE:
            // If the current device was removed, back out
            if( !IsDeviceInserted( m_iCurrDev ) )
            {
                m_iCurrDev = 0;
                m_State = MENU_DEVICE;
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: StartMsgBox()
// Desc: Change the state so that a message box is displayed with the given
//       message. When the message box is dismissed, the next state will
//       be stNext.
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StartMsgBox( const WCHAR* strMessage, State stNext,
                               FLOAT fDisplaySeconds )
{
    lstrcpynW( m_strMessage, strMessage, MAX_MESSAGE );
    m_NextState = stNext;
    m_fMsgBoxSeconds = fDisplaySeconds;
    m_MsgBoxTimer.Stop();
    if( fDisplaySeconds > 0.0f )
        m_MsgBoxTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: StartMsgBoxSave()
// Desc: Display the "saving game" message
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StartMsgBoxSave()
{
    WCHAR strSave[256];
    FLOAT fDeviceSeconds = 0.0f;

    // Hard disk
    if( m_iCurrDev == 0 )
    {
        // TCR 3-9 Hard Disk Warning
        lstrcpynW( strSave, strSAVING[ m_iLang ], 256 );

        // TCR 6-4 Hard Disk Write Warning would apply if save lasted
        // longer than 3 seconds.
        // lstrcatW( strSave, strDO_NOT_POWEROFF[ m_iLang ] );

        fDeviceSeconds = fHD_DEVICE_SECONDS;
    }
    else // MU
    {
        WCHAR strName[ MAX_DEVNAME ];
        m_MemUnitList[ m_iCurrDev-1 ].GetName( strName );

        // Truncate long names to fit in message box
        if( lstrlenW( strName ) > MAX_MU_DISPLAY )
        {
            strName[MAX_MU_DISPLAY] = 0;
            lstrcatW( strName, strELLIPSES );
        }

        // TCR 3-8 Memory Unit Warning
        // TCR 6-2 MU Write Warning
        wsprintfW( strSave, strSAVING_MU[ m_iLang ], strName );
        lstrcatW( strSave, strDO_NOT_REMOVE_MU[ m_iLang ] );
        fDeviceSeconds = fDEVICE_SECONDS;
    }

    StartMsgBox( strSave, GAME_SAVE, fDeviceSeconds );
}




//-----------------------------------------------------------------------------
// Name: StartMsgBoxFree()
// Desc: Display the number of blocks that must be free before the current
//       game can be saved.
//-----------------------------------------------------------------------------
VOID CXBLoadSave::StartMsgBoxFree()
{
    // Convert to blocks
    DWORD dwBlocksToFree = GetSavedGameSize() / CXBStorageDevice::GetBlockSize();
    WCHAR strFree[256];
    wsprintfW( strFree, m_iCurrDev == 0 ? strNO_ROOM_HD_PLZ_FREE[ m_iLang ] : 
               strNO_ROOM_MU_PLZ_FREE[ m_iLang ], dwBlocksToFree );
    StartMsgBox( strFree, MENU_GAMELIST );
}




//-----------------------------------------------------------------------------
// Name: RenderStartScreen()
// Desc: Display start screen
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderStartScreen() const
{
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetStreamSource( 0, m_pvbBackground, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->SetTexture( 0, m_ptPlainBack );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetTexture( 0, NULL );

    m_FontMed.DrawText( 320.0f, 80.0f, 0xF0000000,
                        L"This sample is intended to show appropriate\n"
                        L"functionality only. Please do not lift the\n"
                        L"graphics for use in your game.\n\n"
                        L"Source code for this sample is located at\n"
                        L"Samples\\Xbox\\ReferenceUI\\LoadSave.\n\n"
                        L"A description of the user research that\n"
                        L"went into the creation of this sample is\n"
                        L"located in the XDK documentation at\n"
                        L"Developing for Xbox - Reference User Interface.\n\n"
                        L"For functionality ideas see the\n"
                        L"Technical Certification game.",
                        XBFONT_CENTER_X );

    if( m_iLang != XC_LANGUAGE_ENGLISH )
    {
        m_FontMed.DrawText( 320.0f, 350.0f, 0xF0000000,
                            L"Localized terminology not final.\n"
                            L"See Xbox Guide for final terms.",
                            XBFONT_CENTER_X );
    }

    WCHAR strButton[2] = { BTN_A, 0 };
    m_FontBtn.DrawText( 280.0f, BUTTON_Y, BUTTON_COLOR, strButton );
    m_FontBig.DrawText( 280.0f + BUTTON_OFFSET, BUTTON_Y, BUTTON_TEXT, L"continue" );
}




//-----------------------------------------------------------------------------
// Name: RenderMainMenu()
// Desc: Display main menu
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderMainMenu() const
{
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetStreamSource( 0, m_pvbBackground, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->SetTexture( 0, m_ptPlainBack );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetTexture( 0, NULL );

    RenderSelection( g_avUIRects[ m_Mode ], MAIN_MENU_OFFSET );
    DrawMsgBox( g_avUIRects[MM_SAVE], strSAVE_GAME[ m_iLang ], m_FontBig,
                XBFONT_CENTER_X | XBFONT_CENTER_Y );
    DrawMsgBox( g_avUIRects[MM_LOAD], strLOAD_GAME[ m_iLang ], m_FontBig,
                XBFONT_CENTER_X | XBFONT_CENTER_Y );

    m_FontSmall.DrawText( 320.0f, 320.0f, 0xF0000000, strILLUS_GRAPHICS[ m_iLang ],
                          XBFONT_CENTER_X );

    DrawButton( 280.0f, BTN_A );
}




//-----------------------------------------------------------------------------
// Name: RenderDevice()
// Desc: Display device menu
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderDevice() const
{
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetStreamSource( 0, m_pvbBackground, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->SetTexture( 0, m_ptBackground );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetTexture( 0, NULL );

    // Show statistics for selected device
    const StorageDev& CurrDev = m_DeviceList[m_iCurrDev];
    WCHAR strStats[256];
    wsprintfW( strStats, strFORMAT_DEVICE[ m_iLang ], CurrDev.strTotalBlocks, 
               CurrDev.strFreeBlocks );
    DrawMsgBox( g_avUIRects[DS_BLOCKBOX], strStats, m_FontSmall, XBFONT_RIGHT );

    // Show device full name
    WCHAR strName[ MAX_DEVNAME ];
    if( m_iCurrDev == 0 )
        lstrcpynW( strName, strXHD[ m_iLang ], MAX_DEVNAME );
    else
        m_MemUnitList[ m_iCurrDev-1 ].GetName( strName );

    // Handle MU error conditions
    if( CurrDev.dwState & StorageDev::MU_UNUSABLE )
        lstrcpynW( strName, strUNUSABLE_MU_NAME[ m_iLang ], MAX_DEVNAME );
    else if( CurrDev.dwState & StorageDev::MU_FULL )
        lstrcpynW( strName, strFULL_MU_NAME[ m_iLang ], MAX_DEVNAME );

    DrawMsgBox( g_avUIRects[DS_MAINDESC], strName, m_FontBig, XBFONT_RIGHT );

    // Show header
    WCHAR strHeader[256];
    wsprintfW( strHeader, m_Mode == MODE_LOAD ? strCHOOSE_LOAD[ m_iLang ] : 
                                                strCHOOSE_SAVE[ m_iLang ] );
    DrawMsgBox( g_avUIRects[DS_TITLE], strHeader, m_FontBig,
                XBFONT_CENTER_X | XBFONT_CENTER_Y );

    // Render each inserted device image
    for( DWORD i = 0; i < MAX_STORAGE_DEVICES; ++i )
    {
        if( IsDeviceInserted( i ) )
            m_DeviceList[ i ].Render( m_iCurrDev == i, this );
    }

    DrawButton( 80.0f, BTN_A );
    DrawButton( 460.0f, BTN_B );
}




//-----------------------------------------------------------------------------
// Name: RenderGameList()
// Desc: Display game list for the current device
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderGameList() const
{
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetStreamSource( 0, m_pvbBackground, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->SetTexture( 0, m_ptPlainBack );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetTexture( 0, NULL );

    // Device image
    const StorageDev& CurrDev = m_DeviceList[ m_iCurrDev ];
    RenderTile( g_avUIRects[GS_DEVICEIMG], CurrDev.pWideTexture );

    // Show current device statistics
    WCHAR strStats[256];
    wsprintfW( strStats, strFORMAT_DEVICE[ m_iLang ], CurrDev.strTotalBlocks, 
               CurrDev.strFreeBlocks );
    DrawMsgBox( g_avUIRects[GS_BLOCKBOX], strStats, m_FontSmall, XBFONT_RIGHT );

    // Show device full name
    WCHAR strName[ MAX_DEVNAME ];
    if( m_iCurrDev == 0 )
        lstrcpynW( strName, strXHD[ m_iLang ], MAX_DEVNAME );
    else
        m_MemUnitList[ m_iCurrDev-1 ].GetName( strName );

    // Show selected game image
    const CXBSavedGame& CurrGame = m_GameList[ m_iCurrGame ];
    DrawMsgBox( g_avUIRects[GS_META], L"", m_FontBig, 0 );
    LPDIRECT3DTEXTURE8 pGameImage;
    if( CurrGame.GetImage( &pGameImage ) )
    {
        RenderTile( g_avUIRects[GS_METAIMG], pGameImage );
        pGameImage->Release();
    }

    // Show selected game name/size/date/time. "Empty slot" gets today/now
    WCHAR strDate[32];
    WCHAR strTime[32];
    CHAR strBlocks[32];
    DWORD dwBlocks = 0;
    if( CurrGame.IsEmpty() )
    {
        lstrcpynW( strDate, strTODAY[ m_iLang ], 32 );
        lstrcpynW( strTime, strNOW[ m_iLang ], 32 );

        // Show the size of the game to be saved
        dwBlocks = GetSavedGameSize() / CXBStorageDevice::GetBlockSize();
    }
    else
    {
        FILETIME ftLastWriteTime = CurrGame.GetLastWriteTime();
        CXBConfig::FormatDateTime( ftLastWriteTime, strDate, strTime );

        DWORD dwSaveBytes = CurrGame.GetSize();
        dwBlocks = dwSaveBytes / CXBStorageDevice::GetBlockSize();
    }

    CXBConfig::FormatInt( dwBlocks, strBlocks );
    wsprintfW( strStats, strFORMAT_GAME[ m_iLang ], CurrGame.GetName(), strBlocks, 
               strDate, strTime );
    m_FontMed.DrawText( g_avUIRects[GS_METATEXT].x, g_avUIRects[GS_METATEXT].y,
                        0xFF000000, strStats, 0 );

    // Display list of games
    DWORD j = 0;
    FLOAT fUnit = ( g_avUIRects[GS_GAMELIST].w - g_avUIRects[GS_GAMELIST].y ) / 
                  ( MAX_GAMES_DISPLAYED * GAME_SPACE_MULTIPLE + 
                  ( MAX_GAMES_DISPLAYED - 1 ) );
    FLOAT fHeight = GAME_SPACE_MULTIPLE * fUnit;
    FLOAT fSpacing = ( GAME_SPACE_MULTIPLE + 1 ) * fUnit;
    for( DWORD i = m_iTopGame; i < m_GameList.size() && 
                               j < MAX_GAMES_DISPLAYED; ++i, ++j )
    {
        const CXBSavedGame& SavedGame = m_GameList[ i ];

        // The top slot is the "empty space" for new saves
        WCHAR strGame[ MAX_GAMENAME ];
        lstrcpynW( strGame, SavedGame.IsEmpty() ? strEMPTY_SPACE[ m_iLang ] : 
                                                  SavedGame.GetName(), MAX_GAMENAME );

        D3DXVECTOR4 vec = g_avUIRects[GS_GAMELIST];
        vec.y = g_avUIRects[GS_GAMELIST].y + j * fSpacing;
        vec.w = vec.y + fHeight;
        if( i == m_iCurrGame )
            RenderSelection( vec, GAME_SELECTION_RATIO * fUnit );

        // Each game is its own "box"
        DrawMsgBox( vec, strGame, m_FontMed, XBFONT_CENTER_Y );
    }

    // Show scroll arrows
    BOOL bShowTopArrow = m_iTopGame > 0;
    BOOL bShowBtmArrow = m_iTopGame + MAX_GAMES_DISPLAYED < m_GameList.size();
    if( bShowTopArrow )
        RenderTile( g_avUIRects[GS_UP], m_ptUp );
    if( bShowBtmArrow )
        RenderTile( g_avUIRects[GS_DOWN], m_ptDown );

    // Buttons
    DrawButton( 80.0f, BTN_A );
    DrawButton( 270.0f, BTN_Y );
    DrawButton( 460.0f, BTN_B );
}




//-----------------------------------------------------------------------------
// Name: RenderOverwrite()
// Desc: Display "overwrite" question
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderOverwrite() const
{
    RenderGameList();
    DrawMsgBox( g_avUIRects[MB_MESSAGE], strOVERWRITE[ m_iLang ], m_FontBig, 
                XBFONT_CENTER_X | XBFONT_CENTER_Y );
    RenderYesNo();
}




//-----------------------------------------------------------------------------
// Name: RenderDelete()
// Desc: Display "delete" question
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderDelete() const
{
    RenderGameList();
    DrawMsgBox( g_avUIRects[MB_MESSAGE], strDELETE[ m_iLang ], m_FontBig, 
                XBFONT_CENTER_X | XBFONT_CENTER_Y );
    RenderYesNo();
}




//-----------------------------------------------------------------------------
// Name: RenderYesNo()
// Desc: Display Yes/No boxes
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderYesNo() const
{
    RenderSelection( m_Answer == ANSWER_YES ? g_avUIRects[MB_YES] : 
                                              g_avUIRects[MB_NO], 10.0f );
    m_FontBig.DrawText( ( g_avUIRects[MB_YES].x + g_avUIRects[MB_YES].z ) / 2,
                        ( g_avUIRects[MB_YES].y + g_avUIRects[MB_YES].w ) / 2,
                        0xFF000000, strYES[ m_iLang ], 
                        XBFONT_CENTER_X | XBFONT_CENTER_Y );

    m_FontBig.DrawText( ( g_avUIRects[MB_NO].x + g_avUIRects[MB_NO].z ) / 2,
                        ( g_avUIRects[MB_NO].y + g_avUIRects[MB_NO].w ) / 2,
                        0xFF000000, strNO[ m_iLang ], 
                        XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: DrawButton()
// Desc: Display button image and descriptive text
//-----------------------------------------------------------------------------
VOID CXBLoadSave::DrawButton( FLOAT fX, WCHAR chButton ) const
{
    const WCHAR* strText = NULL;
    switch( chButton )
    {
        case BTN_A : strText = strA_SELECT[ m_iLang ]; break;
        case BTN_B : strText = strB_BACK  [ m_iLang ]; break;
        case BTN_Y : strText = strY_DELETE[ m_iLang ]; break;
        default : assert( FALSE ); return;
    }
    WCHAR strButton[2] = { chButton, 0 };

    m_FontBtn.DrawText( fX, BUTTON_Y, BUTTON_COLOR, strButton );
    m_FontBig.DrawText( fX + BUTTON_OFFSET, BUTTON_Y, BUTTON_TEXT, strText );
}




//-----------------------------------------------------------------------------
// Name: DrawMsgBox
// Desc: Draws some text inside of a message box tile
//-----------------------------------------------------------------------------
VOID CXBLoadSave::DrawMsgBox( const D3DXVECTOR4& rc, const WCHAR* strMessage,
                              CXBFont& Font, DWORD dwFlags ) const
{
    CXBFont* pFont = &Font;

    // Render the message box tile
    RenderTile( rc, m_ptMsgBox );

    // Figure out our text position, offset into the box
    FLOAT x;
    if( dwFlags & XBFONT_RIGHT )
        x = rc.z - MB_TEXT_OFFSET;
    else if ( dwFlags & XBFONT_CENTER_X )
        x = rc.x + ( rc.z - rc.x ) / 2;
    else
        x = rc.x + MB_TEXT_OFFSET;

    FLOAT y;
    if( dwFlags & XBFONT_CENTER_Y )
        y = rc.y + ( rc.w - rc.y ) / 2;
    else
        y = rc.y + MB_TEXT_OFFSET;

    // TCR 3-26 Unsupported Characters
    WCHAR strMessageX[1024];
    lstrcpynW( strMessageX, strMessage, 1024 );
    Font.ReplaceInvalidChars( strMessageX, L'\x7F' );

    // If the text is not preformatted (no linefeeds), check the text width
    const WCHAR* strDraw = strMessageX;
    WCHAR strText[1024];
    if( wcschr( strMessageX, L'\n' ) == NULL )
    {
        FLOAT fWidth;
        FLOAT fHeight;
        pFont->GetTextExtent( strMessageX, &fWidth, &fHeight );
        FLOAT fMaxWidth = rc.z - rc.x - MB_TEXT_OFFSET - MB_TEXT_OFFSET;

        // If the text is too large
        if( fWidth > fMaxWidth )
        {
            // First try a smaller font
            if( pFont == &m_FontBig )
                pFont = &m_FontMed;

            pFont->GetTextExtent( strMessageX, &fWidth, &fHeight );

            // If the text is still too large, shrink to fit
            if( fWidth > fMaxWidth )
            {
                // Account for ellipses
                FLOAT fDotWidth;
                FLOAT fDotHeight;
                pFont->GetTextExtent( strELLIPSES, &fDotWidth, &fDotHeight );

                lstrcpyW( strText, strMessageX );
                strDraw = strText;

                // Remove characters from the end of the text
                // until the text and ellipses fit
                WCHAR* pEnd = strText + lstrlenW( strText ) - 1;
                do
                {
                    *pEnd = 0;
                    --pEnd;
                    pFont->GetTextExtent( strText, &fWidth, &fHeight );
                } while( pEnd != strText && ( fWidth + fDotWidth ) > fMaxWidth );

                // Append ellipses
                lstrcatW( strText, strELLIPSES );
            }
        }
    }

    // Draw the text
    pFont->DrawText( x, y, MB_TEXT_COLOR, strDraw, dwFlags );
}




//-----------------------------------------------------------------------------
// Name: RenderTile
// Desc: Renders the texture at the given rect.  If bPulse is TRUE, also 
//       does an alpha-blend pulse based on the application time (for
//       things like selections textures)
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderTile( const D3DXVECTOR4& rc, 
                              const LPDIRECT3DTEXTURE8 pTile,
                              BOOL bPulse ) const
{
    if( pTile == NULL )
        return;

    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW|D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    if( bPulse )
    {
        // If we're pulsing, calculate the alpha, and set up the texture stage
        FLOAT fPulse = (FLOAT)( cos( 4.0f * m_fTime ) + 1.0f ) / 3.0f + 1.0f / 3.0f;
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, DWORD( fPulse * 255 ) << 24 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    }

    // Set up our state
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    m_pd3dDevice->SetTexture( 0, pTile );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetTexture( 0, NULL );

    if( bPulse )
    {
        // Clean up our alpha state
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    }

    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: RenderBar
// Desc: Renders a progress bar at the given rect, fPercent full
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderBar( const D3DXVECTOR4& vecBar, FLOAT fPercent,
                             DWORD dwColor ) const
{
    struct BARVERTEX
    { 
        D3DXVECTOR4 p;
    };

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    m_pd3dDevice->CreateVertexBuffer( 9 * sizeof( BARVERTEX ), D3DUSAGE_WRITEONLY,
                                      FVF_BARVERTEX, D3DPOOL_MANAGED, &pvbTemp );

    // Create vertices for the filled-in bar and for the outer border
    BARVERTEX* pVertices;
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );

    // Quad for filled-in section
    pVertices[0].p = D3DXVECTOR4( vecBar.x - 0.5f, vecBar.w - 0.5f, 1.0f, 1.0f );
    pVertices[1].p = D3DXVECTOR4( vecBar.x - 0.5f, vecBar.y - 0.5f, 1.0f, 1.0f );
    pVertices[2].p = D3DXVECTOR4( vecBar.x + fPercent*(vecBar.z - vecBar.x) - 0.5f,
                                  vecBar.w - 0.5f, 1.0f, 1.0f );
    pVertices[3].p = D3DXVECTOR4( vecBar.x + fPercent*(vecBar.z - vecBar.x) - 0.5f,
                                  vecBar.y - 0.5f, 1.0f, 1.0f );
    
    // Line-strip rectangle for border
    pVertices[4].p = D3DXVECTOR4( vecBar.x, vecBar.w, 1.0f, 1.0f );
    pVertices[5].p = D3DXVECTOR4( vecBar.x, vecBar.y, 1.0f, 1.0f );
    pVertices[6].p = D3DXVECTOR4( vecBar.z, vecBar.y, 1.0f, 1.0f );
    pVertices[7].p = D3DXVECTOR4( vecBar.z, vecBar.w, 1.0f, 1.0f );
    pVertices[8].p = D3DXVECTOR4( vecBar.x, vecBar.w, 1.0f, 1.0f );
    pvbTemp->Unlock();

    m_pd3dDevice->SetVertexShader( FVF_BARVERTEX );
    m_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( BARVERTEX ) );
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );

    // First render the filled-in-section in BARCOLOR
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Then render the linestrip border in BARBORDER
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, BARBORDER );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINESTRIP, 4, 4 );

    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: RenderSelection
// Desc: Renders the selection texture, with a given border around the 
//       rectangle
//-----------------------------------------------------------------------------
VOID CXBLoadSave::RenderSelection( const D3DXVECTOR4& rc, FLOAT fOffset ) const
{
    D3DXVECTOR4 vec = rc;

    vec.x -= fOffset;
    vec.y -= fOffset;
    vec.z += fOffset;
    vec.w += fOffset;

    RenderTile( vec, m_ptXboxSel, TRUE );
}




//-----------------------------------------------------------------------------
// Name: IsDeviceInserted
// Desc: TRUE if given device is available (even if unusable/full). The hard
//       disk is always inserted.
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::IsDeviceInserted( DWORD i ) const
{
    // Hard disk
    if( i == 0 )
        return m_DeviceList[ i ].IsValid();

    return m_MemUnitList[ i-1 ].IsValid();
}




//-----------------------------------------------------------------------------
// Name: AnyMemoryUnitsInserts()
// Desc: TRUE if any MUs are currently available for load/save
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::AnyMemoryUnitsInserted() const
{
    for( DWORD i = 1; i < MAX_STORAGE_DEVICES; ++i )
    {
        if( IsDeviceInserted( i ) )
            return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: IsSpaceAvail()
// Desc: TRUE if space is available for the save game data on the current
//       device, even if other saves have to be deleted. If other saves
//       have to be deleted, returns the bytes that must be deleted
//       in the optional pBytesNeeded param.
//       Bytes needed is cluster based, and is always evenly divisible by
//       the cluster size of the device.
//-----------------------------------------------------------------------------
BOOL CXBLoadSave::IsSpaceAvail( DWORD* pBytesNeeded ) const
{
    if( pBytesNeeded != NULL )
        *pBytesNeeded = 0;

    // Examine the device storage statistics
    const StorageDev& CurrDev = m_DeviceList[ m_iCurrDev ];
    ULONGLONG qwTotalBytes;
    ULONGLONG qwUsedBytes;
    ULONGLONG qwFreeBytes;
    CurrDev.GetSize( qwTotalBytes, qwUsedBytes, qwFreeBytes );

    // Scads o' space
    if( qwFreeBytes > ULONGLONG( ULONG_MAX ) )
        return TRUE;

    // Convert to DWORD
    DWORD dwFreeBytes = DWORD( qwFreeBytes );

    // Plenty o' space
    if( GetSavedGameSize() < dwFreeBytes )
        return TRUE;

    // Determine the number of bytes that would need to be deleted
    if( pBytesNeeded != NULL )
    {
        *pBytesNeeded = GetSavedGameSize() - dwFreeBytes;
        return FALSE;
    }

    // Scan through the size of games on the device to see if there might
    // be room
    DWORD dwGameBytes = 0;
    for( SavedGameIndex i = 0; i < m_GameList.size(); ++i )
    {
        const CXBSavedGame& SavedGame = m_GameList[ i ];
        dwGameBytes += SavedGame.GetSize();

        if( GetSavedGameSize() < dwFreeBytes + dwGameBytes )
            return TRUE;
    }

    // Not enough room, even if games were deleted
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: DeleteGame()
// Desc: Remove the selected saved game container and update the game list
//-----------------------------------------------------------------------------
VOID CXBLoadSave::DeleteGame()
{
    // Free up the space and adjust the list
    if( m_GameList[ m_iCurrGame ].DeleteGame() )
        DeleteGameFromList();
}




//-----------------------------------------------------------------------------
// Name: DeleteGame( SavedGameIndex )
// Desc: Remove the given game from the game list
//-----------------------------------------------------------------------------
VOID CXBLoadSave::DeleteGameFromList()
{
    // Remove the element from the list
    SavedGameIndex j = 0;
    SavedGameList::iterator i;
    for( i = m_GameList.begin(); i != m_GameList.end() && j < m_iCurrGame; ++i, ++j )
        ;
    assert( i != m_GameList.end() );
    m_GameList.erase( i );

    // Adjust the current game index if we were on the last game
    if( m_iCurrGame == m_GameList.size() )
    {
        if( m_iCurrGame > 0 )
            --m_iCurrGame;
    }

    // Adjust the top element if the last pane of games displayed
    if( m_iTopGame + MAX_GAMES_DISPLAYED - 1 == m_GameList.size() )
    {
        if( m_iTopGame > 0 )
            --m_iTopGame;
    }
}




//-----------------------------------------------------------------------------
// Name: SortByLastWriteTime()
// Desc: Sorting predicate for std::sort function in BuildGameList(). The
//       game list is sorted by last write time (most recent first).
//-----------------------------------------------------------------------------
bool CXBLoadSave::SortByLastWriteTime( const CXBSavedGame& lhs, 
                                       const CXBSavedGame& rhs ) // static
{
    return( lhs.GetLastWriteQword() > rhs.GetLastWriteQword() );
}




//-----------------------------------------------------------------------------
// Name: BuildGameList()
// Desc: Constructs the list of games on the current device. If we're in save
//       mode, includes an "empty space" game in the top slot. Games are sorted
//       by last write time, most recent first.
//-----------------------------------------------------------------------------
VOID CXBLoadSave::BuildGameList()
{
    const StorageDev& CurrDev = m_DeviceList[ m_iCurrDev ];

    // Nuke the previous list, if any
    m_GameList.clear();

    // Begin timing the load
    CXBStopWatch stopWatch( TRUE );

    // Build the list of all games on the device
    XGAME_FIND_DATA XgameFindData;
    if( CurrDev.FindFirstSaveGame( XgameFindData ) )
    {
        m_GameList.push_back( CXBSavedGame( XgameFindData ) );
        while( CurrDev.FindNextSaveGame( XgameFindData ) )
        {
            m_GameList.push_back( CXBSavedGame( XgameFindData ) );

            // If there are lots of games to load, display a message
            if( stopWatch.GetElapsedSeconds() > 0.5f )
            {
                // Render a progress bar by first rendering the normal screen
                CXBLoadSave::Render();

                // Then draw the message on top
                DrawMsgBox( g_avUIRects[MB_MESSAGE], strLOADING_GAME_LIST[ m_iLang ],
                            m_FontBig, XBFONT_CENTER_X | XBFONT_CENTER_Y );

                // We're in a tight loop here, so we have to call present ourselves
                m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
            }
        }
    }

    // Sort the list by last write time (most recent first)
    std::sort( m_GameList.begin(), m_GameList.end(), SortByLastWriteTime );

    // If we're saving, then add an "empty slot" at the top of the list
    if( m_Mode == MODE_SAVE )
        m_GameList.push_front( CXBSavedGame() );

    // Always begin at the top of the list
    m_iTopGame = m_iCurrGame = 0;
}




//-----------------------------------------------------------------------------
// Name: GetSavedGameFileName()
// Desc: Returns the full path to the saved game data file for the current
//       save game
//-----------------------------------------------------------------------------
VOID CXBLoadSave::GetSavedGameFileName( CHAR* strFile ) const
{
    assert( strFile != NULL );
    const CXBSavedGame& SavedGame = m_GameList[ m_iCurrGame ];

    // Get the game directory
    lstrcpynA( strFile, SavedGame.GetDirectory(), MAX_PATH );

    // Append the game file name
    lstrcatA( strFile, strSAVE_FILE );
}




//-----------------------------------------------------------------------------
// Name: GetSavedGameSize()
// Desc: Returns the total number of bytes required to save the game
//-----------------------------------------------------------------------------
DWORD CXBLoadSave::GetSavedGameSize() const
{
    const StorageDev& CurrDev = m_DeviceList[ m_iCurrDev ];

    DWORD dwSaveGameSize = CurrDev.GetFileBytes( m_dwSavedGameBytes + 
                                                 sizeof( XValidationHeader ) );
    DWORD dwImageSize = CurrDev.GetFileBytes( IMAGE_META_HDR_SIZE + 
                                             IMAGE_META_DATA_SIZE );
    DWORD dwOverhead = CurrDev.GetSaveGameOverhead();

    return( dwSaveGameSize + dwImageSize + dwOverhead );
}




//-----------------------------------------------------------------------------
// Name: GenerateSavedGameName()
// Desc: Uses the patented "Never Fails Save Game Naming Kit" to derive a fake
//       name for the saved game. Your game would typically generate a name
//       based on the current level, character, or other game context
//       information. Using the virtual keyboard to enter a game name should
//       only be done as a last resort.
//-----------------------------------------------------------------------------
VOID CXBLoadSave::GenerateSavedGameName( WCHAR* strName ) // static
{
    struct GameName
    {
        WCHAR* strAdj;
        WCHAR* strNoun;
    };
    const INT MAX_NAME = 16;
    GameName NameList[ MAX_NAME ] =
    {
        { L"Hydro",    L"Fortress" },
        { L"Roller",   L"Castle"   },
        { L"Opposing", L"Level"    },
        { L"Final",    L"Ruins"    },
        { L"Monkey",   L"Island"   },
        { L"Wicked",   L"Hamster"  },
        { L"Battle",   L"Zone"     },
        { L"Dark",     L"Corridor" },   
        { L"Delta",    L"Tundra"   },
        { L"Evil",     L"Core"     },
        { L"Galactic", L"Patrol"   },
        { L"Mech",     L"Fields"   },
        { L"Red",      L"Vista"    },
        { L"Shadow",   L"Company"  },
        { L"Hamster",  L"Sewers"   },
        { L"Power",    L"Outpost"  }   
    };

    // Choose one word from each column
    INT nColumnOne = rand() % MAX_NAME;
    INT nColumnTwo = rand() % MAX_NAME;

    // Build the name
    lstrcpyW( strName, NameList[ nColumnOne ].strAdj );
    lstrcatW( strName, L" " );
    lstrcatW( strName, NameList[ nColumnTwo ].strNoun );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Text.cpp ===
//-----------------------------------------------------------------------------
// File: Text.cpp
//
// Desc: All text for LoadSave sample in single place to simplify localization
//
// Hist: 04.10.01 - Added for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Text.h"





//-----------------------------------------------------------------------------
// Order of text matches XC_LANGUAGE_XXX #definitions in Xbox.h
//-----------------------------------------------------------------------------

const WCHAR* const strSAVE_FAILED[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Unable to save game.\n"
    L"Press A to continue",

    L"",

    L"Spiel konnte nicht\n"
    L"gespeichert werden", // DE

    L"Impossible d'enregistrer\n"
    L"la partie", // FR

    L"Fallo al guardar\n"
    L"la partida", // ES

    L"Impossibile salvare\n"
    L"la partita", // IT
};

const WCHAR* const strGAME_SAVED[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Game Saved",
    L"",
    L"Spiel wurde gespeichert", // DE
    L"La partie est enregistr" L"\xE9" L"e", // FR
    L"Partida guardada", // ES
    L"Partita salvata", // IT
};

const WCHAR* const strLOAD_FAILED[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Unable to load game.\n"
    L"Press A to continue",

    L"",

    L"Spiel konnte nicht\n"
    L"geladen werden", // DE

    L"Impossible de charger\n"
    L"la partie", // FR

    L"Fallo al cargar\n"
    L"la partida", // ES

    L"Impossibile caricare\n"
    L"la partita", // IT
};

const WCHAR* const strGAME_LOADED[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Game Loaded",
    L"",
    L"Spiel wurde geladen", // DE
    L"La partie est charg" L"\xE9" L"e", // FR
    L"Partida cargada", // ES
    L"Partita caricata", // IT
};

const WCHAR* const strNO_ROOM_MU[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The memory unit does not\n"
    L"have enough free blocks\n"
    L"for this saved game.",

    L"",

    L"F" L"\xFC" L"r das gespeicherte Spiel\n"
    L"sind nicht ausreichend freie\n"
    L"Blocks auf der Speicherkarte\n"
    L"vorhanden", // DE

    L"Il n'y a pas assez de blocs\n"
    L"libres dans l'unit" L"\xE9" L" de\n"
    L"m" L"\xE9" L"moire pour enregistrer\n"
    L"cette partie", // FR

    L"La unidad de memoria no\n"
    L"dispone de suficientes\n"
    L"bloques para la partida\n"
    L"guardada", // ES

    L"I blocchi disponibili\n"
    L"sull'unit" L"\xE0" L" di memoria non sono\n"
    L"sufficienti per questa\n"
    L"partita salvata", // IT
};

const WCHAR* const strNO_ROOM_HD[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The hard disk does not\n"
    L"have enough free blocks\n"
    L"for this saved game.",

    L"",

    // Need to be updated for HD translations ...
    L"F" L"\xFC" L"r das gespeicherte Spiel\n"
    L"sind nicht ausreichend freie\n"
    L"Blocks auf der Speicherkarte\n"
    L"vorhanden", // DE

    L"Il n'y a pas assez de blocs\n"
    L"libres dans l'unit" L"\xE9" L" de\n"
    L"m" L"\xE9" L"moire pour enregistrer\n"
    L"cette partie", // FR

    L"La unidad de memoria no\n"
    L"dispone de suficientes\n"
    L"bloques para la partida\n"
    L"guardada", // ES

    L"I blocchi disponibili\n"
    L"sull'unit" L"\xE0" L" di memoria non sono\n"
    L"sufficienti per questa\n"
    L"partita salvata", // IT
};

const WCHAR* const strNO_ROOM_MU_PLZ_FREE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The memory unit does not\n"
    L"have enough free blocks for\n"
    L"this saved game.\n"
    L"%lu blocks must be free.",

    L"",

    L"F" L"\xFC" L"r das gespeicherte Spiel\n"
    L"sind nicht ausreichend freie\n"
    L"Blocks auf der Speicherkarte\n"
    L"vorhanden. %lu Blocks\n"
    L"m" L"\xFC" L"ssen verf" L"\xFC" L"gbar sein.", // DE

    L"Il n'y a pas assez de blocs\n"
    L"libres dans l'unit" L"\xE9" L" de\n"
    L"m" L"\xE9" L"moire pour enregistrer\n"
    L"cette partie. Vous devez\n"
    L"lib" L"\xE9" L"rer %lu blocs.", // FR

    L"La unidad de memoria no\n"
    L"dispone de suficientes\n"
    L"bloques para la partida\n"
    L"guardada. Se necesitan\n"
    L"%lu bloques disponibles.", // ES

    L"I blocchi disponibili\n"
    L"sull'unit" L"\xE0" L" di memoria non sono\n"
    L"sufficienti per questa partita\n"
    L"salvata. Sono necessari %lu\n"
    L"blocchi disponibili.", // IT
};

const WCHAR* const strNO_ROOM_HD_PLZ_FREE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The hard disk does not\n"
    L"have enough free blocks for\n"
    L"this saved game.\n"
    L"%lu blocks must be free.",

    L"",

    // Need to be updated for HD translations ...
    L"F" L"\xFC" L"r das gespeicherte Spiel\n"
    L"sind nicht ausreichend freie\n"
    L"Blocks auf der Speicherkarte\n"
    L"vorhanden. %lu Blocks\n"
    L"m" L"\xFC" L"ssen verf" L"\xFC" L"gbar sein.", // DE

    L"Il n'y a pas assez de blocs\n"
    L"libres dans l'unit" L"\xE9" L" de\n"
    L"m" L"\xE9" L"moire pour enregistrer\n"
    L"cette partie. Vous devez\n"
    L"lib" L"\xE9" L"rer %lu blocs.", // FR

    L"La unidad de memoria no\n"
    L"dispone de suficientes\n"
    L"bloques para la partida\n"
    L"guardada. Se necesitan\n"
    L"%lu bloques disponibles.", // ES

    L"I blocchi disponibili\n"
    L"sull'unit" L"\xE0" L" di memoria non sono\n"
    L"sufficienti per questa partita\n"
    L"salvata. Sono necessari %lu\n"
    L"blocchi disponibili.", // IT
};

const WCHAR* const strNO_SAVES[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"No saved games",

    L"",

    L"Keine gespeicherten\n"
    L"Spiele vorhanden", // DE

    L"Il n'y a pas de\n"
    L"partie enregistr" L"\xE9" L"e", // FR

    L"No hay partidas guardadas", // ES

    L"Nessuna partita salvata", // IT
};

const WCHAR* const strLOADING[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Loading Game",

    L"",

    L"Spiel wird geladen", // DE

    L"Chargement de la\n"
    L"partie", // FR

    L"Cargando partida", // ES

    L"Caricamento partita in\n"
    L"corso", // IT
};

const WCHAR* const strSAVING_MU[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Saving game to memory unit\n%s.\n",

    L"",

    L"Saving game to memory unit\n%s.\n", // DE
    L"Saving game to memory unit\n%s.\n", // FR
    L"Saving game to memory unit\n%s.\n", // ES
    L"Saving game to memory unit\n%s.\n", // IT
};

const WCHAR* const strSAVING[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Saving Game",

    L"",

    L"Spiel wird gespeichert", // DE

    L"Enregistrement de la\n"
    L"partie", // FR

    L"Guardando partida", // ES

    L"Salvataggio partita in\n"
    L"corso", // IT
};

const WCHAR* const strDO_NOT_REMOVE_MU[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Please don't remove memory\n"
    L"units or disconnect controllers.",

    L"",

    L"Entfernen Sie nicht die\n"
    L"Speicherkarte oder die\n"
    L"Controller.", // DE

    L"Ne supprimez pas\n"
    L"d'unit" L"\xE9" L"s de m" L"\xE9" L"moire ni ne\n"
    L"d" L"\xE9" L"connectez les contr" L"\xF4" L"leurs.", // FR

    L"No retire las unidades\n"
    L"de memoria ni desconecte\n"
    L"los controladores.", // ES

    L"Non rimuovere le unit" L"\xE0" L"\n"
    L"di memoria o disconnettere\n"
    L"i controller.\n", // IT
};

const WCHAR* const strDO_NOT_POWEROFF[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L". Please don't\n"
    L"turn off your Xbox console.\n",

    L"",

    L".\n"
    L"Schalten Sie die\n"
    L"Xbox nicht aus.", // DE

    L". N'" L"\xE9" L"teignez\n"
    L"pas votre Xbox.", // FR

    L". No\n"
    L"apague la Xbox.", // ES

    L". Non spegnere\n"
    L"la Xbox.", // IT
};

const WCHAR* const strSAVE_GAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Save Game",
    L"",
    L"Spiel speichern", // DE
    L"Enregistrer la partie", // FR
    L"Guardar partida", // ES
    L"Salva partita", // IT
};

const WCHAR* const strLOAD_GAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Load Game",
    L"",
    L"Spiel laden", // DE
    L"Charger la partie", // FR
    L"Cargar partida", // ES
    L"Carica partita", // IT
};

const WCHAR* const strILLUS_GRAPHICS[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Sample graphics. Don't use in your game",
    L"",
    L"Grafiken nur zur Illustration", // DE
    L"Exemples de graphiques uniquement", // FR
    L"Gr" L"\xE1" L"ficos s" L"\xF3" L"lo de muestra", // ES
    L"Grafica solo dimostrativa", // IT
};

const WCHAR* const strFORMAT_DEVICE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Total blocks\n%hs\n"
    L"Available blocks\n%hs",

    L"",

    L"Gesamtgr" L"\xF6" L"\xDF" L"e\n%hs\n"
    L"Verf" L"\xFC" L"gbare Gr" L"\xF6" L"\xDF" L"e\n%hs", // DE

    L"Blocs totale\n%hs\n"
    L"Blocs disponible\n%hs", // FR

    L"Bloques total\n%hs\n"
    L"Bloques disponible\n%hs", // ES

    L"Blocchi totale\n%hs\n"
    L"Blocchi disponibile\n%hs", // IT
};

const WCHAR* const strCHOOSE_LOAD[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"choose memory device to load game",
    L"",
    L"W" L"\xE4" L"hlen Sie ein Speichermedium zum Laden des Spiels", // DE
    L"Choisissez une unit" L"\xE9" L" de m" L"\xE9" L"moire pour charger la partie", // FR
    L"Elija un dispositivo de memoria para cargar la partida", // ES
    L"Scegliere la periferica di memoria da cui caricare il gioco", // IT
};

const WCHAR* const strCHOOSE_SAVE[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"choose memory device to save game",
    L"",
    L"W" L"\xE4" L"hlen Sie ein Speichermedium zum Speichern des Spiels", // DE
    L"Choisissez une unit" L"\xE9" L" de m" L"\xE9" L"moire pour enregistrer la partie", // FR
    L"Elija un dispositivo de memoria para guardar la partida", // ES
    L"Scegliere la periferica di memoria su cui salvare il gioco", // IT
};

const WCHAR* const strTODAY[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Today",
    L"",
    L"Heute", // DE
    L"Aujourd'hui", // FR
    L"Hoy", // ES
    L"Oggi", // IT
};

const WCHAR* const strNOW[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Now",
    L"",
    L"Jetzt", // DE
    L"Maintenant", // FR
    L"Ahora", // ES
    L"Ora", // IT
};

const WCHAR* const strFORMAT_GAME[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Name: %s\nBlocks: %hs\n"
    L"Date: %s\nTime: %s",

    L"",

    L"Name: %s\nBlocks: %hs\n"
    L"Datum: %s\nZeit: %s", // DE

    L"Nom: %s\nBlocs: %hs\n"
    L"Date: %s\nHeure: %s", // FR

    L"Nombre: %s\nBloques: %hs\n"
    L"Fecha: %s\nHora: %s", // ES

    L"Nome: %s\nBlocchi: %hs\n"
    L"Date: %s\nOra: %s", // IT
};

const WCHAR* const strEMPTY_SPACE[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Empty Space",
    L"",
    L"Freier Speicherplatz", // DE
    L"Espace disponible", // FR
    L"Espacio vac" L"\xED" L"o", // ES
    L"Spazio disponibile", // IT
};

const WCHAR* const strA_SELECT[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"select",
    L"",
    L"ausw" L"\xE4" L"hlen", // DE
    L"s" L"\xE9" L"lectionner", // FR               
    L"seleccionar", // ES
    L"seleziona", // IT
};

const WCHAR* const strB_BACK[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"back",
    L"",
    L"zur" L"\xFC" L"ck", // DE
    L"retour", // FR
    L"atr" L"\xE1" L"s", // ES
    L"indietro", // IT
};

const WCHAR* const strY_DELETE[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"delete",
    L"",
    L"l" L"\xF6" L"schen", // DE
    L"supprimer", // FR
    L"eliminar", // ES
    L"elimina", // IT
};

const WCHAR* const strOVERWRITE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Overwrite saved game?",

    L"",

    L"Gespeichertes Spiel\n"
    L"\xFC" L"berschreiben?", // DE

    L"Ecraser la partie\n"
    L"enregistr" L"\xE9" L"e?", // FR

    L"\xBF" L"Desea sobrescribir\n"
    L"la partida guardada?", // ES

    L"Sovrascrivere la\n"
    L"partita salvata?", // IT
};

const WCHAR* const strYES[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Yes",
    L"",
    L"Ja", // DE
    L"Oui", // FR
    L"S" L"\xED" L"", // ES
    L"S" L"\xEC" L"", // IT
};

const WCHAR* const strNO[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"No",
    L"",
    L"Nein", // DE
    L"Non", // FR
    L"No", // ES
    L"No", // IT
};

const WCHAR* const strDELETE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Delete saved game?",

    L"",

    L"Gespeichertes Spiel\n"
    L"l" L"\xF6" L"schen?", // DE

    L"Supprimer la partie\n"
    L"enregistr" L"\xE9" L"e?", // FR

    L"\xBF" L"Desea eliminar la\n"
    L"partida guardada?", // ES

    L"Eliminare la partita\n"
    L"salvata?", // IT
};

const WCHAR* const strLOADING_GAME_LIST[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Loading game list",

    L"",

    L"Spieleliste wird geladen", // DE

    L"Chargement de la liste\n"
    L"des parties", // FR

    L"Cargando lista\n"
    L"de partidas", // ES

    L"Caricamento elenco\n"
    L"partite", // IT
};

const WCHAR* const strMAX_SAVED_GAMES[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"There is a maximum of\n"
    L"4096 saved games.",

    L"",

    L"There is a maximum of\n"
    L"4096 saved games.", // DE

    L"There is a maximum of\n"
    L"4096 saved games.", // FR

    L"There is a maximum of\n"
    L"4096 saved games.", // ES

    L"There is a maximum of\n"
    L"4096 saved games.", // IT
};

const WCHAR* const strMU_UNUSABLE[ XC_LANGUAGE_MAX ] = 
{
    L"",

	L"This memory unit is unusable",
    
    L"",

    L"Diese Speicherkarte ist\n"
    L"m" L"\xF6" L"glicherweise besch" L"\xE4" L"digt", // DE

    L"Cette unit" L"\xE9" L" de m" L"\xE9" L"moire\n"
    L"est peut-" L"\xEA" L"tre endommag" L"\xE9" L"e", // FR

    L"Es posible que esta\n"
    L"unidad de memoria\n"
    L"est" L"\xE9" L" da" L"\xF1" L"ada", // ES

    L"Questa unit" L"\xE0" L" di memoria\n"
    L"potrebbe essere\n"
    L"danneggiata", // IT
};

const WCHAR* const strMU_FULL[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"This memory unit is full",
    L"This memory unit is full", // JP
    L"Diese Speicher-Einheit ist voll", // DE
    L"La Carte m" L"\x00E9"  L"moire est pleine", // FR
    L"Esta unidad de memoria est" L"\x00E1" L"llena", // ES
    L"Questa memory unit " L"\x00E8" L"piena", // IT
};

const WCHAR* const strUNUSABLE_MU_NAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Unusable Xbox MU",
    L"",
    L"Xbox-SE besch" L"\xE4" L"digt", // DE
    L"CM Xbox endommag" L"\xE9" L"e", // FR
    L"UM de la Xbox da" L"\xF1" L"ada", // ES
    L"UM Xbox danneggiata", // IT
};

const WCHAR* const strFULL_MU_NAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Full Xbox MU",
    L"",
    L"Xbox-SE voll.", // DE
    L"CM Xbox pleine", // FR
    L"UM Xbox llena", // ES
    L"MU Xbox piena", // IT
};

const WCHAR* const strMU_REMOVED[ XC_LANGUAGE_MAX ] =
{
    L"",

    L"%s\nwas removed during use.\n"
    L"%s failed.\n"
    L"Press A to continue.",

    L"",

    L"%s\nwurde w" L"\xE4" L"hrend Benutzung\n"
    L"entfernt. %s ist\n"
    L"fehlgeschlagen. Weiter\n"
    L"mit A-Taste.", // DE

    L"%s\na " L"\xE9" L"t" L"\xE9" L" retir" L"\xE9" L"e de mani" L"\xE8" L"re\n"
    L"intempestive. %s\n"
    L"a " L"\xE9" L"chou" L"\xE9" L". Appuyer sur A\n"
    L"pour continuer.", // FR

    L"%s\nse ha extra" L"\xED" L"do mientras\n"
    L"estaba en uso. Error\n"
    L"de %s. Presione A\n"
    L"para continuar.", // ES

    L"%s\nrimosso durante l'uso.\n"
    L"Errore di %s. Premere\n"
    L"A per continuare.", // IT
};

const WCHAR* const strACTION_SAVE[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Save",
    L"",
    L"Speichern", // DE
    L"Sauvegarder", // FR
    L"Guardar", // ES
    L"Salva", // IT
};

const WCHAR* const strACTION_LOAD[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Load",
    L"",
    L"Laden", // DE
    L"Charger", // FR
    L"Cargar", // ES
    L"Carica", // IT
};

const CHAR* const strMAX_BLOCKS[ XC_LANGUAGE_MAX ] =
{
    "",
    "50,000+",
    "50,000+", // JP
    "50.000+", // DE
    "50 000+", // FR
    "50.000+", // ES
    "50.000+", // IT
};

const WCHAR* const strXHD[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Xbox Hard Disk",
    L"Xbox Hard Disk", // JP
    L"Xbox Festplatte", // DE
    L"Xbox Disque", // FR
    L"Xbox Disco", // ES
    L"Xbox Disco Rigido", // IT
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\Font9.h ===
// Automatically generated by the bundler tool from Font9.rdf

#define Font9_NUM_RESOURCES 2UL

#define Font9_Font_OFFSET 0UL
#define Font9_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\LoadSaveResource.h ===
// Automatically generated by the bundler tool from LoadSaveResource.rdf

#define LoadSaveResource_NUM_RESOURCES 11UL

#define LoadSaveResource_Background_OFFSET 0UL
#define LoadSaveResource_PlainBack_OFFSET 20UL
#define LoadSaveResource_Up_OFFSET 40UL
#define LoadSaveResource_Down_OFFSET 60UL
#define LoadSaveResource_MsgBox_OFFSET 80UL
#define LoadSaveResource_MU_OFFSET 100UL
#define LoadSaveResource_MUWide_OFFSET 120UL
#define LoadSaveResource_MU_Sel_OFFSET 140UL
#define LoadSaveResource_Xbox_OFFSET 160UL
#define LoadSaveResource_Xbox_Sel_OFFSET 180UL
#define LoadSaveResource_MU_Bad_OFFSET 200UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\obj\i386\Xboxdings_24.h ===
// Automatically generated by the bundler tool from Xboxdings_24.rdf

#define Xboxdings_24_NUM_RESOURCES 2UL

#define Xboxdings_24_Font_OFFSET 0UL
#define Xboxdings_24_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\LoadSave.h ===
//-----------------------------------------------------------------------------
// File: LoadSave.h
//
// Desc: Load and save game reference UI
//
// Hist: 02.06.01 - New for March XDK release 
//       03.14.01 - Metadata updates for April XDK release
//       03.27.01 - Certification updates for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBLOADSAVE_H
#define XBLOADSAVE_H

#pragma warning( disable: 4702 4786 )
#include <xtl.h>
#include <XbApp.h>
#include <XbFont.h>
#include <XbStorageDevice.h>
#include <XbMemUnit.h>
#include <XbResource.h>
#include <XbSavedGame.h>
#include <XbStopWatch.h>

#pragma warning( push, 3 )  // Suppress VC warnings when compiling at W4
#include <deque>
#include <vector>
#pragma warning( pop )

// Forward declarations
class File;




//-----------------------------------------------------------------------------
// Name: class CXBLoadSave
// Desc: Application object for load and save game reference UI
//-----------------------------------------------------------------------------
class CXBLoadSave : public CXBApplication
{
    //-------------------------------------------------------------------------
    // Constants
    //-------------------------------------------------------------------------

    // We never display a block count greater than "50,000+" to meet
    // cert requirements
    static const int MAX_BLOCKS_STR = 8;

    // Largest message in message box
    static const int MAX_MESSAGE = 128;

    // MU names include default name plus user-defined name
    static const DWORD MAX_DEVNAME = MAX_MUNAME + 32;

    //-------------------------------------------------------------------------
    // Classes
    //-------------------------------------------------------------------------

    // Preformats storage device values
    struct StorageDev : public CXBStorageDevice
    {
        enum MuState
        {
            MU_UNUSABLE = 1 << 0,
            MU_FULL     = 1 << 1,
        };

        FLOAT fPercentUsed;                       // blocks used/blocks free
        CHAR  strTotalBlocks[ MAX_BLOCKS_STR ];   // Formatted total blocks string
        CHAR  strFreeBlocks[ MAX_BLOCKS_STR ];    // Formatted free blocks string
        DWORD dwState;                            // MU unusable/full
        BOOL  bIsMU;                              // TRUE if Memory Unit

        LPDIRECT3DTEXTURE8  pTextureGood;
        LPDIRECT3DTEXTURE8  pTextureBad;
        LPDIRECT3DTEXTURE8  pWideTexture;
        LPDIRECT3DTEXTURE8  pTexSel;
        D3DXVECTOR4         rcRegion;
        D3DXVECTOR4         rcImage;
        D3DXVECTOR4         rcUsed;

        explicit StorageDev( CHAR chDriveLetter = 0, BOOL bIsMU = FALSE );
        VOID SetDevice( CHAR chDriveLetter, BOOL bIsMU );
        VOID SetDeviceState( DWORD );
        VOID Refresh();
        VOID Render( BOOL bSelected, const CXBLoadSave* pRContext ) const;

    };

    //-------------------------------------------------------------------------
    // Enums
    //-------------------------------------------------------------------------

    enum Mode
    {
        MODE_SAVE,      // Saving a game
        MODE_LOAD,      // Loading a game

        MODE_MAX
    };

    enum State
    {
        START_SCREEN,     // Initial screen
        MENU_MAIN,        // Save/Load menu
        MENU_DEVICE,      // Select memory device
        MENU_GAMELIST,    // Game list menu
        GAME_SAVE,        // Saving game to device
        GAME_LOAD,        // Loading game from device
        BOX_OVERWRITE,    // Overwrite question box
        BOX_DELETE,       // Delete game question box
        BOX_DASH_CONFIRM, // Boot to dash question box

        STATE_MAX
    };

    enum Event
    {
        EV_NULL,            // No events
        EV_A_BUTTON,        // A button
        EV_START_BUTTON,    // Start button
        EV_B_BUTTON,        // B button
        EV_BACK_BUTTON,     // Back button
        EV_UP,              // Up Dpad or left joy
        EV_DOWN,            // Down Dpad or left joy
        EV_LEFT,            // Left Dpad or left joy
        EV_RIGHT,           // Right Dpad or left joy
        EV_MU_CHANGE,       // MU removed/inserted
        EV_X_BUTTON,        // X button
        EV_Y_BUTTON,        // Y button

        EVENT_MAX
    };

    enum Answer
    {
        ANSWER_YES,
        ANSWER_NO,

        ANSWER_MAX
    };

    enum DeviceZone
    {
        MM_SAVE,
        MM_LOAD,
        DS_MAINDESC,
        DS_BLOCKBOX,
        DS_TITLE,
        GS_MAINDESC,
        GS_BLOCKBOX,
        GS_DEVICEIMG,
        GS_META,
        GS_METAIMG,
        GS_METATEXT,
        GS_GAMELIST,
        GS_UP,
        GS_DOWN,
        MB_MESSAGE,
        MB_PROGRESS,
        MB_YES,
        MB_NO
    };


    //-------------------------------------------------------------------------
    // Types
    //-------------------------------------------------------------------------

    typedef std::vector< CXBMemUnit >   MemUnitList;
    typedef std::vector< StorageDev >   StorageDevList;
    typedef StorageDevList::size_type   StorageDevIndex;
    typedef std::deque< CXBSavedGame >  SavedGameList;
    typedef SavedGameList::size_type    SavedGameIndex;

    //-------------------------------------------------------------------------
    // Data
    //-------------------------------------------------------------------------

	CXBPackedResource m_xprResource;  // Packed resource (textures) for the LoadSave UI

    DWORD             m_iLang;        // Current language
    mutable CXBFont   m_FontBig;      // Big font
    mutable CXBFont   m_FontMed;      // Medium font
    mutable CXBFont   m_FontSmall;    // Smaller font
    mutable CXBFont   m_FontBtn;      // Xboxdings font buttons
    Mode              m_Mode;         // Current mode
    State             m_State;        // Current menu/box

    MemUnitList       m_MemUnitList;  // MUs
    StorageDevList    m_DeviceList;   // User data regions
    SavedGameList     m_GameList;     // Games on the current storage device

    StorageDevIndex   m_iCurrDev;          // Current storage device
    StorageDevIndex   m_iLastMu;           // Last selected MU
    SavedGameIndex    m_iCurrGame;         // Current selected game
    SavedGameIndex    m_iTopGame;          // Topmost game visible on screen
    DWORD             m_dwSavedGameBytes;  // Size of game save data
    BOOL              m_bOverwriteMode;    // TRUE if overwriting saved game

    CXBStopWatch      m_RepeatTimer;          // Controller button repeat timer
    FLOAT             m_fRepeatDelay;         // Time between button repeats

    CXBStopWatch      m_MsgBoxTimer;                 // Time msg box displayed
    FLOAT             m_fMsgBoxSeconds;              // Max msg box display time; 0=forever
    WCHAR             m_strMessage[ MAX_MESSAGE ];   // Message box message
    Answer            m_Answer;                      // Yes/no
    State             m_NextState;                   // State after message box exit

    LPDIRECT3DVERTEXBUFFER8     m_pvbBackground;    // Quad for background
    LPDIRECT3DTEXTURE8          m_ptBackground;     // Texture for background
    LPDIRECT3DTEXTURE8          m_ptMsgBox;         // Message Box texture
    LPDIRECT3DTEXTURE8          m_ptPlainBack;      // Plain background

    LPDIRECT3DTEXTURE8 m_ptXbox;    // Xbox graphic
    LPDIRECT3DTEXTURE8 m_ptMU;      // MU graphic
    LPDIRECT3DTEXTURE8 m_ptWideMU;  // Wide MU Graphic
    LPDIRECT3DTEXTURE8 m_ptXboxSel; // Xbox selection background
    LPDIRECT3DTEXTURE8 m_ptMUSel;   // MU selection background
    LPDIRECT3DTEXTURE8 m_ptUp;      // Up arrow
    LPDIRECT3DTEXTURE8 m_ptDown;    // Down arrow
    LPDIRECT3DTEXTURE8 m_ptMUBad;   // Corrupt MU graphic

    DWORD m_dwFileErr;              // Last read/write error

public:

    CXBLoadSave();

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

private:

    VOID ValidateState() const;
    BOOL SaveGame();
    LPDIRECT3DTEXTURE8 GetGameImage( const WCHAR* ) const;
    BOOL SaveGame( const CHAR* );
    BOOL LoadGame();
    BOOL GameExists( const WCHAR* ) const;

    Event GetEvent();
    Event GetControllerEvent();
    Event GetMemoryUnitEvent();
    static DWORD GetMuState( DWORD );

    VOID UpdateState( Event );
    VOID UpdateStateStartScreen( Event );
    VOID UpdateStateMainMenu( Event );
    VOID UpdateStateDevice( Event );
    VOID UpdateStateGameList( Event );
    VOID UpdateStateOverwrite( Event );
    VOID UpdateStateDelete( Event );
    VOID UpdateStateDashConfirm( Event );

    VOID StartMsgBox( const WCHAR*, State, FLOAT = 0.0f );
    VOID StartMsgBoxSave();
    VOID StartMsgBoxFree();

    VOID RenderStartScreen() const;
    VOID RenderMainMenu() const;
    VOID RenderDevice() const;
    VOID RenderGameList() const;
    VOID RenderOverwrite() const;
    VOID RenderDelete() const;
    VOID RenderDashConfirm() const;
    VOID RenderYesNo() const;
    VOID DrawButton( FLOAT fX, WCHAR ) const;
    VOID DrawMsgBox( const D3DXVECTOR4&, const WCHAR*, CXBFont&, DWORD ) const;
    VOID RenderTile( const D3DXVECTOR4&, const LPDIRECT3DTEXTURE8,
                     BOOL = FALSE ) const;
    VOID RenderBar( const D3DXVECTOR4&, FLOAT, DWORD ) const;
    VOID RenderSelection( const D3DXVECTOR4&, FLOAT ) const;

    BOOL IsDeviceInserted( DWORD ) const;
    BOOL AnyMemoryUnitsInserted() const;
    BOOL IsSpaceAvail( DWORD* = NULL ) const;
    VOID DeleteGame();
    VOID DeleteGameFromList();

    static bool SortByLastWriteTime( const CXBSavedGame&, const CXBSavedGame& );

    VOID BuildGameList();
    VOID GetSavedGameFileName( CHAR* ) const;
    DWORD GetSavedGameSize() const;

    static VOID GenerateSavedGameName( WCHAR* );

};

#endif // XBLOADSAVE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\LoadSave\Text.h ===
//-----------------------------------------------------------------------------
// File: Text.h
//
// Desc: All text for LoadSave sample in single place to simplify localization
//
// Hist: 04.10.01 - Added for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBLOADSAVE_TEXT_H
#define XBLOADSAVE_TEXT_H

#include <xtl.h>




const UINT XC_LANGUAGE_MAX = XC_LANGUAGE_ITALIAN + 1;




extern const WCHAR* const strSAVE_FAILED        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strGAME_SAVED         [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOAD_FAILED        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strGAME_LOADED        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_MU         [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_HD         [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_MU_PLZ_FREE[ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_HD_PLZ_FREE[ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_SAVES           [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOADING            [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strSAVING             [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strSAVING_MU          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strDO_NOT_REMOVE_MU   [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strDO_NOT_POWEROFF    [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strSAVE_GAME          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOAD_GAME          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strILLUS_GRAPHICS     [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strFORMAT_DEVICE      [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strCHOOSE_LOAD        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strCHOOSE_SAVE        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strTODAY              [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNOW                [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strFORMAT_GAME        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strEMPTY_SPACE        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strA_SELECT           [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strB_BACK             [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strY_DELETE           [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strOVERWRITE          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strYES                [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO                 [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strDELETE             [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOADING_GAME_LIST  [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strMAX_SAVED_GAMES    [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strMU_UNUSABLE        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strMU_FULL            [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strUNUSABLE_MU_NAME   [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strFULL_MU_NAME       [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMU_REMOVED         [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strACTION_SAVE        [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strACTION_LOAD        [ XC_LANGUAGE_MAX ];
extern const  CHAR* const strMAX_BLOCKS         [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strXHD                [ XC_LANGUAGE_MAX ];




#endif // XBLOADSAVE_TEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\Fonteuro.h ===
// Automatically generated by the bundler tool from Fonteuro.rdf

#define Fonteuro_NUM_RESOURCES 2UL

#define Fonteuro_Font_OFFSET 0UL
#define Fonteuro_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\FontJapanese.h ===
// Automatically generated by the bundler tool from fontjapanese.rdf

#define fontjapanese_NUM_RESOURCES 2UL

#define fontjapanese_Font_OFFSET 0UL
#define fontjapanese_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\Fontarrows.h ===
// Automatically generated by the bundler tool from Fontarrows.rdf

#define Fontarrows_NUM_RESOURCES 2UL

#define Fontarrows_Font_OFFSET 0UL
#define Fontarrows_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\Font18.h ===
// Automatically generated by the bundler tool from Font18.rdf

#define Font18_NUM_RESOURCES 2UL

#define Font18_Font_OFFSET 0UL
#define Font18_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\ControllerS.h ===
// Automatically generated by the bundler tool from ControllerS.rdf

#define ControllerS_NUM_RESOURCES 1UL

#define ControllerS_ControllerSTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\Xboxdings_24.h ===
// Automatically generated by the bundler tool from Xboxdings_24.rdf

#define Xboxdings_24_NUM_RESOURCES 2UL

#define Xboxdings_24_Font_OFFSET 0UL
#define Xboxdings_24_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\ControllerS.h ===
// Automatically generated by the bundler tool from ControllerS.rdf

#define ControllerS_NUM_RESOURCES 1UL

#define ControllerS_ControllerSTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_MsgBox_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\Font18.h ===
// Automatically generated by the bundler tool from Font18.rdf

#define Font18_NUM_RESOURCES 2UL

#define Font18_Font_OFFSET 0UL
#define Font18_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\Fontarrows.h ===
// Automatically generated by the bundler tool from Fontarrows.rdf

#define Fontarrows_NUM_RESOURCES 2UL

#define Fontarrows_Font_OFFSET 0UL
#define Fontarrows_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\Fonteuro.h ===
// Automatically generated by the bundler tool from Fonteuro.rdf

#define Fonteuro_NUM_RESOURCES 2UL

#define Fonteuro_Font_OFFSET 0UL
#define Fonteuro_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_MsgBox_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\Xboxdings_24.h ===
// Automatically generated by the bundler tool from Xboxdings_24.rdf

#define Xboxdings_24_NUM_RESOURCES 2UL

#define Xboxdings_24_Font_OFFSET 0UL
#define Xboxdings_24_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AsyncXMO\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AsyncXMO\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AsyncXMO\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\VirtualKeyboard.h ===
//-----------------------------------------------------------------------------
// File: VirtualKeyboard.h
//
// Desc: Virtual keyboard reference UI
//
// Hist: 02.13.01 - New for March XDK release 
//       03.07.01 - Localized for April XDK release
//       04.10.01 - Updated for May XDK with full translations
//       06.06.01 - Japanese keyboard added
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBVIRTUAL_KEYBOARD_H
#define XBVIRTUAL_KEYBOARD_H

#pragma warning( disable: 4710 4786 )
#include <xtl.h>
#include <XbApp.h>
#include <XbFont.h>
#include <XbStopWatch.h>
#include <Xbhelp.h>
#include <XbResource.h>
#include <XbSound.h>

#pragma warning( push, 3 )  // Suppress VC warnings when compiling at W4
#include <string>
#include <vector>
#pragma warning( pop )




//-----------------------------------------------------------------------------
// Define VKEY_JAPAN to turn on support for Japanese virtual keyboard
//-----------------------------------------------------------------------------
#define VKEY_JAPAN                  1
#define FIXED_JAPANESE_SMALL_LETTER 1




//-----------------------------------------------------------------------------
// Name: class CXBVirtualKeyboard
// Desc: Application object for load and save game reference UI
//-----------------------------------------------------------------------------
class CXBVirtualKeyboard : public CXBApplication
{
    //-------------------------------------------------------------------------
    // Constants
    //-------------------------------------------------------------------------

    static const DWORD MAX_ROWS = 5;     // rows of keys
    static const DWORD KEY_WIDTH = 34;   // width of std key in pixels

    //-------------------------------------------------------------------------
    // Types
    //-------------------------------------------------------------------------

    typedef std::basic_string< WCHAR > String;
    typedef String::size_type          StringIndex;

    //-------------------------------------------------------------------------
    // Enums
    //-------------------------------------------------------------------------

    enum KeyboardTypes
    {
        TYPE_ALPHABET,
        TYPE_SYMBOLS,
        TYPE_ACCENTS,

        TYPE_MAX
    };

    enum State
    {
        STATE_STARTSCREEN,  // First screen
        STATE_MENU,         // Main menu
        STATE_KEYBOARD,     // Keyboard display
        STATE_HELP,         // Controller mappings

        STATE_MAX
    };

    enum ControllerSState
    {
        XKJ_START   = 1 << 0,
        XKJ_BACK    = 1 << 1,
        XKJ_A       = 1 << 2,
        XKJ_B       = 1 << 3,
        XKJ_X       = 1 << 4,
        XKJ_Y       = 1 << 5,
        XKJ_BLACK   = 1 << 6,
        XKJ_WHITE   = 1 << 7,
        XKJ_LEFTTR  = 1 << 8,
        XKJ_RIGHTTR = 1 << 9,

        XKJ_DUP     = 1 << 12,
        XKJ_DDOWN   = 1 << 13,
        XKJ_DLEFT   = 1 << 14,
        XKJ_DRIGHT  = 1 << 15,
        XKJ_UP      = 1 << 16,
        XKJ_DOWN    = 1 << 17,
        XKJ_LEFT    = 1 << 18,
        XKJ_RIGHT   = 1 << 19
    };

    enum Event
    {
        EV_NULL,            // No events
        EV_A_BUTTON,        // A button
        EV_START_BUTTON,    // Start button
        EV_B_BUTTON,        // B button
        EV_BACK_BUTTON,     // Back button
        EV_X_BUTTON,        // X button
        EV_Y_BUTTON,        // Y button
        EV_WHITE_BUTTON,    // White button
        EV_BLACK_BUTTON,    // Black button
        EV_LEFT_BUTTON,     // Left trigger
        EV_RIGHT_BUTTON,    // Right trigger
        EV_UP,              // Up Dpad or left joy
        EV_DOWN,            // Down Dpad or left joy
        EV_LEFT,            // Left Dpad or left joy
        EV_RIGHT,           // Right Dpad or left joy

        EVENT_MAX
    };

    enum Xkey
    {
        XK_NULL         = 0,

        XK_SPACE        = ' ',
        XK_LBRACK       = '[',
        XK_RBRACK       = ']',
        XK_LBRACE       = '{',
        XK_RBRACE       = '}',
        XK_LPAREN       = '(',
        XK_RPAREN       = ')',
        XK_FSLASH       = '/',
        XK_BSLASH       = '\\',
        XK_LT           = '<',
        XK_GT           = '>',
        XK_AT           = '@',
        XK_SEMI         = ';',
        XK_COLON        = ':',
        XK_QUOTE        = '\'',
        XK_DQUOTE       = '\"',
        XK_AMPER        = '&',
        XK_STAR         = '*',
        XK_QMARK        = '?',
        XK_COMMA        = ',',
        XK_PERIOD       = '.',
        XK_DASH         = '-',
        XK_UNDERS       = '_',
        XK_PLUS         = '+',
        XK_EQUAL        = '=',
        XK_DOLLAR       = '$',
        XK_PERCENT      = '%',
        XK_CARET        = '^',
        XK_TILDE        = '~',
        XK_APOS         = '`',
        XK_EXCL         = '!',
        XK_VERT         = '|',
        XK_NSIGN        = '#',

        // Numbers
        XK_0            = '0',
        XK_1,
        XK_2,
        XK_3,
        XK_4,
        XK_5,
        XK_6,
        XK_7,
        XK_8,
        XK_9,
        
        // Letters
        XK_A            = 'A',
        XK_B,
        XK_C,
        XK_D,
        XK_E,
        XK_F,
        XK_G,
        XK_H,
        XK_I,
        XK_J,
        XK_K,
        XK_L,
        XK_M,
        XK_N,
        XK_O,
        XK_P,
        XK_Q,
        XK_R,
        XK_S,
        XK_T,
        XK_U,
        XK_V,
        XK_W,
        XK_X,
        XK_Y,
        XK_Z,

        // Accented characters and other special characters

        XK_INVERTED_EXCL        = 0xA1, // 
        XK_CENT_SIGN            = 0xA2, // 
        XK_POUND_SIGN           = 0xA3, // 
        XK_YEN_SIGN             = 0xA5, // 
        XK_COPYRIGHT_SIGN       = 0xA9, // 
        XK_LT_DBL_ANGLE_QUOTE   = 0xAB, // <<
        XK_REGISTERED_SIGN      = 0xAE, // 
        XK_SUPERSCRIPT_TWO      = 0xB2, // 
        XK_SUPERSCRIPT_THREE    = 0xB3, // 
        XK_ACUTE_ACCENT         = 0xB4, // 
        XK_MICRO_SIGN           = 0xB5, // 
        XK_SUPERSCRIPT_ONE      = 0xB9, // 
        XK_RT_DBL_ANGLE_QUOTE   = 0xBB, // >>
        XK_INVERTED_QMARK       = 0xBF, // 
        XK_CAP_A_GRAVE          = 0xC0, // 
        XK_CAP_A_ACUTE          = 0xC1, // 
        XK_CAP_A_CIRCUMFLEX     = 0xC2, // 
        XK_CAP_A_TILDE          = 0xC3, // 
        XK_CAP_A_DIAERESIS      = 0xC4, // 
        XK_CAP_A_RING           = 0xC5, // 
        XK_CAP_AE               = 0xC6, // 
        XK_CAP_C_CEDILLA        = 0xC7, // 
        XK_CAP_E_GRAVE          = 0xC8, // 
        XK_CAP_E_ACUTE          = 0xC9, // 
        XK_CAP_E_CIRCUMFLEX     = 0xCA, // 
        XK_CAP_E_DIAERESIS      = 0xCB, // 
        XK_CAP_I_GRAVE          = 0xCC, // 
        XK_CAP_I_ACUTE          = 0xCD, // 
        XK_CAP_I_CIRCUMFLEX     = 0xCE, // 
        XK_CAP_I_DIAERESIS      = 0xCF, // 
        XK_CAP_N_TILDE          = 0xD1, // 
        XK_CAP_O_GRAVE          = 0xD2, // 
        XK_CAP_O_ACUTE          = 0xD3, // 
        XK_CAP_O_CIRCUMFLEX     = 0xD4, // 
        XK_CAP_O_TILDE          = 0xD5, // 
        XK_CAP_O_DIAERESIS      = 0xD6, // 
        XK_CAP_O_STROKE         = 0xD8, // 
        XK_CAP_U_GRAVE          = 0xD9, // 
        XK_CAP_U_ACUTE          = 0xDA, // 
        XK_CAP_U_CIRCUMFLEX     = 0xDB, // 
        XK_CAP_U_DIAERESIS      = 0xDC, // 
        XK_CAP_Y_ACUTE          = 0xDD, // 
        XK_SM_SHARP_S           = 0xDF, // 
        XK_SM_A_GRAVE           = 0xE0, // 
        XK_SM_A_ACUTE           = 0xE1, // 
        XK_SM_A_CIRCUMFLEX      = 0xE2, // 
        XK_SM_A_TILDE           = 0xE3, // 
        XK_SM_A_DIAERESIS       = 0xE4, // 
        XK_SM_A_RING            = 0xE5, // 
        XK_SM_AE                = 0xE6, // 
        XK_SM_C_CEDILLA         = 0xE7, // 
        XK_SM_E_GRAVE           = 0xE8, // 
        XK_SM_E_ACUTE           = 0xE9, // 
        XK_SM_E_CIRCUMFLEX      = 0xEA, // 
        XK_SM_E_DIAERESIS       = 0xEB, // 
        XK_SM_I_GRAVE           = 0xEC, // 
        XK_SM_I_ACUTE           = 0xED, // 
        XK_SM_I_CIRCUMFLEX      = 0xEE, // 
        XK_SM_I_DIAERESIS       = 0xEF, // 
        XK_SM_N_TILDE           = 0xF1, // 
        XK_SM_O_GRAVE           = 0xF2, // 
        XK_SM_O_ACUTE           = 0xF3, // 
        XK_SM_O_CIRCUMFLEX      = 0xF4, // 
        XK_SM_O_TILDE           = 0xF5, // 
        XK_SM_O_DIAERESIS       = 0xF6, // 
        XK_SM_O_STROKE          = 0xF8, // 
        XK_SM_U_GRAVE           = 0xF9, // 
        XK_SM_U_ACUTE           = 0xFA, // 
        XK_SM_U_CIRCUMFLEX      = 0xFB, // 
        XK_SM_U_DIAERESIS       = 0xFC, // 
        XK_SM_Y_ACUTE           = 0xFD, // 
        XK_SM_Y_DIAERESIS       = 0xFF, // 

        // Unicode
        XK_CAP_Y_DIAERESIS = 0x0178, // Y umlaut
        XK_EURO_SIGN       = 0x20AC, // Euro symbol
        XK_ARROWLEFT       = 0x22B2, // left arrow
        XK_ARROWRIGHT      = 0x22B3, // right arrow

        // Japanese Unicode
        XK_HIRAGANA_SP  = 0x3040,
        XK_HIRAGANA_LA  = 0x3041,
        XK_HIRAGANA_A   = 0x3042,
        XK_HIRAGANA_LI  = 0x3043,
        XK_HIRAGANA_I   = 0x3044,
        XK_HIRAGANA_LU  = 0x3045,
        XK_HIRAGANA_U   = 0x3046,
        XK_HIRAGANA_LE  = 0x3047,
        XK_HIRAGANA_E   = 0x3048,
        XK_HIRAGANA_LO  = 0x3049,
        XK_HIRAGANA_O   = 0x304A,

        XK_HIRAGANA_KA  = 0x304B,
        XK_HIRAGANA_GA  = 0x304C,
        XK_HIRAGANA_KI  = 0x304D,
        XK_HIRAGANA_GI  = 0x304E,
        XK_HIRAGANA_KU  = 0x304F,
        XK_HIRAGANA_GU  = 0x3050,
        XK_HIRAGANA_KE  = 0x3051,
        XK_HIRAGANA_GE  = 0x3052,
        XK_HIRAGANA_KO  = 0x3053,
        XK_HIRAGANA_GO  = 0x3054,

        XK_HIRAGANA_SA  = 0x3055,
        XK_HIRAGANA_ZA  = 0x3056,
        XK_HIRAGANA_SI  = 0x3057,
        XK_HIRAGANA_ZI  = 0x3058,
        XK_HIRAGANA_SU  = 0x3059,
        XK_HIRAGANA_ZU  = 0x305A,
        XK_HIRAGANA_SE  = 0x305B,
        XK_HIRAGANA_ZE  = 0x305C,
        XK_HIRAGANA_SO  = 0x305D,
        XK_HIRAGANA_ZO  = 0x305E,

        XK_HIRAGANA_TA  = 0x305F,
        XK_HIRAGANA_DA  = 0x3060,
        XK_HIRAGANA_TI  = 0x3061,
        XK_HIRAGANA_DI  = 0x3062,
        XK_HIRAGANA_LTU = 0x3063,
        XK_HIRAGANA_TU  = 0x3064,
        XK_HIRAGANA_DU  = 0x3065,
        XK_HIRAGANA_TE  = 0x3066,
        XK_HIRAGANA_DE  = 0x3067,
        XK_HIRAGANA_TO  = 0x3068,
        XK_HIRAGANA_DO  = 0x3069,

        XK_HIRAGANA_NA  = 0x306A,
        XK_HIRAGANA_NI  = 0x306B,
        XK_HIRAGANA_NU  = 0x306C,
        XK_HIRAGANA_NE  = 0x306D,
        XK_HIRAGANA_NO  = 0x306E,

        XK_HIRAGANA_HA  = 0x306F,
        XK_HIRAGANA_BA  = 0x3070,
        XK_HIRAGANA_PA  = 0x3071,
        XK_HIRAGANA_HI  = 0x3072,
        XK_HIRAGANA_BI  = 0x3073,
        XK_HIRAGANA_PI  = 0x3074,
        XK_HIRAGANA_HU  = 0x3075,
        XK_HIRAGANA_BU  = 0x3076,
        XK_HIRAGANA_PU  = 0x3077,
        XK_HIRAGANA_HE  = 0x3078,
        XK_HIRAGANA_BE  = 0x3079,
        XK_HIRAGANA_PE  = 0x307A,
        XK_HIRAGANA_HO  = 0x307B,
        XK_HIRAGANA_BO  = 0x307C,
        XK_HIRAGANA_PO  = 0x307D,

        XK_HIRAGANA_MA  = 0x307E,
        XK_HIRAGANA_MI  = 0x307F,
        XK_HIRAGANA_MU  = 0x3080,
        XK_HIRAGANA_ME  = 0x3081,
        XK_HIRAGANA_MO  = 0x3082,

        XK_HIRAGANA_LYA = 0x3083,
        XK_HIRAGANA_YA  = 0x3084,
        XK_HIRAGANA_LYU = 0x3085,
        XK_HIRAGANA_YU  = 0x3086,
        XK_HIRAGANA_LYO = 0x3087,
        XK_HIRAGANA_YO  = 0x3088,

        XK_HIRAGANA_RA  = 0x3089,
        XK_HIRAGANA_RI  = 0x308A,
        XK_HIRAGANA_RU  = 0x308B,
        XK_HIRAGANA_RE  = 0x308C,
        XK_HIRAGANA_RO  = 0x308D,

        XK_HIRAGANA_LWA = 0x308E,
        XK_HIRAGANA_WA  = 0x308F,
        XK_HIRAGANA_WI  = 0x3090,
        XK_HIRAGANA_WE  = 0x3091,
        XK_HIRAGANA_WO  = 0x3092,
        XK_HIRAGANA_N   = 0x3093,
        XK_HIRAGANA_VU  = 0x3094,

        // Katakana
        XK_KATAKANA_SP  = 0x30A0,
        XK_KATAKANA_LA  = 0x30A1,
        XK_KATAKANA_A   = 0x30A2,
        XK_KATAKANA_LI  = 0x30A3,
        XK_KATAKANA_I   = 0x30A4,
        XK_KATAKANA_LU  = 0x30A5,
        XK_KATAKANA_U   = 0x30A6,
        XK_KATAKANA_LE  = 0x30A7,
        XK_KATAKANA_E   = 0x30A8,
        XK_KATAKANA_LO  = 0x30A9,
        XK_KATAKANA_O   = 0x30AA,

        XK_KATAKANA_KA  = 0x30AB,
        XK_KATAKANA_GA  = 0x30AC,
        XK_KATAKANA_KI  = 0x30AD,
        XK_KATAKANA_GI  = 0x30AE,
        XK_KATAKANA_KU  = 0x30AF,
        XK_KATAKANA_GU  = 0x30B0,
        XK_KATAKANA_KE  = 0x30B1,
        XK_KATAKANA_GE  = 0x30B2,
        XK_KATAKANA_KO  = 0x30B3,
        XK_KATAKANA_GO  = 0x30B4,

        XK_KATAKANA_SA  = 0x30B5,
        XK_KATAKANA_ZA  = 0x30B6,
        XK_KATAKANA_SI  = 0x30B7,
        XK_KATAKANA_ZI  = 0x30B8,
        XK_KATAKANA_SU  = 0x30B9,
        XK_KATAKANA_ZU  = 0x30BA,
        XK_KATAKANA_SE  = 0x30BB,
        XK_KATAKANA_ZE  = 0x30BC,
        XK_KATAKANA_SO  = 0x30BD,
        XK_KATAKANA_ZO  = 0x30BE,

        XK_KATAKANA_TA  = 0x30BF,
        XK_KATAKANA_DA  = 0x30C0,
        XK_KATAKANA_TI  = 0x30C1,
        XK_KATAKANA_DI  = 0x30C2,
        XK_KATAKANA_LTU = 0x30C3,
        XK_KATAKANA_TU  = 0x30C4,
        XK_KATAKANA_DU  = 0x30C5,
        XK_KATAKANA_TE  = 0x30C6,
        XK_KATAKANA_DE  = 0x30C7,
        XK_KATAKANA_TO  = 0x30C8,
        XK_KATAKANA_DO  = 0x30C9,

        XK_KATAKANA_NA  = 0x30CA,
        XK_KATAKANA_NI  = 0x30CB,
        XK_KATAKANA_NU  = 0x30CC,
        XK_KATAKANA_NE  = 0x30CD,
        XK_KATAKANA_NO  = 0x30CE,

        XK_KATAKANA_HA  = 0x30CF,
        XK_KATAKANA_BA  = 0x30D0,
        XK_KATAKANA_PA  = 0x30D1,
        XK_KATAKANA_HI  = 0x30D2,
        XK_KATAKANA_BI  = 0x30D3,
        XK_KATAKANA_PI  = 0x30D4,
        XK_KATAKANA_HU  = 0x30D5,
        XK_KATAKANA_BU  = 0x30D6,
        XK_KATAKANA_PU  = 0x30D7,
        XK_KATAKANA_HE  = 0x30D8,
        XK_KATAKANA_BE  = 0x30D9,
        XK_KATAKANA_PE  = 0x30DA,
        XK_KATAKANA_HO  = 0x30DB,
        XK_KATAKANA_BO  = 0x30DC,
        XK_KATAKANA_PO  = 0x30DD,

        XK_KATAKANA_MA  = 0x30DE,
        XK_KATAKANA_MI  = 0x30DF,
        XK_KATAKANA_MU  = 0x30E0,
        XK_KATAKANA_ME  = 0x30E1,
        XK_KATAKANA_MO  = 0x30E2,

        XK_KATAKANA_LYA = 0x30E3,
        XK_KATAKANA_YA  = 0x30E4,
        XK_KATAKANA_LYU = 0x30E5,
        XK_KATAKANA_YU  = 0x30E6,
        XK_KATAKANA_LYO = 0x30E7,
        XK_KATAKANA_YO  = 0x30E8,

        XK_KATAKANA_RA  = 0x30E9,
        XK_KATAKANA_RI  = 0x30EA,
        XK_KATAKANA_RU  = 0x30EB,
        XK_KATAKANA_RE  = 0x30EC,
        XK_KATAKANA_RO  = 0x30ED,

        XK_KATAKANA_LWA = 0x30EE,
        XK_KATAKANA_WA  = 0x30EF,
        XK_KATAKANA_WI  = 0x30F0,
        XK_KATAKANA_WE  = 0x30F1,
        XK_KATAKANA_WO  = 0x30F2,
        XK_KATAKANA_N   = 0x30F3,
        XK_KATAKANA_VU  = 0x30F4,
        XK_KATAKANA_DASH= 0x30FC,

        // Special
        XK_BACKSPACE = 0x10000, // backspace
        XK_DELETE,              // delete           // !!!
        XK_SHIFT,               // shift
        XK_CAPSLOCK,            // capslock
        XK_ALPHABET,            // alphabet
        XK_SYMBOLS,             // symbols
        XK_ACCENTS,             // accents
        XK_OK                   // "done"
    };

    //-------------------------------------------------------------------------
    // Classes
    //-------------------------------------------------------------------------

    // Keyboard key information
    struct Key
    {
        Xkey    xKey;       // virtual key code
        DWORD   dwWidth;    // width of the key
        String  strName;    // name of key when vKey >= 0x10000
        static UINT iLang;  // current language

        explicit Key( Xkey, DWORD = KEY_WIDTH );
    };

    //-------------------------------------------------------------------------
    // Types
    //-------------------------------------------------------------------------

    typedef std::vector< Key > KeyRow;              // list of keys in a row
    typedef KeyRow::size_type KeyIndex;

    typedef std::vector< KeyRow > Keyboard;         // list of rows = keyboard
    typedef Keyboard::size_type RowIndex;

    typedef std::vector< Keyboard > KeyboardList;   // alpha, symbol, etc.
    typedef KeyboardList::size_type BoardIndex;

    //-------------------------------------------------------------------------
    // Data
    //-------------------------------------------------------------------------

    CXBPackedResource  m_xprResource;      // General app packed resource
    CXBPackedResource  m_xprControllerS;   // ControllerS gamepad resource

    mutable CXBFont    m_FontLatin;        // Font renderer for most keys
    mutable CXBFont    m_FontJapan;        // Japanese font (Unicode 30xx - 30xx)
    mutable CXBFont    m_FontCaps;         // Font renderer for capital name keys
    mutable CXBFont    m_FontArrows;       // Arrow font (Unicode 8882 - 8883)
    mutable CXBFont    m_FontEuro;         // Euro font (Unicode 8364)
    mutable CXBFont    m_FontBtn;          // Xbox Button font

    BOOL               m_bIsCapsLockOn;    // CapsLock status
    BOOL               m_bIsShiftOn;       // Sticky shift key status
    State              m_State;            // Current state
    UINT               m_iLanguage;        // Current language
    String             m_strData;          // Current string
    StringIndex        m_iPos;             // Current pos of caret in string
    KeyboardList       m_KeyboardList;     // All potential keyboards
    BoardIndex         m_iCurrBoard;       // Current keyboard
    RowIndex           m_iCurrRow;         // Current row
    KeyIndex           m_iCurrKey;         // Current key in the current row           
    KeyIndex           m_iLastColumn;      // Column of last single char key
    CXBStopWatch       m_RepeatTimer;      // Controller button repeat timer
    FLOAT              m_fRepeatDelay;     // Time between button repeats
    CXBStopWatch       m_CaretTimer;       // Controls caret blink
    mutable CXBHelp    m_Help;             // Help
    LPDIRECT3DTEXTURE8 m_ptKey;            // Keyboard "key" texture
    LPDIRECT3DTEXTURE8 m_ptControllerS;    // ControllerS gamepad texture
    CXBSound           m_ClickSnd;         // Click sound

    // These items are used exclusively for the Japanese vkeyboard

    DWORD              m_dwCurrCtlrState;  // Current state of ControllerS
    DWORD              m_dwOldCtlrState;   // Previous state of ControllerS
    mutable Xkey       m_xNextKeyJpn;      // Japanese key press
    BOOL               m_bTrig;            // TRUE if trigger held
    BOOL               m_bKana;            // TRUE if Katakana; FALSE if Hiragana

public:

    CXBVirtualKeyboard();

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

private:

    VOID ValidateState() const;
    VOID InitBoard();

    Event GetEvent();
    DWORD GetEventJapan();
    Event GetControllerEvent();

    VOID UpdateState( Event );
    VOID UpdateStateJapan();
    VOID PressCurrent();
    VOID Press( Xkey );
    VOID MoveUp();
    VOID MoveDown();
    VOID MoveLeft();
    VOID MoveRight();
    VOID SetLastColumn();

    VOID DrawTextBox() const;
    VOID DrawButton( FLOAT fX, WCHAR chButton ) const;
    VOID RenderStartScreen() const;
    VOID RenderMenu() const;
    VOID RenderKeyboard() const;
    VOID RenderKeyboardLatin() const;
    VOID RenderKeyboardJapan() const;
    VOID RenderHelp() const;
    VOID RenderKey( FLOAT fX, FLOAT fY, const Key & pKey, D3DCOLOR selKeyColor,
                    D3DCOLOR selTextColor ) const;
    VOID DrawText( FLOAT x, FLOAT y ) const;
    VOID DrawTextLatin( FLOAT x, FLOAT y ) const;
    VOID DrawTextJapan( FLOAT x, FLOAT y ) const;

    VOID    DrawJapanese( FLOAT x, FLOAT y, DWORD, const WCHAR*, DWORD ) const;
    HRESULT DrawControllerS() const;

    BOOL IsKeyDisabled() const;
    VOID PlayClick() const;
    WCHAR GetChar( Xkey ) const;
    static WCHAR ToUpper( WCHAR );
    static WCHAR ToLower( WCHAR );

};

// Hiragana characters
#define JH_SP   L"\x3040"
#define JH_LA   L"\x3041"
#define JH_A    L"\x3042"
#define JH_LI   L"\x3043"
#define JH_I    L"\x3044"
#define JH_LU   L"\x3045"
#define JH_U    L"\x3046"
#define JH_LE   L"\x3047"
#define JH_E    L"\x3048"
#define JH_LO   L"\x3049"
#define JH_O    L"\x304A"
#define JH_KA   L"\x304B"
#define JH_GA   L"\x304C"
#define JH_KI   L"\x304D"
#define JH_GI   L"\x304E"
#define JH_KU   L"\x304F"
#define JH_GU   L"\x3050"
#define JH_KE   L"\x3051"
#define JH_GE   L"\x3052"
#define JH_KO   L"\x3053"
#define JH_GO   L"\x3054"
#define JH_SA   L"\x3055"
#define JH_ZA   L"\x3056"
#define JH_SI   L"\x3057"
#define JH_ZI   L"\x3058"
#define JH_SU   L"\x3059"
#define JH_ZU   L"\x305A"
#define JH_SE   L"\x305B"
#define JH_ZE   L"\x305C"
#define JH_SO   L"\x305D"
#define JH_ZO   L"\x305E"
#define JH_TA   L"\x305F"
#define JH_DA   L"\x3060"
#define JH_TI   L"\x3061"
#define JH_DI   L"\x3062"
#define JH_LTU  L"\x3063"
#define JH_TU   L"\x3064"
#define JH_DU   L"\x3065"
#define JH_TE   L"\x3066"
#define JH_DE   L"\x3067"
#define JH_TO   L"\x3068"
#define JH_DO   L"\x3069"
#define JH_NA   L"\x306A"
#define JH_NI   L"\x306B"
#define JH_NU   L"\x306C"
#define JH_NE   L"\x306D"
#define JH_NO   L"\x306E"
#define JH_HA   L"\x306F"
#define JH_BA   L"\x3070"
#define JH_PA   L"\x3071"
#define JH_HI   L"\x3072"
#define JH_BI   L"\x3073"
#define JH_PI   L"\x3074"
#define JH_HU   L"\x3075"
#define JH_BU   L"\x3076"
#define JH_PU   L"\x3077"
#define JH_HE   L"\x3078"
#define JH_BE   L"\x3079"
#define JH_PE   L"\x307A"
#define JH_HO   L"\x307B"
#define JH_BO   L"\x307C"
#define JH_PO   L"\x307D"
#define JH_MA   L"\x307E"
#define JH_MI   L"\x307F"
#define JH_MU   L"\x3080"
#define JH_ME   L"\x3081"
#define JH_MO   L"\x3082"
#define JH_LYA  L"\x3083"
#define JH_YA   L"\x3084"
#define JH_LYU  L"\x3085"
#define JH_YU   L"\x3086"
#define JH_LYO  L"\x3087"
#define JH_YO   L"\x3088"
#define JH_RA   L"\x3089"
#define JH_RI   L"\x308A"
#define JH_RU   L"\x308B"
#define JH_RE   L"\x308C"
#define JH_RO   L"\x308D"
#define JH_LWA  L"\x308E"
#define JH_WA   L"\x308F"
#define JH_WI   L"\x3090"
#define JH_WE   L"\x3091"
#define JH_WO   L"\x3092"
#define JH_N    L"\x3093"
#define JH_VU   L"\x3094"
#define JH_NULL L"\xFFFF"

// Katakana characters
#define JK_SP   L"\x30A0"
#define JK_LA   L"\x30A1"
#define JK_A    L"\x30A2"
#define JK_LI   L"\x30A3"
#define JK_I    L"\x30A4"
#define JK_LU   L"\x30A5"
#define JK_U    L"\x30A6"
#define JK_LE   L"\x30A7"
#define JK_E    L"\x30A8"
#define JK_LO   L"\x30A9"
#define JK_O    L"\x30AA"
#define JK_KA   L"\x30AB"
#define JK_GA   L"\x30AC"
#define JK_KI   L"\x30AD"
#define JK_GI   L"\x30AE"
#define JK_KU   L"\x30AF"
#define JK_GU   L"\x30B0"
#define JK_KE   L"\x30B1"
#define JK_GE   L"\x30B2"
#define JK_KO   L"\x30B3"
#define JK_GO   L"\x30B4"
#define JK_SA   L"\x30B5"
#define JK_ZA   L"\x30B6"
#define JK_SI   L"\x30B7"
#define JK_ZI   L"\x30B8"
#define JK_SU   L"\x30B9"
#define JK_ZU   L"\x30BA"
#define JK_SE   L"\x30BB"
#define JK_ZE   L"\x30BC"
#define JK_SO   L"\x30BD"
#define JK_ZO   L"\x30BE"
#define JK_TA   L"\x30BF"
#define JK_DA   L"\x30C0"
#define JK_TI   L"\x30C1"
#define JK_DI   L"\x30C2"
#define JK_LTU  L"\x30C3"
#define JK_TU   L"\x30C4"
#define JK_DU   L"\x30C5"
#define JK_TE   L"\x30C6"
#define JK_DE   L"\x30C7"
#define JK_TO   L"\x30C8"
#define JK_DO   L"\x30C9"
#define JK_NA   L"\x30CA"
#define JK_NI   L"\x30CB"
#define JK_NU   L"\x30CC"
#define JK_NE   L"\x30CD"
#define JK_NO   L"\x30CE"
#define JK_HA   L"\x30CF"
#define JK_BA   L"\x30D0"
#define JK_PA   L"\x30D1"
#define JK_HI   L"\x30D2"
#define JK_BI   L"\x30D3"
#define JK_PI   L"\x30D4"
#define JK_HU   L"\x30D5"
#define JK_BU   L"\x30D6"
#define JK_PU   L"\x30D7"
#define JK_HE   L"\x30D8"
#define JK_BE   L"\x30D9"
#define JK_PE   L"\x30DA"
#define JK_HO   L"\x30DB"
#define JK_BO   L"\x30DC"
#define JK_PO   L"\x30DD"
#define JK_MA   L"\x30DE"
#define JK_MI   L"\x30DF"
#define JK_MU   L"\x30E0"
#define JK_ME   L"\x30E1"
#define JK_MO   L"\x30E2"
#define JK_LYA  L"\x30E3"
#define JK_YA   L"\x30E4"
#define JK_LYU  L"\x30E5"
#define JK_YU   L"\x30E6"
#define JK_LYO  L"\x30E7"
#define JK_YO   L"\x30E8"
#define JK_RA   L"\x30E9"
#define JK_RI   L"\x30EA"
#define JK_RU   L"\x30EB"
#define JK_RE   L"\x30EC"
#define JK_RO   L"\x30ED"
#define JK_LWA  L"\x30EE"
#define JK_WA   L"\x30EF"
#define JK_WI   L"\x30F0"
#define JK_WE   L"\x30F1"
#define JK_WO   L"\x30F2"
#define JK_N    L"\x30F3"
#define JK_VU   L"\x30F4"
#define JK_DASH L"\x30FC"
#define JK_NULL L"\xFFFF"

#endif // XBVIRTUAL_KEYBOARD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\refui\VirtualKeyboard\VirtualKeyboard.cpp ===
//-----------------------------------------------------------------------------
// File: VirtualKeyboard.cpp
//
// Desc: Virtual keyboard reference UI
//
// Hist: 02.13.01 - New for March XDK release 
//       03.07.01 - Localized for April XDK release
//       04.10.01 - Updated for May XDK with full translations
//       06.06.01 - Japanese keyboard added
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// This sample is intended to show appropriate functionality only. Please 
// do not lift the graphics for use in your game. A description of the user 
// research that went into the creation of this sample is located in the 
// XDK documentation at Developing for Xbox - Reference User Interface
//
//-----------------------------------------------------------------------------
#include "VirtualKeyboard.h"
#include <cassert>
#include <algorithm>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"

// The following header file is generated from "ControllerS.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (ControllerS.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "ControllerS.h"




//-----------------------------------------------------------------------------
// Help text
//-----------------------------------------------------------------------------
struct HelpStrings
{
    WCHAR* strSelect;
    WCHAR* strCancel;
    WCHAR* strToggle;
    WCHAR* strHelp;
    WCHAR* strBackspace;
    WCHAR* strSpace;
    WCHAR* strTrigger;
};
HelpStrings *g_HelpStr;

const UINT XC_LANGUAGE_MAX = XC_LANGUAGE_ITALIAN + 1;

// Must match XC_LANGUAGE_* constants in xbox.h
// Accented chars must be specified in Unicode to build properly on 
// Far East versions of Windows
const WCHAR* g_strLanguage[] =
{
    L"",                        // Unknown (not used)
    L"English",                 // English
    JH_NI JH_HO JH_N JH_GO,     // Japanese (displayed if VKEY_JAPAN #defined)
    L"Deutsch",                 // German
    L"Fran" L"\xE7" L"ais",     // French
    L"Espa" L"\xF1" L"ol",      // Spanish
    L"Italiano",                // Italian
};

UINT CXBVirtualKeyboard::Key::iLang = XC_LANGUAGE_ENGLISH;




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// These are the widths of the keys on the display. GAP2 is the distance
// between the mode keys on the left and the rest of the keyboard. The safe
// title area is 512 pixels across, so these values must meet the following
// guideline: MODEKEY_WIDTH + GAP2_WIDTH + (10*KEY_WIDTH) + (9*GAP_WIDTH) <=512
const DWORD GAP_WIDTH     = 0;
const DWORD GAP2_WIDTH    = 4;
const DWORD MODEKEY_WIDTH = 166;
const DWORD KEY_INSET     = 1;
const FLOAT KEY_HEIGHT    = 42.0f;

const DWORD MAX_KEYS_PER_ROW = 14;

// Must be this far from center on 0.0 - 1.0 scale
const FLOAT JOY_THRESHOLD = 0.25f; 

// How often (per second) the caret blinks
const FLOAT fCARET_BLINK_RATE = 1.0f;

// During the blink period, the amount the caret is visible. 0.5 equals
// half the time, 0.75 equals 3/4ths of the time, etc.
const FLOAT fCARET_ON_RATIO = 0.75f;

// Text colors for keys
const D3DCOLOR COLOR_TEXT          = 0xFF00FF00;   // green
const D3DCOLOR COLOR_HIGHLIGHT     = 0xFF00FF00;   // green
const D3DCOLOR COLOR_PRESSED       = 0xFF808080;   // gray
const D3DCOLOR COLOR_NORMAL        = 0xFF000000;   // black
const D3DCOLOR COLOR_DISABLED      = 0xFFFFFFFF;   // white
const D3DCOLOR COLOR_HELPTEXT      = 0xFFFFFFFF;   // white
const D3DCOLOR COLOR_FONT_DISABLED = 0xFF808080;   // gray
const D3DCOLOR COLOR_INVISIBLE     = 0xFF0000FF;   // blue
const D3DCOLOR COLOR_RED           = 0xFFFF0000;   // red

// Controller repeat values
const FLOAT fINITIAL_REPEAT = 0.333f; // 333 mS recommended for first repeat
const FLOAT fSTD_REPEAT     = 0.085f; // 85 mS recommended for repeat rate

// Maximum number of characters in string
const DWORD MAX_CHARS = 64;

// Width of text box
const FLOAT fTEXTBOX_WIDTH = 576.0f - 64.0f - 4.0f - 4.0f - 10.0f;

const FLOAT BUTTON_Y = 400.0f;          // button text line
const FLOAT BUTTON_OFFSET = 40.0f;      // space between button and text
const D3DCOLOR BUTTON_COLOR = 0xFFFFFFFF;
const D3DCOLOR BUTTON_TEXT  = 0xFFFFFFFF;
const FLOAT FIXED_JSL_SIZE = 3.0f;

// Xboxdings font button mappings
const WCHAR BTN_A = L'A';
const WCHAR BTN_B = L'B';
const WCHAR BTN_X = L'C';
const WCHAR BTN_Y = L'D';




//-----------------------------------------------------------------------------
// Standard text
// Order of text matches XC_LANGUAGE_XXX #definitions in Xbox.h
//-----------------------------------------------------------------------------

const WCHAR* const strCHOOSE_KEYBOARD[7] = 
{
    L"",
    L"Choose Keyboard",
    JK_KI JK_DASH JK_BO JK_DASH JK_DO JH_WO JH_E JH_RA JH_N JH_DE JH_KU
    JH_DA JH_SA JH_I, // JP
    L"Tastatur ausw" L"\xE4" L"hlen", // DE
    L"Choisir le clavier", // FR
    L"Elegir teclado", // ES
    L"Scegli tastiera", // IT
};

const WCHAR* const strILLUSTRATIVE_GRAPHICS[7] = 
{
    L"",
    L"Sample graphics. Don't use in your game",
    JH_TO JH_KU JH_BE JH_TU JH_SI JH_YO JH_U JH_NO JK_KI JK_DASH JK_BO
    JK_DASH JK_DO, // JP
    L"Grafiken nur zur Illustration", // DE
    L"Exemples de graphiques uniquement", // FR
    L"Gr" L"\xE1" L"ficos s" L"\xF3" L"lo de muestra", // ES
    L"Grafica solo dimostrativa", // IT
};

const WCHAR* const strA_SELECT[ 7 ] = 
{
    L"",
    L"select",
    JH_KE JH_LTU JH_TE JH_I, // JP
    L"ausw" L"\xE4" L"hlen", // DE
    L"s" L"\xE9" L"lectionner", // FR               
    L"seleccionar", // ES
    L"seleziona", // IT
};

const WCHAR* const strB_BACK[ 7 ] = 
{
    L"",
    L"back",
    JH_MO JH_DO JH_RU, // JP
    L"zur" L"\xFC" L"ck", // DE
    L"retour", // FR
    L"atr" L"\xE1" L"s", // ES
    L"indietro", // IT
};

const WCHAR* const strY_HELP[7] =
{
    L"",
    L"help",
    JK_HE JK_RU JK_PU, // JP
    L"Hilfe", // DE
    L"aide",  // FR
    L"ayuda", // ES
    L"aiuto", // IT
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBVirtualKeyboard xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBVirtualKeyboard::Key()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBVirtualKeyboard::Key::Key( Xkey xk, DWORD w )
:
    xKey( xk ),
    dwWidth( w ),
    strName()
{
    if( iLang == XC_LANGUAGE_JAPANESE )
    {
        // No key names for Japanese
        strName = L"";
        return;
    }

    // Special keys get their own names
    switch( xKey )
    {
        case XK_SPACE:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Space";             break;
                case XC_LANGUAGE_GERMAN:  strName = L"LEERTASTE";         break;
                case XC_LANGUAGE_FRENCH:  strName = L"Espace";            break;
                case XC_LANGUAGE_SPANISH: strName = L"Espacio";           break;
                case XC_LANGUAGE_ITALIAN: strName = L"BARRA SPAZIATRICE"; break;
            }
            break;
        case XK_BACKSPACE:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Backspace";         break;
                case XC_LANGUAGE_GERMAN:  strName = L"R" L"\xDC" L"CKTASTE"; break;
                case XC_LANGUAGE_FRENCH:  strName = L"Ret. arr";          break;
                case XC_LANGUAGE_SPANISH: strName = L"Retroceso";         break;
                case XC_LANGUAGE_ITALIAN: strName = L"BACKSPACE";         break;
            }
            break;
        case XK_SHIFT:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Shift";             break;
                case XC_LANGUAGE_GERMAN:  strName = L"UMSCHALTTASTE";     break;
                case XC_LANGUAGE_FRENCH:  strName = L"Maj.";              break;
                case XC_LANGUAGE_SPANISH: strName = L"May" L"\xFA" L"s";  break;
                case XC_LANGUAGE_ITALIAN: strName = L"MAIUSC";            break;
            }
            break;
        case XK_CAPSLOCK:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Caps Lock";         break;
                case XC_LANGUAGE_GERMAN:  strName = L"FESTSTELLTASTE";    break;
                case XC_LANGUAGE_FRENCH:  strName = L"Verr. maj.";        break;
                case XC_LANGUAGE_SPANISH: strName = L"Bloq may" L"\xFA" L"s"; break;
                case XC_LANGUAGE_ITALIAN: strName = L"BLOC MAIUSC";       break;
            }
            break;
        case XK_ALPHABET:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Alphabet";        break;
                case XC_LANGUAGE_GERMAN:  strName = L"Alphabet";        break;
                case XC_LANGUAGE_FRENCH:  strName = L"Alphabet";        break;
                case XC_LANGUAGE_SPANISH: strName = L"Alfabeto";        break;
                case XC_LANGUAGE_ITALIAN: strName = L"Alfabeto";        break;
            }
            break;
        case XK_SYMBOLS:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Symbols";         break;
                case XC_LANGUAGE_GERMAN:  strName = L"Symbole";         break;
                case XC_LANGUAGE_FRENCH:  strName = L"Symbole";         break;
                case XC_LANGUAGE_SPANISH: strName = L"Simbolos";        break;
                case XC_LANGUAGE_ITALIAN: strName = L"Simboli";         break;
            }
            break;
        case XK_ACCENTS:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Accents";         break;
                case XC_LANGUAGE_GERMAN:  strName = L"Akzente";         break;
                case XC_LANGUAGE_FRENCH:  strName = L"Accents";         break;
                case XC_LANGUAGE_SPANISH: strName = L"Accentos";        break;
                case XC_LANGUAGE_ITALIAN: strName = L"Accenti";         break;
            }
            break;
        case XK_OK:
            switch( iLang )
            {   
                default:
                case XC_LANGUAGE_ENGLISH: strName = L"Done";            break;
                case XC_LANGUAGE_GERMAN:  strName = L"Fertig";          break;
                case XC_LANGUAGE_FRENCH:  strName = L"Termin" L"\xE9";  break;
                case XC_LANGUAGE_SPANISH: strName = L"Hecho";           break;
                case XC_LANGUAGE_ITALIAN: strName = L"Chiudi";          break;
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: CXBVirtualKeyboard()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBVirtualKeyboard::CXBVirtualKeyboard()
:
    CXBApplication   (),
    m_xprResource    (),
    m_xprControllerS (),
    m_FontLatin      (),
    m_FontJapan      (),
    m_FontCaps       (),
    m_FontArrows     (),
    m_FontEuro       (),
    m_FontBtn        (),
    m_bIsCapsLockOn  ( FALSE ),
    m_bIsShiftOn     ( FALSE ),
    m_State          ( STATE_STARTSCREEN ),
    m_iLanguage      ( XC_LANGUAGE_ENGLISH ),
    m_strData        (),
    m_iPos           ( 0 ),
    m_KeyboardList   (),
    m_iCurrBoard     ( TYPE_ALPHABET ),
    m_iCurrRow       ( 0 ),
    m_iCurrKey       ( 0 ),
    m_iLastColumn    ( 0 ),
    m_RepeatTimer    ( FALSE ),
    m_fRepeatDelay   ( fINITIAL_REPEAT ),
    m_CaretTimer     ( TRUE ),
    m_Help           (),
    m_ptKey          ( NULL ),
    m_ptControllerS  ( NULL ),
    m_ClickSnd       (),
    m_dwCurrCtlrState( 0 ),
    m_dwOldCtlrState ( 0 ),
    m_xNextKeyJpn    ( XK_NULL ),
    m_bTrig          ( FALSE ),
    m_bKana          ( FALSE )
{
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Sets up the virtual keyboard example
//-----------------------------------------------------------------------------
HRESULT CXBVirtualKeyboard::Initialize()
{
    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Help text for controller mappings
    g_HelpStr = new HelpStrings [ XC_LANGUAGE_MAX ];

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strSelect = L"Select";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strSelect = L"Ausw" L"\xE4" L"hlen";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strSelect = L"S" L"\xE9" L"lectionner";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strSelect = L"Seleccionar";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strSelect = L"Seleziona";

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strCancel = L"Cancel";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strCancel = L"Abbrechen";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strCancel = L"Annuler";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strCancel = L"Cancelar";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strCancel = L"Annulla";

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strToggle = L"Toggle\nmode";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strToggle = L"Modus\nwechseln";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strToggle = L"Basculer\nles modes";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strToggle = L"Alternar\nmodo";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strToggle = L"Alterna\nmodalit" L"\xE0";

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strHelp = L"Display help";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strHelp = L"Hilfe anzeigen";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strHelp = L"Afficher l'aide";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strHelp = L"Mostrar ayuda";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strHelp = L"Visualizza\nla Guida";

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strBackspace = L"Backspace";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strBackspace = L"R" L"\xFC" L"cktaste";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strBackspace = L"Retour arri" L"\xE8" L"re";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strBackspace = L"Retroceso";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strBackspace = L"\nBackspace";

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strSpace = L"Space";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strSpace = L"Leertaste";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strSpace = L"Espace";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strSpace = L"Espacio";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strSpace = L"Spazio";

    g_HelpStr[ XC_LANGUAGE_ENGLISH ].strTrigger = L"Trigger buttons move cursor";
    g_HelpStr[ XC_LANGUAGE_GERMAN  ].strTrigger = L"Schalter-Tasten bewegen den Cursor";
    g_HelpStr[ XC_LANGUAGE_FRENCH  ].strTrigger = L"Les g" L"\xE2" L"chettes d" L"\xE9" L"placent le curseur";
    g_HelpStr[ XC_LANGUAGE_SPANISH ].strTrigger = L"Los disparadores mueven el cursor";
    g_HelpStr[ XC_LANGUAGE_ITALIAN ].strTrigger = L"I grilletti permettono di spostare il cursore";

    // Set the matrices
    D3DXVECTOR3 vEye(-2.5f, 2.0f, -4.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEye,&vAt, &vUp );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Arial Unicode MS 18, regular, 32-376, for keys
    if( FAILED( m_FontLatin.Create( g_pd3dDevice, "Font18.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Arial 12, bold, 32-255, for capital words on keys
    if( FAILED( m_FontCaps.Create( g_pd3dDevice, "Font12.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Arial Unicode MS, 8882 - 8883
    if( FAILED( m_FontArrows.Create( g_pd3dDevice, "FontArrows.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Arial Unicode MS 12, regular, 8364
    if( FAILED( m_FontEuro.Create( g_pd3dDevice, "FontEuro.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Xbox dingbats (buttons) 24
    if( FAILED( m_FontBtn.Create( g_pd3dDevice, "Xboxdings_24.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

#ifdef VKEY_JAPAN
    // Only need to load these resources if want to support Japanese
    // virtual keyboard

    // Japanese font
    if( FAILED( m_FontJapan.Create( g_pd3dDevice, "FontJapanese.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // ControllerS gamepad
    if( FAILED( m_xprControllerS.Create( m_pd3dDevice, "ControllerS.xpr", 
                                         ControllerS_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_ptControllerS = m_xprControllerS.GetTexture( 
                                        ControllerS_ControllerSTexture_OFFSET );
#endif

    // Load the click sound
    if( FAILED( m_ClickSnd.Create( "Sounds\\Click.wav" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Validate key sizes
    assert( MODEKEY_WIDTH + GAP2_WIDTH + (10 * KEY_WIDTH) + (9 * GAP_WIDTH) <= 512 );

    // Create the keyboard key texture
    m_ptKey = m_xprResource.GetTexture( resource_MsgBox_OFFSET );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame; the entry point for animating the scene
//-----------------------------------------------------------------------------
HRESULT CXBVirtualKeyboard::FrameMove()
{
    ValidateState();

    // Poll the system for events
    Event ev = GetEvent();

    if( m_iLanguage == XC_LANGUAGE_JAPANESE && m_State == STATE_KEYBOARD )
    {
        if( ev == EV_BACK_BUTTON )
        {
            m_State = STATE_MENU;
        }
        else
        {
            // Must get additional information from the controller
            m_dwCurrCtlrState = GetEventJapan();
            UpdateStateJapan();
        }
    }
    else
    {
        // Normal state update
        UpdateState( ev );
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d rendering.
//       This function sets up render states, clears the viewport, and renders
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBVirtualKeyboard::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | 
                         D3DCLEAR_STENCIL, 0x000000FF, 1.0f, 0L );

    switch( m_State )
    {
        case STATE_STARTSCREEN: RenderStartScreen(); break;
        case STATE_MENU:        RenderMenu();        break;
        case STATE_KEYBOARD:    RenderKeyboard();    break;
        case STATE_HELP:        RenderHelp();        break;
        default:                assert( FALSE );     break;
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ValidateState()
// Desc: Check object invariants
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::ValidateState() const
{
    assert( m_State >= 0 );
    assert( m_State < STATE_MAX );
    assert( m_iLanguage > 0 );

#ifndef VKEY_JAPAN
    // If we're not supporting Japanese, the language should never be Japanese
    assert( m_iLanguage != XC_LANGUAGE_JAPANESE );
#endif

    assert( m_iLanguage < XC_LANGUAGE_MAX );
    assert( m_iPos <= m_strData.length() );
    assert( m_iCurrBoard <= m_KeyboardList.size() );
    assert( m_iCurrRow < MAX_ROWS );
    if( !m_KeyboardList.empty() )
        assert( m_iCurrKey < m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ].size() );
}




//-----------------------------------------------------------------------------
// Name: InitBoard()
// Desc: Sets up the virtual keyboard for the selected language
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::InitBoard()
{
    // Restore keyboard to default state
    m_iCurrRow = 1;
    m_iCurrKey = 1;
    m_iLastColumn = 1;
    m_iCurrBoard = TYPE_ALPHABET;
    m_bIsCapsLockOn = FALSE;
    m_bIsShiftOn = FALSE;
    m_strData.erase();
    m_iPos = 0;

    // Notify the keys of the language
    Key::iLang = m_iLanguage;

    // Destroy old keyboard
    m_KeyboardList.clear();

    // Japanese doesn't use a Latin keyboard layout, so we can skip the
    // keyboard initialization
    if( m_iLanguage == XC_LANGUAGE_JAPANESE )
        return;

    //-------------------------------------------------------------------------
    // Alpha keyboard
    //-------------------------------------------------------------------------

    Keyboard keyBoard;
    keyBoard.reserve( MAX_ROWS );
    keyBoard.clear();

    KeyRow keyRow;
    keyRow.reserve( MAX_KEYS_PER_ROW );

    // First row is Done, 1-0
    keyRow.clear();
    keyRow.push_back( Key( XK_OK, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_1 ) );
    keyRow.push_back( Key( XK_2 ) );
    keyRow.push_back( Key( XK_3 ) );
    keyRow.push_back( Key( XK_4 ) );
    keyRow.push_back( Key( XK_5 ) );
    keyRow.push_back( Key( XK_6 ) );
    keyRow.push_back( Key( XK_7 ) );
    keyRow.push_back( Key( XK_8 ) );
    keyRow.push_back( Key( XK_9 ) );
    keyRow.push_back( Key( XK_0 ) );
    keyBoard.push_back( keyRow );

    // Second row is Shift, A-J
    keyRow.clear();
    keyRow.push_back( Key( XK_SHIFT, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_A ) );
    keyRow.push_back( Key( XK_B ) );
    keyRow.push_back( Key( XK_C ) );
    keyRow.push_back( Key( XK_D ) );
    keyRow.push_back( Key( XK_E ) );
    keyRow.push_back( Key( XK_F ) );
    keyRow.push_back( Key( XK_G ) );
    keyRow.push_back( Key( XK_H ) );
    keyRow.push_back( Key( XK_I ) );
    keyRow.push_back( Key( XK_J ) );
    keyBoard.push_back( keyRow );

    // Third row is Caps Lock, K-T
    keyRow.clear();
    keyRow.push_back( Key( XK_CAPSLOCK, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_K ) );
    keyRow.push_back( Key( XK_L ) );
    keyRow.push_back( Key( XK_M ) );
    keyRow.push_back( Key( XK_N ) );
    keyRow.push_back( Key( XK_O ) );
    keyRow.push_back( Key( XK_P ) );
    keyRow.push_back( Key( XK_Q ) );
    keyRow.push_back( Key( XK_R ) );
    keyRow.push_back( Key( XK_S ) );
    keyRow.push_back( Key( XK_T ) );
    keyBoard.push_back( keyRow );

    // Fourth row is Symbols, U-Z, Backspace
    keyRow.clear();
    keyRow.push_back( Key( XK_SYMBOLS, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_U ) );
    keyRow.push_back( Key( XK_V ) );
    keyRow.push_back( Key( XK_W ) );
    keyRow.push_back( Key( XK_X ) );
    keyRow.push_back( Key( XK_Y ) );
    keyRow.push_back( Key( XK_Z ) );
    keyRow.push_back( Key( XK_BACKSPACE, (KEY_WIDTH * 4) + (GAP_WIDTH * 3) ) );
    keyBoard.push_back( keyRow );

    // Fifth row is Accents, Space, Left, Right
    keyRow.clear();
    keyRow.push_back( Key( XK_ACCENTS, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_SPACE, (KEY_WIDTH * 6) + (GAP_WIDTH * 5) ) );
    keyRow.push_back( Key( XK_ARROWLEFT, (KEY_WIDTH * 2) + (GAP_WIDTH * 1) ) );
    keyRow.push_back( Key( XK_ARROWRIGHT, (KEY_WIDTH * 2) + (GAP_WIDTH * 1) ) );
    keyBoard.push_back( keyRow );

    // Add the alpha keyboard to the list
    m_KeyboardList.push_back( keyBoard );

    //-------------------------------------------------------------------------
    // Symbol keyboard
    //-------------------------------------------------------------------------

    keyBoard.clear();

    // First row
    keyRow.clear();
    keyRow.push_back( Key( XK_OK, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_LPAREN ) );
    keyRow.push_back( Key( XK_RPAREN ) );
    keyRow.push_back( Key( XK_AMPER ) );
    keyRow.push_back( Key( XK_UNDERS ) );
    keyRow.push_back( Key( XK_CARET ) );
    keyRow.push_back( Key( XK_PERCENT ) );
    keyRow.push_back( Key( XK_BSLASH ) );
    keyRow.push_back( Key( XK_FSLASH ) );
    keyRow.push_back( Key( XK_AT ) );
    keyRow.push_back( Key( XK_NSIGN ) );
    keyBoard.push_back( keyRow );

    // Second row
    keyRow.clear();
    keyRow.push_back( Key( XK_SHIFT, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_LBRACK ) );
    keyRow.push_back( Key( XK_RBRACK ) );
    keyRow.push_back( Key( XK_DOLLAR ) );
    keyRow.push_back( Key( XK_POUND_SIGN ) );
    keyRow.push_back( Key( XK_YEN_SIGN ) );
    keyRow.push_back( Key( XK_EURO_SIGN ) );
    keyRow.push_back( Key( XK_SEMI ) );
    keyRow.push_back( Key( XK_COLON ) );
    keyRow.push_back( Key( XK_QUOTE ) );
    keyRow.push_back( Key( XK_DQUOTE ) );
    keyBoard.push_back( keyRow );

    // Third row
    keyRow.clear();
    keyRow.push_back( Key( XK_CAPSLOCK, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_LT ) );
    keyRow.push_back( Key( XK_GT ) );
    keyRow.push_back( Key( XK_QMARK ) );
    keyRow.push_back( Key( XK_EXCL ) );
    keyRow.push_back( Key( XK_INVERTED_QMARK ) );
    keyRow.push_back( Key( XK_INVERTED_EXCL ) );
    keyRow.push_back( Key( XK_DASH ) );
    keyRow.push_back( Key( XK_STAR ) );
    keyRow.push_back( Key( XK_PLUS ) );
    keyRow.push_back( Key( XK_EQUAL ) );
    keyBoard.push_back( keyRow );

    // Fourth row
    keyRow.clear();
    keyRow.push_back( Key( XK_ALPHABET, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_LBRACE ) );
    keyRow.push_back( Key( XK_RBRACE ) );
    keyRow.push_back( Key( XK_LT_DBL_ANGLE_QUOTE ) );
    keyRow.push_back( Key( XK_RT_DBL_ANGLE_QUOTE ) );
    keyRow.push_back( Key( XK_COMMA ) );
    keyRow.push_back( Key( XK_PERIOD ) );
    keyRow.push_back( Key( XK_BACKSPACE, (KEY_WIDTH * 4) + (GAP_WIDTH * 3) ) );
    keyBoard.push_back( keyRow );

    // Fifth row is Accents, Space, Left, Right
    keyRow.clear();
    keyRow.push_back( Key( XK_ACCENTS, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_SPACE, (KEY_WIDTH * 6) + (GAP_WIDTH * 5) ) );
    keyRow.push_back( Key( XK_ARROWLEFT, (KEY_WIDTH * 2) + (GAP_WIDTH * 1) ) );
    keyRow.push_back( Key( XK_ARROWRIGHT, (KEY_WIDTH * 2) + (GAP_WIDTH * 1) ) );
    keyBoard.push_back( keyRow );

    // Add the symbol keyboard to the list
    m_KeyboardList.push_back( keyBoard );

    //-------------------------------------------------------------------------
    // Accents keyboard
    //-------------------------------------------------------------------------

    keyBoard.clear();

    // First row
    keyRow.clear();
    keyRow.push_back( Key( XK_OK, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_1 ) );
    keyRow.push_back( Key( XK_2 ) );
    keyRow.push_back( Key( XK_3 ) );
    keyRow.push_back( Key( XK_4 ) );
    keyRow.push_back( Key( XK_5 ) );
    keyRow.push_back( Key( XK_6 ) );
    keyRow.push_back( Key( XK_7 ) );
    keyRow.push_back( Key( XK_8 ) );
    keyRow.push_back( Key( XK_9 ) );
    keyRow.push_back( Key( XK_0 ) );
    keyBoard.push_back( keyRow );

    // Second row
    keyRow.clear();
    keyRow.push_back( Key( XK_SHIFT, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_CAP_A_GRAVE ) );
    keyRow.push_back( Key( XK_CAP_A_ACUTE ) );
    keyRow.push_back( Key( XK_CAP_A_CIRCUMFLEX ) );
    keyRow.push_back( Key( XK_CAP_A_DIAERESIS ) );
    keyRow.push_back( Key( XK_CAP_C_CEDILLA ) );
    keyRow.push_back( Key( XK_CAP_E_GRAVE ) );
    keyRow.push_back( Key( XK_CAP_E_ACUTE ) );
    keyRow.push_back( Key( XK_CAP_E_CIRCUMFLEX ) );
    keyRow.push_back( Key( XK_CAP_E_DIAERESIS ) );
    keyRow.push_back( Key( XK_CAP_I_GRAVE ) );
    keyBoard.push_back( keyRow );

    // Third row
    keyRow.clear();
    keyRow.push_back( Key( XK_CAPSLOCK, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_CAP_I_ACUTE ) );
    keyRow.push_back( Key( XK_CAP_I_CIRCUMFLEX ) );
    keyRow.push_back( Key( XK_CAP_I_DIAERESIS ) );
    keyRow.push_back( Key( XK_CAP_N_TILDE ) );
    keyRow.push_back( Key( XK_CAP_O_GRAVE ) );
    keyRow.push_back( Key( XK_CAP_O_ACUTE ) );
    keyRow.push_back( Key( XK_CAP_O_CIRCUMFLEX ) );
    keyRow.push_back( Key( XK_CAP_O_TILDE ) );
    keyRow.push_back( Key( XK_CAP_O_DIAERESIS ) );
    keyRow.push_back( Key( XK_SM_SHARP_S ) );
    keyBoard.push_back( keyRow );

    // Fourth row
    keyRow.clear();
    keyRow.push_back( Key( XK_ALPHABET, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_CAP_U_GRAVE ) );
    keyRow.push_back( Key( XK_CAP_U_ACUTE ) );
    keyRow.push_back( Key( XK_CAP_U_CIRCUMFLEX ) );
    keyRow.push_back( Key( XK_CAP_U_DIAERESIS ) );
    keyRow.push_back( Key( XK_CAP_Y_ACUTE ) );
    keyRow.push_back( Key( XK_CAP_Y_DIAERESIS ) );
    keyRow.push_back( Key( XK_BACKSPACE, (KEY_WIDTH * 4) + (GAP_WIDTH * 3) ) );
    keyBoard.push_back( keyRow );

    // Fifth row
    keyRow.clear();
    keyRow.push_back( Key( XK_ACCENTS, MODEKEY_WIDTH ) );
    keyRow.push_back( Key( XK_SPACE, (KEY_WIDTH * 6) + (GAP_WIDTH * 5) ) );
    keyRow.push_back( Key( XK_ARROWLEFT, (KEY_WIDTH * 2) + (GAP_WIDTH * 1) ) );
    keyRow.push_back( Key( XK_ARROWRIGHT, (KEY_WIDTH * 2) + (GAP_WIDTH * 1) ) );
    keyBoard.push_back( keyRow );

    // Add the accents keyboard to the list
    m_KeyboardList.push_back( keyBoard );

}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Polls the controller for events. Returns EV_NULL if no event
//-----------------------------------------------------------------------------
CXBVirtualKeyboard::Event CXBVirtualKeyboard::GetEvent()
{
    // Query the primary controller
    Event evControllerClick = GetControllerEvent();

    if( evControllerClick != EV_NULL && 
        m_iLanguage != XC_LANGUAGE_JAPANESE &&
        m_State == STATE_KEYBOARD )
    {
        PlayClick();
    }

    return evControllerClick;
}




//-----------------------------------------------------------------------------
// Name: IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 >  JOY_THRESHOLD ||
        pGamePad->fX1 < -JOY_THRESHOLD ||
        pGamePad->fY1 >  JOY_THRESHOLD ||
        pGamePad->fY1 < -JOY_THRESHOLD )
    {
        return TRUE;
    }

    if( pGamePad->fX2 >  JOY_THRESHOLD ||
        pGamePad->fX2 < -JOY_THRESHOLD ||
        pGamePad->fY2 >  JOY_THRESHOLD ||
        pGamePad->fY2 < -JOY_THRESHOLD )
    {
        return TRUE;
    }

    // Nothing active
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: GetEventJapan()
// Desc: Returns the full ControllerS state packed into a DWORD.
//       Remembers the "old" state of the controller.
//-----------------------------------------------------------------------------
DWORD CXBVirtualKeyboard::GetEventJapan()
{
    assert( m_iLanguage == XC_LANGUAGE_JAPANESE );
    const XBGAMEPAD* pGamePad = GetPrimaryController();
    if( pGamePad == NULL )
        return 0;

    DWORD dwCurrCtlrState = 0;

    // Primary buttons
    if( pGamePad->wButtons & XINPUT_GAMEPAD_START )
    {
        if( !(m_dwOldCtlrState & XKJ_START) )
        {
            dwCurrCtlrState |= XKJ_START;
            m_dwOldCtlrState |= XKJ_START;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_START;

    // "A"
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_A ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_A) )
        {
            dwCurrCtlrState |= XKJ_A;
            m_dwOldCtlrState |= XKJ_A;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_A;

    // "B"
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_B ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_B) )
        {
            dwCurrCtlrState |= XKJ_B;
            m_dwOldCtlrState |= XKJ_B;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_B;

    // "X"
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_X ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_X) )
        {
            dwCurrCtlrState |= XKJ_X;
            m_dwOldCtlrState |= XKJ_X;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_X;

    // "Y"
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_Y ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_Y) )
        {
            dwCurrCtlrState |= XKJ_Y;
            m_dwOldCtlrState |= XKJ_Y;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_Y;

    // black
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_BLACK) )
        {
            dwCurrCtlrState |= XKJ_BLACK;
            m_dwOldCtlrState |= XKJ_BLACK;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_BLACK;

    // white
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_WHITE) )
        {
            dwCurrCtlrState |= XKJ_WHITE;
            m_dwOldCtlrState |= XKJ_WHITE;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_WHITE;

    // left trigger
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_LEFT_TRIGGER ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_LEFTTR) )
        {
            dwCurrCtlrState |= XKJ_LEFTTR;
            m_dwOldCtlrState |= XKJ_LEFTTR;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_LEFTTR;

    // right trigger
    if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_RIGHT_TRIGGER ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
    {
        if( !(m_dwOldCtlrState & XKJ_RIGHTTR) )
        {
            dwCurrCtlrState |= XKJ_RIGHTTR;
            m_dwOldCtlrState |= XKJ_RIGHTTR;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_RIGHTTR;

    // Cursor Movement
    if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT )
    {
        if( !(m_dwOldCtlrState & XKJ_DLEFT) )
        {
            dwCurrCtlrState |= XKJ_DLEFT;
            m_dwOldCtlrState |= XKJ_DLEFT;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_DLEFT;

    if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
    {
        if( !(m_dwOldCtlrState & XKJ_DRIGHT) )
        {
            dwCurrCtlrState |= XKJ_DRIGHT;
            m_dwOldCtlrState |= XKJ_DRIGHT;
        }
    }
    else
        m_dwOldCtlrState &= ~XKJ_DRIGHT;

    if( pGamePad->fY1 > JOY_THRESHOLD )
        dwCurrCtlrState |= XKJ_UP;
    if( pGamePad->fY1 < -JOY_THRESHOLD )
        dwCurrCtlrState |= XKJ_DOWN;
    if( pGamePad->fX1 < -JOY_THRESHOLD )
        dwCurrCtlrState |= XKJ_LEFT;
    if( pGamePad->fX1 > JOY_THRESHOLD )
        dwCurrCtlrState |= XKJ_RIGHT;

    return dwCurrCtlrState;
}




//-----------------------------------------------------------------------------
// Name: GetControllerEvent()
// Desc: Polls the controller for events. Handles button repeats.
//-----------------------------------------------------------------------------
CXBVirtualKeyboard::Event CXBVirtualKeyboard::GetControllerEvent()
{
    const XBGAMEPAD* pGamePad = GetPrimaryController();
    if( pGamePad != NULL )
    {
        // Handle button press and joystick hold repeats
        BOOL bRepeat = FALSE;
        if( IsAnyButtonActive( pGamePad ) )
        {
            // If the timer is running, the button is being held. If it's
            // held long enough, it triggers a repeat. If the timer isn't
            // running, we start it.
            if( m_RepeatTimer.IsRunning() )
            {
                // If the timer is running but hasn't expired, bail out
                if( m_RepeatTimer.GetElapsedSeconds() < m_fRepeatDelay )
                    return EV_NULL;

                m_fRepeatDelay = fSTD_REPEAT;
                m_RepeatTimer.StartZero();
                bRepeat = TRUE;
            }
            else
            {
                m_fRepeatDelay = fINITIAL_REPEAT;
                m_RepeatTimer.StartZero();
            }
        }
        else
        {
            // No buttons or joysticks active; kill the repeat timer
            m_fRepeatDelay = fINITIAL_REPEAT;
            m_RepeatTimer.Stop();
        }

        // Only allow repeat for navigation or left/right arrows
        if( bRepeat )
        {
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_A ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            {
                if( !m_KeyboardList.empty() )
                {
                    Key key = m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ][ m_iCurrKey ];
                    if( key.xKey == XK_ARROWLEFT ||
                        key.xKey == XK_ARROWRIGHT )
                    {
                        return EV_A_BUTTON;
                    }
                }
            }
        }
        else
        {
            // Primary buttons
            if( pGamePad->wButtons & XINPUT_GAMEPAD_START )
                return EV_START_BUTTON;
            if( pGamePad->wButtons & XINPUT_GAMEPAD_BACK )
                return EV_BACK_BUTTON;
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_A ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                return EV_A_BUTTON;
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_B ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                return EV_B_BUTTON;
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_X ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                return EV_X_BUTTON;
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_Y ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                return EV_Y_BUTTON;
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                return EV_BLACK_BUTTON;
            if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                return EV_WHITE_BUTTON;
        }

        // Cursor movement
        if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_LEFT_TRIGGER ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            return EV_LEFT_BUTTON;
        if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_RIGHT_TRIGGER ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            return EV_RIGHT_BUTTON;

        // Movement
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_UP ||
            pGamePad->fY1 > JOY_THRESHOLD )
            return EV_UP;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
            pGamePad->fY1 < -JOY_THRESHOLD )
            return EV_DOWN;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
            pGamePad->fX1 < -JOY_THRESHOLD )
            return EV_LEFT;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
            pGamePad->fX1 > JOY_THRESHOLD )
            return EV_RIGHT;
    }

    // No controllers inserted or no button presses or no repeat
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: UpdateState()
// Desc: State machine updates the current context based on the incoming event
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::UpdateState( Event ev )
{
    switch( m_State )
    {
        case STATE_STARTSCREEN:
            switch( ev )
            {
                case EV_A_BUTTON:           // Select current key
                case EV_START_BUTTON:
                    m_State = STATE_MENU;
                    break;
            }
            break;
        case STATE_MENU:
            switch( ev )
            {
                case EV_A_BUTTON:           // Select current key
                case EV_START_BUTTON:
                    InitBoard();
                    m_State = STATE_KEYBOARD;
                    break;

                // Navigation
                case EV_UP:
                    if( m_iLanguage == XC_LANGUAGE_ENGLISH )
                        m_iLanguage = XC_LANGUAGE_MAX - 1;
                    else
                    {
                        --m_iLanguage;
#ifndef VKEY_JAPAN
                        // If we're not supporting the Japanese keyboard,
                        // it's not in the list
                        if( m_iLanguage == XC_LANGUAGE_JAPANESE )
                            --m_iLanguage;
#endif
                    }
                    break;
                case EV_DOWN:
                    if( m_iLanguage == XC_LANGUAGE_MAX - 1 )
                        m_iLanguage = XC_LANGUAGE_ENGLISH;
                    else
                    {
                        ++m_iLanguage;
#ifndef VKEY_JAPAN
                        // If we're not supporting the Japanese keyboard,
                        // it's not in the list
                        if( m_iLanguage == XC_LANGUAGE_JAPANESE )
                            ++m_iLanguage;
#endif
                    }
                    break;
            }
            break;
        case STATE_KEYBOARD:
            switch( ev )
            {
                case EV_A_BUTTON:           // Select current key
                case EV_START_BUTTON:
                    PressCurrent();
                    break;
                case EV_B_BUTTON:           // Shift mode
                case EV_BACK_BUTTON:        // Back
                    m_State = STATE_MENU;
                    break;
                case EV_X_BUTTON:           // Toggle keyboard
                    if( m_iLanguage == XC_LANGUAGE_ENGLISH )
                    {
                        Press( m_iCurrBoard == TYPE_SYMBOLS ?
                               XK_ALPHABET : XK_SYMBOLS );
                    }
                    else
                    {
                        switch( m_iCurrBoard )
                        {
                            case TYPE_ALPHABET: Press( XK_SYMBOLS  ); break;
                            case TYPE_SYMBOLS:  Press( XK_ACCENTS  ); break;
                            case TYPE_ACCENTS:  Press( XK_ALPHABET ); break;
                        }
                    }
                    break;
                case EV_Y_BUTTON:           // Show help
                    m_State = STATE_HELP;
                    break;
                case EV_WHITE_BUTTON:       // Backspace
                    Press( XK_BACKSPACE );
                    break;
                case EV_BLACK_BUTTON:       // Space
                    Press( XK_SPACE );
                    break;
                case EV_LEFT_BUTTON:        // Left
                    Press( XK_ARROWLEFT );
                    break;
                case EV_RIGHT_BUTTON:       // Right
                    Press( XK_ARROWRIGHT );
                    break;

                // Navigation
                case EV_UP:     MoveUp();    break;
                case EV_DOWN:   MoveDown();  break;
                case EV_LEFT:   MoveLeft();  break;
                case EV_RIGHT:  MoveRight(); break;
            }
            break;
        case STATE_HELP:
            // Any key returns to keyboard
            if( ev != EV_NULL )
                m_State = STATE_KEYBOARD;
            break;
        default:
            assert( FALSE );
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateJapan()
// Desc: {qAy^J^JiB
//       {^NbNoB
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::UpdateStateJapan()
{
    assert( m_iLanguage == XC_LANGUAGE_JAPANESE );

    // See if right trigger is held
    if( m_dwCurrCtlrState & XKJ_RIGHTTR )
        m_bTrig ^= TRUE;

    // See if left trigger is held
    if( m_dwCurrCtlrState & XKJ_LEFTTR )
        m_bKana ^= TRUE;

    // Determine if we should play the click sound. The following
    // buttons give a click: A, B, X, Y, black, white, Dpad left/right
    const DWORD dwButtons = XKJ_A | XKJ_B | XKJ_X | XKJ_Y | XKJ_BLACK | 
                            XKJ_WHITE | XKJ_DLEFT | XKJ_DRIGHT;
    if( m_dwCurrCtlrState & dwButtons )
        PlayClick();

    // "Key press"
    if( m_xNextKeyJpn != NULL )
        Press( m_xNextKeyJpn );
}




//-----------------------------------------------------------------------------
// Name: PressCurrent()
// Desc: Press the current key on the keyboard
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::PressCurrent()
{
    // Determine the current key
    Key key = m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ][ m_iCurrKey ];

    // Press it
    Press( key.xKey );
}




//-----------------------------------------------------------------------------
// Name: Press()
// Desc: Press the given key on the keyboard
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::Press( Xkey xk )
{
    // If the key represents a character, add it to the word
    if( xk < 0x10000 && xk != XK_ARROWLEFT && xk != XK_ARROWRIGHT )
    {
        // Don't add more than the maximum characters, and don't allow 
        // text to exceed the width of the text entry field
        if( m_strData.length() < MAX_CHARS )
        {
            CXBFont& Font = ( m_iLanguage == XC_LANGUAGE_JAPANESE ) ? 
                              m_FontJapan : m_FontLatin;

            // Get the width of the string in pixels
            FLOAT fHeight;
            FLOAT fWidth;
            Font.GetTextExtent( m_strData.c_str(), &fWidth, &fHeight );

            // Account for any Euro symbols
            FLOAT fEuroWidth;
            WCHAR strEuro[] = { XK_EURO_SIGN, 0 };
            m_FontEuro.GetTextExtent( strEuro, &fEuroWidth, &fHeight );

            fWidth += std::count( m_strData.begin(), m_strData.end(), 
                                  XK_EURO_SIGN ) * fEuroWidth;

            if( fWidth < fTEXTBOX_WIDTH )
            {
                m_strData.insert( m_iPos, 1, GetChar( xk ) );
                ++m_iPos; // move the caret
            }
        }

        // Unstick the shift key
        m_bIsShiftOn = FALSE;
    }

    // Special cases
    else switch( xk )
    {
        case XK_BACKSPACE:
            if( m_iPos > 0 )
            {
                --m_iPos; // move the caret
                m_strData.erase( m_iPos, 1 );
            }
            break;
        case XK_DELETE: // Used for Japanese only
            if( m_strData.length() > 0 )
                m_strData.erase( m_iPos, 1 );
            break;
        case XK_SHIFT:
            m_bIsShiftOn = !m_bIsShiftOn;
            break;
        case XK_CAPSLOCK:
            m_bIsCapsLockOn = !m_bIsCapsLockOn;
            break;
        case XK_ALPHABET:
            m_iCurrBoard = TYPE_ALPHABET;

            // Adjust mode keys
            m_KeyboardList[m_iCurrBoard][3][0] = Key( XK_SYMBOLS, MODEKEY_WIDTH );
            m_KeyboardList[m_iCurrBoard][4][0] = Key( XK_ACCENTS, MODEKEY_WIDTH );

            break;
        case XK_SYMBOLS:
            m_iCurrBoard = TYPE_SYMBOLS;

            // Adjust mode keys
            m_KeyboardList[m_iCurrBoard][3][0] = Key( XK_ALPHABET, MODEKEY_WIDTH );
            m_KeyboardList[m_iCurrBoard][4][0] = Key( XK_ACCENTS, MODEKEY_WIDTH );

            break;
        case XK_ACCENTS:
            m_iCurrBoard = TYPE_ACCENTS;

            // Adjust mode keys
            m_KeyboardList[m_iCurrBoard][3][0] = Key( XK_ALPHABET, MODEKEY_WIDTH );
            m_KeyboardList[m_iCurrBoard][4][0] = Key( XK_SYMBOLS, MODEKEY_WIDTH );

            break;
        case XK_ARROWLEFT:
            if( m_iPos > 0 )
                --m_iPos;
            break;
        case XK_ARROWRIGHT:
            if( m_iPos < m_strData.length() )
                ++m_iPos;
            break;
        case XK_OK:
            m_iPos = 0;
            m_strData.erase();
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: MoveUp()
// Desc: Move the cursor up
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::MoveUp()
{
    do
    {
        // Update key index for special cases
        switch( m_iCurrRow )
        {
            case 0:
                if( 1 < m_iCurrKey && m_iCurrKey < 7 )      // 2 - 6
                {
                    m_iLastColumn = m_iCurrKey;             // remember column
                    m_iCurrKey = 1;                         // move to spacebar
                }
                else if( 6 < m_iCurrKey && m_iCurrKey < 9 ) // 7 - 8
                {
                    m_iLastColumn = m_iCurrKey;             // remember column
                    m_iCurrKey = 2;                         // move to left arrow
                }
                else if( m_iCurrKey > 8 )                   // 9 - 0
                {
                    m_iLastColumn = m_iCurrKey;             // remember column
                    m_iCurrKey = 3;                         // move to right arrow
                }
                break;
            case 3:
                if( m_iCurrKey == 7 )                       // backspace
                    m_iCurrKey = max( 7, m_iLastColumn );   // restore column
                break;
            case 4:
                if( m_iCurrKey == 1 )                       // spacebar
                    m_iCurrKey = min( 6, m_iLastColumn );   // restore column
                else if( m_iCurrKey > 1 )                   // left and right
                    m_iCurrKey = 7;                         // backspace
                break;
        }

        // Update row
        m_iCurrRow = ( m_iCurrRow == 0 ) ? MAX_ROWS - 1 : m_iCurrRow - 1;

    } while( IsKeyDisabled() );
}




//-----------------------------------------------------------------------------
// Name: MoveDown()
// Desc: Move the cursor down
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::MoveDown()
{
    do
    {
        // Update key index for special cases
        switch( m_iCurrRow )
        {
            case 2:
                if( m_iCurrKey > 7 )                    // q - t
                {
                    m_iLastColumn = m_iCurrKey;         // remember column
                    m_iCurrKey = 7;                     // move to backspace
                }
                break;
            case 3:
                if( 0 < m_iCurrKey && m_iCurrKey < 7 )  // u - z
                {
                    m_iLastColumn = m_iCurrKey;         // remember column
                    m_iCurrKey = 1;                     // move to spacebar
                }
                else if( m_iCurrKey > 6 )               // backspace
                {
                    if( m_iLastColumn > 8 )
                        m_iCurrKey = 3;                 // move to right arrow
                    else
                        m_iCurrKey = 2;                 // move to left arrow
                }
                break;
            case 4:
                switch( m_iCurrKey )
                {
                    case 1:                             // spacebar
                        m_iCurrKey = min( 6, m_iLastColumn );
                        break;
                    case 2:                             // left arrow
                        m_iCurrKey = max( min( 8, m_iLastColumn ), 7 );
                        break;
                    case 3:                             // right arrow
                        m_iCurrKey = max( 9, m_iLastColumn );
                        break;
                }
                break;
        }

        // Update row
        m_iCurrRow = ( m_iCurrRow == MAX_ROWS - 1 ) ? 0 : m_iCurrRow + 1;

    } while( IsKeyDisabled() );
}




//-----------------------------------------------------------------------------
// Name: MoveLeft()
// Desc: Move the cursor left
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::MoveLeft()
{
    do
    {
        if( m_iCurrKey == 0 )
            m_iCurrKey = m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ].size() - 1;
        else
            --m_iCurrKey;

    } while( IsKeyDisabled() );

    SetLastColumn();
}




//-----------------------------------------------------------------------------
// Name: MoveRight()
// Desc: Move the cursor right
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::MoveRight()
{
    do
    {
        if( m_iCurrKey == m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ].size() - 1 )
            m_iCurrKey = 0;
        else
            ++m_iCurrKey;

    } while( IsKeyDisabled() );

    SetLastColumn();
}




//-----------------------------------------------------------------------------
// Name: SetLastColumn()
// Desc: Remember the column position if we're on a single letter character
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::SetLastColumn()
{
    // If the new key is a single character, remember it for later
    Key key = m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ][ m_iCurrKey ];
    if( key.strName.empty() )
    {
        switch( key.xKey )
        {
            // Adjust the last column for the arrow keys to confine it
            // within the range of the key width
            case XK_ARROWLEFT:
                m_iLastColumn = ( m_iLastColumn <= 7 ) ? 7 : 8; break;
            case XK_ARROWRIGHT:
                m_iLastColumn = ( m_iLastColumn <= 9 ) ? 9 : 10; break;

            // Single char, non-arrow
            default:
                m_iLastColumn = m_iCurrKey; break;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: RenderKey()
// Desc: Render the key at the given position
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderKey( FLOAT fX, FLOAT fY, const Key& key, 
                                    D3DCOLOR selKeyColor, 
                                    D3DCOLOR selTextColor ) const
{
    if( selKeyColor == COLOR_INVISIBLE )
        return;

    struct KEYVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };

    WCHAR strKey[2] = { GetChar( key.xKey ), 0 };
    const WCHAR* strName = key.strName.empty() ? strKey : key.strName.c_str();

    FLOAT x = fX + KEY_INSET;
    FLOAT y = fY + KEY_INSET;
    FLOAT z = fX + key.dwWidth - KEY_INSET;
    FLOAT w = fY + KEY_HEIGHT - KEY_INSET;

    LPDIRECT3DVERTEXBUFFER8 pVertexBuf;
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( KEYVERTEX ), D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, D3DPOOL_MANAGED, 
                                      &pVertexBuf );
    KEYVERTEX* pVertices;
    pVertexBuf->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( x-0.5f, y-0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 0.0f );
    pVertices[1].p = D3DXVECTOR4( z-0.5f, y-0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 1.0f, 0.0f );
    pVertices[2].p = D3DXVECTOR4( x-0.5f, w-0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 0.0f, 1.0f );
    pVertices[3].p = D3DXVECTOR4( z-0.5f, w-0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 1.0f );
    pVertexBuf->Unlock();

    LPDIRECT3DINDEXBUFFER8 pIndexBuf;
    m_pd3dDevice->CreateIndexBuffer( 5 * 2, D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                     D3DPOOL_MANAGED, &pIndexBuf );
    SHORT* pIndices;
    pIndexBuf->Lock( 0, 0, (BYTE **)&pIndices, 0L );
    pIndices[0] = 0;
    pIndices[1] = 1;
    pIndices[2] = 3;
    pIndices[3] = 2;
    pIndices[4] = 0;
    pIndexBuf->Unlock();

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_TEX1 );
    m_pd3dDevice->SetStreamSource( 0, pVertexBuf, sizeof( KEYVERTEX ) );

    // Draw the key background
    m_pd3dDevice->SetTexture( 0, m_ptKey );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );

    if( selKeyColor )
    {
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, selKeyColor );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }
    
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xFF000000 );
    m_pd3dDevice->SetIndices( pIndexBuf, 0 );
    m_pd3dDevice->DrawIndexedPrimitive( D3DPT_LINESTRIP, 0, 5, 0, 4 );

    pVertexBuf->Release();
    pIndexBuf->Release();

    // Determine font. Arrow keys and euro sign have special fonts because
    // their Unicode values are unusually large. To save texture space,
    // those fonts just include the arrow keys/euro sign. If key name is
    // all uppercase, we use a slightly smaller font.
    CXBFont* pFont;
    if( key.xKey == XK_ARROWLEFT || key.xKey == XK_ARROWRIGHT )
        pFont = &m_FontArrows;
    else if( key.xKey == XK_EURO_SIGN )
        pFont = &m_FontEuro;
    else if( key.strName.length() > 1 && iswupper( key.strName[1] ) )
        pFont = &m_FontCaps;
    else
        pFont = &m_FontLatin;

    // Draw the key text
    pFont->DrawText( ( x + z ) / 2.0f, ( y + w ) / 2.0f , selTextColor, strName, 
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: DrawTextBox()
// Desc: Display box containing text input
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::DrawTextBox() const
{
    D3DXVECTOR4 avRect[5];
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xFF000000 );
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    avRect[0] = D3DXVECTOR4(  64 - 0.5f, 48 - 0.5f, 1.0f, 1.0f );
    avRect[1] = D3DXVECTOR4( 576 - 0.5f, 48 - 0.5f, 1.0f, 1.0f );
    avRect[2] = D3DXVECTOR4( 576 - 0.5f, 88 - 0.5f, 1.0f, 1.0f );
    avRect[3] = D3DXVECTOR4(  64 - 0.5f, 88 - 0.5f, 1.0f, 1.0f );
    avRect[4] = avRect[0];

    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, 4, avRect, sizeof( D3DXVECTOR4 ) );
}




//-----------------------------------------------------------------------------
// Name: RenderStartScreen()
// Desc: Startup screen
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderStartScreen() const
{
    m_FontLatin.DrawText( 320.0f, 50.0f, 0xFFFFFFFF,
                          L"This sample is intended to show appropriate\n"
                          L"functionality only. Please do not lift the\n"
                          L"graphics for use in your game.\n"
                          L"Source code for this sample is located at\n"
                          L"Samples\\Xbox\\ReferenceUI\\VirtualKeyboard\n"
                          L"A description of the user research that\n"
                          L"went into the creation of this sample is\n"
                          L"located in the XDK documentation at\n"
                          L"Developing for Xbox - Reference User Interface.",
                          XBFONT_CENTER_X );

    WCHAR strButton[2] = { BTN_A, 0 };
    m_FontBtn.DrawText( 270.0f, BUTTON_Y, BUTTON_COLOR, strButton );
    m_FontLatin.DrawText( 270.0f + BUTTON_OFFSET, BUTTON_Y, BUTTON_TEXT, 
                          L"continue" );
}




//-----------------------------------------------------------------------------
// Name: RenderMenu()
// Desc: Main menu
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderMenu() const
{
    const D3DCOLOR COLOR_DEFAULT = 0xFFFFFFFF; // white
    const D3DCOLOR COLOR_SELECT  = 0xFF00FF00; // green
    const D3DCOLOR COLOR_LIGHT   = 0xFF808080; // gray

    CXBFont& Font = ( m_iLanguage == XC_LANGUAGE_JAPANESE ) ? 
                    m_FontJapan : m_FontLatin;

    Font.DrawText( 320.0f, 60.0f, COLOR_DEFAULT, 
                   strCHOOSE_KEYBOARD[ m_iLanguage ], XBFONT_CENTER_X );
    UINT j = 0;
    for( UINT i = XC_LANGUAGE_ENGLISH; i < XC_LANGUAGE_MAX; ++i )
    {
#ifndef VKEY_JAPAN
        // Don't display Japanese as an option
        if( i == XC_LANGUAGE_JAPANESE )
            continue;
#endif

        D3DCOLOR selColor = COLOR_DEFAULT;
        if( m_iLanguage == i )
            selColor = COLOR_SELECT;
#ifdef VKEY_JAPAN
        if( i == XC_LANGUAGE_JAPANESE )
            m_FontJapan.DrawText( 280.0f, 105.0f + ( j++ * 30.0f ), selColor,
                                  g_strLanguage[i] );
        else
#endif
            m_FontLatin.DrawText( 280.0f, 100.0f + ( j++ * 30.0f ), selColor,
                                  g_strLanguage[i] );
    }

    if( m_iLanguage != XC_LANGUAGE_ENGLISH )
    {
        m_FontLatin.DrawText( 320.0f, 280.0f, COLOR_LIGHT, 
                              L"Localized terminology not final.\n"
                              L"See Xbox Guide for final terms.",
                              XBFONT_CENTER_X );
    }

    Font.DrawText( 320.0f, m_iLanguage == XC_LANGUAGE_ENGLISH ?
                   320.0f : 344.0f, COLOR_LIGHT, 
                   strILLUSTRATIVE_GRAPHICS[ m_iLanguage ],
                   XBFONT_CENTER_X );

    DrawButton( 270.0f, BTN_A );
}




//-----------------------------------------------------------------------------
// Name: RenderKeyboard()
// Desc: Display current keyboard
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderKeyboard() const
{
    if( m_iLanguage == XC_LANGUAGE_JAPANESE )
        RenderKeyboardJapan();
    else
        RenderKeyboardLatin();
}




//-----------------------------------------------------------------------------
// Name: RenderKeyboardLatin()
// Desc: Display current latin keyboard
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderKeyboardLatin() const
{
    // Show text and caret
    DrawTextBox();
    DrawText( 68.0f, 54.0f );

    // Draw each row
    FLOAT fY = 120.0f;
    const Keyboard& keyBoard = m_KeyboardList[ m_iCurrBoard ];
    for( DWORD row = 0; row < MAX_ROWS; ++row, fY += KEY_HEIGHT )
    {
        FLOAT fX = 64.0f;
        FLOAT fWidthSum = 0.0f;
        const KeyRow& keyRow = keyBoard[ row ];
        DWORD dwIndex = 0;
        for( KeyRow::const_iterator i = keyRow.begin(); 
             i != keyRow.end(); ++i, ++dwIndex )
        {
            // Determine key name
            const Key& key = *i;
            D3DCOLOR selKeyColor = 0x00000000;
            D3DCOLOR selTextColor = COLOR_NORMAL;

            // Handle special key coloring
            switch( key.xKey )
            {
                case XK_SHIFT:
                    switch( m_iCurrBoard )
                    {
                        case TYPE_ALPHABET:
                        case TYPE_ACCENTS:
                            if( m_bIsShiftOn )
                                selKeyColor = COLOR_PRESSED;
                            break;
                        case TYPE_SYMBOLS:
                            selKeyColor = COLOR_DISABLED;
                            selTextColor = COLOR_FONT_DISABLED;
                            break;
                    }
                    break;
                case XK_CAPSLOCK:
                    switch( m_iCurrBoard )
                    {
                        case TYPE_ALPHABET:
                        case TYPE_ACCENTS:
                            if( m_bIsCapsLockOn )
                                selKeyColor = COLOR_PRESSED;
                            break;
                        case TYPE_SYMBOLS:
                            selKeyColor = COLOR_DISABLED;
                            selTextColor = COLOR_FONT_DISABLED;
                            break;
                    }
                    break;
                case XK_ACCENTS:
                    if( m_iLanguage == XC_LANGUAGE_ENGLISH )
                    {
                        selKeyColor = COLOR_INVISIBLE;
                        selTextColor = COLOR_INVISIBLE;
                    }
                    break;
            }

            // Highlight the current key
            if( row == m_iCurrRow && dwIndex == m_iCurrKey )
                selKeyColor |= COLOR_HIGHLIGHT;

            RenderKey( fX + fWidthSum, fY, key, selKeyColor, selTextColor );

            fWidthSum += key.dwWidth;

            // There's a slightly larger gap between the leftmost keys (mode
            // keys) and the main keyboard
            if( dwIndex == 0 )
                fWidthSum += GAP2_WIDTH;
            else
                fWidthSum += GAP_WIDTH;
        }
    }

    DrawButton( 80.0f,  BTN_A );
    DrawButton( 280.0f, BTN_Y );
    DrawButton( 460.0f, BTN_B );
}




//-----------------------------------------------------------------------------
// Name: RenderKeyboardJapan()
// Desc: Display current Japanese keyboard
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderKeyboardJapan() const
{
    assert( m_iLanguage == XC_LANGUAGE_JAPANESE );

    // Show the controller
    DrawControllerS();

    // Show text and caret
    DrawTextBox();
    DrawText( 68.0f, 54.0f );

    const WCHAR *cChar = JH_A JH_KA JH_SA JH_TA JH_NA JH_HA JH_MA JH_YA
                         JH_LA JH_GA JH_ZA JH_DA JH_PA JH_BA JH_RA JH_WA
                         JK_A JK_KA JK_SA JK_TA JK_NA JK_HA JK_MA JK_YA
                         JK_LA JK_GA JK_ZA JK_DA JK_PA JK_BA JK_RA JK_WA;

    const WCHAR *cCharX = JH_A JH_I JH_U JH_E JH_O JH_NULL JH_KA JH_KI JH_KU 
                          JH_KE JH_KO JH_NULL JH_SA JH_SI JH_SU JH_SE JH_SO 
                          JH_NULL JH_TA JH_TI JH_TU JH_TE JH_TO JH_NULL JH_NA 
                          JH_NI JH_NU JH_NE JH_NO JH_NULL JH_HA JH_HI JH_HU 
                          JH_HE JH_HO JH_NULL JH_MA JH_MI JH_MU JH_ME JH_MO 
                          JH_NULL JH_YA JH_LYA JH_YU JH_LYU JH_YO JH_LYO JH_N 
                          JH_LTU JH_WO JH_NULL JH_NULL JH_NULL JH_LA JH_LI 
                          JH_LU JH_LE JH_LO JH_NULL JH_GA JH_GI JH_GU JH_GE 
                          JH_GO JH_NULL JH_ZA JH_ZI JH_ZU JH_ZE JH_ZO JH_NULL 
                          JH_DA JH_DI JH_DU JH_DE JH_DO JH_NULL JH_PA JH_PI 
                          JH_PU JH_PE JH_PO JH_NULL JH_BA JH_BI JH_BU JH_BE 
                          JH_BO JH_NULL JH_RA JH_RI JH_RU JH_RE JH_RO JH_NULL 
                          JH_WA JH_WI JH_LWA JH_WE JH_WO JH_NULL JH_N JH_LTU 
                          JH_WO JH_NULL JH_NULL JH_NULL JK_A JK_I JK_U JK_E 
                          JK_O JK_NULL JK_KA JK_KI JK_KU JK_KE JK_KO JK_NULL
                          JK_SA JK_SI JK_SU JK_SE JK_SO JK_NULL JK_TA JK_TI 
                          JK_TU JK_TE JK_TO JK_NULL JK_NA JK_NI JK_NU JK_NE 
                          JK_NO JK_NULL JK_HA JK_HI JK_HU JK_HE JK_HO JK_NULL
                          JK_MA JK_MI JK_MU JK_ME JK_MO JK_NULL JK_YA JK_LYA
                          JK_YU JK_LYU JK_YO JK_LYO JK_N JK_LTU JK_WO JK_DASH
                          JK_NULL JK_NULL JK_LA JK_LI JK_LU JK_LE JK_LO JK_NULL
                          JK_GA JK_GI JK_GU JK_GE JK_GO JK_NULL JK_ZA JK_ZI 
                          JK_ZU JK_ZE JK_ZO JK_NULL JK_DA JK_DI JK_DU JK_DE 
                          JK_DO JK_NULL JK_PA JK_PI JK_PU JK_PE JK_PO JK_NULL
                          JK_BA JK_BI JK_BU JK_BE JK_BO JK_NULL JK_RA JK_RI 
                          JK_RU JK_RE JK_RO JK_NULL JK_WA JK_WI JK_VU JK_WE
                          JK_WO JK_NULL JK_N JK_LTU JK_WO JK_DASH JK_NULL
                          JK_NULL;

    const WCHAR *strHiragana = JH_HI JH_RA JH_GA JH_NA;
    const WCHAR *strKatakana = JK_KA JK_TA JK_KA JK_NA;

    const WCHAR *strDESCRIPTION[8] =
    {
        { JK_DASH JH_SO JH_U JH_SA JH_SE JH_TU JH_ME JH_I JK_DASH },
        { JH_HI JH_DA JH_RI JH_NO JK_A JK_NA JK_RO JK_GU JK_PA JK_LTU JK_DO 
          JH_DE JH_SI JH_I JH_N JH_WO JH_KI JH_ME JH_TE L"\n"
          JH_MI JH_GI JH_NO JK_BO JK_TA JK_N JH_DE JH_MO JH_ZI JH_WO JH_U 
          JH_TI JH_MA JH_SU },
        { JH_U JH_RA JH_GA JH_WA JH_NI JH_A JH_RU JH_MI JH_GI JH_NO JK_TO JK_RI JK_GA JH_DE JH_SI JH_I 
          JH_N JH_WO }, 
        { JH_HI JH_DA JH_RI JH_NO JK_TO JK_RI JK_GA JH_DE JH_HI JH_RA JH_GA
          JH_NA JH_TO JK_KA JK_TA JK_KA JK_NA JH_WO L"\n"
          JH_KO JH_U JH_GO JH_NI JH_KI JH_RI JH_KA JH_E JH_RU JH_KO JH_TO 
          JH_GA JH_DE JH_KI JH_MA JH_SU },
        { JK_DE JK_ZI JK_TA JK_RU JK_PA JK_LTU JK_DO JH_NO JH_SA JH_YU JH_U 
          JH_NO JK_KI JK_DASH JH_DE L"\n"
          JK_KA JK_DASH JK_SO JK_RU JH_GA JH_I JH_DO JH_U JH_SI JH_MA JH_SU },
        { JH_MO JH_SI JH_U JH_TI JH_MA JH_TI JH_GA JH_E JH_TA JH_RA L"\n"
          JH_KU JH_RO JH_KA JH_SI JH_RO JH_NO JK_BO JK_TA JK_N JH_DE JH_MO 
          JH_ZI JH_WO JH_SA JH_KU JH_ZI JH_LYO JH_SI JH_TE JH_KU JH_DA JH_SA JH_I },
        { JK_BA JK_LTU JK_KU JK_BO JK_TA JK_N JH_WO JH_O JH_SU JH_TO L"\n"
          JK_KI JK_DASH JK_BO JK_DASH JK_DO JK_SE JK_RE JK_KU JK_TO JH_NO 
          JK_ME JK_NI JK_LYU JK_DASH JH_NI JH_MO JH_DO JH_RI JH_MA JH_SU },
        { L"" }
    };

    // Determine color and direction values
    DWORD dwColor[16];
    for( INT i = 0; i < 16; i++ )
        dwColor[i] = 0xFFFFFFFF;

    INT nDirection; // 0 - 8
    if( m_dwCurrCtlrState & XKJ_UP )
    {
        if( m_dwCurrCtlrState & XKJ_RIGHT )
        {
            nDirection = 1;
            dwColor[1] = 0xFFFFFF00;
        }
        else if( m_dwCurrCtlrState & XKJ_LEFT )
        {
            nDirection = 7;
            dwColor[7] = 0xFFFFFF00;
        }
        else
        {
            nDirection = 0;
            dwColor[0] = 0xFFFFFF00;
        }
    }
    else if( m_dwCurrCtlrState & XKJ_DOWN )
    {
        if( m_dwCurrCtlrState & XKJ_RIGHT )
        {
            nDirection = 3;
            dwColor[3] = 0xFFFFFF00;
        }
        else if( m_dwCurrCtlrState & XKJ_LEFT )
        {
            nDirection = 5;
            dwColor[5] = 0xFFFFFF00;
        }
        else
        {
            nDirection = 4;
            dwColor[4] = 0xFFFFFF00;
        }
    }
    else if( m_dwCurrCtlrState & XKJ_RIGHT )
    {
        nDirection = 2;
        dwColor[2] = 0xFFFFFF00;
    }
    else if( m_dwCurrCtlrState & XKJ_LEFT )
    {
        nDirection = 6;
        dwColor[6] = 0xFFFFFF00;
    }
    else 
    {
        nDirection = 8;
    }

    if( m_dwOldCtlrState & XKJ_X )
        dwColor[8] = 0xFFFFFF00;
    if( m_dwOldCtlrState & XKJ_Y )
        dwColor[9] = 0xFFFFFF00;
    if( m_dwOldCtlrState & XKJ_B )
        dwColor[10] = 0xFFFFFF00;
    if( m_dwOldCtlrState & XKJ_A )
        dwColor[11] = 0xFFFFFF00;
    if( m_dwOldCtlrState & XKJ_WHITE )
        dwColor[12] = 0xFFFFFF00;
    if( m_dwOldCtlrState & XKJ_BLACK )
        dwColor[13] = 0xFFFFFF00;
    if( m_bTrig )
        dwColor[14] = 0xFFFFFF00;
    if( m_dwOldCtlrState & XKJ_LEFTTR )
        dwColor[15] = 0xFFFFFF00;

    WCHAR wcChar[8][2];
    for( i = 0; i < 8; i++ )
    {
        INT nStp = m_bTrig ? 1 : 0;
        if( m_bKana )
            nStp += 2;

        wcChar[i][0] = cChar[i + 8 * nStp];
        wcChar[i][1] = 0;
    }

    WCHAR wcCharX[6][2];
    DWORD wcCharXIdx[6];
    for( i = 0; i < 6; i++ )
    {
        INT nStp = m_bTrig ? ( 6 * 9 ) : 0;
        if( m_bKana ) 
            nStp += 6 * 9 * 2;

        wcCharXIdx[i] = i + 6 * nDirection + nStp;
        wcCharX[i][0] = cCharX[wcCharXIdx[i]];
        wcCharX[i][1] = 0;
    }

    // Japanese characters
    const Xkey cJAPAN_KEY[] =
    {
        XK_HIRAGANA_A,XK_HIRAGANA_I,XK_HIRAGANA_U,XK_HIRAGANA_E,XK_HIRAGANA_O,XK_DELETE,
        XK_HIRAGANA_KA,XK_HIRAGANA_KI,XK_HIRAGANA_KU,XK_HIRAGANA_KE,XK_HIRAGANA_KO,XK_DELETE,
        XK_HIRAGANA_SA,XK_HIRAGANA_SI,XK_HIRAGANA_SU,XK_HIRAGANA_SE,XK_HIRAGANA_SO,XK_DELETE,
        XK_HIRAGANA_TA,XK_HIRAGANA_TI,XK_HIRAGANA_TU,XK_HIRAGANA_TE,XK_HIRAGANA_TO,XK_DELETE,
        XK_HIRAGANA_NA,XK_HIRAGANA_NI,XK_HIRAGANA_NU,XK_HIRAGANA_NE,XK_HIRAGANA_NO,XK_DELETE,
        XK_HIRAGANA_HA,XK_HIRAGANA_HI,XK_HIRAGANA_HU,XK_HIRAGANA_HE,XK_HIRAGANA_HO,XK_DELETE,
        XK_HIRAGANA_MA,XK_HIRAGANA_MI,XK_HIRAGANA_MU,XK_HIRAGANA_ME,XK_HIRAGANA_MO,XK_DELETE,
        XK_HIRAGANA_YA,XK_HIRAGANA_LYA,XK_HIRAGANA_YU,XK_HIRAGANA_LYU,XK_HIRAGANA_YO,XK_HIRAGANA_LYO,
        XK_HIRAGANA_N,XK_HIRAGANA_LTU,XK_HIRAGANA_WO,XK_SHIFT,XK_BACKSPACE,XK_DELETE,

        XK_HIRAGANA_LA,XK_HIRAGANA_LI,XK_HIRAGANA_LU,XK_HIRAGANA_LE,XK_HIRAGANA_LO,XK_DELETE,
        XK_HIRAGANA_GA,XK_HIRAGANA_GI,XK_HIRAGANA_GU,XK_HIRAGANA_GE,XK_HIRAGANA_GO,XK_DELETE,
        XK_HIRAGANA_ZA,XK_HIRAGANA_ZI,XK_HIRAGANA_ZU,XK_HIRAGANA_ZE,XK_HIRAGANA_ZO,XK_DELETE,
        XK_HIRAGANA_DA,XK_HIRAGANA_DI,XK_HIRAGANA_DU,XK_HIRAGANA_DE,XK_HIRAGANA_DO,XK_DELETE,
        XK_HIRAGANA_PA,XK_HIRAGANA_PI,XK_HIRAGANA_PU,XK_HIRAGANA_PE,XK_HIRAGANA_PO,XK_DELETE,
        XK_HIRAGANA_BA,XK_HIRAGANA_BI,XK_HIRAGANA_BU,XK_HIRAGANA_BE,XK_HIRAGANA_BO,XK_DELETE,
        XK_HIRAGANA_RA,XK_HIRAGANA_RI,XK_HIRAGANA_RU,XK_HIRAGANA_RE,XK_HIRAGANA_RO,XK_DELETE,
        XK_HIRAGANA_WA,XK_HIRAGANA_WI,XK_HIRAGANA_LWA,XK_HIRAGANA_WE,XK_HIRAGANA_WO,XK_DELETE,
        XK_HIRAGANA_N,XK_HIRAGANA_LTU,XK_HIRAGANA_WO,XK_SHIFT,XK_BACKSPACE,XK_DELETE,

        XK_KATAKANA_A,XK_KATAKANA_I,XK_KATAKANA_U,XK_KATAKANA_E,XK_KATAKANA_O,XK_DELETE,
        XK_KATAKANA_KA,XK_KATAKANA_KI,XK_KATAKANA_KU,XK_KATAKANA_KE,XK_KATAKANA_KO,XK_DELETE,
        XK_KATAKANA_SA,XK_KATAKANA_SI,XK_KATAKANA_SU,XK_KATAKANA_SE,XK_KATAKANA_SO,XK_DELETE,
        XK_KATAKANA_TA,XK_KATAKANA_TI,XK_KATAKANA_TU,XK_KATAKANA_TE,XK_KATAKANA_TO,XK_DELETE,
        XK_KATAKANA_NA,XK_KATAKANA_NI,XK_KATAKANA_NU,XK_KATAKANA_NE,XK_KATAKANA_NO,XK_DELETE,
        XK_KATAKANA_HA,XK_KATAKANA_HI,XK_KATAKANA_HU,XK_KATAKANA_HE,XK_KATAKANA_HO,XK_DELETE,
        XK_KATAKANA_MA,XK_KATAKANA_MI,XK_KATAKANA_MU,XK_KATAKANA_ME,XK_KATAKANA_MO,XK_DELETE,
        XK_KATAKANA_YA,XK_KATAKANA_LYA,XK_KATAKANA_YU,XK_KATAKANA_LYU,XK_KATAKANA_YO,XK_KATAKANA_LYO,
        XK_KATAKANA_N,XK_KATAKANA_LTU,XK_KATAKANA_WO,XK_KATAKANA_DASH,XK_BACKSPACE,XK_DELETE,

        XK_KATAKANA_LA,XK_KATAKANA_LI,XK_KATAKANA_LU,XK_KATAKANA_LE,XK_KATAKANA_LO,XK_DELETE,
        XK_KATAKANA_GA,XK_KATAKANA_GI,XK_KATAKANA_GU,XK_KATAKANA_GE,XK_KATAKANA_GO,XK_DELETE,
        XK_KATAKANA_ZA,XK_KATAKANA_ZI,XK_KATAKANA_ZU,XK_KATAKANA_ZE,XK_KATAKANA_ZO,XK_DELETE,
        XK_KATAKANA_DA,XK_KATAKANA_DI,XK_KATAKANA_DU,XK_KATAKANA_DE,XK_KATAKANA_DO,XK_DELETE,
        XK_KATAKANA_PA,XK_KATAKANA_PI,XK_KATAKANA_PU,XK_KATAKANA_PE,XK_KATAKANA_PO,XK_DELETE,
        XK_KATAKANA_BA,XK_KATAKANA_BI,XK_KATAKANA_BU,XK_KATAKANA_BE,XK_KATAKANA_BO,XK_DELETE,
        XK_KATAKANA_RA,XK_KATAKANA_RI,XK_KATAKANA_RU,XK_KATAKANA_RE,XK_KATAKANA_RO,XK_DELETE,
        XK_KATAKANA_WA,XK_KATAKANA_WI,XK_KATAKANA_VU,XK_KATAKANA_WE,XK_KATAKANA_WO,XK_DELETE,
        XK_KATAKANA_N,XK_KATAKANA_LTU,XK_KATAKANA_WO,XK_KATAKANA_DASH,XK_BACKSPACE,XK_DELETE,
    };

    // Determine the key to press
    m_xNextKeyJpn = XK_NULL;
    if( m_dwCurrCtlrState & XKJ_X )
        m_xNextKeyJpn = cJAPAN_KEY[ wcCharXIdx[0] ];
    else if( m_dwCurrCtlrState & XKJ_Y )
        m_xNextKeyJpn = cJAPAN_KEY[wcCharXIdx[1]];
    else if( m_dwCurrCtlrState & XKJ_B )
        m_xNextKeyJpn = cJAPAN_KEY[ wcCharXIdx[2] ];
    else if( m_dwCurrCtlrState & XKJ_A )
        m_xNextKeyJpn = cJAPAN_KEY[ wcCharXIdx[3] ];
    else if( m_dwCurrCtlrState & XKJ_WHITE )
        m_xNextKeyJpn = cJAPAN_KEY[ wcCharXIdx[4] ];
    else if( m_dwCurrCtlrState & XKJ_BLACK )
        m_xNextKeyJpn = cJAPAN_KEY[ wcCharXIdx[5] ];
    else if( m_dwCurrCtlrState & XKJ_DLEFT )
        m_xNextKeyJpn = XK_ARROWLEFT;
    else if( m_dwCurrCtlrState & XKJ_DRIGHT )
        m_xNextKeyJpn = XK_ARROWRIGHT;

    DWORD dwFontFlags = XBFONT_CENTER_X | XBFONT_CENTER_Y;
    DrawJapanese( 230.0f, 142.0f, dwColor[0], wcChar[0], dwFontFlags );
    DrawJapanese( 252.0f, 151.0f, dwColor[1], wcChar[1], dwFontFlags );
    DrawJapanese( 268.0f, 169.0f, dwColor[2], wcChar[2], dwFontFlags );
    DrawJapanese( 261.0f, 193.0f, dwColor[3], wcChar[3], dwFontFlags );
    DrawJapanese( 239.0f, 206.0f, dwColor[4], wcChar[4], dwFontFlags );
    DrawJapanese( 217.0f, 199.0f, dwColor[5], wcChar[5], dwFontFlags );
    DrawJapanese( 200.0f, 178.0f, dwColor[6], wcChar[6], dwFontFlags );
    DrawJapanese( 208.0f, 156.0f, dwColor[7], wcChar[7], dwFontFlags );
    DrawJapanese( 400.0f, 200.0f, dwColor[8], wcCharX[0], dwFontFlags );
    DrawJapanese( 420.0f, 180.0f, dwColor[9], wcCharX[1], dwFontFlags );
    DrawJapanese( 450.0f, 200.0f, dwColor[10], wcCharX[2], dwFontFlags );
    DrawJapanese( 430.0f, 220.0f, dwColor[11], wcCharX[3], dwFontFlags );
    DrawJapanese( 440.0f, 280.0f, dwColor[12], wcCharX[4], dwFontFlags );
    DrawJapanese( 460.0f, 260.0f, dwColor[13], wcCharX[5], dwFontFlags );

    DrawJapanese( 140.0f, 238.0f, 0xFF00FFFF, JK_ME JK_NI JK_LYU JK_DASH,
                  dwFontFlags );

    // Kana or Hiragana
    const WCHAR *strKanaGana = m_bKana ? strKatakana : strHiragana;
    DrawJapanese( 135.0f, 145.0f, dwColor[15], strKanaGana, dwFontFlags );

    // Show description string
    static INT nCounter = 0;
    ++nCounter &= 0x00000fff;
    INT nDescript = (nCounter >> 9) & 7;
    DrawJapanese( 320.0f, 410.0f, 0xFFFFFFFF, strDESCRIPTION[ nDescript ], 
                  dwFontFlags );
}




//-----------------------------------------------------------------------------
// Name: RenderHelp()
// Desc: Display controller mappings
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::RenderHelp() const
{
    RenderKeyboard();

    const DWORD NUM_HELP_CALLOUTS = 9;
    const WORD PLC1 = XBHELP_PLACEMENT_1;
    const WORD PLC2 = XBHELP_PLACEMENT_2;
    XBHELP_CALLOUT HelpCallouts[] =
    {
        { XBHELP_A_BUTTON,     PLC2, g_HelpStr[ m_iLanguage ].strSelect    },
        { XBHELP_START_BUTTON, PLC2, g_HelpStr[ m_iLanguage ].strSelect    },
        { XBHELP_B_BUTTON,     PLC2, g_HelpStr[ m_iLanguage ].strCancel    },
        { XBHELP_BACK_BUTTON,  PLC2, g_HelpStr[ m_iLanguage ].strCancel    },
        { XBHELP_X_BUTTON,     PLC1, g_HelpStr[ m_iLanguage ].strToggle    },
        { XBHELP_Y_BUTTON,     PLC2, g_HelpStr[ m_iLanguage ].strHelp      },
        { XBHELP_WHITE_BUTTON, PLC2, g_HelpStr[ m_iLanguage ].strBackspace },
        { XBHELP_BLACK_BUTTON, PLC2, g_HelpStr[ m_iLanguage ].strSpace     },
        { XBHELP_MISC_CALLOUT, PLC2, g_HelpStr[ m_iLanguage ].strTrigger   }
    };

    m_Help.Render( &m_FontLatin, HelpCallouts, NUM_HELP_CALLOUTS );
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draw text in the text input area, accounting for special characters
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::DrawText( FLOAT x, FLOAT y ) const
{
    if( m_iLanguage == XC_LANGUAGE_JAPANESE )
        DrawTextJapan( x, y );
    else
        DrawTextLatin( x, y );
}




//-----------------------------------------------------------------------------
// Name: DrawTextLatin()
// Desc: Draw text in the text input area, accounting for special characters
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::DrawTextLatin( FLOAT x, FLOAT y ) const
{
    FLOAT fEuroWidth = 0.0f;

    // We have to do some unusual text handling for large-value Unicode
    // symbols that aren't in the regular font file. The reason they're not
    // in the regular font file is that they'd make the bitmapped font
    // image enormous.
    String::const_iterator iStart = m_strData.begin();
    while ( iStart != m_strData.end() )
    {
        String::const_iterator iEnd = std::find( iStart, m_strData.end(), XK_EURO_SIGN );

        // Determine the string to be drawn
        String strDraw;
        BOOL bFoundEuro = iEnd != m_strData.end();
        if( bFoundEuro )
        {
            if( iEnd > iStart )
                strDraw.assign( iStart, iEnd );
            iStart = iEnd + 1;
        }
        else
        {
            strDraw.assign( iStart, iEnd );
            iStart = iEnd;
        }

        // Draw everything up to, but not including, the Euro character
        m_FontLatin.DrawText( x, y, COLOR_TEXT, strDraw.c_str() );

        // Move the drawing position
        FLOAT fWidth;
        FLOAT fHeight;
        m_FontLatin.GetTextExtent( strDraw.c_str(), &fWidth, &fHeight );
        x += fWidth;

        // Draw the Euro character
        if( bFoundEuro )
        {
            WCHAR strEuro[] = { XK_EURO_SIGN, 0 };
            m_FontEuro.DrawText( x, y, COLOR_TEXT, strEuro );

            // Move the drawing position
            m_FontEuro.GetTextExtent( strEuro, &fEuroWidth, &fHeight );
            x += fEuroWidth;
        }
    }

    // Determine caret location
    String strUpToCaret( m_strData, 0, m_iPos );
    FLOAT fWidth;
    FLOAT fHeight;
    m_FontLatin.GetTextExtent( strUpToCaret.c_str(), &fWidth, &fHeight );

    // Account for any Euro symbols
    fWidth += std::count( strUpToCaret.begin(), strUpToCaret.end(), XK_EURO_SIGN ) *
              fEuroWidth;

    // Draw blinking caret using a font for simplicity. Better method
    // would draw an "I-bar" using line primitives.
    if( fmod( m_CaretTimer.GetElapsedSeconds(), fCARET_BLINK_RATE ) < 
        fCARET_ON_RATIO )
    {
        m_FontLatin.DrawText( 68.0f + fWidth - 2.0f, 56.0f, COLOR_HIGHLIGHT, L"|" );
        m_FontLatin.DrawText( 68.0f + fWidth - 2.0f, 46.0f, COLOR_HIGHLIGHT, L"|" );
    }
}




//-----------------------------------------------------------------------------
// Name: DrawTextJapan()
// Desc: Draw text in the text input area, accounting for special characters
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::DrawTextJapan( FLOAT x, FLOAT y ) const
{
    String::const_iterator it;
    WCHAR jChar = 0;
    for( it = m_strData.begin(); it != m_strData.end(); it++ )
    {
        BOOL bJChar = FALSE; 
        String::const_reference currentChar = *it;

        for( jChar = XK_HIRAGANA_SP; jChar <= XK_HIRAGANA_VU; jChar++ )
        {
            if( currentChar == jChar)
            {
                bJChar = TRUE;
                break;
            }
        }
        if( !bJChar )
        {
            for( jChar = XK_KATAKANA_SP; jChar <= XK_KATAKANA_DASH; jChar++ )
            {
                if( currentChar == jChar)
                {
                    bJChar = TRUE;
                    break;
                }
            }
        }
        if( bJChar )
        {
            WCHAR strJapan[] = { currentChar, 0 };
            FLOAT fFixedY = 0.0f;

#if FIXED_JAPANESE_SMALL_LETTER

            // Arial MS UnicodetHgu\u
            WCHAR cSmallLetter[] =
            {
                XK_HIRAGANA_LA, XK_HIRAGANA_LI, XK_HIRAGANA_LU, XK_HIRAGANA_LE, 
                XK_HIRAGANA_LO, XK_HIRAGANA_LTU, XK_HIRAGANA_LYA, XK_HIRAGANA_LYU, 
                XK_HIRAGANA_LYO, XK_HIRAGANA_LWA, XK_KATAKANA_LA, XK_KATAKANA_LI, 
                XK_KATAKANA_LU, XK_KATAKANA_LE, XK_KATAKANA_LO, XK_KATAKANA_LTU, 
                XK_KATAKANA_LYA, XK_KATAKANA_LYU, XK_KATAKANA_LYO, XK_KATAKANA_LWA,
            };

            for( INT i = sizeof(cSmallLetter) / sizeof(WCHAR); i; i-- )
            {
                if( cSmallLetter[i - 1] == currentChar )
                    break;
            }
            if( i )
                fFixedY = FIXED_JSL_SIZE;
#endif
            m_FontJapan.DrawText( x, y + fFixedY, COLOR_TEXT, strJapan );

            // Move the drawing position
            FLOAT fWidth;
            FLOAT fHeight;
            m_FontJapan.GetTextExtent( strJapan, &fWidth, &fHeight );
            x += fWidth;
        }
    }

    String strUpToCaret( m_strData, 0, m_iPos );
    FLOAT fWidth;
    FLOAT fHeight;

    // Determine caret location
    m_FontLatin.GetTextExtent( strUpToCaret.c_str(), &fWidth, &fHeight );

    // LbguJ^Ji
    // Account for any Japanese symbols
    for( jChar = XK_HIRAGANA_SP; jChar <= XK_HIRAGANA_VU; jChar++ )
    {
        fWidth += std::count( strUpToCaret.begin(), strUpToCaret.end(), jChar ) *
                  21.0f;
    }
    for( jChar = XK_KATAKANA_SP; jChar <= XK_KATAKANA_DASH; jChar++ )
    {
        fWidth += std::count( strUpToCaret.begin(), strUpToCaret.end(), jChar ) *
                  21.0f;
    }

    // Draw blinking caret using a font for simplicity. Better method
    // would draw an "I-bar" using line primitives.
    if( fmod( m_CaretTimer.GetElapsedSeconds(), fCARET_BLINK_RATE ) < 
        fCARET_ON_RATIO )
    {
        m_FontLatin.DrawText( 68.0f + fWidth - 2.0f, 56.0f, COLOR_HIGHLIGHT, L"|" );
        m_FontLatin.DrawText( 68.0f + fWidth - 2.0f, 46.0f, COLOR_HIGHLIGHT, L"|" );
    }
}




//-----------------------------------------------------------------------------
// Name: DrawJapanese()
// Desc: {pL[{[h\
//       {tHge\
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::DrawJapanese( FLOAT x, FLOAT y, DWORD dwColor, 
                                       const WCHAR* str, DWORD flag ) const
{
    m_FontJapan.DrawText( x+2.0f, y+2.0f, COLOR_RED, str, flag );
    m_FontJapan.DrawText( x, y, dwColor, str, flag );
}




//-----------------------------------------------------------------------------
// Name: DrawButton()
// Desc: Display button image and descriptive text
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::DrawButton( FLOAT fX, WCHAR chButton ) const
{
    const WCHAR* strText = NULL;
    switch( chButton )
    {
        case BTN_A : strText = strA_SELECT[ m_iLanguage ]; break;
        case BTN_B : strText = strB_BACK  [ m_iLanguage ]; break;
        case BTN_Y : strText = strY_HELP  [ m_iLanguage ]; break;
        default : assert( FALSE ); return;
    }
    WCHAR strButton[2] = { chButton, 0 };

    m_FontBtn.DrawText( fX, BUTTON_Y, BUTTON_COLOR, strButton );
#ifdef VKEY_JAPAN
    if( m_iLanguage == XC_LANGUAGE_JAPANESE )
        m_FontJapan.DrawText( fX + BUTTON_OFFSET, BUTTON_Y, BUTTON_TEXT, strText );
    else
#endif
        m_FontLatin.DrawText( fX + BUTTON_OFFSET, BUTTON_Y, BUTTON_TEXT, strText );
}




//-----------------------------------------------------------------------------
// Name: DrawControllerS()
// Desc: {Rg[C[W\
//-----------------------------------------------------------------------------
HRESULT CXBVirtualKeyboard::DrawControllerS() const
{
    assert( m_iLanguage == XC_LANGUAGE_JAPANESE );

    // Setup vertices for a background-covering quad
    struct BACKGROUNDVERTEX
    { 
        FLOAT x;    // x,y,z,w form D3DXVECTOR4
        FLOAT y;
        FLOAT z;
        FLOAT w;
        FLOAT u;
        FLOAT v;
    };
    BACKGROUNDVERTEX v[4] =
    {
        {   0+120 - 0.5f,   0+120 - 0.5f, 1.0f, 1.0f,    0,   0 },
        { 400+120 - 0.5f,   0+120 - 0.5f, 1.0f, 1.0f,  400,   0 },
        {   0+120 - 0.5f, 320+120 - 0.5f, 1.0f, 1.0f,    0, 320 },
        { 400+120 - 0.5f, 320+120 - 0.5f, 1.0f, 1.0f,  400, 320 }
    };

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    // Set states
    m_pd3dDevice->SetTexture( 0, m_ptControllerS );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);

    // Render the quad
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, 
                                   sizeof(BACKGROUNDVERTEX) );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: IsDisabled()
// Desc: TRUE if the current key (m_iCurrBoard, m_iCurrRow, m_iCurrKey) is
//       disabled.
//-----------------------------------------------------------------------------
BOOL CXBVirtualKeyboard::IsKeyDisabled() const
{
    Key key = m_KeyboardList[ m_iCurrBoard ][ m_iCurrRow ][ m_iCurrKey ];

    // On the symbols keyboard, Shift and Caps Lock are disabled
    if( m_iCurrBoard == TYPE_SYMBOLS )
    {
        if( key.xKey == XK_SHIFT || key.xKey == XK_CAPSLOCK )
            return TRUE;
    }

    // On the English keyboard, the Accents key is disabled
    if( m_iLanguage == XC_LANGUAGE_ENGLISH )
    {
        if( key.xKey == XK_ACCENTS )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: PlayClick()
// Desc: Produces an audible click to meet certification requirements
//-----------------------------------------------------------------------------
VOID CXBVirtualKeyboard::PlayClick() const
{
    m_ClickSnd.Play();
}




//-----------------------------------------------------------------------------
// Name: GetChar()
// Desc: Convert Xkey value to WCHAR given current capitalization settings
//-----------------------------------------------------------------------------
WCHAR CXBVirtualKeyboard::GetChar( Xkey xk ) const
{
    // Handle case conversion
    WCHAR wc = WCHAR( xk );

    if( ( m_bIsCapsLockOn && !m_bIsShiftOn ) ||
        ( !m_bIsCapsLockOn && m_bIsShiftOn ) )
        wc = ToUpper( wc );
    else
        wc = ToLower( wc );

    return wc;
}




//-----------------------------------------------------------------------------
// Name: ToUpper()
// Desc: Convert WCHAR to upper case. Handles accented characters properly.
//-----------------------------------------------------------------------------
WCHAR CXBVirtualKeyboard::ToUpper( WCHAR c ) // static
{
#ifdef USE_CONVERSTION_TABLE

    // The table-based solution is faster, but requires 512 bytes of space
    static const WCHAR arrToUpper[] =
    {
        0,   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96

        // alpha mapping here
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        
        123, 124, 125, 126, 127,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
        0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
        0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
        0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
        0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
        0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
        0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
        0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
        0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,

        // accented character mapping here
        0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
        0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
        0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
        0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xFE, 0x0178,
    };

    if( c > 0xFF )
        return c;
    return arrToUpper[ c ];

#else

    // The code solution is slower but smaller
    if( c >= 'a' && c <= 'z' )
        return c - ('a' - 'A');
    if( c >= 0xE0 && c <= 0xFD )
        return c - (0xE0 - 0xC0);
    if( c == XK_SM_Y_DIAERESIS )    // 0x00FF
        return XK_CAP_Y_DIAERESIS;  // 0x0178
    return c;

#endif

}




//-----------------------------------------------------------------------------
// Name: ToLower()
// Desc: Convert WCHAR to lower case. Handles accented characters properly.
//-----------------------------------------------------------------------------
WCHAR CXBVirtualKeyboard::ToLower( WCHAR c ) // static
{
#ifdef USE_CONVERSTION_TABLE

    // The table-based solution is faster, but requires 512 bytes of space
    static const WCHAR arrToLower[] =
    {
        0,   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64

        // alpha mapping here
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',

        91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
        105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
        118, 119, 120, 121, 122, 123, 124, 125, 126, 127,

        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
        0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
        0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
        0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
        0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,

        // accented character mapping here
        0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
        0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 
        
        0xDE, 0xDF,
        0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
        0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
    };

    if( c == XK_CAP_Y_DIAERESIS ) // 0x0178
        return XK_SM_Y_DIAERESIS;
    if( c > 0xFF )
        return c;
    return arrToLower[ c ];

#else

    // The code solution is slower but smaller
    if( c >= 'A' && c <= 'Z' )
        return c + ( 'a' - 'A' );
    if( c >= 0xC0 && c <= 0xDD )
        return c + ( 0xE0 - 0xC0 );
    if( c == XK_CAP_Y_DIAERESIS ) // 0x0178
        return XK_SM_Y_DIAERESIS;
    return c;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AsyncXMO\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AsyncXMO\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AudioStress\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AudioStress\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AudioStress\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AudioStress\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AudioStress\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\MusicManager.h ===
//-----------------------------------------------------------------------------
// File: MusicManager.h
//
// Desc: Class definition for the CMusicManager class.  This is the real
//       playback engine.
//
// Hist: 8.20.01 - New for October XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef _MUSICMANAGER_H_
#define _MUSICMANAGER_H_

#include <xtl.h>
#include <dsound.h>

// Packet size is set up to be 2048 samples
// Samples are 16-bit and stereo
#define PACKET_SIZE ( 2048 * 2 * 2 )
#define PACKET_TIME ( 2048.0f / 44100.0f )

#define PACKET_COUNT 43     // Base number of packets
#define EXTRA_PACKETS 10    // Extra packets to get through the transition
#define FADE_TIME ( PACKET_COUNT * PACKET_TIME )


typedef enum {
    MM_STOPPED,
    MM_PAUSED,
    MM_PLAYING,
} MM_STATE;



//-----------------------------------------------------------------------------
// Name: class CSoundtrack
// Desc: Abstraction layer for soundtracks that help merge together game
//       soundtracks and user soundtracks stored on the Xbox hard drive
//-----------------------------------------------------------------------------
class CSoundtrack
{
public:
    CSoundtrack() {}

    VOID    GetSoundtrackName( WCHAR * szName )
        { wcscpy( szName, m_szName ); }
    UINT    GetSongCount()
        { return m_uSongCount; }

    VOID    GetSongInfo( UINT uSongIndex, DWORD * pdwID, DWORD * pdwLength, WCHAR * szName );
    HANDLE  OpenSong( DWORD dwSongID );
    
    WCHAR       m_szName[MAX_SOUNDTRACK_NAME];
    UINT        m_uSongCount;
    BOOL        m_fGameSoundtrack;
    union {
        UINT    m_uSoundtrackID;
        UINT    m_uSoundtrackIndex;
    };
};


//-----------------------------------------------------------------------------
// Name: class CMusicManager
// Desc: Background music engine class.  Spawns its own worker thread when
//       initialized.  Cost of calls from main rendering loop is negligible.
//       All public methods are safe to be called from main rendering loop, 
//       however, they do not all take effect immediately.
//-----------------------------------------------------------------------------
class CMusicManager
{
public:
    CMusicManager();
    ~CMusicManager();
    HRESULT Initialize( BOOL bSpinThread = TRUE );  // Initialize MusicManager

    HRESULT Play();                                 // Start playing
    HRESULT Stop();                                 // Stop playback
    HRESULT Pause();                                // Pause playback
    MM_STATE GetStatus() { return m_mmOldState; }   // Returns current playback status
    HRESULT SetRandom( BOOL fRandom );              // Change random mode
    BOOL    GetRandom() { return m_fRandom; }       // Get random mode
    HRESULT SetGlobal( BOOL fGlobal );              // Toggle global mode
    BOOL    GetGlobal() { return m_fGlobal; }       // Get global mode
    HRESULT SetVolume( LONG lVolume );              // Set volume level
    LONG    GetVolume() { return m_lVolume; }       // Get volume level

    // Returns info on currently playing song
    HRESULT GetCurrentInfo( WCHAR * szSoundtrack, WCHAR * szSong, DWORD * pdwLength );
    FLOAT   GetPlaybackPosition();                  // Returns position in current song
    HRESULT NextSoundtrack();                       // Switch to next soundtrack
    HRESULT NextSong();                             // Switch to next song
    HRESULT RandomSong( BOOL fGlobal = TRUE );      // Switch to a random song

    HRESULT MusicManagerDoWork();                   // Performs processing

private:
    HRESULT LoadSoundtracks();                      // Fill our soundtrack cache
    HRESULT SelectSoundtrack( DWORD dwSoundtrack ); // Switch to a soundtrack
    HRESULT SelectSong( DWORD dwSong );             // Switch to a song
    HRESULT FindNextSong();                         // Determine next song to play

    HRESULT Prepare();          // Get ready to decode and playback current song
    HRESULT Cleanup();          // Cleanup from playing current song
    HRESULT Process();          // Workhorse function - update state and manage packets

    BOOL    FindFreePacket( DWORD *pdwPacket, DWORD dwStream );     // Looks for a free packet
    HRESULT ProcessSource( DWORD dwPacket, XMEDIAPACKET * pxmp );   // Fills packet from source
    HRESULT ProcessStream( DWORD dwPacket, XMEDIAPACKET * pxmp );   // Submist packet to stream

    // Give the threadproc access to our Process() method
    friend DWORD WINAPI MusicManagerThreadProc(LPVOID lpParameter );

    // Stream callback routine for updating playback position
    friend static void CALLBACK StreamCallback( LPVOID pStreamContext, LPVOID pPacketContext, DWORD dwStatus );

    // State variables
    BOOL                    m_fGlobal;                          // TRUE to loop/randomize globally
    BOOL                    m_fRandom;                          // TRUE to move randomly
    LONG                    m_lVolume;                          // Volume level
    MM_STATE                m_mmOldState;                       // Old/current state
    MM_STATE                m_mmState;                          // New state set from game thread
    DWORD                   m_dwPacketsCompleted;               // # of packets completed

    // Music information
    CSoundtrack *           m_aSoundtracks;                     // List of soundtracks
    UINT                    m_uSoundtrackCount;                 // Total number of soundtracks
    UINT                    m_uCurrentSoundtrack;               // Currently selected soundtrack
    WCHAR                   m_szSong[MAX_SONG_NAME];            // Current song name
    DWORD                   m_dwLength;                         // Length of current song
    DWORD                   m_dwSong;                           // Current song index
    DWORD                   m_dwSongID;                         // Current song ID
    HANDLE                  m_hDecodingFile;                    // Song file handle

    // Decode/playback members
    XWmaFileMediaObject *   m_pDecoder;                         // WMA decoder
    IDirectSoundStream *    m_pStream[2];                       // Output streams
    DWORD                   m_dwStream;                         // Current stream
    BYTE *                  m_pbSampleData;                     // Audio sample data

    // Packet status values
    DWORD                   m_adwPacketStatus[PACKET_COUNT+EXTRA_PACKETS];

    // Thread/Synchronization
    HANDLE                  m_hThread;                          // Worker thread
    HANDLE                  m_hShutdownEvent;                   // Shutdown event

#if _DEBUG
    HRESULT DebugVerify();  // Verify all game soundtracks are present
#endif
};

#endif // _MUSICMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AsyncXMO\asyncxmo.cpp ===
//-----------------------------------------------------------------------------
// File: AsyncXMO.cpp
//
// Desc: A sample to show how to stream data between 2 XMOs( 1 async source, 
//       one async target).
//
// Hist: 02.20.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdlib.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "dsstdfx.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Pause" },
};

#define NUM_HELP_CALLOUTS 2


//
// Debug macros
//
#define ASSERT(w) {if(w){}}
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp)
#define DBG_ERROR(_exp)
#define DBG_WARN(_exp)


//
// Simple macro to verify that the packet size is OK for a particular XMO
//
inline HRESULT XMOFILTER_VERIFY_PACKET_SIZE( XMEDIAINFO& xMediaInfo, DWORD dwPacketSize )
{
    if( xMediaInfo.dwOutputSize > dwPacketSize )
        return E_FAIL;
    if( xMediaInfo.dwOutputSize ) 
        if( dwPacketSize % xMediaInfo.dwOutputSize != 0 )
            return E_FAIL;
    if( dwPacketSize < xMediaInfo.dwMaxLookahead )
        return E_FAIL;

    return S_OK;
}


//
// Linked list structure for tracking our media packet contexts
//
struct LINKED_LIST 
{
    LINKED_LIST* pNext;
    LINKED_LIST* pPrev;

    inline VOID Initialize()         { pNext = pPrev = this; }
    inline BOOL IsListEmpty()        { return pNext == this; }
    inline LINKED_LIST* RemoveHead() { pNext->Remove(); }
    inline LINKED_LIST* RemoveTail() { pPrev->Remove(); }

    inline VOID Remove() 
    {
        LINKED_LIST* pOldNext = pNext;
        LINKED_LIST* pOldPrev = pPrev;
        pOldPrev->pNext = pOldNext;
        pOldNext->pPrev = pOldPrev;
    }

    inline VOID Add( LINKED_LIST* pEntry ) 
    {
        LINKED_LIST* pOldHead = this;
        LINKED_LIST* pOldPrev = this->pPrev;
        pEntry->pNext   = pOldHead;
        pEntry->pPrev   = pOldPrev;
        pOldPrev->pNext = pEntry;
        pOldHead->pPrev = pEntry;
    }
};


//
// We arrived at this packet size based on the requirements of the XMOs.
// The idea is to pick an arbitrary packet size, go through the Init function
// once and then if any asserts fires while verifying the packet sizes, change
// the packet to satisfy all requirements
//
#define PACKET_CNT      4
#define PACKET_SIZE     0x1000*2
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

// This structure keeps track of our packet status, buffer data, etc.
struct MEDIA_PACKET_CTX
{
    LINKED_LIST ListEntry;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};


//-----------------------------------------------------------------------------
// Name: class XFilterGraph
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CFilterGraph : public CXBApplication
{
public:
    LPDIRECTSOUND8 m_pDSound;               // DirectSound object
    XFileMediaObject* m_pSourceXMO;         // Source XMO - the WMA file
    XMediaObject* m_pTargetXMO;             // Target XMO - DSound

    DWORD         m_dwSourceLength;         // Size of source
    DWORD         m_dwBytesRead;            // Bytes of stream processed

    DWORD         m_dwMinPacketSize;        // For verifying our packet size
    DWORD         m_dwPacketSize;           // Packet size
    DWORD         m_dwMaxBufferCount;       // # of buffers

    WAVEFORMATEX  m_wfxAudioFormat;         // Audio format

    LINKED_LIST   m_SourcePendingList;      // Media Contexts in source list
    LINKED_LIST   m_TargetPendingList;      // Media Contexts in target list

    BYTE*         m_pTransferBuffer;        // Buffer data
    BYTE*         m_pPacketContextPool;     // Packet contexts

    CXBFont       m_Font;                   // Font renderer
    CXBHelp       m_Help;                   // Help object
    BOOL          m_bDrawHelp;              // Should we draw help?

    HRESULT       m_hOpenResult;            // Error code from WMAStream::Initialize()
    BOOL          m_bPaused;                // Paused?

    // Virtual calls from CXBApplication
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

    // These functions attach a media context packet to an XMO by 
    // setting up the XMEDIAPACKET struct, calling Process(), and
    // then adding our media packet context to the appropriate list
    HRESULT AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx );
    HRESULT AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx );

    // Handles transferring packets through our filter graph
    HRESULT TransferData();
};




//-----------------------------------------------------------------------------
// Name: AttachPacketToSourceXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       source XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the source XMO (first xmo in the chain)
    hr = m_pSourceXMO->Process( NULL, &xmb );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our source list
    m_SourcePendingList.Add( &pCtx->ListEntry );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AttachPacketToTargetXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       target XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer         
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the target XMO (first xmo in the chain)
    hr = m_pTargetXMO->Process( &xmb, NULL );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our target list
    m_TargetPendingList.Add( &pCtx->ListEntry );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize
//
// Desc: Creates a streaming graph between 2 XMOs: a source, and a target. 
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::Initialize()
{
    HRESULT        hr;
    DWORD          dwMinSize;
    XMEDIAINFO     xMediaInfo;
    DSSTREAMDESC   dssd;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;
    m_bPaused = FALSE;

    m_dwBytesRead = 0;
    m_dwPacketSize     = PACKET_SIZE;
    m_dwMaxBufferCount = PACKET_CNT;

    // Create src media object
    m_hOpenResult = WmaCreateDecoder("D:\\MEDIA\\sounds\\test.wma",
                                     NULL,
                                     TRUE,
                                     4096*16,
                                     PACKET_CNT,
                                     0,
                                     &m_wfxAudioFormat,
                                     (XFileMediaObject **)&m_pSourceXMO );

    if( FAILED(m_hOpenResult) ) 
    {
        // If we failed to create a decoder, return success so we keep running.
        // FrameMove and render will check this error code and display an error
        // message instead of attempting to process the WMA
        DBG_ERROR( ("XmoFilter: WmaCreateDecoder failed with %x", m_hOpenResult) );
        return S_OK;
    }

    m_pSourceXMO->GetLength( &m_dwSourceLength );

    // Now create the target XMO, the end part of the streaming chain
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwFlags              = 0;
    dssd.dwMaxAttachedPackets = PACKET_CNT;
    dssd.lpwfxFormat          = &m_wfxAudioFormat;

    hr = DirectSoundCreateStream( &dssd, 
                                  (LPDIRECTSOUNDSTREAM*)&m_pTargetXMO );
    if( FAILED(hr) ) 
    {          
        DBG_ERROR( ("XmoFilter: DirectSoundCreateXMOStream failed with %x", hr) );
        DBG_ERROR( ("Init: Could not open a target audio XMO\n") );
        return hr;
    }

    //
    // At this point we should have all the XMOs.
    // Figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned.
    // As a last check we make sure its also larger than the maxLookahead
    //
    // At the end of all this, m_dwMinPacketSize is the minimum packet size
    // for this filter graph.
    //
    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    if( m_pSourceXMO )
    {
        m_pSourceXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = xMediaInfo.dwOutputSize;

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    if( m_pTargetXMO )
    {
        m_pTargetXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = max( xMediaInfo.dwOutputSize, m_dwMinPacketSize );

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    ASSERT( m_pTargetXMO );
    ASSERT( m_pSourceXMO );

    // Initialize the linked lists
    m_SourcePendingList.Initialize();
    m_TargetPendingList.Initialize();

    //
    // Allocate one large buffer for incoming/outgoing data. The buffer is
    // going to be divided among our media context packets, which will be 
    // used to stream data between XMOs
    //
    dwMinSize = MAXBUFSIZE;
    m_pTransferBuffer = (BYTE *)XPhysicalAlloc( dwMinSize,
                                                MAXULONG_PTR,
                                                0,
                                                PAGE_READWRITE | PAGE_NOCACHE );
    ZeroMemory( m_pTransferBuffer, dwMinSize );

    //
    // Allocate a context pool. A context is associated with a packet buffer
    // and used to track the pending packets attached to the source or target
    // XMO.
    dwMinSize = ( PACKET_CNT * sizeof(MEDIA_PACKET_CTX) );
    m_pPacketContextPool = new BYTE[dwMinSize];
    ZeroMemory( m_pPacketContextPool, dwMinSize );

    //
    // We attach all available packet buffers in the beginning to prime the
    // graph: As each packet is completed by the source XMO, the status is
    // udpated in its packet context and we pass the packet to the next XMO.
    //
    for( DWORD i = 0; i < PACKET_CNT; i++ ) 
    {
        MEDIA_PACKET_CTX* pCtx = &((MEDIA_PACKET_CTX*)m_pPacketContextPool)[i];

        ZeroMemory( pCtx, sizeof(MEDIA_PACKET_CTX) );
        pCtx->dwCompletedSize = m_dwPacketSize;
        pCtx->pBuffer         = &m_pTransferBuffer[i*PACKET_SIZE];

        AttachPacketToSourceXMO( pCtx );
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Clean up resources
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::Cleanup()
{
    // Cleanup: delete any XMO's
    if( m_pSourceXMO )       
        m_pSourceXMO->Release();
    if( m_pTargetXMO )       
        m_pTargetXMO->Release();
    if( m_pDSound )
        m_pDSound->Release();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene - just a progress bar denoting how much of the 
//       source file has been read.
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::Render()
{
    DWORD dwPercentCompleted = 100 * m_dwBytesRead / m_dwSourceLength;
    // Render the scene (which is just the progress bar)
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );
    RenderGradientBackground( 0xFFFF0000, 0xFF0000FF );

    DirectSoundDoWork();

    // If didn't open the WMA file
    if( FAILED( m_hOpenResult ) )
    {
        WCHAR strFailure[128];
        wsprintfW( strFailure, L"Failed to load WMA; HRESULT: 0x%X", m_hOpenResult );
        m_Font.DrawText( 64,  50, 0xffffffff, strFailure );
    }
    else
    {
        // Show title, frame rate, and help
        if( m_bDrawHelp )
            m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
        else
        {
            // Draw the text
            m_Font.DrawText( 64,  50, 0xffffffff, L"AsyncXMO" );
        }
        WCHAR sz[100];
        swprintf( sz, L"Progress: %s", m_bPaused ? L"(Paused)" : L"" );
        m_Font.DrawText( 64, 375, 0xffffff00, sz);

        // Render a simple progress bar to show the percent completed
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[8];
        FLOAT x1 =  64, x2 = x1 + ( 512 * dwPercentCompleted ) / 100, x3 = 64 + 512;
        FLOAT y1 = 400, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffff00;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffff00;
        v[2].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffffff00;
        v[3].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffffff00;
        v[4].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[4].color = 0xff8080ff;
        v[5].p = D3DXVECTOR4( x3-0.5f, y1-0.5f, 1.0f, 1.0f );  v[5].color = 0xff8080ff;
        v[6].p = D3DXVECTOR4( x3-0.5f, y2-0.5f, 1.0f, 1.0f );  v[6].color = 0xff8080ff;
        v[7].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[7].color = 0xff8080ff;

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 2, v, sizeof(v[0]) );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates, such as checking async xmo status, and
//       updating source file position for our progress bar
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle pause
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_bPaused = !m_bPaused;
        ((LPDIRECTSOUNDSTREAM)m_pTargetXMO)->Pause( m_bPaused ? DSSTREAMPAUSE_PAUSE : DSSTREAMPAUSE_RESUME );
    }

   if( !FAILED(m_hOpenResult) ) 
   {
        // Instruct routine to poll the filter graph so completed packets can be
        // moved through the streaming chain.
        if( FAILED( TransferData() ) )
            return E_FAIL;

        // Because of compression, we have to ask the filter how much
        // we've processed
        m_pSourceXMO->Seek( 0, FILE_CURRENT, &m_dwBytesRead  );
   }
        
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: TransferData
// Desc: If we have a packet completed from our source XMO, pass it through
//       the intermediate XMO and on to the target.
//       If we have a packet completed from our target XMO, recycle it back
//       to the source XMO.
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::TransferData()
{
    HRESULT        hr=S_OK;
    DWORD          index = 0;
    XMEDIAPACKET   xmb;
    MEDIA_PACKET_CTX* pSrcCtx = NULL;
    MEDIA_PACKET_CTX* pDstCtx = NULL;
    DWORD             dwSize  = 0;

    // Setup media buffer
    ZeroMemory( &xmb, sizeof(xmb) );

    //
    // Always deal with the oldest packet first.  Oldest packets are at the 
    // head, since we insert at the tail, and remove from head
    //
    if( !m_SourcePendingList.IsListEmpty() ) 
    {
        pSrcCtx = (MEDIA_PACKET_CTX*)m_SourcePendingList.pNext; // Head
    }

    if( !m_TargetPendingList.IsListEmpty() ) 
    {
        pDstCtx = (MEDIA_PACKET_CTX*)m_TargetPendingList.pNext; // Head
    }        

    // Do we have a completed source packet?
    if( pSrcCtx && pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING ) 
    {
        // A src buffer completed.
        // Remove this context from the Src pending list.
        // Send it to a codec, if present, then send it to the Target xmo
        pSrcCtx->ListEntry.Remove();

        // Before we pass it on, set the context packet to amount of data we received
        xmb.pvBuffer         = pSrcCtx->pBuffer;            
        xmb.dwMaxSize        = pSrcCtx->dwCompletedSize;

        DBG_SPAM(("Context %x received %x bytes, xmb %x\n",pSrcCtx, xmb.dwMaxSize, &xmb));
        ASSERT( xmb.dwMaxSize );

        // Rset the state of our context
        pSrcCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

        // Remember how much data we got from the source XMO
        dwSize = xmb.dwMaxSize;

        if (dwSize < PACKET_SIZE) {
    
            //
            // the source xmo produced less than asked. this signals end of file for wma xmo
            // flush it so it starts at the begininning again...
            // Pass at least a sample worth of data to dsound so it will not RIP
            //
            m_pSourceXMO->Flush();
            pSrcCtx->dwCompletedSize = max(4,dwSize);

        }

        // Pass media buffer to the target xmo.
        AttachPacketToTargetXMO( pSrcCtx );
    }

    // Check if we have a completed packet from the target
    if( pDstCtx && pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING )
    {       
        DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));

        // Remove the entry from the list
        pDstCtx->ListEntry.Remove();

        ASSERT(pDstCtx->dwCompletedSize != 0);

        // The target XMO is done with a buffer.
        pDstCtx->dwCompletedSize = PACKET_SIZE;
        AttachPacketToSourceXMO( pDstCtx );
    } 

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CFilterGraph xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\BackgroundMusic.cpp ===
//-----------------------------------------------------------------------------
// File: BackgroundMusic.cpp
//
// Desc: The BackgroundMusic sample demonstrates how to play background WMA
//       files, combining game WMA assets with user soundtracks stored on the
//       Xbox hard drive.  Please see the documentation for this sample for
//       further information.
//
// Hist: 8.20.01 - New for October XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "dsstdfx.h"
#include "musicmanager.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle playback" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Next\nsoundtrack" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Next\nsong" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Pause playback" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Recreate\nMusicManager" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Random\nsong" },
    { XBHELP_LEFT_BUTTON,  XBHELP_PLACEMENT_2, L"Toggle\nrandom" },
    { XBHELP_RIGHT_BUTTON, XBHELP_PLACEMENT_2, L"Toggle global" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Volume" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT DownloadEffectsImage(LPCSTR pszScratchFile);    // downloads a default DSP image to the GP

    // Font and help
    CXBFont         m_Font;
    CXBHelp         m_Help;
    BOOL            m_bDrawHelp;

    LPDIRECTSOUND8  m_pDSound;                          // DirectSound object
    CMusicManager*  m_pMusicManager;                    // Music Manager
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp     = FALSE;
    m_pMusicManager = NULL;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(LPCSTR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if( !bResult )
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;    

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Create MusicManager
    m_pMusicManager = new CMusicManager();
    if( !m_pMusicManager )
        return E_OUTOFMEMORY;

    // Initialize it
    if( FAILED( m_pMusicManager->Initialize() ) )
        return E_FAIL;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle playback
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_pMusicManager->GetStatus() == MM_PLAYING )
            m_pMusicManager->Stop();
        else
            m_pMusicManager->Play();
    }

    // Switch to next soundtrack
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_pMusicManager->NextSoundtrack();
    }

    // Switch to next song
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_pMusicManager->NextSong();
    }

    // Select a random song
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
    {
        m_pMusicManager->RandomSong( m_pMusicManager->GetGlobal() );
    }

    // Pause playback
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] &&
        m_pMusicManager->GetStatus() == MM_PLAYING )
    {
        m_pMusicManager->Pause();
    }

    // Destroy the MusicManager and create a new one
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_WHITE ] )
    {
        delete m_pMusicManager;
        m_pMusicManager = new CMusicManager();
        if( !m_pMusicManager )
            return E_OUTOFMEMORY;

        if( FAILED( m_pMusicManager->Initialize() ) )
            return E_FAIL;
    }

    // Select between random and sequential play
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_LEFT_TRIGGER ] )
    {
        m_pMusicManager->SetRandom( !m_pMusicManager->GetRandom() );
    }

    // Select between global and local play
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_RIGHT_TRIGGER ] )
    {
        m_pMusicManager->SetGlobal( !m_pMusicManager->GetGlobal() );
    }

    LONG lVolume = m_pMusicManager->GetVolume();
    lVolume += LONG(m_DefaultGamepad.fX1 * m_fElapsedTime * 500);
    if( lVolume < DSBVOLUME_MIN )
        lVolume = DSBVOLUME_MIN;
    if( lVolume > DSBVOLUME_MAX )
        lVolume = DSBVOLUME_MAX;
    m_pMusicManager->SetVolume( lVolume );

    DirectSoundDoWork();

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"BackgroundMusic" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR szSoundtrack[ MAX_SOUNDTRACK_NAME ];
        WCHAR szSong[ MAX_SONG_NAME ];
        DWORD dwLength;
        WCHAR sz[100];

        // Get information about what song/soundtrack is currently selected
        m_pMusicManager->GetCurrentInfo( szSoundtrack, szSong, &dwLength );
        swprintf( sz, L"Soundtrack: %s", szSoundtrack );
        m_Font.DrawText( 64, 80, 0xffffffff, sz );

        swprintf( sz, L"Song: %s", szSong );
        m_Font.DrawText( 64, 110, 0xffffffff, sz );

        FLOAT fPos = m_pMusicManager->GetPlaybackPosition();
        swprintf( sz, L"Position: %02d:%02d / %02d:%02d", DWORD(fPos / 60), 
                                                          (DWORD)fPos % 60, 
                                                          ( dwLength / 60000 ), 
                                                          ( dwLength / 1000 ) % 60 );
        m_Font.DrawText( 64, 140, m_pMusicManager->GetStatus() == MM_PLAYING ? 0xffffffff : 0xff808080, sz );

        swprintf( sz, L"Mode: %s %s", m_pMusicManager->GetRandom() ? L"Random" : L"Sequential", 
                                      m_pMusicManager->GetGlobal() ? L"Global" : L"Local" );
        m_Font.DrawText( 64, 170, 0xffffff00, sz );

        swprintf( sz, L"Volume %ddB", m_pMusicManager->GetVolume() / 100 );
        m_Font.DrawText( 64, 200, 0xffffff00, sz );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\AudioStress\AudioStress.cpp ===
//-----------------------------------------------------------------------------
// File: AudioStress.cpp
//
// Desc: Demonstrates the effects of CPU and GPU load on audio playback using
//       asynchronous streaming
//
// Hist: 3.20.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "dsstdfx.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Adjust CPU Load" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Adjust GPU Load" },
};

#define NUM_HELP_CALLOUTS 3

#define PACKET_CNT      3
#define PACKET_SIZE     0x2000*2
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

// This structure keeps track of our packet status, buffer data, etc.
struct MEDIA_PACKET_CTX
{
    BOOL        bDecoded;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT AttachPacketToXMO( BOOL bSource, MEDIA_PACKET_CTX * pPacket );
    HRESULT ProcessPackets();
    MEDIA_PACKET_CTX * FindFreePacket();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    // Load to put on CPU and GPU
    FLOAT       m_fCPUUsage;
    FLOAT       m_fGPUUsage;

    // Draw help?
    BOOL        m_bDrawHelp;

    // Vertex shader for using GPU
    DWORD       m_dwVertexShader;

    HRESULT     m_hOpenResult;

    XFileMediaObject* m_pSourceXMO;         // Source XMO - the WMA file
    XMediaObject*     m_pTargetXMO;         // Target XMO - DSound
    LPDIRECTSOUND8    m_pDSound;            // DirectSound object

    // Buffers for audio processing
    MEDIA_PACKET_CTX    m_aPacketContexts[ PACKET_CNT ];
    BYTE *              m_abBuffer;

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    m_fCPUUsage =
    m_fGPUUsage = 0.0f;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    WAVEFORMATEX wf;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Create the state shader for consuming GPU time
    if(FAILED(XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\MatInv.xvu", 
									     NULL, &m_dwVertexShader)))
	return E_FAIL;

    // Create src media object
    m_hOpenResult = WmaCreateDecoder("D:\\MEDIA\\sounds\\becky.wma",
                                     NULL,
                                     TRUE,
                                     4096*16,
                                     PACKET_CNT,
                                     0,
                                     &wf,
                                     (XFileMediaObject **)&m_pSourceXMO );

    if( FAILED(m_hOpenResult) ) 
        return S_OK;

    // Now create the target XMO, the end part of the streaming chain
    DSSTREAMDESC   dssd;
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwFlags              = 0;
    dssd.dwMaxAttachedPackets = PACKET_CNT;
    dssd.lpwfxFormat          = &wf;

    if( FAILED( DirectSoundCreateStream( &dssd, 
                                         (LPDIRECTSOUNDSTREAM*)&m_pTargetXMO ) ) )
        return E_FAIL;

    m_abBuffer = new BYTE[ MAXBUFSIZE ];
    ZeroMemory( m_aPacketContexts, sizeof( m_aPacketContexts ) );

    for( int i = 0; i < PACKET_CNT; i++ )
    {
        m_aPacketContexts[ i ].dwCompletedSize = PACKET_SIZE;
        m_aPacketContexts[ i ].pBuffer = &m_abBuffer[ i * PACKET_SIZE ];
        AttachPacketToXMO( TRUE, &m_aPacketContexts[ i ] );
    }

    return S_OK;
}

#define USAGE_SCALE 20.0f
// CPU_MAXTIME is 100% CPU utilization in seconds
#define CPU_MAXTIME 0.016667f * 6
// GPU_MAXTIME is 100% GPU utilization in seconds
#define GPU_MAXTIME 0.016667f * 6
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    LARGE_INTEGER liFreq;
    FLOAT         fSecondsPerTick;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liCurrent;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Update CPU and GPU usage
    m_fCPUUsage += m_DefaultGamepad.fY1 * m_fElapsedTime * USAGE_SCALE;
    if( m_fCPUUsage < 1.0f )
        m_fCPUUsage = 1.0f;
    else if( m_fCPUUsage > 100.0f )
        m_fCPUUsage = 100.0f;

    m_fGPUUsage += m_DefaultGamepad.fY2 * m_fElapsedTime * USAGE_SCALE;
    if( m_fGPUUsage < 1.0f )
        m_fGPUUsage = 1.0f;
    else if( m_fGPUUsage > 100.0f )
        m_fGPUUsage = 100.0f;

    // Set up for timing measurements
    QueryPerformanceFrequency( &liFreq );
    fSecondsPerTick = 1.0f / liFreq.QuadPart;

    m_pd3dDevice->SetVertexShader( m_dwVertexShader );

    ProcessPackets();

    // Here's where we keep the machine busy
    QueryPerformanceCounter( &liStart );
    for( ; ; )
    {
        QueryPerformanceCounter( &liCurrent );
        BOOL bUseCPU = ( liCurrent.QuadPart - liStart.QuadPart ) * fSecondsPerTick < CPU_MAXTIME * m_fCPUUsage / 100.0f;
        BOOL bUseGPU = ( liCurrent.QuadPart - liStart.QuadPart ) * fSecondsPerTick < GPU_MAXTIME * m_fGPUUsage / 100.0f;

        // If we don't need to use either CPU or GPU, break out
        if( !bUseCPU && !bUseGPU )
            break;

        // If we should be using the GPU and we're not already running the shader, do so
        if( bUseGPU && !m_pd3dDevice->IsBusy() )
            m_pd3dDevice->RunVertexStateShader( 0, NULL );

        // If we should NOT be using the CPU, yield.  Otherwise, we'll
        // continue in a tight loop, which will burn the CPU
        if( !bUseCPU )
            Sleep( 5 );
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    m_Font.DrawText( 100, 150, 0xFFFF0000, L"CPU:");
    m_Font.DrawText( 100, 250, 0xFF0000FF, L"GPU:");

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );

    // Draw the CPU Usage bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 200, x2 = x1 + (340*m_fCPUUsage)/100;
        FLOAT y1 = 150, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffff0000;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffff0000;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Draw the GPU Usage bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 200, x2 = x1 + (340*m_fGPUUsage)/100;
        FLOAT y1 = 250, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xff0000ff;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xff0000ff;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }


    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"AudioStress" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: AttachPacketToXMO
// Desc: Attaches the packet to either the source or target XMO.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::AttachPacketToXMO( BOOL bSource, MEDIA_PACKET_CTX * pPacket )
{
    XMEDIAPACKET xmb;

    pPacket->dwStatus = XMEDIAPACKET_STATUS_PENDING;

    ZeroMemory( &xmb, sizeof( XMEDIAPACKET ) );
    xmb.pvBuffer            = pPacket->pBuffer;
    xmb.dwMaxSize           = pPacket->dwCompletedSize;
    xmb.pdwCompletedSize    = &pPacket->dwCompletedSize;
    xmb.pdwStatus           = &pPacket->dwStatus;

    if( bSource )
    {
        if( FAILED( m_pSourceXMO->Process( NULL, &xmb ) ) )
            return E_FAIL;
    }
    else
    {
        if( FAILED( m_pTargetXMO->Process( &xmb, NULL ) ) )
            return E_FAIL;
    }        

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Finds the first free packet and returns it
//-----------------------------------------------------------------------------
MEDIA_PACKET_CTX * CXBoxSample::FindFreePacket()
{
    for( int i = 0; i < PACKET_CNT; i++ )
    {
        if( m_aPacketContexts[ i ].dwStatus == XMEDIAPACKET_STATUS_SUCCESS )
            return &m_aPacketContexts[ i ];
    }

    return NULL;
}



//-----------------------------------------------------------------------------
// Name: ProcessPackets
// Desc: Grabs all available packets and sends them to the appropriate
//       XMO - Source if they haven't been decoded yet, Target if they have.
//       Also checks for end of source buffer and resets the source XMO
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ProcessPackets()
{
    MEDIA_PACKET_CTX * pPacket;

    while( pPacket = FindFreePacket() )
    {
        // If we didn't get enough from the source, adjust size and flush
        if( !pPacket->bDecoded && pPacket->dwCompletedSize < PACKET_SIZE )
        {
            m_pSourceXMO->Flush();
            if( pPacket->dwCompletedSize < 4 )
                pPacket->dwCompletedSize = 4;
        }

        pPacket->dwStatus = XMEDIAPACKET_STATUS_PENDING;
        pPacket->dwCompletedSize = PACKET_SIZE;
        pPacket->bDecoded = !pPacket->bDecoded;

        if( FAILED( AttachPacketToXMO( !pPacket->bDecoded, pPacket ) ) )
            return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\BackgroundMusic\MusicManager.cpp ===
//-----------------------------------------------------------------------------
// File: MusicManager.cpp
//
// Desc: Implementation file for CMusicManager class.
//
// Hist: 8.20.01 - New for October XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "musicmanager.h"
#include "XbUtil.h"
#include <assert.h>
#include <stdio.h>
#include <tchar.h>



//
// Here is our game soundtrack including WMA files we ship
// with our game.  If needed, this concept could be extended
// to include several different game soundtracks
//

// Structure representing game soundtrack song
typedef struct {
    WCHAR * szName;
    CHAR *  szFilename;
    DWORD   dwLength;
} MM_SONG;

MM_SONG g_aGameSoundtrack[] =
{
    { L"Becky", "D:\\Media\\Sounds\\Becky.wma", 165000 },
    { L"Becky remix", "D:\\Media\\Sounds\\Becky.wma", 165000 },
};

#define NUM_GAME_SONGS ( sizeof( g_aGameSoundtrack ) / sizeof( g_aGameSoundtrack[0] ) )

#define WORKER_THREAD_STACK_SIZE 12 * 1024
#define WMA_LOOKAHEAD 64 * 1024
#define YIELD_RATE 3

//
// The following methods are safe to be called from the main rendering thread.
// In order to avoid CPU-intensive thread synchronization, we assume that only
// one thread will ever be calling into these functions.  That way, we know
// that if there is no state change already pending, then the state cannot 
// possibly change during a function call.  Threading issues are noted for
// each of these functions
//

//-----------------------------------------------------------------------------
// Name: CMusicManager (ctor)
// Desc: Initializes member variables
// Thread issues: None - worker thread is not created yet.
//-----------------------------------------------------------------------------
CMusicManager::CMusicManager()
{
    m_mmOldState    = MM_STOPPED;
    m_mmState       = MM_STOPPED;
    m_fRandom       = FALSE;
    m_fGlobal       = TRUE;
    m_lVolume       = DSBVOLUME_MAX;
    m_dwStream      = 0;
    m_dwSong        = 0;
    m_szSong[0]     = 0;
    m_dwLength      = 0;
    m_dwSongID      = 0;

    m_aSoundtracks          = NULL;
    m_uSoundtrackCount      = 0;
    m_uCurrentSoundtrack    = 0;
    m_dwPacketsCompleted    = 0;

    m_pbSampleData  = NULL;
    m_pDecoder      = NULL;
    m_pStream[0]    = NULL;
    m_pStream[1]    = NULL;
    m_hDecodingFile = INVALID_HANDLE_VALUE;

    m_hThread           = INVALID_HANDLE_VALUE;
    m_hShutdownEvent    = INVALID_HANDLE_VALUE;

    for( INT i = 0; i < PACKET_COUNT + EXTRA_PACKETS; i++ )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;
}


//-----------------------------------------------------------------------------
// Name: ~CMusicManager (dtor)
// Desc: Releases any resources allocated by the object
// Thread issues: This function waits for the worker thread to shut down
//                before continuing processing.  
//-----------------------------------------------------------------------------
CMusicManager::~CMusicManager()
{
    // Signal our worker thread to shutdown, then wait for it
    // before releasing objects
    if( m_hShutdownEvent != INVALID_HANDLE_VALUE )
        SetEvent( m_hShutdownEvent );
    
    if( m_hThread != INVALID_HANDLE_VALUE )
    {
        WaitForSingleObject( m_hThread, INFINITE );
        CloseHandle( m_hThread );
    }

    // We can't close the handle until we're sure the worker
    // thread has terminated.
    if( m_hShutdownEvent != INVALID_HANDLE_VALUE )
        CloseHandle( m_hShutdownEvent );

    // Now that we've shut down the worker thread, it's safe
    // to clean these guys up.
    if( m_pStream[0] )
    {
        m_pStream[0]->Pause( DSSTREAMPAUSE_RESUME );
        m_pStream[0]->Release();
    }

    if( m_pStream[1] )
    {
        m_pStream[1]->Pause( DSSTREAMPAUSE_RESUME );
        m_pStream[1]->Release();
    }

    if( m_pbSampleData )
        delete[] m_pbSampleData;

    free( m_aSoundtracks );

}


//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Sets up the object to run
// Thread issues: None - worker thread isn't created until end of function
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Initialize( BOOL bSpinThread /* TRUE */ )
{
    HRESULT hr;

    // Load up soundtrack information
    hr = LoadSoundtracks();
    if( FAILED( hr ) )
        return hr;
    SelectSong( 0 );

    srand( GetTickCount() );

    // Soundtrack songs are ripped to this format.  Any individual
    // WMA tracks shipped with the game will need to be encoded
    // similarly.
    // Alternately, streams could be released and re-created when
    // switching tracks, but this would incur additional CPU costs.  
    // In the future, a SetFormat() routine on DirectSound streams 
    // and buffers will make this simpler.
    WAVEFORMATEX wfx = {0};
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 2;
    wfx.nSamplesPerSec = 44100;
    wfx.wBitsPerSample = 16;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;

    // Set up a stream desc to create our streams
    DSSTREAMDESC dssd = {0};
    dssd.dwMaxAttachedPackets = PACKET_COUNT;
    dssd.lpwfxFormat = &wfx;
    dssd.lpfnCallback = StreamCallback;
    dssd.lpvContext = this;

    // Create the streams
    hr = DirectSoundCreateStream( &dssd, &m_pStream[0] );
    if( FAILED( hr ) )
        return hr;
    hr = DirectSoundCreateStream( &dssd, &m_pStream[1] );
    if( FAILED( hr ) )
        return hr;

    // Set up attack envelopes to fade in for us
    DSENVELOPEDESC dsed = {0};
    dsed.dwEG = DSEG_AMPLITUDE;
    dsed.dwMode = DSEG_MODE_ATTACK;
    dsed.dwAttack = DWORD(48000 * FADE_TIME / 512);
    dsed.dwRelease = DWORD(48000 * FADE_TIME / 512);
    dsed.dwSustain = 255;
    m_pStream[0]->SetEG( &dsed );
    m_pStream[1]->SetEG( &dsed );

    // Allocate sample data buffer
    m_pbSampleData = new BYTE[ ( PACKET_COUNT + EXTRA_PACKETS ) * PACKET_SIZE ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

#if _DEBUG
    if( FAILED( DebugVerify() ) )
        return E_FAIL;
#endif // _DEBUG

    if( bSpinThread )
    {
        // Create an event to signal the worker thread to shutdown
        m_hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if( NULL == m_hShutdownEvent )
            return E_FAIL;

        // Create the worker thread
        m_hThread = CreateThread( NULL, WORKER_THREAD_STACK_SIZE, MusicManagerThreadProc, this, 0, NULL );
        if( NULL == m_hThread )
        {
            return E_FAIL;
        }
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Play
// Desc: Starts playing background music
// Thread issues: Depends on worker thread state:
//                MM_PLAYING: No effective change.  Worker thread could be
//                            processing a state change to MM_PAUSED or
//                            MM_STOPPED, in which case we will switch back
//                            to MM_PLAYING on the next iteration of Process()
//                MM_PAUSED:  Next iteration of Process() will pick up the 
//                            state change and resume playback
//                MM_STOPPED: Next iteration of Process() will pick up the
//                            state change and stop playback
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Play()
{
    // Can always transition to playing
    m_mmState = MM_PLAYING;
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Stop
// Desc: Stops background music playback
// Thread issues: Depends on worker thread state:
//                MM_PLAYING: Next iteration of Process() will pick up the
//                            state change and stop playback
//                MM_PAUSED:  Next iteration of Process() will pick up the 
//                            state change and resume playback
//                MM_STOPPED: No effective change.  Worker thread could be
//                            processing a state change to MM_PLAYING, in
//                            which case we will switch back to MM_STOPPED
//                            on the next iteration of Process()
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Stop()
{
    // Can always transition to stopped
    if( m_mmOldState != MM_STOPPED &&
        m_mmState    != MM_STOPPED )
    {
        m_mmState = MM_STOPPED;

        // Pause the streams right now so that we
        // stop playback.  They'll get shut down
        // fully on the worker thread
        m_pStream[0]->Pause( DSSTREAMPAUSE_PAUSE );
        m_pStream[1]->Pause( DSSTREAMPAUSE_PAUSE );
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Pause
// Desc: Pauses background music playback
// Thread issues: Since we can only transition to MM_PAUSED from MM_PLAYING,
//                make sure that we're already at MM_PLAYING, and don't have
//                a pending state change.  Next iteration of Process() will
//                pick up the change to MM_PAUSED and pause playback
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Pause()
{
    // Can only transition to paused from playing.
    if( m_mmOldState == MM_PLAYING &&
        m_mmState == MM_PLAYING )
    {
        m_pStream[0]->Pause( DSSTREAMPAUSE_PAUSE );
        m_pStream[1]->Pause( DSSTREAMPAUSE_PAUSE );
        m_mmState = MM_PAUSED;
        return S_OK;
    }

    return S_FALSE;
}



//-----------------------------------------------------------------------------
// Name: SetRandom
// Desc: Sets the playback mode for how to pick the next song.  If fRandom is
//       true, the next track is picked randomly, otherwise it's sequential.
//       If fGlobal is true, we'll move between soundtracks, otherwise we stay
//       within the current soundtrack
// Thread issues: The worker thread could be in the middle of picking which
//                track to play next.  The new setting may or may not be 
//                used, depending on exactly when the calls occurs.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SetRandom( BOOL fRandom )
{
    m_fRandom = fRandom;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetGlobal
// Desc: Sets the playback mode for how to pick the next song.  If fGlobal is 
//       true, we'll move between soundtracks, otherwise we stay  within the 
//       current soundtrack
// Thread issues: The worker thread could be in the middle of picking which
//                track to play next.  The new setting may or may not be 
//                used, depending on exactly when the calls occurs.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SetGlobal( BOOL fGlobal )
{
    m_fGlobal = fGlobal;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetVolume
// Desc: Sets the overall volume level for music playback.  Note that this
//       won't really work properly until we start using envelope release
// Thread issues: None - the worker thread doesn't set volume levels.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SetVolume( LONG lVolume )
{
    assert( m_pStream[0] && m_pStream[1] );

    m_lVolume = lVolume;
    m_pStream[0]->SetVolume( lVolume );
    m_pStream[1]->SetVolume( lVolume );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: GetCurrentInfo
// Desc: Returns pointers to info.  Buffers should be appropriately sized, ie
//       MAX_SOUNDTRACK_NAME and MAX_SONG_NAME, respectively
// Thread issues: The worker thread could be in the middle of switching
//                between songs and/or soundtracks.  In this case, we could
//                return mixed information.  This is OK, since this is meant
//                to be called periodically to update state, so the results
//                will eventually be consistent.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::GetCurrentInfo( WCHAR * szSoundtrack, WCHAR * szSong, DWORD * pdwLength )
{
    if( szSoundtrack )
        m_aSoundtracks[ m_uCurrentSoundtrack ].GetSoundtrackName( szSoundtrack );
    if( szSong )
        wcscpy( szSong, m_szSong );
    if( pdwLength )
        *pdwLength = m_dwLength;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: GetPlaybackPosition
// Desc: Returns the current playback position, in seconds
//-----------------------------------------------------------------------------
FLOAT
CMusicManager::GetPlaybackPosition()
{
    return PACKET_TIME * m_dwPacketsCompleted;
}



//-----------------------------------------------------------------------------
// Name: NextSoundtrack
// Desc: Switches to the next soundtrack.  This is only safe to do if playback
//       is stopped, and we don't have a state change pending.  
// Thread issues: The worker thread could be trying to switch songs or 
//                soundtracks, so we can't make a call unless we know that
//                the worker thread is in MM_STOPPED and will stay there for
//                the duration of this call
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::NextSoundtrack()
{
    if( m_mmOldState == MM_STOPPED &&
        m_mmState    == MM_STOPPED )
    {
        return SelectSoundtrack( ( m_uCurrentSoundtrack + 1 ) % m_uSoundtrackCount );
    }

    return S_FALSE;
}



//-----------------------------------------------------------------------------
// Name: NextSong
// Desc: Switches to the next song in the current soundtrack.  This is only 
//       safe to do if playback is stopped, and we don't have a state change 
//       pending.
// Thread issues: The worker thread could be trying to switch songs or 
//                soundtracks, so we can't make a call unless we know that
//                the worker thread is in MM_STOPPED and will stay there for
//                the duration of this call
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::NextSong()
{
    if( m_mmOldState == MM_STOPPED &&
        m_mmState    == MM_STOPPED )
    {
        return SelectSong( ( m_dwSong + 1 ) % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }

    return S_FALSE;
}




//-----------------------------------------------------------------------------
// Name: RandomSong
// Desc: Switches to a random song, either in this soundtrack if fGlobal is
//       FALSE or globally random if fGlobal is TRUE.  This is only safe
//       to do if playback is stopped, and we don't have a state change 
//       pending.
// Thread issues: The worker thread could be trying to switch songs or 
//                soundtracks, so we can't make a call unless we know that
//                the worker thread is in MM_STOPPED and will stay there for
//                the duration of this call
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::RandomSong( BOOL fGlobal )
{
    if( m_mmOldState == MM_STOPPED &&
        m_mmState    == MM_STOPPED )
    {
        if( fGlobal )
        {
            SelectSoundtrack( rand() % m_uSoundtrackCount );
        }
        return SelectSong( rand() % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }
    else
        return S_FALSE;
}




//
// The following methods are not public and are meant only to be called 
// internally by the CMusicManager class.  Any tricky threading issues are
// pointed out as needed.
//



//-----------------------------------------------------------------------------
// Name: LoadSoundtracks
// Desc: Loads soundtrack info for user soundtracks stored on HD
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::LoadSoundtracks()
{
    HANDLE hSoundtrack;
    XSOUNDTRACK_DATA stData;
    UINT uAllocatedSoundtracks;

    m_aSoundtracks = (CSoundtrack *)malloc( sizeof( CSoundtrack ) );
    if( !m_aSoundtracks )
        return E_OUTOFMEMORY;
    uAllocatedSoundtracks = 1;

    // Set up our game soundtrack as soundtrack 0.
    // If we had more than 1 game soundtrack, we could
    // set them all up here
    m_aSoundtracks[0].m_fGameSoundtrack     = TRUE;
    m_aSoundtracks[0].m_uSoundtrackIndex    = 0;
    m_aSoundtracks[0].m_uSongCount          = NUM_GAME_SONGS;
    wcscpy( m_aSoundtracks[0].m_szName, L"Game Soundtrack" );
    m_uSoundtrackCount = 1;

    // Start scanning the soundtrack DB
    hSoundtrack = XFindFirstSoundtrack( &stData );
    if( INVALID_HANDLE_VALUE != hSoundtrack )
    {
        do
        {
            // Double our buffer if we need more space
            if( m_uSoundtrackCount + 1 > uAllocatedSoundtracks )
            {
                void * pNewAlloc = realloc( m_aSoundtracks, ( uAllocatedSoundtracks * 2 ) * sizeof( CSoundtrack ) );
                if( !pNewAlloc )
                {
                    // We couldn't expand our buffer, so clean up
                    // and bail out
                    free( m_aSoundtracks );
                    m_aSoundtracks = NULL;
                    XFindClose( hSoundtrack );
                    return E_OUTOFMEMORY;
                }
                m_aSoundtracks = (CSoundtrack *)pNewAlloc;
                uAllocatedSoundtracks *= 2;
            }

            // Ignore empty soundtracks
            if( stData.uSongCount > 0 )
            {
                // Copy the data over
                m_aSoundtracks[ m_uSoundtrackCount ].m_fGameSoundtrack = FALSE;
                m_aSoundtracks[ m_uSoundtrackCount ].m_uSoundtrackID   = stData.uSoundtrackId;
                m_aSoundtracks[ m_uSoundtrackCount ].m_uSongCount      = stData.uSongCount;
                wcscpy( m_aSoundtracks[ m_uSoundtrackCount ].m_szName, stData.szName );

                m_uSoundtrackCount++;
            }

        } while( XFindNextSoundtrack( hSoundtrack, &stData ) );

        XFindClose( hSoundtrack );
    }

    // Shrink our allocation down to what's actually needed, since
    // we can't add soundtracks on the fly
    m_aSoundtracks = (CSoundtrack *)realloc( m_aSoundtracks, m_uSoundtrackCount * sizeof( CSoundtrack ) );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SelectSoundtrack
// Desc: Changes to the specified soundtrack
// NOTE: This should only be called by the worker thread OR
//       after making sure that playback is stopped with no state change
//       pending.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SelectSoundtrack( DWORD dwSoundtrack )
{
    m_uCurrentSoundtrack = dwSoundtrack;
    SelectSong( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SelectSong
// Desc: Switches to the specified song and caches song info
// NOTE: This should only be called by the worker thread OR
//       after making sure that playback is stopped with no state change
//       pending.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SelectSong( DWORD dwSong )
{
    m_dwSong = dwSong;
    m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongInfo( m_dwSong,
                                                        &m_dwSongID,
                                                        &m_dwLength,
                                                        m_szSong );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindNextSong
// Desc: Simple helper function to switch to the next song, based on the
//       global repeat flag.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::FindNextSong()
{
    if( m_fRandom )
    {
        if( m_fGlobal )
        {
            SelectSoundtrack( rand() % m_uSoundtrackCount );
        }
        SelectSong( rand() % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }
    else
    {
        if( m_fGlobal && 
            m_dwSong == m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() - 1 )
        {
            SelectSoundtrack( ( m_uCurrentSoundtrack + 1 ) % m_uSoundtrackCount );
        }
        else
            SelectSong( ( m_dwSong + 1 ) % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Prepare
// Desc: Prepares to begin playback of the currently set track:
//       1) Clean up the old decoder, if we already had one
//       2) Create a new decoder on the soundtrack handle or our WMA file
//       3) Lower the volume on the output stream for the crossfade
//       4) Mark the start time of the track for rough timing
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Prepare()
{
    WAVEFORMATEX wfx;

    // Kill the old decoder
    Cleanup();

    // Open soundtrack file
    m_hDecodingFile = m_aSoundtracks[ m_uCurrentSoundtrack ].OpenSong( m_dwSongID );
    if( INVALID_HANDLE_VALUE == m_hDecodingFile )
        return E_FAIL;

    // Create the decoder
    if( FAILED( WmaCreateDecoderEx( NULL, 
                                    m_hDecodingFile, 
                                    FALSE,              // Synchronous
                                    WMA_LOOKAHEAD,      // 64k lookahead
                                    PACKET_COUNT,       // # of packets
                                    YIELD_RATE,         // Yield rate
                                    &wfx,               // We know the format already
                                    &m_pDecoder ) ) )   // New decoder
        return E_FAIL;

    // Remember when we started
    m_dwPacketsCompleted = 0;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Cleans up decoding resources
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Cleanup()
{
    // Close soundtrack file, if that's what we had
    if( INVALID_HANDLE_VALUE != m_hDecodingFile )
    {
        CloseHandle( m_hDecodingFile );
        m_hDecodingFile = INVALID_HANDLE_VALUE;
    }

    // Free up the decoder
    if( m_pDecoder )
    {
        m_pDecoder->Release();
        m_pDecoder = NULL;
    }

    m_dwPacketsCompleted = 0;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Process
// Desc: Manages audio packets, filling them from the source XMO and 
//       dispatching them to the appropriate stream.
// Thread issues: This function manages state changes requested from the
//                main game thread.  The main game thread will INT a new value
//                for m_mmState, and then the worker thread will transition
//                to that state as appropriate
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Process()
{
    HRESULT hr;
    DWORD   dwPacket;
    MM_STATE mmCurrentState = m_mmState;

    // Check to see if our state has changed from a call
    // from the main rendering loop, and if it has,
    // update accordingly.
    if( m_mmOldState != mmCurrentState )
    {
        // We can't transition from MM_STOPPED to
        // anything but MM_PLAYING
        assert( !( m_mmOldState == MM_STOPPED &&
                   mmCurrentState != MM_PLAYING ) );

        switch( m_mmOldState )
        {
        //
        // Valid transitions from MM_STOPPED:
        // -> MM_PLAYING = Prepare to play
        //
        case MM_STOPPED:
            switch( mmCurrentState )
            {
            case MM_PLAYING:
                // Make sure the streams are unpaused
                m_pStream[0]->Pause( DSSTREAMPAUSE_RESUME );
                m_pStream[1]->Pause( DSSTREAMPAUSE_RESUME );
                Prepare();
                break;
            }
            break;

        //
        // Valid transitions from MM_PAUSED:
        // -> MM_PLAYING = Resume playback
        // -> MM_STOPPED = Stop playback and clean up
        //
        case MM_PAUSED:
            switch( mmCurrentState )
            {
            case MM_PLAYING:
                m_pStream[0]->Pause( DSSTREAMPAUSE_RESUME );
                m_pStream[1]->Pause( DSSTREAMPAUSE_RESUME );
                break;
            case MM_STOPPED:
                m_pStream[0]->Flush();
                m_pStream[1]->Flush();
                Cleanup();
                break;
            }
            break;

        //
        // Valid transitions from MM_PLAYING:
        // -> MM_PAUSED = Pause streams (already done)
        // -> MM_STOPPED = Stop playback and clean up
        case MM_PLAYING:
            switch( mmCurrentState )
            {
            case MM_STOPPED:
                m_pStream[0]->Flush();
                m_pStream[1]->Flush();
                Cleanup();
                break;
            }
            break;
        }

        // We're done with the transition.  At this point,
        // we're really in the appropriate state, and the
        // other thread can push a new state change through
        m_mmOldState = mmCurrentState;
    }


    // If we're currently playing, then process packets
    // and fades
    if( mmCurrentState == MM_PLAYING )
    {
        // Process packets
        while( FindFreePacket( &dwPacket, m_dwStream ) )
        {
            XMEDIAPACKET xmp;

            hr = ProcessSource( dwPacket, &xmp );
            if( FAILED( hr ) )
                return hr;

            // Make sure we got data from the decoder.  When we
            // hit the end of a track, we may end up with an
            // empty packet.  We'll just loop again and fill it
            // up from the next track.
            if( xmp.dwMaxSize )
            {
                hr = ProcessStream( dwPacket, &xmp );
                if( FAILED( hr ) )
                    return hr;
            }
        }
    }


    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Looks for a free audio packet.  Returns TRUE if one was found and
//       returns the index
//-----------------------------------------------------------------------------
BOOL CMusicManager::FindFreePacket( DWORD * pdwPacket, DWORD dwStream )
{
    for( DWORD dwIndex = dwStream; dwIndex < PACKET_COUNT; dwIndex += 2 )
    {
        // The first EXTRA_PACKETS * 2 packets are reserved - odd packets
        // for stream 1, even packets for stream 2.  This is to ensure
        // that there are packets available during the crossfade
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[ dwIndex ] &&
            ( dwIndex > EXTRA_PACKETS * 2 || dwIndex % 2 == dwStream ) )
        {
            if( pdwPacket )
                *pdwPacket = dwIndex;
            return TRUE;
        }
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: ProcessSource
// Desc: Fills audio packets from the decoder XMO
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::ProcessSource( DWORD dwPacket, XMEDIAPACKET * pxmp )
{
    HRESULT      hr;
    DWORD        dwBytesDecoded;

    // Set up the XMEDIAPACKET structure
    ZeroMemory( pxmp, sizeof( XMEDIAPACKET ) );
    pxmp->pvBuffer          = m_pbSampleData + dwPacket * PACKET_SIZE;
    pxmp->dwMaxSize         = PACKET_SIZE;
    pxmp->pdwCompletedSize  = &dwBytesDecoded;

    hr = m_pDecoder->Process( NULL, pxmp );
    if( FAILED( hr ) )
        return hr;

    if( 0 == dwBytesDecoded )
    {
        // We hit the end of the current track.  Key the fade-out
        m_pStream[ m_dwStream ]->Discontinuity();
        m_pStream[ m_dwStream ]->FlushEx( 0, DSSTREAMFLUSHEX_ASYNC | DSSTREAMFLUSHEX_ENVELOPE );

        // Clean up resources from this song, and get
        // ready for the next one:
        Cleanup();
        FindNextSong();
        m_dwStream = ( m_dwStream + 1 ) % 2;
        Prepare();

    }
    pxmp->dwMaxSize = dwBytesDecoded;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: ProcessStream
// Desc: Submits audio packets to the appropriate stream
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::ProcessStream( DWORD dwPacket, XMEDIAPACKET * pxmp )
{
    HRESULT      hr;

    // The XMEDIAPACKET should already have been filled out
    // by the call to ProcessSource().  In addition, ProcessSource()
    // should have properly set the dwMaxSize member to reflect
    // how much data was decoded.
    pxmp->pdwStatus = &m_adwPacketStatus[ dwPacket ];
    pxmp->pdwCompletedSize = NULL;
    pxmp->pContext = (LPVOID)m_dwStream;

    hr = m_pStream[ m_dwStream ]->Process( pxmp, NULL );
    if( FAILED( hr ) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: MusicManagerDoWork
// Desc: Workhorse function for the CMusicManager class.  Either called by
//       the MusicManager's threadproc, or manually by a game worker thread
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::MusicManagerDoWork()
{
    Process();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: MusicManagerThreadProc
// Desc: Thread procedure on which the music manager decodes
//-----------------------------------------------------------------------------
DWORD WINAPI MusicManagerThreadProc( LPVOID lpParameter )
{
    CMusicManager * pThis = (CMusicManager *)lpParameter;
    DWORD dwResult;

    //
    // Our thread procedure basically just loops indefinitely,
    // processing packets and switching between songs as 
    // appropriate, until we're signalled to shutdown.
    //
    do
    {
        pThis->MusicManagerDoWork();
        dwResult = WaitForSingleObject( pThis->m_hShutdownEvent, 1000 / 60 );
    } while( dwResult == WAIT_TIMEOUT );

    // Since we created the decoder on this thread, we'll
    // release it on this thread.
    pThis->Cleanup();

    return 0;
}



//-----------------------------------------------------------------------------
// Name: StreamCallback
// Desc: Called back on completion of stream packets.  The stream context
//       contains a pointer to the CMusicManager object, and the packet
//       context contains the stream number
//-----------------------------------------------------------------------------
void CALLBACK 
StreamCallback( LPVOID pStreamContext, LPVOID pPacketContext, DWORD dwStatus )
{
    CMusicManager * pThis = (CMusicManager *)pStreamContext;

    if( DWORD(pPacketContext) == pThis->m_dwStream &&
        dwStatus == XMEDIAPACKET_STATUS_SUCCESS )
        ++pThis->m_dwPacketsCompleted;
}




#if _DEBUG
//-----------------------------------------------------------------------------
// Name: DebugVerify
// Desc: Debug routine to verify that everything is properly set up:
//       * Must have at least 1 game soundtrack, since a game can't depend
//         on there being user soundtracks on the Xbox hard drive
//       * Check that we can open all soundtrack songs
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::DebugVerify()
{
    // Make sure we have at least 1 game soundtrack
    if( !m_aSoundtracks[ 0 ].m_fGameSoundtrack )
    {
        OUTPUT_DEBUG_STRING( "Must have at least 1 game soundtrack.\n" );
        return E_FAIL;
    }

    // Verify we can open all soundtrack files.  This could take a while.
    for( UINT uSoundtrack = 0; uSoundtrack < m_uSoundtrackCount; uSoundtrack++ )
    {
        for( UINT uSong = 0; uSong < m_aSoundtracks[ uSoundtrack ].GetSongCount(); uSong++ )
        {
            DWORD dwSongID;
            DWORD dwSongLength;
            WCHAR szSongName[ MAX_SONG_NAME ];

            m_aSoundtracks[ uSoundtrack ].GetSongInfo( uSong, &dwSongID, &dwSongLength, szSongName );
            HANDLE h = m_aSoundtracks[ uSoundtrack ].OpenSong( dwSongID );
            if( INVALID_HANDLE_VALUE == h )
            {
                OUTPUT_DEBUG_STRING( "Failed to open a soundtrack file.\n" );
                return E_FAIL;
            }
            CloseHandle( h );
        }
    }

    return S_OK;
}
#endif // _DEBUG




//
// CSoundtrack functions
//



//-----------------------------------------------------------------------------
// Name: GetSongInfo
// Desc: Returns information about the given song
//-----------------------------------------------------------------------------
void
CSoundtrack::GetSongInfo( UINT uSongIndex, DWORD * pdwID, DWORD * pdwLength, WCHAR szName[MAX_SONG_NAME] )
{
    if( m_fGameSoundtrack )
    {
        *pdwID = uSongIndex;
        *pdwLength = g_aGameSoundtrack[ uSongIndex ].dwLength;
        wcscpy( szName, g_aGameSoundtrack[ uSongIndex ].szName );
    }
    else
    {
        XGetSoundtrackSongInfo( m_uSoundtrackID, uSongIndex, pdwID, pdwLength, szName, MAX_SONG_NAME );
    }
}



//-----------------------------------------------------------------------------
// Name: OpenSong
// Desc: Opens the song with the given ID and returns a handle to the file
//-----------------------------------------------------------------------------
HANDLE
CSoundtrack::OpenSong( DWORD dwSongID )
{
    if( m_fGameSoundtrack )
        return CreateFile( g_aGameSoundtrack[ dwSongID ].szFilename, 
                           GENERIC_READ, 
                           FILE_SHARE_READ, 
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );
    else
        return XOpenSoundtrackSong( dwSongID, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\DM3DScript.cpp ===
//-----------------------------------------------------------------------------
// File: DM3DScript.cpp
//
// Desc: This sample demonstrates how to use the 3D capabilities of 
//       DirectMusic, moving a sound source and listener in 3D.
//
// Hist: 5.14.01 - New for June XDK Release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include <dsound.h>
#include <dmusici.h>
#include <dsstdfx.h>
#include "myfactory.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle Headphones" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
};

#define NUM_HELP_CALLOUTS 9



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    LPDIRECTSOUND8              m_pDSound;          // DirectSound object
    IDirectMusicLoader8 *       m_pLoader;          // DM Loader
    IDirectMusicPerformance8 *  m_pPerformance;     // DM Performance
    IDirectMusicAudioPath8 *    m_pAudioPath;       // DM AudioPath
    IDirectMusicScript8 *       m_pScript;          // DM Script
    LONG                        m_lVolume;          // Current volume
    BOOL                        m_bHeadphones;      // True if headphones enabled

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_bHeadphones = FALSE;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;

    // Positions
    m_vSourcePosition    = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound object
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();

    // Create DirectMusic loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pLoader );

    // Create DirectMusic performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pPerformance );

    // Initialize the performance with a 3D audio path.
    m_pPerformance->InitAudioX( DMUS_APATH_DYNAMIC_3D, 64, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );

    // Get 3D audiopath.
    m_pPerformance->GetDefaultAudioPath( &m_pAudioPath );

    // Max volume for music
    m_pAudioPath->SetVolume( m_lVolume, 0 );

    if( FAILED( m_pLoader->LoadObjectFromFile( CLSID_DirectMusicScript, IID_IDirectMusicScript8, "dm3dscript.spt", (VOID **)&m_pScript ) ) )
        return E_FAIL;

    m_pScript->Init( m_pPerformance, NULL );
    m_pScript->CallRoutine( "Initialize", NULL );
    m_pScript->CallRoutine( "PlaySound", NULL );

    //
    // Set the transform matrices
    //

    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    //
    // Create our vertex buffers
    //
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();


    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX *     pVertices;
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_pScript->CallRoutine( "TogglePlayback", NULL );
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_pScript->CallRoutine( "NextSegment", NULL );
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    // Toggle headphones
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_bHeadphones = !m_bHeadphones;
        m_pDSound->EnableHeadphones( m_bHeadphones );
    }


    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    //
    // Move selected object and clamp to the appropriate range
    //
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    //
    // Update source/listener vertex buffers
    //
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cSource;
    pVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cSource;
    pVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cSource;
    pVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cSource;
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cListener;
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cListener;
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cListener;
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cListener;
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pAudioPath->SetVolume( m_lVolume, 0 );
    //
    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    // We scale the velocities by 2 so that doppler effect
    // is a bit more noticable.
    //
    LPDIRECTSOUNDBUFFER8 pBuffer;
    D3DXVECTOR3 vListenerVelocity = 2.0f * ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = 2.0f * ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;


    // Get the 3D DirectSoundBuffer
    m_pAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, 0, GUID_NULL, 0, GUID_NULL, (VOID **)&pBuffer );

    // Source position/velocity/volume
    pBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    pBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );

    // Release the buffer
    pBuffer->Release();

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the source
    m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        static char * pszSegment = NULL;
        static LONG   lAllocated = 0;
        WCHAR szBuff[200];

		m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"DM3DScript" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Ask the script if a segment is playing
        LONG lPlaying;
        m_pScript->GetVariableNumber( "Playing", &lPlaying, NULL );

        // Ask the script which segment is selected:
        // First, find out how long the string is
        LONG lNeeded;
        m_pScript->GetVariableString( "SegmentName", NULL, 0, &lNeeded, NULL );

        // Then make sure we have enough space and get the value
        if( lNeeded > lAllocated )
        {
            delete[] pszSegment;
            pszSegment = new char[lNeeded];
            lAllocated = lNeeded;
        }
        m_pScript->GetVariableString( "SegmentName", pszSegment, lNeeded, &lNeeded, NULL );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", pszSegment );
        m_Font.DrawText( 64, 100, lPlaying ? 0xFFFFFFFF : 0xFF808080, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
        if( m_bHeadphones )
            m_Font.DrawText( 64, 220, 0xFFFFFF00, L"Headphones enabled");
        else
            m_Font.DrawText( 64, 220, 0x80808000, L"Headphones disabled");

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DM3DScript\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectSoundWave)
    {
        // Wave: represents the file version of a wave - required if wave files are used.
        hr = DirectSoundWaveCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSegment)
    {
        // Segment Automation: used by scripting to control a segment.
        hr = DirectMusicAutSegmentCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        // Container: storage container for multiple DirectMusic file objects. Always used in scripting.
        hr = DirectMusicContainerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicWaveTrack)
    {
        // Wave Track - plays one or more waves.
        hr = DirectMusicWaveTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        // Time Signature Track - defines time signature in segments, always required for music synchronization.
        hr = DirectMusicTimeSigTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicAudioPathConfig)
    {
        // Audio Path Configuration Automation - used by scripting to control an audiopath configuration.
        hr = DirectMusicAutAudioPathConfigCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSong)
    {
        // Song Automation - used by scripting to control a song.
        hr = DirectMusicAutSongCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSegmentState)
    {
        // A helper scripting object that implements IDispatch.
        hr = AutDirectMusicSegmentStateCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicPerformance)
    {
        // Performance Automation - used by scripting to control a performance.
        hr = DirectMusicAutPerformanceCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicAudioPath)
    {
        // Audio Path Automation - used by scripting to control a style directly.
        hr = DirectMusicAutAudioPathCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicScript)
    {
        // Script: Manages a script and all embedded and linked content.
        hr = DirectMusicScriptCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\DMAudioPath.cpp ===
//-----------------------------------------------------------------------------
// File: DMAudioPath.cpp
//
// Desc: This sample demonstrates how to use the 3D capabilities of 
//       DirectMusic, moving a sound source and listener in 3D.
//
// Hist: 05.14.01 - New for June XDK Release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include <dsound.h>
#include <dmusici.h>
#include <dsstdfx.h>
#include "myfactory.h"


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle Headphones" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
};

#define NUM_HELP_CALLOUTS 9




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\heli.wav",
    "D:\\Media\\Sounds\\DockingMono.wav",
    "D:\\Media\\Sounds\\EngineStartMono.wav",
    "D:\\Media\\Sounds\\MaleDialog1.wav",
    "D:\\Media\\Sounds\\MiningMono.wav",
    "D:\\Media\\Sounds\\MusicMono.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
};

#define NUM_SOUNDS 7




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    LPDIRECTSOUND8              m_pDSound;          // DirectSound object
    IDirectMusicLoader8 *       m_pLoader;          // DM Loader
    IDirectMusicPerformance8 *  m_pPerformance;     // DM Performance
    IDirectMusicSegment8 *      m_pSegment;         // DM Segment
    IDirectMusicAudioPath8 *    m_pAudioPath;       // DM AudioPath
    DWORD                       m_dwCurrent;        // Current segment
    BOOL                        m_bPlaying;         // Are we playing?
    LONG                        m_lVolume;          // Current volume
    BOOL                        m_bHeadphones;      // True if headphones enabled

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;
    m_bHeadphones       = FALSE;

    // Sounds
    m_dwCurrent         = 0;
    m_lVolume           = DSBVOLUME_MAX;
    m_pSegment          = NULL;
    m_bControlSource    = TRUE;

    // Positions
    m_vSourcePosition   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound object
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();


    // Create DirectMusic loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pLoader );

    // Create DirectMusic performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pPerformance );

    // Initialize the performance with a 3D audio path.
    m_pPerformance->InitAudioX( DMUS_APATH_DYNAMIC_3D, 64, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );

    // Get 3D audiopath.
    m_pPerformance->GetDefaultAudioPath( &m_pAudioPath );

    // Max volume for music
    m_pAudioPath->SetVolume( m_lVolume, 0 );

    m_bPlaying = TRUE;
    SwitchToSound( 0 );

    //
    // Set the transform matrices
    //

    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    //
    // Create our vertex buffers
    //
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();


    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Release the current segment
//       3) Load a new segment
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    // If we're currently playing, stop
    if( m_bPlaying )
        m_pPerformance->StopEx( m_pSegment, 0, 0 );

    // Release the current sound
    if( m_pSegment )
    {
        m_pSegment->Release();
        m_pSegment = NULL;
    }

    m_dwCurrent = dwIndex;

    // Load the new sound
    m_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8,
                                   g_aszFileNames[dwIndex], (VOID **)&m_pSegment );
    m_pSegment->SetRepeats( DMUS_SEG_REPEAT_INFINITE );

    // If we were playing before, restart playback now
    if( m_bPlaying )
        m_pPerformance->PlaySegmentEx( m_pSegment, NULL, NULL, 0, 
                                       0, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX *     pVertices;
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pPerformance->StopEx( m_pSegment, 0, 0 );
        else
            m_pPerformance->PlaySegmentEx( m_pSegment, NULL, NULL, 0, 
                                           0, NULL, NULL, NULL );

        m_bPlaying = !m_bPlaying;
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        SwitchToSound( ( m_dwCurrent + 1 ) % NUM_SOUNDS );
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    // Toggle headphones
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_bHeadphones = !m_bHeadphones;
        m_pDSound->EnableHeadphones( m_bHeadphones );
    }

    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    //
    // Move selected object and clamp to the appropriate range
    //
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    //
    // Update source/listener vertex buffers
    //
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cSource;
    pVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cSource;
    pVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cSource;
    pVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cSource;
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cListener;
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cListener;
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cListener;
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cListener;
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pAudioPath->SetVolume( m_lVolume, 0 );
    //
    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    // We scale the velocities by 2 so that doppler effect
    // is a bit more noticable.
    //
    LPDIRECTSOUNDBUFFER8 pBuffer;
    D3DXVECTOR3 vListenerVelocity = 2.0f * ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = 2.0f * ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;


    // Get the 3D DirectSoundBuffer
    m_pAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, 0, GUID_NULL, 0, GUID_NULL, (VOID **)&pBuffer );

    // Source position/velocity/volume
    pBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    pBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );

    // Release the buffer
    pBuffer->Release();

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the source
    m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

        m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"DMAudioPath" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF404040, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
        if( m_bHeadphones )
            m_Font.DrawText( 64, 220, 0xFFFFFF00, L"Headphones enabled");
        else
            m_Font.DrawText( 64, 220, 0x80808000, L"Headphones disabled");

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMAudioPath\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectMusicWaveTrack)
    {
        // Wave Track - plays one or more waves.
        hr = DirectMusicWaveTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectSoundWave)
    {
        // Wave: represents the file version of a wave - required if wave files are used.
        hr = DirectSoundWaveCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\DMGrooveLevel.cpp ===
//-----------------------------------------------------------------------------
// File: DMGrooveLevel.cpp
//
// Desc: Simple app to play some sounds using DirectMusic.
//
// Hist: 01.12.00 - New for February XDK release
//       02.16.01 - Renamed from DMApp for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBUtil.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <dmusici.h>
#include <dsstdfx.h>
#include "myfactory.h"



//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Adjust\nvolume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Adjust groove\nlevel" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Sound Effect #1" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Sound Effect #2" },
};

#define NUM_HELP_CALLOUTS 5



//-----------------------------------------------------------------------------
// Global DirectMusic variables
//-----------------------------------------------------------------------------
IDirectMusicLoader8*      g_pLoader         = NULL;
IDirectMusicPerformance8* g_pPerformance    = NULL;
IDirectMusicSegment8*     g_pMusic          = NULL;
IDirectMusicSegment8*     g_pFastMusic      = NULL;
IDirectMusicSegment8*     g_pSound1         = NULL;
IDirectMusicSegment8*     g_pSound2         = NULL;
IDirectMusicAudioPath8*   g_p3DAudioPath1   = NULL;
IDirectMusicAudioPath8*   g_pMusicAudioPath = NULL;




//-----------------------------------------------------------------------------
// Name: InitDirectMusic
// Desc: Init DM
//-----------------------------------------------------------------------------
HRESULT InitDirectMusic() 
{
    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();


    // Create loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&g_pLoader );

    // Create performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&g_pPerformance );

    // Initialize the performance with the standard audio path.
    // The flags (final) argument allows us to specify whether or not we want
    // DirectMusic to create a thread on our behalf to process music, using 
    // DMUS_INITAUDIO_NOTHREADS.  The default is for DirectMusic to create its
    // own thread; DMUS_INITAUDIO_NOTHREADS tells DirectMusic not to do this, 
    // and the app will periodically call DirectMusicDoWork().  For software 
    // emulation on alpha hardware, it's generally better to have DirectMusic
    // create its own thread. On real hardware, periodically calling 
    // DirectMusicDoWork may provide a better option.
    g_pPerformance->InitAudioX( DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, 128, 0 );

    // Tell DirectMusic where the default search path is
    g_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );
    
    // Load main music
    g_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                   "xdk1.sgt", (VOID**)&g_pMusic );

    // Load a sound effect
    g_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                   "xdk1.wav", (VOID**)&g_pSound1 );

    // load another sound effect
    g_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                   "xdk2.wav", (VOID**)&g_pSound2 );

    // Set the music to repeat for a while...
    g_pMusic->SetRepeats( 100 );
    
    // Play segment on the default audio path
    g_pPerformance->PlaySegmentEx( g_pMusic, NULL, NULL, 0, 
                                   0, NULL, NULL, NULL );

    // Get default (music) audiopath.
    g_pPerformance->GetDefaultAudioPath( &g_pMusicAudioPath );

    // Max volume for music
    g_pMusicAudioPath->SetVolume( (100*100)-10000, 0 );

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    // Create a 3D audiopath
    g_pPerformance->CreateStandardAudioPath( DMUS_APATH_DYNAMIC_3D, 64,
                                             TRUE, &g_p3DAudioPath1 );

    // Now DirectMusic will play in the background, so continue on with our task
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PlaySound()
// Desc: Play sound on a single audiopath
//-----------------------------------------------------------------------------
HRESULT PlaySound( IDirectMusicSegment8* pSound )
{
    g_pPerformance->PlaySegmentEx( pSound, NULL, NULL, DMUS_SEGF_SECONDARY, 
                                   0, NULL, NULL, g_p3DAudioPath1 );
        
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetVolume()
// Desc: Set volume on the main music audipath
// Note: The argument to IDirectMusicAudioPath::SetVolume is attenuation in
//       hundredths of a dB.  Attenuation more than 60dB is silent, so
//       that's our effective minimum.  
//-----------------------------------------------------------------------------
HRESULT SetVolume( LONG lVolume )
{
    // Change range from [0,100] to [-6000,0]
    lVolume = lVolume * 60 - 6000;

    g_pMusicAudioPath->SetVolume( lVolume, 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetGrooveLevel()
// Desc: Change the groove level of the performance
//-----------------------------------------------------------------------------
HRESULT SetGrooveLevel( INT dwGrooveLevel )
{
    CHAR chGrooveLevel = (CHAR)dwGrooveLevel;
    g_pPerformance->SetGlobalParam( GUID_PerfMasterGrooveLevel, 
                                    &chGrooveLevel, sizeof(CHAR) );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont           m_Font;         // Font object
    CXBHelp           m_Help;         // Help object
    BOOL              m_bDrawHelp;    // Should we draw help?

    FLOAT             m_fGrooveLevel;
    FLOAT             m_fVolume;
    LPDIRECTSOUND8    m_pDSound;      // DSound object

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application class constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
{
    m_fGrooveLevel =  50.0f;
    m_fVolume      = 100.0f;        
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    if( FAILED( InitDirectMusic() ) )
        return E_FAIL;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED(DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
		return E_FAIL;

    DownloadEffectsImage("d:\\media\\dsstdfx.bin");

    m_bDrawHelp = FALSE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 || pGamePad->fY1 || pGamePad->fX2 || pGamePad->fX2  )
        return TRUE;

    // Nothing active
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    const XBGAMEPAD* pGamepad = GetPrimaryController();
    if( pGamepad == NULL )
        return S_OK;

    // Toggle help
    if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Adjust volume
    m_fVolume += pGamepad->fY1 * m_fElapsedTime * 100.0f;
    if( m_fVolume <   1.0f )   m_fVolume =   1.0f;
    if( m_fVolume > 100.0f )   m_fVolume = 100.0f;
    SetVolume( (INT)m_fVolume);

    // Adjust sound
    m_fGrooveLevel += pGamepad->fY2 * m_fElapsedTime * 100.0f;
    if( m_fGrooveLevel <   1.0f )   m_fGrooveLevel =   1.0f;
    if( m_fGrooveLevel > 100.0f )   m_fGrooveLevel = 100.0f;
    SetGrooveLevel( (INT)(m_fGrooveLevel - 50) );

    // Play sound based on button pressed
    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) 
        PlaySound( g_pSound1 );

    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] ) 
        PlaySound( g_pSound2 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.DrawText(  64, 50, 0xffffffff, L"DMGrooveLevel" );
        m_Font.DrawText( 64, 150, 0xffffff00, L"Volume:" );
        {
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            FLOAT x1 = 200, x2 = x1 + (340*m_fVolume)/100;
            FLOAT y1 = 150, y2 = y1 + 20;
            v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
            v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
            v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffff0000;
            v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffff0000;

            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
        }

        m_Font.DrawText( 64, 200, 0xffffff00, L"Groove Level:" );
        {
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            FLOAT x1 = 200, x2 = x1 + (340*m_fGrooveLevel)/100;
            FLOAT y1 = 200, y2 = y1 + 20;
            v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
            v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
            v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xff00ff00;
            v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xff00ff00;

            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectMusicWaveTrack)
    {
        // Wave Track - plays one or more waves.
        hr = DirectMusicWaveTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectSoundWave)
    {
        // Wave: represents the file version of a wave - required if wave files are used.
        hr = DirectSoundWaveCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMGrooveLevel\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyle)
    {
        // Style - style playback object, represents a specific style type.
        hr = DirectMusicStyleCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicWaveTrack)
    {
        // Wave Track - plays one or more waves.
        hr = DirectMusicWaveTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectSoundWave)
    {
        // Wave: represents the file version of a wave - required if wave files are used.
        hr = DirectSoundWaveCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBandTrack)
    {
        // Band Track - manages one or more bands - always required for any MIDI + DLS playback.
        hr = DirectMusicBandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyleTrack)
    {
        // Style Track - selects style for playback.
        hr = DirectMusicStyleTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        // Tempo Track - defines tempo changes, always required for music.
        hr = DirectMusicTempoTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBand)
    {
        // Band - manages downloading of DLS instruments as well as volume and pan presets - always required for MIDI + DLS.
        hr = DirectMusicBandCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        // Container: storage container for multiple DirectMusic file objects. Always used in scripting.
        hr = DirectMusicContainerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\DMNotifications.cpp ===
//-----------------------------------------------------------------------------
// File: DMNotifications.cpp
//
// Desc: Demonstrates how to use DirectMusic Notification messages to get
//       information about audio playback.
//
// Hist: 04.06.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <dmusici.h>
#include "dsstdfx.h"
#include "myfactory.h"



//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nplayback" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Select\nsegment" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Play control" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase\nvolume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease\nvolume" },
};

#define NUM_HELP_CALLOUTS 6

DMUS_SEGF_FLAGS g_adsf[] = 
{
    DMUS_SEGF_FLAGS(0),
    DMUS_SEGF_GRID,
    DMUS_SEGF_BEAT,
    DMUS_SEGF_MEASURE,
};
static const DWORD NUM_FLAGS = sizeof( g_adsf ) / sizeof( g_adsf[0] );

WCHAR * g_szWhen[] = 
{
    L"Immediately",
    L"Grid Boundary",
    L"Beat Boundary",
    L"Measure Boundary",
};

char * g_szSegments[] = 
{
    "Bach Invention.sgt", 
    "ClaireDeLune.sgt", 
    "BrassAction.sgt",  
    "FurElise.sgt",
};
static const DWORD NUM_SEGMENTS = sizeof( g_szSegments ) / sizeof( g_szSegments[0] );

typedef struct {
    DWORD                       dwSegment;
    IDirectMusicSegment8 *      pSegment;
    IDirectMusicSegmentState8 * pSegState;
    BOOL                        bPlaying;
} PLAYSTATE;


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT LoadSegment( PLAYSTATE * ps, DWORD dwSegment );

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL        m_bDrawHelp;

    DWORD       m_dwBoundary;   // Current Boundary
    DWORD       m_dwCurrent;
    LONG        m_lVolume;

    FLOAT       m_fBeat;
    WCHAR       m_szSegment[100];
    
    PLAYSTATE   m_aStates[2];

    IDirectMusicPerformance8 *     m_pDMPerformance;
    IDirectMusicLoader8 *          m_pDMLoader;
    IDirectMusicAudioPath8 *       m_pMusicAudioPath;
    IDirectMusicGraph8 *           m_pDMGraph;
    LPDIRECTSOUND8                 m_pDSound;           // DirectSound object

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile); // downloads a default DSP image to the GP
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    ZeroMemory( m_aStates, sizeof( PLAYSTATE ) * 2 );
    m_dwBoundary = 0;
    m_dwCurrent  = 0;
    m_bDrawHelp = FALSE;
    m_szSegment[0] = 0;
}



//-----------------------------------------------------------------------------
// Name: LoadSegment
// Desc: Transitions the playstate to a different segment.  Stops playback
//       if it's currently playing, releases current segment, loads and 
//       downloads new segment, and restarts playback if needed.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::LoadSegment( PLAYSTATE * ps, DWORD dwSegment )
{
    // Shut down the current segment
    if( ps->bPlaying )
    {
        m_pDMPerformance->StopEx( ps->pSegState, 0, 0 );
        ps->pSegState->Release();
        ps->pSegState = NULL;
    }

    if( ps->pSegment )
    {
        ps->pSegment->Release();
        ps->pSegment = NULL;
    }

    if( FAILED( m_pDMLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, 
                                                 IID_IDirectMusicSegment8,
                                                 g_szSegments[ dwSegment ], 
                                                 (VOID **)&ps->pSegment ) ) )
        return E_FAIL;

    ps->dwSegment = dwSegment;
    if( ps->bPlaying )
    {
        m_pDMPerformance->PlaySegmentEx( ps->pSegment, 
                                         NULL, 
                                         NULL, 
                                         0, 
                                         0, 
                                         &ps->pSegState, 
                                         NULL, 
                                         NULL );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();

    // Create loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pDMLoader );

    // Create performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pDMPerformance );

    // Initialize the performance with the standard audio path.
    // The flags (final) argument allows us to specify whether or not we want
    // DirectMusic to create a thread on our behalf to process music, using 
    // DMUS_INITAUDIO_NOTHREADS.  The default is for DirectMusic to create its
    // own thread; DMUS_INITAUDIO_NOTHREADS tells DirectMusic not to do this, 
    // and the app will periodically call DirectMusicDoWork().  For software 
    // emulation on alpha hardware, it's generally better to have DirectMusic
    // create its own thread. On real hardware, periodically calling 
    // DirectMusicDoWork may provide a better option.
    m_pDMPerformance->InitAudioX( DMUS_APATH_SHARED_STEREOPLUSREVERB, 96, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pDMLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );
    
    // Load primary segment
    m_pDMLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                   g_szSegments[0], (VOID**)&m_aStates[0].pSegment);
    // Load secondary segment
    m_pDMLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                   g_szSegments[0], (VOID**)&m_aStates[1].pSegment );

    // Play segment on the default audio path
    m_pDMPerformance->PlaySegmentEx( m_aStates[0].pSegment, NULL, NULL, 0, 
                                   0, &m_aStates[0].pSegState, NULL, NULL );
    m_aStates[0].bPlaying = TRUE;

    // Get default (music) audiopath.
    m_pDMPerformance->GetDefaultAudioPath( &m_pMusicAudioPath );

    // Max volume for music
    m_lVolume = DSBVOLUME_MAX;
    m_pMusicAudioPath->SetVolume( m_lVolume, 0 );

    // Set up to receive the notifications we're interested in
    GUID guid = GUID_NOTIFICATION_SEGMENT;
    m_pDMPerformance->AddNotificationType( guid );
    guid = GUID_NOTIFICATION_MEASUREANDBEAT;
    m_pDMPerformance->AddNotificationType( guid );

    return S_OK;
}

#define VOLUME_SCALE 5.0f
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    DMUS_NOTIFICATION_PMSG * pPMsg;
    PLAYSTATE * ps = &m_aStates[ m_dwCurrent ];

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle playback
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( ps->bPlaying )
        {
            m_pDMPerformance->StopEx( ps->pSegState, 0, g_adsf[ m_dwBoundary ] );
        }
        else
        {
            DWORD dwFlags = ( m_dwCurrent == 0 ) ? 0 : DMUS_SEGF_SECONDARY;

            m_pDMPerformance->PlaySegmentEx( ps->pSegment, 
                                             NULL, 
                                             NULL, 
                                             g_adsf[ m_dwBoundary ] | dwFlags, 
                                             0, 
                                             &ps->pSegState, 
                                             NULL, 
                                             NULL );
            if( m_dwCurrent != 0 && g_adsf[ m_dwBoundary ] != 0 )
                swprintf( m_szSegment, L"Secondary Segment Pending" );
        }
        if( m_dwCurrent == 0 )
            ps->bPlaying ^= 1;
    }

    // Select segment
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        LoadSegment( ps, ( ps->dwSegment + 1 ) % NUM_SEGMENTS );
    }

    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        m_dwBoundary = ( m_dwBoundary + NUM_FLAGS - 1 ) % NUM_FLAGS;
    }
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        m_dwBoundary = ( m_dwBoundary + 1 ) % NUM_FLAGS;
    }
    if( m_DefaultGamepad.wPressedButtons & ( XINPUT_GAMEPAD_DPAD_LEFT | XINPUT_GAMEPAD_DPAD_RIGHT ) )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % 2;
    }


    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < -6000 )
        m_lVolume = -6000;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;
    m_pMusicAudioPath->SetVolume( m_lVolume, 0 );

    m_fBeat -= 0.1f;
    if( m_fBeat < 0.0f )
        m_fBeat = 0.0f;

    // Here's where we look at this shiznit
    while( S_OK == m_pDMPerformance->GetNotificationPMsg( &pPMsg ) )
    {
        IDirectMusicSegmentState8 * pSegState = NULL;

        if( SUCCEEDED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pSegState ) ) )

        //
        // We're interested in segment notifications on the secondary 
        // segment, and beat notifications on the primary segment
        //
        if( pPMsg->guidNotificationType == GUID_NOTIFICATION_SEGMENT )
        {
            if( pSegState == m_aStates[1].pSegState )
            {
                // Yeah baby
                switch( pPMsg->dwNotificationOption )
                {
                case DMUS_NOTIFICATION_SEGABORT:
                    swprintf( m_szSegment, L"Secondary Segment Aborted" );
                    m_aStates[1].bPlaying = FALSE;
                    break;
                case DMUS_NOTIFICATION_SEGALMOSTEND:
                    swprintf( m_szSegment, L"Secondary Segment almost at end" );
                    break;
                case DMUS_NOTIFICATION_SEGLOOP:
                    swprintf( m_szSegment, L"Secondary Segment has looped" );
                    break;
                case DMUS_NOTIFICATION_SEGSTART:
                    swprintf( m_szSegment, L"Secondary Segment Playing" );
                    m_aStates[1].bPlaying = TRUE;
                    break;
                case DMUS_NOTIFICATION_SEGEND:
                    swprintf( m_szSegment, L"Secondary Segment Completed" );
                    m_aStates[1].bPlaying = FALSE;
                    break;
                }
            }
            else if( pSegState == m_aStates[0].pSegState && 
                     pPMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGEND )
            {
                m_pDMPerformance->PlaySegmentEx( m_aStates[0].pSegment, NULL, NULL, 0, 
                                                 0, &m_aStates[0].pSegState, NULL, NULL );
            }
        }
        else if( pSegState == m_aStates[0].pSegState &&
                 pPMsg->guidNotificationType == GUID_NOTIFICATION_MEASUREANDBEAT )
        {
            m_fBeat = 1.0;
        }

        m_pDMPerformance->FreePMsg( (DMUS_PMSG*)pPMsg );
    }


    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff408040, 0xff404040 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR sz[100];

		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"DMNotifications" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        swprintf( sz, L"Controlling %s segment: %S", m_dwCurrent ? L"secondary" : L"primary", 
                                                     g_szSegments[ m_aStates[ m_dwCurrent ].dwSegment ] );
        m_Font.DrawText(  64, 80, m_aStates[ m_dwCurrent ].bPlaying ? 0xffffffff : 0xFF808080, sz );
        m_Font.DrawText(  64, 110, 0xffffffff, L"Boundary:" );
        m_Font.DrawText( 200, 110, 0xffffffff, g_szWhen[ m_dwBoundary ] );
        m_Font.DrawText( 200, 200, 0x00FFFFFF | DWORD( m_fBeat * 255 ) << 24, L"Primary Beat" );
        m_Font.DrawText( 200, 240, 0xFFFFFFFF, m_szSegment );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMMultiPass\DMMultiPass.cpp ===
//-----------------------------------------------------------------------------
// File: DMMultiPass.cpp
//
// Desc: This sample demonstrates how to use the multipass capabilities of 
//       DirectMusic, by playing several different segments at once on a 3D
//       audiopath moving a sound source and listener in 3D.
//
// Hist: 5.14.01 - New for June XDK Release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include <dsound.h>
#include <dmusici.h>
#include <dsstdfx.h>
#include "myfactory.h"


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle looping\n(Not when playing)" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_2, L"Toggle Headphones" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
};

#define NUM_HELP_CALLOUTS 10



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\heli.wav",
    "D:\\Media\\Sounds\\DockingMono.wav",
    "D:\\Media\\Sounds\\EngineStartMono.wav",
    "D:\\Media\\Sounds\\MaleDialog1.wav",
    "D:\\Media\\Sounds\\MiningMono.wav",
    "D:\\Media\\Sounds\\MusicMono.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
};

#define NUM_SOUNDS 7


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    LPDIRECTSOUND8              m_pDSound;          // DirectSound object
    IDirectMusicLoader8 *       m_pLoader;          // DM Loader
    IDirectMusicPerformance8 *  m_pPerformance;     // DM Performance
    IDirectMusicSegment8 *      m_apSegments[NUM_SOUNDS];   // DM Segments
    IDirectMusicSegmentState8 * m_apSegStates[NUM_SOUNDS];  // DM Segment states
    IDirectMusicAudioPath8 *    m_pAudioPath;       // DM AudioPath
    DWORD                       m_dwCurrent;        // Current segment
    BOOL                        m_bPlaying[NUM_SOUNDS];     // Are we playing?
    LONG                        m_lVolume[NUM_SOUNDS];      // Current volume
    BOOL                        m_bLooping[NUM_SOUNDS];     // Looping?
    BOOL                        m_bHeadphones;              // True if headphones enabled

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_bHeadphones = FALSE;

    // Sounds
    m_dwCurrent = 0;

    // Positions
    m_vSourcePosition    = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound object
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();


    // Create DirectMusic loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pLoader );

    // Create DirectMusic performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pPerformance );

    // Initialize the performance with a 3D audio path.
    m_pPerformance->InitAudioX( DMUS_APATH_DYNAMIC_3D, 64, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );

    // Load each of our sound effect segments
    for( i = 0; i < NUM_SOUNDS; i++ )
    {
        m_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                       g_aszFileNames[i], (VOID**)&m_apSegments[i] );
        m_apSegments[i]->SetRepeats( DMUS_SEG_REPEAT_INFINITE );
        m_bPlaying[i] = FALSE;
        m_lVolume[i] = DSBVOLUME_MAX;
        m_bLooping[i] = TRUE;
        m_apSegStates[i] = NULL;
    }

    // Register for segment notifications
    m_pPerformance->AddNotificationType( GUID_NOTIFICATION_SEGMENT );

    // Get 3D audiopath.
    m_pPerformance->GetDefaultAudioPath( &m_pAudioPath );

    // Play first segment on the 3D audio path[
    m_pPerformance->PlaySegmentEx( m_apSegments[m_dwCurrent], NULL, NULL, DMUS_SEGF_SECONDARY, 
                                   0, &m_apSegStates[m_dwCurrent], NULL, NULL );

    // Max volume for music
    m_apSegStates[m_dwCurrent]->SetVolume( m_lVolume[m_dwCurrent], 0 );

    m_bPlaying[m_dwCurrent] = TRUE;
    

    //
    // Set the transform matrices
    //

    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    //
    // Create our vertex buffers
    //
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();


    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX *     pVertices;
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );
    DMUS_NOTIFICATION_PMSG * pMsg;

    // Check for segment completions
    while( S_OK == m_pPerformance->GetNotificationPMsg( &pMsg ) )
    {
        // If a segment has ended, find it and update state
        if( pMsg->guidNotificationType == GUID_NOTIFICATION_SEGMENT &&
            pMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT ||
            pMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGEND )
        {
            for( int i = 0; i < NUM_SOUNDS; i++ )
            {
                if( pMsg->punkUser == m_apSegStates[i] )
                {
                    m_bPlaying[i] = FALSE;
                }
            }
        }
    }

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume[m_dwCurrent] += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume[m_dwCurrent] < DSBVOLUME_MIN )
        m_lVolume[m_dwCurrent] = DSBVOLUME_MIN;
    else if( m_lVolume[m_dwCurrent] > DSBVOLUME_MAX )
        m_lVolume[m_dwCurrent] = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying[m_dwCurrent] )
        {
            m_pPerformance->StopEx( m_apSegments[m_dwCurrent], 0, 0 );
            m_apSegStates[m_dwCurrent] = NULL;
        }
        else
            m_pPerformance->PlaySegmentEx( m_apSegments[m_dwCurrent], NULL, NULL, DMUS_SEGF_SECONDARY, 
                                           0, &m_apSegStates[m_dwCurrent], NULL, NULL );

        m_bPlaying[m_dwCurrent] = !m_bPlaying[m_dwCurrent];
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        DWORD dwNew = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
        m_dwCurrent = dwNew;
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    if( !m_bPlaying[m_dwCurrent] && m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_bLooping[m_dwCurrent] = !m_bLooping[m_dwCurrent];
        m_apSegments[m_dwCurrent]->SetRepeats( m_bLooping[m_dwCurrent] ? DMUS_SEG_REPEAT_INFINITE : 0 );
    }

    // Toggle headphones
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        m_bHeadphones = !m_bHeadphones;
        m_pDSound->EnableHeadphones( m_bHeadphones );
    }

    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    //
    // Move selected object and clamp to the appropriate range
    //
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    //
    // Update source/listener vertex buffers
    //
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cSource;
    pVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cSource;
    pVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cSource;
    pVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cSource;
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cListener;
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cListener;
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cListener;
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cListener;
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    if( m_bPlaying[m_dwCurrent] )
        m_apSegStates[m_dwCurrent]->SetVolume( m_lVolume[m_dwCurrent], 0 );

    //
    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    // We scale the velocities by 2 so that doppler effect
    // is a bit more noticable.
    //
    LPDIRECTSOUNDBUFFER8 pBuffer;
    D3DXVECTOR3 vListenerVelocity = 2.0f * ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = 2.0f * ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;


    // Get the 3D DirectSoundBuffer
    m_pAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, 0, GUID_NULL, 0, GUID_NULL, (VOID **)&pBuffer );

    // Source position/velocity/volume
    pBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    pBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );

    // Release the buffer
    pBuffer->Release();

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the source
    m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

		m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"DMMultiPass" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S %s", g_aszFileNames[m_dwCurrent], m_bLooping[m_dwCurrent] ? L"(Looping)" : L"" );
        m_Font.DrawText( 64, 100, m_bPlaying[m_dwCurrent] ? 0xFFFFFFFF : 0xFF404040, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume[m_dwCurrent] / 100, 100.0f * ( m_lVolume[m_dwCurrent] - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
        if( m_bHeadphones )
            m_Font.DrawText( 64, 220, 0xFFFFFF00, L"Headphones enabled");
        else
            m_Font.DrawText( 64, 220, 0x80808000, L"Headphones disabled");

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMNotifications\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBandTrack)
    {
        // Band Track - manages one or more bands - always required for any MIDI + DLS playback.
        hr = DirectMusicBandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        // Tempo Track - defines tempo changes, always required for music.
        hr = DirectMusicTempoTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyle)
    {
        // Style - style playback object, represents a specific style type.
        hr = DirectMusicStyleCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSeqTrack)
    {
        // Sequence Track: plays straight MIDI sequences.
        hr = DirectMusicSeqTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        // Time Signature Track - defines time signature in segments, always required for music synchronization.
        hr = DirectMusicTimeSigTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyleTrack)
    {
        // Style Track - selects style for playback.
        hr = DirectMusicStyleTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBand)
    {
        // Band - manages downloading of DLS instruments as well as volume and pan presets - always required for MIDI + DLS.
        hr = DirectMusicBandCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        // Container: storage container for multiple DirectMusic file objects. Always used in scripting.
        hr = DirectMusicContainerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLyricsTrack)
    {
        // Lyrics Track: sends lyrics.
        hr = DirectMusicLyricsTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectSoundWave)
    {
        // Wave: represents the file version of a wave - required if wave files are used.
        hr = DirectSoundWaveCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSegment)
    {
        // Segment Automation: used by scripting to control a segment.
        hr = DirectMusicAutSegmentCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicWaveTrack)
    {
        // Wave Track - plays one or more waves.
        hr = DirectMusicWaveTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        // Container: storage container for multiple DirectMusic file objects. Always used in scripting.
        hr = DirectMusicContainerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        // Time Signature Track - defines time signature in segments, always required for music synchronization.
        hr = DirectMusicTimeSigTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicScriptTrack)
    {
        // Script Track: Sequences script routines to play in time with the music.
        hr = DirectMusicScriptTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBandTrack)
    {
        // Band Track - manages one or more bands - always required for any MIDI + DLS playback.
        hr = DirectMusicBandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyle)
    {
        // Style - style playback object, represents a specific style type.
        hr = DirectMusicStyleCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPatternTrack)
    {
        // Pattern Track - plays patterns with variations tranposed to chord progression.
        hr = DirectMusicPatternTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        // Tempo Track - defines tempo changes, always required for music.
        hr = DirectMusicTempoTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicScript)
    {
        // Script: Manages a script and all embedded and linked content.
        hr = DirectMusicScriptCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicAudioPathConfig)
    {
        // Audio Path Configuration Automation - used by scripting to control an audiopath configuration.
        hr = DirectMusicAutAudioPathConfigCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSong)
    {
        // Song Automation - used by scripting to control a song.
        hr = DirectMusicAutSongCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSegmentState)
    {
        // A helper scripting object that implements IDispatch.
        hr = AutDirectMusicSegmentStateCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicPerformance)
    {
        // Performance Automation - used by scripting to control a performance.
        hr = DirectMusicAutPerformanceCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicAudioPath)
    {
        // Audio Path Automation - used by scripting to control a style directly.
        hr = DirectMusicAutAudioPathCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\DMTool.cpp ===
//-----------------------------------------------------------------------------
// File: DMTool.cpp
//
// Desc: Demonstrates how to use Direct Music tools to synchronize
//       audio and video
//
// Hist: 3.13.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <dmusici.h>
#include "tool.h"
#include "dsstdfx.h"
#include "myfactory.h"

typedef struct
{
    D3DXVECTOR4 p;
    D3DCOLOR    c;
} CUSTOMVERTEX;
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Start/stop" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change segment" },
};

#define NUM_HELP_CALLOUTS 3

char * g_szSegments[] =
{
    "ClaireDeLune.sgt", 
    "Bach Invention.sgt", 
    "BrassAction.sgt",  
    "FurElise.sgt",
};

#define NUM_SEGMENTS 4

// Since most of the time is taken modifying vertices and rendering them,
// we need to double buffer to avoid blocking
#define NUM_BUFFERS 2

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL            m_bDrawHelp;    // Show Help?
    BOOL            m_bPlaying;     // Is music playing?
    DWORD           m_dwCurrent;    // Current segment

    // VB to show notes being played
    LPDIRECT3DVERTEXBUFFER8        m_pVB;

    // How many quads we filled in the VB
    DWORD                          m_dwNumQuads;

    IDirectMusicPerformance8 *     m_pDMPerformance;
    IDirectMusicLoader8 *          m_pDMLoader;
    IDirectMusicSegment8 *         m_apMusic[NUM_SEGMENTS];
    IDirectMusicAudioPath8 *       m_pMusicAudioPath;
    IDirectMusicGraph8 *           m_pDMGraph;
    CDisplayTool *                 m_pDisplayTool;
    LPDIRECTSOUND8                 m_pDSound;

    // Array of last playing of each note by each channel
    DMUS_NOTE_PMSG *               m_aNotes;

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_dwCurrent = 0;
    m_aNotes = new DMUS_NOTE_PMSG[ NUM_CHANNELS * NUM_NOTES ];
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}




#define COL_WIDTH 4
#define COL_HEIGHT 4
//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();

    // Create loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pDMLoader );

    // Create performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pDMPerformance );

    // Initialize the performance with the standard audio path.
    // The flags (final) argument allows us to specify whether or not we want
    // DirectMusic to create a thread on our behalf to process music, using 
    // DMUS_INITAUDIO_NOTHREADS.  The default is for DirectMusic to create its
    // own thread; DMUS_INITAUDIO_NOTHREADS tells DirectMusic not to do this, 
    // and the app will periodically call DirectMusicDoWork().  For software 
    // emulation on alpha hardware, it's generally better to have DirectMusic
    // create its own thread. On real hardware, periodically calling 
    // DirectMusicDoWork may provide a better option.
    m_pDMPerformance->InitAudioX( DMUS_APATH_SHARED_STEREOPLUSREVERB, 96, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pDMLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );
    
    // Load segments 
    // We load all segments up front so there isn't a delay when switching 
    // between segments later on
    for( int i = 0; i < NUM_SEGMENTS; i++ )
    {
        m_pDMLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                       g_szSegments[i], (VOID**)&m_apMusic[i] );

        m_apMusic[i]->SetRepeats( DMUS_SEG_REPEAT_INFINITE );
    }
    
    // Get default (music) audiopath.
    m_pDMPerformance->GetDefaultAudioPath( &m_pMusicAudioPath );

    // Max volume for music
    m_pMusicAudioPath->SetVolume( (100*100)-10000, 0 );

    // Create a DirectMusicGraph, and tell the preformance about it
    m_pMusicAudioPath->GetObjectInPath( 0, DMUS_PATH_PERFORMANCE_GRAPH, 0,
                                           GUID_NULL, 0, IID_IDirectMusicGraph, 
                                           (LPVOID*) &m_pDMGraph );

    // Create and insert the DirectMusic Tool
    m_pDisplayTool = new CDisplayTool( m_aNotes );
    m_pDMGraph->InsertTool( m_pDisplayTool, NULL, 0, 0 );

    // Play segment on the default audio path
    m_pDMPerformance->PlaySegmentEx( m_apMusic[0], NULL, NULL, 0, 
                                   0, NULL, NULL, NULL );
    m_bPlaying = TRUE;

    // Create vertex buffer to display notes
    m_pd3dDevice->CreateVertexBuffer( NUM_CHANNELS * NUM_NOTES * 4 * sizeof( CUSTOMVERTEX ), 0, 0, D3DPOOL_MANAGED, &m_pVB );

    ZeroMemory( m_aNotes, NUM_CHANNELS * NUM_NOTES * sizeof( DMUS_NOTE_PMSG ) );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    REFERENCE_TIME rt;
    MUSIC_TIME mt;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle playback
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDMPerformance->StopEx( m_apMusic[m_dwCurrent], 0, 0 );
        else
            m_pDMPerformance->PlaySegmentEx( m_apMusic[m_dwCurrent], NULL, NULL, 0, 0, NULL, NULL, NULL );

        m_bPlaying = !m_bPlaying;
    }

    // Change to a different segment
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        ZeroMemory( m_aNotes, NUM_CHANNELS * NUM_NOTES * sizeof( DMUS_NOTE_PMSG ) );

        // If we were playing before, stop the segment
        if( m_bPlaying )
            m_pDMPerformance->StopEx( m_apMusic[m_dwCurrent], 0, 0 );

        // Switch to next segment
        m_dwCurrent = ( m_dwCurrent + 1 ) % ( sizeof( g_szSegments ) / sizeof( g_szSegments[0] ) );
    
        // Play new segment on the default audio path
        if( m_bPlaying )
            m_pDMPerformance->PlaySegmentEx( m_apMusic[m_dwCurrent], NULL, NULL, 0, 
                                             0, NULL, NULL, NULL );
    }

    // Update our vertex buffer with current state of notes.
    m_pDMPerformance->GetTime( &rt, &mt );

    //
    // Now, loop over each note of each channel.  If it's
    // being played, add it to our vertex buffer
    //
    m_dwNumQuads = 0;
    CUSTOMVERTEX * pVertices;
    m_pVB->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( int channel = 0; channel < NUM_CHANNELS; channel++ )
    {
        // Spread the colors out over the channel range
        DWORD dwChannelColor = 0xFF000000 | DWORD( channel / (float)NUM_CHANNELS * 0xFFFFFF );

        for( int note = 0; note < NUM_NOTES; note++ )
        {
            BYTE bVel;
            MUSIC_TIME mtNoteEnd = m_aNotes[ channel * NUM_NOTES + note ].mtTime + m_aNotes[ channel * NUM_NOTES + note ].mtDuration;
            REFERENCE_TIME rtNoteEnd;
            
            m_pDMPerformance->MusicToReferenceTime( mtNoteEnd, &rtNoteEnd );

            if( rtNoteEnd + 2500000 < rt )
            {
                // Note ended > .25 seconds ago
                bVel = 0;
                continue;
            }
            else if( rtNoteEnd > rt )
            {
                // Note still playing
                bVel = m_aNotes[ channel * NUM_NOTES + note ].bVelocity;
            }
            else
            {
                // Within .25 seconds of note end
                bVel = BYTE( ( 1.0f - ( rt - rtNoteEnd ) / 2500000.0f ) * m_aNotes[ channel * NUM_NOTES + note ].bVelocity );
            }

            // Calculate height of note
            FLOAT fHeight = 480 - ( ( 480 - 48 ) * bVel / 127.0f );

            // Add a quad to the vertex buffer
            pVertices[m_dwNumQuads * 4 + 0].p = D3DXVECTOR4( (note+0)*COL_WIDTH + 64 - 0.5f, fHeight+COL_HEIGHT - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 0].c = dwChannelColor;
            pVertices[m_dwNumQuads * 4 + 1].p = D3DXVECTOR4( (note+0)*COL_WIDTH + 64 - 0.5f, fHeight            - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 1].c = dwChannelColor;
            pVertices[m_dwNumQuads * 4 + 2].p = D3DXVECTOR4( (note+1)*COL_WIDTH + 64 - 0.5f, fHeight            - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 2].c = dwChannelColor;
            pVertices[m_dwNumQuads * 4 + 3].p = D3DXVECTOR4( (note+1)*COL_WIDTH + 64 - 0.5f, fHeight+COL_HEIGHT - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 3].c = dwChannelColor;
            m_dwNumQuads++;
        }
    }
    m_pVB->Unlock();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof( CUSTOMVERTEX ) );

    // Draw the quads from our vertex buffer
    if( m_dwNumQuads > 0 )
        m_pd3dDevice->DrawVertices( D3DPT_QUADLIST, 0, m_dwNumQuads * 4 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szTemp[256];

		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"DMTool" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        swprintf( szTemp, L"Playing: %S", g_szSegments[ m_dwCurrent ] );
        m_Font.DrawText(  64, 80, m_bPlaying ? 0xFFFFFFFF : 0xFF808080, szTemp );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMScript\DMScript.cpp ===
//-----------------------------------------------------------------------------
// File: DMScript.cpp
//
// Desc: Plays a script file using DirectMusic.
//
// Hist: 01.12.00 - New for February XDK release
//       02.22.01 - Updated for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBUtil.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <dmusici.h>
#include "dsstdfx.h"
#include "myfactory.h"



//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"+1 Home score" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"+1 Visitor\nscore" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Play food\nvendor" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_1, L"Play organ" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Announce score" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_2, L"New game" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Adjust volume" },
};

#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help
    
	FLOAT              m_fVolume;
    WCHAR*             m_strScriptName;
    LONG               m_HomeTeamScore;
    LONG               m_AwayTeamScore;

    // DirectMusic variables
    IDirectMusicLoader8*      m_pLoader;
    IDirectMusicPerformance8* m_pPerformance;
    IDirectMusicSegment8*     m_pMusic;
    IDirectMusicAudioPath8*   m_pMusicAudioPath;
    IDirectMusicScript8*      m_pMusicScript;
    LPDIRECTSOUND8            m_pDSound;

    HRESULT AddScore( BOOL bHomeTeam, INT delta );
    HRESULT NewGame();
    HRESULT CallRoutine( const CHAR* strRoutine );
    HRESULT DrawScore( FLOAT x, FLOAT y, const WCHAR* strLabel, INT score );
    HRESULT InitDirectMusic();
    HRESULT StartScript();
    HRESULT StopScript();
    HRESULT UpdateScriptFromScore( BOOL bHomeTeam );
    HRESULT SetVolume( LONG lVolume );
    VOID    ReportScriptError( const CHAR* method, const CHAR* name,
                               DMUS_SCRIPT_ERRORINFO* pErrorInfo );
    HRESULT SetVariableNumber( const CHAR* varName, LONG value );
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:

    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application class constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
{
    m_fVolume       = 100.0f;
    m_strScriptName = NULL;
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Init DM and fonts
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    if( FAILED( InitDirectMusic() ) )
        return E_FAIL;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;

    NewGame();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: NewGame
// Desc: Restart script
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::NewGame()
{
    StopScript();

    m_HomeTeamScore = 0;
    m_AwayTeamScore = 0;
    
    StartScript();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AddScore
// Desc: Update team score
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::AddScore( BOOL bHomeTeam, INT delta )
{
    if( bHomeTeam )
        m_HomeTeamScore += delta;
    else
        m_AwayTeamScore += delta;

    UpdateScriptFromScore( bHomeTeam );

    return S_OK;
}



#ifdef _DEBUG
extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);
#endif

//-----------------------------------------------------------------------------
// Name: CallRoutine()
// Desc: DM callback
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CallRoutine( const CHAR* strRoutine )
{
    DMUS_SCRIPT_ERRORINFO errorInfo = {sizeof(errorInfo)};

    HRESULT hr;
    if( FAILED( hr = m_pMusicScript->CallRoutine( strRoutine, &errorInfo ) ) ) 
	{
        ReportScriptError("CallRoutine", strRoutine, &errorInfo);
        return hr;
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReportScriptError()
// Desc: Debugging information
//-----------------------------------------------------------------------------
void CXBoxSample::ReportScriptError(const CHAR* method, const CHAR* name,
                                       DMUS_SCRIPT_ERRORINFO* pErrorInfo){
#ifdef _DEBUG
        DbgPrint("Script error method %s \"%s\"\n", method, name);
        DbgPrint(" hr = 0x%08x\n", pErrorInfo->hr);
        DbgPrint(" line number: %d\n", pErrorInfo->ulLineNumber);
        DbgPrint(" character position: %d\n", pErrorInfo->ichCharPosition);
        DbgPrint(" source file : %S\n", pErrorInfo->wszSourceFile);
        DbgPrint(" source component : %S\n", pErrorInfo->wszSourceComponent);
        DbgPrint(" description : %S\n", pErrorInfo->wszDescription);
        DbgPrint(" source line text : %S\n", pErrorInfo->wszSourceLineText);
#endif
}




//-----------------------------------------------------------------------------
// Name: DrawScore()
// Desc: Display score
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawScore( FLOAT x, FLOAT y, const WCHAR* strLabel, 
                                INT score )
{
    WCHAR buf[100];
    wsprintfW( buf, L"%s %d", strLabel, score ); 
    m_Font.DrawText( x, y, 0xffffffff, buf );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitDirectMusic
// Desc: Start up DM
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitDirectMusic() 
{
    m_pLoader         = NULL;
    m_pPerformance    = NULL;
    m_pMusicAudioPath = NULL;
    m_pMusicScript    = NULL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();

    // Create loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pLoader );

    // Create performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pPerformance );

    // Initialize the performance with the standard audio path.
    // The flags (final) argument allows us to specify whether or not we want
    // DirectMusic to create a thread on our behalf to process music, using 
    // DMUS_INITAUDIO_NOTHREADS.  The default is for DirectMusic to create its
    // own thread; DMUS_INITAUDIO_NOTHREADS tells DirectMusic not to do this, 
    // and the app will periodically call DirectMusicDoWork().  For software 
    // emulation on alpha hardware, it's generally better to have DirectMusic
    // create its own thread. On real hardware, periodically calling 
    // DirectMusicDoWork may provide a better option.
    m_pPerformance->InitAudioX( DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );

    // Get default (music) audiopath.
    m_pPerformance->GetDefaultAudioPath( &m_pMusicAudioPath );

    // Max volume for music
    m_pMusicAudioPath->SetVolume( (100*100)-10000, 0 );

    // Now DirectMusic will play in the background, so continue on with our task
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: StopScript()
// Desc: stop the script
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::StopScript()
{
    if( m_pMusicScript )
    {
        CallRoutine("StopAll");
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: StartScript()
// Desc: Load the script
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::StartScript()
{
    HRESULT hr;

    if(! m_pMusicScript )
    {
	    // Load and init the music script
        hr = m_pLoader->LoadObjectFromFile( CLSID_DirectMusicScript, IID_IDirectMusicScript8, 
			                                "BaseBall.spt", (VOID**)&m_pMusicScript );
        if( FAILED(hr) )
        {
            m_strScriptName = L"Could not load script";
            return hr;
        }

        hr = m_pMusicScript->Init( m_pPerformance, NULL );
        if( FAILED(hr) )
        {
            m_strScriptName = L"Could not Initialize script";
            return hr;
        }
    }

    m_strScriptName = L"Baseball";

    UpdateScriptFromScore( TRUE );  // For home team
    UpdateScriptFromScore( FALSE ); // For away team

    hr = CallRoutine( "Start" );
    return hr;
}




//-----------------------------------------------------------------------------
// Name: UpdateScriptFromScore
// Desc: Update DM script
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateScriptFromScore( BOOL bHomeTeam )
{
    // Tell the script what the score is
    if( NULL == m_pMusicScript )
        return E_FAIL;

    HRESULT hr;

    if( bHomeTeam )
        hr = SetVariableNumber( "Variable1", m_HomeTeamScore);
    else
        hr = SetVariableNumber( "Variable2", m_AwayTeamScore);

    return hr;
}




//-----------------------------------------------------------------------------
// Name: SetVariableNumber
// Desc: Save variable in script
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetVariableNumber( const CHAR* varName, LONG value )
{
    // Tell the script what the score is
    if( NULL == m_pMusicScript )
        return E_FAIL;

    DMUS_SCRIPT_ERRORINFO errorInfo;
    HRESULT hr = m_pMusicScript->SetVariableNumber( varName, value, &errorInfo );

    if( FAILED(hr) )
    {
        ReportScriptError("SetVariableNumber", varName, &errorInfo);
    }
    return hr;
}




//-----------------------------------------------------------------------------
// Name: SetVolume()
// Desc: Set volume on the main music audipath
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetVolume( LONG lVolume )
{
    // Change range from [0,100] to [-3000,0]
    const INT kInLow = 0;
    const INT kInHigh = 100;
    const INT kOutLow = -3000;
    const INT kOutHigh = 0;
    lVolume = (lVolume - kInLow) * (kOutHigh - kOutLow) / (kInHigh - kInLow)
        + kOutLow;

    m_pMusicAudioPath->SetVolume( lVolume, 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[i] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 || pGamePad->fY1 || pGamePad->fX2 || pGamePad->fX2  )
        return TRUE;

    // Nothing active
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Check controller and update script
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    const XBGAMEPAD* pGamepad = GetPrimaryController();
    if( pGamepad == NULL )
        return S_OK;

    // Adjust volume
    m_fVolume += pGamepad->fY1 * m_fElapsedTime * 100.0f;
    if( m_fVolume <   1.0f )
        m_fVolume =   1.0f;
    if( m_fVolume > 100.0f )
        m_fVolume = 100.0f;
    SetVolume( (INT)m_fVolume );

    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        CallRoutine( "Hit" );
        AddScore( TRUE, 1 );
    }

    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
        CallRoutine( "Hit" );
        AddScore( FALSE, 1 );
    }

    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        CallRoutine( "Routine1" );
    }

    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
    {
        CallRoutine( "Routine2" );
    }
    
    if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
    {
        CallRoutine( "Routine3" );
    }
    
    if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_START )
    {
        NewGame();
    }

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Graphics display
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        // Draw title
        m_Font.DrawText( 64, 50, 0xffffffff, L"DMScript: DirectMusic AudioScript Sample" );
        m_Font.DrawText( 64, 75, 0xffffffff, m_strScriptName );

        // Draw instructions
        DrawScore( 64, 150, L"A - Add One to Home Team Score:", m_HomeTeamScore );
        DrawScore( 64, 180, L"B - Add One to Visitors Score:", m_AwayTeamScore );
        m_Font.DrawText( 64, 210, 0xffffffff, L"X - Trigger Food Vendor" );
        m_Font.DrawText( 64, 240, 0xffffffff, L"Y - Trigger Organ Music" );
        m_Font.DrawText( 64, 270, 0xffffffff, L"Black - Announce Score" );
        m_Font.DrawText( 64, 300, 0xffffffff, L"Start - Start New Game" );
        m_Font.DrawText( 64, 330, 0xffc0c0c0, L"The game is over after one team scores 10 runs." );
        m_Font.DrawText( 64, 400, 0xffffffff, L"L stick up/down - Volume:" );
    
        // Draw the volume bar
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 320, x2 = x1 + (280*m_fVolume)/100;
        FLOAT y1 = 400, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffc0ffc0;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffc0ffc0;

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\tool.cpp ===
//-----------------------------------------------------------------------------
// File: Tool.cpp
//
// Desc: Implementation file for CDispayTool class
//
// Hist: 3.13.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "tool.h"
#include <stdio.h>
#include <tchar.h>

//-----------------------------------------------------------------------------
// Name: CDisplayTool::CDisplayTool()
// Desc: Constructor
//-----------------------------------------------------------------------------
CDisplayTool::CDisplayTool( DMUS_NOTE_PMSG * pNotes )
{
    m_cRef = 1;                 // Set to 1 so one call to Release() will free this
    m_pNotes = pNotes;
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::~CDisplayTool()
// Desc: Destructor
//-----------------------------------------------------------------------------
CDisplayTool::~CDisplayTool()
{
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::QueryInterface()
// Desc: Per IUnknown interface
//-----------------------------------------------------------------------------
STDMETHODIMP CDisplayTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::AddRef()
// Desc: Per IUnknown interface
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDisplayTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::Release()
// Desc: Per IUnknown interface
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDisplayTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}



//-----------------------------------------------------------------------------
// Name: CDisplayTool::Init()
// Desc: Performs any needed initialization for the tool
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CDisplayTool::Init( IDirectMusicGraph* pGraph )
{
    // This tool has no need to do any type of initialization.
    return E_NOTIMPL;
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::GetMsgDeliveryType()
// Desc: Tells DirectMusic when we want to receive messages
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CDisplayTool::GetMsgDeliveryType( DWORD* pdwDeliveryType )
{
    // This tool wants messages before they're played, so
    // we return DMUS_PMSGF_TOOL_IMMEDIATE.  The other options are
    // DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
    
    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::GetMediaTypeArraySize()
// Desc: Returns the number of message types we're interested in
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CDisplayTool::GetMediaTypeArraySize( DWORD* pdwNumElements )
{
    // This tool only wants note messages, patch messages, sysex, 
    // and MIDI messages, so set *pdwNumElements to 4.
    
    *pdwNumElements = 1;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::GetMediaTypes()
// Desc: Returns message types we're interested in
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CDisplayTool::GetMediaTypes( DWORD** padwMediaTypes, 
                                                    DWORD dwNumElements )
{
    // Fill in the array padwMediaTypes with the type of
    // messages this tool wants to process. In this case,
    // dwNumElements will be 1, since that is what this
    // tool returns from GetMediaTypeArraySize().
    
    if( dwNumElements == 1 )
    {
        // Set the elements in the array to DMUS_PMSGT_NOTE,
        (*padwMediaTypes)[0] = DMUS_PMSGT_NOTE;
        return S_OK;
    }
    else
    {
        // This should never happen
        return E_FAIL;
    }
}




//-----------------------------------------------------------------------------
// Name: CDisplayTool::ProcessPMsg()
// Desc: Handles processing of the message
//       We intercept messages at DMUS_PMSGF_TOOL_IMMEDIATE time, because
//       intercepting them at play time would delay the playback of the note.
//       To coordinate the timing of the various notes, we clone the message
//       and send it back to ourselves, stamped to show up at play time.
//       This way we can take our time with the copied message and not disturb
//       playback.
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CDisplayTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    DMUS_NOTE_PMSG * pNote = (DMUS_NOTE_PMSG *)pPMsg;

    if (pPMsg->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        // This came in from the segment. 
        // Make a copy of the PMsg and send that back to this tool, but marked
        // with DMUS_PMSGF_TOOL_ATTIME, so it will arrive at the actual time stamped
        // in the PMsg. Meanwhile, the original PMsgs should pass straight through, 
        // undelayed, so it will play properly on the synth.
        DMUS_PMSG *pCopy;
        if (SUCCEEDED(pPerf->ClonePMsg(pPMsg,&pCopy)))
        {
            pCopy->dwFlags &= ~DMUS_PMSGF_TOOL_IMMEDIATE;
            pCopy->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
            pPerf->SendPMsg(pCopy); // Since the msg wasn't changed, this will come
                                    // right back, but at the time in the time stamp.
        }

        // Now, call StampPMsg() to send the original PMsgs through to the synth.
        if(( NULL == pPMsg->pGraph ) ||
            FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
        {
            return DMUS_S_FREE;
        }

        // Return DMUS_S_REQUEUE so the original message is requeued
        return DMUS_S_REQUEUE;
    }
    else 
    {
        // This must be the DMUS_PMSGF_TOOL_ATTIME copy we went ourselves. 
        // Copy the note into our buffer so we trigger the display at the 
        // exact right time.
        m_pNotes[ pNote->dwPChannel * NUM_NOTES + pNote->bMidiValue ] = *pNote;

        // We're done with this, so free it.
        return DMUS_S_FREE;
    }
}





//-----------------------------------------------------------------------------
// Name: CDisplayTool::Flush()
// Desc: Not implemented
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CDisplayTool::Flush( IDirectMusicPerformance* pPerf, 
                                            DMUS_PMSG* pDMUS_PMSG,
                                            REFERENCE_TIME rt)
{
    // This tool does not need to flush.
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\tool.h ===
//-----------------------------------------------------------------------------
// File: Tool.h
//
// Desc: Header file for CDispayTool class
//
// Hist: 3.13.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <dmusici.h>

#define NUM_NOTES 128
#define NUM_CHANNELS 96

class CDisplayTool : public IDirectMusicTool
{
public:
	CDisplayTool( DMUS_NOTE_PMSG * pNotes );
    ~CDisplayTool();

public:
// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTool
	HRESULT STDMETHODCALLTYPE Init( IDirectMusicGraph* pGraph );
	HRESULT STDMETHODCALLTYPE GetMsgDeliveryType( DWORD* pdwDeliveryType );
	HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize( DWORD* pdwNumElements );
	HRESULT STDMETHODCALLTYPE GetMediaTypes( DWORD** padwMediaTypes, DWORD dwNumElements) ;
	HRESULT STDMETHODCALLTYPE ProcessPMsg( IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG );
	HRESULT STDMETHODCALLTYPE Flush( IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt );
private:
	long	m_cRef;			    // Reference counter
    DMUS_NOTE_PMSG * m_pNotes;

public:
// Public class methods
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\DMTool\myfactory.h ===
//--------------------------------------------------------------------------------------------    
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); 
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );
STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );
STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );
STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);
STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );
STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );
STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);
STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);
STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);
STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);
STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);
STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);
STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);
STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);
STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);
STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);
STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);
STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );
STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );
STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );
STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );
STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );
STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );
STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );
STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );
STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
                                                                                                  
                                                                                                  
HRESULT CALLBACK MyFactory(REFCLSID clsid,
                           LPUNKNOWN pUnkOuter,
                           REFIID iid,
                           LPVOID *ppvInterface)
{
   HRESULT hr = E_FAIL;
    if (clsid == CLSID_DirectMusicChordTrack)
    {
        // Chord Track - used for style playback.
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBandTrack)
    {
        // Band Track - manages one or more bands - always required for any MIDI + DLS playback.
        hr = DirectMusicBandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        // Tempo Track - defines tempo changes, always required for music.
        hr = DirectMusicTempoTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyle)
    {
        // Style - style playback object, represents a specific style type.
        hr = DirectMusicStyleCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required.
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        // DLS Collection: manages a DLS file - always required for MIDI + DLS.
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        // Groove Track - used to store groove levels for style playback.
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSeqTrack)
    {
        // Sequence Track: plays straight MIDI sequences.
        hr = DirectMusicSeqTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        // Time Signature Track - defines time signature in segments, always required for music synchronization.
        hr = DirectMusicTimeSigTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyleTrack)
    {
        // Style Track - selects style for playback.
        hr = DirectMusicStyleTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBand)
    {
        // Band - manages downloading of DLS instruments as well as volume and pan presets - always required for MIDI + DLS.
        hr = DirectMusicBandCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        // Container: storage container for multiple DirectMusic file objects. Always used in scripting.
        hr = DirectMusicContainerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        // Synthesizer: controls the hardware synthesizer - always required.
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        // ChordMap Track - defines ChordMap to be used to compose a chord track.
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        // Composer: creates playback segments and autotransitions from chordmaps and template segments.
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory.
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream.
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk.
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLyricsTrack)
    {
        // Lyrics Track: sends lyrics.
        hr = DirectMusicLyricsTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        // Loader: required to read files from disk and link objects. May be replaced by application.
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        // Performance - segment playback framework, always required.
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    #ifndef AUDANALYZE_NODEBUG     
    else                           
    {                              
        OUTPUT_DEBUG_STRING("DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \n");
        OUTPUT_DEBUG_STRING("Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \n");
        OUTPUT_DEBUG_STRING("AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \n");
        OUTPUT_DEBUG_STRING("a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \n");
        CHAR szTemp[MAX_PATH] ={0};
        sprintf(szTemp,"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
        OUTPUT_DEBUG_STRING(szTemp);
        DebugBreak();              
    }                              
    #endif AUDANALYZE_NODEBUG     
    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\EnumSoundtrack.cpp ===
//-----------------------------------------------------------------------------
// File: EnumSoundtrack.cpp
//
// Desc: Enumerate WMA soundtracks
//
// Hist: 02.16.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "EnumSoundtrack.h"
#include <cassert>


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// Maximum viewable songs
const DWORD MAX_SONGS_DISPLAYED = 10;

// Must be this far from center on 0.0 - 1.0 scale
const FLOAT JOY_THRESHOLD = 0.25f;

// Text colors
const DWORD COLOR_HIGHLIGHT = 0xff00ff00;
const DWORD COLOR_NORMAL = 0xffffffff;

// Controller repeat values
const FLOAT fINITIAL_REPEAT = 0.333f; // 333 mS recommended for first repeat
const FLOAT fSTD_REPEAT     = 0.085f; // 85 mS recommended for repeat rate




//-----------------------------------------------------------------------------
// Name: Song()
// Desc: Construct song object
//-----------------------------------------------------------------------------
CXBEnumSoundtrack::Song::Song( DWORD dwId, const WCHAR* strAlbum, 
                               const WCHAR* strSong, DWORD dwLength )
:
    m_dwId( dwId ),
    m_strAlbum(),
    m_strSong(),
    m_dwLength( dwLength )
{
    lstrcpynW( m_strAlbum, strAlbum, MAX_SOUNDTRACK_NAME );
    lstrcpynW( m_strSong, strSong, MAX_SONG_NAME );
}




//-----------------------------------------------------------------------------
// Name: GetAlbum()
// Desc: Returns the album name
//-----------------------------------------------------------------------------
const WCHAR* CXBEnumSoundtrack::Song::GetAlbum() const
{
    return m_strAlbum;
}




//-----------------------------------------------------------------------------
// Name: GetSong()
// Desc: Returns the song name
//-----------------------------------------------------------------------------
const WCHAR* CXBEnumSoundtrack::Song::GetSong() const
{
    return m_strSong;
}




//-----------------------------------------------------------------------------
// Name: GetLength()
// Desc: Returns length of song in mS
//-----------------------------------------------------------------------------
DWORD CXBEnumSoundtrack::Song::GetLength() const
{
    return m_dwLength;
}




//-----------------------------------------------------------------------------
// Name: GetLength()
// Desc: Formats the incoming string as "MM:SS"
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::Song::GetLength( CHAR* strMMSS ) const
{
    assert( strMMSS != NULL );

    // Convert to seconds
    DWORD dwSeconds = m_dwLength / 1000;

    // Round to nearest second
    if( m_dwLength - ( dwSeconds * 1000 ) >= 500 )
        ++dwSeconds;

    // Determine minutes
    DWORD dwMinutes = dwSeconds / 60;

    // Remaining seconds
    dwSeconds -= ( dwMinutes * 60 );

    // Format in strMMSS
    wsprintfA( strMMSS, "%lu:%02lu", dwMinutes, dwSeconds );
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Open the soundtrack WMA song and return file handle
//-----------------------------------------------------------------------------
HANDLE CXBEnumSoundtrack::Song::Open( BOOL bAsync ) const
{
    return XOpenSoundtrackSong( m_dwId, bAsync );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBEnumSoundtrack xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBEnumSoundtrack()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBEnumSoundtrack::CXBEnumSoundtrack()
:
    CXBApplication(),
    m_Font        (),
    m_RepeatTimer ( FALSE ),
    m_fRepeatDelay( fINITIAL_REPEAT ),
    m_SongList    (),
    m_iCurrSong   ( 0 ),
    m_iTopSong    ( 0 ),
    m_hSongFile   ( INVALID_HANDLE_VALUE ),
    m_Stream      (),
    m_bPlaying    ( FALSE )
{
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBEnumSoundtrack::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize = 0;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Sets up the enum soundtrack example
//-----------------------------------------------------------------------------
HRESULT CXBEnumSoundtrack::Initialize()
{
    // Set the matrices
    D3DXVECTOR3 vEye(-2.5f, 2.0f, -4.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEye,&vAt, &vUp );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;

    // Load the list of soundtracks
    InitSoundtrackList();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitSoundtrackList()
// Desc: Load all soundtracks into memory
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::InitSoundtrackList()
{
    // Enumerate all soundtracks
    XSOUNDTRACK_DATA SoundtrackData;
    HANDLE hFind = XFindFirstSoundtrack( &SoundtrackData );
    if( hFind != INVALID_HANDLE_VALUE )
    {
        AddSoundtrackSongs( SoundtrackData );
        while( XFindNextSoundtrack( hFind, &SoundtrackData ) )
            AddSoundtrackSongs( SoundtrackData );
        XFindClose( hFind );
    }
}




//-----------------------------------------------------------------------------
// Name: AddSoundtrackSongs()
// Desc: Load all songs from the given soundtrack into the list
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::AddSoundtrackSongs( const XSOUNDTRACK_DATA& SoundtrackData )
{
    // Get each song
    for( UINT i = 0; i < SoundtrackData.uSongCount; ++i )
    {
        DWORD dwSongId;
        DWORD dwSongLength;
        WCHAR strSong[ MAX_SONG_NAME ];
        if( XGetSoundtrackSongInfo( SoundtrackData.uSoundtrackId, i, &dwSongId,
                                    &dwSongLength, strSong, MAX_SONG_NAME ) )
        {
            // Add it to the list
            m_SongList.push_back( Song( dwSongId, SoundtrackData.szName, 
                                        strSong, dwSongLength ) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame; the entry point for animating the scene
//-----------------------------------------------------------------------------
HRESULT CXBEnumSoundtrack::FrameMove()
{
    ValidateState();

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Poll the system for events
    Event ev = GetControllerEvent();

    // Update the current state
    UpdateState( ev );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d rendering.
//       This function sets up render states, clears the viewport, and renders
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBEnumSoundtrack::Render()
{
    // Keep any WMA file playing
    if( FAILED( m_Stream.Process() ) )
        return E_FAIL;

    DirectSoundDoWork();

    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x000000ff, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff102030, 0xff405060 );

    // Draw title & framerate
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"EnumSoundtrack" );
    m_Font.DrawText( 460, 50, 0xffffff00, m_strFrameRate );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        if( m_SongList.empty() )
        {
            m_Font.DrawText( 80.0f, 68.0f, COLOR_NORMAL, L"No soundtracks available" );
        }
        else
        {
            // Show the list of songs
            FLOAT fTop = 90.0f;
            FLOAT fOffset = 24.0f;
            SongListIndex j = 0;
            for( SongListIndex i = m_iTopSong; i < m_SongList.size() &&
                                               j < MAX_SONGS_DISPLAYED; ++i, ++j )
            {
                const Song& song = m_SongList[ i ];

                CHAR strMMSS[32];
                song.GetLength( strMMSS );

                WCHAR strSong[ 256 ];
                wsprintfW( strSong, L"%ls: %ls (%hs)", song.GetAlbum(), song.GetSong(), 
                           strMMSS );
                DWORD dwColor = ( i == m_iCurrSong ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;

                m_Font.DrawText( 80.0f, fTop + (fOffset * j ), dwColor, strSong );
            }

            // Show scroll arrows
            BOOL bShowTopArrow = m_iTopSong > 0;
            BOOL bShowBtmArrow = m_iTopSong + MAX_SONGS_DISPLAYED < m_SongList.size();
            if( bShowTopArrow )
                m_Font.DrawText( 80.0f, 48.0f, COLOR_NORMAL, L"^" );
            if( bShowBtmArrow )
                m_Font.DrawText( 80.0f, 320.0f, COLOR_NORMAL, L"v" );

            // Descriptive text
            m_Font.DrawText( 320.0f, 
                             320.0f, 
                             COLOR_NORMAL, 
                             m_bPlaying ? L"Playing..." : L"Stopped", 
                             XBFONT_CENTER_X );
            m_Font.DrawText( 320.0f, 380.0f, COLOR_NORMAL, L"A play    B stop",
                             XBFONT_CENTER_X );
        }
    }

    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ValidateState()
// Desc: Check object invariants
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::ValidateState() const
{
    assert( m_SongList.empty() || m_iCurrSong < m_SongList.size() );
    assert( m_iTopSong <= m_iCurrSong );
    assert( m_iCurrSong < m_iTopSong + MAX_SONGS_DISPLAYED );
}




//-----------------------------------------------------------------------------
// Name: IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 || pGamePad->fY1 || pGamePad->fX2 || pGamePad->fX2  )
        return TRUE;

    // Nothing active
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: GetControllerEvent()
// Desc: Polls the controller for events. Handles button repeats.
//-----------------------------------------------------------------------------
CXBEnumSoundtrack::Event CXBEnumSoundtrack::GetControllerEvent()
{
    const XBGAMEPAD* pGamePad = GetPrimaryController();
    if( pGamePad != NULL )
    {
        // Handle button press and joystick hold repeats
        if( IsAnyButtonActive( pGamePad ) )
        {
            // If the timer is running, the button is being held. If it's
            // held long enough, it triggers a repeat. If the timer isn't
            // running, we start it.
            if( m_RepeatTimer.IsRunning() )
            {
                // If the timer is running but hasn't expired, bail out
                if( m_RepeatTimer.GetElapsedSeconds() < m_fRepeatDelay )
                    return EV_NULL;

                m_fRepeatDelay = fSTD_REPEAT;
                m_RepeatTimer.StartZero();
            }
            else
            {
                m_fRepeatDelay = fINITIAL_REPEAT;
                m_RepeatTimer.StartZero();
            }
        }
        else
        {
            // No buttons or joysticks active; kill the repeat timer
            m_fRepeatDelay = fINITIAL_REPEAT;
            m_RepeatTimer.Stop();
        }

        // Primary buttons
        if( pGamePad->wButtons & XINPUT_GAMEPAD_START )
            return EV_START_BUTTON;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_BACK )
            return EV_BACK_BUTTON;
        if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_A ] )
            return EV_A_BUTTON;
        if( pGamePad->bAnalogButtons[ XINPUT_GAMEPAD_B ] )
            return EV_B_BUTTON;

        // Movement
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_UP ||
            pGamePad->fY1 > JOY_THRESHOLD )
            return EV_UP;
        if( pGamePad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
            pGamePad->fY1 < -JOY_THRESHOLD )
            return EV_DOWN;
    }

    // No controllers inserted or no button presses
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: UpdateState()
// Desc: State machine updates the current context based on the incoming event
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::UpdateState( Event ev )
{
    switch( ev )
    {
        case EV_NULL:
            break;
        case EV_A_BUTTON:
            Start();
            break;
        case EV_B_BUTTON:
            Stop();
            break;
        case EV_UP:
            // If we're at the top of the displayed list, shift the display
            if( m_iCurrSong == m_iTopSong )
            {
                if( m_iTopSong > 0 )
                    --m_iTopSong;
            }
            // Move to previous song
            if( m_iCurrSong > 0 )
                --m_iCurrSong;
            break;
        case EV_DOWN:
            // If we're at the bottom of the displayed list, shift the display
            if( m_iCurrSong == m_iTopSong + MAX_SONGS_DISPLAYED - 1 )
            {
                if( m_iTopSong + MAX_SONGS_DISPLAYED < m_SongList.size() )
                    ++m_iTopSong;
            }
            // Move to next song
            if( m_iCurrSong < m_SongList.size() - 1 )
                ++m_iCurrSong;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Start the selected song
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::Start()
{
    if( !m_bPlaying )
    {
        Stop();

        // Open the current song
        m_hSongFile = m_SongList[ m_iCurrSong ].Open( FALSE );

        // Start playback
        m_Stream.Start( m_hSongFile );
        m_bPlaying = TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stop the song that's playing and close the file
//-----------------------------------------------------------------------------
VOID CXBEnumSoundtrack::Stop()
{
    m_bPlaying = FALSE;
    // Stop the current song
    m_Stream.Stop();

    // Close the file
    if( m_hSongFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hSongFile );
        m_hSongFile = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnvelopeGenerator\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnvelopeGenerator\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnvelopeGenerator\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\EnumSoundtrack.h ===
//-----------------------------------------------------------------------------
// File: EnumSoundtrack.h
//
// Desc: Enum WMA Soundtrack sample
//
// Hist: 02.16.01 - New for March XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBENUM_SOUNDTRACK_H
#define XBENUM_SOUNDTRACK_H

#pragma warning( disable: 4702 )
#include <xtl.h>
#include <XbApp.h>
#include <XbFont.h>
#include <XbStopWatch.h>
#include <Xbhelp.h>
#include <XbSound.h>
#include "WmaFileStream.h"
#include "dsstdfx.h"

#pragma warning( push, 3 )  // Suppress VC warnings when compiling at W4
#include <vector>
#pragma warning( pop )


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Change song" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Change song" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Play song" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Stop playback" },
};

#define NUM_HELP_CALLOUTS 5



//-----------------------------------------------------------------------------
// Name: class CXBEnumSoundtrack
// Desc: Application object for enumerating soundtracks
//-----------------------------------------------------------------------------
class CXBEnumSoundtrack : public CXBApplication
{
    //-------------------------------------------------------------------------
    // Song class stores information about each song
    //-------------------------------------------------------------------------

    class Song
    {

        DWORD m_dwId;
        WCHAR m_strAlbum[ MAX_SOUNDTRACK_NAME ];
        WCHAR m_strSong[ MAX_SONG_NAME ];
        DWORD m_dwLength; // mS

    public:

        Song( DWORD dwId, const WCHAR* strAlbum, const WCHAR* strSong,
              DWORD dwLength );

        const WCHAR* GetAlbum() const;
        const WCHAR* GetSong() const;
        DWORD        GetLength() const;
        VOID         GetLength( CHAR* strMMSS ) const;
        HANDLE       Open( BOOL bAsync ) const;

    private:

        Song(); // disabled

    };

    //-------------------------------------------------------------------------
    // Enums
    //-------------------------------------------------------------------------

    enum Event
    {
        EV_NULL,            // No events
        EV_A_BUTTON,        // A button
        EV_START_BUTTON,    // Start button
        EV_B_BUTTON,        // B button
        EV_BACK_BUTTON,     // Back button
        EV_UP,              // Up Dpad or left joy
        EV_DOWN,            // Down Dpad or left joy

        EVENT_MAX
    };

    //-------------------------------------------------------------------------
    // Types
    //-------------------------------------------------------------------------

    typedef std::vector< Song > SongList;
    typedef SongList::size_type SongListIndex;

    //-------------------------------------------------------------------------
    // Data
    //-------------------------------------------------------------------------

    mutable CXBFont m_Font;             // Font renderer
    mutable CXBHelp m_Help;             // Help object
    BOOL            m_bDrawHelp;        // Should we draw help?

    CXBStopWatch    m_RepeatTimer;      // Controller button repeat timer
    FLOAT           m_fRepeatDelay;     // Time between button repeats
    SongList        m_SongList;         // List of songs
    SongListIndex   m_iCurrSong;        // Selected song
    SongListIndex   m_iTopSong;         // Topmost song displayed
    HANDLE          m_hSongFile;        // Song being played
    CWMAFileStream  m_Stream;           // WMA playback object
    LPDIRECTSOUND8  m_pDSound;          // DirectSound object
    BOOL            m_bPlaying;         // TRUE if track is playing

public:

    CXBEnumSoundtrack();

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

private:

    VOID InitSoundtrackList();
    VOID AddSoundtrackSongs( const XSOUNDTRACK_DATA& );
    VOID ValidateState() const;
    Event GetControllerEvent();
    VOID UpdateState( Event );
    VOID Start();
    VOID Stop();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};

#endif // XBENUM_SOUNDTRACK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnvelopeGenerator\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnvelopeGenerator\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\WmaFileStream.h ===
//-----------------------------------------------------------------------------
// File: WmaFileStream.cpp
//
// Desc: WMA file playback
//
// Hist: 02.16.01 - New for March XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBWMA_FILE_STREAM_H
#define XBWMA_FILE_STREAM_H

#include <xtl.h>
#include <XbSound.h>




//-----------------------------------------------------------------------------
// Name: class CWMAFileStream
// Desc: Wave file streaming object
//-----------------------------------------------------------------------------
class CWMAFileStream
{
    // The maximum amount of packets we will ever submit to the renderer
    static const DWORD WMASTRM_PACKET_COUNT = 8;

    XFileMediaObject*   m_pSourceFilter;    // Source (wave file) filter
    IDirectSoundStream* m_pRenderFilter;    // Render (DirectSoundStream) filter
    BYTE*               m_pSourceBuffer;    // Source filter data buffer

    // Packet status array
    DWORD m_adwPacketStatus[ WMASTRM_PACKET_COUNT ];

public:

    CWMAFileStream();
    ~CWMAFileStream();

    HRESULT Start( HANDLE hFile );
    VOID    Stop();
    BOOL    IsStopped() const;
    HRESULT Process();

private:

    // Packet processing
    BOOL    FindFreePacket( DWORD& dwPacketIndex ) const;
    HRESULT ProcessSource( DWORD dwPacketIndex ) const;
    HRESULT ProcessRenderer( DWORD dwPacketIndex );

};

#endif // XBWMA_FILE_STREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnumSoundtrack\WmaFileStream.cpp ===
//-----------------------------------------------------------------------------
// File: WmaFileStream.cpp
//
// Desc: WMA file playback
//
// Hist: 02.16.01 - New for March XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "WmaFileStream.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The WMA decoder will work properly in async mode, with all formats
// only when using a lookahead size of at least 64k. We are using it synchronous mode
// but for good measure we still pass 64k
const DWORD WMASTRM_LOOKAHEAD_SIZE = 4096 * 16;

// This value is hard-coded assuming a WMA file of stero, 16bit resolution.  If
// this Value can by dynamically set based on the WMA format, keeping in mind
// that WMA needs enough buffer for a minimum of 2048 samples worth of PCM data
const DWORD WMASTRM_SOURCE_PACKET_BYTES = (2048*2*2);





//-----------------------------------------------------------------------------
// Name: CWMAFileStream()
// Desc: Object constructor
//-----------------------------------------------------------------------------
CWMAFileStream::CWMAFileStream()
:
    m_pSourceFilter  ( NULL ),
    m_pRenderFilter  ( NULL ),
    m_pSourceBuffer  ( NULL ),
    m_adwPacketStatus()
    
{
    for( DWORD i = 0; i < WMASTRM_PACKET_COUNT; ++i )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;
}




//-----------------------------------------------------------------------------
// Name: ~CWMAFileStream()
// Desc: Object destructor
//-----------------------------------------------------------------------------
CWMAFileStream::~CWMAFileStream()
{
    Stop();
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Initializes the wave file streaming subsystem for playback
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::Start( HANDLE hFile )
{
    // Create the source (wma file) filter
    WAVEFORMATEX wfxSourceFormat;
    HRESULT hr = WmaCreateDecoder( "", hFile, FALSE, WMASTRM_LOOKAHEAD_SIZE,
                                   WMASTRM_PACKET_COUNT,
                                   0,
                                   &wfxSourceFormat, &m_pSourceFilter );
    if( FAILED(hr) )
        return hr;

    // Create the render (DirectSoundStream) filter
    DSSTREAMDESC dssd;
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwMaxAttachedPackets = WMASTRM_PACKET_COUNT;
    dssd.lpwfxFormat          = &wfxSourceFormat;

    hr = DirectSoundCreateStream( &dssd, &m_pRenderFilter );
    if( FAILED(hr) )
        return hr;

    // Allocate data buffers.  Since the source filter is synchronous, we only
    // have to allocate enough data to process a single packet.  The render
    // filter, however, is asynchronous, so we'll have to allocate enough
    // space to hold all the packets that could be submitted at any given time.
    m_pSourceBuffer = new BYTE[ WMASTRM_SOURCE_PACKET_BYTES * WMASTRM_PACKET_COUNT ];
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stop the WMA playback; does all cleanup
//-----------------------------------------------------------------------------
VOID CWMAFileStream::Stop()
{
    if( m_pSourceFilter != NULL )
    {
        m_pSourceFilter->Release();
        m_pSourceFilter = NULL;
    }
    if( m_pRenderFilter != NULL )
    {
        m_pRenderFilter->Release();
        m_pRenderFilter = NULL;
    }
    if( m_pSourceBuffer )
    {
        delete[] m_pSourceBuffer;
        m_pSourceBuffer = NULL;
    }

    for( DWORD i = 0; i < WMASTRM_PACKET_COUNT; ++i )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;
}




//-----------------------------------------------------------------------------
// Name: IsStopped()
// Desc: TRUE if playback stopped
//-----------------------------------------------------------------------------
BOOL CWMAFileStream::IsStopped() const
{
    return( m_pSourceFilter == NULL );
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Performs any work necessary to keep the stream playing.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::Process()
{
    if( IsStopped() )
        return S_OK;

    // Find a free packet.  If there's none free, we don't have anything to do
    DWORD dwPacketIndex;
    while( FindFreePacket( dwPacketIndex ) )
    {
         // Read from the source filter
         HRESULT hr = ProcessSource( dwPacketIndex );
         if( FAILED(hr) )
             return hr;
         
         // Send the data to the renderer
         hr = ProcessRenderer( dwPacketIndex );
         if( FAILED(hr) )
             return hr;
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket()
// Desc: Finds a render packet available for processing
//-----------------------------------------------------------------------------
BOOL CWMAFileStream::FindFreePacket( DWORD& dwPacketIndex ) const
{
    for( DWORD i = 0; i < WMASTRM_PACKET_COUNT; ++i )
    {
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[i] )
        {
            dwPacketIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessSource()
// Desc: Reads data from the source filter
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::ProcessSource( DWORD dwPacketIndex ) const
{
    // We're going to read a full packet's worth of data into the source
    // buffer.  Since we're playing in an infinite loop, we'll just spin
    // until we've read enough data, even if that means wrapping around the
    // end of the file.
    DWORD dwSourceUsed;
    XMEDIAPACKET xmp;
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer         = m_pSourceBuffer + 
                           ( dwPacketIndex * WMASTRM_SOURCE_PACKET_BYTES );
    xmp.dwMaxSize        = WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwCompletedSize = &dwSourceUsed;

    DWORD dwTotalSourceUsed = 0;
    while( dwTotalSourceUsed < WMASTRM_SOURCE_PACKET_BYTES )
    {
        // Read from the source
        HRESULT hr = m_pSourceFilter->Process(NULL, &xmp);
        if( FAILED(hr) )
            return hr;

        // Add the amount read to the total
        dwTotalSourceUsed += dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
            hr = m_pSourceFilter->Flush();
            if( FAILED(hr) )
                return hr;
        };
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessRenderer()
// Desc: Sends data to the renderer.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::ProcessRenderer( DWORD dwPacketIndex )
{
    // There's a full packet's worth of data ready for us to send to the
    // renderer.  We want to track the status of this packet since the
    // render filter is asychronous and we need to know when the packet is
    // completed.
    XMEDIAPACKET xmp;
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer  = m_pSourceBuffer + (dwPacketIndex * WMASTRM_SOURCE_PACKET_BYTES );
    xmp.dwMaxSize = WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwStatus = &m_adwPacketStatus[ dwPacketIndex ];

    HRESULT hr = m_pRenderFilter->Process( &xmp, NULL );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\EnvelopeGenerator\EnvelopeGenerator.cpp ===
//-----------------------------------------------------------------------------
// File: EnvelopeGenerator.cpp
//
// Desc: The EnvelopeGenerator sample demonstrates how to control looping and
//       Envelope Generators in DirectSound
//
// Hist: 4.30.01 - New for June release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBSound.h>
#include <dsound.h>
#include <xgraphics.h>
#include <stddef.h> // For offsetof
#include "dsstdfx.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle playback" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nLooping" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_1, L"Change EG" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, L"Decrease volume" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select\nparameter" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change value" },
};

#define NUM_HELP_CALLOUTS 9

// List of wav files to cycle through
const char* g_strBasePath = "D:\\Media\\Sounds\\";
char* g_aszFileNames[] = 
{
    "heli.wav",
    "DockingMono.wav",
    "EngineStartMono.wav",
    "MaleDialog1.wav",
    "MiningMono.wav",
    "MusicMono.wav",
    "Dolphin4.wav",
};
static const DWORD NUM_SOUNDS = sizeof( g_aszFileNames ) / sizeof( g_aszFileNames[0] );

// Struct for changing parameters of DSENVELOPEDESC
typedef struct 
{
    DWORD   dwOffset;       // Offset into EnvelopeDesc of field being changed
    LONG    dwMinValue;     // Minimum value of option
    LONG    dwMaxValue;     // Maximum value of option
    BOOL    bEG2;           // TRUE if only available in EG2 (DSEG_MULTI)
    WCHAR * szDescription;  // Description of option
} OPTION_STRUCT;

// List of parameters we can change
OPTION_STRUCT g_aOptions[] =
{
    { offsetof( DSENVELOPEDESC, dwDelay ),      0,  0xFFF, FALSE,  L"Delay" },
    { offsetof( DSENVELOPEDESC, dwAttack ),     0,  0xFFF, FALSE,  L"Attack" },
    { offsetof( DSENVELOPEDESC, dwHold ),       0,  0xFFF, FALSE,  L"Hold" },
    { offsetof( DSENVELOPEDESC, dwDecay ),      0,  0xFFF, FALSE,  L"Decay" },
    { offsetof( DSENVELOPEDESC, dwSustain ),    0,  0xFF,  FALSE,  L"Sustain" },
    { offsetof( DSENVELOPEDESC, dwRelease ),    0,  0xFFF, FALSE,  L"Release" },
    { offsetof( DSENVELOPEDESC, lPitchScale ),  -128, 127, TRUE,   L"Pitch Scale" },
    { offsetof( DSENVELOPEDESC, lFilterCutOff), -128, 127, TRUE,   L"Filter Cutoff" },
};
static const DWORD NUM_OPTIONS = sizeof( g_aOptions ) / sizeof( g_aOptions[0] );
    


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    BOOL        m_bDrawHelp;
    CXBFont     m_Font;
    CXBHelp     m_Help;

    CWaveFile               m_awfSounds[NUM_SOUNDS];// Wave file parsers
    DWORD                   m_dwCurrent;            // Current sound
    BOOL                    m_bPlaying;             // Are we playing?
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE *                  m_pbSampleData;         // Sample data from wav
    DSENVELOPEDESC          m_adsedEG[2];           // Envelope Generate settings
    DWORD                   m_dwParam;              // Selected parameter
    DWORD                   m_dwEG;                 // Selected EG
    BOOL                    m_bLooping;             // True if loop is enabled
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object

    // Acceleration factor for controller input
    FLOAT                   m_fAcceleration;

    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DrawEnvelope();                         // Draw the envelope graph
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;
    m_pbSampleData = NULL;
    
    m_fAcceleration = 1.0f;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    //
    // For testing purposes:
    // Make sure that all our files have the same format,
    // since we're re-using the samd DirectSoundBuffer for
    // all the files.  First, we have to determine how
    // much space to allocate for the wave format, since
    // the XBOXADPCMWAVEFORMAT is 2 bytes larger than
    // WAVEFORMATEX.
    //
    DWORD          cbFirst;
    WAVEFORMATEX * pwfFirst = NULL;
    DWORD          cbWalk;
    WAVEFORMATEX * pwfWalk = NULL;
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        char strFullPath[MAX_PATH];

        strcpy( strFullPath, g_strBasePath );
        strcat( strFullPath, g_aszFileNames[i] );
        if( FAILED( m_awfSounds[ i ].Open( strFullPath ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Testing only:
        // Verify they're all the same format, since we're only going to have
        // one sound buffer.
        if( i == 0 )
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbFirst );
            pwfFirst = (WAVEFORMATEX *)new BYTE[ cbFirst ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfFirst, cbFirst ) ) )
                return E_FAIL;
        }
        else
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbWalk );
            pwfWalk = (WAVEFORMATEX *)new BYTE[ cbWalk ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfWalk, cbWalk ) ) )
                return E_FAIL;

            if( cbWalk != cbFirst ||
                memcmp( pwfFirst, pwfWalk, cbFirst ) )
            {
                OUTPUT_DEBUG_STRING( "All wav files should have the same format!\n" );
                return E_FAIL;
            }

            delete[] pwfWalk;
        }
    }

    //
    // Initialize EnvelopeGenerators
    //
    m_dwEG = 0;
    m_dwParam = 0;
    ZeroMemory( m_adsedEG, 2 * sizeof( DSENVELOPEDESC ) );
    m_adsedEG[0].dwEG = DSEG_AMPLITUDE;
    m_adsedEG[0].dwMode = DSEG_MODE_DELAY;
    m_adsedEG[1].dwEG = DSEG_MULTI;
    m_adsedEG[1].dwMode = DSEG_MODE_DELAY;
    m_adsedEG[0].dwSustain = 0xFF;


    //
    // Create a sound buffer of 0 size, since we're going to use
    // SetBufferData
    //
    DSBUFFERDESC dsbdesc;
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    /* If fewer than 256 buffers are in existence at all points during 
       the game, it may be more efficient not to use LOCDEFER. */
    dsbdesc.dwFlags = DSBCAPS_LOCDEFER;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = pwfFirst;
    if( FAILED( DirectSoundCreateBuffer( &dsbdesc, &m_pDSBuffer ) ) )
        return E_FAIL;

    // Set up and play our initial sound
    // If we play the buffer with the EGs disabled (as they are by
    // default), then changing the EG's after playback started 
    // wouldn't have any affect.  Therefore, set the EG's BEFORE
    // starting playback
    m_pDSBuffer->SetEG( &m_adsedEG[0] );
    m_pDSBuffer->SetEG( &m_adsedEG[1] );
    m_dwCurrent = 0;
    m_bPlaying = TRUE;
    m_bLooping = TRUE;
    SwitchToSound( m_dwCurrent );

    // Clean up our memory allocations
    delete[] pwfFirst;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Reallocate the sample data buffer
//       3) Point the DirectSoundBuffer to the new data
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    DWORD dwNewSize;
    DWORD dwLoopStartSample, dwLoopLengthSamples;
    DWORD cbLoopStart, cbLoopLength;

    // If we're currently playing, stop, so that we don't crash
    // when we reallocate our buffer
    if( m_bPlaying )
    {
        m_pDSBuffer->Stop();
    }

    // Calling stop doesn't immediately shut down
    // the voice, so point it away from our buffer
    m_pDSBuffer->SetBufferData( NULL, 0 );

    // Find out how big the new sample is
    m_awfSounds[ dwIndex ].GetDuration( &dwNewSize );

    // Set our allocation to that size
    if( m_pbSampleData )
        delete[] m_pbSampleData;
    m_pbSampleData = new BYTE[ dwNewSize ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

    // Read sample data from the file
    m_awfSounds[ dwIndex ].ReadSample( 0, m_pbSampleData, dwNewSize, &dwNewSize );

    // Check for embedded loop points
    if( SUCCEEDED( m_awfSounds[ dwIndex ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
    {
        WAVEFORMATEX wfx;

        // We're not interested in the whole wave format, which is
        // why we can get away with just loading the core WAVEFORMATEX
        m_awfSounds[ dwIndex ].GetFormat( &wfx, sizeof( WAVEFORMATEX ) );

        // We need to convert the loop points from sample counts to
        // byte offsets, but it's slightly different between PCM and ADPCM
        if( wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
        {
            // For ADPCM, calculate # of blocks and multiply that
            // by bytes per block.  Xbox ADPCM is always 64 samples
            // per block.
            cbLoopStart = dwLoopStartSample / 64 * wfx.nBlockAlign;
            cbLoopLength = dwLoopLengthSamples / 64 * wfx.nBlockAlign;
        }
        else
        {
            // For PCM, multiply by bytes per sample
            DWORD cbBytesPerSample = wfx.nChannels * wfx.wBitsPerSample / 8;
            cbLoopStart = dwLoopStartSample * cbBytesPerSample;
            cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
        }
    }
    else
    {
        // Otherwise, just loop the whole file
        cbLoopStart = 0;
        cbLoopLength = dwNewSize;
    }


    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( cbLoopStart, cbLoopLength );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // If we were playing before, restart playback now
    if( m_bPlaying )
    {
        m_pDSBuffer->Play( 0, 0, m_bLooping ? DSBPLAY_LOOPING : 0 );
    }

    return S_OK;
}


#define VOLUME_SCALE 5.0f
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Check if buffer is still playing
    DWORD dwStatus;
    m_pDSBuffer->GetStatus( &dwStatus );
    m_bPlaying = dwStatus & DSBSTATUS_PLAYING;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
        {
            m_pDSBuffer->StopEx( 0, DSBSTOPEX_ENVELOPE );
        }
        else
        {
            // Start playback at beginning of buffer
            m_pDSBuffer->SetCurrentPosition( 0 );
            m_pDSBuffer->Play( 0, 0, m_bLooping ? DSBPLAY_LOOPING : 0 );
            m_bPlaying = TRUE;
        }
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
        SwitchToSound( m_dwCurrent );
    }

    // Cycle through EnvelopeDesc parameters
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        do {
            m_dwParam = ( m_dwParam + NUM_OPTIONS - 1 ) % NUM_OPTIONS;
        } while ( g_aOptions[ m_dwParam ].bEG2 && m_dwEG == 0 );
    }
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        do {
            m_dwParam = ( m_dwParam + 1 ) % NUM_OPTIONS;
        } while ( g_aOptions[ m_dwParam ].bEG2 && m_dwEG == 0 );
    }

    // Switch between EGs
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_dwEG ^= 1;

        // If we were on an EG2-only param, change to first param
        if( m_dwEG == 0 && g_aOptions[ m_dwParam ].bEG2 ) {

            m_dwParam = 0;
        }
            
    }

    // Adjust value of currently selected parameter, making
    // sure to keep it within the appropriate range
    LONG * plValue = (LONG *)((BYTE *)&m_adsedEG[ m_dwEG ] + g_aOptions[ m_dwParam ].dwOffset);
    LONG lDelta = LONG(m_DefaultGamepad.fX2 * m_fElapsedTime * 100 * m_fAcceleration);

    if( lDelta == 0 )
    {
        // Reset acceleration
        m_fAcceleration = 1.0f;
    }
    else
    {
        if( lDelta < 0 && *plValue + lDelta < g_aOptions[ m_dwParam ].dwMinValue )
            lDelta = g_aOptions[ m_dwParam ].dwMinValue - *plValue;
        else if( lDelta > 0 && *plValue + lDelta > g_aOptions[ m_dwParam ].dwMaxValue )
            lDelta = g_aOptions[ m_dwParam ].dwMaxValue - *plValue;

        // Adjust acceleration factor
        m_fAcceleration += 0.03f;
    }

    // Write out the new value
    *plValue += lDelta;

    // Toggle looping
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bLooping = !m_bLooping;

        // If we were playing, make another call to play to change looping
        if( m_bPlaying )
            m_pDSBuffer->Play( 0, 0, m_bLooping ? DSBPLAY_LOOPING : 0 );
    }


    //
    // To use Filtercutoff in the MULTI EG, we need to set the DLS2 lowpass filter in 
    // the hardware to some reasonable values otherwise when we try to change the 
    // FilterCutoff, nothing will happen. FilterCutoff is relative to the resonant 
    // frequency we set below.  We set both pairs of coefficients to the same value
    // to handle stereo buffers, since we don't plan to use ParamEQ.
    // However, we don't want to use the filter unless we're actually using the
    // FilterCutOff in the EG, otherwise we'll lowpass filter ALL sounds
    //
    DSFILTERDESC            dsfd = {0};

    if( m_adsedEG[1].lFilterCutOff == 0 )
        dsfd.dwMode = DSFILTER_MODE_BYPASS;
    else
        dsfd.dwMode = DSFILTER_MODE_DLS2;
    dsfd.adwCoefficients[0] = 0xE283; // ~4kHz
    dsfd.adwCoefficients[1] = 0x8FF5; // ~3dB
    dsfd.adwCoefficients[2] = 0xE283; // ~4kHz
    dsfd.adwCoefficients[3] = 0x8FF5; // ~3dB
    m_pDSBuffer->SetFilter( &dsfd );

    // Update settings
    m_pDSBuffer->SetVolume( m_lVolume );
    m_pDSBuffer->SetEG( &m_adsedEG[0] );
    m_pDSBuffer->SetEG( &m_adsedEG[1] );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff402040, 0xff404040 );

    // Draw a graph of the envelope
    DrawEnvelope();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"EnvelopeGenerator" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S %s", g_aszFileNames[ m_dwCurrent ], m_bLooping ? L"(looping)" : L"" );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF808080, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 130, 0xFFFFFF00, szBuff );
        for( int i = 0; i < sizeof( g_aOptions ) / sizeof( g_aOptions[0] ); i++ )
        {
            // For each valid option, print out name and value
            if( m_dwEG != 0 || !g_aOptions[i].bEG2 )
            {
                swprintf( szBuff, L"EG%d %s: %d", m_dwEG + 1, g_aOptions[ i ].szDescription, *(LONG *)((BYTE *)&m_adsedEG[ m_dwEG ] + g_aOptions[ i ].dwOffset) );
                m_Font.DrawText( 64, FLOAT(160 + i * 30), i == m_dwParam ? 0xFFFFFFFF : 0xFFFFFF00, szBuff );
            }
        }
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}



#define ENV_XMIN 320
#define ENV_XMAX 580
#define ENV_YMIN 200
#define ENV_YMAX 400
#define ENV_XRANGE ( ENV_XMAX - ENV_XMIN )
#define ENV_YRANGE ( ENV_YMAX - ENV_YMIN )

//-----------------------------------------------------------------------------
// Name: DrawEnvelope
// Desc: Draws a graph of the envelope
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::DrawEnvelope()
{
    D3DXVECTOR4 ap[7];
    WAVEFORMATEX wfx;
    DWORD dwSize;
    FLOAT fDuration;

    // Calculate EG values in seconds
    FLOAT fDelay  = m_adsedEG[ m_dwEG ].dwDelay  * 512 / 48000.0f;
    FLOAT fAttack = m_adsedEG[ m_dwEG ].dwAttack * 512 / 48000.0f;
    FLOAT fHold   = m_adsedEG[ m_dwEG ].dwHold   * 512 / 48000.0f;
    FLOAT fDecay  = m_adsedEG[ m_dwEG ].dwDecay  * 512 / 48000.0f;
    FLOAT fSustain= m_adsedEG[ m_dwEG ].dwSustain / 255.0f;
    FLOAT fRelease= m_adsedEG[ m_dwEG ].dwRelease * 512 / 48000.0f;

    // Calculate length of sound in seconds
    m_awfSounds[ m_dwCurrent ].GetFormat( &wfx, sizeof( WAVEFORMATEX ) );
    m_awfSounds[ m_dwCurrent ].GetDuration( &dwSize );
    fDuration = ((float)dwSize) / (float)wfx.nAvgBytesPerSec;

    // Scale over the total length of the envelope
    FLOAT fTotal = fDelay + fAttack + fHold + fDecay + fDuration + fRelease;
    
    // Set vertices for graph
    ap[0] = D3DXVECTOR4( ENV_XMIN, ENV_YMAX, 0.0f, 1.0f );
    ap[1] = D3DXVECTOR4( ap[0].x + fDelay / fTotal * ENV_XRANGE, ENV_YMAX, 0.0f, 1.0f );
    ap[2] = D3DXVECTOR4( ap[1].x + fAttack / fTotal * ENV_XRANGE, ENV_YMIN, 0.0f, 1.0f );
    ap[3] = D3DXVECTOR4( ap[2].x + fHold / fTotal * ENV_XRANGE, ENV_YMIN, 0.0f, 1.0f );
    ap[4] = D3DXVECTOR4( ap[3].x + fDecay / fTotal * ( 1.0f - fSustain ) * ENV_XRANGE, ENV_YMAX - fSustain * ENV_YRANGE, 0.0f, 1.0f );
    ap[5] = D3DXVECTOR4( ENV_XMAX - fRelease / fTotal * fSustain * ENV_XRANGE, ENV_YMAX - fSustain * ENV_YRANGE, 0.0f, 1.0f );
    ap[6] = D3DXVECTOR4( ENV_XMAX, ENV_YMAX, 0.0f, 1.0f );

    // Draw the graph
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xFFFFFF00 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, 6, ap, sizeof( D3DXVECTOR4 ) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\FileStream.h ===
//-----------------------------------------------------------------------------
// File: FileStream.h
//
// Desc: Streaming wave file playback.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef FILESTREAM_H
#define FILESTREAM_H




// Define the maximum amount of packets we will ever submit to the renderer
#define FILESTRM_PACKET_COUNT 3




// This value is hard-coded assuming an ADPCM frame of 36 samples and 16
// bit stereo (128 ADPCM frames per packet)
#define FILESTRM_PACKET_BYTES 2 * 2 * 36 * 128


// ThreadProc for worker thread
DWORD WINAPI WAVFileStreamThreadProc( LPVOID lpParameter );


//-----------------------------------------------------------------------------
// Name: class CWaveFileStream
// Desc: Wave file streaming object
//-----------------------------------------------------------------------------
class CWaveFileStream
{
protected:
    XFileMediaObject*   m_pSourceFilter;                          // Source (wave file) filter
    IDirectSoundStream* m_pRenderFilter;                          // Render (DirectSoundStream) filter
    LPVOID              m_pvSourceBuffer;                         // Source filter data buffer
    DWORD               m_adwPacketStatus[FILESTRM_PACKET_COUNT]; // Packet status array
    DWORD               m_dwFileLength;                           // File duration, in bytes
    DWORD               m_dwFileProgress;                         // File progress, in bytes

    DWORD *             m_pdwPercentCompleted;                    // Pointer to percentage completed

    // Packet processing
    BOOL    FindFreePacket(DWORD* pdwPacketIndex );
    HRESULT ProcessSource( DWORD dwPacketIndex );
    HRESULT ProcessRenderer( DWORD dwPacketIndex );

public:
    // Processing
    HRESULT Process();

    // Initialization
    HRESULT Initialize( const CHAR* strFileName, DWORD * pdwPercentCompleted );

    // Play control
    VOID Pause( DWORD dwPause );
    
    CWaveFileStream();
    ~CWaveFileStream();
};




#endif // FILESTREAMM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\FileStream.cpp ===
//-----------------------------------------------------------------------------
// File: FileStream.cpp
//
// Desc: Class for streaming wave file playback.
//
// Hist: 12.15.00 - New for December XDK release
//       05.07.01 - Updated for hardware ADPCM
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "FileStream.h"




//-----------------------------------------------------------------------------
// Debugging help
//-----------------------------------------------------------------------------
#define MY_ASSERT(x) if( !(x) ) _asm int 3;

BOOL g_bDoDebugChecks = TRUE;




//-----------------------------------------------------------------------------
// Name: CWaveFileStream()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWaveFileStream::CWaveFileStream()
{
    m_pSourceFilter    = NULL;
    m_pRenderFilter    = NULL;
    m_pvSourceBuffer   = NULL;
    
    for( DWORD i = 0; i < FILESTRM_PACKET_COUNT; i++ )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;

    m_dwFileLength   = 0;
    m_dwFileProgress = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CWaveFileStream()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWaveFileStream::~CWaveFileStream()
{
    if( m_pSourceFilter )      m_pSourceFilter->Release();
    if( m_pRenderFilter )      m_pRenderFilter->Release();
    if( m_pvSourceBuffer )     XPhysicalFree( m_pvSourceBuffer );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the wave file streaming subsystem.
//-----------------------------------------------------------------------------
HRESULT CWaveFileStream::Initialize( const CHAR* strFileName, DWORD * pdwPercentCompleted )
{
    LPCWAVEFORMATEX pwfxSourceFormat;
    DSSTREAMDESC    dssd;
    HRESULT         hr;

    m_pdwPercentCompleted = pdwPercentCompleted;
    
    // Create the source (wave file) filter
    hr = XWaveFileCreateMediaObject( strFileName, &pwfxSourceFormat, &m_pSourceFilter );
    if( FAILED(hr) )
        return hr;

    // For this sample, we're expecting an Xbox ADPCM wav file, but
    // normal PCM would be just fine.
    MY_ASSERT( WAVE_FORMAT_XBOX_ADPCM == pwfxSourceFormat->wFormatTag );

    // Create the render (DirectSoundStream) filter
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwMaxAttachedPackets = FILESTRM_PACKET_COUNT;
    dssd.lpwfxFormat          = (LPWAVEFORMATEX)pwfxSourceFormat;

    hr = DirectSoundCreateStream( &dssd, &m_pRenderFilter );
    if( FAILED(hr) )
        return hr;

    if( g_bDoDebugChecks )
    {
        XMEDIAINFO xmi;

        // We expect the source filter to be synchronous and read-only and the 
        // render filter to be asynchronous write-only.  Assert that all of
        // this is true and check the packet sizes for compatibility.

        hr = m_pSourceFilter->GetInfo( &xmi );
        if( FAILED(hr) )
            return hr;
        MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_FIXED_SAMPLE_SIZE) );
        MY_ASSERT( !xmi.dwMaxLookahead );
        MY_ASSERT( !xmi.dwInputSize );
        MY_ASSERT( !(FILESTRM_PACKET_BYTES % xmi.dwOutputSize) );

        hr = m_pRenderFilter->GetInfo( &xmi );
        if( FAILED(hr) )
            return hr;
        MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC) );
        MY_ASSERT( FILESTRM_PACKET_BYTES * FILESTRM_PACKET_COUNT >= xmi.dwMaxLookahead );
        MY_ASSERT( !(FILESTRM_PACKET_BYTES % xmi.dwInputSize) );
        MY_ASSERT( !xmi.dwOutputSize );
    }

    // Allocate data buffers.  The render filter, however, is asynchronous, 
    // so we'll have to allocate enough space to hold all the packets that 
    // could be submitted at any given time.
    m_pvSourceBuffer = XPhysicalAlloc( FILESTRM_PACKET_BYTES * FILESTRM_PACKET_COUNT,
                                       MAXULONG_PTR,
                                       0,
                                       PAGE_READWRITE | PAGE_NOCACHE );
    if( NULL == m_pvSourceBuffer )
        return E_OUTOFMEMORY;

    // Get the total wave file size.  We'll use this to calculate how far
    // along in the file we are during processing.
    hr = m_pSourceFilter->GetLength( &m_dwFileLength );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Performs any work necessary to keep the stream playing.
//-----------------------------------------------------------------------------
HRESULT CWaveFileStream::Process()
{
    DWORD   dwPacketIndex;
    HRESULT hr;
    
    // Find a free packet.  If there's none free, we don't have anything
    // to do
    while( FindFreePacket( &dwPacketIndex ) )
    {
        // Read from the source filter
        hr = ProcessSource( dwPacketIndex );
        if( FAILED(hr) )
            return hr;
        
        // Send the data to the renderer
        hr = ProcessRenderer( dwPacketIndex );
        if( FAILED(hr) )
            return hr;
    }

    // Calculate the completion percentage based on the total amount of
    // data we've read from the source.
    if( m_pdwPercentCompleted )
        (*m_pdwPercentCompleted) = m_dwFileProgress * 100 / m_dwFileLength;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket()
// Desc: Finds a render packet available for processing.
//-----------------------------------------------------------------------------
BOOL CWaveFileStream::FindFreePacket( DWORD* pdwPacketIndex )
{
    for( DWORD dwPacketIndex = 0; dwPacketIndex < FILESTRM_PACKET_COUNT; dwPacketIndex++ )
    {
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[dwPacketIndex] )
        {
            if( pdwPacketIndex )
                (*pdwPacketIndex) = dwPacketIndex;

            return TRUE;
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessSource()
// Desc: Reads data from the source filter.
//-----------------------------------------------------------------------------
HRESULT CWaveFileStream::ProcessSource( DWORD dwPacketIndex )
{
    DWORD        dwTotalSourceUsed   = 0;
    DWORD        dwSourceUsed;
    XMEDIAPACKET xmp;
    HRESULT      hr;
    
    // We're going to read a full packet's worth of data into the source
    // buffer.  Since we're playing in an infinite loop, we'll just spin
    // until we've read enough data, even if that means wrapping around the
    // end of the file.

    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer         = (BYTE *)m_pvSourceBuffer + dwPacketIndex * FILESTRM_PACKET_BYTES;
    xmp.dwMaxSize        = FILESTRM_PACKET_BYTES;
    xmp.pdwCompletedSize = &dwSourceUsed;

    while( dwTotalSourceUsed < FILESTRM_PACKET_BYTES )
    {
        // Read from the source
        hr = m_pSourceFilter->Process(NULL, &xmp);
        if( FAILED(hr) )
            return hr;

        // Add the amount read to the total
        dwTotalSourceUsed += dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
            hr = m_pSourceFilter->Seek( 0, FILE_BEGIN, NULL );
            if( FAILED(hr) )
                return hr;
        };
    }

    // Update the file progress
    m_dwFileProgress += dwTotalSourceUsed;
    m_dwFileProgress %= m_dwFileLength;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessRenderer()
// Desc: Sends data to the renderer.
//-----------------------------------------------------------------------------
HRESULT CWaveFileStream::ProcessRenderer( DWORD dwPacketIndex )
{
    XMEDIAPACKET xmp;
    HRESULT      hr;

    // There's a full packet's worth of data ready for us to send to the
    // renderer.  We want to track the status of this packet since the
    // render filter is asychronous and we need to know when the packet is
    // completed.
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer  = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * FILESTRM_PACKET_BYTES);
    xmp.dwMaxSize = FILESTRM_PACKET_BYTES;
    xmp.pdwStatus = &m_adwPacketStatus[dwPacketIndex];

    hr = m_pRenderFilter->Process( &xmp, NULL );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Pause
// Desc: Pauses or resumes stream playback
//-----------------------------------------------------------------------------
VOID
CWaveFileStream::Pause( DWORD dwPause )
{
    m_pRenderFilter->Pause( dwPause );
}



//-----------------------------------------------------------------------------
// Name: WAVFileStreamThreadProc
// Desc: Thread proc for sound processing worker thread
//-----------------------------------------------------------------------------
DWORD WINAPI WAVFileStreamThreadProc( LPVOID lpParameter )
{
    /*
    // To process approximately once per frame, we can sleep
    // for 1000 ms / 60 fps between calls to Process.
    */
    DWORD dwQuantum = 1000 / 60;

    /*
    // Alternately, the minimum time between processing is
    // determined by how much data we're sending to the stream
    // at once:
    // 2048 * 16 samples per packet * 16 packets = 524288 samples
    // 524288 samples / 44100 samples per second = 11.8 seconds
    //
    // DWORD dwQuantum = 11000;
    */

    CWaveFileStream * pThis = (CWaveFileStream *)lpParameter;

    for( ; ; )
    {
        pThis->Process();
        Sleep( dwQuantum );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\filestream\main.cpp ===
//-----------------------------------------------------------------------------
// File: Main.cpp
//
// Desc: Simple app to play a streaming sound and render the percent completion
//       of the sound.  Processes synchronously on a worker thread
//
// Hist: 12.15.00 - New for December XDK release
//       05.07.01 - Updated for hardware ADPCM and to spin a worker thread
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include "FileStream.h"
#include "dsstdfx.h"



//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Pause" },
};

#define NUM_HELP_CALLOUTS 2


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CWaveFileStream m_Stream;        // WAV file XMO

    CXBFont         m_Font;          // A font to render text
    CXBHelp         m_Help;          // Help object
    BOOL            m_bDrawHelp;     // Should we draw help?
    HRESULT         m_hOpenResult;   // Error code from WMAStream::Initialize()
    HANDLE          m_hWorkerThread; // Worker thread
    DWORD           m_dwPercentCompleted;   // Percentage of file processed
    BOOL            m_bPaused;       // Paused?

    LPDIRECTSOUND8  m_pDSound;       // DirectSound object

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Performs all initialization needed to run the sample
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the wav file stream
    m_hOpenResult = m_Stream.Initialize( "D:\\media\\sounds\\becky_xbadpcm.wav", &m_dwPercentCompleted );

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;
    m_bPaused = FALSE;

    m_dwPercentCompleted = 0;

    if( !FAILED( m_hOpenResult ) )
    {
        // Create worker thread to process audio
        m_hWorkerThread = CreateThread( NULL, 0, WAVFileStreamThreadProc, &m_Stream, 0, NULL );
        if( m_hWorkerThread == NULL )
            return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Called once per frame to update state
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle pause
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_bPaused = !m_bPaused;
        m_Stream.Pause( m_bPaused ? DSSTREAMPAUSE_PAUSE : DSSTREAMPAUSE_RESUME );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render the scene (which is just the progress bar)
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );

    // Process the streaming sound
    DirectSoundDoWork();

    // If didn't open the wav file
    if( FAILED( m_hOpenResult ) )
    {
        WCHAR strFailure[128];
        wsprintfW( strFailure, L"Failed to load wav; HRESULT: 0x%X", m_hOpenResult );
        m_Font.DrawText( 64,  50, 0xffffffff, strFailure );
    }
    else
    {
        // Show title, frame rate, and help
        if( m_bDrawHelp )
            m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
        else
        {
            // Draw the text
            m_Font.DrawText( 64,  50, 0xffffffff, L"FileStream" );
        }
        WCHAR sz[100];
        swprintf( sz, L"Progress: %s", m_bPaused ? L"(Paused)" : L"" );
        m_Font.DrawText( 64, 375, 0xffffff00, sz);


        // Render a simple progress bar to show the percent completed
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[8];
        FLOAT x1 =  64, x2 = x1 + (512*m_dwPercentCompleted)/100, x3 = 64+512;
        FLOAT y1 = 400, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffff00;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffff00;
        v[2].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffffff00;
        v[3].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffffff00;
        v[4].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[4].color = 0xff8080ff;
        v[5].p = D3DXVECTOR4( x3-0.5f, y1-0.5f, 1.0f, 1.0f );  v[5].color = 0xff8080ff;
        v[6].p = D3DXVECTOR4( x3-0.5f, y2-0.5f, 1.0f, 1.0f );  v[6].color = 0xff8080ff;
        v[7].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[7].color = 0xff8080ff;

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 2, v, sizeof(v[0]) );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\multipass.h ===
typedef enum _DSP_IMAGE_DSSTDFX_FX_INDICES {
    I3DL2_CHAIN_I3DL2_REVERB = 0,
    I3DL2_CHAIN_XTALK = 1,
    CHORUS_CHAIN_CHORUS = 2,
    FLANGE_CHAIN_FLANGE = 3,
    AMPMOD_CHAIN_AMPMOD = 4,
    ECHO_CHAIN_ECHO = 5,
    IIR2_CHAIN_IIR2_LEFT = 6,
    IIR2_CHAIN_IIR2_RIGHT = 7,
    REVERB_CHAIN_MINI_REVERB = 8,
    MULTIPASS_ECHO_CHAIN_ECHO = 9
} DSP_IMAGE_DSSTDFX_FX_INDICES;

typedef struct _I3DL2_CHAIN_FX0_I3DL2_REVERB_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[35];     // XRAM offsets in DSP WORDS, of output mixbins
} I3DL2_CHAIN_FX0_I3DL2_REVERB_STATE, *LPI3DL2_CHAIN_FX0_I3DL2_REVERB_STATE;

typedef const I3DL2_CHAIN_FX0_I3DL2_REVERB_STATE *LPCI3DL2_CHAIN_FX0_I3DL2_REVERB_STATE;

typedef struct _I3DL2_CHAIN_FX1_XTALK_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[4];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[4];     // XRAM offsets in DSP WORDS, of output mixbins
} I3DL2_CHAIN_FX1_XTALK_STATE, *LPI3DL2_CHAIN_FX1_XTALK_STATE;

typedef const I3DL2_CHAIN_FX1_XTALK_STATE *LPCI3DL2_CHAIN_FX1_XTALK_STATE;

typedef struct _CHORUS_CHAIN_FX0_CHORUS_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} CHORUS_CHAIN_FX0_CHORUS_STATE, *LPCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef const CHORUS_CHAIN_FX0_CHORUS_STATE *LPCCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef struct _FLANGE_CHAIN_FX0_FLANGE_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} FLANGE_CHAIN_FX0_FLANGE_STATE, *LPFLANGE_CHAIN_FX0_FLANGE_STATE;

typedef const FLANGE_CHAIN_FX0_FLANGE_STATE *LPCFLANGE_CHAIN_FX0_FLANGE_STATE;

typedef struct _AMPMOD_CHAIN_FX0_AMPMOD_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_CHAIN_FX0_AMPMOD_STATE, *LPAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef const AMPMOD_CHAIN_FX0_AMPMOD_STATE *LPCAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef struct _ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} ECHO_CHAIN_FX0_ECHO_STATE, *LPECHO_CHAIN_FX0_ECHO_STATE;

typedef const ECHO_CHAIN_FX0_ECHO_STATE *LPCECHO_CHAIN_FX0_ECHO_STATE;

typedef struct _IIR2_CHAIN_FX0_IIR2_LEFT_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} IIR2_CHAIN_FX0_IIR2_LEFT_STATE, *LPIIR2_CHAIN_FX0_IIR2_LEFT_STATE;

typedef const IIR2_CHAIN_FX0_IIR2_LEFT_STATE *LPCIIR2_CHAIN_FX0_IIR2_LEFT_STATE;

typedef struct _IIR2_CHAIN_FX1_IIR2_RIGHT_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} IIR2_CHAIN_FX1_IIR2_RIGHT_STATE, *LPIIR2_CHAIN_FX1_IIR2_RIGHT_STATE;

typedef const IIR2_CHAIN_FX1_IIR2_RIGHT_STATE *LPCIIR2_CHAIN_FX1_IIR2_RIGHT_STATE;

typedef struct _REVERB_CHAIN_FX0_MINI_REVERB_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[12];     // XRAM offsets in DSP WORDS, of output mixbins
} REVERB_CHAIN_FX0_MINI_REVERB_STATE, *LPREVERB_CHAIN_FX0_MINI_REVERB_STATE;

typedef const REVERB_CHAIN_FX0_MINI_REVERB_STATE *LPCREVERB_CHAIN_FX0_MINI_REVERB_STATE;

typedef struct _MULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} MULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE, *LPMULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE;

typedef const MULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE *LPCMULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\fxmultipass.cpp ===
//-----------------------------------------------------------------------------
// File: FXMultiPass.cpp
//
// Desc: This sample demonstrates how to use the GP multipass audio processing
//       capabilities of DirectSound on the Xbox.  Several standard DirectSound
//       buffers are created, processed by the audio hardware, and their output 
//       is routed to a 3D Buffer, which is then positioned.
//       This is different from the MultiPass sample because the source buffers
//       go through the GP and can have DSP effects applied before being mixed
//       into the 3D FXIn buffer.
//
// Hist: 06.29.01 - New for August Release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include "dsound.h"
#include "multipass.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle Headphones" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
};

#define NUM_HELP_CALLOUTS 9



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\heli.wav",
    "D:\\Media\\Sounds\\DockingMono.wav",
    "D:\\Media\\Sounds\\EngineStartMono.wav",
    "D:\\Media\\Sounds\\MaleDialog1.wav",
    "D:\\Media\\Sounds\\MiningMono.wav",
    "D:\\Media\\Sounds\\MusicMono.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
};

#define NUM_SOUNDS 7

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    // Sound members
    DWORD                   m_dwCurrent;            // Current sound
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object
    LPDIRECTSOUNDBUFFER8    m_pDS3DBuffer;            // 3D DirectSoundBuffer

    BOOL                    m_bPlaying[NUM_SOUNDS];     // Is buffer playing?
    LONG                    m_lVolume[NUM_SOUNDS];      // Buffer volume
    CWaveFile               m_awfSounds[NUM_SOUNDS];    // Wave file parsers
    LPDIRECTSOUNDBUFFER8    m_apBuffers[NUM_SOUNDS];    // Non-3D Buffers
    BYTE *                  m_pbSampleData[NUM_SOUNDS]; // Sample data from wavs
    BOOL                    m_bHeadphones;              // True if headphones enabled

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    HRESULT CXBoxSample::LoadSounds();              // Loads list of wav files
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_bHeadphones = FALSE;

    // Set up sounds
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        m_lVolume[i] = DSBVOLUME_MAX;
        m_pbSampleData[i] = NULL;
        m_apBuffers[i] = NULL;
    }


    // Positions
    m_vSourcePosition    = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}


//-----------------------------------------------------------------------------
// Name: LoadSounds
// Desc: Creates a DirectSound Buffer for each wav file and reads the sample
//       data from the wav file.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::LoadSounds()
{
    //
    // Create buffers for each of our sound effects and load
    // the sample data from the wav files
    //
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        DWORD           cbFormat;
        WAVEFORMATEX *  pwfx;
        DSBUFFERDESC    dsbdesc;
        DSMIXBINS       dsmixbins;
        DWORD           dwDuration;
        DWORD           dwLoopStartSample, dwLoopLengthSamples;
        DWORD           cbLoopStart, cbLoopLength;

        if( FAILED( m_awfSounds[ i ].Open( g_aszFileNames[i] ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Allocate space for the wave format
        m_awfSounds[ i ].GetFormat( NULL, 0, &cbFormat );
        pwfx = (WAVEFORMATEX *)new BYTE[ cbFormat ];

        if( FAILED( m_awfSounds[ i ].GetFormat( pwfx, cbFormat ) ) )
            return E_FAIL;

        //
        // Create a sound buffer of 0 size, since we're going to use
        // SetBufferData
        //
        ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
        dsbdesc.dwSize = sizeof( DSBUFFERDESC );
        
        /* If fewer than 256 buffers are in existence at all points during 
           the game, it may be more efficient not to use LOCDEFER. */
        // dsbdesc.dwFlags = 0;
        dsbdesc.dwFlags = DSBCAPS_LOCDEFER;
        dsbdesc.dwBufferBytes = 0;
        dsbdesc.lpwfxFormat = pwfx;
        dsbdesc.lpMixBins = &dsmixbins;

        // Set mixbin count to 0 so the sound is only sent to the submix
        // and not to any other mixbins.
        dsmixbins.dwMixBinCount = 0;

        if( FAILED( m_pDSound->CreateSoundBuffer( &dsbdesc, &m_apBuffers[i], NULL ) ) )
            return E_FAIL;

        // Find out how big the sample is
        m_awfSounds[i].GetDuration( &dwDuration );

        // Allocate a buffer for this sound
        m_pbSampleData[i] = (BYTE *)XPhysicalAlloc( dwDuration, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE );
        if( !m_pbSampleData[i] )
            return E_OUTOFMEMORY;

        // Read sample data from the file
        m_awfSounds[i].ReadSample( 0, m_pbSampleData[i], dwDuration, &dwDuration );

        // Check for embedded loop points
        if( SUCCEEDED( m_awfSounds[ i ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
        {
            // We need to convert the loop points from sample counts to
            // byte offsets, but it's slightly different between PCM and ADPCM
            if( pwfx->wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
            {
                // For ADPCM, calculate # of blocks and multiply that
                // by bytes per block.  Xbox ADPCM is always 64 samples
                // per block.
                cbLoopStart = dwLoopStartSample / 64 * pwfx->nBlockAlign;
                cbLoopLength = dwLoopLengthSamples / 64 * pwfx->nBlockAlign;
            }
            else
            {
                // For PCM, multiply by bytes per sample
                DWORD cbBytesPerSample = pwfx->nChannels * pwfx->wBitsPerSample / 8;
                cbLoopStart = dwLoopStartSample * cbBytesPerSample;
                cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
            }
        }
        else
        {
            // Otherwise, just loop the whole file
            cbLoopStart = 0;
            cbLoopLength = dwDuration;
        }

        // Set up values for the new buffer
        m_apBuffers[i]->SetBufferData( m_pbSampleData[i], dwDuration );
        m_apBuffers[i]->SetLoopRegion( cbLoopStart, cbLoopLength );
        m_apBuffers[i]->SetCurrentPosition( 0 );

        // Set initial values for the buffer
        m_bPlaying[i] = FALSE;
        m_lVolume[i] = DSBVOLUME_MAX;
        m_apBuffers[i]->SetVolume( m_lVolume[i] );
        m_apBuffers[i]->SetOutputBuffer( m_pDS3DBuffer );

        delete[] pwfx;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the app
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    //
    // Download our modified DSP effects image, which contains the
    // multipass echo chain
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\multipass.bin") ) )
        return E_FAIL;

    // Set up 3d Buffer desc
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwFlags = DSBCAPS_FXIN | DSBCAPS_CTRL3D;
    dsbd.dwInputMixBin = DSMIXBIN_FXSEND_13;
    dsbd.lpwfxFormat = NULL;
    if( FAILED( m_pDSound->CreateSoundBuffer( &dsbd, &m_pDS3DBuffer, NULL ) ) )
        return E_FAIL;

    // Set submix mixbin headroom to 0 to prevent over-attenuation
    m_pDSound->SetMixBinHeadroom( dsbd.dwInputMixBin, 0 );

    // Create and initialize our individual sound buffers
    if( FAILED( LoadSounds() ) )
        return E_FAIL;

    //
    // Set the transform matrices
    //
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    //
    // Create our vertex buffers
    //
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();

    // Set up and play our initial sound
    m_dwCurrent = 0;
    m_bPlaying[0] = TRUE;
    m_apBuffers[0]->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX *     pVertices;
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume[m_dwCurrent] += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                                    m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                                    m_fElapsedTime * 
                                    VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume[m_dwCurrent] < DSBVOLUME_MIN )
        m_lVolume[m_dwCurrent] = DSBVOLUME_MIN;
    else if( m_lVolume[m_dwCurrent] > DSBVOLUME_MAX )
        m_lVolume[m_dwCurrent] = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying[m_dwCurrent] )
            m_apBuffers[m_dwCurrent]->Stop( );
        else
            m_apBuffers[m_dwCurrent]->Play( 0, 0, DSBPLAY_LOOPING );

        m_bPlaying[m_dwCurrent] = !m_bPlaying[m_dwCurrent];
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    // Toggle headphones
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_bHeadphones = !m_bHeadphones;
        m_pDSound->EnableHeadphones( m_bHeadphones );
    }

    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    //
    // Move selected object and clamp to the appropriate range
    //
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    //
    // Update source/listener vertex buffers
    //
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cSource;
    pVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cSource;
    pVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cSource;
    pVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cSource;
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cListener;
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cListener;
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cListener;
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cListener;
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    //
    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    // We scale the velocities by 2 so that doppler effect
    // is a bit more noticable.
    //
    D3DXVECTOR3 vListenerVelocity = 2.0f * ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = 2.0f * ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;

    // Source position/velocity/volume
    m_pDS3DBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    m_pDS3DBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );
    m_apBuffers[m_dwCurrent]->SetVolume( m_lVolume[m_dwCurrent] );

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the source
    m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

		m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"FXMultiPass" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying[m_dwCurrent] ? 0xFFFFFFFF : 0xFF808080, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume[m_dwCurrent] / 100, 100.0f * ( m_lVolume[m_dwCurrent] - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
        if( m_bHeadphones )
            m_Font.DrawText( 64, 220, 0xFFFFFF00, L"Headphones enabled");
        else
            m_Font.DrawText( 64, 220, 0x80808000, L"Headphones disabled");

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\image.h ===
typedef enum _DSP_IMAGE_MY_FIRST_GRAPH_FX_INDICES {
    OSCILLATOR_CHAIN_OSCILLATOR = 0,
    DISTORTION_CHAIN_DISTORTION0 = 1,
    DISTORTION_CHAIN_DISTORTION1 = 2,
    CHORUS_CHAIN_CHORUS = 3,
    AMPMOD_FLANGE_CHAIN_AMPMOD = 4,
    AMPMOD_FLANGE_CHAIN_FLANGE = 5,
    ECHO_CHAIN_ECHO = 6
} DSP_IMAGE_MY_FIRST_GRAPH_FX_INDICES;

typedef struct _OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwOutMixbinPtrs[4];     // XRAM offsets in DSP WORDS, of output mixbins
} OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE, *LPOSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE;

typedef const OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE *LPCOSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE;

typedef struct _DISTORTION_CHAIN_FX0_DISTORTION0_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} DISTORTION_CHAIN_FX0_DISTORTION0_STATE, *LPDISTORTION_CHAIN_FX0_DISTORTION0_STATE;

typedef const DISTORTION_CHAIN_FX0_DISTORTION0_STATE *LPCDISTORTION_CHAIN_FX0_DISTORTION0_STATE;

typedef struct _DISTORTION_CHAIN_FX1_DISTORTION1_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} DISTORTION_CHAIN_FX1_DISTORTION1_STATE, *LPDISTORTION_CHAIN_FX1_DISTORTION1_STATE;

typedef const DISTORTION_CHAIN_FX1_DISTORTION1_STATE *LPCDISTORTION_CHAIN_FX1_DISTORTION1_STATE;

typedef struct _CHORUS_CHAIN_FX0_CHORUS_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} CHORUS_CHAIN_FX0_CHORUS_STATE, *LPCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef const CHORUS_CHAIN_FX0_CHORUS_STATE *LPCCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef struct _AMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE, *LPAMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE;

typedef const AMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE *LPCAMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE;

typedef struct _AMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE, *LPAMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE;

typedef const AMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE *LPCAMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE;

typedef struct _ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} ECHO_CHAIN_FX0_ECHO_STATE, *LPECHO_CHAIN_FX0_ECHO_STATE;

typedef const ECHO_CHAIN_FX0_ECHO_STATE *LPCECHO_CHAIN_FX0_ECHO_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\gpcycles\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\FXMultiPass\obj\i386\multipass.h ===
typedef enum _DSP_IMAGE_DSSTDFX_FX_INDICES {
    I3DL2_CHAIN_I3DL2_REVERB = 0,
    I3DL2_CHAIN_XTALK = 1,
    CHORUS_CHAIN_CHORUS = 2,
    FLANGE_CHAIN_FLANGE = 3,
    AMPMOD_CHAIN_AMPMOD = 4,
    ECHO_CHAIN_ECHO = 5,
    IIR2_CHAIN_IIR2_LEFT = 6,
    IIR2_CHAIN_IIR2_RIGHT = 7,
    REVERB_CHAIN_MINI_REVERB = 8,
    MULTIPASS_ECHO_CHAIN_ECHO = 9
} DSP_IMAGE_DSSTDFX_FX_INDICES;

typedef struct _I3DL2_CHAIN_FX0_I3DL2_REVERB_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[35];     // XRAM offsets in DSP WORDS, of output mixbins
} I3DL2_CHAIN_FX0_I3DL2_REVERB_STATE, *LPI3DL2_CHAIN_FX0_I3DL2_REVERB_STATE;

typedef const I3DL2_CHAIN_FX0_I3DL2_REVERB_STATE *LPCI3DL2_CHAIN_FX0_I3DL2_REVERB_STATE;

typedef struct _I3DL2_CHAIN_FX1_XTALK_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[4];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[4];     // XRAM offsets in DSP WORDS, of output mixbins
} I3DL2_CHAIN_FX1_XTALK_STATE, *LPI3DL2_CHAIN_FX1_XTALK_STATE;

typedef const I3DL2_CHAIN_FX1_XTALK_STATE *LPCI3DL2_CHAIN_FX1_XTALK_STATE;

typedef struct _CHORUS_CHAIN_FX0_CHORUS_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} CHORUS_CHAIN_FX0_CHORUS_STATE, *LPCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef const CHORUS_CHAIN_FX0_CHORUS_STATE *LPCCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef struct _FLANGE_CHAIN_FX0_FLANGE_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} FLANGE_CHAIN_FX0_FLANGE_STATE, *LPFLANGE_CHAIN_FX0_FLANGE_STATE;

typedef const FLANGE_CHAIN_FX0_FLANGE_STATE *LPCFLANGE_CHAIN_FX0_FLANGE_STATE;

typedef struct _AMPMOD_CHAIN_FX0_AMPMOD_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_CHAIN_FX0_AMPMOD_STATE, *LPAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef const AMPMOD_CHAIN_FX0_AMPMOD_STATE *LPCAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef struct _ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} ECHO_CHAIN_FX0_ECHO_STATE, *LPECHO_CHAIN_FX0_ECHO_STATE;

typedef const ECHO_CHAIN_FX0_ECHO_STATE *LPCECHO_CHAIN_FX0_ECHO_STATE;

typedef struct _IIR2_CHAIN_FX0_IIR2_LEFT_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} IIR2_CHAIN_FX0_IIR2_LEFT_STATE, *LPIIR2_CHAIN_FX0_IIR2_LEFT_STATE;

typedef const IIR2_CHAIN_FX0_IIR2_LEFT_STATE *LPCIIR2_CHAIN_FX0_IIR2_LEFT_STATE;

typedef struct _IIR2_CHAIN_FX1_IIR2_RIGHT_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} IIR2_CHAIN_FX1_IIR2_RIGHT_STATE, *LPIIR2_CHAIN_FX1_IIR2_RIGHT_STATE;

typedef const IIR2_CHAIN_FX1_IIR2_RIGHT_STATE *LPCIIR2_CHAIN_FX1_IIR2_RIGHT_STATE;

typedef struct _REVERB_CHAIN_FX0_MINI_REVERB_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[12];     // XRAM offsets in DSP WORDS, of output mixbins
} REVERB_CHAIN_FX0_MINI_REVERB_STATE, *LPREVERB_CHAIN_FX0_MINI_REVERB_STATE;

typedef const REVERB_CHAIN_FX0_MINI_REVERB_STATE *LPCREVERB_CHAIN_FX0_MINI_REVERB_STATE;

typedef struct _MULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} MULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE, *LPMULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE;

typedef const MULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE *LPCMULTIPASS_ECHO_CHAIN_FX0_ECHO_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\GlobalFX.cpp ===
//-----------------------------------------------------------------------------
// File: GlobalFX.cpp
//
// Desc: The GlobalFX sample demonstrates how to create audio effects using
//       the DSP.  It also demonstrates modifying effect parameters via the
//       SetEffectData calll
//
// Hist: 5.29.01 - New for July XDK
//      10.15.01 - Updated DSP image handling.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBSound.h>
#include <dsound.h>
#include <xgraphics.h>
#include <stddef.h>
#include <assert.h>
#include "image.h"
#include "dsfxparm.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle playback" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Next effect\nchain" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Modify parameter value" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Modify oscillator(DSP)\nfrequency" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select parameter" },
};

#define NUM_HELP_CALLOUTS 9

// The GP DSP uses different mixbin constant definitions than DirectSound does
// These are used for re-routing DSP effects on the fly
#define DSPMIXBIN_FRONT_LEFT    0x000C00
#define DSPMIXBIN_FRONT_RIGHT   0x000C20
#define DSPMIXBIN_FRONT_CENTER  0x000C40
#define DSPMIXBIN_LOW_FREQUENCY 0x000C60
#define DSPMIXBIN_BACK_LEFT     0x000C80
#define DSPMIXBIN_BACK_RIGHT    0x000CA0
#define DSPMIXBIN_FXSEND_0      0x000D60
#define DSPMIXBIN_FXSEND_1      0x000D80
#define DSPMIXBIN_FXSEND_2      0x000DA0
#define DSPMIXBIN_FXSEND_3      0x000DC0
#define DSPMIXBIN_FXSEND_4      0x000DE0
#define DSPMIXBIN_FXSEND_5      0x000E00
#define DSPMIXBIN_FXSEND_6      0x000E20
#define DSPMIXBIN_FXSEND_7      0x000E40
#define DSPMIXBIN_FXSEND_8      0x000E60
#define DSPMIXBIN_FXSEND_9      0x000E80
#define DSPMIXBIN_FXSEND_10     0x000EA0
#define DSPMIXBIN_FXSEND_11     0x000EC0
#define DSPMIXBIN_FXSEND_12     0x000EE0
#define DSPMIXBIN_FXSEND_13     0x000F00
#define DSPMIXBIN_FXSEND_14     0x000F20
#define DSPMIXBIN_FXSEND_15     0x000F40
#define DSPMIXBIN_FXSEND_16     0x000F60
#define DSPMIXBIN_FXSEND_17     0x000F80
#define DSPMIXBIN_FXSEND_18     0x000FA0
#define DSPMIXBIN_FXSEND_19     0x000FC0


// These constants define how we want our DSP oscillator to operate
#define OSCILLATOR_SCALE    100
#define MAX_OSCILLATOR_FREQUENCY 30
#define MIN_OSCILLATOR_FREQUENCY 0.01

// Utility function for updating parameters of the DSP oscillator effect
HRESULT SetFxOscillatorParameters(LPDIRECTSOUND pDirectSound,DWORD dwEffectIndex,DOUBLE Frequency);

// Parameter type enum
typedef enum {
    PARAM_DWORD,
    PARAM_FLOAT,
} PARAM_TYPE;

// Parameter struct definition
typedef struct {
    WCHAR * szDescription;
    PARAM_TYPE ef;
    DWORD   dwEffectIndex;
    void *  pvFXParam;
    DWORD   dwOffset;
    FLOAT   fValue;
    FLOAT   fMin;
    FLOAT   fMax;
} EFFECTPARAM;

// Output mixbin struct definition
typedef struct {
    DWORD dwEffectIndex;
    DWORD dwOutputOffset;
} EFFECTOUTPUT;

// Struct definition for describing effect chains
typedef struct {
    WCHAR*          szDescription;
    DWORD           dwMixBinCount;
    DWORD           dwMixBins[ DSMIXBIN_ASSIGNMENT_MAX ];
    DWORD           dwNumParams;
    EFFECTPARAM*    pEffectParams;
    DWORD           dwNumOutputs;
    EFFECTOUTPUT*   pOutputs;
} OPTION_STRUCT;


// Echo effect parameters
DSFX_ECHO_STEREO_PARAMS g_fxEcho;
EFFECTPARAM g_aEchoParams[] =
{
    { L"Gain",                                                                  // Description
      PARAM_FLOAT,                                                              // Value type
      ECHO_CHAIN_ECHO,                                                          // Effect index
      &g_fxEcho,                                                                // pvFXParam
      offsetof( DSFX_ECHO_STEREO_PARAMS, dwGain),                               // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      1.0f }                                                                    // Max

};

// Echo output mixbins
EFFECTOUTPUT g_aEchoOutputs[] =
{
    { ECHO_CHAIN_ECHO, offsetof( DSFX_ECHO_STEREO_STATE, dwOutMixbinPtrs[0] ) },
    { ECHO_CHAIN_ECHO, offsetof( DSFX_ECHO_STEREO_STATE, dwOutMixbinPtrs[1] ) }
};


// Distortion effect parameters
DSFX_DISTORTION_PARAMS g_fxDistortionL;
DSFX_DISTORTION_PARAMS g_fxDistortionR;
EFFECTPARAM g_aDistortionParams[] =
{
    { L"Gain L",                                                                // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwGain ),                               // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      1.0f },                                                                   // Max

    { L"PreFilter B0 L",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterB0 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter B1 L",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterB1 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter B2 L",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterB2 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter A1 L",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterA1 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter A2 L",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterA2 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter B0 L",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterB0 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter B1 L",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterB1 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter B2 L",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterB2 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter A1 L",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterA1 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter A2 L",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION0,                                             // Effect index
      &g_fxDistortionL,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterA2 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"Gain R",                                                                // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwGain ),                               // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      1.0f },                                                                   // Max

    { L"PreFilter B0 R",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterB0 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter B1 R",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterB1 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter B2 R",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterB2 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter A1 R",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterA1 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PreFilter A2 R",                                                        // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPreFilterA2 ),                        // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter B0 R",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterB0 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter B1 R",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterB1 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter B2 R",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterB2 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter A1 R",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterA1 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max

    { L"PostFilter A2 R",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      DISTORTION_CHAIN_DISTORTION1,                                             // Effect index
      &g_fxDistortionR,                                                         // pvFXParam
      offsetof( DSFX_DISTORTION_PARAMS, dwPostFilterA2 ),                       // Offset
      0.0f,                                                                     // Value
      -1.0f,                                                                    // Min
      1.0f },                                                                   // Max
};

// Distortion output mixbins
EFFECTOUTPUT g_aDistortionOutputs[] =
{
    { DISTORTION_CHAIN_DISTORTION0, offsetof( DSFX_DISTORTION_STATE, dwOutMixbinPtrs[0] ) },
    { DISTORTION_CHAIN_DISTORTION1, offsetof( DSFX_DISTORTION_STATE, dwOutMixbinPtrs[1] ) }
};


// Chorus effect parameters
DSFX_CHORUS_STEREO_PARAMS g_fxChorus;
EFFECTPARAM g_aChorusParams[] =
{
    { L"Gain",                                                                  // Description
      PARAM_FLOAT,                                                              // Value type
      CHORUS_CHAIN_CHORUS,                                                      // Effect index
      &g_fxChorus,                                                              // pvFXParam
      offsetof( DSFX_CHORUS_STEREO_PARAMS, dwGain),                             // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      1.0f },                                                                   // Max

    { L"ModScale",                                                              // Description
      PARAM_DWORD,                                                              // Value type
      CHORUS_CHAIN_CHORUS,                                                      // Effect index
      &g_fxChorus,                                                              // pvFXParam
      offsetof( DSFX_CHORUS_STEREO_PARAMS, dwModScale),                         // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      200.0f }                                                                    // Max
};

// Chorus output mixbins
EFFECTOUTPUT g_aChorusOutputs[] =
{
    { CHORUS_CHAIN_CHORUS, offsetof( DSFX_CHORUS_STEREO_STATE, dwOutMixbinPtrs[0] ) },
    { CHORUS_CHAIN_CHORUS, offsetof( DSFX_CHORUS_STEREO_STATE, dwOutMixbinPtrs[1] ) }
};


// AmpMod->Flange effect paramaters
DSFX_FLANGE_STEREO_PARAMS g_fxFlange;
EFFECTPARAM g_aAmpModFlangeParams[] =
{
    { L"Flange Feedback",                                                       // Description
      PARAM_FLOAT,                                                              // Value type
      AMPMOD_FLANGE_CHAIN_FLANGE,                                               // Effect index
      &g_fxFlange,                                                              // pvFXParam
      offsetof( DSFX_FLANGE_STEREO_PARAMS, dwFeedback ),                        // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      1.0f },                                                                   // Max

    { L"Flange Scale",                                                          // Description
      PARAM_DWORD,                                                              // Value type
      AMPMOD_FLANGE_CHAIN_FLANGE,                                               // Effect index
      &g_fxFlange,                                                              // pvFXParam
      offsetof( DSFX_FLANGE_STEREO_PARAMS, dwModScale ),                        // Offset
      0.0f,                                                                     // Value
      0.0f,                                                                     // Min
      100.0f },                                                                 // Max
};

// AmpMod->Flange output mixbins
EFFECTOUTPUT g_aAmpModFlangeOutputs[] =
{
    { AMPMOD_FLANGE_CHAIN_FLANGE, offsetof( DSFX_FLANGE_STEREO_STATE, dwOutMixbinPtrs[0] ) },
    { AMPMOD_FLANGE_CHAIN_FLANGE, offsetof( DSFX_FLANGE_STEREO_STATE, dwOutMixbinPtrs[1] ) }
};


typedef enum {

    EFFECT_NONE = 0,
    EFFECT_ECHO,
    EFFECT_DISTORTION,
    EFFECT_CHORUS,
    EFFECT_AMPMOD_FLANGE,
    MAX_CHAINS

} EFFECT_CHAINS;


// List of all effect chains, mixbins, and parameters
OPTION_STRUCT g_aOptions[] =
{
//      Name, # of bins, mixbin assignments, # params, param structure, # outputs, output struct
    { L"None",              6, { DSMIXBIN_FRONT_LEFT, DSMIXBIN_FRONT_RIGHT, DSMIXBIN_FRONT_CENTER, DSMIXBIN_BACK_LEFT, DSMIXBIN_BACK_RIGHT, DSMIXBIN_LOW_FREQUENCY }, 0, NULL, 0, NULL },
    { L"Echo",              2, { DSMIXBIN_FXSEND_0, DSMIXBIN_FXSEND_1 }, 1, g_aEchoParams, 2, g_aEchoOutputs },
    { L"Distortion",        2, { DSMIXBIN_FXSEND_2, DSMIXBIN_FXSEND_3 }, 22, g_aDistortionParams, 2, g_aDistortionOutputs },
    { L"Chorus",            2, { DSMIXBIN_FXSEND_4, DSMIXBIN_FXSEND_5 }, 2, g_aChorusParams, 2, g_aChorusOutputs },
    { L"AmpMod->Flange",    2, { DSMIXBIN_FXSEND_6, DSMIXBIN_FXSEND_7 }, 2, g_aAmpModFlangeParams, 2, g_aAmpModFlangeOutputs },
};


// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\heli.wav",
    "D:\\Media\\Sounds\\DockingMono.wav",
    "D:\\Media\\Sounds\\EngineStartMono.wav",
    "D:\\Media\\Sounds\\MaleDialog1.wav",
    "D:\\Media\\Sounds\\MiningMono.wav",
    "D:\\Media\\Sounds\\MusicMono.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
};

#define NUM_SOUNDS 7

#define PARAM_DISPLAY_LENGTH 7

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Utility function for creating a sine wave buffer
    HRESULT CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer );

    HRESULT InitializeEffectParameters();           // Loads effect parameters
    HRESULT NextFilterGraph();                      // Switch to next effect

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;


    LPDIRECTSOUND8          m_pDSound;              // DirectSound object
    CWaveFile               m_awfSounds[NUM_SOUNDS];// Wave file parsers
    DWORD                   m_dwCurrent;            // Current sound
    BOOL                    m_bPlaying;             // Are we playing?
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE *                  m_pbSampleData;         // Sample data from wav
    DWORD                   m_dwEffect;             // Current effect graph
    DWORD                   m_dwParam;              // Current effect param
    DWORD                   m_dwFirstDisplayed;     // First displayed param
    LPDIRECTSOUNDBUFFER8    m_pOscillator;          // Host buffer used as Oscillator

    DOUBLE                  m_fOscillatorFrequency; // frequency of DSP fx oscillator

    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_fOscillatorFrequency = 1;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;
    m_pbSampleData = NULL;

}


//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    if( !XLoadSection( "DSPImage" ) )
        return E_FAIL;

    LPDSEFFECTIMAGEDESC pDesc;
    if( FAILED( XAudioDownloadEffectsImage( "DSPImage", NULL, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc ) ) )
        return E_FAIL;

    XFreeSection( "DSPImage" );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitializeEffectParameters()
// Desc: Loads the current effect parameters from the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitializeEffectParameters()
{
    // For each effect chain...
    for( DWORD dwEffect = 0; dwEffect < MAX_CHAINS; dwEffect++ )
    {
        // Iterate over each parameter
        for( DWORD i = 0; i < g_aOptions[ dwEffect ].dwNumParams; i++ )
        {
            EFFECTPARAM * pParam = &g_aOptions[ dwEffect ].pEffectParams[ i ];

            // Get the raw value
            DWORD dwValue;
            m_pDSound->GetEffectData( pParam->dwEffectIndex, pParam->dwOffset, &dwValue, sizeof( DWORD ) );

            // And convert to something we can display
            switch( pParam->ef )
            {
            case PARAM_DWORD:
                // DWORDs can be type-cast 
                pParam->fValue = (FLOAT)dwValue;
                break;

            case PARAM_FLOAT:
                // Float format is s.23: 24 bit two's complement with the point fixed
                // at the left. 0x7FFFFF is just less than 1.0, 0x800000 is -1.0
                if( dwValue >= 0x800000 )
                {
                    pParam->fValue = -(( 0x1000000 - dwValue ) / (FLOAT)0x800000);
                }
                else
                {
                    pParam->fValue = dwValue / (FLOAT)0x7FFFFF;
                }
                break;
            }
        }
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    m_dwCurrent        = 0;
    m_dwEffect         = 0;
    m_dwParam          = 0;
    m_dwFirstDisplayed = 0;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    // Download a scratch image that contains our effects graphs
    if( FAILED( DownloadEffectsImage("d:\\media\\image.bin") ) )
        return E_FAIL;

    // Load all of the initial effect parameters from the DSP
    InitializeEffectParameters();

    // Set frequency on oscillator running in the DSP
    SetFxOscillatorParameters(m_pDSound, OSCILLATOR_CHAIN_OSCILLATOR,m_fOscillatorFrequency);

    // Create a sine wave for our host-based oscillator
    CreateSineWaveBuffer( 1, &m_pOscillator );

    //
    // For testing purposes:
    // Make sure that all our files have the same format,
    // since we're re-using the samd DirectSoundBuffer for
    // all the files.  First, we have to determine how
    // much space to allocate for the wave format, since
    // the XBOXADPCMWAVEFORMAT is 2 bytes larger than
    // WAVEFORMATEX.
    //
    DWORD          cbFirst;
    WAVEFORMATEX * pwfFirst = NULL;
    DWORD          cbWalk;
    WAVEFORMATEX * pwfWalk = NULL;
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        if( FAILED( m_awfSounds[ i ].Open( g_aszFileNames[i] ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Testing only:
        // Verify they're all the same format, since we're only going to have
        // one sound buffer.
        if( i == 0 )
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbFirst );
            pwfFirst = (WAVEFORMATEX *)new BYTE[ cbFirst ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfFirst, cbFirst ) ) )
                return E_FAIL;
        }
        else
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbWalk );
            pwfWalk = (WAVEFORMATEX *)new BYTE[ cbWalk ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfWalk, cbWalk ) ) )
                return E_FAIL;

            if( cbWalk != cbFirst ||
                memcmp( pwfFirst, pwfWalk, cbFirst ) )
            {
                OUTPUT_DEBUG_STRING( "All wav files should have the same format!\n" );
                return E_FAIL;
            }

            delete[] pwfWalk;
        }
    }

    //
    // Create a sound buffer of 0 size, since we're going to use
    // SetBufferData
    //
    DSBUFFERDESC dsbdesc;
    DSMIXBINS dsmixbins;
    DSMIXBINVOLUMEPAIR dsmbvp[DSMIXBIN_ASSIGNMENT_MAX];
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    /* If fewer than 256 buffers are in existence at all points during 
       the game, it may be more efficient not to use LOCDEFER. */
    dsbdesc.dwFlags = DSBCAPS_LOCDEFER;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = pwfFirst;
    dsbdesc.lpMixBins = &dsmixbins;

    dsmixbins.dwMixBinCount = g_aOptions[ m_dwEffect ].dwMixBinCount;
    dsmixbins.lpMixBinVolumePairs = dsmbvp;

    for (i = 0; i < (int)dsmixbins.dwMixBinCount; i++ )
    {
        dsmbvp[ i ].dwMixBin = g_aOptions[ m_dwEffect ].dwMixBins[ i ];
        dsmbvp[ i ].lVolume = DSBVOLUME_MAX;
    }

    if( FAILED( DirectSoundCreateBuffer( &dsbdesc, &m_pDSBuffer ) ) )
        return E_FAIL;

    // Set up and play our initial sound
    m_bPlaying = TRUE;
    SwitchToSound( m_dwCurrent );

    // Clean up our memory allocations
    delete[] pwfFirst;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Reallocate the sample data buffer
//       3) Point the DirectSoundBuffer to the new data
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    DWORD dwNewSize;
    DWORD dwLoopStartSample, dwLoopLengthSamples;
    DWORD cbLoopStart, cbLoopLength;

    // If we're currently playing, stop, so that we don't crash
    // when we reallocate our buffer
    if( m_bPlaying )
    {
        m_pDSBuffer->Stop();
    }

    // Calling stop doesn't immediately shut down
    // the voice, so point it away from our buffer
    m_pDSBuffer->SetBufferData( NULL, 0 );

    // Find out how big the new sample is
    m_awfSounds[ dwIndex ].GetDuration( &dwNewSize );

    // Set our allocation to that size
    if( m_pbSampleData )
        delete[] m_pbSampleData;
    m_pbSampleData = new BYTE[ dwNewSize ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

    // Read sample data from the file
    m_awfSounds[ dwIndex ].ReadSample( 0, m_pbSampleData, dwNewSize, &dwNewSize );

    // Check for embedded loop points
    if( SUCCEEDED( m_awfSounds[ dwIndex ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
    {
        WAVEFORMATEX wfx;

        // We're not interested in the whole wave format, which is
        // why we can get away with just loading the core WAVEFORMATEX
        m_awfSounds[ dwIndex ].GetFormat( &wfx, sizeof( WAVEFORMATEX ) );

        // We need to convert the loop points from sample counts to
        // byte offsets, but it's slightly different between PCM and ADPCM
        if( wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
        {
            // For ADPCM, calculate # of blocks and multiply that
            // by bytes per block.  Xbox ADPCM is always 64 samples
            // per block.
            cbLoopStart = dwLoopStartSample / 64 * wfx.nBlockAlign;
            cbLoopLength = dwLoopLengthSamples / 64 * wfx.nBlockAlign;
        }
        else
        {
            // For PCM, multiply by bytes per sample
            DWORD cbBytesPerSample = wfx.nChannels * wfx.wBitsPerSample / 8;
            cbLoopStart = dwLoopStartSample * cbBytesPerSample;
            cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
        }
    }
    else
    {
        // Otherwise, just loop the whole file
        cbLoopStart = 0;
        cbLoopLength = dwNewSize;
    }


    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( cbLoopStart, cbLoopLength );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // If we were playing before, restart playback now
    if( m_bPlaying )
        m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: NextFilterGraph
// Desc: Switches to the next filter graph.  This involves:
//       1) Routing the current effect to a dummy mixbin to silence it
//       2) Routing the next effect to the speaker mixbins
//       3) Routing the buffer to the new effect's input mixbins
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::NextFilterGraph()
{
    // First, we need to silence the current effect by routing its output
    // to unused mixbins.  Otherwise, an effect that uses a delay line may
    // keep playing
    for( DWORD i = 0; i < g_aOptions[ m_dwEffect ].dwNumOutputs; i++ )
    {
        // Use unlucky number 13 for our dummy mixbin
        DWORD dwDummyOutput = DSPMIXBIN_FXSEND_13;

        m_pDSound->SetEffectData( g_aOptions[ m_dwEffect ].pOutputs[ i ].dwEffectIndex,
                                  g_aOptions[ m_dwEffect ].pOutputs[ i ].dwOutputOffset,
                                  &dwDummyOutput,
                                  sizeof( DWORD ),
                                  DSFX_DEFERRED );
    }

    m_dwEffect = ( m_dwEffect + 1 ) % MAX_CHAINS;

    // Now, route the new effect's output to the speakers
    DWORD adwSpeakerOutputs[6] = {
        DSPMIXBIN_FRONT_LEFT,
        DSPMIXBIN_FRONT_RIGHT,
        DSPMIXBIN_FRONT_CENTER,
        DSPMIXBIN_LOW_FREQUENCY,
        DSPMIXBIN_BACK_LEFT,
        DSPMIXBIN_BACK_RIGHT };
    assert( g_aOptions[ m_dwEffect ].dwNumOutputs < 6 );
    for( DWORD i = 0; i < g_aOptions[ m_dwEffect ].dwNumOutputs; i++ )
    {
        DWORD dwDummy;
        m_pDSound->GetEffectData( g_aOptions[ m_dwEffect ].pOutputs[ i ].dwEffectIndex,
                                  g_aOptions[ m_dwEffect ].pOutputs[ i ].dwOutputOffset,
                                  &dwDummy,
                                  sizeof( DWORD ) );
        m_pDSound->SetEffectData( g_aOptions[ m_dwEffect ].pOutputs[ i ].dwEffectIndex,
                                  g_aOptions[ m_dwEffect ].pOutputs[ i ].dwOutputOffset,
                                  &adwSpeakerOutputs[i],
                                  sizeof( DWORD ),
                                  DSFX_DEFERRED );
    }

    // Now commit our routing changes
    m_pDSound->CommitEffectData();

    // Have our buffer send its output to the inputs of the new
    // effect chain
    DSMIXBINS dsmixbins;
    DSMIXBINVOLUMEPAIR dsmbvp[ DSMIXBIN_ASSIGNMENT_MAX ];

    dsmixbins.dwMixBinCount = g_aOptions[ m_dwEffect ].dwMixBinCount;
    dsmixbins.lpMixBinVolumePairs = dsmbvp;
    
    for( int i = 0; i < (int)dsmixbins.dwMixBinCount; i++)
    {
        dsmbvp[ i ].dwMixBin = g_aOptions[ m_dwEffect ].dwMixBins[ i ];
        dsmbvp[ i ].lVolume = DSBVOLUME_MAX;
    }
    
    m_pDSBuffer->SetMixBins( &dsmixbins );
    m_dwParam = 0;
    m_dwFirstDisplayed = 0;

    return S_OK;
}
                       

#define VOLUME_SCALE 5.0f
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDSBuffer->Stop( );
        else
            m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

        m_bPlaying = !m_bPlaying;
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
        SwitchToSound( m_dwCurrent );
    }

    // change oscillator frequency of DSP FX that drives ampmod->flange chain
    // the oscillator that drives chorus is justa looping buffer with a single-cycle sine-wave
    // on the host
    if (m_dwEffect == EFFECT_AMPMOD_FLANGE) {

        DOUBLE fOldFrequency = m_fOscillatorFrequency;
        m_fOscillatorFrequency += m_DefaultGamepad.fX1 / OSCILLATOR_SCALE;
        if( m_fOscillatorFrequency > MAX_OSCILLATOR_FREQUENCY )
            m_fOscillatorFrequency = MAX_OSCILLATOR_FREQUENCY;
        if( m_fOscillatorFrequency <= MIN_OSCILLATOR_FREQUENCY )
            m_fOscillatorFrequency = MIN_OSCILLATOR_FREQUENCY;

        //
        // check if the frequency changed. We only want to touch the dsp oscillator FX params
        // if something changed, to minimize clicks caused by resetting the waveform
        //

        if (fOldFrequency != m_fOscillatorFrequency) {

            SetFxOscillatorParameters(m_pDSound, OSCILLATOR_CHAIN_OSCILLATOR,m_fOscillatorFrequency);

        }
    }

    // Cycle through effect graphs
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
        NextFilterGraph();

    // Deal with effect parameters
    if( g_aOptions[ m_dwEffect ].dwNumParams )
    {
        // Select active parameter with DPAD
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        {
            // Scroll up if we can and need to
            if( m_dwFirstDisplayed == m_dwParam && m_dwFirstDisplayed > 0)
            {
                m_dwFirstDisplayed -= 1;
            }

            // Select previous parameter
            if( m_dwParam > 0 )
            {
                m_dwParam -= 1;
            }
        }
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        {
            // Scroll down if we can and need to
            if( m_dwFirstDisplayed + PARAM_DISPLAY_LENGTH - 1 == m_dwParam &&
                m_dwFirstDisplayed + PARAM_DISPLAY_LENGTH < g_aOptions[ m_dwEffect ].dwNumParams )
            {
                m_dwFirstDisplayed += 1;
            }

            // Select next parameter
            if( m_dwParam < g_aOptions[ m_dwEffect ].dwNumParams - 1 )
            {
                m_dwParam += 1;
            }
        }

        // Grab a pointer to the current effect
        EFFECTPARAM * pParam = &g_aOptions[ m_dwEffect ].pEffectParams[ m_dwParam ];
        FLOAT fOld = pParam->fValue;
        DWORD dwScale = DWORD( 32768 / ( pParam->fMax - pParam->fMin ) / 60 );
        BOOL bParamChanged = FALSE;

        // Internally, we store all types of parameters as floats, and then
        // convert for display/SetEffectData
        pParam->fValue += m_DefaultGamepad.fX2 / dwScale;
        if( pParam->fValue > pParam->fMax )
            pParam->fValue = pParam->fMax;
        if( pParam->fValue < pParam->fMin )
            pParam->fValue = pParam->fMin;

        // See if the parameter changed
        bParamChanged = ( fOld != pParam->fValue );

        // If a parameter changed, we need to call SetEffectData
        // Note that we could use DSFX_DEFERRED and CommitEffectData() if we were
        // changing several parameters at once.
        if( bParamChanged )
        {
            DWORD dwValue;
            switch( pParam->ef )
            {
            case PARAM_DWORD:
                // DWORDs can just be copied over
                dwValue = DWORD(pParam->fValue);
                break;
            case PARAM_FLOAT:
                // Float format is s.23: 24 bit two's complement with the point fixed
                // at the left. 0x7FFFFF is just less than 1.0, 0x800000 is -1.0
                if( pParam->fValue >= 0 )
                    dwValue = DWORD( pParam->fValue * 0x7FFFFF );
                else
                    dwValue = 0x1000000 - DWORD( -pParam->fValue * 0x800000 );
                break;
            }
            m_pDSound->SetEffectData( pParam->dwEffectIndex, pParam->dwOffset, &dwValue, sizeof( DWORD ), DSFX_IMMEDIATE );
        }
    }

    m_pDSBuffer->SetVolume( m_lVolume );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"GlobalFX" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF808080, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 130, 0xFFFFFF00, szBuff );
        swprintf( szBuff, L"Effect graph: %s", g_aOptions[ m_dwEffect ].szDescription );
        m_Font.DrawText( 64, 160, 0xffffffff, szBuff );

        if (m_dwEffect == EFFECT_AMPMOD_FLANGE) {

            //
            // display current oscillator frequency
            //

            swprintf( szBuff, L"Oscillator Frequency: %f",m_fOscillatorFrequency );
            m_Font.DrawText( 64, 400, 0xffffffff, szBuff );

        }

        // Now display our effect parameters, if any
        EFFECTPARAM * pParams = g_aOptions[ m_dwEffect ].pEffectParams;
        DWORD dwLastDisplayed = min( m_dwFirstDisplayed + PARAM_DISPLAY_LENGTH,
                                     g_aOptions[ m_dwEffect ].dwNumParams );
        FLOAT fY = 190.0f;
        for( DWORD i = m_dwFirstDisplayed; i < dwLastDisplayed; i++ )
        {
            switch( pParams[ i ].ef )
            {
            case PARAM_DWORD:
                swprintf( szBuff, L"%s: %ld", pParams[ i ].szDescription, (DWORD)pParams[ i ].fValue );
                break;
            case PARAM_FLOAT:
                swprintf( szBuff, L"%s: %f", pParams[ i ].szDescription, pParams[ i ].fValue );
                break;
            }
            m_Font.DrawText( 90, fY, m_dwParam == i ? 0xffffffff : 0xffffff00, szBuff );
            fY += 30.0f;
        }

        // Show scroll arrows if needed
        if( m_dwFirstDisplayed > 0 )
            m_Font.DrawText( 64, 190, 0xffffff00, L"^" );
        if( m_dwFirstDisplayed + PARAM_DISPLAY_LENGTH < g_aOptions[ m_dwEffect ].dwNumParams )
            m_Font.DrawText( 64, 190 + ( PARAM_DISPLAY_LENGTH - 1 ) * 30.0f, 0xffffff00, L"v" );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateSineWaveBuffer
// Desc: Creates a DirectSound Buffer and fills it with a sine wave.  This
//       can be useful for DSP effects that are driven off an oscillator.
//       Note that non-integral frequencies will end up with a discontinuity
//       at the loop point.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer )
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER8 pBuffer = NULL;
    BYTE * pData = NULL;
    DWORD dwBytes = 0;
    double dArg = 0.0;
    double dSinVal = 0.0;
    BYTE bVal = 0;

    // Check arguments
    if( !ppBuffer || dFrequency < 0 )
        return E_INVALIDARG;

    *ppBuffer = NULL;

    //
    // Initialize a wave format structure
    //
    WAVEFORMATEX wfx;
    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    wfx.wFormatTag      = WAVE_FORMAT_PCM;      // PCM data
    wfx.nChannels       = 1;                    // Mono
    wfx.nSamplesPerSec  = 1000;                 // 1kHz
    wfx.nAvgBytesPerSec = 1000;                 // 1kHz * 1 bytes / sample
    wfx.nBlockAlign     = 1;                    // sample size in bytes
    wfx.wBitsPerSample  = 8;                    // 8 bit samples
    wfx.cbSize          = 0;                    // No extra data

    //
    // Intialize the buffer description
    DSBUFFERDESC dsbd;
    DSMIXBINS dsmixbins;
    DSMIXBINVOLUMEPAIR dsmbvp;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
    dsbd.lpwfxFormat = &wfx;
    dsbd.lpMixBins = &dsmixbins;

    dsmixbins.dwMixBinCount = 1;
    dsmixbins.lpMixBinVolumePairs = &dsmbvp;

    dsmbvp.dwMixBin = DSMIXBIN_FXSEND_19;
    dsmbvp.lVolume = DSBVOLUME_MAX;

    // Create the buffer
    hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
    if( FAILED( hr ) )
        return hr;

    // Set the oscillator mixbin headroom to 0 so the effect gets a full-scale
    // sine wave
    m_pDSound->SetMixBinHeadroom( DSMIXBIN_FXSEND_19, 0 );

    // Get a pointer to buffer data to fill
    hr = pBuffer->Lock( 0, dsbd.dwBufferBytes, (VOID **)&pData, &dwBytes, NULL, NULL, 0 );
    if( FAILED( hr ) )
        return hr;

    // Now fill the buffer, 1 8-bit sample at a time
    for( DWORD i = 0; i < dwBytes; i++ )
    {
        // Convert sample offset to radians
        dArg = (double)i / wfx.nSamplesPerSec * D3DX_PI * 2;

        // Calculate the sin
        dSinVal = sin( dFrequency * dArg );

        // Scale to sample format
        bVal = BYTE( dSinVal * 127 );

        // Store the sample
        pData[i] = bVal;
    }

    // Start the sine wave looping
    hr = pBuffer->Play( 0, 0, DSBPLAY_LOOPING );
    if( FAILED( hr ) )
        return hr;

    // return the buffer
    *ppBuffer = pBuffer;

    return hr;
}

#define PI (DOUBLE)3.14159

//-----------------------------------------------------------------------------
// Name: SetFXOscillatorParameters
// Desc: The routine manipulates variables in DSP memory to change the output
//       of the low frequency oscillator DSP effect. It translates frequency
//       to coefficients required for a second order IIR to produce a pseudo
//       sine wave. The dsp effect image loaded must include the oscillator FX.
//       Using an in-dsp oscillator is presented here as an alternative to using
//       a buffer above (essentially burning a hw voice) for oscillators.
//-----------------------------------------------------------------------------

HRESULT SetFxOscillatorParameters(LPDIRECTSOUND pDirectSound,DWORD dwEffectIndex,DOUBLE Frequency)
{

    DWORD dwValue = 0;
    HRESULT hr = S_OK;

    //
    // convert frequency to 1/10s of Hz as an integer
    //

    dwValue = (DWORD)(Frequency*10.0);

    hr = pDirectSound->SetEffectData(dwEffectIndex,FIELD_OFFSET( DSFX_OSCILLATOR_PARAMS,adwFrequency), &dwValue, sizeof( DWORD ), DSFX_IMMEDIATE);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\i3dl2\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\ManualPanning\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\ManualPanning\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\ManualPanning\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\GlobalFX\obj\i386\image.h ===
typedef enum _DSP_IMAGE_MY_FIRST_GRAPH_FX_INDICES {
    OSCILLATOR_CHAIN_OSCILLATOR = 0,
    DISTORTION_CHAIN_DISTORTION0 = 1,
    DISTORTION_CHAIN_DISTORTION1 = 2,
    CHORUS_CHAIN_CHORUS = 3,
    AMPMOD_FLANGE_CHAIN_AMPMOD = 4,
    AMPMOD_FLANGE_CHAIN_FLANGE = 5,
    ECHO_CHAIN_ECHO = 6
} DSP_IMAGE_MY_FIRST_GRAPH_FX_INDICES;

typedef struct _OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwOutMixbinPtrs[4];     // XRAM offsets in DSP WORDS, of output mixbins
} OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE, *LPOSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE;

typedef const OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE *LPCOSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE;

typedef struct _DISTORTION_CHAIN_FX0_DISTORTION0_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} DISTORTION_CHAIN_FX0_DISTORTION0_STATE, *LPDISTORTION_CHAIN_FX0_DISTORTION0_STATE;

typedef const DISTORTION_CHAIN_FX0_DISTORTION0_STATE *LPCDISTORTION_CHAIN_FX0_DISTORTION0_STATE;

typedef struct _DISTORTION_CHAIN_FX1_DISTORTION1_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} DISTORTION_CHAIN_FX1_DISTORTION1_STATE, *LPDISTORTION_CHAIN_FX1_DISTORTION1_STATE;

typedef const DISTORTION_CHAIN_FX1_DISTORTION1_STATE *LPCDISTORTION_CHAIN_FX1_DISTORTION1_STATE;

typedef struct _CHORUS_CHAIN_FX0_CHORUS_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} CHORUS_CHAIN_FX0_CHORUS_STATE, *LPCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef const CHORUS_CHAIN_FX0_CHORUS_STATE *LPCCHORUS_CHAIN_FX0_CHORUS_STATE;

typedef struct _AMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE, *LPAMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE;

typedef const AMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE *LPCAMPMOD_FLANGE_CHAIN_FX0_AMPMOD_STATE;

typedef struct _AMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE, *LPAMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE;

typedef const AMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE *LPCAMPMOD_FLANGE_CHAIN_FX1_FLANGE_STATE;

typedef struct _ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} ECHO_CHAIN_FX0_ECHO_STATE, *LPECHO_CHAIN_FX0_ECHO_STATE;

typedef const ECHO_CHAIN_FX0_ECHO_STATE *LPCECHO_CHAIN_FX0_ECHO_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\ManualPanning\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\ManualPanning\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\gpcycles\util.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testds.cpp
 *  Content:    DirectSound test functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *  04/2001   georgioc  cut and paste/delete from testds, for testing dsp stuff
 *
 ****************************************************************************/

#include "xtl.h"
#include "stdio.h"

static const float pi = 3.1415f;
#define PAGE_SIZE 4096

__inline HRESULT
ValidateResult
(
    HRESULT                 hr
)
{
    if(FAILED(hr)) {
        _asm int 3;
    }

    return hr;
}


__inline HRESULT
ValidateBool
(
    BOOL                    fSuccess
)
{
    return fSuccess ? S_OK : E_FAIL;
}


__inline HRESULT
ValidatePtr
(
    LPVOID                  pv
)
{
    return pv ? S_OK : E_OUTOFMEMORY;
}


LPVOID
__Malloc
(
    DWORD                   dwSize
)
{

    DWORD                   dwAllocSize;
    DWORD                   dwOffset;
    LPVOID                  pvBuffer;
    DWORD                   dwOldProtect;
    BOOL                    fProtect;

    dwAllocSize = dwSize + PAGE_SIZE + PAGE_SIZE - 1;

    dwAllocSize += sizeof(DWORD);

    dwAllocSize /= PAGE_SIZE;
    dwAllocSize *= PAGE_SIZE;

    if(pvBuffer = VirtualAlloc(NULL, dwAllocSize, MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE))
    {
        fProtect = VirtualProtect((LPBYTE)pvBuffer + dwAllocSize - PAGE_SIZE, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE, &dwOldProtect);

        dwOffset = dwAllocSize - dwSize - PAGE_SIZE;

        pvBuffer = (LPBYTE)pvBuffer + dwOffset;

        *((LPDWORD)pvBuffer - 1) = dwOffset;

    }

    return pvBuffer;

}

#define MALLOC(a) \
    __Malloc(a)


void
__Free
(
    LPVOID *                ppvBuffer
)
{

    LPVOID                  pvBuffer    = *ppvBuffer;
    DWORD                   dwOffset;

    *ppvBuffer = NULL;

    if(pvBuffer)
    {

#ifdef ALLOC_CONTIGUOUS

        MmFreeContiguousMemory(pvBuffer);

#else // ALLOC_CONTIGUOUS

#ifdef ALLOC_ALIGNED

        dwOffset = 0;

#else // ALLOC_ALIGNED

        dwOffset = *((LPDWORD)pvBuffer - 1);

#endif // ALLOC_ALIGNED
    
        VirtualFree((LPBYTE)pvBuffer - dwOffset, 0, MEM_RELEASE);

#endif // ALLOC_CONTIGUOUS

    }
}

#define FREE(p) \
    __Free((LPVOID *)&(p))


/****************************************************************************
 *
 *  ReadXMO
 *
 *  Description:
 *      Reads data from an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Read from the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwRead;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(NULL, &xmp));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    CloseHandle(hCompletionEvent);

    return hr;
}

/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Loads a wave file into an XMO object.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      LPCWAVEFORMATEX [out]: wave file format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    return ValidateResult(XWaveFileCreateMediaObject(pszFileName, ppwfxFormat, ppMediaObject));
}



/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a sound buffer based on a given wave file.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      XFileMediaObject * [in]: file XMO.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *      LPDWORD [out]: buffer length, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateBufferFromFile
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject *      pMediaObject,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPDWORD                 pdwDuration     = NULL
)
{
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr              = DS_OK;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLockSize = 0;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

    hr = ValidateResult(pMediaObject->GetLength(&dsbd.dwBufferBytes));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(0, 0, &pvLock, &dwLockSize, NULL, NULL, DSBLOCK_ENTIREBUFFER));
    }

    if(SUCCEEDED(hr))
    {
        hr = ReadXMO(pMediaObject, pvLock, dwLockSize, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;

        if(pdwDuration)
        {
            *pdwDuration = dsbd.dwBufferBytes;
        }
    }
    else
    {
        pBuffer->Release();
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a sound buffer based on a given wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *      REFGUID [in]: 3D algorithm.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPDWORD                 pdwDuration     = NULL
)
{
    XFileMediaObject *      pMediaObject    = NULL;
    LPCWAVEFORMATEX         pwfxFormat      = NULL;
    HRESULT                 hr;

    hr = LoadWaveFile(pszFile, &pwfxFormat, &pMediaObject);

    if(SUCCEEDED(hr))
    {
        hr = CreateBufferFromFile(dwFlags, pwfxFormat, pMediaObject, ppBuffer, pdwDuration);
    }

    pMediaObject->Release();

    return hr;
}

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double FREQ = 2.55;
static const double PI = 3.1415926535;

///
/// Scaling factors
///
/// ISCALE is used to convert an interger [0, 44099] to a double [0, 2PI]
/// DATASCALE is used to conver a double [-1.0, 1.0] to an integer [-32767, 32767]

static const double ISCALE = 2.0 * PI / 48000.0;
static const double DATASCALE = 32767.0 / 1.0;

///
/// the main sine player code
///
    
HRESULT PlaySineWave(double Frequency, DWORD dwMixBins,LPDIRECTSOUNDBUFFER     *pBuffer )
{

	///
	/// create a dsound buffer and a data buffer
	///

    HRESULT hr = S_OK;
	LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
	LPSHORT pData = NULL;

	///
	/// place to hold the number of bytes allocated by dsound
	///

	DWORD dwBytes = 0;

	///
	/// allocate space for calculate argument to sin, return value from sine, and actual integer value
	///

	double dArg = 0.0;
	double dSinVal = 0.0;
	SHORT sVal = 0;
   
	///
	/// allocate the dsound buffer description and the wave format
	///

	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;

	///
	/// It's always safe to zero out stack allocated structs
	///

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( DSBUFFERDESC ) );

	///
	/// setup the waveformat description to be PCM, 44100hz, 16bit, mono
    ///

	wfx.cbSize = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 48000;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	///
	/// setup the dsound buffer description with the waveformatex
	///

	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.dwFlags = 0;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = &wfx;
    dsbd.dwMixBinMask = dwMixBins;

	/// 
	/// Create the dsound buffer
	///

	hr = DirectSoundCreateBuffer( &dsbd, &pDSBuffer );

	///
	/// continue forever (or until an error occurs)
	///

	if ( SUCCEEDED( hr ) )
	{

		///
		/// get a buffer from dsound using lock
		///

		hr = pDSBuffer->Lock( 0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0 );

		///
		/// go through the buffer 2 bytes (1 short) at a time
		///

		for( DWORD i = 0; SUCCEEDED( hr ) && i < dsbd.dwBufferBytes / 2; i++ )
		{	
			///
			/// calculate the sin value
			///

			dArg = (double) i * ISCALE;
			dSinVal = sin( Frequency * dArg );
			sVal = (SHORT) ( dSinVal * DATASCALE );

			///
			/// copy the value into the dsound buffer
			///

			pData[i] = sVal;
		}

    }
    
	///
	/// start the dsound buffer playing in a loop mode
	///

	if ( SUCCEEDED( hr ) )
	{
		hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );
        *pBuffer = pDSBuffer;
	}



    //
    // leave with the buffer still playing..
    //

    return hr;
}

HRESULT
PlayLoopingBuffer
(
    LPCSTR pszFile,
    LPDIRECTSOUNDBUFFER     *pBuffer
)
{

    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
    DWORD dwDuration;

    hr = CreateBufferFromFile(pszFile,
                              0,
                              &pDSBuffer,
                              &dwDuration);
    if (SUCCEEDED(hr)) {

        hr = pDSBuffer->SetLoopRegion( 0, 0);

    }

    if (SUCCEEDED(hr)) {

        hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    }

    *pBuffer = pDSBuffer;

    return hr;
}

HRESULT
DownloadEffectsImage(PCHAR pszScratchFile)
{

    LPDIRECTSOUND           pDirectSound;
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer=NULL;
    DWORD err;
    HRESULT hr=S_OK;

    UCHAR data[4] = {0,1,2,3};
    LPDSEFFECTIMAGEDESC pDesc;

    //
    // open scratch image file generated by xps2 tool
    //


    hFile = CreateFile(
        pszScratchFile,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        fprintf(stderr,"\n Failed to open the dsp image file.Error 0x%x\n", err);
        hr = HRESULT_FROM_WIN32(err);

    }

    if (SUCCEEDED(hr)) {

        dwSize = SetFilePointer(hFile, 0, NULL, FILE_END);              
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        pBuffer = new BYTE[dwSize];

        DWORD dwBytesRead;
        BOOL bResult = ReadFile(hFile,
            pBuffer,
            dwSize,
            &dwBytesRead,
            0);
        
        if (!bResult) {
            
            err = GetLastError();
            fprintf(stderr,"\n Failed to open the dsp image file.Error 0x%x\n", err);
            hr = HRESULT_FROM_WIN32(err);
    
        }

    }

    if (SUCCEEDED(hr)) {

        //
        // call dsound api to download the image..
        //

        hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

        if (SUCCEEDED(hr)) {

            hr = ValidateResult(pDirectSound->DownloadEffectsImage(pBuffer,
                                               dwSize,
                                               NULL,
                                               &pDesc));
        }

    }

    if (hFile) {
        CloseHandle(hFile);
    }
    
    if (pBuffer) {
        delete [] pBuffer;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\gpcycles\gpcycles.cpp ===
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>


extern HRESULT PlaySineWave(double Frequency, DWORD dwMixBins,LPDIRECTSOUNDBUFFER     *pBuffer );

extern HRESULT
PlayLoopingBuffer
(
    LPCSTR pszFile,
    LPDIRECTSOUNDBUFFER     *pBuffer
);

extern HRESULT
DownloadEffectsImage(PCHAR pszScratchFile);

#define MAX_GP_IDLE_CYCLES  106720 // 32 samples at 160Mhz (or 667us*160Mhz)

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_BLACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" }    
};

#define NUM_HELP_CALLOUTS 2

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    FLOAT       m_fGPAvgCycles;
    DWORD       m_dwGPMinCycles;
    DWORD       m_dwGPMaxCycles;

    // Draw help?
    BOOL        m_bDrawHelp;

    HRESULT     m_hOpenResult;
    LPDIRECTSOUNDBUFFER m_pDSBuffer;
    LPDIRECTSOUNDBUFFER m_pOscillatorBuffer0;
    LPDIRECTSOUNDBUFFER m_pOscillatorBuffer1;
    LPDIRECTSOUNDBUFFER m_pOscillatorBuffer2;

};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_fGPAvgCycles = 0.0f;
    m_dwGPMinCycles = -1;
    m_dwGPMaxCycles = 0;
}

//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT                 hr  = DS_OK;
        
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    //
    // create oscillators that drive FX
    //

    hr = PlaySineWave(3,DSMIXBIN_FXSEND_2,&m_pOscillatorBuffer0);
    if(SUCCEEDED(hr)) hr = PlaySineWave(1,DSMIXBIN_FXSEND_3,&m_pOscillatorBuffer1);
    if(SUCCEEDED(hr)) hr = PlaySineWave(1005,DSMIXBIN_FXSEND_4,&m_pOscillatorBuffer2);

    //
    // create audio buffer
    //

    if(SUCCEEDED(hr)) hr = PlayLoopingBuffer("d:\\media\\sounds\\CleanGuitarArpeggios.wav", &m_pDSBuffer);

    //
    // download an effects image
    //
    
    if(SUCCEEDED(hr)) hr = DownloadEffectsImage("d:\\media\\scratchimg.bin");

    return S_OK;
}

#define ELAPSED_TIME_BASE    (0x30000+512-4*sizeof(DWORD))

#define USAGE_SCALE 20.0f
// CPU_MAXTIME is 100% CPU utilization in seconds
#define CPU_MAXTIME 0.016667f * 6
// GPU_MAXTIME is 100% GPU utilization in seconds
#define GPU_MAXTIME 0.016667f * 6
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    LARGE_INTEGER liFreq;
    FLOAT         fSecondsPerTick;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liCurrent;

    DWORD dwValue;

    //
    // get some DSP usage statistics straight from a variable inside the DSP X-ram and print them out
    //

    dwValue = MAX_GP_IDLE_CYCLES - *(PDWORD)(0xFE800000+ELAPSED_TIME_BASE);
    m_fGPAvgCycles = (FLOAT) dwValue;

    if (dwValue>m_dwGPMaxCycles) {
        m_dwGPMaxCycles=dwValue;
    }

    if (dwValue<m_dwGPMinCycles) {
        m_dwGPMinCycles=dwValue;
    }

    if (m_dwGPMinCycles <= 1000) {
        m_dwGPMinCycles = m_dwGPMaxCycles;
    }

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    WCHAR szString[256];
    DWORD dwValue=0;

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    dwValue = (DWORD)m_fGPAvgCycles;
    swprintf (szString,L"Average DSP Idle cycles per Frame: %d",dwValue);
    m_Font.DrawText( 50, 150, 0xFFFF0000, szString);

    swprintf (szString,L"Min.(worst case) DSP Idle cycles per Frame: %d",m_dwGPMinCycles);
    m_Font.DrawText( 50, 250, 0xFF0000FF, szString);

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );

    // Draw the GP Avg cycles Usage bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 100, x2 = x1 + (340*m_fGPAvgCycles)/MAX_GP_IDLE_CYCLES;
        FLOAT y1 = 180, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffff0000;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffff0000;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Draw the minimum cycles bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 100, x2 = x1 + (340*(FLOAT)m_dwGPMinCycles)/MAX_GP_IDLE_CYCLES;
        FLOAT y1 = 280, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xff0000ff;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xff0000ff;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"GPCycles" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\i3dl2\i3dl2.cpp ===
//-----------------------------------------------------------------------------
// File: I3DL2.cpp
//
// Desc: This sample demonstrates how to use the 3D capabilities of 
//       DirectSound, moving a sound source and listener in 3D.
//
// Hist: 12.15.00 - New for December XDK release
//       03.09.01 - Rewritten for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include "dsound.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
};

#define NUM_HELP_CALLOUTS 8



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\Heli.wav",
    "D:\\Media\\Sounds\\Dolphin1.wav",
    "D:\\Media\\Sounds\\Dolphin2.wav",
    "D:\\Media\\Sounds\\Dolphin3.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
    "D:\\Media\\Sounds\\Dolphin5.wav",
};


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    // Sound members
    CWaveFile               m_awfSounds[6];         // Wave file parsers
    DWORD                   m_dwCurrent;            // Current sound
    BOOL                    m_bPlaying;             // Are we playing?
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE *                  m_pbSampleData;         // Sample data from wav

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadScratch(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;
    m_pbSampleData = NULL;

    // Positions
    m_vSourcePosition    = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );
}




//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadScratch(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        if (SUCCEEDED(hr))
        {
            hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                                  dwSize,
                                                  NULL,
                                                  &pDesc );
        }
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    //
    // download a default scratch image that contains crosstalk
    // We must do this to get any 3d voice sound out the speakers
    //
    if( FAILED( DownloadScratch("d:\\media\\crosstalk.bin") ) )
        return E_FAIL;

    //
    // For testing purposes:
    // Make sure that all our files have the same format,
    // since we're re-using the samd DirectSoundBuffer for
    // all the files.
    //
    WAVEFORMATEX wfFirst;
    WAVEFORMATEX wfWalk;
    for( i = 0; i < sizeof( g_aszFileNames ) / sizeof( g_aszFileNames[0] ); i++ )
    {
        if( FAILED( m_awfSounds[ i ].Open( g_aszFileNames[i] ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Testing only:
        // Verify they're all the same format, since we're only going to have
        // one sound buffer.
        if( i == 0 )
        {
            if( FAILED( m_awfSounds[ i ].GetFormat( &wfFirst, sizeof( WAVEFORMATEX ) ) ) )
                return E_FAIL;
        }
        else
        {
            if( FAILED( m_awfSounds[ i ].GetFormat( &wfWalk, sizeof( WAVEFORMATEX ) ) ) )
                return E_FAIL;

            if( memcmp( &wfFirst, &wfWalk, sizeof( WAVEFORMATEX ) ) )
            {
                OUTPUT_DEBUG_STRING( "All wav files should have the same format!\n" );
                return E_FAIL;
            }
        }
    }

    //
    // Create a sound buffer of 0 size, since we're going to use
    // SetBufferData
    //
    DSBUFFERDESC dsbdesc;
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    /* If fewer than 256 buffers are in existence at all points during 
       the game, it may be more efficient not to use LOCDEFER. */
    // dsbdesc.dwFlags = DSBCAPS_CTRL3D;
    dsbdesc.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_LOCDEFER;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = &wfFirst;

    if( FAILED( m_pDSound->CreateSoundBuffer( &dsbdesc, &m_pDSBuffer, NULL ) ) )
        return E_FAIL;

    //
    // Set the transform matrices
    //

    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    //
    // Create our vertex buffers
    //
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();


    // Set up and play our initial sound
    m_dwCurrent = 0;
    SwitchToSound( m_dwCurrent );
    m_bPlaying = TRUE;
    m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Reallocate the sample data buffer
//       3) Point the DirectSoundBuffer to the new data
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    DWORD dwNewSize;

    // If we're currently playing, stop, so that we don't crash
    // when we reallocate our buffer
    if( m_bPlaying )
        m_pDSBuffer->Stop( );

    // Calling stop doesn't immediately shut down
    // the voice, so point it away from our buffer
    m_pDSBuffer->SetBufferData( NULL, 0 );

    // Find out how big the new sample is
    m_awfSounds[ dwIndex ].GetDuration( &dwNewSize );

    // Set our allocation to that size
    if( m_pbSampleData )
        delete[] m_pbSampleData;
    m_pbSampleData = new BYTE[ dwNewSize ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

    // Read sample data from the file
    m_awfSounds[ dwIndex ].ReadSample( 0, m_pbSampleData, dwNewSize, &dwNewSize );

    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( 0, dwNewSize );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // If we were playing before, restart playback now
    if( m_bPlaying )
        m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX *     pVertices;
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDSBuffer->Stop( );
        else
            m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

        m_bPlaying = !m_bPlaying;
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % ( sizeof( g_aszFileNames ) / sizeof( g_aszFileNames[0] ) );
        SwitchToSound( m_dwCurrent );
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    //
    // Move selected object and clamp to the appropriate range
    //
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    //
    // Update source/listener vertex buffers
    //
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cSource;
    pVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cSource;
    pVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cSource;
    pVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cSource;
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cListener;
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cListener;
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cListener;
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cListener;
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    //
    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    // We scale the velocities by 2 so that doppler effect
    // is a bit more noticable.
    //
    D3DXVECTOR3 vListenerVelocity = 2.0f * ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = 2.0f * ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;

    // Source position/velocity/volume
    m_pDSBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    m_pDSBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );
    m_pDSBuffer->SetVolume( m_lVolume );

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    DSI3DL2BUFFER ds3db = {0};

    ds3db.lDirect = 0;
    ds3db.lDirectHF = 0;
    ds3db.lRoom = 0;
    ds3db.lRoomHF = 0;
    ds3db.flRoomRolloffFactor = 0.0f;
    ds3db.Obstruction.lHFLevel = 0;
    ds3db.Obstruction.flLFRatio = 0.0f;
    ds3db.Occlusion.lHFLevel = 0;
    ds3db.Occlusion.flLFRatio = 0.0f;
    m_pDSBuffer->SetI3DL2Source( &ds3db, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the source
    m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

		m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"I3DL2" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF404040, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %d%%", 100 * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\MultiPass\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\MultiPass\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\MultiPass\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\MultiPass\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\MultiPass\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\play3dsound\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\play3dsound\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\ManualPanning\ManualPanning.cpp ===
//-----------------------------------------------------------------------------
// File: ManualPanning.cpp
//
// Desc: The ManualPanning sample demonstrates how to perform panning by 
//       sending a buffer to different mixbins and controlling the mixbin
//       volume.  This sample demonstrates the mixbins for individual speakers,
//       but the process is the same for non-speaker mixbins
//
// Hist: 4.30.01 - New for June release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBSound.h>
#include <dsound.h>
#include <xgraphics.h>
#include "dsstdfx.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle playback" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle Looping" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select\nspeaker" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change speaker\nvolume" },
};

#define NUM_HELP_CALLOUTS 8

// List of wav files to cycle through
const char g_strBasePath[] = "D:\\Media\\Sounds\\";
char * g_aszFileNames[] = 
{
    "heli.wav",
    "DockingMono.wav",
    "EngineStartMono.wav",
    "MaleDialog1.wav",
    "MiningMono.wav",
    "MusicMono.wav",
    "Dolphin4.wav",
};
static const DWORD NUM_SOUNDS = sizeof( g_aszFileNames ) / sizeof( g_aszFileNames[0] );

// Struct containing speaker information
typedef struct
{
    DWORD   dwMixBinID;
    LONG    lVolume;
    WCHAR * szDescription;
} OPTION_STRUCT;

// List of speakers/mixbins we can configure
OPTION_STRUCT g_aOptions[] =
{
    { DSMIXBIN_FRONT_LEFT,      DSBVOLUME_MAX,  L"Front Left" },
    { DSMIXBIN_FRONT_RIGHT,     DSBVOLUME_MAX,  L"Front Right" },
    { DSMIXBIN_FRONT_CENTER,    DSBVOLUME_MAX,  L"Front Center" },
    { DSMIXBIN_LOW_FREQUENCY,   DSBVOLUME_MAX,  L"Low Frequency" },
    { DSMIXBIN_BACK_LEFT,       DSBVOLUME_MAX,  L"Back Left" },
    { DSMIXBIN_BACK_RIGHT,      DSBVOLUME_MAX,  L"Back Right" },
};
static const DWORD NUM_OPTIONS = sizeof( g_aOptions ) / sizeof( g_aOptions[0] );

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    BOOL        m_bDrawHelp;
    CXBFont     m_Font;
    CXBHelp     m_Help;

    CWaveFile               m_awfSounds[NUM_SOUNDS];// Wave file parsers
    DWORD                   m_dwCurrent;            // Current sound
    BOOL                    m_bPlaying;             // Are we playing?
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE *                  m_pbSampleData;         // Sample data from wav
    BOOL                    m_bLooping;             // TRUE if loop is enabled
    DWORD                   m_dwOption;             // Selected option
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object


    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;
    m_pbSampleData = NULL;
    m_dwOption = 0;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    //
    // For testing purposes:
    // Make sure that all our files have the same format,
    // since we're re-using the samd DirectSoundBuffer for
    // all the files.  First, we have to determine how
    // much space to allocate for the wave format, since
    // the XBOXADPCMWAVEFORMAT is 2 bytes larger than
    // WAVEFORMATEX.
    //
    DWORD          cbFirst;
    WAVEFORMATEX * pwfFirst = NULL;
    DWORD          cbWalk;
    WAVEFORMATEX * pwfWalk = NULL;
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        char strFullPath[MAX_PATH];

        strcpy( strFullPath, g_strBasePath );
        strcat( strFullPath, g_aszFileNames[i] );
        if( FAILED( m_awfSounds[ i ].Open( strFullPath ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Testing only:
        // Verify they're all the same format, since we're only going to have
        // one sound buffer.
        if( i == 0 )
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbFirst );
            pwfFirst = (WAVEFORMATEX *)new BYTE[ cbFirst ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfFirst, cbFirst ) ) )
                return E_FAIL;
        }
        else
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbWalk );
            pwfWalk = (WAVEFORMATEX *)new BYTE[ cbWalk ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfWalk, cbWalk ) ) )
                return E_FAIL;

            if( cbWalk != cbFirst ||
                memcmp( pwfFirst, pwfWalk, cbFirst ) )
            {
                OUTPUT_DEBUG_STRING( "All wav files should have the same format!\n" );
                return E_FAIL;
            }

            delete[] pwfWalk;
        }
    }

    //
    // Create a sound buffer of 0 size, since we're going to use
    // SetBufferData
    //
    DSBUFFERDESC dsbdesc;
    DSMIXBINS dsmixbins;
    DSMIXBINVOLUMEPAIR dsmbvp[6];
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    /* If fewer than 256 buffers are in existence at all points during 
       the game, it may be more efficient not to use LOCDEFER. */
    dsbdesc.dwFlags = DSBCAPS_LOCDEFER;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = pwfFirst;
    dsbdesc.lpMixBins = &dsmixbins;

    dsmixbins.dwMixBinCount = 6;
    dsmixbins.lpMixBinVolumePairs = dsmbvp;

    dsmbvp[0].dwMixBin = DSMIXBIN_FRONT_LEFT;
    dsmbvp[0].lVolume = DSBVOLUME_MAX;
    dsmbvp[1].dwMixBin = DSMIXBIN_FRONT_RIGHT;
    dsmbvp[1].lVolume = DSBVOLUME_MAX;
    dsmbvp[2].dwMixBin = DSMIXBIN_FRONT_CENTER;
    dsmbvp[2].lVolume = DSBVOLUME_MAX;
    dsmbvp[3].dwMixBin = DSMIXBIN_LOW_FREQUENCY;
    dsmbvp[3].lVolume = DSBVOLUME_MAX;
    dsmbvp[4].dwMixBin = DSMIXBIN_BACK_LEFT;
    dsmbvp[4].lVolume = DSBVOLUME_MAX;
    dsmbvp[5].dwMixBin = DSMIXBIN_BACK_RIGHT;
    dsmbvp[5].lVolume = DSBVOLUME_MAX;

    if( FAILED( DirectSoundCreateBuffer( &dsbdesc, &m_pDSBuffer ) ) )
        return E_FAIL;

    // Set up and play our initial sound
    m_dwCurrent = 0;
    m_bPlaying = TRUE;
    m_bLooping = TRUE;
    SwitchToSound( m_dwCurrent );

    // Clean up our memory allocations
    delete[] pwfFirst;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Reallocate the sample data buffer
//       3) Point the DirectSoundBuffer to the new data
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    DWORD dwNewSize;
    DWORD dwLoopStartSample, dwLoopLengthSamples;
    DWORD cbLoopStart, cbLoopLength;

    // If we're currently playing, stop, so that we don't crash
    // when we reallocate our buffer
    if( m_bPlaying )
    {
        m_pDSBuffer->Stop();
    }

    // Calling stop doesn't immediately shut down
    // the voice, so point it away from our buffer
    m_pDSBuffer->SetBufferData( NULL, 0 );

    // Find out how big the new sample is
    m_awfSounds[ dwIndex ].GetDuration( &dwNewSize );

    // Set our allocation to that size
    if( m_pbSampleData )
        delete[] m_pbSampleData;
    m_pbSampleData = new BYTE[ dwNewSize ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

    // Read sample data from the file
    m_awfSounds[ dwIndex ].ReadSample( 0, m_pbSampleData, dwNewSize, &dwNewSize );

    // Check for embedded loop points
    if( SUCCEEDED( m_awfSounds[ dwIndex ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
    {
        WAVEFORMATEX wfx;

        // We're not interested in the whole wave format, which is
        // why we can get away with just loading the core WAVEFORMATEX
        m_awfSounds[ dwIndex ].GetFormat( &wfx, sizeof( WAVEFORMATEX ) );

        // We need to convert the loop points from sample counts to
        // byte offsets, but it's slightly different between PCM and ADPCM
        if( wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
        {
            // For ADPCM, calculate # of blocks and multiply that
            // by bytes per block.  Xbox ADPCM is always 64 samples
            // per block.
            cbLoopStart = dwLoopStartSample / 64 * wfx.nBlockAlign;
            cbLoopLength = dwLoopLengthSamples / 64 * wfx.nBlockAlign;
        }
        else
        {
            // For PCM, multiply by bytes per sample
            DWORD cbBytesPerSample = wfx.nChannels * wfx.wBitsPerSample / 8;
            cbLoopStart = dwLoopStartSample * cbBytesPerSample;
            cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
        }
    }
    else
    {
        // Otherwise, just loop the whole file
        cbLoopStart = 0;
        cbLoopLength = dwNewSize;
    }


    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( cbLoopStart, cbLoopLength );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // If we were playing before, restart playback now
    if( m_bPlaying )
    {
        m_pDSBuffer->Play( 0, 0, m_bLooping ? DSBPLAY_LOOPING : 0 );
    }

    return S_OK;
}


#define VOLUME_SCALE 5.0f
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Check if buffer is still playing
    DWORD dwStatus;
    m_pDSBuffer->GetStatus( &dwStatus );
    m_bPlaying = dwStatus & DSBSTATUS_PLAYING;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDSBuffer->Stop( );
        else
        {
            // Start playback at beginning of buffer
            m_pDSBuffer->SetCurrentPosition( 0 );
            m_pDSBuffer->Play( 0, 0, m_bLooping ? DSBPLAY_LOOPING : 0 );
            m_bPlaying = TRUE;
        }
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
        SwitchToSound( m_dwCurrent );
    }

    // Cycle through speakers
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        m_dwOption = ( m_dwOption + NUM_OPTIONS - 1 ) % NUM_OPTIONS;
    }
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        m_dwOption = ( m_dwOption + 1 ) % NUM_OPTIONS;
    }

    // Adjust selected speaker volume
    LONG lDelta = LONG(m_DefaultGamepad.fX2 * m_fElapsedTime * 1500 );
    g_aOptions[ m_dwOption ].lVolume += lDelta;
    if( g_aOptions[ m_dwOption ].lVolume < DSBVOLUME_MIN )
        g_aOptions[ m_dwOption ].lVolume = DSBVOLUME_MIN;
    else if( g_aOptions[ m_dwOption ].lVolume > DSBVOLUME_MAX )
        g_aOptions[ m_dwOption ].lVolume = DSBVOLUME_MAX;

    // Toggle looping
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bLooping = !m_bLooping;

        // If we were playing, make another call to play to change looping
        if( m_bPlaying )
            m_pDSBuffer->Play( 0, 0, m_bLooping ? DSBPLAY_LOOPING : 0 );
    }

    // Set overall buffer volume
    m_pDSBuffer->SetVolume( m_lVolume );
    
    // Build up a bitmap with active speakers and an array 
    // of active speaker volumes
    DSMIXBINS dsmixbins;
    DSMIXBINVOLUMEPAIR dsmbvp[DSMIXBIN_ASSIGNMENT_MAX];

    dsmixbins.dwMixBinCount = 0;
    dsmixbins.lpMixBinVolumePairs = dsmbvp;

    for( int i = 0; i < sizeof( g_aOptions ) / sizeof( g_aOptions[0] ); i++ )
    {
        // If this speaker is more than minimum volume, 
        if( g_aOptions[i].lVolume > DSBVOLUME_MIN )
        {
            // Add it to the bitmap and volume array
            dsmbvp[dsmixbins.dwMixBinCount].dwMixBin = g_aOptions[i].dwMixBinID;
            dsmbvp[dsmixbins.dwMixBinCount].lVolume = g_aOptions[i].lVolume;

            dsmixbins.dwMixBinCount++;
        }
    }

    // Set all speaker volumes
    m_pDSBuffer->SetMixBinVolumes( &dsmixbins );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ManualPanning" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S %s", g_aszFileNames[ m_dwCurrent ], m_bLooping ? L"(Looping)" : L"" );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF808080, szBuff );
        swprintf( szBuff, L"Buffer Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / ( DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 130, 0xFFFFFF00, szBuff );

        for( int i = 0; i < sizeof( g_aOptions ) / sizeof( g_aOptions[0] ); i++ )
        {
            DWORD dwColor;
            
            // Determine color based on if speaker is selected and if it's active
            if( m_dwOption == i )
                dwColor = ( g_aOptions[i].lVolume == DSBVOLUME_MIN ) ? 0xFFE0E0E0 : 0xFFFFFFFF;
            else
                dwColor = ( g_aOptions[i].lVolume == DSBVOLUME_MIN ) ? 0xFFA0A000 : 0xFFFFFF00;

            swprintf( szBuff, L"%s: %ddB (%0.0f%%)", g_aOptions[i].szDescription, 
                                           g_aOptions[i].lVolume / 100,
                                           100.0f * ( g_aOptions[i].lVolume - DSBVOLUME_MIN ) / ( DSBVOLUME_MAX - DSBVOLUME_MIN ) );
            m_Font.DrawText( 64, 160.0f + i * 30, dwColor, szBuff );
        }
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\play3dsound\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\play3dsound\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\play3dsound\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\SetFilter\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\SetFilter\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\SetFilter\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\SetFilter\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\SetFilter\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\MultiPass\MultiPass.cpp ===
//-----------------------------------------------------------------------------
// File: MultiPass.cpp
//
// Desc: This sample demonstrates how to use the multipass audio processing
//       capabilities of DirectSound on the Xbox.  Several standard DirectSound
//       buffers are created, and are set to output to another 3D Buffer, which
//       is then positioned.
//
// Hist: 05.10.01 - New for June Release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include "dsound.h"
#include "dsstdfx.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle Headphones" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
};

#define NUM_HELP_CALLOUTS 9



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\heli.wav",
    "D:\\Media\\Sounds\\DockingMono.wav",
    "D:\\Media\\Sounds\\EngineStartMono.wav",
    "D:\\Media\\Sounds\\MaleDialog1.wav",
    "D:\\Media\\Sounds\\MiningMono.wav",
    "D:\\Media\\Sounds\\MusicMono.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
};

#define NUM_SOUNDS 7

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    // Sound members
    DWORD                   m_dwCurrent;            // Current sound
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object
    LPDIRECTSOUNDBUFFER8    m_pDS3DBuffer;            // 3D DirectSoundBuffer

    BOOL                    m_bPlaying[NUM_SOUNDS];     // Is buffer playing?
    LONG                    m_lVolume[NUM_SOUNDS];      // Buffer volume
    CWaveFile               m_awfSounds[NUM_SOUNDS];    // Wave file parsers
    LPDIRECTSOUNDBUFFER8    m_apBuffers[NUM_SOUNDS];    // Non-3D Buffers
    BYTE *                  m_pbSampleData[NUM_SOUNDS]; // Sample data from wavs
    BOOL                    m_bHeadphones;              // True if headphones enabled

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    HRESULT CXBoxSample::LoadSounds();              // Loads list of wav files
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_bHeadphones = FALSE;

    // Set up sounds
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        m_lVolume[i] = DSBVOLUME_MAX;
        m_pbSampleData[i] = NULL;
        m_apBuffers[i] = NULL;
    }


    // Positions
    m_vSourcePosition    = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}


//-----------------------------------------------------------------------------
// Name: LoadSounds
// Desc: Creates a DirectSound Buffer for each wav file and reads the sample
//       data from the wav file.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::LoadSounds()
{
    //
    // Create buffers for each of our sound effects and load
    // the sample data from the wav files
    //
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        DWORD        cbFormat;
        WAVEFORMATEX * pwfx;
        DSBUFFERDESC dsbdesc;
        DWORD        dwDuration;
        DWORD        dwLoopStartSample, dwLoopLengthSamples;
        DWORD        cbLoopStart, cbLoopLength;

        if( FAILED( m_awfSounds[ i ].Open( g_aszFileNames[i] ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Allocate space for the wave format
        m_awfSounds[ i ].GetFormat( NULL, 0, &cbFormat );
        pwfx = (WAVEFORMATEX *)new BYTE[ cbFormat ];

        if( FAILED( m_awfSounds[ i ].GetFormat( pwfx, cbFormat ) ) )
            return E_FAIL;

        //
        // Create a sound buffer of 0 size, since we're going to use
        // SetBufferData
        //
        ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
        dsbdesc.dwSize = sizeof( DSBUFFERDESC );
        
        /* If fewer than 256 buffers are in existence at all points during 
           the game, it may be more efficient not to use LOCDEFER. */
        // dsbdesc.dwFlags = 0;
        dsbdesc.dwFlags = DSBCAPS_LOCDEFER;
        dsbdesc.dwBufferBytes = 0;
        dsbdesc.lpwfxFormat = pwfx;

        if( FAILED( m_pDSound->CreateSoundBuffer( &dsbdesc, &m_apBuffers[i], NULL ) ) )
            return E_FAIL;

        // Find out how big the sample is
        m_awfSounds[i].GetDuration( &dwDuration );

        // Allocate a buffer for this sound
        m_pbSampleData[i] = (BYTE *)XPhysicalAlloc( dwDuration, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE );
        if( !m_pbSampleData[i] )
            return E_OUTOFMEMORY;

        // Read sample data from the file
        m_awfSounds[i].ReadSample( 0, m_pbSampleData[i], dwDuration, &dwDuration );

        // Check for embedded loop points
        if( SUCCEEDED( m_awfSounds[ i ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
        {
            // We need to convert the loop points from sample counts to
            // byte offsets, but it's slightly different between PCM and ADPCM
            if( pwfx->wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
            {
                // For ADPCM, calculate # of blocks and multiply that
                // by bytes per block.  Xbox ADPCM is always 64 samples
                // per block.
                cbLoopStart = dwLoopStartSample / 64 * pwfx->nBlockAlign;
                cbLoopLength = dwLoopLengthSamples / 64 * pwfx->nBlockAlign;
            }
            else
            {
                // For PCM, multiply by bytes per sample
                DWORD cbBytesPerSample = pwfx->nChannels * pwfx->wBitsPerSample / 8;
                cbLoopStart = dwLoopStartSample * cbBytesPerSample;
                cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
            }
        }
        else
        {
            // Otherwise, just loop the whole file
            cbLoopStart = 0;
            cbLoopLength = dwDuration;
        }

        // Set up values for the new buffer
        m_apBuffers[i]->SetBufferData( m_pbSampleData[i], dwDuration );
        m_apBuffers[i]->SetLoopRegion( cbLoopStart, cbLoopLength );
        m_apBuffers[i]->SetCurrentPosition( 0 );

        // Set initial values for the buffer
        m_bPlaying[i] = FALSE;
        m_lVolume[i] = DSBVOLUME_MAX;
        m_apBuffers[i]->SetVolume( m_lVolume[i] );
        m_apBuffers[i]->SetOutputBuffer( m_pDS3DBuffer );

        delete[] pwfx;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the app
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    /* If the application doesn't care about vertical HRTF positioning,
       calling DirectSoundUseLightHRTF can save about 60k of memory. */
    // DirectSoundUseLightHRTF();
    DirectSoundUseFullHRTF();

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Set up 3d Buffer desc
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwFlags = DSBCAPS_MIXIN | DSBCAPS_CTRL3D;
    dsbd.lpwfxFormat = NULL;
    if( FAILED( m_pDSound->CreateSoundBuffer( &dsbd, &m_pDS3DBuffer, NULL ) ) )
        return E_FAIL;

    // Create and initialize our individual sound buffers
    if( FAILED( LoadSounds() ) )
        return E_FAIL;

    //
    // Set the transform matrices
    //
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    //
    // Create our vertex buffers
    //
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();

    // Set up and play our initial sound
    m_dwCurrent = 0;
    m_bPlaying[0] = TRUE;
    m_apBuffers[0]->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX *     pVertices;
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume[m_dwCurrent] += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                                    m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                                    m_fElapsedTime * 
                                    VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume[m_dwCurrent] < DSBVOLUME_MIN )
        m_lVolume[m_dwCurrent] = DSBVOLUME_MIN;
    else if( m_lVolume[m_dwCurrent] > DSBVOLUME_MAX )
        m_lVolume[m_dwCurrent] = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying[m_dwCurrent] )
            m_apBuffers[m_dwCurrent]->Stop( );
        else
            m_apBuffers[m_dwCurrent]->Play( 0, 0, DSBPLAY_LOOPING );

        m_bPlaying[m_dwCurrent] = !m_bPlaying[m_dwCurrent];
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    // Toggle headphones
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_bHeadphones = !m_bHeadphones;
        m_pDSound->EnableHeadphones( m_bHeadphones );
    }

    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    //
    // Move selected object and clamp to the appropriate range
    //
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    //
    // Update source/listener vertex buffers
    //
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cSource;
    pVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cSource;
    pVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cSource;
    pVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cSource;
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = m_cListener;
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = m_cListener;
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = m_cListener;
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = m_cListener;
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    //
    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    // We scale the velocities by 2 so that doppler effect
    // is a bit more noticable.
    //
    D3DXVECTOR3 vListenerVelocity = 2.0f * ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = 2.0f * ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;

    // Source position/velocity/volume
    m_pDS3DBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    m_pDS3DBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );
    m_apBuffers[m_dwCurrent]->SetVolume( m_lVolume[m_dwCurrent] );

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the source
    m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

		m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"MultiPass" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying[m_dwCurrent] ? 0xFFFFFFFF : 0xFF808080, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume[m_dwCurrent] / 100, 100.0f * ( m_lVolume[m_dwCurrent] - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
        if( m_bHeadphones )
            m_Font.DrawText( 64, 220, 0xFFFFFF00, L"Headphones enabled");
        else
            m_Font.DrawText( 64, 220, 0x80808000, L"Headphones disabled");

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\voiceDSP\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\SetFilter\SetFilter.cpp ===
//-----------------------------------------------------------------------------
// File: SetFilter.cpp
//
// Desc: The SetFilter sample demonstrates how to use the programmable filter
//       block provided by DirectSound.
//
// Hist: 4.30.01 - Created
//       7.18.01 - Added routines for calculating coefficients
//      10.15.01 - Updated Parametric EQ gain
//
// Warning: This sample is still in progress.  The routines for calculating
//      DLS2 coefficients are an approximation and are not perfect.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBSound.h>
#include <dsound.h>
#include <xgraphics.h>
#include "dsstdfx.h"
#include <math.h>

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle playback" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle DLS2" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle ParamEQ" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select parameter" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change parameter" },
};

#define NUM_HELP_CALLOUTS 9

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\noise.wav",
    "D:\\Media\\Sounds\\55.wav",
    "D:\\Media\\Sounds\\110.wav",
    "D:\\Media\\Sounds\\220.wav",
    "D:\\Media\\Sounds\\440.wav",
    "D:\\Media\\Sounds\\880.wav",
    "D:\\Media\\Sounds\\1760.wav",
    "D:\\Media\\Sounds\\3520.wav",
    "D:\\Media\\Sounds\\7040.wav",
    "D:\\Media\\Sounds\\14080.wav",
};

#define NUM_SOUNDS 10


typedef struct
{
    DWORD dwScale;          // Joystick scale factor
    WCHAR * szDescription;  // Description of option
} OPTION_STRUCT;

OPTION_STRUCT g_aOptions[] =
{
    { 1000,  L"DLS2 Filter Freq" },
    { 10000, L"DLS2 Resonance" },
    { 1000, L"ParamEQ Filter Freq" },
    { 10000, L"ParamEQ Filter Gain" },
    { 10000, L"ParamEQ Filter Q" },
};

typedef enum
{
    DLS2_CutoffFrequency,
    DLS2_Resonance,
    PARAMEQ_Frequency,
    PARAMEQ_Gain,
    PARAMEQ_Q,
    NUM_OPTIONS,
} FILTER_OPTION;

#define RES_SCALE 1000
#define PEQ_GAIN_SCALE 400


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;

    CWaveFile               m_awfSounds[NUM_SOUNDS];// Wave file parsers
    DWORD                   m_dwCurrent;            // Current sound
    BOOL                    m_bPlaying;             // Are we playing?
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE *                  m_pbSampleData;         // Sample data from wav
    DSFILTERDESC            m_dsfd;                 // DSFILTERDESC struct
    DWORD                   m_dwParam;              // Selected parameter
    BOOL                    m_bDLS2;                // Enable DLS2 filter
    BOOL                    m_bParamEQ;             // Enable ParamEQ filter
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object

    FLOAT                   m_fDLS2Freq;            // DLS2 cutoff frequency
    LONG                    m_lDLS2Resonance;       // DLS2 resonance * RES_SCALE
    LONG                    m_lParamEQFreq;
    LONG                    m_lParamEQGain;
    LONG                    m_lParamEQQ;


    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;
    m_pbSampleData = NULL;
    m_lDLS2Resonance = 0;
    m_fDLS2Freq = 440;
    m_lParamEQFreq = 1000;
    m_lParamEQGain = 4096;
    m_lParamEQQ = 0;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    //
    // For testing purposes:
    // Make sure that all our files have the same format,
    // since we're re-using the samd DirectSoundBuffer for
    // all the files.  First, we have to determine how
    // much space to allocate for the wave format, since
    // the XBOXADPCMWAVEFORMAT is 2 bytes larger than
    // WAVEFORMATEX.
    //
    DWORD          cbFirst;
    WAVEFORMATEX * pwfFirst = NULL;
    DWORD          cbWalk;
    WAVEFORMATEX * pwfWalk = NULL;
    for( int i = 0; i < NUM_SOUNDS; i++ )
    {
        if( FAILED( m_awfSounds[ i ].Open( g_aszFileNames[i] ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Testing only:
        // Verify they're all the same format, since we're only going to have
        // one sound buffer.
        if( i == 0 )
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbFirst );
            pwfFirst = (WAVEFORMATEX *)new BYTE[ cbFirst ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfFirst, cbFirst ) ) )
                return E_FAIL;
        }
        else
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbWalk );
            pwfWalk = (WAVEFORMATEX *)new BYTE[ cbWalk ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfWalk, cbWalk ) ) )
                return E_FAIL;

            if( cbWalk != cbFirst ||
                memcmp( pwfFirst, pwfWalk, cbFirst ) )
            {
                OUTPUT_DEBUG_STRING( "All wav files should have the same format!\n" );
                return E_FAIL;
            }

            delete[] pwfWalk;
        }
    }

    //
    // Create a sound buffer of 0 size, since we're going to use
    // SetBufferData
    //
    DSBUFFERDESC dsbdesc;
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    /* If fewer than 256 buffers are in existence at all points during 
       the game, it may be more efficient not to use LOCDEFER. */
    dsbdesc.dwFlags = DSBCAPS_LOCDEFER;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = pwfFirst;
    if( FAILED( DirectSoundCreateBuffer( &dsbdesc, &m_pDSBuffer ) ) )
        return E_FAIL;

    // Set up and play our initial sound
    m_dwCurrent = 0;
    SwitchToSound( m_dwCurrent );
    m_bPlaying = TRUE;
    // m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    // Disable filters to start with
    m_dwParam = 0;
    ZeroMemory( &m_dsfd, sizeof( DSFILTERDESC ) );
    m_bDLS2 = FALSE;
    m_bParamEQ = FALSE;

    // Clean up our memory allocation
    delete[] pwfFirst;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Reallocate the sample data buffer
//       3) Point the DirectSoundBuffer to the new data
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    DWORD dwNewSize;
    DWORD dwLoopStartSample, dwLoopLengthSamples;
    DWORD cbLoopStart, cbLoopLength;

    // If we're currently playing, stop, so that we don't crash
    // when we reallocate our buffer
    if( m_bPlaying )
    {
        m_pDSBuffer->Stop();
    }

    // Calling stop doesn't immediately shut down
    // the voice, so point it away from our buffer
    m_pDSBuffer->SetBufferData( NULL, 0 );

    // Find out how big the new sample is
    m_awfSounds[ dwIndex ].GetDuration( &dwNewSize );

    // Set our allocation to that size
    if( m_pbSampleData )
        delete[] m_pbSampleData;
    m_pbSampleData = new BYTE[ dwNewSize ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

    // Read sample data from the file
    m_awfSounds[ dwIndex ].ReadSample( 0, m_pbSampleData, dwNewSize, &dwNewSize );

    // Check for embedded loop points
    if( SUCCEEDED( m_awfSounds[ dwIndex ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
    {
        WAVEFORMATEX wfx;

        // We're not interested in the whole wave format, which is
        // why we can get away with just loading the core WAVEFORMATEX
        m_awfSounds[ dwIndex ].GetFormat( &wfx, sizeof( WAVEFORMATEX ) );

        // We need to convert the loop points from sample counts to
        // byte offsets, but it's slightly different between PCM and ADPCM
        if( wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
        {
            // For ADPCM, calculate # of blocks and multiply that
            // by bytes per block.  Xbox ADPCM is always 64 samples
            // per block.
            cbLoopStart = dwLoopStartSample / 64 * wfx.nBlockAlign;
            cbLoopLength = dwLoopLengthSamples / 64 * wfx.nBlockAlign;
        }
        else
        {
            // For PCM, multiply by bytes per sample
            DWORD cbBytesPerSample = wfx.nChannels * wfx.wBitsPerSample / 8;
            cbLoopStart = dwLoopStartSample * cbBytesPerSample;
            cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
        }
    }
    else
    {
        // Otherwise, just loop the whole file
        cbLoopStart = 0;
        cbLoopLength = dwNewSize;
    }


    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( cbLoopStart, cbLoopLength );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // If we were playing before, restart playback now
    if( m_bPlaying )
        m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FreqToHardwareCoeff
// Desc: Calculates coefficient value[0] for DLS2 filter from a frequency
//-----------------------------------------------------------------------------
ULONG FreqToHardwareCoeff( FLOAT fFreq )
{
    FLOAT fNormCutoff = fFreq / 48000.0f;

    // Filter is ineffective out of these ranges, so why
    // bother even trying?
    if( fFreq < 30.0f )
        return 0x8000;
    if( fFreq > 8000.0f )
        return 0x0;

    FLOAT fFC = FLOAT( 2.0f * sin( D3DX_PI * fNormCutoff ) );
    LONG lOctaves = LONG( 4096.0f * log( fFC ) / log( 2.0f ) );

    return (ULONG)lOctaves & 0xFFFF;
}



//-----------------------------------------------------------------------------
// Name: dBToHardwareCoeff
// Desc: Calculates coefficient value[1] for DLS2 filter from resonance in dB
//-----------------------------------------------------------------------------
ULONG dBToHardwareCoeff( LONG lResonance )
{
    FLOAT fResonance = (FLOAT)lResonance;

    if( fResonance > 22.5f )
        fResonance = 22.5f;

    double fQ = pow( 10.0, -0.05*fResonance);
    unsigned int dwQ = (unsigned int)(fQ*(1<<15));
    if( dwQ > 0xFFFF )
        dwQ = 0xFFFF;

    return (ULONG)dwQ;
}


 

#define VOLUME_SCALE 5.0f
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDSBuffer->Stop( );
        else
            m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

        m_bPlaying = !m_bPlaying;
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
        SwitchToSound( m_dwCurrent );
    }

    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        if( m_dwParam == 0 )
            m_dwParam = NUM_OPTIONS - 1;
        else
            m_dwParam = ( m_dwParam - 1 );
    }
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        m_dwParam = ( m_dwParam + 1 ) % NUM_OPTIONS;
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_dsfd.dwMode ^= DSFILTER_MODE_DLS2;
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_dsfd.dwMode ^= DSFILTER_MODE_PARAMEQ;
    }

    // Adjust value of currently selected parameter
    LONG lDelta = LONG(m_DefaultGamepad.fX2 * m_fElapsedTime * g_aOptions[ m_dwParam ].dwScale );
    switch( m_dwParam )
    {
    case DLS2_CutoffFrequency:
        m_fDLS2Freq += lDelta;
        if( m_fDLS2Freq < 0.0f )
            m_fDLS2Freq = 0.0f;
        else if( m_fDLS2Freq > 8000 )
            m_fDLS2Freq = 8000;
        break;
    case DLS2_Resonance:
        m_lDLS2Resonance += lDelta;
        if( m_lDLS2Resonance < 0 )
            m_lDLS2Resonance = 0;
        else if( m_lDLS2Resonance > 22 * RES_SCALE )
            m_lDLS2Resonance = 22 * RES_SCALE;
        break;
    case PARAMEQ_Frequency:
        m_lParamEQFreq += lDelta;
        if( m_lParamEQFreq < 0 )
            m_lParamEQFreq = 0;
        else if( m_lParamEQFreq > 8000 )
            m_lParamEQFreq = 8000;
        break;
    case PARAMEQ_Gain:
        m_lParamEQGain += lDelta;
        if( m_lParamEQGain < -8192 )
            m_lParamEQGain = -8192;
        else if( m_lParamEQGain > 8191 )
            m_lParamEQGain = 8191;
        break;
    case PARAMEQ_Q:
        m_lParamEQQ += lDelta;
        if( m_lParamEQQ < 0 )
            m_lParamEQQ = 0;
        else if( m_lParamEQQ / RES_SCALE > 7 )
            m_lParamEQQ = 7 * RES_SCALE;
        break;
    }

    // 
    // Note!!!:
    // For stereo buffers, where you can only use DLS2 OR ParamEQ, you must 
    // set both pairs of coefficients (one for each channel).
    //
    m_dsfd.adwCoefficients[0] = FreqToHardwareCoeff( m_fDLS2Freq );
    m_dsfd.adwCoefficients[1] = dBToHardwareCoeff( m_lDLS2Resonance / RES_SCALE );
    m_dsfd.adwCoefficients[2] = FreqToHardwareCoeff( FLOAT(m_lParamEQFreq) );
    m_dsfd.adwCoefficients[3] = m_lParamEQGain & 0xFFFF;
    m_dsfd.dwQCoefficient = m_lParamEQQ / RES_SCALE;

    m_pDSBuffer->SetVolume( m_lVolume );
    m_pDSBuffer->SetFilter( &m_dsfd );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"SetFilter" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF606060, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 130, 0xFFFFFF00, szBuff );
        swprintf( szBuff, L"DLS2 %s  ParamEQ %s", m_dsfd.dwMode & DSFILTER_MODE_DLS2 ? L"Enabled" : L"Disabled", m_dsfd.dwMode & DSFILTER_MODE_PARAMEQ ? L"Enabled" : L"Disabled" );
        m_Font.DrawText( 64, 160, 0xFFFFFF00, szBuff );

        for( int i = 0; i < NUM_OPTIONS; i++ )
        {
            switch( i )
            {
            case DLS2_CutoffFrequency:
                swprintf( szBuff, L"%s: %0.2fHz", g_aOptions[i].szDescription, m_fDLS2Freq );
                break;
            case DLS2_Resonance:
                swprintf( szBuff, L"%s: %lddB", g_aOptions[i].szDescription, m_lDLS2Resonance / RES_SCALE );
                break;
            case PARAMEQ_Frequency:
                swprintf( szBuff, L"%s: %ldHz", g_aOptions[i].szDescription, m_lParamEQFreq );
                break;
            case PARAMEQ_Gain:
                swprintf( szBuff, L"%s: %lddB", g_aOptions[i].szDescription, m_lParamEQGain / PEQ_GAIN_SCALE );
                break;
            case PARAMEQ_Q:
                swprintf( szBuff, L"%s: %ld", g_aOptions[i].szDescription, m_lParamEQQ / RES_SCALE );
                break;
            }
            m_Font.DrawText( 64, FLOAT(190 + i * 30), i == m_dwParam ? 0xFFFFFFFF : 0xFFFFFF00, szBuff );
        }

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\play3dsound\Play3DSound.cpp ===
//-----------------------------------------------------------------------------
// File: Play3DSound.cpp
//
// Desc: This sample demonstrates how to use the 3D capabilities of 
//       DirectSound, moving a sound source and listener in 3D.
//
// Hist: 12.15.00 - New for December XDK release
//       03.09.01 - Rewritten for April XDK release
//       01.21.02 - Added Listener orientation
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBSound.h>
#include <XBHelp.h>
#include "dsound.h"
#include "dsstdfx.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle source/\nlistener" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle Headphones" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Increase volume" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Decrease volume" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move object in Y" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move object in X/Z" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Change wall\nmaterials" },
    { XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_2, L"Triggers:\nChange Environment" },
};

#define NUM_HELP_CALLOUTS 11



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5

#define WALL1_XMIN ( XMIN )
#define WALL1_XMAX ( XMAX )
#define WALL1_ZMIN ( ZMAX - 0.12f * ( ZMAX - ZMIN ) )
#define WALL1_ZMAX ( ZMAX - 0.10f * ( ZMAX - ZMIN ) )

#define WALL2_XMIN ( XMIN + 0.25f * ( XMAX - XMIN ) )
#define WALL2_XMAX ( XMIN + 0.75f * ( XMAX - XMIN ) )
#define WALL2_ZMIN ( ZMAX - 0.42f * ( ZMAX - ZMIN ) )
#define WALL2_ZMAX ( ZMAX - 0.40f * ( ZMAX - ZMIN ) )

// Constants for colors
#define SOURCE_COLOR 0xFFFF0000
#define LISTENER_COLOR 0xFF0000FF

// Constants for scaling input
#define MOTION_SCALE 10.0f
#define VOLUME_SCALE  5.0f

// List of wav files to cycle through
char * g_aszFileNames[] = 
{
    "D:\\Media\\Sounds\\heli.wav",
    "D:\\Media\\Sounds\\DockingMono.wav",
    "D:\\Media\\Sounds\\EngineStartMono.wav",
    "D:\\Media\\Sounds\\MaleDialog1.wav",
    "D:\\Media\\Sounds\\MiningMono.wav",
    "D:\\Media\\Sounds\\MusicMono.wav",
    "D:\\Media\\Sounds\\Dolphin4.wav",
};
static const DWORD NUM_SOUNDS = sizeof( g_aszFileNames ) / sizeof( g_aszFileNames[0] );

typedef struct
{
    WCHAR *szName;
    LONG lHFLevel;
    FLOAT flLFRatio;
} I3DL2MATERIAL;

I3DL2MATERIAL g_aMaterials[] =
{
    { L"None",           0,    0.0f  },
    { L"Single Window", -2800, 0.71f },
    { L"Double Window", -5000, 0.40f },
    { L"Thin Door",     -1800, 0.66f },
    { L"Thick Door",    -4400, 0.64f },
    { L"Wood Wall",     -4000, 0.50f },
    { L"Brick Wall",    -5000, 0.60f },
    { L"Stone Wall",    -6000, 0.68f },
    { L"Curtain",       -1200, 0.15f },
};
static const DWORD NUM_MATERIALS = sizeof( g_aMaterials ) / sizeof( g_aMaterials[0] );

typedef struct
{
    WCHAR *         szName;
    DSI3DL2LISTENER ds3dl;
} I3DL2ENVIRONMENT;
    
I3DL2ENVIRONMENT g_aEnvironments[] =
{
    { L"Default",           { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT }        },
    { L"Generic",           { DSI3DL2_ENVIRONMENT_PRESET_GENERIC }        },
    { L"Padded Cell",       { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL }     },
    { L"Room",              { DSI3DL2_ENVIRONMENT_PRESET_ROOM }           },
    { L"Bathroom",          { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM }       },
    { L"Living Room",       { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM }     },
    { L"Stone Room",        { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM }      },
    { L"Auditorium",        { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM }     },
    { L"Concert Hall",      { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL }    },
    { L"Cave",              { DSI3DL2_ENVIRONMENT_PRESET_CAVE }           },
    { L"Arena",             { DSI3DL2_ENVIRONMENT_PRESET_ARENA }          },
    { L"Hangar",            { DSI3DL2_ENVIRONMENT_PRESET_HANGAR }         },
    { L"Carpeted Hallway",  { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY }},
    { L"Hallway",           { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY }        },
    { L"Stone Corridor",    { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR }  },
    { L"Alley",             { DSI3DL2_ENVIRONMENT_PRESET_ALLEY }          },
    { L"Forest",            { DSI3DL2_ENVIRONMENT_PRESET_FOREST }         },
    { L"City",              { DSI3DL2_ENVIRONMENT_PRESET_CITY }           },
    { L"Mountains",         { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS }      },
    { L"Quarry",            { DSI3DL2_ENVIRONMENT_PRESET_QUARRY }         },
    { L"Plain",             { DSI3DL2_ENVIRONMENT_PRESET_PLAIN }          },
    { L"Parking Lot",       { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT }     },
    { L"Sewer Pipe",        { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE }      },
    { L"Underwater",        { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER }     },
};
static const DWORD NUM_ENVIRONMENTS = sizeof( g_aEnvironments ) / sizeof( g_aEnvironments[0] );

static const FLOAT DOPPLER_FACTOR = 2.0f;


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;                 // Font object
    CXBHelp                 m_Help;                 // Help object

    // Sound members
    CWaveFile               m_awfSounds[NUM_SOUNDS];// Wave file parsers
    DWORD                   m_dwCurrent;            // Current sound
    BOOL                    m_bPlaying;             // Are we playing?
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE *                  m_pbSampleData;         // Sample data from wav
    BOOL                    m_bHeadphones;          // True if headphones enabled

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector
    FLOAT                   m_fListenerAngle;       // Listener orientation angle in x-z
    D3DXVECTOR3             m_vListenerOrientationTop; // Listener top orientation vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Models for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbFloor;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbSource;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pvbListener;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pvbGrid;              // Lines to grid the floor
    LPDIRECT3DVERTEXBUFFER8 m_pvbWall1;             // 1st wall
    LPDIRECT3DVERTEXBUFFER8 m_pvbWall2;             // 2nd wall

    D3DCOLOR        m_cSource;                      // Color for sound source
    D3DCOLOR        m_cListener;                    // Color for listener

    BOOL            m_bDrawHelp;                    // Should we draw help?
    BOOL            m_bControlSource;               // Control source (TRUE) or
                                                    // listener (FALSE)

    DWORD           m_dwOcclusionMaterial;          // Occlusion material
    DWORD           m_dwObstructionMaterial;        // Obstruction material
    FLOAT           m_fObstructFactor;              // Obstruction factor
    DWORD           m_dwEnvironment;                // Environment

    HRESULT SwitchToSound( DWORD dwIndex );         // Sets up a different sound
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
    FLOAT CalculateObstructionFactor();             // Calculates obstruction factor

public:
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    // Sounds
    m_lVolume = DSBVOLUME_MAX;
    m_pbSampleData = NULL;
    m_bHeadphones = FALSE;

    // Positions
    m_vSourcePosition   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, ZMIN );

    // listener default orientation
    m_fListenerAngle = 0.0f;
    m_vListenerOrientationTop   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    m_dwOcclusionMaterial   = 3;    // Thin door
    m_dwObstructionMaterial = 6;    // Brick wall
    m_dwEnvironment         = 0;
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    int i, j;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    // There are 2 options for 3-D sound processing:
    // 1) DirectSoundUseFullHRTF - full hardware HRTF-based processing
    // 2) DirectSoundUseLightHRTF - hardware HRTF processing, but without
    //      any vertical component (azimuth only).  Saves ~60k of memory
    DirectSoundUseFullHRTF();

    // Exaggerate the doppler effect for demonstration purposes.
    m_pDSound->SetDopplerFactor( DOPPLER_FACTOR, DS3D_IMMEDIATE );
    
    // download the standard DirectSound effecs image
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    //
    // For testing purposes:
    // Make sure that all our files have the same format,
    // since we're re-using the samd DirectSoundBuffer for
    // all the files.  First, we have to determine how
    // much space to allocate for the wave format, since
    // the XBOXADPCMWAVEFORMAT is 2 bytes larger than
    // WAVEFORMATEX.
    //
    DWORD          cbFirst;
    WAVEFORMATEX * pwfFirst = NULL;
    DWORD          cbWalk;
    WAVEFORMATEX * pwfWalk = NULL;
    for( i = 0; i < NUM_SOUNDS; i++ )
    {
        if( FAILED( m_awfSounds[ i ].Open( g_aszFileNames[i] ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        // Testing only:
        // Verify they're all the same format, since we're only going to have
        // one sound buffer.
        if( i == 0 )
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbFirst );
            pwfFirst = (WAVEFORMATEX *)new BYTE[ cbFirst ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfFirst, cbFirst ) ) )
                return E_FAIL;
        }
        else
        {
            // Allocate space for the wave format
            m_awfSounds[ i ].GetFormat( NULL, 0, &cbWalk );
            pwfWalk = (WAVEFORMATEX *)new BYTE[ cbWalk ];

            if( FAILED( m_awfSounds[ i ].GetFormat( pwfWalk, cbWalk ) ) )
                return E_FAIL;

            if( cbWalk != cbFirst ||
                memcmp( pwfFirst, pwfWalk, cbFirst ) )
            {
                OUTPUT_DEBUG_STRING( "All wav files should have the same format!\n" );
                return E_FAIL;
            }

            delete[] pwfWalk;
        }
    }

    // Create a sound buffer of 0 size, since we're going to use
    // SetBufferData
    DSBUFFERDESC dsbdesc;
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    // If fewer than 256 buffers are in existence at all points during 
    //   the game, it may be more efficient not to use LOCDEFER
    dsbdesc.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_LOCDEFER;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = pwfFirst;

    if( FAILED( m_pDSound->CreateSoundBuffer( &dsbdesc, &m_pDSBuffer, NULL ) ) )
        return E_FAIL;

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create our vertex buffers
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbFloor );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbSource );
    m_pd3dDevice->CreateVertexBuffer( 3 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbListener );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbGrid );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbWall1 );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pvbWall2 );
    
    D3DVERTEX * pVertices;

    // Fill the VB for the listener
    m_pvbListener->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( -0.5f, 0.0f, -1.0f ); pVertices[0].c = LISTENER_COLOR; // m_cListener;
    pVertices[1].p = D3DXVECTOR3(  0.0f, 0.0f,  1.0f ); pVertices[1].c = LISTENER_COLOR; // m_cListener;
    pVertices[2].p = D3DXVECTOR3(  0.5f, 0.0f, -1.0f ); pVertices[2].c = LISTENER_COLOR; // m_cListener;

    // Fill the VB for the source
    m_pvbSource->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = SOURCE_COLOR; // m_cSource;
    pVertices[1].p = D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = SOURCE_COLOR; // m_cSource;
    pVertices[2].p = D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = SOURCE_COLOR; // m_cSource;
    pVertices[3].p = D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = SOURCE_COLOR; // m_cSource

    // Fill the VB for the floor
    m_pvbFloor->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pVertices[0].c = 0xFF101010;
    pVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pVertices[1].c = 0xFF101010;
    pVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pVertices[2].c = 0xFF101010;
    pVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pVertices[3].c = 0xFF101010;
    m_pvbFloor->Unlock();

    // Fill the VB for the grid
    m_pvbGrid->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pVertices[ j * 2 ].c     = 0xFF00A000;
        pVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pvbGrid->Unlock();

    // Set up first (full width) wall
    m_pvbWall1->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( WALL1_XMIN, 0.0f, WALL1_ZMIN ); pVertices[0].c = 0xFF808080;
    pVertices[1].p = D3DXVECTOR3( WALL1_XMIN, 0.0f, WALL1_ZMAX ); pVertices[1].c = 0xFF808080;
    pVertices[2].p = D3DXVECTOR3( WALL1_XMAX, 0.0f, WALL1_ZMIN ); pVertices[2].c = 0xFF808080;
    pVertices[3].p = D3DXVECTOR3( WALL1_XMAX, 0.0f, WALL1_ZMAX ); pVertices[3].c = 0xFF808080;
    m_pvbWall1->Unlock();

    // Set up second (smaller) wall
    m_pvbWall2->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3( WALL2_XMIN, 0.0f, WALL2_ZMIN ); pVertices[0].c = 0xFF808080;
    pVertices[1].p = D3DXVECTOR3( WALL2_XMIN, 0.0f, WALL2_ZMAX ); pVertices[1].c = 0xFF808080;
    pVertices[2].p = D3DXVECTOR3( WALL2_XMAX, 0.0f, WALL2_ZMIN ); pVertices[2].c = 0xFF808080;
    pVertices[3].p = D3DXVECTOR3( WALL2_XMAX, 0.0f, WALL2_ZMAX ); pVertices[3].c = 0xFF808080;
    m_pvbWall2->Unlock();

    // Set up and play our initial sound
    m_dwCurrent = 0;
    SwitchToSound( m_dwCurrent );
    m_bPlaying = TRUE;
    m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    // Clean up our memory allocations
    delete[] pwfFirst;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SwitchToSound
// Desc: Switches to the given sound by:
//       1) Stop playback if we're playing
//       2) Reallocate the sample data buffer
//       3) Point the DirectSoundBuffer to the new data
//       4) Restart plyaback if needed
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::SwitchToSound( DWORD dwIndex )
{
    DWORD dwNewSize;
    DWORD dwLoopStartSample, dwLoopLengthSamples;
    DWORD cbLoopStart, cbLoopLength;

    // If we're currently playing, stop, so that we don't crash
    // when we reallocate our buffer
    if( m_bPlaying )
    {
        m_pDSBuffer->Stop();
    }

    // Calling stop doesn't immediately shut down
    // the voice, so point it away from our buffer
    m_pDSBuffer->SetBufferData( NULL, 0 );

    // Find out how big the new sample is
    m_awfSounds[ dwIndex ].GetDuration( &dwNewSize );

    // Set our allocation to that size
    if( m_pbSampleData )
        delete[] m_pbSampleData;
    m_pbSampleData = new BYTE[ dwNewSize ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

    // Read sample data from the file
    m_awfSounds[ dwIndex ].ReadSample( 0, m_pbSampleData, dwNewSize, &dwNewSize );

    // Check for embedded loop points
    if( SUCCEEDED( m_awfSounds[ dwIndex ].GetLoopRegion( &dwLoopStartSample, &dwLoopLengthSamples ) ) )
    {
        WAVEFORMATEX wfx;

        // We're not interested in the whole wave format, which is
        // why we can get away with just loading the core WAVEFORMATEX
        m_awfSounds[ dwIndex ].GetFormat( &wfx, sizeof( WAVEFORMATEX ) );

        // We need to convert the loop points from sample counts to
        // byte offsets, but it's slightly different between PCM and ADPCM
        if( wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM )
        {
            // For ADPCM, calculate # of blocks and multiply that
            // by bytes per block.  Xbox ADPCM is always 64 samples
            // per block.
            cbLoopStart = dwLoopStartSample / 64 * wfx.nBlockAlign;
            cbLoopLength = dwLoopLengthSamples / 64 * wfx.nBlockAlign;
        }
        else
        {
            // For PCM, multiply by bytes per sample
            DWORD cbBytesPerSample = wfx.nChannels * wfx.wBitsPerSample / 8;
            cbLoopStart = dwLoopStartSample * cbBytesPerSample;
            cbLoopLength = dwLoopLengthSamples * cbBytesPerSample;
        }
    }
    else
    {
        // Otherwise, just loop the whole file
        cbLoopStart = 0;
        cbLoopLength = dwNewSize;
    }


    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( cbLoopStart, cbLoopLength );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // If we were playing before, restart playback now
    if( m_bPlaying )
        m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CalculateObstructionFactor
// Desc: Calculates the obstruction factor for the 2nd wall.  Assumes that 
//       the second wall is actually a valid obstruction (ie, the line between
//       source and listener should cross through it).  Calculates the cos
//       of the angles made by source, wall edge, and listener on each side
//       of the wall, and returns the lesser.
//-----------------------------------------------------------------------------
FLOAT CXBoxSample::CalculateObstructionFactor()
{
    float a2, b2, c2, cosC;
    float fObLeft, fObRight;

    // We want to figure out the angle formed by the source,
    // the listener, and the edge of the wall, using law of 
    // cosines (lower case = edge, uppper case = angle):
    // c^2 = a^2 + b^2 - 2ab * cos C
    // cos C = ( c^2 - a^2 - b^2 ) / -2ab
    // We'll do this for both the left and right edges of the
    // wall, and take the smaller one.  A more accurate model
    // could be used that combined the two.
    a2 = ( m_vListenerPosition.x - WALL2_XMAX ) * ( m_vListenerPosition.x - WALL2_XMAX ) + 
         ( m_vListenerPosition.z - WALL2_ZMAX ) * ( m_vListenerPosition.z - WALL2_ZMAX );
    b2 = ( m_vSourcePosition.x - WALL2_XMAX ) * ( m_vSourcePosition.x - WALL2_XMAX ) + 
         ( m_vSourcePosition.z - WALL2_ZMAX ) * ( m_vSourcePosition.z - WALL2_ZMAX );
    c2 = ( m_vListenerPosition.x - m_vSourcePosition.x ) * ( m_vListenerPosition.x - m_vSourcePosition.x ) +
         ( m_vListenerPosition.z - m_vSourcePosition.z ) * ( m_vListenerPosition.z - m_vSourcePosition.z );

    cosC = float( ( c2 - a2 - b2 ) / ( -2.0f * sqrt( a2 ) * sqrt( b2 ) ) );

    // Smaller angle means less obstruction.
    // cos(0) = 1
    // cos(90) = 0
    // cos(180) = -1
    // Rough estimate of obstruction factor is (1 - cosC) / 2
    fObRight = ( 1.0f + cosC ) / 2.0f;

    // Now repeat for the left wall
    a2 = ( m_vListenerPosition.x - WALL2_XMIN ) * ( m_vListenerPosition.x - WALL2_XMIN ) + ( m_vListenerPosition.z - WALL2_ZMIN ) * ( m_vListenerPosition.z - WALL2_ZMIN );
    b2 = ( m_vSourcePosition.x - WALL2_XMIN ) * ( m_vSourcePosition.x - WALL2_XMIN ) + ( m_vSourcePosition.z - WALL2_ZMIN ) * ( m_vSourcePosition.z - WALL2_ZMIN );

    cosC = float( ( c2 - a2 - b2 ) / ( -2.0f * sqrt( a2 ) * sqrt( b2 ) ) );

    fObLeft = ( 1.0f + cosC ) / 2.0f;

    return ( fObLeft < fObRight ) ? fObLeft : fObRight;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXVECTOR3     vSourceOld   = m_vSourcePosition;
    D3DXVECTOR3     vListenerOld = m_vListenerPosition;
    D3DXVECTOR3 *   pvControl;
    DWORD           dwPulse = DWORD( ( cosf( m_fAppTime * 6.0f ) + 1.0f ) * 50 );
    D3DCOLOR        cBlend = dwPulse | ( dwPulse << 8 ) | ( dwPulse << 16 );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_BLACK ] - 
                   m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_WHITE ] ) *
                   m_fElapsedTime * 
                   VOLUME_SCALE );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    else if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Toggle sound on and off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDSBuffer->Stop( );
        else
            m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

        m_bPlaying = !m_bPlaying;
    }

    // Cycle through sounds
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % NUM_SOUNDS;
        SwitchToSound( m_dwCurrent );
    }

    // Switch which of source vs. listener we are moving
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_bControlSource = !m_bControlSource;
    }

    // Toggle headphones
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        m_bHeadphones = !m_bHeadphones;
        m_pDSound->EnableHeadphones( m_bHeadphones );
    }

    // Changing listener enviornment settings is expensive, so only do it when we're
    // actually changing the environment.
    BOOL bResetListener = FALSE;
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_LEFT_TRIGGER ] )
    {
        m_dwEnvironment = ( m_dwEnvironment + NUM_ENVIRONMENTS - 1 ) % NUM_ENVIRONMENTS;
        bResetListener = TRUE;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_RIGHT_TRIGGER ] )
    {
        m_dwEnvironment = ( m_dwEnvironment + 1 ) % NUM_ENVIRONMENTS;
        bResetListener = TRUE;
    }

    if( bResetListener )
    {
        m_pDSound->SetI3DL2Listener( &g_aEnvironments[ m_dwEnvironment ].ds3dl, DS3D_DEFERRED );
    }

    // Select occlusion/obstruction materials
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        m_dwOcclusionMaterial = ( m_dwOcclusionMaterial + 1 ) % NUM_MATERIALS;
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        m_dwOcclusionMaterial = ( m_dwOcclusionMaterial + NUM_MATERIALS - 1 ) % NUM_MATERIALS;
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        m_dwObstructionMaterial = ( m_dwObstructionMaterial + 1 ) % NUM_MATERIALS;
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
        m_dwObstructionMaterial = ( m_dwObstructionMaterial + NUM_MATERIALS - 1 ) % NUM_MATERIALS;

    // Set up our colors
    m_cSource   = SOURCE_COLOR   | (  m_bControlSource ? cBlend : 0 );
    m_cListener = LISTENER_COLOR | ( !m_bControlSource ? cBlend : 0 );

    // Point to the appropriate vector
    pvControl = m_bControlSource ? &m_vSourcePosition : &m_vListenerPosition;

    // Move selected object and clamp to the appropriate range
    pvControl->x += m_DefaultGamepad.fX1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->x < XMIN )
        pvControl->x = XMIN;
    else if( pvControl->x > XMAX )
        pvControl->x = XMAX;

    pvControl->z += m_DefaultGamepad.fY1 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->z < ZMIN )
        pvControl->z = ZMIN;
    else if( pvControl->z > ZMAX )
        pvControl->z = ZMAX;

    pvControl->y += m_DefaultGamepad.fY2 * m_fElapsedTime * MOTION_SCALE;
    if( pvControl->y < YMIN )
        pvControl->y = YMIN;
    else if( pvControl->y > YMAX )
        pvControl->y = YMAX;

    // Calculate listener orientation in x-z plane
    if( m_vListenerPosition.x != vListenerOld .x ||
        m_vListenerPosition.z != vListenerOld .z )
    {
        D3DXVECTOR3 vDelta = m_vListenerPosition - vListenerOld;
        m_fListenerAngle = FLOAT( atan2( vDelta.x, vDelta.z ) );

        // set default listener orientation
        m_pDSound->SetOrientation( vDelta.x,
                                   0.0f,
                                   vDelta.z,
                                   m_vListenerOrientationTop.x,
                                   m_vListenerOrientationTop.y,
                                   m_vListenerOrientationTop.z,
                                   DS3D_DEFERRED );
    }

    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    D3DXVECTOR3 vListenerVelocity = ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;

    // Source position/velocity/volume
    m_pDSBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    m_pDSBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );
    m_pDSBuffer->SetVolume( m_lVolume );

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Calculate I3DL2 effects:
    BOOL bOccluded = FALSE;
    BOOL bObstructed = FALSE;

    // Occlusion - see if source and listener are on opposite sides of wall 1
    if( ( m_vSourcePosition.z > WALL1_ZMAX &&
          m_vListenerPosition.z < WALL1_ZMIN ) ||
        ( m_vSourcePosition.z < WALL1_ZMIN &&
          m_vListenerPosition.z > WALL1_ZMAX ) )
    {
        bOccluded = TRUE;
    }
    
    // Obstruction - calculate if line between source and listener
    // hits obstruction wall 2.  Calculate z-intercept value, and
    // then find x-value at that intercept.  If it's in the range 
    // of the wall, then we're obstructed
    float fGamma = ( WALL2_ZMAX - m_vSourcePosition.z ) / ( m_vListenerPosition.z - m_vSourcePosition.z );
    if( fGamma >= 0.0f && fGamma <= 1.0f )
    {
        float fxint = m_vSourcePosition.x + fGamma * ( m_vListenerPosition.x - m_vSourcePosition.x );
        if( fxint > WALL2_XMIN && fxint < WALL2_XMAX )
            bObstructed = TRUE;
    }

    //
    // Set up I3DL2BUFFER parameters
    //
    DSI3DL2BUFFER ds3db = {0};

    // Calculate obstruction factor based on angle between 
    // source, wall, and listener
    if( bObstructed )
        m_fObstructFactor = CalculateObstructionFactor();
    else
        m_fObstructFactor = 0.0f;

    // Calculate obstruction values:
    I3DL2MATERIAL mat = g_aMaterials[ m_dwObstructionMaterial ];
    ds3db.Obstruction.lHFLevel = LONG( m_fObstructFactor * mat.lHFLevel );
    ds3db.Obstruction.flLFRatio = m_fObstructFactor * mat.flLFRatio;

    // Set Occlusion values
    if( bOccluded )
    {
        ds3db.Occlusion.lHFLevel = g_aMaterials[ m_dwOcclusionMaterial ].lHFLevel;
        ds3db.Occlusion.flLFRatio = g_aMaterials[ m_dwOcclusionMaterial ].flLFRatio;
    }

    // Bring the reverb down by 6dB
    ds3db.lRoom = -600;

    m_pDSBuffer->SetI3DL2Source( &ds3db, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    //
    // call dsound to do some work of low priority queued items such
    // as notifications, stream packets completions, etc
    //
    DirectSoundDoWork();

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0xFF000000, 1.0f, 0L );

    RenderGradientBackground( 0xFF408040, 0xFF404040 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pvbFloor, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pvbGrid, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the first wall
    if( m_dwOcclusionMaterial != 0 )
    {
        m_pd3dDevice->SetStreamSource( 0, m_pvbWall1, sizeof( D3DVERTEX ) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }

    // Draw the second wall
    if( m_dwObstructionMaterial != 0 )
    {
        m_pd3dDevice->SetStreamSource( 0, m_pvbWall2, sizeof( D3DVERTEX ) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }

    // Draw the source
    {
        D3DXMATRIX matSource;
        D3DXMatrixTranslation( &matSource, 
                               m_vSourcePosition.x,
                               m_vSourcePosition.y,
                               m_vSourcePosition.z );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matSource );
        m_pd3dDevice->SetStreamSource( 0, m_pvbSource, sizeof( D3DVERTEX ) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }

    // Draw the listener
    {
        D3DXMATRIX matListener;
        D3DXMATRIX mat;

        D3DXMatrixTranslation( &matListener, m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        D3DXMatrixRotationY( &mat, m_fListenerAngle );
        D3DXMatrixMultiply( &matListener, &mat, &matListener );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matListener );
        m_pd3dDevice->SetStreamSource( 0, m_pvbListener, sizeof( D3DVERTEX ) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 1 );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szBuff[200];

		m_Font.Begin();
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"Play3DSound" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show status
        swprintf( szBuff, L"Current Sound: %S", g_aszFileNames[ m_dwCurrent ] );
        m_Font.DrawText( 64, 100, m_bPlaying ? 0xFFFFFFFF : 0xFF404040, szBuff );
        swprintf( szBuff, L"Source: <%0.1f, %0.1f, %0.1f>", m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z );
        m_Font.DrawText( 64, 130, m_cSource, szBuff );
        swprintf( szBuff, L"Listener: <%0.1f, %0.1f, %0.1f>", m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z );
        m_Font.DrawText( 64, 160, m_cListener, szBuff );
        swprintf( szBuff, L"Volume: %ddB (%0.0f%%)", m_lVolume / 100, 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN ) );
        m_Font.DrawText( 64, 190, 0xFFFFFF00, szBuff );
        swprintf( szBuff, L"Occluder: %s", g_aMaterials[ m_dwOcclusionMaterial ].szName );
        m_Font.DrawText( 64, 220, 0xFFFFFFFF, szBuff );
        swprintf( szBuff, L"Obstructor: %s", g_aMaterials[ m_dwObstructionMaterial ].szName );
        m_Font.DrawText( 64, 250, 0xFFFFFFFF, szBuff );
        swprintf( szBuff, L"Obstruction Factor: %0.2f", m_fObstructFactor );
        m_Font.DrawText( 64, 280, 0xFFFFFFFF, szBuff );
        swprintf( szBuff, L"Environment: %s", g_aEnvironments[ m_dwEnvironment ].szName );
        m_Font.DrawText( 64, 310, 0xFFFFFFFF, szBuff );
        if( m_bHeadphones )
            m_Font.DrawText( 64, 340, 0xFFFFFF00, L"Headphones enabled");
        else
            m_Font.DrawText( 64, 340, 0x80808000, L"Headphones disabled");

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\voiceDSP\fximg.h ===
typedef enum _DSP_IMAGE_DSSTDFX_FX_INDICES {
    FLANGE_CHAIN_FLANGE = 0,
    AMPMOD_CHAIN_AMPMOD = 1,
    SRC_CHAIN_SRC = 2
} DSP_IMAGE_DSSTDFX_FX_INDICES;

typedef struct _FLANGE_CHAIN_FX0_FLANGE_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} FLANGE_CHAIN_FX0_FLANGE_STATE, *LPFLANGE_CHAIN_FX0_FLANGE_STATE;

typedef const FLANGE_CHAIN_FX0_FLANGE_STATE *LPCFLANGE_CHAIN_FX0_FLANGE_STATE;

typedef struct _AMPMOD_CHAIN_FX0_AMPMOD_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_CHAIN_FX0_AMPMOD_STATE, *LPAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef const AMPMOD_CHAIN_FX0_AMPMOD_STATE *LPCAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef struct _SRC_CHAIN_FX0_SRC_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[1];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} SRC_CHAIN_FX0_SRC_STATE, *LPSRC_CHAIN_FX0_SRC_STATE;

typedef const SRC_CHAIN_FX0_SRC_STATE *LPCSRC_CHAIN_FX0_SRC_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\sounds.h ===
#pragma once

typedef enum
{
    WAVEBANK_SOUNDS_CLICK8BIT = 0,
    WAVEBANK_SOUNDS_CONSTRUCTIONSTEREO8BIT = 1,
    WAVEBANK_SOUNDS_DOCKINGMONO = 2,
    WAVEBANK_SOUNDS_DOLPHIN4 = 3,
    WAVEBANK_SOUNDS_ENGINESTARTMONO = 4,
    WAVEBANK_SOUNDS_EXPLOSIONSHOCKWAVE = 5,
    WAVEBANK_SOUNDS_HELI = 6,
    WAVEBANK_SOUNDS_INVEST = 7,
    WAVEBANK_SOUNDS_LARGEENERGYWEAPON = 8,
    WAVEBANK_SOUNDS_MALEDIALOG1 = 9,
    WAVEBANK_SOUNDS_MININGMONO = 10,
    WAVEBANK_SOUNDS_MUSICMONO = 11,
    WAVEBANK_SOUNDS_MUSICSTEREO = 12,
    WAVEBANK_SOUNDS_SELECT = 13,
} WAVEBANK_SOUNDS;

#define WAVEBANK_SOUNDS_ENTRY_COUNT 14
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\voiceDSP\voiceDSP.cpp ===
//-----------------------------------------------------------------------------
// File: VoiceDSP.cpp
//
// Desc: A sample to show how to utilize dsound and the DSPs to do voice processing
// in realtime and apply DSP fx to incoming or outgoing voices.
// A dsp image containing Flange is loaded using DownloadEffectsImage
// so hawk microphone data can be routed through the FX to demonstrate real time
// voice morphing. The output of the FX is then routed in the dsp to the SRC effect
// which then outputs 8khz 32 bit data in system memory. We then stream that data
// to the hawk headphone. See FXIMG.INI for what we load to the DSP 
// Hist: 10.15.01
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define DSOUND_IFACE_VERSION DSOUND_IFACE_VERSION_LATEST

#include "voicedsp.h"


#if DBG

ULONG g_dwVoiceDSPDebugLevel = DEBUG_LEVEL_WARNING;

#endif

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------

XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle DSP Voice Effect" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Change Oscillator Frequency" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select EQ parameter" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change EQ parameter" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle DLS2" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle ParamEQ" }

};

#define NUM_HELP_CALLOUTS 7

// Struct definition for describing effect chains
typedef struct {
    WCHAR * szDescription;
    DWORD   dwMixBinMask;
    DWORD   dwNumInputs;
    DWORD   dwNumOutputs;
    DWORD   dwEffectIndex;
} EFFECT_DESCRIPTION;

typedef enum
{
    DLS2_CutoffFrequency,
    DLS2_Resonance,
    PARAMEQ_Frequency,
    PARAMEQ_Gain,
    PARAMEQ_Q,
    NUM_OPTIONS,
} FILTER_OPTION;

#define RES_SCALE 1000
#define PEQ_GAIN_SCALE 400


#define MIXBIN_FXSEND_5  (1 << DSMIXBIN_FXSEND_5)
#define MIXBIN_FXSEND_2  (1 << DSMIXBIN_FXSEND_2)
#define MIXBIN_FXSEND_3  (1 << DSMIXBIN_FXSEND_3)
#define MIXBIN_CENTER (1 << DSMIXBIN_FRONT_CENTER)


// List of all effect chains, mixbins, and parameters
EFFECT_DESCRIPTION g_aEffectDescriptions[] =
{
    { L"None",          MIXBIN_CENTER | MIXBIN_FXSEND_5, 0, 0, -1},
    { L"Flange",        MIXBIN_FXSEND_2, 3, 2, AMPMOD_CHAIN_AMPMOD},
    { L"AmpMod",        MIXBIN_FXSEND_3, 3, 2, FLANGE_CHAIN_FLANGE},
};

typedef struct
{
    DWORD dwScale;          // Joystick scale factor
    WCHAR * szDescription;  // Description of option
} OPTION_STRUCT;

OPTION_STRUCT g_aOptions[] =
{
    { 5000,  L"DLS2 Filter Freq" },
    { 10000, L"DLS2 Resonance" },
    { 5000, L"ParamEQ Filter Freq" },
    { 10000, L"ParamEQ Filter Gain" },
    { 10000, L"ParamEQ Filter Q" },
};

//
// Simple macro to verify that the packet size is OK for a particular XMO
//
inline HRESULT XMOFILTER_VERIFY_PACKET_SIZE( XMEDIAINFO& xMediaInfo, DWORD dwPacketSize )
{
    if( xMediaInfo.dwOutputSize > dwPacketSize )
        return E_FAIL;
    if( xMediaInfo.dwOutputSize ) 
        if( dwPacketSize % xMediaInfo.dwOutputSize != 0 )
            return E_FAIL;
    if( dwPacketSize < xMediaInfo.dwMaxLookahead )
        return E_FAIL;

    return S_OK;
}

CFilterGraph::CFilterGraph()
{

    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    //
    // init some locals
    //

    m_pDSBufferOscillator = NULL;
    m_lOscillatorFrequency = 100;
    m_dwPortNumber = -1;
    m_dwCount= 0;
    m_dwOldPosition = 0xFFFFFFFF;
    m_pDSound = NULL;

    m_dwCurrentEffect = 0;

    m_dwParam = 0;
    ZeroMemory( &m_dsfd, sizeof( DSFILTERDESC ) );

    m_lParamEQFreq = 0;
    m_lParamEQGain = 0;
    m_lParamEQQ = 0;

    m_fDLS2Freq = 0;
    m_lDLS2Resonance = 0;

}

CFilterGraph::~CFilterGraph()
{

    if (m_pDSBufferOscillator) {
        m_pDSBufferOscillator->Release();
    }

    if (m_pDSound) {
        m_pDSound->Release();
    }

}


//-----------------------------------------------------------------------------
// Name: Initialize
//
// Desc: Creates a streaming graph between 2 XMOs: a source, and a target. 
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::Initialize()
{
    HRESULT        hr;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\fximg.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;
    m_bPaused = FALSE;

    InitializeStreamingObjects();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FindHeadsetPort()
// Desc: Returns the controller port of the first communicator device found
//-----------------------------------------------------------------------------
int CFilterGraph::FindHeadsetPort()
{
    DWORD dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    DWORD dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);

    if(dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("CXBoxSample::Voice()...dwConnectedMicrophones != dwConnectedHeadphone\n");
        return -1;
    }

    if(!dwConnectedMicrophones || !dwConnectedHeadphones)
    {
        return -1;
    }

    // Go through each port and see if there's a headset on it
    for(int i = 0; i < XGetPortCount(); ++i)
    {
        if(dwConnectedMicrophones & (1 << i))
        {
            return i;
        }
    }

    return -1;
}

HRESULT CFilterGraph::InitializeStreamingObjects()
{

    HRESULT hr = S_OK;
    DWORD          dwMinSize;
    XMEDIAINFO     xMediaInfo;
    DSSTREAMDESC   dssd;
    DSMIXBINS               dsMixBins;
    DSMIXBINVOLUMEPAIR      dsMixBinArray[8];

    memset(dsMixBinArray,0,sizeof(dsMixBinArray));

    //
    // enumerate a hawk device
    //    

    if (m_dwPortNumber == -1) {
        m_dwPortNumber = FindHeadsetPort();
    }
        
    if (m_dwPortNumber == -1) {
        return S_OK;
    }

    m_dwPacketSize     = PACKET_SIZE;
    m_dwMaxBufferCount = PACKET_CNT;

    m_wfxAudioFormat.wFormatTag = WAVE_FORMAT_PCM;
    m_wfxAudioFormat.nChannels = 1;
    m_wfxAudioFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    m_wfxAudioFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    m_wfxAudioFormat.nBlockAlign = 2;
    m_wfxAudioFormat.wBitsPerSample = 16;
    m_wfxAudioFormat.cbSize = 0;


    DBG_WARN(("Xbox Communicator found in port %d!\n", m_dwPortNumber));

    //
    //  Create the source xmo (microphone)
    //

    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                 &m_wfxAudioFormat, &m_pSourceXMO);

    if( FAILED( hr ) )
    {
        DBG_ERROR(("Failed to open hawk mic, hr %x", hr));
        return hr;
    }

    //
    // create the in-between transform XMO (Dsound)
    //

    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwFlags              = 0;
    dssd.dwMaxAttachedPackets = PACKET_CNT;
    dssd.lpMixBins            = &dsMixBins;
    dssd.lpwfxFormat          = &m_wfxAudioFormat;

    dsMixBins.dwMixBinCount = 3;
    dsMixBins.lpMixBinVolumePairs = dsMixBinArray;

    dsMixBinArray[0].dwMixBin = DSMIXBIN_FXSEND_5;
    dsMixBinArray[1].dwMixBin = DSMIXBIN_FRONT_LEFT;
    dsMixBinArray[2].dwMixBin = DSMIXBIN_FRONT_RIGHT;

    hr = DirectSoundCreateStream( &dssd, 
                                  (LPDIRECTSOUNDSTREAM*)&m_pTransformXMO );
    if( FAILED(hr) ) 
    {          
        DBG_ERROR( ("XmoFilter: DirectSoundCreateXMOStream failed with %x", hr) );
        DBG_ERROR( ("Init: Could not open a target audio XMO\n") );
        return hr;
    }

    //
    // create the target XMO (hawk)
    //

    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                 &m_wfxAudioFormat, &m_pTargetXMO);

    if( FAILED( hr ) )
    {
        DBG_ERROR(("Failed to open hawk headphone, hr %x", hr));
        return hr;
    }


    //
    // At this point we should have all the XMOs.
    // Figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned.
    // As a last check we make sure its also larger than the maxLookahead
    //
    // At the end of all this, m_dwMinPacketSize is the minimum packet size
    // for this filter graph.
    //
    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    if( m_pSourceXMO )
    {
        m_pSourceXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = xMediaInfo.dwOutputSize;

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    if( m_pTransformXMO )
    {
        m_pTransformXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = max( xMediaInfo.dwOutputSize, m_dwMinPacketSize );

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    if( m_pTargetXMO )
    {
        m_pTargetXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = max( xMediaInfo.dwOutputSize, m_dwMinPacketSize );

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    ASSERT( m_pTargetXMO );
    ASSERT( m_pSourceXMO );
    ASSERT( m_pTransformXMO );

    //
    // make sure SRC effect delay line is aligned with our packet size
    //

    ASSERT(m_pEffectsImageDesc->aEffectMaps[SRC_CHAIN_SRC].dwScratchSize%m_dwPacketSize == 0);

    // Initialize the linked lists
    m_SourcePendingList.Initialize();
    m_TransformPendingList.Initialize();
    m_TargetPendingList.Initialize();

    //
    // Allocate one large buffer for incoming/outgoing data. The buffer is
    // going to be divided among our media context packets, which will be 
    // used to stream data between XMOs
    //
    dwMinSize = MAXBUFSIZE;
    m_pTransferBuffer = (BYTE *)XPhysicalAlloc( dwMinSize,
                                                MAXULONG_PTR,
                                                0,
                                                PAGE_READWRITE | PAGE_NOCACHE );

    ZeroMemory( m_pTransferBuffer, dwMinSize );

    //
    // Allocate a context pool. A context is associated with a packet buffer
    // and used to track the pending packets attached to the source or target
    // XMO.
    dwMinSize = ( PACKET_CNT * sizeof(MEDIA_PACKET_CTX) );
    m_pPacketContextPool = new BYTE[dwMinSize];
    ZeroMemory( m_pPacketContextPool, dwMinSize );

    //
    // We attach all available packet buffers in the beginning to prime the
    // graph: As each packet is completed by the source XMO, the status is
    // udpated in its packet context and we pass the packet to the next XMO.
    //
    for( DWORD i = 0; i < PACKET_CNT; i++ ) 
    {
        MEDIA_PACKET_CTX* pCtx = &((MEDIA_PACKET_CTX*)m_pPacketContextPool)[i];

        ZeroMemory( pCtx, sizeof(MEDIA_PACKET_CTX) );
        pCtx->dwCompletedSize = m_dwPacketSize;
        pCtx->pBuffer         = &m_pTransferBuffer[i*PACKET_SIZE];

        AttachPacketToSourceXMO( pCtx );
    }

    hr = CreateSineWaveBuffer(m_lOscillatorFrequency,&m_pDSBufferOscillator);

    return hr;


}


//-----------------------------------------------------------------------------
// Name: AttachPacketToSourceXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       source XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // reset packet size
    pCtx->dwCompletedSize = m_dwPacketSize;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the source XMO (first xmo in the chain)
    hr = m_pSourceXMO->Process( NULL, &xmb );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our source list
    m_SourcePendingList.Add( &pCtx->ListEntry );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: AttachPacketToTransformXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       transform (in-between) XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToTransformXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer         
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the target XMO (first xmo in the chain)
    hr = m_pTransformXMO->Process( &xmb, NULL );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our target list
    m_TransformPendingList.Add( &pCtx->ListEntry );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: AttachPacketToTargetXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       target XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    //
    // figure out where we are in the circular buffer of the SRC FX.
    // Then stream the appropriate number of samples to the target XMO
    // 

    // retrieve effect parameters so we can getthe current buffer index from the DSP
    // delay line

    LPCDSFX_SAMPLE_RATE_CONVERTER_PARAMS pSrcParams = (LPCDSFX_SAMPLE_RATE_CONVERTER_PARAMS)m_pEffectsImageDesc->aEffectMaps[SRC_CHAIN_SRC].lpvStateSegment; 

    //
    // figure out where to read
    //

    DWORD dwCircularBufferSize = m_pEffectsImageDesc->aEffectMaps[SRC_CHAIN_SRC].dwScratchSize;
    DWORD dwSamplesToStream = m_dwPacketSize/sizeof(WORD);

    //
    // the circular buffer index increments in 4 byte increments since each sample is
    // 32 bit. Our hawk packet needs 16 bit samples
    //

    DWORD dwSrcPacketSize = m_dwPacketSize*(sizeof(DWORD)/sizeof(WORD));
    DWORD dwCurrentPosition = pSrcParams->dwScratchSampleOffset;

    PDWORD pSrcData;
    PWORD pData = (PWORD)pCtx->pBuffer;
    BOOL bReSync = FALSE;

    if (m_dwOldPosition == -1) {

        //
        // this is the first time through the loop, just record the position and bail
        // attach to source XMO so packet is not lost
        //

        m_dwOldPosition = dwCurrentPosition - (dwCurrentPosition%(dwSrcPacketSize));
        AttachPacketToSourceXMO( pCtx );
        return S_OK;
    }

    //
    // do the circular buffer -> packet streaming math
    // if the current postion has moved more than 3 packet sizes than the old position
    // re-synchronize
    //

    if (m_dwOldPosition > dwCurrentPosition) {

        if ((dwCurrentPosition + (dwCircularBufferSize-m_dwOldPosition)) > dwSrcPacketSize*3) {

            bReSync = TRUE;

        }

        if ((dwCurrentPosition + (dwCircularBufferSize-m_dwOldPosition)) < dwSrcPacketSize) {
               
            //
            // if we poll too fast the SRC effect circular buffer index might have not
            // progressed far enough for us to submit a full packet.
            //

            DBG_WARN(("positions too close Old pos %x, current %x\n",m_dwOldPosition,dwCurrentPosition));
            AttachPacketToSourceXMO( pCtx );
            return S_OK;

        }

    } else {

        if ((dwCurrentPosition - m_dwOldPosition) > dwSrcPacketSize*3) {

            bReSync = TRUE;

        }

        if ((dwCurrentPosition - m_dwOldPosition) < dwSrcPacketSize) {

            DBG_WARN(("positions too close Old pos %x, current %x\n",m_dwOldPosition,dwCurrentPosition));
            AttachPacketToSourceXMO( pCtx );
            Sleep(5);
            return S_OK;
        }

    }

    if (bReSync) {

        DBG_WARN(("Drifted current %x, old %x\n",dwCurrentPosition,m_dwOldPosition));
        m_dwOldPosition = dwCurrentPosition - (dwCurrentPosition%(dwSrcPacketSize));
        DBG_WARN(("New Old pos %x\n",m_dwOldPosition));

    }

    //
    // create VA of base offset into the delay line
    // we always align the the current reading position to the packet size
    // this way we dont need to worry about wrapping with a partial packet 
    // at the end of the delay line
    //

    pSrcData = (PDWORD)((PUCHAR)m_pEffectsImageDesc->aEffectMaps[SRC_CHAIN_SRC].lpvScratchSegment+m_dwOldPosition);            

    //
    // convert 32 bit container to 16 bit container
    //

    for (DWORD i=0;i<dwSamplesToStream;i++) {

        *pData++ = WORD(*pSrcData++ >> 16);

    }

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer         
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the target XMO (first xmo in the chain)
    hr = m_pTargetXMO->Process( &xmb, NULL );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our target list
    m_TargetPendingList.Add( &pCtx->ListEntry );

    //
    // increment index into SRC effect delay line
    //

    m_dwOldPosition = (m_dwOldPosition+dwSrcPacketSize)%dwCircularBufferSize;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = DSFX_IMAGELOC_UNUSED;
        EffectLoc.dwCrosstalkIndex = DSFX_IMAGELOC_UNUSED;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &m_pEffectsImageDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}





//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Clean up resources
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::Cleanup()
{
    // Cleanup: delete any XMO's
    if( m_pSourceXMO )       
        m_pSourceXMO->Release();
    if( m_pTargetXMO )       
        m_pTargetXMO->Release();
    if( m_pDSound )
        m_pDSound->Release();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: dBToHardwareCoeff
// Desc: Calculates coefficient value[1] for DLS2 filter from resonance in dB
//-----------------------------------------------------------------------------
ULONG dBToHardwareCoeff( LONG lResonance )
{
    FLOAT fResonance = (FLOAT)lResonance;

    if( fResonance > 22.5f )
        fResonance = 22.5f;

    double fQ = pow( 10.0, -0.05*fResonance);
    unsigned int dwQ = (unsigned int)(fQ*(1<<15));
    if( dwQ > 0xFFFF )
        dwQ = 0xFFFF;

    return (ULONG)dwQ;
}

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double PI = 3.1415926535;


HRESULT
CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer )
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER8 pBuffer = NULL;
    WORD * pData = NULL;
    DWORD dwBytes = 0;
    double dArg = 0.0;
    double dSinVal = 0.0;
    WORD wVal = 0;
    DSBUFFERDESC dsbd;
    WAVEFORMATEX wfx;

    DSMIXBINS               dsMixBins;
    DSMIXBINVOLUMEPAIR      dsMixBinArray[8];

    memset(dsMixBinArray,0,sizeof(dsMixBinArray));

    //
    // Initialize a wave format structure
    //

    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    wfx.wFormatTag      = WAVE_FORMAT_PCM;      // PCM data
    wfx.nChannels       = 1;                    // Mono
    wfx.nSamplesPerSec  = 48000;                 // 48kHz
    wfx.nAvgBytesPerSec = 96000;                 // 48kHz * 2 bytes / sample
    wfx.nBlockAlign     = 2;                    // sample size in bytes
    wfx.wBitsPerSample  = 16;                   // 16 bit samples
    wfx.cbSize          = 0;                    // No extra data

    //
    // Intialize the buffer description
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
    dsbd.lpwfxFormat = &wfx;
    dsbd.lpMixBins = &dsMixBins;

    //
    // oscillator output goes to FXSEND 4
    //

    dsMixBins.dwMixBinCount = 1;
    dsMixBins.lpMixBinVolumePairs = dsMixBinArray;
    dsMixBinArray[0].dwMixBin = DSMIXBIN_FXSEND_4;

    if (*ppBuffer == NULL) {

        // Check arguments
        if( !ppBuffer || dFrequency < 0 )
            return E_INVALIDARG;
    
        *ppBuffer = NULL;
    
        // Create the buffer
        hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
        if( FAILED( hr ) )
            return hr;

    } else {

        pBuffer = *ppBuffer;

    }

    // Get a pointer to buffer data to fill
    hr = pBuffer->Lock( 0, dsbd.dwBufferBytes, (VOID **)&pData, &dwBytes, NULL, NULL, 0 );
    if( FAILED( hr ) )
        return hr;

    // Now fill the buffer, 1 16-bit sample at a time
    for( DWORD i = 0; i < dwBytes/sizeof(WORD); i++ )
    {
        // Convert sample offset to radians
        dArg = (double)i / wfx.nSamplesPerSec * D3DX_PI * 2;

        // Calculate the sin
        dSinVal = sin( dFrequency * dArg );

        // Scale to sample format
        wVal = WORD( dSinVal * 32767 );

        // Store the sample
        pData[i] = wVal;
    }

    // Start the sine wave looping
    hr = pBuffer->Play( 0, 0, DSBPLAY_LOOPING );
    if( FAILED( hr ) )
        return hr;

    // return the buffer
    *ppBuffer = pBuffer;

    return hr;
}

//-----------------------------------------------------------------------------
// Name: FreqToHardwareCoeff
// Desc: Calculates coefficient value[0] for DLS2 filter from a frequency
//-----------------------------------------------------------------------------
ULONG FreqToHardwareCoeff( FLOAT fFreq )
{
    FLOAT fNormCutoff = fFreq / 48000.0f;

    // Filter is ineffective out of these ranges, so why
    // bother even trying?
    if( fFreq < 30.0f )
        return 0x8000;
    if( fFreq > 8000.0f )
        return 0x0;

    FLOAT fFC = FLOAT( 2.0f * sin( D3DX_PI * fNormCutoff ) );
    LONG lOctaves = LONG( 4096.0f * log( fFC ) / log( 2.0f ) );

    return (ULONG)lOctaves & 0xFFFF;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates, such as checking async xmo status, and
//       updating source file position for our progress bar
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::FrameMove()
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDSTREAM pDSStream = (LPDIRECTSOUNDSTREAM)m_pTransformXMO;

    //
    // check if hawk is plugged in
    //

    if (m_dwPortNumber == -1) {

        hr = InitializeStreamingObjects();

    } else {

        if (SUCCEEDED(hr)) {
    
            LONG lDelta;

            if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
            {
                if( m_dwParam == 0 )
                    m_dwParam = NUM_OPTIONS - 1;
                else
                    m_dwParam = ( m_dwParam - 1 );
            }
    
            if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
            {
                m_dwParam = ( m_dwParam + 1 ) % NUM_OPTIONS;
            }
    
            //
            // Change frequency of oscillator driving the voice FX
            //

            lDelta = LONG(m_DefaultGamepad.fX1 * m_fElapsedTime * FREQ_STEP);
          
            if (abs(lDelta) > 0) {

                if (m_lOscillatorFrequency < 500) {
    
                    lDelta /= 10;

                }
    

                m_lOscillatorFrequency = m_lOscillatorFrequency + lDelta;

                if (m_lOscillatorFrequency < 0) {
                    m_lOscillatorFrequency = MAX_OSCILLATOR_FREQUENCY;
                }

                if (m_lOscillatorFrequency > MAX_OSCILLATOR_FREQUENCY) {
                    m_lOscillatorFrequency = 0;
                }
              
                hr = CreateSineWaveBuffer(m_lOscillatorFrequency,&m_pDSBufferOscillator);

            }
        
            // Toggle effect
            if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
            {
                m_dwCurrentEffect = ( m_dwCurrentEffect + 1 ) % ( sizeof( g_aEffectDescriptions ) / sizeof( g_aEffectDescriptions[0] ) );
        
                //
                // change mixbin assignment
                //
        
                DSMIXBINS               dsMixBins;
                DSMIXBINVOLUMEPAIR      dsMixBinArray[8];
            
                dsMixBins.dwMixBinCount = 0;
                dsMixBins.lpMixBinVolumePairs = dsMixBinArray;
                memset(dsMixBinArray,0,sizeof(dsMixBinArray));
        
                for (DWORD i=0;i<32;i++) {
        
                    if ((1 << i) & g_aEffectDescriptions[m_dwCurrentEffect].dwMixBinMask) {
        
                        dsMixBinArray[dsMixBins.dwMixBinCount++].dwMixBin = i;
        
                    }
        
                }
        
                hr = pDSStream->SetMixBins(&dsMixBins);
        
            }
    
        }
    
        // Instruct routine to poll the filter graph so completed packets can be
        // moved through the streaming chain.
    
        if (SUCCEEDED(hr) && (m_dwPortNumber != -1)) {
            hr = TransferData();
        }
            
        BOOLEAN bSetFilter = FALSE;

        if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
        {
            m_dsfd.dwMode ^= DSFILTER_MODE_DLS2;
            bSetFilter = TRUE;
        }
    
        if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
        {
            m_dsfd.dwMode ^= DSFILTER_MODE_PARAMEQ;
            bSetFilter = TRUE;
        }

        if (SUCCEEDED(hr)) {
    
            // Adjust value of currently selected parameter
            LONG lDelta = LONG(m_DefaultGamepad.fX2 * m_fElapsedTime * g_aOptions[ m_dwParam ].dwScale );
            if ((abs(lDelta) > 0)  || bSetFilter)  {

                switch( m_dwParam )
                {
                case DLS2_CutoffFrequency:
                    m_fDLS2Freq += lDelta;
                    if( m_fDLS2Freq < 0.0f )
                        m_fDLS2Freq = 0.0f;
                    else if( m_fDLS2Freq > 8000 )
                        m_fDLS2Freq = 8000;
                    break;
                case DLS2_Resonance:
                    m_lDLS2Resonance += lDelta;
                    if( m_lDLS2Resonance < 0 )
                        m_lDLS2Resonance = 0;
                    else if( m_lDLS2Resonance > 22 * RES_SCALE )
                        m_lDLS2Resonance = 22 * RES_SCALE;
                    break;

                case PARAMEQ_Frequency:
                    m_lParamEQFreq += lDelta;
                    if( m_lParamEQFreq < 0 )
                        m_lParamEQFreq = 0;
                    else if( m_lParamEQFreq > 8000 )
                        m_lParamEQFreq = 8000;
                    break;
                case PARAMEQ_Gain:
                    m_lParamEQGain += lDelta;
                    if( m_lParamEQGain < -8192 )
                        m_lParamEQGain = -8192;
                    else if( m_lParamEQGain > 8191 )
                        m_lParamEQGain = 8191;
                    break;
                case PARAMEQ_Q:
                    m_lParamEQQ += lDelta;
                    if( m_lParamEQQ < 0 )
                        m_lParamEQQ = 0;
                    else if( m_lParamEQQ / RES_SCALE > 7 )
                        m_lParamEQQ = 7 * RES_SCALE;
                    break;
                }
            
                // 
                // Note!!!:
                // For stereo buffers, where you can only use DLS2 OR ParamEQ, you must 
                // set both pairs of coefficients (one for each channel).
                //
                m_dsfd.adwCoefficients[0] = FreqToHardwareCoeff( m_fDLS2Freq );
                m_dsfd.adwCoefficients[1] = dBToHardwareCoeff( m_lDLS2Resonance / RES_SCALE );
                m_dsfd.adwCoefficients[2] = FreqToHardwareCoeff( FLOAT(m_lParamEQFreq) );
                m_dsfd.adwCoefficients[3] = m_lParamEQGain & 0xFFFF;
                m_dsfd.dwQCoefficient = m_lParamEQQ / RES_SCALE;
            
                pDSStream->SetFilter( &m_dsfd );

            }
    
        }


    }

    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }


    return hr;
}


//-----------------------------------------------------------------------------
// Name: TransferData
// Desc: If we have a packet completed from our source XMO, pass it through
//       the intermediate XMO and on to the target.
//       If we have a packet completed from our target XMO, recycle it back
//       to the source XMO.
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::TransferData()
{
    HRESULT        hr=S_OK;
    DWORD          index = 0;
    XMEDIAPACKET   xmb;
    MEDIA_PACKET_CTX* pSrcCtx = NULL;
    MEDIA_PACKET_CTX* pInBetweenCtx = NULL;
    MEDIA_PACKET_CTX* pDstCtx = NULL;
    DWORD             dwSize  = 0;

    // Setup media buffer
    ZeroMemory( &xmb, sizeof(xmb) );

    //
    // Always deal with the oldest packet first.  Oldest packets are at the 
    // head, since we insert at the tail, and remove from head
    //
    if( !m_SourcePendingList.IsListEmpty() ) 
    {
        pSrcCtx = (MEDIA_PACKET_CTX*)m_SourcePendingList.pNext; // Head
    }

    if( !m_TransformPendingList.IsListEmpty() ) 
    {
        pInBetweenCtx = (MEDIA_PACKET_CTX*)m_TransformPendingList.pNext; // Head
    }        

    if( !m_TargetPendingList.IsListEmpty() ) 
    {
        pDstCtx = (MEDIA_PACKET_CTX*)m_TargetPendingList.pNext; // Head
    }        

    // Do we have a completed source packet?
    if( pSrcCtx && pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING ) 
    {
        // A src buffer completed.
        // Remove this context from the Src pending list.
        // Send it to a codec, if present, then send it to the Target xmo
        pSrcCtx->ListEntry.Remove();

        DBG_SPAM(("Context %x received %x bytes\n",pSrcCtx, pSrcCtx->dwCompletedSize));
        ASSERT( pSrcCtx->dwCompletedSize);

        // Pass media buffer to the transform xmo.
        AttachPacketToTransformXMO( pSrcCtx );
    }

    // Do we have a completed transform packet?
    if( pInBetweenCtx && pInBetweenCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING ) 
    {
        // A in-between buffer completed.
        // Remove this context from the transform pending list.
        pInBetweenCtx->ListEntry.Remove();

        DBG_SPAM(("InBetween Context %x received %x bytes\n",pInBetweenCtx, pInBetweenCtx->dwCompletedSize));
        ASSERT( pInBetweenCtx->dwCompletedSize);

        // Pass media buffer to the target xmo.
        AttachPacketToTargetXMO( pInBetweenCtx );

    }


    // Check if we have a completed packet from the target
    if( pDstCtx && pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING )
    {       
        DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));

        // Remove the entry from the list
        pDstCtx->ListEntry.Remove();

        ASSERT(pDstCtx->dwCompletedSize != 0);

        AttachPacketToSourceXMO( pDstCtx );
    } 

    return S_OK;
}

static const float PEAK_MONITOR_LEFT_X = 350.;
static const float PEAK_MONITOR_BOTTOM_Y = 350.;

static const float PEAK_MONITOR_X_SIZE = 100.;
static const float PEAK_MONITOR_Y_SIZE = 250.;

static const float PEAK_MONITOR_BAR_WIDTH = 100.;
static const float PEAK_MONITOR_BAR_SPACING = 30.;

static const DWORD NUM_MIXBINS=1;

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene - just a progress bar denoting how much of the 
//       source file has been read.
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::Render()
{

    WCHAR szString[256];
    DWORD dwValue=0,i;
    FLOAT fXPos;
    FLOAT fYPos;
    
    FLOAT x1, x2;
    FLOAT y1, y2;
    FLOAT fPeakLevels[NUM_MIXBINS];

    FLOAT fValue = 0.;

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp ) {
    
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );

    } else {

        //
        // get the output levels from dsound
        //
    
        DSOUTPUTLEVELS dsOutputLevels;
        memset(&dsOutputLevels, 0 ,sizeof(dsOutputLevels));
    
        m_pDSound->GetOutputLevels(&dsOutputLevels, FALSE);
    
        //
        // digital peak levels
        //
    
        fPeakLevels[DSMIXBIN_FRONT_LEFT] = (FLOAT) dsOutputLevels.dwDigitalFrontLeftPeak;
        fPeakLevels[DSMIXBIN_FRONT_RIGHT] = (FLOAT) dsOutputLevels.dwDigitalFrontRightPeak;
        fPeakLevels[DSMIXBIN_BACK_LEFT] = (FLOAT) dsOutputLevels.dwDigitalBackLeftPeak;
        fPeakLevels[DSMIXBIN_BACK_RIGHT] = (FLOAT) dsOutputLevels.dwDigitalBackRightPeak;
        fPeakLevels[DSMIXBIN_FRONT_CENTER] = (FLOAT) dsOutputLevels.dwDigitalFrontCenterPeak;
        fPeakLevels[DSMIXBIN_LOW_FREQUENCY] = (FLOAT) dsOutputLevels.dwDigitalLowFrequencyPeak;

        fYPos = PEAK_MONITOR_BOTTOM_Y+20 ;
    
        for (i=0;i<NUM_MIXBINS;i++) {
    
            fValue = (FLOAT)(fPeakLevels[i]/pow(2,23));
            fValue = (FLOAT)(20.0*log10(fValue));
        
            fXPos = PEAK_MONITOR_LEFT_X+PEAK_MONITOR_BAR_SPACING+i*(PEAK_MONITOR_BAR_SPACING+PEAK_MONITOR_BAR_WIDTH);
            swprintf (szString,L"%2.2f",fValue);
            m_Font.DrawText( fXPos, fYPos, 0xFFFFFF00, szString);
     
    
            m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    
            // Draw left level
            {
                struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
                BACKGROUNDVERTEX v[4];
    
                fValue = (FLOAT)(fPeakLevels[i]/pow(2,23));
    
                x1 = PEAK_MONITOR_LEFT_X + PEAK_MONITOR_BAR_SPACING + i*(PEAK_MONITOR_BAR_SPACING+PEAK_MONITOR_BAR_WIDTH);
                x2 = x1 + PEAK_MONITOR_BAR_WIDTH;
                y2 = PEAK_MONITOR_BOTTOM_Y;
                y1 = y2 - PEAK_MONITOR_Y_SIZE*fValue;
        
                v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
                v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
                v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xff0000ff;
                v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xff0000ff;
        
                m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
                m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
            }
    
            // Draw current max
            {
                struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
                BACKGROUNDVERTEX v[4];
                x1 = PEAK_MONITOR_LEFT_X + PEAK_MONITOR_BAR_SPACING + i*(PEAK_MONITOR_BAR_SPACING+PEAK_MONITOR_BAR_WIDTH);
                x2 = x1 + PEAK_MONITOR_BAR_WIDTH;
    
                fValue = (FLOAT)(fPeakLevels[i]/pow(2,23));
                y1 = PEAK_MONITOR_BOTTOM_Y - PEAK_MONITOR_Y_SIZE*fValue;
                y2 = y1+3;
    
        
                v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffff00;
                v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffff00;
                v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xffff00ff;
                v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xffff00ff;
        
                m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
                m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
            }
    
    
        }
        
    
        m_Font.Begin();
    
        if (m_dwPortNumber == -1) {
            swprintf (szString,L"Voice Peripheral Not Plugged in");
            m_Font.DrawText( 50,10, 0xFFFFFF00, szString);
        }
    
        swprintf (szString,L"Current Effect: %s",g_aEffectDescriptions[m_dwCurrentEffect].szDescription);
        m_Font.DrawText( 50, 50, 0xFFFFFF00, szString);
    
        swprintf (szString,L"Oscillator Frequency %d",m_lOscillatorFrequency);
        m_Font.DrawText( 50, 80, 0xFFFFFF00, szString);
    
        for( int i = 0; i < NUM_OPTIONS; i++ )
        {
            switch( i )
            {
            case DLS2_CutoffFrequency:
                swprintf( szString, L"%s: %0.2fHz", g_aOptions[i].szDescription, m_fDLS2Freq );
                break;
            case DLS2_Resonance:
                swprintf( szString, L"%s: %lddB", g_aOptions[i].szDescription, m_lDLS2Resonance / RES_SCALE );
                break;
            case PARAMEQ_Frequency:
                swprintf( szString, L"%s: %ldHz", g_aOptions[i].szDescription, m_lParamEQFreq );
                break;
            case PARAMEQ_Gain:
                swprintf( szString, L"%s: %lddB", g_aOptions[i].szDescription, m_lParamEQGain / PEQ_GAIN_SCALE );
                break;
            case PARAMEQ_Q:
                swprintf( szString, L"%s: %ld", g_aOptions[i].szDescription, m_lParamEQQ / RES_SCALE );
                break;
            }
            m_Font.DrawText( 50, FLOAT(110 + i * 30), i == m_dwParam ? 0xFFFFFFFF : 0xFFFFFF00, szString );
        }
    
        //m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();

    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CFilterGraph xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WaveBank\WaveBank.cpp ===
//-----------------------------------------------------------------------------
// File: WaveBank.cpp
//
// Desc: This sample demonstrates how to use the new SetPlayRegion and 
//       SetFormat APIs to implement a wave bank of wav files
//
// Hist: 11.13.01 - New for December XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <wavbndlr.h>
#include <assert.h>
#include <dsstdfx.h>

// This header file is generated by the wav bundler tool
#include "sounds.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Select sound" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Play sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Loop sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Stop buffer" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )




#define DISPLAY_LENGTH 8




//-----------------------------------------------------------------------------
// Name: BufferQueueNode
// Desc: Node in our queue of buffers
//-----------------------------------------------------------------------------
struct BufferQueueNode
{
    BufferQueueNode*            pNext;
    LPDIRECTSOUNDBUFFER         pBuffer;
    LONG                        lPlayingSound;
};



// Helper function for converting wave formats
VOID CreateWaveFormatEx( WAVEBANKMINIWAVEFORMAT* pmini, XBOXADPCMWAVEFORMAT* pwfx );





//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);     // downloads a default DSP image to the GP
    HRESULT LoadWaveBank( LPCSTR strFilename );             // Load a wave bank
    HRESULT InitializeBufferPool( DWORD dwNumberOfBuffers,  // Initialize our buffer pool
                                  VOID* pbSampleData, 
                                  DWORD dwDataLength );
    HRESULT PlaySound( DWORD dwIndex, BOOL fLooping );      // Play the specified sound

    BufferQueueNode*    Dequeue();                          // Dequeue from buffer pool
    void                Enqueue( BufferQueueNode* pNode );  // Enqueue to buffer pool

    CXBFont     m_Font;                                     // Font object
    CXBHelp     m_Help;                                     // Help object
    BOOL        m_bDrawHelp;                                // TRUE to draw help screen

    LPDIRECTSOUND       m_pDSound;                          // DirectSound object

    DWORD               m_dwDisplayStart;                   // Display management
    DWORD               m_dwSelection;                      // ...
    DWORD               m_dwCurrent;                        // ...

    // Wave bank entries and sample data
    WAVEBANKENTRY       m_aWaveBankEntries[WAVEBANK_SOUNDS_ENTRY_COUNT];
    BYTE*               m_pbSampleData;

    BufferQueueNode*    m_pNodes;                           // Buffer Queue allocation
    DWORD               m_dwNumberOfBuffers;                // Total # of buffers
    DWORD               m_dwAvailableBuffers;               // # of available buffers
    DWORD               m_dwPlayingBuffers;                 // # of playing buffers
    BufferQueueNode*    m_pBufferPoolHead;                  // Queue of ready buffers
    BufferQueueNode*    m_pBufferPoolTail;                  // ...

    BufferQueueNode*    m_pBusyBuffersHead;                 // List of busy buffers
};




//-----------------------------------------------------------------------------
// Name: Dequeue
// Desc: Dequeues from the head of the buffer queue, returning NULL if empty
//-----------------------------------------------------------------------------
BufferQueueNode* CXBoxSample::Dequeue()
{
    BufferQueueNode* pNode = m_pBufferPoolHead;

    if( m_pBufferPoolHead )
    {
        m_pBufferPoolHead = m_pBufferPoolHead->pNext;
        if( m_pBufferPoolTail == pNode )
            m_pBufferPoolTail = NULL;
    }

    return pNode;
}




//-----------------------------------------------------------------------------
// Name: Enqueue
// Desc: Adds to the tail of the queue
//-----------------------------------------------------------------------------
void CXBoxSample::Enqueue( BufferQueueNode* pNode )
{
    if( m_pBufferPoolTail )
    {
        m_pBufferPoolTail->pNext = pNode;
        m_pBufferPoolTail = pNode;
    }
    else
    {
        m_pBufferPoolHead =
        m_pBufferPoolTail = pNode;
    }
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;
    m_pbSampleData      = NULL;
    m_pDSound           = NULL;

    m_pNodes            = NULL;
    m_pBufferPoolHead   = NULL;
    m_pBufferPoolTail   = NULL;
    m_pBusyBuffersHead  = NULL;

    m_dwCurrent         = 0;
    m_dwDisplayStart    = 0;
    m_dwSelection       = 0;
}




//-----------------------------------------------------------------------------
// Name: InitializeBufferPool
// Desc: Initializes the buffer pool by creating the specified number of 
//       buffers, inserting them into a queue, and mapping the wave bank
//       data
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitializeBufferPool( DWORD dwNumberOfBuffers, VOID* pbSampleData, DWORD dwDataLength )
{
    // Set up a default wave format
    WAVEFORMATEX wfx    = {0};
    wfx.wFormatTag      = WAVE_FORMAT_PCM;
    wfx.nChannels       = 1;
    wfx.nSamplesPerSec  = 44100;
    wfx.wBitsPerSample  = 16;
    wfx.nBlockAlign     = wfx.nChannels * wfx.wBitsPerSample / 8 ;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;

    // And a default buffer description
    DSBUFFERDESC dsbd   = {0};
    dsbd.dwBufferBytes  = 0;
    dsbd.lpwfxFormat    = &wfx;

    // Allocate a block of Buffer Queue nodes
    m_pNodes = new BufferQueueNode[ dwNumberOfBuffers ];
    if( !m_pNodes )
    {
        return E_OUTOFMEMORY;
    }
    m_dwNumberOfBuffers = dwNumberOfBuffers;
    ZeroMemory( m_pNodes, m_dwNumberOfBuffers * sizeof( BufferQueueNode ) );

    // Set up the initial queue
    for( DWORD i = 0; i < m_dwNumberOfBuffers; i++ )
    {
        if( FAILED( DirectSoundCreateBuffer( &dsbd, &m_pNodes[ i ].pBuffer ) ) )
        {
            // TODO: Should clean up already-created buffers
            return E_OUTOFMEMORY;
        }
        m_pNodes[ i ].pBuffer->SetBufferData( pbSampleData, dwDataLength );
        m_pNodes[ i ].pNext = &m_pNodes[ i + 1 ];
    }

    // Set up our pointers
    m_pBufferPoolHead           = &m_pNodes[ 0 ];
    m_pBufferPoolTail           = &m_pNodes[ m_dwNumberOfBuffers - 1 ];
    m_pBufferPoolTail->pNext    = NULL;


    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: LoadWaveBank
// Desc: Loads a wave bank
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::LoadWaveBank( LPCSTR strFilename )
{
    // First, open the file
    HANDLE hWaveBank;
    hWaveBank = CreateFile( strFilename, 
                            GENERIC_READ, 
                            FILE_SHARE_READ, 
                            NULL, 
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
    if( hWaveBank == INVALID_HANDLE_VALUE )
    {
        OUTPUT_DEBUG_STRING( "Sound bank not found!\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Read the header
    WAVEBANKHEADER  header;
    DWORD           dwRead;
    if( !ReadFile( hWaveBank, &header, sizeof( WAVEBANKHEADER ), &dwRead, NULL ) )
    {
        CloseHandle( hWaveBank );
        return E_FAIL;
    }

    // Validate the signature
    if( header.dwSignature  != WAVEBANKHEADER_SIGNATURE ||
        header.dwVersion    != WAVEBANKHEADER_VERSION ||
        header.dwEntryCount != WAVEBANK_SOUNDS_ENTRY_COUNT )
    {
        CloseHandle( hWaveBank );
        return E_UNEXPECTED;
    }

    // Read the entries
    if( !ReadFile( hWaveBank, 
                   m_aWaveBankEntries, 
                   WAVEBANK_SOUNDS_ENTRY_COUNT * sizeof( WAVEBANKENTRY ),
                   &dwRead,
                   NULL ) )
    {
        CloseHandle( hWaveBank );
        return E_UNEXPECTED;
    }

    // Calculate amount of data
    DWORD dwDataBegin = SetFilePointer( hWaveBank, 0, NULL, FILE_CURRENT );
    DWORD dwTotalSize = SetFilePointer( hWaveBank, 0, NULL, FILE_END );
    DWORD dwDataLength = dwTotalSize - dwDataBegin;
    SetFilePointer( hWaveBank, dwDataBegin, NULL, FILE_BEGIN );

    // Allocate memory for the sound data
    m_pbSampleData = new BYTE[ dwDataLength ];
    if( !m_pbSampleData )
    {
        CloseHandle( hWaveBank );
        return E_OUTOFMEMORY;
    }

    // Read the sound data
    if( !ReadFile( hWaveBank, m_pbSampleData, dwDataLength, &dwRead, NULL ) )
    {
        CloseHandle( hWaveBank );
        return E_UNEXPECTED;
    }

    // Initialize a buffer pool on this wave bank
    if( FAILED( InitializeBufferPool( 64, m_pbSampleData, dwDataLength ) ) )
    {
        CloseHandle( hWaveBank );
        return E_OUTOFMEMORY;
    }

    CloseHandle( hWaveBank );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PlaySound
// Desc: Grabs the first available buffer and plays the specified sound from
//       the wave bank on that buffer
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::PlaySound( DWORD dwIndex, BOOL fLooping )
{
    // Grab the node off the head of the queue
    BufferQueueNode* pNode = Dequeue();
    if( !pNode )
    {
        return E_PENDING;
    }

    // Add this node to the busy list
    pNode->pNext = m_pBusyBuffersHead;
    m_pBusyBuffersHead = pNode;

#if _DEBUG
    // Make sure this buffer is really available
    DWORD dwStatus;
    HRESULT hr = pNode->pBuffer->GetStatus( &dwStatus );
    assert( SUCCEEDED( hr ) && !( dwStatus & DSBSTATUS_PLAYING ) );
#endif // _DEBUG

    // We're using a XBOXADPCMWAVEFORMAT structure to guarantee we have enough
    // space for a PCM or ADPCM WAVEFORMATEX struct.  This way, we don't have
    // to make another call to find the size, allocate memory on the heap, and
    // then free it later,
    XBOXADPCMWAVEFORMAT wfx;
    CreateWaveFormatEx( &m_aWaveBankEntries[ dwIndex ].Format,
                        &wfx );
    pNode->pBuffer->SetFormat( (WAVEFORMATEX *)&wfx );

    // Set loop and play regions...
    pNode->pBuffer->SetPlayRegion( m_aWaveBankEntries[ dwIndex ].PlayRegion.dwStart,
                                   m_aWaveBankEntries[ dwIndex ].PlayRegion.dwLength );
    pNode->pBuffer->SetLoopRegion( m_aWaveBankEntries[ dwIndex ].LoopRegion.dwStart, 
                                   m_aWaveBankEntries[ dwIndex ].LoopRegion.dwLength );

    // Play the sound
    pNode->lPlayingSound = dwIndex;
    if( FAILED( pNode->pBuffer->PlayEx( 0, DSBPLAY_FROMSTART | ( fLooping ? DSBPLAY_LOOPING : 0 ) ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up direct sound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    DirectSoundUseFullHRTF();

    DownloadEffectsImage( "d:\\media\\dsstdfx.bin" );

    // Load our wave bank
    if( FAILED( LoadWaveBank( "d:\\media\\sounds\\sounds.xwb" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // A to trigger the sound as a one-shot
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        PlaySound( m_dwCurrent, FALSE );
    }

    // X to loop the sound
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        PlaySound( m_dwCurrent, TRUE );
    }

    // B to stop the selected playing sound
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] &&
        m_dwSelection < m_dwPlayingBuffers )
    {
        BufferQueueNode* pNode = m_pBusyBuffersHead;
        for( DWORD i = 0; i < m_dwSelection; i++ )
            pNode = pNode->pNext;

        pNode->pBuffer->Stop();
    }

    // Walk the busy buffers list, and remove any buffer that is done
    // playing
    BufferQueueNode** ppNode;
    m_dwPlayingBuffers = 0;
    for( ppNode = &m_pBusyBuffersHead; *ppNode; )
    {
        DWORD dwStatus;
        (*ppNode)->pBuffer->GetStatus( &dwStatus );

        // If the buffer is no longer playing
        if( !( dwStatus & DSBSTATUS_PLAYING ) )
        {
            // Remove it from the list and add to the queue
            BufferQueueNode* pRemove = *ppNode;
            *ppNode = (*ppNode)->pNext;
            Enqueue( pRemove );
        }
        else
        {
            ++m_dwPlayingBuffers;
            ppNode = &(*ppNode)->pNext;
        }
    }

    m_dwAvailableBuffers = m_dwNumberOfBuffers - m_dwPlayingBuffers;

    // If our selection is off the end of the list, correct that
    if( m_dwSelection > m_dwPlayingBuffers - 1 )
        m_dwSelection = m_dwPlayingBuffers - 1;

    // Select sound
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
    {
        m_dwCurrent = ( m_dwCurrent + WAVEBANK_SOUNDS_ENTRY_COUNT - 1 ) % WAVEBANK_SOUNDS_ENTRY_COUNT;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % WAVEBANK_SOUNDS_ENTRY_COUNT;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        if( m_dwSelection < m_dwPlayingBuffers - 1 )
            m_dwSelection += 1;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        if( m_dwSelection > 0 )
            m_dwSelection -= 1;
    }

    // If we've got a list of playing sounds, we want to manage it so that
    // we're always showing a full screen that includes our selection
    if( m_dwPlayingBuffers )
    {
        if( m_dwPlayingBuffers < DISPLAY_LENGTH )
            m_dwDisplayStart = 0;
        else if( m_dwPlayingBuffers - m_dwDisplayStart < DISPLAY_LENGTH  )
            m_dwDisplayStart = m_dwPlayingBuffers - ( DISPLAY_LENGTH  );

        // make sure the selection is always on screen
        if( m_dwSelection < m_dwDisplayStart )
            m_dwDisplayStart = m_dwSelection;
        if( m_dwSelection - m_dwDisplayStart > DISPLAY_LENGTH - 1 )
            m_dwDisplayStart = m_dwSelection - ( DISPLAY_LENGTH - 1 );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff606060 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"WaveBank" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR str[100];
        swprintf( str, L"%d sounds in wave bank", WAVEBANK_SOUNDS_ENTRY_COUNT );
        m_Font.DrawText( 64, 80, 0xffffff00, str );
        swprintf( str, L"%d buffers in pool (%d available)", m_dwNumberOfBuffers, m_dwAvailableBuffers );
        m_Font.DrawText( 64, 110, 0xffffff00, str );
        swprintf( str, L"Press `A' to play sound %d", m_dwCurrent );
        m_Font.DrawText( 64, 140, 0xffffffff, str );
        if( m_aWaveBankEntries[m_dwCurrent].Format.wFormatTag == WAVEBANKMINIFORMAT_TAG_PCM )
        {
            swprintf( str, L"%dkHz %dbit %s PCM",
                      m_aWaveBankEntries[m_dwCurrent].Format.nSamplesPerSec / 1000,
                      m_aWaveBankEntries[m_dwCurrent].Format.wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_8 ? 8: 16,
                      m_aWaveBankEntries[m_dwCurrent].Format.nChannels == 1 ? L"Mono" : L"Stereo" );
        }
        else
        {
            swprintf( str, L"%dkHz %s ADPCM",
                      m_aWaveBankEntries[m_dwCurrent].Format.nSamplesPerSec / 1000,
                      m_aWaveBankEntries[m_dwCurrent].Format.nChannels == 1 ? L"Mono" : L"Stereo" );
        }
        m_Font.DrawText( 64, 170, 0xc0c0c0c0, str );


        m_Font.End();

        // Find the first buffer to display
        BufferQueueNode* pNode = m_pBusyBuffersHead;
        for( DWORD i = 0; i < m_dwDisplayStart; i++ )
        {
            pNode = pNode->pNext;
        }

        for( DWORD i = 0; i < DISPLAY_LENGTH && m_dwDisplayStart + i < m_dwPlayingBuffers; i++ )
        {
            assert( pNode );
            DWORD dwStatus;
            pNode->pBuffer->GetStatus( &dwStatus );

            swprintf( str, L"Sound %d buffer %lx (%s)", pNode->lPlayingSound,
                                                        pNode->pBuffer,
                                                        ( dwStatus & DSBSTATUS_LOOPING ) ? 
                                                            L"Looping" : 
                                                            (dwStatus & DSBSTATUS_PLAYING ) ? L"Playing" : L"Stopped" );
            m_Font.DrawText( 64, 200.0f + 30 * i, m_dwDisplayStart + i == m_dwSelection ? 0xffffffff : 0xffffff00, str );
            pNode = pNode->pNext;
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateWaveFormatEx
// Desc: Helper function to populate an XBOXADPCMWAVEFORMAT struct, based off
//       the packed wave format struct in the wave bank
//-----------------------------------------------------------------------------
VOID CreateWaveFormatEx( WAVEBANKMINIWAVEFORMAT* pmini, XBOXADPCMWAVEFORMAT* pwfx )
{
    assert( pmini && pwfx );
    ZeroMemory( pwfx, sizeof( XBOXADPCMWAVEFORMAT ) );

    // Common to both PCM and ADPCM
    pwfx->wfx.nChannels = pmini->nChannels;
    pwfx->wfx.nSamplesPerSec = pmini->nSamplesPerSec;

    // Deal with PCM/ADPCM-specific fields
    if( pmini->wFormatTag == WAVEBANKMINIFORMAT_TAG_ADPCM )
    {
        assert( pmini->wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_4 );

        pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
        pwfx->wSamplesPerBlock = 64;
        pwfx->wfx.cbSize = sizeof( XBOXADPCMWAVEFORMAT ) - sizeof( WAVEFORMATEX );

        pwfx->wfx.wBitsPerSample = 4;
        pwfx->wfx.nBlockAlign = pwfx->wfx.nChannels * 36;
        pwfx->wfx.nAvgBytesPerSec = pwfx->wfx.nSamplesPerSec / pwfx->wSamplesPerBlock * pwfx->wfx.nBlockAlign;

    }
    else
    {
        pwfx->wfx.wFormatTag = WAVE_FORMAT_PCM;
        pwfx->wfx.wBitsPerSample = ( pmini->wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_8 ) ? 8 : 16;
        pwfx->wfx.nBlockAlign = pwfx->wfx.nChannels * pwfx->wfx.wBitsPerSample / 8;
        pwfx->wfx.nAvgBytesPerSec = pwfx->wfx.nSamplesPerSec * pwfx->wfx.nBlockAlign;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\voiceDSP\VOICEDSP.h ===
#include <stdlib.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "fximg.h"
#include <xvoice.h>

//
// We arrived at this packet size based on the requirements of the XMOs.
// The idea is to pick an arbitrary packet size, go through the Init function
// once and then if any asserts fires while verifying the packet sizes, change
// the packet to satisfy all requirements
//
#define PACKET_CNT      8
#define PACKET_SIZE     1024
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

const int VOICE_SAMPLING_RATE = 16000;
const int XVOICE_BYTES_PER_MS = (((ULONG)( VOICE_SAMPLING_RATE / 1000.0 )) * 2 );

const int XVOICE_BUFFER_REGION_TIME = 40; 
const int XVOICE_BUFFER_REGION_SIZE = ( XVOICE_BYTES_PER_MS * XVOICE_BUFFER_REGION_TIME );
const int XVOICE_PREBUFFER_REGIONS = 20;
const int XVOICE_TOTAL_REGIONS = ( XVOICE_PREBUFFER_REGIONS + 2 );
const int XVOICE_BUFFER_SIZE = ( XVOICE_BUFFER_REGION_SIZE * XVOICE_TOTAL_REGIONS );

//
// frequency of oscillator that drives the speech alternating FX in the dsp
//

const DWORD MAX_OSCILLATOR_FREQUENCY = 10000;
const DWORD FREQ_STEP = 5000;



#if DBG

extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_dwVoiceDSPDebugLevel;
#define DBG_SPAM(_exp_) {if (g_dwVoiceDSPDebugLevel >= DEBUG_LEVEL_SPAM) DebugPrint _exp_;}
#define DBG_INFO(_exp) {if (g_dwVoiceDSPDebugLevel >= DEBUG_LEVEL_INFO) DebugPrint _exp;}
#define DBG_ERROR(_exp) {if (g_dwVoiceDSPDebugLevel >= DEBUG_LEVEL_ERROR) DebugPrint _exp;}
#define DBG_WARN(_exp) {if (g_dwVoiceDSPDebugLevel >= DEBUG_LEVEL_WARNING) DebugPrint _exp;}

    #define ASSERT(Expression)  \
    {                                                          \
        if(!(Expression))                                      \
        {                                                      \
            DebugPrint("XBOX RIP:\n");               \
            _asm { int 3 };                                    \
        }                                                      \
    }                                   

#else

#define ASSERT(_exp_)
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)

#endif



//
// Linked list structure for tracking our media packet contexts
//
struct LINKED_LIST 
{
    LINKED_LIST* pNext;
    LINKED_LIST* pPrev;

    inline VOID Initialize()         { pNext = pPrev = this; }
    inline BOOL IsListEmpty()        { return pNext == this; }
    inline LINKED_LIST* RemoveHead() { pNext->Remove(); }
    inline LINKED_LIST* RemoveTail() { pPrev->Remove(); }

    inline VOID Remove() 
    {
        LINKED_LIST* pOldNext = pNext;
        LINKED_LIST* pOldPrev = pPrev;
        pOldPrev->pNext = pOldNext;
        pOldNext->pPrev = pOldPrev;
    }

    inline VOID Add( LINKED_LIST* pEntry ) 
    {
        LINKED_LIST* pOldHead = this;
        LINKED_LIST* pOldPrev = this->pPrev;
        pEntry->pNext   = pOldHead;
        pEntry->pPrev   = pOldPrev;
        pOldPrev->pNext = pEntry;
        pOldHead->pPrev = pEntry;
    }
};



// This structure keeps track of our packet status, buffer data, etc.
struct MEDIA_PACKET_CTX
{
    LINKED_LIST ListEntry;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};


//-----------------------------------------------------------------------------
// Name: class XFilterGraph
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CFilterGraph : public CXBApplication
{
public:
    LPDIRECTSOUND8 m_pDSound;               // DirectSound object
    LPDIRECTSOUNDBUFFER m_pDSBufferOscillator;
    XMediaObject* m_pTargetXMO;             // Target XMO - Headphone
    XMediaObject* m_pTransformXMO;          // Transform XMO - DSound
    XMediaObject* m_pSourceXMO;             // Source XMO - microphone

    DWORD         m_dwMinPacketSize;        // For verifying our packet size
    DWORD         m_dwPacketSize;           // Packet size
    DWORD         m_dwMaxBufferCount;       // # of buffers

    WAVEFORMATEX  m_wfxAudioFormat;         // Audio format

    LINKED_LIST   m_SourcePendingList;      // Media Contexts in source list
    LINKED_LIST   m_TransformPendingList;      // Media Contexts in source list
    LINKED_LIST   m_TargetPendingList;      // Media Contexts in target list

    BYTE*         m_pTransferBuffer;        // Buffer data
    BYTE*         m_pPacketContextPool;     // Packet contexts

    CXBFont       m_Font;                   // Font renderer
    CXBHelp       m_Help;                   // Help object
    BOOL          m_bDrawHelp;              // Should we draw help?

    HRESULT       m_hOpenResult;            // Error code from WMAStream::Initialize()
    BOOL          m_bPaused;                // Paused?

    DWORD         m_dwPortNumber;           // port number
    DWORD         m_dwCount;

    DWORD         m_dwOldPosition;          // sample rate converter delay line index
    DWORD         m_dwCurrentEffect;        // current Effect applied to hawk input

    LPDSEFFECTIMAGEDESC m_pEffectsImageDesc;
    LONG          m_lOscillatorFrequency;

    //
    // set filter coeffs
    //

    LONG                    m_lParamEQFreq;
    LONG                    m_lParamEQGain;
    LONG                    m_lParamEQQ;
    DWORD                   m_dwParam;
    FLOAT                   m_fDLS2Freq;
    LONG                    m_lDLS2Resonance;
    DSFILTERDESC            m_dsfd;                 // DSFILTERDESC struct

    // Virtual calls from CXBApplication
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();

    HRESULT InitializeStreamingObjects();
    int FindHeadsetPort();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

    // These functions attach a media context packet to an XMO by 
    // setting up the XMEDIAPACKET struct, calling Process(), and
    // then adding our media packet context to the appropriate list
    HRESULT AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx );
    HRESULT AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx );
    HRESULT AttachPacketToTransformXMO( MEDIA_PACKET_CTX* pCtx );

    // Handles transferring packets through our filter graph
    HRESULT TransferData();

};


    
HRESULT
CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\main.cpp ===
//-----------------------------------------------------------------------------
// File: Main.cpp
//
// Desc: Simple app to play a streaming sound and render the percent completion
//       of the sound
//
// Hist: 3.15.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include "WMAInMemory.h"
#include "dsstdfx.h"


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Pause" },
};

#define NUM_HELP_CALLOUTS 2



//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CWMAFileStream m_Stream;        // The WMA stream
    CXBFont        m_Font;          // A font to render text
    CXBHelp        m_Help;          // Help object
    BOOL           m_bDrawHelp;     // Should we draw help?
    HRESULT        m_hOpenResult;   // Error code from WMAStream::Initialize()
    BOOL           m_bPaused;       // Paused?
    LPDIRECTSOUND8 m_pDSound;       // DirectSound object

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};




//-----------------------------------------------------------------------------
// Name: Main
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the sample
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a WMA stream
    m_hOpenResult = m_Stream.Initialize( "D:\\Media\\Sounds\\Becky.wma" );

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;
    m_bPaused = FALSE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Called once per frame to update state
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle pause
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_bPaused = !m_bPaused;
        m_Stream.Pause( m_bPaused ? DSSTREAMPAUSE_PAUSE : DSSTREAMPAUSE_RESUME );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Performs the actual rendering
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render the scene (which is just the progress bar)
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );

    DirectSoundDoWork();

    // If didn't open the WMA file
    if( FAILED( m_hOpenResult ) )
    {
        WCHAR strFailure[128];
        wsprintfW( strFailure, L"Failed to load WMA; HRESULT: 0x%X", m_hOpenResult );
        m_Font.DrawText( 64,  50, 0xffffffff, strFailure );
    }
    else
    {
        // Process the streaming sound
        DWORD dwPercentCompleted;
        m_Stream.Process( &dwPercentCompleted );

        // Show title, frame rate, and help
        if( m_bDrawHelp )
            m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
        else
        {
            // Draw the text
            m_Font.DrawText( 64,  50, 0xffffffff, L"WMAInMemory" );
        }
        WCHAR sz[100];
        swprintf( sz, L"Progress: %s", m_bPaused ? L"(Paused)" : L"" );
        m_Font.DrawText( 64, 375, 0xffffff00, sz);

        // Render a simple progress bar to show the percent completed
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[8];
        FLOAT x1 =  64, x2 = x1 + (512*dwPercentCompleted)/100, x3 = 64+512;
        FLOAT y1 = 400, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffff00;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffff00;
        v[2].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffffff00;
        v[3].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffffff00;
        v[4].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[4].color = 0xff8080ff;
        v[5].p = D3DXVECTOR4( x3-0.5f, y1-0.5f, 1.0f, 1.0f );  v[5].color = 0xff8080ff;
        v[6].p = D3DXVECTOR4( x3-0.5f, y2-0.5f, 1.0f, 1.0f );  v[6].color = 0xff8080ff;
        v[7].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[7].color = 0xff8080ff;

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 2, v, sizeof(v[0]) );
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\WMAInMemory.cpp ===
//-----------------------------------------------------------------------------
// File: WMAInMemory.cpp
//
// Desc: Class for streaming wave file playback using in-memory WMA codec XMO.
//
// Hist: 3.08.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "WMAInMemory.h"

//-----------------------------------------------------------------------------
// Debugging help
//-----------------------------------------------------------------------------
#define MY_ASSERT(x) if( !(x) ) _asm int 3;

BOOL g_bDoDebugChecks = FALSE;


//-----------------------------------------------------------------------------
// Name: CWMAFileStream()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWMAFileStream::CWMAFileStream()
{
    m_pSourceFilter    = NULL;
    m_pRenderFilter    = NULL;
    m_pvSourceBuffer   = NULL;
    
    for( DWORD i = 0; i < WMASTRM_PACKET_COUNT; i++ )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;

    m_dwFileLength   = 0;
    m_dwFileProgress = 0;
    m_pFileBuffer = NULL;
    m_hFile = NULL;

}




//-----------------------------------------------------------------------------
// Name: ~CWMAFileStream()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWMAFileStream::~CWMAFileStream()
{
    if( m_pSourceFilter )      m_pSourceFilter->Release();
    if( m_pRenderFilter )      m_pRenderFilter->Release();
    if( m_pvSourceBuffer )     delete[] m_pvSourceBuffer;

    if( m_pFileBuffer )        delete m_pFileBuffer;
    if( m_hFile )              CloseHandle(m_hFile);
    
    
}





//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the wave file streaming subsystem.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::Initialize( const CHAR* strFileName )
{
    WAVEFORMATEX   wfxSourceFormat;
    DSSTREAMDESC   dssd;
    HRESULT        hr;
    
    //
    // before we create the in memory decoder, we must read the WMA file
    // and have it in memory. The WmaCreateInMemoryDecoder function
    // will start calling our callbakc immediately for data...
    //

    m_hFile = CreateFile(strFileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL);


    if (m_hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    //
    // Determine size of WMA file
    //

    m_dwFileLength = SetFilePointer(m_hFile, 0, NULL, FILE_END);
    if (m_dwFileLength == INVALID_SET_FILE_POINTER) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;

    }
    
    //
    // restore file pointer to beginning of file
    //

    SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN);


    //
    // allocate the buffer for the wma file
    //

    m_pFileBuffer = new BYTE[m_dwFileLength];
    if (m_pFileBuffer == NULL) {

        return E_OUTOFMEMORY;
    }

    //
    // read the whole file in. We are doing this for simplicity.
    // You can instead read a little bit at time making sure you stay ahead
    // of the WMA request file offset, passed in the callback..
    // 

    DWORD dwBytesRead = 0;

    if (!ReadFile(m_hFile,
                  m_pFileBuffer,
                  m_dwFileLength,
                  &dwBytesRead,
                  NULL)) {


        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;

    }

    // Create the source (wma file) filter
    hr = WmaCreateInMemoryDecoder(WMAStreamCallback,
                                  this,
                                  0, // dont yield
                                  &wfxSourceFormat,
                                  &m_pSourceFilter);

    if( FAILED(hr) )
        return hr;

    // Create the render (DirectSoundStream) filter
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwMaxAttachedPackets = WMASTRM_PACKET_COUNT;
    dssd.lpwfxFormat          = &wfxSourceFormat;

    hr = DirectSoundCreateStream( &dssd, &m_pRenderFilter );
    if( FAILED(hr) )
        return hr;

    if( g_bDoDebugChecks )
    {
        XMEDIAINFO xmi;

        // We expect the source filter to be synchronous and read-only, the
        // transform filter to be synchronous and read/write and the render
        // filter to be asynchronous write-only.  Assert that all of this 
        // is true and check the packet sizes for compatibility.

        hr = m_pSourceFilter->GetInfo( &xmi );
        if( FAILED(hr) )
            return hr;
        MY_ASSERT( xmi.dwFlags & XMO_STREAMF_FIXED_SAMPLE_SIZE );

        MY_ASSERT( !xmi.dwMaxLookahead );
        MY_ASSERT( xmi.dwOutputSize );
        MY_ASSERT( !(WMASTRM_SOURCE_PACKET_BYTES % xmi.dwOutputSize) );

        hr = m_pRenderFilter->GetInfo( &xmi );
        if( FAILED(hr) )
            return hr;
        MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC) );
        MY_ASSERT( WMASTRM_SOURCE_PACKET_BYTES * WMASTRM_PACKET_COUNT >= xmi.dwMaxLookahead );
        MY_ASSERT( !(WMASTRM_SOURCE_PACKET_BYTES % xmi.dwInputSize) );
        MY_ASSERT( !xmi.dwOutputSize );
    }

    // Allocate data buffers.  Since the source filter is synchronous, we only
    // have to allocate enough data to process a single packet.  The render
    // filter, however, is asynchronous, so we'll have to allocate enough
    // space to hold all the packets that could be submitted at any given time.
    m_pvSourceBuffer = new BYTE[ WMASTRM_SOURCE_PACKET_BYTES * WMASTRM_PACKET_COUNT ];
    if( NULL == m_pvSourceBuffer )
        return E_OUTOFMEMORY;


    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: WMAStreamCallback()
// Desc: The WMA decoder calls this function to retrieve raw (compressed) file data.
//-----------------------------------------------------------------------------

DWORD CALLBACK WMAStreamCallback (
    LPVOID pContext,
    ULONG offset,
    ULONG num_bytes,
    LPVOID *ppData)
{

    CWMAFileStream *pThis = (CWMAFileStream *)pContext;

    *ppData = pThis->m_pFileBuffer + offset;

    //
    // update current file offset for our progress bar
    //

    pThis->m_dwFileProgress = offset;
    return num_bytes;


}


//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Performs any work necessary to keep the stream playing.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::Process( DWORD* pdwPercentCompleted )
{
    DWORD   dwPacketIndex;
    HRESULT hr;
    
    // Find a free packet.  If there's none free, we don't have anything
    // to do
    while( FindFreePacket( &dwPacketIndex ) )
    {
         // Read from the source filter
         hr = ProcessSource(dwPacketIndex);
         if( FAILED(hr) )
             return hr;
         
         // Send the data to the renderer
         hr = ProcessRenderer(dwPacketIndex);
         if( FAILED(hr) )
             return hr;
    }

    // Calculate the completion percentage based on the total amount of
    // data we've read from the source.
    if( pdwPercentCompleted )
        (*pdwPercentCompleted) = m_dwFileProgress * 100 / m_dwFileLength;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket()
// Desc: Finds a render packet available for processing.
//-----------------------------------------------------------------------------
BOOL CWMAFileStream::FindFreePacket( DWORD* pdwPacketIndex )
{
    for( DWORD dwPacketIndex = 0; dwPacketIndex < WMASTRM_PACKET_COUNT; dwPacketIndex++ )
    {
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[dwPacketIndex] )
        {
            if( pdwPacketIndex )
                (*pdwPacketIndex) = dwPacketIndex;

            return TRUE;
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessSource()
// Desc: Reads data from the source filter.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::ProcessSource(DWORD dwPacketIndex)
{
    DWORD        dwTotalSourceUsed   = 0;
    DWORD        dwSourceUsed;
    XMEDIAPACKET xmp;
    HRESULT      hr;
    
    // We're going to read a full packet's worth of data into the source
    // buffer.  Since we're playing in an infinite loop, we'll just spin
    // until we've read enough data, even if that means wrapping around the
    // end of the file.

    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer         = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * WMASTRM_SOURCE_PACKET_BYTES);
    xmp.dwMaxSize        = WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwCompletedSize = &dwSourceUsed;

    while( dwTotalSourceUsed < WMASTRM_SOURCE_PACKET_BYTES )
    {
        // Read from the source
        hr = m_pSourceFilter->Process(NULL, &xmp);
        if( FAILED(hr) )
            return hr;

        // Add the amount read to the total
        dwTotalSourceUsed += dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
            hr = m_pSourceFilter->Flush();
            if( FAILED(hr) )
                return hr;
        };
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessRenderer()
// Desc: Sends data to the renderer.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::ProcessRenderer( DWORD dwPacketIndex )
{
    XMEDIAPACKET xmp;
    HRESULT      hr;

    // There's a full packet's worth of data ready for us to send to the
    // renderer.  We want to track the status of this packet since the
    // render filter is asychronous and we need to know when the packet is
    // completed.
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer  = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * WMASTRM_SOURCE_PACKET_BYTES );
    xmp.dwMaxSize = WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwStatus = &m_adwPacketStatus[dwPacketIndex];

    hr = m_pRenderFilter->Process( &xmp, NULL );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Pause
// Desc: Pauses and resumes stream playback
//-----------------------------------------------------------------------------
VOID
CWMAFileStream::Pause( DWORD dwPause )
{
    m_pRenderFilter->Pause( dwPause );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\Main.cpp ===
//-----------------------------------------------------------------------------
// File: Main.cpp
//
// Desc: Simple app to play a streaming sound and render the percent completion
//       of the sound.  Processes synchronously on a worker thread
//
// Hist: 12.15.00 - New for December XDK release
//       3.15.01 - Updated for April XDK 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

//#define NODSOUND 1

#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>

//#include  "D:\AugDSound\h\dsound.h"

#include "WMAStream.h"
#include "dsstdfx.h"



//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Pause" },
};

#define NUM_HELP_CALLOUTS 2


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CWMAFileStream m_Stream;        // The WMA stream
    CXBFont        m_Font;          // A font to render text
    CXBHelp        m_Help;          // Help object
    BOOL           m_bDrawHelp;     // Should we draw help?
    DWORD          m_dwPercentCompleted;    // Percentage of file processed

    HANDLE         m_hWorkerThread; // Worker thread
    BOOL           m_bPaused;       // Paused?

    LPDIRECTSOUND8 m_pDSound;       // DirectSound object

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};




//-----------------------------------------------------------------------------
// Name: Main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Performs whatever initialization the sample needs
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a WMA stream
    if( FAILED( m_Stream.Initialize( "D:\\Media\\Sounds\\Becky.wma", &m_dwPercentCompleted ) ) )
        return E_FAIL;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    m_bDrawHelp = FALSE;
    m_bPaused = FALSE;

    m_dwPercentCompleted = 0;

    // Create worker thread to process audio
    m_hWorkerThread = CreateThread( NULL, 0, WMAFileStreamThreadProc, &m_Stream, 0, NULL );
    if( m_hWorkerThread == NULL )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Called once per frame to update state
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle pause
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_bPaused = !m_bPaused;
        m_Stream.Pause( m_bPaused ? DSSTREAMPAUSE_PAUSE : DSSTREAMPAUSE_RESUME );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render the scene (which is just the progress bar)
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );

    DirectSoundDoWork();

    if( E_PENDING == m_Stream.GetOpenResult() )
    {
        m_Font.DrawText( 64, 50, 0xffffffff, L"Loading WMA file..." );
    }
    else if( E_FAIL == m_Stream.GetOpenResult() )
    {
        // If didn't open the WMA file
        WCHAR strFailure[128];
        wsprintfW( strFailure, L"Failed to load WMA; HRESULT: 0x%X", m_Stream.GetOpenResult() );
        m_Font.DrawText( 64,  50, 0xffffffff, strFailure );
    }
    else
    {
        // Show title, frame rate, and help
        if( m_bDrawHelp )
            m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
        else
        {
            // Draw the text
            m_Font.DrawText( 64,  50, 0xffffffff, L"WMAStream" );

			//Print out Track Length in ms			
			WCHAR szTrackLengthInMS[100];
		    swprintf( szTrackLengthInMS, L"Track Length %d ms", m_Stream.m_WmaFileHeader.dwDuration );
			m_Font.DrawText( 64, 275, 0xffffff00, szTrackLengthInMS);


			//Print out Track Name
			WCHAR szTrackName[256];
		    swprintf( szTrackName, L"Track Name: %s", m_Stream.m_WmaContentDescription.pTitle );
			m_Font.DrawText( 64, 300, 0xffffff00, szTrackName);

			//Print out Track Name
			WCHAR szTrackAuthor[256];
		    swprintf( szTrackAuthor, L"Author: %s", m_Stream.m_WmaContentDescription.pAuthor );
			m_Font.DrawText( 64, 325, 0xffffff00, szTrackAuthor);

        }
        WCHAR sz[100];
        swprintf( sz, L"Progress: %s", m_bPaused ? L"(Paused)" : L"" );
        m_Font.DrawText( 64, 375, 0xffffff00, sz);

        // Render a simple progress bar to show the percent completed
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[8];
        FLOAT x1 =  64, x2 = x1 + (512*m_dwPercentCompleted)/100, x3 = 64+512;
        FLOAT y1 = 400, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffff00;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffff00;
        v[2].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffffff00;
        v[3].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffffff00;
        v[4].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[4].color = 0xff8080ff;
        v[5].p = D3DXVECTOR4( x3-0.5f, y1-0.5f, 1.0f, 1.0f );  v[5].color = 0xff8080ff;
        v[6].p = D3DXVECTOR4( x3-0.5f, y2-0.5f, 1.0f, 1.0f );  v[6].color = 0xff8080ff;
        v[7].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[7].color = 0xff8080ff;

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 2, v, sizeof(v[0]) );
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmainmemory\WMAInMemory.h ===
//-----------------------------------------------------------------------------
// File: WMAInMemory.h
//
// Desc: Streaming wave file playback.
//
// Hist: 3.15.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef WMAINMEMORY_H
#define WMAINMEMORY_H

//
// the wma decoder will work properly in async mode, with all formats
// only when using a lookahead size of at least 64k. We are using it synchronous mode
// but for good measure we still pass 64k
//

#define WMASTRM_LOOKAHEAD_SIZE (4096*16)

// Define the maximum amount of packets we will ever submit to the renderer
#define WMASTRM_PACKET_COUNT 8




// Define the source packet size:
// This value is hard-coded assuming a WMA file of stero, 16bit resolution.  If
// this Value can by dynamically set based on the wma format, keeping in mind
// that wma needs enough buffer for a minimum of 2048 samples worth of PCM data
#define WMASTRM_SOURCE_PACKET_BYTES (2048*2*2)

DWORD CALLBACK WMAStreamCallback (
    LPVOID pContext,
    DWORD offset,
    DWORD num_bytes,
    LPVOID *ppData);


//-----------------------------------------------------------------------------
// Name: class CWMAFileStream
// Desc: Wave file streaming object
//-----------------------------------------------------------------------------
class CWMAFileStream
{
protected:
    XMediaObject*       m_pSourceFilter;                         // Source (wave file) filter
    IDirectSoundStream* m_pRenderFilter;                         // Render (DirectSoundStream) filter
    LPVOID              m_pvSourceBuffer;                        // Source filter data buffer
    LPVOID              m_pvRenderBuffer;                        // Render filter data buffer
    DWORD               m_adwPacketStatus[WMASTRM_PACKET_COUNT]; // Packet status array
    DWORD               m_dwFileLength;                          // File duration, in bytes
    DWORD               m_dwFileProgress;                        // File progress, in bytes

    PUCHAR              m_pFileBuffer;
    HANDLE              m_hFile;

    // Packet processing
    BOOL    FindFreePacket(DWORD* pdwPacketIndex );
    HRESULT ProcessSource(DWORD dwPacketIndex);
    HRESULT ProcessRenderer( DWORD dwPacketIndex );

    friend DWORD CALLBACK WMAStreamCallback (
    LPVOID pContext,
    ULONG offset,
    ULONG num_bytes,
    LPVOID *ppData);
     

public:
    // Processing
    HRESULT Process( DWORD* pdwPercentCompleted );

    // Initialization
    HRESULT Initialize( const CHAR* strFileName );

    // Play control
    VOID Pause( DWORD dwPause );
    
    CWMAFileStream();
    ~CWMAFileStream();
};




#endif // WMAINMEMORY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\WMAStream.cpp ===
//-----------------------------------------------------------------------------
// File: WMAStream.cpp
//
// Desc: Class for streaming wave file playback.
//
// Hist: 12.15.00 - New for December XDK release
//       3.15.01 - Updated for April XDK 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <xtl.h>
#include "WMAStream.h"




//-----------------------------------------------------------------------------
// Debugging help
//-----------------------------------------------------------------------------
#define MY_ASSERT(x) if( !(x) ) _asm int 3;

BOOL g_bDoDebugChecks = FALSE;




//-----------------------------------------------------------------------------
// Name: CWMAFileStream()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWMAFileStream::CWMAFileStream()
{
    m_pSourceFilter    = NULL;
    m_pRenderFilter    = NULL;
    m_pvSourceBuffer   = NULL;
    m_hrOpenResult     = E_PENDING;
    
    for( DWORD i = 0; i < WMASTRM_PACKET_COUNT; i++ )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;

    m_dwStartingDataOffset = 0;
    m_dwFileProgress = 0;

    memset(&m_WmaContentDescription,0,sizeof(m_WmaContentDescription));
	
}





//-----------------------------------------------------------------------------
// Name: ~CWMAFileStream()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWMAFileStream::~CWMAFileStream()
{
    if( m_pSourceFilter )      m_pSourceFilter->Release();
    if( m_pRenderFilter )      m_pRenderFilter->Release();
    if( m_pvSourceBuffer )     delete[] m_pvSourceBuffer;

    if (m_WmaContentDescription.pTitle)
        delete [] m_WmaContentDescription.pTitle;

    if (m_WmaContentDescription.pDescription)
        delete [] m_WmaContentDescription.pDescription;

    if (m_WmaContentDescription.pAuthor)
        delete [] m_WmaContentDescription.pAuthor;

}




//-----------------------------------------------------------------------------
// Name: InitializeOnThread()
// Desc: Performs initialization that must be done on worker thread
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::InitializeOnThread()
{
    HRESULT        hr;

    // Create the source (wma file) filter
    hr = WmaCreateDecoderEx( m_strFilename,             // File name
                             NULL,                      // instead of handle
                             FALSE,                     // Synchronous
                             WMASTRM_LOOKAHEAD_SIZE,    // Lookahead size
                             WMASTRM_PACKET_COUNT,      // # of packets
                             3,                         // Yield rate
                             &m_wfxSourceFormat,        // Wave format
                             &m_pSourceFilter );        // XMO pointer
    if( FAILED(hr) )
    {
        m_hrOpenResult = E_FAIL;
        return hr;
    }

    // Now we're done with our copy of the filename
    delete[] m_strFilename;

    // get some info about the wma content
    hr = m_pSourceFilter->GetFileContentDescription(&m_WmaContentDescription);
    if( FAILED(hr) )
    {
        m_hrOpenResult = E_FAIL;
        return hr;
    }

    // Create the render (DirectSoundStream) filter
    DSSTREAMDESC   dssd;
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwMaxAttachedPackets = WMASTRM_PACKET_COUNT;
    dssd.lpwfxFormat          = &m_wfxSourceFormat;

    hr = DirectSoundCreateStream( &dssd, &m_pRenderFilter );
    if( FAILED(hr) )
    {
        m_hrOpenResult = E_FAIL;
        return hr;
    }

    if( g_bDoDebugChecks )
    {
        XMEDIAINFO xmi;

        // We expect the source filter to be synchronous and read-only, the
        // transform filter to be synchronous and read/write and the render
        // filter to be asynchronous write-only.  Assert that all of this 
        // is true and check the packet sizes for compatibility.

        hr = m_pSourceFilter->GetInfo( &xmi );
        if( FAILED(hr) )
        {
            m_hrOpenResult = E_FAIL;
            return hr;
        }
        MY_ASSERT( xmi.dwFlags & XMO_STREAMF_FIXED_SAMPLE_SIZE );

        MY_ASSERT( !xmi.dwMaxLookahead );
        MY_ASSERT( xmi.dwOutputSize );
        MY_ASSERT( !(WMASTRM_SOURCE_PACKET_BYTES % xmi.dwOutputSize) );

        hr = m_pRenderFilter->GetInfo( &xmi );
        if( FAILED(hr) )
        {
            m_hrOpenResult = E_FAIL;
            return hr;
        }
        MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC) );
        MY_ASSERT( WMASTRM_SOURCE_PACKET_BYTES * WMASTRM_PACKET_COUNT >= xmi.dwMaxLookahead );
        MY_ASSERT( !(WMASTRM_SOURCE_PACKET_BYTES % xmi.dwInputSize) );
        MY_ASSERT( !xmi.dwOutputSize );
    }

    // Get the total wave file duration.  We'll use this to calculate how far
    // along in the file we are during processing.
    hr = m_pSourceFilter->GetFileHeader( &m_WmaFileHeader );
    if( FAILED(hr) )
    {
        m_hrOpenResult = E_FAIL;
        return hr;
    }

    m_hrOpenResult = S_OK;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the wave file streaming subsystem.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::Initialize( const CHAR* strFileName, DWORD * pdwPercentCompleted )
{
    // Make a copy of the filename
    m_strFilename = new CHAR[ strlen( strFileName ) + 1 ];
    strcpy( m_strFilename, strFileName );

    m_pdwPercentCompleted = pdwPercentCompleted;
    
    m_WmaContentDescription.wTitleLength = 256;
    m_WmaContentDescription.wAuthorLength = 256;
    m_WmaContentDescription.wDescriptionLength = 256;

    // allocate buffers to hold the wma info

    m_WmaContentDescription.pTitle = new WCHAR[m_WmaContentDescription.wTitleLength];
    m_WmaContentDescription.pAuthor = new WCHAR[m_WmaContentDescription.wAuthorLength];
    m_WmaContentDescription.pDescription = new WCHAR[m_WmaContentDescription.wDescriptionLength];

    if ((m_WmaContentDescription.pDescription == NULL) ||
        (m_WmaContentDescription.pAuthor == NULL) ||
        (m_WmaContentDescription.pTitle == NULL)){
        
        return E_OUTOFMEMORY;

    }

    // Allocate data buffers.  Since the source filter is synchronous, we only
    // have to allocate enough data to process a single packet.  The render
    // filter, however, is asynchronous, so we'll have to allocate enough
    // space to hold all the packets that could be submitted at any given time.
    m_pvSourceBuffer = new BYTE[ WMASTRM_SOURCE_PACKET_BYTES * WMASTRM_PACKET_COUNT ];
    if( NULL == m_pvSourceBuffer )
        return E_OUTOFMEMORY;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Performs any work necessary to keep the stream playing.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::Process()
{
    DWORD   dwPacketIndex;
    HRESULT hr;
    
    // Find a free packet.  If there's none free, we don't have anything
    // to do
    while( FindFreePacket( &dwPacketIndex ) )
    {
         // Read from the source filter
         hr = ProcessSource(dwPacketIndex);
         if( FAILED(hr) )
             return hr;
         
         // Send the data to the renderer
         hr = ProcessRenderer(dwPacketIndex);
         if( FAILED(hr) )
             return hr;
    }

    // Calculate the completion percentage based on the total amount of
    // data we've played back.
    // NOTE: Process() is actually being called on our worker thread,
    // not the main title thread, so there could potentially be concurrent
    // access to the value pointed to by m_pdwPercentCompleted.  However,
    // this thread only writes to the value, and the main title thread
    // only reads it.  So the worst that could happen is that the main
    // title thread reads this just before we write to it, which is fine.
    // If more complex cross-thread operations are being performed, 
    // synchronization primitives may be required.
    if( m_pdwPercentCompleted )
        (*m_pdwPercentCompleted) = m_dwFileProgress * 100 / m_WmaFileHeader.dwDuration;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket()
// Desc: Finds a render packet available for processing.
//-----------------------------------------------------------------------------
BOOL CWMAFileStream::FindFreePacket( DWORD* pdwPacketIndex )
{
    for( DWORD dwPacketIndex = 0; dwPacketIndex < WMASTRM_PACKET_COUNT; dwPacketIndex++ )
    {
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[dwPacketIndex] )
        {
            if( pdwPacketIndex )
                (*pdwPacketIndex) = dwPacketIndex;

            return TRUE;
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessSource()
// Desc: Reads data from the source filter.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::ProcessSource(DWORD dwPacketIndex)
{
    DWORD        dwTotalSourceUsed   = 0;
    DWORD        dwSourceUsed;
    XMEDIAPACKET xmp;
    HRESULT      hr;
    
    // We're going to read a full packet's worth of data into the source
    // buffer.  Since we're playing in an infinite loop, we'll just spin
    // until we've read enough data, even if that means wrapping around the
    // end of the file.

    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer         = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * WMASTRM_SOURCE_PACKET_BYTES);
    xmp.dwMaxSize        = WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwCompletedSize = &dwSourceUsed;

    while( dwTotalSourceUsed < WMASTRM_SOURCE_PACKET_BYTES )
    {
        // Read from the source
        hr = m_pSourceFilter->Process(NULL, &xmp);
        if( FAILED(hr) )
            return hr;

        // Add the amount read to the total
        dwTotalSourceUsed += dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
            hr = m_pSourceFilter->Flush();
            if( FAILED(hr) )
                return hr;
        };
    }

    //
    // Update the file progress. We know how much data in bytes, we have just played back
    // using the audio format of the wma file, determine how many ms we just played
    //

    dwTotalSourceUsed = (dwTotalSourceUsed*1000)/m_wfxSourceFormat.nAvgBytesPerSec;
    m_dwFileProgress = (m_dwFileProgress+dwTotalSourceUsed)%m_WmaFileHeader.dwDuration;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessRenderer()
// Desc: Sends data to the renderer.
//-----------------------------------------------------------------------------
HRESULT CWMAFileStream::ProcessRenderer( DWORD dwPacketIndex )
{
    XMEDIAPACKET xmp;
    HRESULT      hr;

    // There's a full packet's worth of data ready for us to send to the
    // renderer.  We want to track the status of this packet since the
    // render filter is asychronous and we need to know when the packet is
    // completed.
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer  = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * WMASTRM_SOURCE_PACKET_BYTES );
    xmp.dwMaxSize = WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwStatus = &m_adwPacketStatus[dwPacketIndex];

    hr = m_pRenderFilter->Process( &xmp, NULL );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Pause
// Desc: Pauses and resumes stream playback
//-----------------------------------------------------------------------------
VOID
CWMAFileStream::Pause( DWORD dwPause )
{
    m_pRenderFilter->Pause( dwPause );
}



//-----------------------------------------------------------------------------
// Name: WMAFileStreamThreadProc
// Desc: Thread proc for sound processing worker thread
//-----------------------------------------------------------------------------
DWORD WINAPI WMAFileStreamThreadProc( LPVOID lpParameter )
{
    CWMAFileStream * pThis = (CWMAFileStream *)lpParameter;

    if( FAILED( pThis->InitializeOnThread() ) )
        return 0;

    // To process approximately once per frame, we can sleep
    // for 1000 ms / 60 fps between calls to Process.
    //
    // Alternately, the minimum time between processing is
    // determined by how much data we're sending to the stream
    // at once:
    // 2048 * 16 samples per packet * 16 packets = 524288 samples
    // 524288 samples / 44100 samples per second = 11.8 seconds
    //
    // DWORD dwQuantum = 11000;
 
    DWORD dwQuantum = 1000 / 60;

    for( ; ; )
    {
        pThis->Process();
        Sleep( dwQuantum );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\WMAStream\WMAStream.h ===
//-----------------------------------------------------------------------------
// File: WMAStream.h
//
// Desc: Streaming wave file playback - demonstrates how to run the WMA
//       decoder synchronously on a separate thread
//
// Hist: 12.15.00 - New for December XDK release
//       3.15.01 - Updated for April XDK 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef WMASTREAM_H
#define WMASTREAM_H

//
// the wma decoder will work properly in async mode, with all formats
// only when using a lookahead size of at least 64k. We are using it in 
// synchronous mode but for good measure we still pass 64k
//

#define WMASTRM_LOOKAHEAD_SIZE (4096*16)

// Define the maximum amount of packets we will ever submit to the renderer
#define WMASTRM_PACKET_COUNT 8




// Define the source packet size:
// This value is hard-coded assuming a WMA file of stero, 16bit resolution.  If
// this Value can by dynamically set based on the wma format, keeping in mind
// that wma needs enough buffer for a minimum of 2048 samples worth of PCM data
#define WMASTRM_SOURCE_PACKET_BYTES (2048*2*2)

// ThreadProc for worker thread
DWORD WINAPI WMAFileStreamThreadProc( LPVOID lpParameter );

//-----------------------------------------------------------------------------
// Name: class CWMAFileStream
// Desc: Wave file streaming object
//-----------------------------------------------------------------------------
class CWMAFileStream
{
protected:
    XWmaFileMediaObject*   m_pSourceFilter;                         // Source (wave file) filter
    IDirectSoundStream* m_pRenderFilter;                         // Render (DirectSoundStream) filter
    LPVOID              m_pvSourceBuffer;                        // Source filter data buffer
    LPVOID              m_pvRenderBuffer;                        // Render filter data buffer
    DWORD               m_adwPacketStatus[WMASTRM_PACKET_COUNT]; // Packet status array
    DWORD               m_dwFileProgress;                        // File progress, in bytes
    DWORD               m_dwStartingDataOffset;                  // offset into wma file were data begins
    DWORD *             m_pdwPercentCompleted;                   // Pointer to percent complete variable

    
    CHAR*               m_strFilename;                           // File to load
    HRESULT             m_hrOpenResult;                          // Result of opening file
    WAVEFORMATEX        m_wfxSourceFormat;                       // Wave format

    // Packet processing
    BOOL    FindFreePacket(DWORD* pdwPacketIndex );
    HRESULT ProcessSource(DWORD dwPacketIndex);
    HRESULT ProcessRenderer( DWORD dwPacketIndex );

public:

    WMAXMOFileContDesc  m_WmaContentDescription;                 // text information about author, title, description, etc
	WMAXMOFileHeader    m_WmaFileHeader;                         // basic information about the wma file

    // Processing
    HRESULT Process();

    // Initialization
    HRESULT Initialize( const CHAR* strFileName, DWORD * pdwPercentCompleted = NULL );
    HRESULT InitializeOnThread();
    HRESULT GetOpenResult() { return m_hrOpenResult; }
    
    // Play control
    VOID Pause( DWORD dwPause );

    CWMAFileStream();
    ~CWMAFileStream();
};




#endif // WMASTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\makefile.inc ===
$(_NT386TREE)\winx\dump\$(TARGETNAME).$(TARGETEXT): $(TARGET)
    copy $** $@

$(_NT386TREE)\winx\dump\$(TARGETNAME).inf: oemsetup.inf
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmvplayback\wmvplay.h ===
#ifndef _WMVPLAY_H__
#define _WMVPLAY_H__

#include "wmfdecode.h"

#if DBG

extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_WmvDebugLevel;
#define DBG_SPAM(_exp_) {if (g_WmvDebugLevel >= DEBUG_LEVEL_SPAM) DebugPrint _exp_;}
#define DBG_INFO(_exp) {if (g_WmvDebugLevel >= DEBUG_LEVEL_INFO) DebugPrint _exp;}
#define DBG_ERROR(_exp) {if (g_WmvDebugLevel >= DEBUG_LEVEL_ERROR) DebugPrint _exp;}
#define DBG_WARN(_exp) {if (g_WmvDebugLevel >= DEBUG_LEVEL_WARNING) DebugPrint _exp;}

    #define ASSERT(Expression)  \
    {                                                          \
        if(!(Expression))                                      \
        {                                                      \
            DebugPrint("XBOX RIP:\n");               \
            _asm { int 3 };                                    \
        }                                                      \
    }                                   

#else

#define ASSERT(_exp_)
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)

#endif

//
// graphics defines
//

#define NUM_HELP_CALLOUTS 5

//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct PROJTEXVERTEX
{
    D3DXVECTOR3 p;
    D3DCOLOR    color;
};

#define D3DFVF_PROJTEXVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)




//----------------------------------------------------------------------------
// projection frustrum
struct LINEVERTEX
{
    FLOAT x, y, z;
    DWORD color;
};






//
// audio defines
//


//
// Simple macro to verify that the packet size is OK for a particular XMO
//
inline HRESULT XMOFILTER_VERIFY_PACKET_SIZE( XMEDIAINFO& xMediaInfo, DWORD dwPacketSize )
{
    if( xMediaInfo.dwOutputSize > dwPacketSize )
        return E_FAIL;
    if( xMediaInfo.dwOutputSize ) 
        if( dwPacketSize % xMediaInfo.dwOutputSize != 0 )
            return E_FAIL;
    if( dwPacketSize < xMediaInfo.dwMaxLookahead )
        return E_FAIL;

    return S_OK;
}


//
// Linked list structure for tracking our media packet contexts
//
struct LINKED_LIST 
{
    LINKED_LIST* pNext;
    LINKED_LIST* pPrev;

    inline VOID Initialize()         { pNext = pPrev = this; }
    inline BOOL IsListEmpty()        { return pNext == this; }
    inline LINKED_LIST* RemoveHead() { pNext->Remove(); }
    inline LINKED_LIST* RemoveTail() { pPrev->Remove(); }

    inline VOID Remove() 
    {
        LINKED_LIST* pOldNext = pNext;
        LINKED_LIST* pOldPrev = pPrev;
        pOldPrev->pNext = pOldNext;
        pOldNext->pPrev = pOldPrev;
    }

    inline VOID Add( LINKED_LIST* pEntry ) 
    {
        LINKED_LIST* pOldHead = this;
        LINKED_LIST* pOldPrev = this->pPrev;
        pEntry->pNext   = pOldHead;
        pEntry->pPrev   = pOldPrev;
        pOldPrev->pNext = pEntry;
        pOldHead->pPrev = pEntry;
    }
};


//
// We arrived at this packet size based on the requirements of the XMOs.
// The idea is to pick an arbitrary packet size, go through the Init function
// once and then if any asserts fires while verifying the packet sizes, change
// the packet to satisfy all requirements
//
#define PACKET_CNT      0x50
#define PACKET_SIZE     0x1000*4
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

// This structure keeps track of our packet status, buffer data, etc.
struct MEDIA_PACKET_CTX
{
    LINKED_LIST ListEntry;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};


//-----------------------------------------------------------------------------
// Name: class XFilterGraph
//
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CFilterGraph : public CXBApplication
{
public:
    XFileMediaObject* m_pSourceXMO;         // Source XMO - the WMA file
    XMediaObject* m_pTargetXMO;             // Target XMO - DSound

    DWORD         m_dwSourceLength;         // Size of source
    DWORD         m_dwBytesRead;            // Bytes of stream processed

    DWORD         m_dwMinPacketSize;        // For verifying our packet size
    DWORD         m_dwPacketSize;           // Packet size
    DWORD         m_dwMaxBufferCount;       // # of buffers

    WAVEFORMATEX  m_wfxAudioFormat;         // Audio format

    LINKED_LIST   m_SourcePendingList;      // Media Contexts in source list
    LINKED_LIST   m_TargetPendingList;      // Media Contexts in target list

    BYTE*         m_pTransferBuffer;        // Buffer data
    BYTE*         m_pPacketContextPool;     // Packet contexts

    CXBFont       m_Font;                   // Font renderer
    DWORD         m_dwFrameCount;           //

    HANDLE        m_hThread;

    // Virtual calls from CXBApplication
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();

    //
    // init calls
    //

    HRESULT InitWmv();
    HRESULT InitGraphics();

    VOID ThreadProc();

    // These functions attach a media context packet to an XMO by 
    // setting up the XMEDIAPACKET struct, calling Process(), and
    // then adding our media packet context to the appropriate list
    HRESULT AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx );
    HRESULT AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx );

    // Handles transferring packets through our filter graph
    HRESULT TransferData();

    //
    // wmv stuff
    //

    AudioStreamInfo m_AudStrm;
    VideoStreamInfo m_VidStrm;
    HWMFDECODER   m_hWmfDecoder;            // WMV decoder
    HANDLE        m_hWmvFile;
    PUCHAR        m_pVidBuf;
    PUCHAR        m_pVidTempBuf;


    //
    // graphics stuff...
    //

    CXBHelp                m_Help;
    BOOL                   m_bDrawHelp;

    LPDIRECT3DTEXTURE8     m_pSpotLightTexture;   // procedurally generated spotlight texture

    D3DXMATRIX             m_matTexProj;   // texture projection matrix

    D3DXVECTOR3            m_vTexEyePt;    // texture eye pt.
    D3DXVECTOR3            m_vTexLookatPt; // texture lookat pt.

    HRESULT CreateSpotLightTexture();
    VOID    ShowTexture( LPDIRECT3DTEXTURE8 pTexture );

    HRESULT GraphicsFrameMove();


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmvplayback\wmvplayback.cpp ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdlib.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <xgraphics.h>

#include "wmvplay.h"

//
// BUGBUG REMoE GLOBALS
//

DWORD g_dwImageSize = 0;
DWORD dwFrameRate = 0;
DWORD dwPrevVideoTimeStamp=0;

DWORD dwDecodeRate = 0;
DWORD dwLastDecodeTimeStamp = 0;

#if DBG


    ULONG g_WmvDebugLevel = 1;

#endif

DWORD WINAPI WmvThreadProc(
    LPVOID pParameter
    );

CFilterGraph *g_pThis;

//-----------------------------------------------------------------------------
// Name: Initialize
//
// Desc: Creates a streaming graph between 3 XMOs: a source, a in-between
//       (codec in this case) and a target. We only support one intermediate
//       xmo, but you could actually have multiple ones that manipulate the
//       same stream passing packets between them
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::Initialize()
{
    HRESULT        hr;
    DWORD          dwMinSize;
    XMEDIAINFO     xMediaInfo;
    DSSTREAMDESC   dssd;

    m_dwFrameCount = 0;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    //
    // init wmv decoder
    //

    InitWmv();

    m_dwBytesRead = 0;
    m_dwPacketSize     = PACKET_SIZE;
    m_dwMaxBufferCount = PACKET_CNT;

    PWAVEFORMATEX format=&m_wfxAudioFormat;

    format->wFormatTag          = WAVE_FORMAT_PCM;
    format->nSamplesPerSec      = m_AudStrm.u32SamplesPerSec;
    format->nChannels           = m_AudStrm.u16Channels;
    format->wBitsPerSample      = (WORD) m_AudStrm.u16BitsPerSample;
    format->nBlockAlign         = (16 * format->nChannels / 8);
    format->nAvgBytesPerSec     = format->nSamplesPerSec * format->nBlockAlign;
    format->cbSize              = 0;

    // Now create the target XMO, the end part of the streaming chain
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwSize               = sizeof(dssd);
    dssd.dwFlags              = 0;
    dssd.dwMaxAttachedPackets = PACKET_CNT;
    dssd.lpwfxFormat          = &m_wfxAudioFormat;

    hr = DirectSoundCreateStream( DSDEVID_MCPX, 
                                  &dssd, 
                                  (LPDIRECTSOUNDSTREAM*)&m_pTargetXMO,
                                  NULL );
    if( FAILED(hr) ) 
    {          
        DBG_ERROR( ("XmoFilter: DirectSoundCreateXMOStream failed with %x", hr) );
        DBG_ERROR( ("Init: Could not open a target audio XMO\n") );
        return hr;
    }

    //
    // At this point we should have all the XMOs.
    // Figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned.
    // As a last check we make sure its also larger than the maxLookahead
    //
    // At the end of all this, m_dwMinPacketSize is the minimum packet size
    // for this filter graph.
    //
    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    if( m_pTargetXMO )
    {
        m_pTargetXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = max( xMediaInfo.dwOutputSize, m_dwMinPacketSize );

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    ASSERT( m_pTargetXMO );

    // Initialize the linked lists
    m_SourcePendingList.Initialize();
    m_TargetPendingList.Initialize();

    //
    // Allocate one large buffer for incoming/outgoing data. The buffer is
    // going to be divided among our media context packets, which will be 
    // used to stream data between XMOs
    //
    dwMinSize = MAXBUFSIZE;
    m_pTransferBuffer = new BYTE[dwMinSize];
    ZeroMemory( m_pTransferBuffer, dwMinSize );

    //
    // Allocate a context pool. A context is associated with a packet buffer
    // and used to track the pending packets attached to the source or target
    // XMO.
    dwMinSize = ( PACKET_CNT * sizeof(MEDIA_PACKET_CTX) );
    m_pPacketContextPool = new BYTE[dwMinSize];
    ZeroMemory( m_pPacketContextPool, dwMinSize );

    //
    // We attach all available packet buffers in the beginning to prime the
    // graph: As each packet is completed by the source XMO, the status is
    // udpated in its packet context and we pass the packet to the next XMO.
    //
    for( DWORD i = 0; i < PACKET_CNT; i++ ) 
    {
        MEDIA_PACKET_CTX* pCtx = &((MEDIA_PACKET_CTX*)m_pPacketContextPool)[i];

        ZeroMemory( pCtx, sizeof(MEDIA_PACKET_CTX) );
        pCtx->dwCompletedSize = m_dwPacketSize;
        pCtx->pBuffer         = &m_pTransferBuffer[i*PACKET_SIZE];

        AttachPacketToSourceXMO( pCtx );
    }

    //
    // create a thread for wmv decode
    //

    DWORD dwThreadId;
    m_hThread = CreateThread(NULL,
                             16384,
                             WmvThreadProc,
                             this,
                             0,
                             &dwThreadId);



    return S_OK;
}


HRESULT CFilterGraph::InitWmv()
{

    WORD wBitsPerPixel =24+8;
    m_hWmfDecoder = WMFDecodeCreate (this);
    WMPERR wmerr;

    g_pThis = this;

    //
    // open the file
    //

    m_hWmvFile = CreateFile("D:\\MEDIA\\test.asf",
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if(m_hWmvFile == INVALID_HANDLE_VALUE) {

        return E_FAIL;

    }

    wmerr = WMFDecodeInit (m_hWmfDecoder, FOURCC_BI_RGB, wBitsPerPixel);
    if (wmerr != WMPERR_OK)
    {
        DBG_ERROR(("Decode Init Failed\n"));
        return wmerr;
    }   


    wmerr = WMFDecodeGetStreamInfo (m_hWmfDecoder, &m_AudStrm, &m_VidStrm);

    if (m_VidStrm.bHasValidVideo) {

        //
        // initialize graphics
        //
    
        InitGraphics();

        g_dwImageSize = m_VidStrm.u32Height * ((m_VidStrm.u32Width * wBitsPerPixel/8 +3)/4)*4;
        //m_pVidBuf = (UCHAR*) LocalAlloc(LPTR, m_VidStrm.u32Height * ((m_VidStrm.u32Width * wBitsPerPixel/8 +3)/4)*4);
        if (m_pVidBuf == NULL)
        {
            DBG_ERROR(("Can't allocate video buffer \n"));
            return 1;
        }
    }

    if(WMPERR_OK != wmerr)
    {
       DBG_ERROR(("Get Info Failed \n"));
       return E_FAIL;
    }

    wmerr = WMFDecodeSeek (m_hWmfDecoder, 0);
    if (WMPERR_OK != wmerr)
        return E_FAIL;

    return S_OK;



}

DWORD WINAPI WmvThreadProc(
    LPVOID pParameter
    )
{
    CFilterGraph *pThis = (CFilterGraph *) pParameter;
    pThis->ThreadProc();

    return 0;
}

VOID CFilterGraph::ThreadProc()
{


    DBG_INFO(("Calling decode\n"));

    while (1) {

        // Instruct routine to poll the filter graph so completed packets can be
        // moved through the streaming chain.

        ASSERT(!FAILED( g_pThis->TransferData() ) );
        ASSERT(WMFDecode (m_hWmfDecoder)==WMPERR_OK);

    }

}

WMPERR WMFCBDecodeGetData (HWMFDECODER hDecoder, PVOID pContext,char* pbuffer, U32_WMF cbSize, U64_WMF cbOffset, U32_WMF *cbRead)
{
    *cbRead=0;

    if (g_pThis->m_hWmvFile != NULL)
    {
        SetFilePointer(g_pThis->m_hWmvFile, (ULONG)cbOffset, NULL, FILE_BEGIN);
        if (!ReadFile(g_pThis->m_hWmvFile, pbuffer, cbSize, cbRead,NULL )) {

            return WMPERR_FAIL;

        }

        if (*cbRead != cbSize) {
            _asm int 3;
        }

    }

    return WMPERR_OK;
}

WMPERR WMFCBOutputDecodedAudio (HWMFDECODER hDecoder,PVOID pContext,const U8_WMF* pbAudio, U32_WMF cbAudioSize, U32_WMF cbSamples, U32_WMF cbTotAudioOut, U32_WMF dwTimeStamp)
{
    I32_WMF cbWritten =0;
    I32_WMF hr;

    if ((cbAudioSize >0) && (pbAudio != NULL))
    {

        MEDIA_PACKET_CTX* pSrcCtx = NULL;

        ASSERT(!FAILED( g_pThis->TransferData() ) );

        if( !g_pThis->m_SourcePendingList.IsListEmpty() ) 
        {
            pSrcCtx = (MEDIA_PACKET_CTX*)g_pThis->m_SourcePendingList.pNext; // Head

            while ((LINKED_LIST*)pSrcCtx != &g_pThis->m_SourcePendingList) {

                if (pSrcCtx->dwStatus == XMEDIAPACKET_STATUS_PENDING) {

                    break;

                }

                pSrcCtx = (MEDIA_PACKET_CTX*)pSrcCtx->ListEntry.pNext;

            }

            if (cbAudioSize == 0) {
                _asm int 3;
            }

            if (pSrcCtx->dwStatus == XMEDIAPACKET_STATUS_PENDING) {
                
                ASSERT(cbAudioSize <= PACKET_SIZE);
                memcpy(pSrcCtx->pBuffer, pbAudio, cbAudioSize);
        
                // Rset the state of our context
                pSrcCtx->dwStatus        = XMEDIAPACKET_STATUS_SUCCESS;
                pSrcCtx->dwCompletedSize = cbAudioSize;

            } else {

                DBG_ERROR((" Could not find empty audio packet\n"));

            }

        }
        DBG_INFO(("WMFCBOutputDecodedAudio: Got Audio Packet: Bytes %x, timestamp %x\n",
                    cbAudioSize, dwTimeStamp));


    }

    return WMPERR_OK;

}

WMPERR WMFCBGetVideoOutputBuffer (HWMFDECODER hDecoder,PVOID pContext,U8_WMF** ppucVideoOutoutBuffer)
{
    *ppucVideoOutoutBuffer = g_pThis->m_pVidBuf;    
    return WMPERR_OK;
}


WMPERR WMFCBOutputDecodedVideo (HWMFDECODER hDecoder,PVOID pContext,const U8_WMF *pbVideo, U32_WMF cbFrame, U32_WMF  biSizeImage, U32_WMF dwVideoTimeStamp)
{
    I32_WMF cbWritten =0;

    I32_WMF hr;
    static U32_WMF dwFrames =0;

    if (dwFrameRate > 0)
    {
        while ((dwVideoTimeStamp > dwPrevVideoTimeStamp)&&(dwVideoTimeStamp - dwPrevVideoTimeStamp)> (1000/dwFrameRate + 5) )
        {
        
            if (pbVideo !=NULL)
            {
                DBG_INFO(("Got Video Frame\n"));
            }
            dwPrevVideoTimeStamp +=(1000/dwFrameRate);
        }
    }
        
    dwFrameRate = 10000/(dwVideoTimeStamp - dwPrevVideoTimeStamp);
    dwFrameRate = (dwFrameRate +5)/10;

    dwDecodeRate = 10000/(GetTickCount() - dwLastDecodeTimeStamp);
    dwDecodeRate = (dwDecodeRate+5)/10;


    if (dwFrameRate) {

        DWORD dwFrameTime,dwDecodeInterval;
        DWORD dwSleepTime;

        dwFrameTime = 1000/dwFrameRate;
        dwDecodeInterval = (1000/dwDecodeRate) + 1;
        if (dwDecodeInterval < dwFrameTime) {

            dwSleepTime = dwFrameTime - dwDecodeInterval;
            Sleep(dwSleepTime);

            DBG_INFO(("Stalling decoder, sleeping for %x\n",
                     dwSleepTime));
        


        }

    }

    dwPrevVideoTimeStamp = dwVideoTimeStamp;
    dwLastDecodeTimeStamp = GetTickCount();
    
    return WMPERR_OK;
}




//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Clean up resources
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::Cleanup()
{
    // Cleanup: delete any XMO's
    if( m_pTargetXMO )       
        m_pTargetXMO->Release();


    if (m_hWmfDecoder) {

        WMFFlushBuffers(m_hWmfDecoder);
        WMFDecodeClose (&m_hWmfDecoder);

    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates, such as checking async xmo status, and
//       updating source file position for our progress bar
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::FrameMove()
{

    WMPERR wmerr;
    m_dwFrameCount++;

    //
    // call graphics routines
    //

    GraphicsFrameMove();
    Sleep((1000/60)/2);

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: TransferData
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::TransferData()
{
    HRESULT        hr=S_OK;
    MEDIA_PACKET_CTX* pSrcCtx = NULL;
    MEDIA_PACKET_CTX* pDstCtx = NULL;

    BOOL bSourcePacketCompleted = TRUE;
    BOOL bTargetPacketCompleted = TRUE;

    do {

        pSrcCtx = NULL;
        pDstCtx = NULL;

        //
        // Always deal with the oldest packet first.  Oldest packets are at the 
        // head, since we insert at the tail, and remove from head
        //
        if( !m_SourcePendingList.IsListEmpty() ) 
        {
            pSrcCtx = (MEDIA_PACKET_CTX*)m_SourcePendingList.pNext; // Head
        }
    
        if( !m_TargetPendingList.IsListEmpty() ) 
        {
            pDstCtx = (MEDIA_PACKET_CTX*)m_TargetPendingList.pNext; // Head
        }        
    
        // Do we have a completed source packet?
        if( pSrcCtx && pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING ) 
        {
            bSourcePacketCompleted = TRUE;
            pSrcCtx->ListEntry.Remove();
    
            // Reset the state of our context
            pSrcCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;
    
            // Pass media buffer to the target xmo.
            AttachPacketToTargetXMO( pSrcCtx );
        } else { 

            bSourcePacketCompleted = FALSE;

        }
    
        // Check if we have a completed packet from the target
        if( pDstCtx && pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING )
        {       
            DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));    
            bTargetPacketCompleted = TRUE;

            // Remove the entry from the list
            pDstCtx->ListEntry.Remove();
    
            ASSERT(pDstCtx->dwCompletedSize != 0);
    
            // The target XMO is done with a buffer.
            pDstCtx->dwCompletedSize = PACKET_SIZE;
            AttachPacketToSourceXMO( pDstCtx );

        } else {

            bTargetPacketCompleted = FALSE;
        }


    } while (bSourcePacketCompleted || bTargetPacketCompleted);

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CFilterGraph xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: AttachPacketToSourceXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       source XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Add this context to our source list
    m_SourcePendingList.Add( &pCtx->ListEntry );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AttachPacketToTargetXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       target XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer         
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the target XMO (first xmo in the chain)
    hr = m_pTargetXMO->Process( &xmb, NULL );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our target list
    m_TargetPendingList.Add( &pCtx->ListEntry );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\imaadpcm.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       imaadpcm.h
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __IMAADPCM_H__
#define __IMAADPCM_H__

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>

#define WAVE_FORMAT_XBOX_ADPCM          0x0069
                                        
#define IMAADPCM_BITS_PER_SAMPLE        4
#define IMAADPCM_HEADER_LENGTH          4
                                        
#define IMAADPCM_MAX_CHANNELS           2
#define IMAADPCM_PCM_BITS_PER_SAMPLE    16

#define NUMELMS(a) (sizeof(a) / sizeof(a[0]))

typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
typedef const IMAADPCMWAVEFORMAT *LPCIMAADPCMWAVEFORMAT;

#ifdef __cplusplus

//
// IMA ADPCM encoder function prototype
//

typedef BOOL (*LPFNIMAADPCMCONVERT)(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

//
// IMA ADPCM CODEC
//

class CImaAdpcmCodec
{
private:
    static const short      m_asNextStep[16];           // Step increment array
    static const short      m_asStep[89];               // Step value array
    IMAADPCMWAVEFORMAT      m_wfxEncode;                // Encoded format description
    BOOL                    m_fEncoder;                 // Is the object acting as an encoder?
    int                     m_nStepIndexL;              // Left-channel stepping index
    int                     m_nStepIndexR;              // Right-channel stepping index
    LPFNIMAADPCMCONVERT     m_pfnConvert;               // Conversion function

public:
    CImaAdpcmCodec(void);
    ~CImaAdpcmCodec(void);

public:
    // Initialization
    BOOL Initialize(LPCIMAADPCMWAVEFORMAT pwfxEncode, BOOL fEncoder);

    // Size conversions
    WORD GetEncodeAlignment(void);
    WORD GetDecodeAlignment(void);
    WORD GetSourceAlignment(void);
    WORD GetDestinationAlignment(void);

    // Data conversions
    BOOL Convert(LPCVOID pvSrc, LPVOID pvDst, UINT cBlocks);
    void Reset(void);

    // Format descriptions
    static void CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPWAVEFORMATEX pwfxFormat);
    static void CreateImaAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, WORD nSamplesPerBlock, LPIMAADPCMWAVEFORMAT pwfxFormat);

    static BOOL IsValidPcmFormat(LPCWAVEFORMATEX pwfxFormat);
    static BOOL IsValidImaAdpcmFormat(LPCIMAADPCMWAVEFORMAT pwfxFormat);

private:
    // En/decoded data alignment
    static WORD CalculateEncodeAlignment(WORD nSamplesPerBlock, WORD nChannels);
    
    // Data conversion functions
    static BOOL EncodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL EncodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL DecodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL DecodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

    static int EncodeSample(int nInputSample, int *nPredictedSample, int nStepSize);
    static int DecodeSample(int nInputSample, int nPredictedSample, int nStepSize);

    static int NextStepIndex(int nEncodedSample, int nStepIndex);
    static BOOL ValidStepIndex(int nStepIndex);
};

__inline WORD CImaAdpcmCodec::GetSourceAlignment(void)
{
    return m_fEncoder ? GetDecodeAlignment() : GetEncodeAlignment();
}

__inline WORD CImaAdpcmCodec::GetDestinationAlignment(void)
{
    return m_fEncoder ? GetEncodeAlignment() : GetDecodeAlignment();
}

__inline int CImaAdpcmCodec::NextStepIndex(int nEncodedSample, int nStepIndex)
{
    nStepIndex += m_asNextStep[nEncodedSample];

    if(nStepIndex < 0)
    {
        nStepIndex = 0;
    }
    else if(nStepIndex >= NUMELMS(m_asStep))
    {
        nStepIndex = NUMELMS(m_asStep) - 1;
    }

    return nStepIndex;
}

__inline BOOL CImaAdpcmCodec::ValidStepIndex(int nStepIndex)
{
    return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));
}

#endif // __cplusplus

#endif // __IMAADPCM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\driver.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       driver.cpp
 *  Content:    XBox ADPCM ACM driver.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *  06/12/01    jharding Adapted for command-line encode
 *
 ****************************************************************************/

#include "imaadpcm.h"
#include "resource.h"
#include "stdio.h"
#include "wavparse.h"

#define XBOX_ADPCM_SAMPLES_PER_BLOCK    64


//-----------------------------------------------------------------------------
// Name: GetSourceInfo
// Desc: Parses source wav file and gets sample data and format information
//-----------------------------------------------------------------------------
HRESULT
GetSourceInfo( const char * szInput, BYTE ** ppbSampleData, DWORD *pdwDuration, DWORD * pdwPadding, WAVEFORMATEX * pwfx )
{
    CWaveFile wfSrc;                // Source file

    *ppbSampleData = NULL;
    *pdwDuration = 0;
    *pdwPadding = 0;
    ZeroMemory( pwfx, sizeof( WAVEFORMATEX ) );

    // Open the source wav file
    if( FAILED( wfSrc.Open( szInput ) ) )
    {
        printf( "Couldn't open %s.\n", szInput );
        return E_FAIL;
    }

    // Get the format and size of the source data
    wfSrc.GetFormat( pwfx, sizeof( WAVEFORMATEX ) );
    wfSrc.GetDuration( pdwDuration );

    // Don't compress 8-bit sounds - the codec can't reliably do it, and
    // it would sound bad, anyway.
    if( pwfx->wBitsPerSample != 16 )
    {
        printf( "You can only compress 16-bit sources - 8 bits would sound bad, anyway.\n" );
        return E_FAIL;
    }

    // See if we need to pad the end to a multiple of 64 samples
    DWORD dwSamples = *pdwDuration / pwfx->nBlockAlign;
    if( dwSamples % 64 )
    {
        printf( "Source is not a multiple of 64 samples.  Padding end with silence.\n" );

        // We need enough memory to pad out to a 64-sample boundary
        *pdwPadding = ( 64 - ( dwSamples % 64 ) ) * pwfx->nBlockAlign;
    }

    // and allocate a buffer for it
    *ppbSampleData = new BYTE[ *pdwDuration + *pdwPadding ];
    if( !*ppbSampleData )
    {
        printf( "Couldn't allocate %d bytes to read sample data.n", *pdwDuration + *pdwPadding );
        return E_FAIL;
    }

    // Read the source data
    wfSrc.ReadSample( 0, *ppbSampleData, *pdwDuration, pdwDuration );
    wfSrc.Close();

    // Fill remainder with silence
    ZeroMemory( *ppbSampleData + *pdwDuration, *pdwPadding );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteCompressedFile
// Desc: Writes out the compressed ADPCM wave file, optionally copying over
//       all RIFF chunks.
//-----------------------------------------------------------------------------
HRESULT
WriteCompressedFile( const char * szInput, 
                     const char * szOutput, 
                     DWORD dwOriginalLength,
                     BYTE * pbEncodedData,
                     DWORD dwNewLength,
                     IMAADPCMWAVEFORMAT * pwfx,
                     BOOL bCopyAllChunks )
{
    HANDLE hSrc;                    // Source file handle
    HANDLE hDest;                   // Destination file handle
    RIFFHEADER rh;                  // RIFF chunk header

    // Open the source file
    hSrc = CreateFile( szInput, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, 0L, NULL );
    if( INVALID_HANDLE_VALUE == hSrc )
    {
        printf( "Couldn't open %s", szInput );
        return E_FAIL;
    }

    // Create the destination file
    hDest = CreateFile( szOutput, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == hDest )
    {
        printf( "Couldn't open output file %s\n", szOutput );
        return E_FAIL;
    }

    //
    // Loop over each chunk in the source file, and write the appropriate data
    // out to the destination file:
    // * For the RIFF chunk, we have to correct the size field of the RIFF
    // header
    // * For the FMT chunk, we have to correct the size, and write out the new
    // wave format structure
    // * For the DATA chunk, we have to correct the size, and write out the 
    // compressed sample data
    // * For all other chunks, we copy verbatim if requested
    //
    for( ; ; )
    {
        BOOL fReadOK;
        DWORD cb;

        // Read the chunk header
        fReadOK = ReadFile( hSrc, &rh, sizeof( RIFFHEADER ), &cb, NULL );
        if( !fReadOK )
        {
            printf( "Error reading from %s.\n", szInput );
            return E_FAIL;
        }

        // Check to see if we hit the end of the file
        if( cb == 0 )
            break;

        switch( rh.fccChunkId )
        {
        case FOURCC_RIFF:
            // Correct the data size to account for compression
            if( bCopyAllChunks )
            {
                // If we're copying everything over, just subtract the
                // compression amount, and account for the difference in
                // wave format structures
                rh.dwDataSize -= ( dwOriginalLength - dwNewLength ) + 
                                 sizeof( WAVEFORMATEX ) - sizeof( IMAADPCMWAVEFORMAT );
            }
            else
            {
                // If we're not copying everything over, then just
                // calculate the new data size
                rh.dwDataSize = 2 * sizeof( RIFFHEADER ) + 
                                sizeof( FOURCC ) + 
                                sizeof( IMAADPCMWAVEFORMAT ) +
                                dwNewLength;
            }

            // Write out the correct RIFF header
            WriteFile( hDest, &rh, sizeof( RIFFHEADER ), &cb, NULL );

            // Copy the form type over
            DWORD dwFormType;
            ReadFile( hSrc, &dwFormType, sizeof( DWORD ), &cb, NULL );
            WriteFile( hDest, &dwFormType, sizeof( DWORD ), &cb, NULL );

            break;
        case FOURCC_FORMAT:
            // Skip past the original format
            SetFilePointer( hSrc, rh.dwDataSize, NULL, FILE_CURRENT );

            // Correct the data size for the format struct
            rh.dwDataSize = sizeof( IMAADPCMWAVEFORMAT );

            // Write out the correct FMT header
            WriteFile( hDest, &rh, sizeof( RIFFHEADER ), &cb, NULL );

            // Write out the new format struct
            WriteFile( hDest, pwfx, sizeof( IMAADPCMWAVEFORMAT ), &cb, NULL );

            break;
        case FOURCC_DATA:
            // Skip past the original data
            SetFilePointer( hSrc, rh.dwDataSize, NULL, FILE_CURRENT );

            // Correct the data size for compressed sample data
            rh.dwDataSize = dwNewLength;

            // Write out the correct DATA header
            WriteFile( hDest, &rh, sizeof( RIFFHEADER ), &cb, NULL );

            // Write out the compressed sample data
            WriteFile( hDest, pbEncodedData, dwNewLength, &cb, NULL );

            break;
        default:
            if( bCopyAllChunks )
            {
                // Allocate a block of memory for the chunk data
                BYTE * pbChunkData = new BYTE[ rh.dwDataSize ];
                if( !pbChunkData )
                {
                    printf( "Couldn't allocate enough memory to copy data.\n" );
                    return E_FAIL;
                }

                // Copy the chunk header over
                WriteFile( hDest, &rh, sizeof( RIFFHEADER ), &cb, NULL );

                // Copy the chunk data over
                ReadFile( hSrc, pbChunkData, rh.dwDataSize, &cb, NULL );
                WriteFile( hDest, pbChunkData, rh.dwDataSize, &cb, NULL );

                // Release the memory
                delete[] pbChunkData;
            }
            else
            {
                // Seek to the next chunk
                SetFilePointer( hSrc, rh.dwDataSize, NULL, FILE_CURRENT );
            }

            break;
        }
    }

    // Clean up
    CloseHandle( hSrc );
    CloseHandle( hDest );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: main
// Desc: Main control of program.  Parses arguments and converts wav file
//-----------------------------------------------------------------------------
void
main( int argc, char * argv[])
{
    const char * szInput = NULL;    // Source file name
    const char * szOutput = NULL;   // Destination file name
    DWORD dwDuration;               // Original length
    DWORD dwPadding;                // Additional padding at end
    BYTE * pbSampleData = NULL;     // Source data
    BYTE * pbEncodedData = NULL;    // Compressed data
    WAVEFORMATEX wfx;               // Source format
    IMAADPCMWAVEFORMAT wfxEncode;   // Destination format
    CImaAdpcmCodec codec;           // Codec
    BOOL bCopyAllChunks = FALSE;    // TRUE to copy all chunks to encoded file

    // Parse arguments
    for( int i = 1; i < argc; i++ )
    {
        const char * szArg = argv[i];

        // Check for options
        if( szArg[0] == '-' || szArg[0] == '/' )
        {
            switch( szArg[1] )
            {
            case 'c':
            case 'C':
                bCopyAllChunks = TRUE;
                break;
            default:
                printf( "Unrecognized option %c%c.\n", szArg[0], szArg[1] );
                return;
            }
        }
        else if( !szInput )
            szInput = szArg;
        else if( !szOutput )
            szOutput = szArg;
    }

    // Check to make sure we had valid arguments
    if( !szInput || !szOutput )
    {
        printf( "Usage: xbadpcmencode Input.wav Output.wav [options]\n" );
        printf( "Options:\n\t/C\tCopy all chunks to encoded file.\n" );
        return;
    }

    printf( "Converting %s to %s...\n", szInput, szOutput );

    // Get the source data and wave format
    if( FAILED( GetSourceInfo( szInput, &pbSampleData, &dwDuration, &dwPadding, &wfx ) ) )
        return;

    if( wfx.wFormatTag != WAVE_FORMAT_PCM ||
        wfx.nChannels > 2 )
    {
        printf( "Invalid source format.\nSource must be mono or stereo 8- or 16-bit PCM.\n" );
        return;
    }

    // Create an APDCM format structure based off the source format
    codec.CreateImaAdpcmFormat( wfx.nChannels, wfx.nSamplesPerSec, XBOX_ADPCM_SAMPLES_PER_BLOCK, &wfxEncode );

    // Calculate number of ADPCM blocks and length of ADPCM data
    DWORD dwDestBlocks  = ( dwDuration + dwPadding ) / wfx.nBlockAlign / XBOX_ADPCM_SAMPLES_PER_BLOCK;
    DWORD dwDestLength  = dwDestBlocks * wfxEncode.wfx.nBlockAlign;

    // Allocate a buffer for encoded data
    pbEncodedData = new BYTE[ dwDestLength ];

    // Initialize the codec
    if( FALSE == codec.Initialize( &wfxEncode, TRUE ) )
    {
        printf( "Couldn't initialize codec.\n" );
        return;
    }

    // Convert the data
    if( FALSE == codec.Convert( pbSampleData, pbEncodedData, dwDestBlocks ) )
    {
        printf( "Codec failed.\n" );
        return;
    }

    // Write out the encoded file
    WriteCompressedFile( szInput, 
                         szOutput, 
                         dwDuration, 
                         pbEncodedData, 
                         dwDestLength, 
                         &wfxEncode, 
                         bCopyAllChunks );

    // Clean up
    delete[] pbSampleData;
    delete[] pbEncodedData;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\wmvplayback\projectedtexture.cpp ===
//-----------------------------------------------------------------------------
// File: ProjectedTexture.cpp
//
// Desc: Sample to show off projected textures
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <xgraphics.h>
#include "wmvplay.h"


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, _T("Rotate\ncube") },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, _T("Move projection\npoint") },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, _T("Show\nfrustrum") },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, _T("Display help") },
    { XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_2, _T("Also: Left trigger w/right stick\nmoves the projection focus") },
};


//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::InitGraphics()
{
    m_bDrawHelp         = FALSE;

    m_pSpotLightTexture = NULL;

    m_vTexEyePt    = D3DXVECTOR3(-2.0f, -2.0f, -7.0f );
    m_vTexLookatPt = D3DXVECTOR3( 0.0f,  0.0f,  0.0f );

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the view matrix
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-15.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXMATRIX  matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &D3DXVECTOR3(0.0f,1.0f,0.0f) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set up a point light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_POINT, 0.0f, 0.0f, -10.0f );
    light.Attenuation0 = 0.0f;
    light.Attenuation1 = 0.0f;
    light.Attenuation2 = 1.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00333333 );

    // Set a default white material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Create the texture for our procedural spotlight texmap
    CreateSpotLightTexture();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CreateSpotLightTexture()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::CreateSpotLightTexture( )
{
    // Release the old texture
    SAFE_RELEASE( m_pSpotLightTexture );

    // Create a new texture
    m_pd3dDevice->CreateTexture( m_VidStrm.u32Width, m_VidStrm.u32Height, 1, 0, D3DFMT_LIN_X8R8G8B8, 
                                 D3DPOOL_DEFAULT, &m_pSpotLightTexture );

    D3DLOCKED_RECT lock;
    m_pSpotLightTexture->LockRect( 0, &lock, NULL, 0L );

    D3DSURFACE_DESC desc;
    m_pSpotLightTexture->GetLevelDesc( 0, &desc );
    DWORD* pBits    = (DWORD*)lock.pBits;

    //
    // the WMV video decoder will ask for a buffer to dump data on.
    // pass it this buffer..
    //

    m_pVidBuf = (PUCHAR)pBits;

    m_pSpotLightTexture->UnlockRect(0);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ShowTexture()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFilterGraph::ShowTexture( LPDIRECT3DTEXTURE8 pTexture )
{
    D3DSURFACE_DESC d3dsd;
    pTexture->GetLevelDesc( 0, &d3dsd );
    FLOAT x1 = 0.0f, x2 = x1 + (FLOAT)d3dsd.Width;
    FLOAT y1 = 0.0f, y2 = y1 + (FLOAT)d3dsd.Height;

    struct SPRITEVERTEX
    {
        FLOAT sx, sy, sz, rhw;
        FLOAT tu, tv;
    };
    
    SPRITEVERTEX vSprite[4] =
    {
        { x1-0.5f, y1-0.5f, 0.99f, 1.0f, 0.0f,               (FLOAT)d3dsd.Height },
        { x2-0.5f, y1-0.5f, 0.99f, 1.0f, (FLOAT)d3dsd.Width, (FLOAT)d3dsd.Height },
        { x2-0.5f, y2-0.5f, 0.99f, 1.0f, (FLOAT)d3dsd.Width, 0.0f                },
        { x1-0.5f, y2-0.5f, 0.99f, 1.0f, 0.0f,               0.0f                },
    };

    // Set state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,  D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,    D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,    D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

    // Display the sprite
    m_pd3dDevice->SetTexture( 0, pTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 4, vSprite, sizeof(vSprite[0]) );
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::GraphicsFrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle drawing of the projection frustum
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        CreateSpotLightTexture();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::Render()
{
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );

    //
    // show wmv generated image
    //

    ShowTexture( m_pSpotLightTexture );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xmoclient\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\imaadpcm.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       imaadpcm.cpp
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *  06/12/01    jharding Adapted for command-line encode
 *
 ****************************************************************************/

#include "imaadpcm.h"
#include "wavparse.h"

/****************************************************************************
 *
 *  CImaAdpcmCodec
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

//
// This array is used by NextStepIndex to determine the next step index to use.  
// The step index is an index to the m_asStep[] array, below.
//

const short CImaAdpcmCodec::m_asNextStep[16] =
{
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8
};

//
// This array contains the array of step sizes used to encode the ADPCM
// samples.  The step index in each ADPCM block is an index to this array.
//

const short CImaAdpcmCodec::m_asStep[89] =
{
        7,     8,     9,    10,    11,    12,    13,
       14,    16,    17,    19,    21,    23,    25,
       28,    31,    34,    37,    41,    45,    50,
       55,    60,    66,    73,    80,    88,    97,
      107,   118,   130,   143,   157,   173,   190,
      209,   230,   253,   279,   307,   337,   371,
      408,   449,   494,   544,   598,   658,   724,
      796,   876,   963,  1060,  1166,  1282,  1411,
     1552,  1707,  1878,  2066,  2272,  2499,  2749,
     3024,  3327,  3660,  4026,  4428,  4871,  5358,
     5894,  6484,  7132,  7845,  8630,  9493, 10442,
    11487, 12635, 13899, 15289, 16818, 18500, 20350,
    22385, 24623, 27086, 29794, 32767
};

CImaAdpcmCodec::CImaAdpcmCodec
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CImaAdpcmCodec
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CImaAdpcmCodec::~CImaAdpcmCodec
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: encoded data format.
 *      BOOL [in]: TRUE to initialize the object as an encoder.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::Initialize
(
    LPCIMAADPCMWAVEFORMAT               pwfxEncode, 
    BOOL                                fEncoder
)
{
    static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
    { 
        {
            DecodeM16,
            DecodeS16 
        },
        {
            EncodeM16,
            EncodeS16 
        }
    };
    
    if(!IsValidImaAdpcmFormat(pwfxEncode))
    {
        return FALSE;
    }

    //
    // Save the format data
    //

    m_wfxEncode = *pwfxEncode;
    m_fEncoder = !!fEncoder;

    //
    // Set up the conversion function
    //

    m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

    //
    // Initialize the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data from the source to destination format.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      LPVOID [out]: destination buffer.
 *      UINT [in]: block count.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::Convert
(
    LPCVOID                 pvSrc,
    LPVOID                  pvDst,
    UINT                    cBlocks
)
{
    return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets the conversion operation.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::Reset
(
    void
)
{
    //
    // Reset the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;
}


/****************************************************************************
 *
 *  GetEncodeAlignment
 *
 *  Description:
 *      Gets the alignment of an encoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::GetEncodeAlignment
(
    void
)
{
    return m_wfxEncode.wfx.nBlockAlign;
}


/****************************************************************************
 *
 *  GetDecodeAlignment
 *
 *  Description:
 *      Gets the alignment of a decoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::GetDecodeAlignment
(
    void
)
{
    return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;
}


/****************************************************************************
 *
 *  CalculateEncodeAlignment
 *
 *  Description:
 *      Calculates an encoded data block alignment based on a PCM sample
 *      count and an alignment multiplier.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      WORD [in]: PCM samples per block.
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::CalculateEncodeAlignment
(
    WORD                    nChannels,
    WORD                    nSamplesPerBlock
)
{
    const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;
    const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = nSamplesPerBlock - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    return nBlockAlign;
}


/****************************************************************************
 *
 *  CreatePcmFormat
 *
 *  Description:
 *      Creates a PCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::CreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPWAVEFORMATEX          pwfx
)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = nChannels;
    pwfx->nSamplesPerSec = nSamplesPerSec;
    pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;
    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
    pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;
}


/****************************************************************************
 *
 *  CreateImaAdpcmFormat
 *
 *  Description:
 *      Creates an IMA ADPCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPIMAADPCMWAVEFORMAT [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::CreateImaAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    nSamplesPerBlock,
    LPIMAADPCMWAVEFORMAT    pwfx
)
{
    pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;
    pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = nSamplesPerBlock;
}


/****************************************************************************
 *
 *  IsValidPcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL 
CImaAdpcmCodec::IsValidPcmFormat
(
    LPCWAVEFORMATEX         pwfx
)
{
    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        return FALSE;
    }
    
    if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))
    {
        return FALSE;
    }

    if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
    {
        return FALSE;
    }

    if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)
    {
        return FALSE;
    }

    if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  IsValidXboxAdpcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL 
CImaAdpcmCodec::IsValidImaAdpcmFormat
(
    LPCIMAADPCMWAVEFORMAT   pwfx
)
{
    if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)
    {
        return FALSE;
    }

    if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)
    {
        return FALSE;
    }
    
    if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))
    {
        return FALSE;
    }

    if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)
    {
        return FALSE;
    }

    if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  EncodeSample
 *
 *  Description:
 *      Encodes a sample.
 *
 *  Arguments:
 *      int [in]: the sample to be encoded.
 *      LPINT [in/out]: the predicted value of the sample.
 *      int [in]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      int: the encoded ADPCM sample.
 *
 ****************************************************************************/

int
CImaAdpcmCodec::EncodeSample
(
    int                 nInputSample,
    LPINT               pnPredictedSample,
    int                 nStepSize
)
{
    int                 nPredictedSample;
    LONG                lDifference;
    int                 nEncodedSample;
    
    nPredictedSample = *pnPredictedSample;

    lDifference = nInputSample - nPredictedSample;
    nEncodedSample = 0;

    if(lDifference < 0) 
    {
        nEncodedSample = 8;
        lDifference = -lDifference;
    }

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 4;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 2;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 1;
        lDifference -= nStepSize;
    }

    if(nEncodedSample & 8)
    {
        nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);
    }
    else
    {
        nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);
    }

    if(nPredictedSample > 32767)
    {
        nPredictedSample = 32767;
    }
    else if(nPredictedSample < -32768)
    {
        nPredictedSample = -32768;
    }

    *pnPredictedSample = nPredictedSample;
    
    return nEncodedSample;
}


/****************************************************************************
 *
 *  DecodeSample
 *
 *  Description:
 *      Decodes an encoded sample.
 *
 *  Arguments:
 *      int [in]: the sample to be decoded.
 *      int [in]: the predicted value of the sample.
 *      int [i]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      int: the decoded PCM sample.
 *
 ****************************************************************************/

int
CImaAdpcmCodec::DecodeSample
(
    int                 nEncodedSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG                lDifference;
    LONG                lNewSample;

    lDifference = nStepSize >> 3;

    if(nEncodedSample & 4) 
    {
        lDifference += nStepSize;
    }

    if(nEncodedSample & 2) 
    {
        lDifference += nStepSize >> 1;
    }

    if(nEncodedSample & 1) 
    {
        lDifference += nStepSize >> 2;
    }

    if(nEncodedSample & 8)
    {
        lDifference = -lDifference;
    }

    lNewSample = nPredictedSample + lDifference;

    if((LONG)(short)lNewSample != lNewSample)
    {
        if(lNewSample < -32768)
        {
            lNewSample = -32768;
        }
        else
        {
            lNewSample = 32767;
        }
    }

    return (int)lNewSample;
}


/****************************************************************************
 *
 *  Conversion Routines
 *
 *  Description:
 *      Converts a PCM buffer to ADPCM, or the reverse.
 *
 *  Arguments:
 *      LPBYTE [in]: source buffer.
 *      LPBYTE [out]: destination buffer.
 *      UINT [in]: block count.
 *      UINT [in]: block alignment of the ADPCM data, in bytes.
 *      UINT [in]: the number of samples in each ADPCM block (not used in
 *                 decoding).
 *      LPINT [in/out]: left-channel stepping index.
 *      LPINT [in/out]: right-channel stepping index.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::EncodeM16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    int                     nSample;
    int                     nStepSize;
    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;

    //
    // Save a local copy of the step index so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndex = *pnStepIndexL;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // Block header
        //

        nPredSample = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk (which consists of a bunch of encoded nibbles).  Note
        // that if we don't have enough data to fill a complete byte, then
        // we add a 0 nibble on the end.
        //

        while(cSamples)
        {
            //
            // Sample 1
            //

            nSample = *(short *)pbSrc;
            pbSrc += sizeof(short);
            cSamples--;

            nStepSize = m_asStep[nStepIndex];
            nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

            //
            // Sample 2
            //

            if(cSamples)
            {
                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);
                cSamples--;

                nStepSize = m_asStep[nStepIndex];
                nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample2, nStepIndex);
            }
            else
            {
                nEncSample2 = 0;
            }

            //
            // Write out encoded byte.
            //

            *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //

    *pnStepIndexL = nStepIndex;

    return TRUE;
}


BOOL
CImaAdpcmCodec::EncodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;
    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;
    UINT                    i;

    //
    // Save a local copy of the step indeces so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndexL = *pnStepIndexL;
    nStepIndexR = *pnStepIndexR;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel block header
        //

        nPredSampleL = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);
        pbBlock += sizeof(LONG);

        //
        // RIGHT channel block header
        //

        nPredSampleR = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk.  This consists of 8 left samples (one DWORD of output)
        // followed by 8 right samples (also one DWORD).  Since the input
        // samples are interleaved, we create the left and right DWORDs
        // sample by sample, and then write them both out.
        //

        while(cSamples)
        {
            dwLeft = 0;
            dwRight = 0;

            cSubSamples = min(cSamples, 8);

            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);

                nStepSize = m_asStep[nStepIndexL];
                
                nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft |= (DWORD)nEncSampleL << (4 * i);

                //
                // RIGHT channel
                //

                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);

                nStepSize = m_asStep[nStepIndexR];
                
                nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);
                dwRight |= (DWORD)nEncSampleR << (4 * i);
            }

            //
            // Write out encoded DWORDs.
            //

            *(LPDWORD)pbBlock = dwLeft;
            pbBlock += sizeof(DWORD);

            *(LPDWORD)pbBlock = dwRight;
            pbBlock += sizeof(DWORD);

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //
    
    *pnStepIndexL = nStepIndexL;
    *pnStepIndexR = nStepIndexR;

    return TRUE;

}


BOOL
CImaAdpcmCodec::DecodeM16   
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    BYTE                    bSample;
    int                     nStepSize;
    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;
    DWORD                   dwHeader;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;
        
        //
        // Block header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);

        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndex))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }
        
        //
        // Write out first sample
        //

        *(short *)pbDst = (short)nPredSample;
        pbDst += sizeof(short);

        //
        // Enter the block loop
        //

        while(cSamples)
        {
            bSample = *pbBlock++;

            //
            // Sample 1
            //

            nEncSample = (bSample & (BYTE)0x0F);
            nStepSize = m_asStep[nStepIndex];
            nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample, nStepIndex);

            *(short *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);

            cSamples--;

            //
            // Sample 2
            //

            if(cSamples)
            {
                nEncSample = (bSample >> 4);
                nStepSize = m_asStep[nStepIndex];
                nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample, nStepIndex);

                *(short *)pbDst = (short)nPredSample;
                pbDst += sizeof(short);

                cSamples--;
            }
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    return fSuccess;
}


BOOL
CImaAdpcmCodec::DecodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;
    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;
    UINT                    i;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexL)) 
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }
        
        //
        // RIGHT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexR))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }

        //
        // Write out first sample
        //

        *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
        pbDst += sizeof(DWORD);

        //
        // The first DWORD contains 4 left samples, the second DWORD
        // contains 4 right samples.  We process the source in 8-byte
        // chunks to make it easy to interleave the output correctly.
        //

        while(cSamples)
        {
            dwLeft = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);
            dwRight = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);

            cSubSamples = min(cSamples, 8);
            
            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nEncSampleL = (dwLeft & 0x0F);
                nStepSize = m_asStep[nStepIndexL];
                nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

                //
                // RIGHT channel
                //

                nEncSampleR = (dwRight & 0x0F);
                nStepSize = m_asStep[nStepIndexR];
                nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

                //
                // Write out sample
                //

                *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
                pbDst += sizeof(DWORD);

                //
                // Shift the next input sample into the low-order 4 bits.
                //

                dwLeft >>= 4;
                dwRight >>= 4;
            }

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\resource.h ===
#define IDS_ACM_DRIVER_SHORTNAME    1
#define IDS_ACM_DRIVER_LONGNAME     2
#define IDS_ACM_DRIVER_COPYRIGHT    3
#define IDS_ACM_DRIVER_LICENSING    4
#define IDS_ACM_DRIVER_FEATURES     5
#define IDS_ACM_DRIVER_TAG_NAME     6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\wavparse.h ===
//-----------------------------------------------------------------------------
// File: wvaparse.h
//
// Desc: Helper class for reading and writing a .wav file 
//
// Hist: 6.12.01 - adapated from xbsound.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOUND_H
#define XBSOUND_H

#include "windows.h"
#include <mmsystem.h>

//-----------------------------------------------------------------------------
// FourCC definitions
//-----------------------------------------------------------------------------
const DWORD FOURCC_WAVE   = 'EVAW';
const DWORD FOURCC_FORMAT = ' tmf';
const DWORD FOURCC_DATA   = 'atad';

//-----------------------------------------------------------------------------
// Name: RIFFHEADER
// Desc: For parsing WAV files
//-----------------------------------------------------------------------------
struct RIFFHEADER
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
};

#define RIFFCHUNK_FLAGS_VALID   0x00000001


//-----------------------------------------------------------------------------
// Name: class CRiffChunk
// Desc: RIFF chunk utility class
//-----------------------------------------------------------------------------
class CRiffChunk
{
    FOURCC            m_fccChunkId;       // Chunk identifier
    const CRiffChunk* m_pParentChunk;     // Parent chunk
    HANDLE            m_hFile;
    DWORD             m_dwDataOffset;     // Chunk data offset
    DWORD             m_dwDataSize;       // Chunk data size
    DWORD             m_dwFlags;          // Chunk flags

public:
    CRiffChunk();

    // Initialization
    VOID    Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk,
                        HANDLE hFile );
    HRESULT Open();
    BOOL    IsValid()     { return !!(m_dwFlags & RIFFCHUNK_FLAGS_VALID); }

    // Data
    HRESULT ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize );

    // Chunk information
    FOURCC  GetChunkId()  { return m_fccChunkId; }
    DWORD   GetDataSize() { return m_dwDataSize; }
};




//-----------------------------------------------------------------------------
// Name: class CWaveFile
// Desc: Wave file utility class
//-----------------------------------------------------------------------------
class CWaveFile
{
    HANDLE      m_hFile;            // File handle
    CRiffChunk  m_RiffChunk;        // RIFF chunk
    CRiffChunk  m_FormatChunk;      // Format chunk
    CRiffChunk  m_DataChunk;        // Data chunk

public:
    CWaveFile();
    ~CWaveFile();

    // Initialization
    HRESULT Open( const CHAR* strFileName );
    VOID    Close();

    // File format
    HRESULT GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize );

    // File data
    HRESULT ReadSample( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize, 
                        DWORD* pdwRead );

    // File properties
    VOID    GetDuration( DWORD* pdwDuration ) { *pdwDuration = m_DataChunk.GetDataSize(); }
};




#endif // XBSOUND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xmoclient\xmosamplerateconverter.cpp ===
//-----------------------------------------------------------------------------
// Name: XMOSampleRateConverter.cpp
//
// Desc: Sample rate converter interface. This is an example of deriving the
//       base XMediaObject into a custom interface.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XMOSampleRateConverter.h"




//-----------------------------------------------------------------------------
// Name: CSampleRateConverter()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CSampleRateConverter::CSampleRateConverter( DWORD dwChannelCount, DWORD dwSourceFrequency, 
                                            DWORD dwDestinationFrequency )
{
    // Initialize members
    m_dwChannelCount         = dwChannelCount;
    m_dwSourceFrequency      = dwSourceFrequency;
    m_dwDestinationFrequency = dwDestinationFrequency;
    m_dwIndex                = 0L;
    m_ulRefCount             = 1L;

    // Calculate the input and output alignment.  Because we may produce or
    // consume more than one sample at a time (i.e. up- or downsampling),  we
    // need to calculate worst-case alignment.
    if( m_dwSourceFrequency < m_dwDestinationFrequency )
    {
        m_dwSourceAlignment      = ( m_dwDestinationFrequency + m_dwSourceFrequency - 1 ) / m_dwSourceFrequency;
        m_dwDestinationAlignment = 1;
    }
    else if( m_dwSourceFrequency > m_dwDestinationFrequency )
    {
        m_dwSourceAlignment      = 1;
        m_dwDestinationAlignment = ( m_dwSourceFrequency + m_dwDestinationFrequency - 1 ) / m_dwDestinationFrequency;
    }
    else
    {
        m_dwSourceAlignment      = 1;
        m_dwDestinationAlignment = 1;
    }
}




//-----------------------------------------------------------------------------
// Name: AddRef()
// Desc: Increments the object's reference count.
//-----------------------------------------------------------------------------
ULONG CSampleRateConverter::AddRef()
{
    return ++m_ulRefCount;
}




//-----------------------------------------------------------------------------
// Name: Release()
// Desc: Decrements the object's reference count.
//-----------------------------------------------------------------------------
ULONG CSampleRateConverter::Release()
{
    if( !--m_ulRefCount )
    {
        delete this;
        return 0;
    }

    return m_ulRefCount;
}




//-----------------------------------------------------------------------------
// Name: GetInfo()
// Desc: Gets information about the data the XMO supports.
//-----------------------------------------------------------------------------
HRESULT CSampleRateConverter::GetInfo( XMEDIAINFO* pXMI )
{
    // Flags are easy.  We only support complete samples, but other than
    // that, we don't do much.
    pXMI->dwFlags = XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE;

    // Our input alignment is the minumum number of samples we require to
    // produce a single output sample.  We store our alignement in terms
    // of samples, but we need to return it in terms of bytes.  We only
    // work with 16-bit data, so converting samples to bytes is as simple
    // as multiplying by the channel count times 2 (16-bit samples == 2 bytes 
    // per sample).
    pXMI->dwInputSize = m_dwSourceAlignment * m_dwChannelCount * 2;

    // Output alignment is maximum number of samples we will every produce
    // when given a single input sample.
    pXMI->dwOutputSize = m_dwDestinationAlignment * m_dwChannelCount * 2;

    // We're a synchronous XMO, so MaxLookahead doesn't apply to us.  
    // Normally, this would be our "low watermark" value; i.e. the minimum
    // amount of data that must be queued at any given time in order to
    // prevent starvation.
    pXMI->dwMaxLookahead = 0;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetStatus()
// Desc: Gets the current status of the XMO.
//-----------------------------------------------------------------------------
HRESULT CSampleRateConverter::GetStatus( DWORD* pdwStatus )
{
    // We're a synchronous XMO, so we're always ready for more data.
    (*pdwStatus) = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Processes data.
//-----------------------------------------------------------------------------
HRESULT CSampleRateConverter::Process( const XMEDIAPACKET* pSourceXMP,
                                       const XMEDIAPACKET* pDestinationXMP )
{
    // Save pointers to the data buffers
    SHORT* pSourceBuffer      = (SHORT*)pSourceXMP->pvBuffer;
    SHORT* pDestinationBuffer = (SHORT*)pDestinationXMP->pvBuffer;
    
    // Convert packet sizes from bytes to samples
    DWORD dwSourceSampleCount      = pSourceXMP->dwMaxSize / m_dwChannelCount / 2;
    DWORD dwDestinationSampleCount = pDestinationXMP->dwMaxSize / m_dwChannelCount / 2;

    // Enter the main loop
    while( ( dwSourceSampleCount >= m_dwSourceAlignment ) && 
           ( dwDestinationSampleCount >= m_dwDestinationAlignment ) )
    {
        // Calculate the number of source samples we'll be using in this
        // iteration.  If we're upsampling, we may produce more than one
        // output sample.  If we're downsampling, we may require more than
        // one input sample.  Because we keep a running SRC index, we'll
        // only produce or consume as many samples as we really need in order
        // to keep the sampling rate accurate.
        DWORD dwWorkingSourceSampleCount      = 1;
        DWORD dwWorkingDestinationSampleCount = 1;

        if( m_dwSourceFrequency < m_dwDestinationFrequency )
        {
            m_dwIndex += m_dwDestinationFrequency;
        
            dwWorkingDestinationSampleCount = m_dwIndex / m_dwSourceFrequency;

            if( dwWorkingDestinationSampleCount > dwDestinationSampleCount )
                dwWorkingDestinationSampleCount = dwDestinationSampleCount;

            m_dwIndex -= dwWorkingDestinationSampleCount * m_dwSourceFrequency;
        }
        else if( m_dwSourceFrequency > m_dwDestinationFrequency )
        {
            m_dwIndex += m_dwSourceFrequency;
        
            dwWorkingSourceSampleCount = m_dwIndex / m_dwDestinationFrequency;

            if( dwWorkingSourceSampleCount > dwSourceSampleCount )
                dwWorkingSourceSampleCount = dwSourceSampleCount;

            m_dwIndex -= dwWorkingSourceSampleCount * m_dwDestinationFrequency;
        }

        // Copy samples. Because we only consume multiple source samples
        // during a downsample operation, the loop below only references
        // the working destination sample count. Well, that and the channel
        // count, but you knew that.
        for( DWORD i = 0; i < dwWorkingDestinationSampleCount; i++ )
        {
            for( DWORD j = 0; j < m_dwChannelCount; j++ )
            {
                pDestinationBuffer[(m_dwChannelCount*i) + j] = pSourceBuffer[j];
            }
        }

        // Increment pointers and decrement sizes
        pSourceBuffer            += dwWorkingSourceSampleCount * m_dwChannelCount;
        dwSourceSampleCount      -= dwWorkingSourceSampleCount;

        pDestinationBuffer       += dwWorkingDestinationSampleCount * m_dwChannelCount;
        dwDestinationSampleCount -= dwWorkingDestinationSampleCount;
    }

    // Update the output parameters of the packet descriptions.
    if( pSourceXMP->pdwCompletedSize )
        (*pSourceXMP->pdwCompletedSize) = (BYTE*)pSourceBuffer - (BYTE*)pSourceXMP->pvBuffer;

    if( pSourceXMP->pdwStatus )
        (*pSourceXMP->pdwStatus) = XMEDIAPACKET_STATUS_SUCCESS;

    if( pSourceXMP->hCompletionEvent )
        SetEvent( pSourceXMP->hCompletionEvent );

    if( pDestinationXMP->pdwCompletedSize )
        (*pDestinationXMP->pdwCompletedSize) = (BYTE*)pDestinationBuffer - (BYTE*)pDestinationXMP->pvBuffer;

    if( pDestinationXMP->pdwStatus )
        (*pDestinationXMP->pdwStatus) = XMEDIAPACKET_STATUS_SUCCESS;

    if( pDestinationXMP->hCompletionEvent )
        SetEvent( pDestinationXMP->hCompletionEvent );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Discontinuity()
// Desc: Signals a discontinuity in the stream.
//-----------------------------------------------------------------------------
HRESULT CSampleRateConverter::Discontinuity()
{
    // Discontinuity doesn't mean anything to a synchronous XMO.  If we were
    // asynchronous, it would signal that no more source data is available
    // and all remaining destination packets should be completed.
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Flush()
// Desc: Resets the stream to it's default state.
//-----------------------------------------------------------------------------
HRESULT CSampleRateConverter::Flush()
{
    // We'll just reset the sample rate converter index
    m_dwIndex = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xbadpcmencode\wavparse.cpp ===
//-----------------------------------------------------------------------------
// File: wvaparse.cpp
//
// Desc: Helper class for reading and writing a .wav file 
//
// Hist: 6.12.01 - adapated from xbsound.cpp
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "wavparse.h"




//-----------------------------------------------------------------------------
// Name: CRiffChunk()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CRiffChunk::CRiffChunk()
{
    // Initialize defaults
    m_fccChunkId   = 0;
    m_pParentChunk = NULL;
    m_hFile        = INVALID_HANDLE_VALUE;
    m_dwDataOffset = 0;
    m_dwDataSize   = 0;
    m_dwFlags      = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the object
//-----------------------------------------------------------------------------
VOID CRiffChunk::Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk, 
                             HANDLE hFile )
{
    m_fccChunkId   = fccChunkId;
    m_pParentChunk = pParentChunk;
    m_hFile        = hFile;
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Opens an existing chunk.
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::Open()
{
    RIFFHEADER rhRiffHeader;
    LONG       lOffset = 0;

    // Seek to the first byte of the parent chunk's data section
    if( m_pParentChunk )
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        // Special case the RIFF chunk
        if( FOURCC_RIFF == m_pParentChunk->m_fccChunkId )
            lOffset += sizeof(FOURCC);
    }
    
    // Read each child chunk header until we find the one we're looking for
    for( ;; )
    {
        if( 0xFFFFFFFF == SetFilePointer( m_hFile, lOffset, NULL, FILE_BEGIN ) )
        {
            // Although 0xfffffff is the return code in case of an error, it
            // also could be a valid file offset. Let's find out.
            if( NO_ERROR != GetLastError() )
                return HRESULT_FROM_WIN32( GetLastError() );
        }

        DWORD dwRead;
        if( 0 == ReadFile( m_hFile, &rhRiffHeader, sizeof(rhRiffHeader), &dwRead, NULL ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        // Check if we found the one we're looking for
        if( m_fccChunkId == rhRiffHeader.fccChunkId )
        {
            // Save the chunk size and data offset
            m_dwDataOffset = lOffset + sizeof(rhRiffHeader);
            m_dwDataSize   = rhRiffHeader.dwDataSize;

            // Success
            m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

            return S_OK;
        }

        lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;
    }
}





//-----------------------------------------------------------------------------
// Name: Read()
// Desc: Reads from the file
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize )
{
    // Seek to the offset
    DWORD dwPosition = SetFilePointer( m_hFile, m_dwDataOffset+lOffset, NULL, FILE_BEGIN );

    if( 0xFFFFFFFF == dwPosition )
    {
        // Although 0xfffffff is the return code in case of an error, it
        // also could be a valid file offset. Let's find out.
        if( NO_ERROR != GetLastError() )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    // Read from the file
    DWORD dwRead;
    if( 0 == ReadFile( m_hFile, pData, dwDataSize, &dwRead, NULL ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_hFile = INVALID_HANDLE_VALUE;
}




//-----------------------------------------------------------------------------
// Name: ~CWaveFile()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Initializes the object.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( const CHAR* strFileName )
{
    // If we're already open, close
    Close();
    
    // Open the file
    m_hFile = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, 0L, NULL );
    if( INVALID_HANDLE_VALUE == m_hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Initialize the chunk objects
    m_RiffChunk.Initialize( FOURCC_RIFF, NULL, m_hFile );
    m_FormatChunk.Initialize( FOURCC_FORMAT, &m_RiffChunk, m_hFile );
    m_DataChunk.Initialize( FOURCC_DATA, &m_RiffChunk, m_hFile );

    HRESULT hr = m_RiffChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_FormatChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_DataChunk.Open();
    if( FAILED(hr) )
        return hr;

    // Validate the file type
    FOURCC fccType;
    hr = m_RiffChunk.ReadData( 0, &fccType, sizeof(fccType) );
    if( FAILED(hr) )
        return hr;

    if( FOURCC_WAVE != fccType )
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetFormat()
// Desc: Gets the wave file format
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize )
{
    DWORD dwValidSize = m_FormatChunk.GetDataSize();

    if( NULL == pwfxFormat || 0 == dwFormatSize )
        return E_INVALIDARG;

    // Read the format chunk into the buffer
    HRESULT hr = m_FormatChunk.ReadData( 0, pwfxFormat, min(dwFormatSize, dwValidSize) );
    if( FAILED(hr) )
        return hr;

    // Zero out remaining bytes, in case enough bytes were not read
    if( dwFormatSize > dwValidSize )
        ZeroMemory( (BYTE*)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSample()
// Desc: Reads data from the audio file.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadSample( DWORD dwPosition, VOID* pBuffer, 
                               DWORD dwBufferSize, DWORD* pdwRead )
{                                   
    // Don't read past the end of the data chunk
    DWORD dwDuration;
    GetDuration( &dwDuration );

    if( dwPosition + dwBufferSize > dwDuration )
        dwBufferSize = dwDuration - dwPosition;

    HRESULT hr = S_OK;
    if( dwBufferSize )
        hr = m_DataChunk.ReadData( (LONG)dwPosition, pBuffer, dwBufferSize );

    if( pdwRead )
        *pdwRead = dwBufferSize;

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Closes the object
//-----------------------------------------------------------------------------
VOID CWaveFile::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\storage\Bench\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xmoclient\xmosamplerateconverter.h ===
//-----------------------------------------------------------------------------
// Name: XMOSampleRateConverter.h
//
// Desc: Sample rate converter interface. This is an example of deriving the
//       base XMediaObject into a custom interface.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#pragma once
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CSampleRateConverter
// Desc: Sample-rate converter XMO
//-----------------------------------------------------------------------------
class CSampleRateConverter : public XMediaObject
{
protected:
    DWORD       m_dwChannelCount;           // Channel count
    DWORD       m_dwSourceFrequency;        // Source sampling rate
    DWORD       m_dwDestinationFrequency;   // Destination sampling rate
    DWORD       m_dwSourceAlignment;        // Source sample alignment
    DWORD       m_dwDestinationAlignment;   // Source sample alignment
    DWORD       m_dwIndex;                  // Sample rate converter index
    ULONG       m_ulRefCount;               // Object reference count

public:
    CSampleRateConverter( DWORD dwChannelCount, DWORD dwSourceFrequency, 
                          DWORD dwDestinationFrequency );

public:
    // IUnknown methods
    virtual ULONG   STDMETHODCALLTYPE AddRef();
    virtual ULONG   STDMETHODCALLTYPE Release();

    // XMediaObject methods
    virtual HRESULT STDMETHODCALLTYPE GetInfo( XMEDIAINFO* pInfo );
    virtual HRESULT STDMETHODCALLTYPE GetStatus( DWORD* pdwStatus );
    virtual HRESULT STDMETHODCALLTYPE Process( const XMEDIAPACKET* pInputPacket, 
                                               const XMEDIAPACKET* pOutputPacket );
    virtual HRESULT STDMETHODCALLTYPE Discontinuity();
    virtual HRESULT STDMETHODCALLTYPE Flush();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\sound\xmoclient\xmoclient.cpp ===
//-----------------------------------------------------------------------------
// Name: XMOClient.cpp
//
// Desc: This sample show an XMO client...an example of using a custom
//       XMediaObject.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XMOSampleRateConverter.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD PLAYBACK_FREQUENCY                 = 48000;
const DWORD PACKET_COUNT                       = 4;
const DWORD PACKET_SIZE                        = 0x4000;




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
VOID*                   g_pSourceBuffer                       = NULL;
VOID*                   g_pDestinationBuffer                  = NULL;
LPXFILEMEDIAOBJECT      g_pSourceFilter                       = NULL;
LPXMEDIAOBJECT          g_pIntermediateFilter                 = NULL;
LPDIRECTSOUNDSTREAM     g_pRenderFilter                       = NULL;
HANDLE                  g_ahPacketEvents[PACKET_COUNT];




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates a file-based XMediaObject. In this case, we our using a
//       custom XMO (the sample rate converter object) that loads a file-based
//       sound file and converts its sample rate.
//-----------------------------------------------------------------------------
HRESULT Create( CHAR* strFilename )
{
    const WAVEFORMATEX* pwfxFile;
    WAVEFORMATEX        wfxStream;
    DSSTREAMDESC        dssd;
    HRESULT             hr;

    // We'll use a hard-coded packet size, because... well... I'm lazy.
    // In a shipping application, you'd want to calculate the optimal packet
    // size based on alignment restrictions and the MaxLookahead of any
    // asynchronous filters.  I'm going to make up a constant value.  If
    // the SRC has to do a significant downsample before sending to the
    // renderer, it's possible the stream will starve.

    // Create the source (wave file) filter.  We'll assume the source file is
    // 16-bit PCM.  Other than that, we don't really care what the format is.
    hr = XWaveFileCreateMediaObject( strFilename, &pwfxFile, &g_pSourceFilter );
    if( FAILED(hr) )
        return hr;

    // Create the intermediate (SRC) filter
    g_pIntermediateFilter = new CSampleRateConverter( pwfxFile->nChannels, 
                                                      pwfxFile->nSamplesPerSec, 
                                                      PLAYBACK_FREQUENCY );
    if( NULL == g_pIntermediateFilter )
        return E_OUTOFMEMORY;

    // Create the render (DirectSound stream) filter
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwMaxAttachedPackets = PACKET_COUNT;
    dssd.lpwfxFormat          = &wfxStream;
    wfxStream.wFormatTag      = WAVE_FORMAT_PCM;
    wfxStream.nChannels       = pwfxFile->nChannels;
    wfxStream.nSamplesPerSec  = PLAYBACK_FREQUENCY;
    wfxStream.wBitsPerSample  = pwfxFile->wBitsPerSample;
    wfxStream.nBlockAlign     = wfxStream.nChannels * wfxStream.wBitsPerSample / 8;
    wfxStream.nAvgBytesPerSec = wfxStream.nSamplesPerSec * wfxStream.nBlockAlign;

    hr = DirectSoundCreateStream( &dssd, &g_pRenderFilter );
    if( FAILED(hr) )
        return hr;

    // Allocate the source data buffer.  Because the source filter is 
    // synchronous, we can just use a single buffer and packet description.  
    // Because the amount of data we read from the source may be a different 
    // size than the amount we send to the renderer, using a single packet 
    // size is really sub-optimal.  We may end up re-reading data from the 
    // source because the renderer couldn't accept it all.
    g_pSourceBuffer = new BYTE[PACKET_SIZE];
    if( NULL == g_pSourceBuffer )
        return E_OUTOFMEMORY;

    // Allocate a buffer large enough to store packet data for all the 
    // renderer's packets. Because it's asynchronous, we have to keep the data
    // around until it's done processing it.
    g_pDestinationBuffer = new BYTE[PACKET_SIZE*PACKET_COUNT];
    if( NULL == g_pDestinationBuffer )
        return E_OUTOFMEMORY;

    // Create render packet completion events
    for( DWORD dwPacketIndex = 0; dwPacketIndex < PACKET_COUNT; dwPacketIndex++ )
    {
        g_ahPacketEvents[dwPacketIndex] = CreateEvent( NULL, TRUE, TRUE, NULL );
        if( NULL == g_ahPacketEvents[dwPacketIndex] )
            return E_OUTOFMEMORY;
    }

    return S_OK;

}




//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT Cleanup()
{
    // Wait for all packets to be completed
    WaitForMultipleObjects( PACKET_COUNT, g_ahPacketEvents, TRUE, INFINITE );

    // Free events
    for( DWORD dwPacketIndex = 0; dwPacketIndex < PACKET_COUNT; dwPacketIndex++ )
    {
        if( g_ahPacketEvents[dwPacketIndex] )
            CloseHandle( g_ahPacketEvents[dwPacketIndex] );
    }
    
    // Free memory and objects
    if( g_pSourceBuffer )       delete g_pSourceBuffer;
    if( g_pDestinationBuffer )  delete g_pDestinationBuffer;
    if( g_pSourceFilter )       g_pSourceFilter->Release();
    if( g_pIntermediateFilter ) g_pIntermediateFilter->Release();
    if( g_pRenderFilter )       g_pRenderFilter->Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT Run()
{
    // Enter the main loop
    while( TRUE )
    {
        HRESULT hr;

        // Wait for a packet completion event to be signalled.  If this is our
        // first time through the loop, all the packets are free, so all the
        // events are signalled.
        DWORD dwPacketIndex = WaitForMultipleObjects( PACKET_COUNT, g_ahPacketEvents, 
                                                      FALSE, INFINITE ) - WAIT_OBJECT_0;
        
        // Read some data
        XMEDIAPACKET xmpSource;
        DWORD        dwSourceCompletedSize;
        ZeroMemory( &xmpSource, sizeof(xmpSource) );
        xmpSource.pvBuffer         = g_pSourceBuffer;
        xmpSource.dwMaxSize        = PACKET_SIZE;
        xmpSource.pdwCompletedSize = &dwSourceCompletedSize;
        
        hr = g_pSourceFilter->Process( NULL, &xmpSource );
        if( FAILED(hr) )
            return hr;

        // If there's no more data to read, go ahead and break out of the loop
        if( 0 == dwSourceCompletedSize )
            return S_OK;

        // Send it through the SRC.  Be sure to fix up the packet size to
        // correspond to the completed size from the source filter.
        xmpSource.dwMaxSize = dwSourceCompletedSize;

        XMEDIAPACKET xmpDestination;
        DWORD        dwDestinationCompletedSize;
        ZeroMemory( &xmpDestination, sizeof(xmpDestination) );
        xmpDestination.pvBuffer         = (BYTE*)g_pDestinationBuffer + (dwPacketIndex * PACKET_SIZE);
        xmpDestination.dwMaxSize        = PACKET_SIZE;
        xmpDestination.pdwCompletedSize = &dwDestinationCompletedSize;

        hr = g_pIntermediateFilter->Process( &xmpSource, &xmpDestination );
        if( FAILED(hr) )
            return hr;

        // It's possible that we read some data, but it's not enough to pass
        // through the intermediate filter.  If that's true, go ahead and
        // break out of the loop.
        if( 0 == dwDestinationCompletedSize )
            return S_OK;

        // Send the packet to the renderer.  Again, be sure to fix up the 
        // packet size.  We don't care how much data actually gets played,
        // so we'll reset pdwCompletedSize to NULL.  If we did care how
        // much was played (or how much was processed by any asynchronous
        // XMO), we'd need to be sure that the variable pointed to by
        // pdwCompletedSize was not 
        xmpDestination.dwMaxSize        = dwDestinationCompletedSize;
        xmpDestination.pdwCompletedSize = NULL;
        xmpDestination.hCompletionEvent = g_ahPacketEvents[dwPacketIndex];

        ResetEvent( xmpDestination.hCompletionEvent );

        hr = g_pRenderFilter->Process( &xmpDestination, NULL );
        if( FAILED(hr) )
            return hr;

        // If the intermediate XMO processed less data than we supplied to
        // it, seek backwards in the source XMO. I outlined why this is lame
        // above, but oh well...
        if( dwSourceCompletedSize < xmpSource.dwMaxSize )
        {
            hr = g_pSourceFilter->Seek( -(LONG)(xmpSource.dwMaxSize - dwSourceCompletedSize), 
                                        FILE_CURRENT, NULL );
            if( FAILED(hr) )
                return hr;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    if( SUCCEEDED( Create( "D:\\Media\\XMOClnt.wav" ) ) )
    {
        Run();
    }

    Cleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\template\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\SimpleWMV\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\storage\Bench\BenchStorage.cpp ===
//-----------------------------------------------------------------------------
// File: BenchStorage.cpp
//
// Desc: Benchmark Xbox storage
//
// Hist: 04.25.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "BenchStorage.h"
#include "File.h"
#include <XbStorageDevice.h>
#include <iostream>
#include <fstream>
#include <cassert>
#include "Resource.h"

#pragma warning( push, 3 )  // Suppress VC warnings when compiling at W4
#pragma warning( disable: 4702 )
#include <list>
#include <vector>
#pragma warning( pop )

#ifdef _DEBUG
    #define VERIFY( e ) assert( e );
#else
    #define VERIFY( e ) (VOID)(e);
#endif




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_MEMORY_UNITS = 2 * XGetPortCount();

//#define QUICK_TEST_MODE
#ifdef QUICK_TEST_MODE
    const DWORD TEST_FILE_SIZE          = 1024 * 1024 * 1;      // 1 MB
    const DWORD MAX_DEVICE_POLLS        = 1000;
    const DWORD MIN_BUFFER_SIZE         = 16 * 1024;            // 16 K
    const DWORD MIN_BUFFER_SIZE_API     = 32 * 1024;            // 32 K
    const DWORD MAX_BUFFER_SIZE         = 1024 * 128;           // 128 K
    const DWORD DEFAULT_BUFFER_SIZE     = 1024 * 64;            // 64 K
    const DWORD MIN_CACHE_SIZE          = 64 * 1024;            // 64 K
    const DWORD MAX_CACHE_SIZE          = 1024 * 1024 * 1;      // 1 MB
    const DWORD API_PASSES              = 100;
    const DWORD MAX_RANDOM_SEEKS        = 100;
    const DWORD MAX_SEQUENTIAL_SEEKS    = 100;
    const DWORD MAX_RANDOM_READS        = 100;
    const DWORD MAX_RANDOM_WRITES       = 20;
    const DWORD MAX_SEQUENTIAL_READS    = 100;
    const DWORD MAX_SEQUENTIAL_WRITES   = 20;
    const DWORD REGION_PASSES           = 10;
    const DWORD ENUM_SAVE_GAMES         = 10;
    const DWORD ENUM_DIR_TREE           = 6;       // root folders
    const DWORD ENUM_OPEN_TREE          = 2;       // root folders
    const DWORD SAVE_SUBFOLDER_RATIO    = 4;       // 1 in 4
    const DWORD MAX_NICKNAMES           = 200;
#else
    const DWORD TEST_FILE_SIZE          = 1024 * 1024 * 4;      // 4 MB
    const DWORD MAX_DEVICE_POLLS        = 1000000;
    const DWORD MIN_BUFFER_SIZE         = 4;
    const DWORD MIN_BUFFER_SIZE_API     = 128;
    const DWORD MAX_BUFFER_SIZE         = 1024 * 512;           // 512 K
    const DWORD DEFAULT_BUFFER_SIZE     = 1024 * 64;            // 64 K
    const DWORD MIN_CACHE_SIZE          = 4 * 1024;             // 4 K
    const DWORD MAX_CACHE_SIZE          = 1024 * 1024 * 4;      // 4 MB
    const DWORD API_PASSES              = 10000;
    const DWORD MAX_RANDOM_SEEKS        = 100000;
    const DWORD MAX_SEQUENTIAL_SEEKS    = 100000;
    const DWORD MAX_RANDOM_READS        = 10000;
    const DWORD MAX_RANDOM_WRITES       = 2000;
    const DWORD MAX_SEQUENTIAL_READS    = 10000;
    const DWORD MAX_SEQUENTIAL_WRITES   = 2000;
    const DWORD REGION_PASSES           = 1000;
    const DWORD ENUM_SAVE_GAMES         = 100;
    const DWORD ENUM_DIR_TREE           = 12;       // root folders
    const DWORD ENUM_OPEN_TREE          = 4;        // root folders
    const DWORD SAVE_SUBFOLDER_RATIO    = 4;        // 1 in 4
    const DWORD MAX_NICKNAMES           = 200;
#endif

const CHAR* const strTEST_FILE                 = "BenchmarkTest.Garbage";
const CHAR* const strTEST_SAVE_GAME            = "Save";
const CHAR* const strDEVICE_CHANGES            = "DeviceChanges";
const CHAR* const strBUFFERS_READ_FILE         = "FileReadBuffers";
const CHAR* const strBUFFERS_WRITE_FILE        = "FileWriteBuffers";
const CHAR* const strASYNC_READ_NOTIFY_FILE    = "AsyncReadNotify";
const CHAR* const strASYNC_WRITE_NOTIFY_FILE   = "AsyncWriteNotify";
const CHAR* const strASYNC_READ_CALLBACK_FILE  = "AsyncReadCallback";
const CHAR* const strASYNC_WRITE_CALLBACK_FILE = "AsyncWriteCallback";
const CHAR* const strAPI_OPEN_FILE             = "ApiOpen";
const CHAR* const strAPI_CLOSE_FILE            = "ApiClose";
const CHAR* const strAPI_READ_FILE             = "ApiRead";
const CHAR* const strAPI_WRITE_FILE            = "ApiWrite";
const CHAR* const strAPI_SEEK_FILE             = "ApiSeek";
const CHAR* const strRANDOM_SEEK_FILE          = "RandomSeek";
const CHAR* const strSEQ_SEEK_FILE             = "SequentialSeek";
const CHAR* const strRANDOM_READ_FILE          = "RandomRead";
const CHAR* const strRANDOM_WRITE_FILE         = "RandomWrite";
const CHAR* const strSEQ_READ_FILE             = "SequentialRead";
const CHAR* const strSEQ_WRITE_FILE            = "SequentialWrite";
const CHAR* const strREGION_READ_FILE          = "RegionRead";
const CHAR* const strREGION_WRITE_FILE         = "RegionWrite";
const CHAR* const strCACHE_RANDOM_READ_FILE    = "CacheRandomRead";
const CHAR* const strCACHE_SEQ_READ_FILE       = "CacheSeqRead";
const CHAR* const strCACHE_RANDOM_WRITE_FILE   = "CacheRandomWrite";
const CHAR* const strCACHE_SEQ_WRITE_FILE      = "CacheSeqWrite";
const CHAR* const strENUM_SAVES_FILE           = "EnumSaves";
const CHAR* const strENUM_DIRS_FILE            = "EnumDirs";
const CHAR* const strENUM_SOUNDTRACKS_FILE     = "EnumSoundtracks";
const CHAR* const strENUM_NICKNAMES_FILE       = "EnumNicknames";
const CHAR* const strENUM_OPEN_FILE            = "EnumOpenFile";

const WCHAR* const strTEST_SAVE_CONTAINER      = L"Garbage";
const WCHAR* const strNICKNAME_PREFIX          = L"Nickname";

// Change these values to limit/expand testing
const BOOL  TEST_MU = FALSE;
const BOOL  TEST_HD = TRUE;
const BOOL  TEST_DVD = FALSE; // TRUE;




//-----------------------------------------------------------------------------
// Name: AutoHandle
// Desc: Local class for doing automatic handle cleanup
//-----------------------------------------------------------------------------
class AutoHandle
{

    HANDLE m_Handle;

public:

    AutoHandle( HANDLE h = NULL )
    : 
        m_Handle( h )
    {
    }

    ~AutoHandle()
    {
        Close();
    }

    operator HANDLE()
    {
        return m_Handle;
    }

    VOID Close()
    {
        if( m_Handle != NULL )
        {
            VERIFY( CloseHandle( m_Handle ) );
            m_Handle = NULL;
        }
    }

private:

    // Disabled
    AutoHandle( const AutoHandle& );
    AutoHandle& operator=( const AutoHandle& );

};




//-----------------------------------------------------------------------------
// Name: AutoHeapPtr
// Desc: Local class for doing automatic heap cleanup
//-----------------------------------------------------------------------------
class AutoHeapPtr
{

    HANDLE m_Heap;
    BYTE* m_pData;

public:

    AutoHeapPtr()
    : 
        m_Heap( GetProcessHeap() ),
        m_pData( NULL )
    {
    }

    ~AutoHeapPtr()
    {
        Free();
    }

    BYTE* Alloc( DWORD dwBytes )
    {
        Free();
        m_pData = ( BYTE* )( HeapAlloc( m_Heap, 0, dwBytes ) );
        return m_pData;
    }

    VOID Free()
    {
        if( m_pData != NULL )
        {
            VERIFY( HeapFree( m_Heap, 0, m_pData ) );
            m_pData = NULL;
        }
    }

private:

    // Disabled
    AutoHeapPtr( const AutoHeapPtr& );
    AutoHeapPtr& operator=( const AutoHeapPtr& );

};




//-----------------------------------------------------------------------------
// Name: TestFile
// Desc: Local class for large benchmark testing file. Automatically
//       deletes the file when it goes out of scope.
//-----------------------------------------------------------------------------
class TestFile
{

    CHAR m_strFile[64];
    BOOL m_bExists;

public:

    TestFile( CHAR chDrive )
    :
        m_bExists( FALSE )
    {
        m_strFile[0] = chDrive;
        m_strFile[1] = ':';
        m_strFile[2] = '\\';
        lstrcpyA( m_strFile+3, strTEST_FILE );
    }

    ~TestFile()
    {
        Delete();
    }

    BOOL Create()
    {
        Delete();

        File file;
        if( !file.Create( m_strFile, GENERIC_WRITE ) )
            return FALSE;

        // Create a buffer with incrementing DWORDS
        AutoHeapPtr Buffer;
        BYTE* pBuffer = Buffer.Alloc( TEST_FILE_SIZE );
        DWORD* pWalk = (DWORD*)( pBuffer );
        for( DWORD i = 0; i < TEST_FILE_SIZE / sizeof(DWORD); ++i, ++pWalk )
            *pWalk = i;

        // Write the buffer
        FLOAT fElapsed;
        BOOL bSuccess = file.Write( pBuffer, TEST_FILE_SIZE, fElapsed );
        assert( bSuccess );
        if( bSuccess )
            m_bExists = TRUE;
        return bSuccess;
    }

    const CHAR* GetFileName() const
    {
        return m_strFile;
    }

    VOID Delete()
    {
        if( m_bExists )
        {
            VERIFY( DeleteFile( m_strFile ) );
            m_bExists = FALSE;
        }
    }

    static BOOL IsValid( const BYTE* pBuffer, DWORD dwBytes )
    {
        assert( pBuffer != NULL );
        assert( dwBytes >= sizeof(DWORD) );
        assert( dwBytes % sizeof(DWORD) == 0 );

        // Validate the buffer against any DWORD-aligned portion of the file
        DWORD* pWalk = (DWORD*)( pBuffer );
        DWORD dwValue = *pWalk;
        ++pWalk;
        for( DWORD i = 1; i < dwBytes / sizeof(DWORD); ++i, ++pWalk )
        {
            assert( *pWalk == dwValue + 1 );
            if( *pWalk != dwValue + 1 )
                return FALSE;
            dwValue = *pWalk;
        }
        return TRUE;
    }

};




//-----------------------------------------------------------------------------
// Name: ResultsFile
// Desc: Local class for writing benchmark output. File is tab delimited for
//       easy importing into Excel. File is always written to user data region
//       (U).
//-----------------------------------------------------------------------------
class ResultsFile
{

    File m_File;

public:

    ResultsFile()
    :
        m_File()
    {
    }

    BOOL Create( const CHAR* strFileName, CHAR chDrive, 
                 const CHAR* strHeader1 = NULL, const CHAR* strHeader2 = NULL, 
                 const CHAR* strHeader3 = NULL, const CHAR* strHeader4 = NULL )
    {
        CHAR strDrive[2] = { chDrive, '\0' };
        CHAR strPath[ MAX_PATH ];
        lstrcpyA( strPath, "U:\\" );
        lstrcatA( strPath, strFileName );
        lstrcatA( strPath, strDrive );
        lstrcatA( strPath, ".csv" );
        BOOL bSuccess = m_File.Create( strPath, GENERIC_WRITE );
        if( !bSuccess )
            return FALSE;

        FLOAT fElapsed;
        if( strHeader1 != NULL )
        {
            bSuccess &= m_File.Write( strHeader1, lstrlenA( strHeader1 ), fElapsed );
            bSuccess &= m_File.Write( ",", 1, fElapsed );
        }
        if( strHeader2 != NULL )
        {
            bSuccess &= m_File.Write( strHeader2, lstrlenA( strHeader2 ), fElapsed );
            bSuccess &= m_File.Write( ",", 1, fElapsed );
        }
        if( strHeader3 != NULL )
        {
            bSuccess &= m_File.Write( strHeader3, lstrlenA( strHeader3 ), fElapsed );
            bSuccess &= m_File.Write( ",", 1, fElapsed );
        }
        if( strHeader4 != NULL )
        {
            bSuccess &= m_File.Write( strHeader4, lstrlenA( strHeader4 ), fElapsed );
            bSuccess &= m_File.Write( ",", 1, fElapsed );
        }
        bSuccess &= m_File.Write( "\n", 1, fElapsed );

        return bSuccess;
    }

    VOID Write( DWORD i, FLOAT j )
    {
        // Comma-delimited
        FLOAT fElapsed;
        CHAR strOutput[64];
        DWORD nChars = sprintf( strOutput, "%lu,%f\n", i, j );
        m_File.Write( strOutput, nChars, fElapsed );
    }

    VOID Write( DWORD i, FLOAT j, FLOAT k )
    {
        // Comma-delimited
        FLOAT fElapsed;
        CHAR strOutput[64];
        DWORD nChars = sprintf( strOutput, "%lu,%f,%f\n", i, j, k );
        m_File.Write( strOutput, nChars, fElapsed );
    }

    VOID Write( DWORD i, FLOAT j, FLOAT k, FLOAT m )
    {
        // Comma-delimited
        FLOAT fElapsed;
        CHAR strOutput[64];
        DWORD nChars = sprintf( strOutput, "%lu,%f,%f,%f\n", i, j, k, m );
        m_File.Write( strOutput, nChars, fElapsed );
    }

    VOID Write( FLOAT i, FLOAT j, FLOAT k )
    {
        // Comma-delimited
        FLOAT fElapsed;
        CHAR strOutput[64];
        DWORD nChars = sprintf( strOutput, "%f,%f,%f", i, j, k );
        m_File.Write( strOutput, nChars, fElapsed );
    }

private:

    // Disabled
    ResultsFile( const ResultsFile& );
    ResultsFile& operator=( const ResultsFile& );

};




//-----------------------------------------------------------------------------
// Name: SavedGames
// Desc: Generates pseudo saved games
//-----------------------------------------------------------------------------
class SavedGames
{

    DWORD m_dwSeed;
    DWORD m_dwSavedGames;
    CHAR  m_chDrive;

public:

    SavedGames( DWORD dwSeed, DWORD dwSavedGames, CHAR chDrive )
    :
        m_dwSeed( dwSeed ),
        m_dwSavedGames( dwSavedGames ),
        m_chDrive( chDrive )
    {
    }

    ~SavedGames()
    {
        Destroy();
    }

    BOOL Create()
    {
        srand( m_dwSeed );
        CHAR strPath[4] = "x:\\";
        strPath[0] = m_chDrive;

        // Determine the maximum number of clusters available per saved
        // game. Each saved game requires at least two clusters: one for
        // the directory and one for the meta data file.
        DWORD dwClusterSize = XGetDiskClusterSize( strPath );
        DWORD dwMaxClusters = TEST_FILE_SIZE / m_dwSavedGames /
                              dwClusterSize;
        assert( dwMaxClusters >= 2 );
        DWORD dwGameClusters = dwMaxClusters - 2;

        for( DWORD i = 0; i < m_dwSavedGames; ++i )
        {
            // Generate a name
            WCHAR strSave[ MAX_GAMENAME ];
            WCHAR strNum[32];
            lstrcpyW( strSave, strTEST_SAVE_CONTAINER );
            lstrcatW( strSave, _itow( i, strNum, 10 ) );

            // Create the container (2 clusters)
            CHAR strDir[ MAX_PATH ];
            DWORD dwSuccess = XCreateSaveGame( strPath, strSave, OPEN_ALWAYS,
                                               XSAVEGAME_NOCOPY, strDir,
                                               MAX_PATH );
            assert( dwSuccess == ERROR_SUCCESS );
            if( dwSuccess != ERROR_SUCCESS )
                return FALSE;

            // Fill the container (dir) with some files
            DWORD dwNumFiles = rand() % ( dwGameClusters + 1 );
            DWORD dwClusters = ( dwNumFiles == 0 ) ? 0 : dwGameClusters / dwNumFiles;
            for( DWORD j = 0; j < dwNumFiles; ++j )
            {
                // Generate a name
                CHAR strFile[ MAX_PATH ];
                CHAR strNum2[32];
                lstrcpyA( strFile, strDir );
                lstrcatA( strFile, strTEST_SAVE_GAME );
                lstrcatA( strFile, itoa( j, strNum2, 10 ) );

                // Create the file
                File file;
                BOOL bSuccess = file.Create( strFile, GENERIC_WRITE );
                assert( bSuccess );
                if( !bSuccess )
                    return FALSE;

                // Size the file
                DWORD dwBytes = ( dwClusters - 1 ) * dwClusterSize;
                dwBytes += rand() % dwClusterSize;
                file.SetPos( dwBytes );
                bSuccess = file.SetEOF();
                if( !bSuccess )
                    return FALSE;
            }

            // Create a subfolder -- sometimes
            if( dwNumFiles * dwClusters < dwGameClusters && 
                ( rand() % SAVE_SUBFOLDER_RATIO ) == 0 )
            {
                // Generate a name
                CHAR strPath[ MAX_PATH ];
                lstrcpyA( strPath, strDir );
                lstrcatA( strPath, strTEST_SAVE_GAME );
                lstrcatA( strPath, "Subdir" );

                BOOL bSuccess = CreateDirectory( strPath, NULL );
                assert( bSuccess );
                if( !bSuccess )
                    return FALSE;

                // Fill the subdir with files
                for( DWORD j = 1; j < dwGameClusters / dwClusters - 
                                      dwNumFiles; ++j )
                {
                    // Generate a name
                    CHAR strFile[ MAX_PATH ];
                    CHAR strNum2[32];
                    lstrcpyA( strFile, strPath );
                    lstrcatA( strFile, "\\" );
                    lstrcatA( strFile, strTEST_SAVE_GAME );
                    lstrcatA( strFile, itoa( j, strNum2, 10 ) );

                    // Create the file
                    File file;
                    BOOL bSuccess = file.Create( strFile, GENERIC_WRITE );
                    assert( bSuccess );
                    if( !bSuccess )
                        return FALSE;

                    // Size the file
                    DWORD dwBytes = ( dwClusters - 1 ) * dwClusterSize;
                    dwBytes += rand() % dwClusterSize;
                    file.SetPos( dwBytes );
                    bSuccess = file.SetEOF();
                    if( !bSuccess )
                        return FALSE;
                }
            }
        }
        return TRUE;
    }

    VOID Destroy()
    {
        CHAR strPath[4] = "x:\\";
        strPath[0] = m_chDrive;

        for( DWORD i = 0; i < m_dwSavedGames; ++i )
        {
            // Generate the name
            WCHAR strSave[ MAX_GAMENAME ];
            WCHAR strNum[32];
            lstrcpyW( strSave, strTEST_SAVE_CONTAINER );
            lstrcatW( strSave, _itow( i, strNum, 10 ) );

            // Delete the container
            VERIFY( XDeleteSaveGame( strPath, strSave ) == ERROR_SUCCESS );
        }
    }

private:

    // Disabled
    SavedGames();
    SavedGames( const SavedGames& );
    SavedGames& operator=( const SavedGames& );

};




//-----------------------------------------------------------------------------
// Name: FileList
// Desc: List of file names
//-----------------------------------------------------------------------------
class FileList : public std::list< CHAR* >
{

public:

    ~FileList()
    {
        for( const_iterator i = begin(); i != end(); ++i )
            delete *i;
    }

};




//-----------------------------------------------------------------------------
// Name: OpenFileList
// Desc: List of open file handles
//-----------------------------------------------------------------------------
class OpenFileList : public std::list< HANDLE >
{

public:

    ~OpenFileList()
    {
        for( const_iterator i = begin(); i != end(); ++i )
        {
            VERIFY( CloseHandle( *i ) );
        }
    }

};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, then begins the
//       profiling phase.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    BenchStorage xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    // Run the tests
    xbApp.RunBenchSuite();

    // Show completion status
    xbApp.ShowComplete();

    Sleep( INFINITE );
}




//-----------------------------------------------------------------------------
// Name: BenchStorage()
// Desc: Constructor
//-----------------------------------------------------------------------------
BenchStorage::BenchStorage()
:
    m_xprResource(),
    m_Font(),
    m_strStatusHdr(),
    m_strStatus(),
    m_StatusTimer( FALSE ),
    m_MemUnit(),
    m_Overlapped(),
    m_dwBytesTransferred( 0 ),
    m_dwHdBufferSize( DEFAULT_BUFFER_SIZE ),
    m_dwDefaultCacheSize( XGetFileCacheSize() ),
    m_dwSeed( GetTickCount() ),
    m_chHardDrive( '\0' ),
    m_chMemUnit( '\0' ),
    m_chDvd( '\0' )
{
    *m_strStatusHdr = 0;
    *m_strStatus = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: One time initialization
//-----------------------------------------------------------------------------
HRESULT BenchStorage::Initialize()
{
    // Create the resources
    // if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
    //                                   resource_NUM_RESOURCES ) ) )
    //     return XBAPPERR_MEDIANOTFOUND;

    // Load the font resources
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font16.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_chHardDrive = 'T';            // persistent data region on HD
    m_chDvd = 'D';                  // DVD drive
    m_chMemUnit = FindBestMu();     // first available MU

    // If no MUs found initially, wait a few moments and try again.
    // The peripheral drivers are initialized late, and may take a
    // few moments to enum all MUs.
    CXBStopWatch stopWatch( TRUE );
    while( m_chMemUnit == '\0' )
    {
        Sleep( 200 );
        m_chMemUnit = FindBestMu();
        if( stopWatch.GetElapsedSeconds() > 5.0f )
            break;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RunBenchSuite()
// Desc: Run benchmark suites
//-----------------------------------------------------------------------------
VOID BenchStorage::RunBenchSuite()
{
    m_StatusTimer.StartZero();

    RunGetDeviceChangesSuite();
    RunFileBuffersSuite();
    RunAsyncSuite();
    RunApiComparisonSuite();
    RunRandomSeekSuite();
    RunSequentialSeekSuite();
    RunRandomAccessSuite();
    RunSequentialAccessSuite();
    RunCacheSuite();
    RunRegionSuite();
    RunEnumerationSuite();
    RunScatterGatherSuite();
    RunInterleavedSuite();
}




//-----------------------------------------------------------------------------
// Name: ShowComplete()
// Desc: Display completion status
//-----------------------------------------------------------------------------
VOID BenchStorage::ShowComplete()
{
    lstrcpyW( m_strStatusHdr, L"Benchmarks complete" );
    lstrcpyW( m_strStatus, L"Output available on U:\n"
                           L"xbcp xU:\\*.csv" );
    ShowStatus( TRUE );
}




//-----------------------------------------------------------------------------
// Name: FindBestMu()
// Desc: Find and mount the MU with the largest amount of free space
//-----------------------------------------------------------------------------
CHAR BenchStorage::FindBestMu()
{
    // Locate the MU with the largest amount of free space
    ULONGLONG qwMaxFreeBlocks = ULONGLONG( 0 );
    DWORD dwBestMu = DWORD(-1);
    DWORD dwSnapshot = CXBMemUnit::GetMemUnitSnapshot();
    for( DWORD i = 0; i < MAX_MEMORY_UNITS; ++i )
    {
        if( dwSnapshot & CXBMemUnit::GetMemUnitMask( i ) )
        {
            // Temporarily mount MU
            DWORD dwPort = CXBMemUnit::GetMemUnitPort( i );
            DWORD dwSlot = CXBMemUnit::GetMemUnitSlot( i );
            DWORD dwError;
            CXBMemUnit MemUnit( dwPort, dwSlot, dwError );
            CXBStorageDevice MuDevice( MemUnit.GetDrive() );

            // See how much room on MU
            ULONGLONG qwTotalBlocks;
            ULONGLONG qwUsedBlocks;
            ULONGLONG qwFreeBlocks;
            if( MuDevice.GetSize( qwTotalBlocks, qwUsedBlocks, qwFreeBlocks ) )
            {
                if( qwFreeBlocks > qwMaxFreeBlocks )
                {
                    qwMaxFreeBlocks = qwFreeBlocks;
                    dwBestMu = i;
                }
            }
        }
    }
    if( dwBestMu != DWORD(-1) )
    {
        // Mount MU for duration of app
        DWORD dwPort = CXBMemUnit::GetMemUnitPort( dwBestMu );
        DWORD dwSlot = CXBMemUnit::GetMemUnitSlot( dwBestMu );
        DWORD dwError;
        if( m_MemUnit.Mount( dwPort, dwSlot, dwError ) )
            return m_MemUnit.GetDrive();
    }

    // No MUs available
    return '\0';
}




//-----------------------------------------------------------------------------
// Name: RunGetDeviceChangesSuite()
// Desc: Evaluate the speed of XGetDevices() and XGetDeviceChanges()
//-----------------------------------------------------------------------------
VOID BenchStorage::RunGetDeviceChangesSuite()
{
    DeviceType devType = Device_HD;
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strDEVICE_CHANGES, 
                  "XGetDevices",
                  L"Compare XGetDevices and XGetDeviceChanges", "Calls",
                  "XGetDevices (seconds)", "XGetDeviceChanges (seconds)" ) )
        return;

    CXBStopWatch timer( FALSE );
    for( DWORD i = 0; i < MAX_DEVICE_POLLS; ++i )
    {
        timer.Start();
        XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );
        timer.Stop();
        ShowStatus( FLOAT(i) / FLOAT(MAX_DEVICE_POLLS*2) );
    }

    FLOAT fGetDevices = timer.GetElapsedSeconds();
    timer.Reset();

    DWORD dwInsert;
    DWORD dwRemove;
    for( DWORD i = 0; i < MAX_DEVICE_POLLS; ++i )
    {
        timer.Start();
        XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwInsert, &dwRemove );
        timer.Stop();
        ShowStatus( FLOAT(MAX_DEVICE_POLLS+i) / FLOAT(MAX_DEVICE_POLLS*2) );
    }

    FLOAT fGetDeviceChanges = timer.GetElapsedSeconds();
    fileResults.Write( MAX_DEVICE_POLLS, fGetDevices, fGetDeviceChanges );
}




//-----------------------------------------------------------------------------
// Name: RunFileBuffersSuite()
// Desc: Evaluate the best size for file buffers
//-----------------------------------------------------------------------------
VOID BenchStorage::RunFileBuffersSuite()
{
    FileBuffersRead( Device_MU );
    FileBuffersRead( Device_HD );
    FileBuffersRead( Device_DVD );

    FileBuffersWrite( Device_MU );
    FileBuffersWrite( Device_HD );
}




//-----------------------------------------------------------------------------
// Name: RunAsyncSuite()
// Desc: Evaluate asynchronous file I/O
//-----------------------------------------------------------------------------
VOID BenchStorage::RunAsyncSuite()
{
    AsyncRead( Device_MU );
    AsyncRead( Device_HD );
    AsyncRead( Device_DVD );

    AsyncWrite( Device_MU );
    AsyncWrite( Device_HD );
}




//-----------------------------------------------------------------------------
// Name: RunApiComparisonSuite()
// Desc: Evaluate the performance differences between Xbox API, C API and C++
//       API
//-----------------------------------------------------------------------------
VOID BenchStorage::RunApiComparisonSuite()
{
    ApiCompare( Device_MU );
    ApiCompare( Device_HD );
    ApiCompare( Device_DVD );
}




//-----------------------------------------------------------------------------
// Name: RunRandomSeekSuite()
// Desc: Evaluate random access time
//-----------------------------------------------------------------------------
VOID BenchStorage::RunRandomSeekSuite()
{
    RandomSeek( Device_MU );
    RandomSeek( Device_HD );
    RandomSeek( Device_DVD );
}




//-----------------------------------------------------------------------------
// Name: RunSequentialSeekSuite()
// Desc: Evaluate sequential access time
//-----------------------------------------------------------------------------
VOID BenchStorage::RunSequentialSeekSuite()
{
    SeqSeek( Device_MU );
    SeqSeek( Device_HD );
    SeqSeek( Device_DVD );
}




//-----------------------------------------------------------------------------
// Name: RunRandomAccessSuite()
// Desc: Evaluate random access file I/O
//-----------------------------------------------------------------------------
VOID BenchStorage::RunRandomAccessSuite()
{
    RandomRead( Device_MU );
    RandomRead( Device_HD );
    RandomRead( Device_DVD );

    RandomWrite( Device_MU );
    RandomWrite( Device_HD );
}




//-----------------------------------------------------------------------------
// Name: RunSequentialAccessSuite()
// Desc: Evaluate sequential access file I/O
//-----------------------------------------------------------------------------
VOID BenchStorage::RunSequentialAccessSuite()
{
    SeqRead( Device_MU );
    SeqRead( Device_HD );
    SeqRead( Device_DVD );

    SeqWrite( Device_MU );
    SeqWrite( Device_HD );
}




//-----------------------------------------------------------------------------
// Name: RunCacheSuite()
// Desc: Evaluate file caching issues
//-----------------------------------------------------------------------------
VOID BenchStorage::RunCacheSuite()
{
    CacheRead( Device_MU );
    CacheRead( Device_HD );
    CacheRead( Device_DVD );

    CacheWrite( Device_MU );
    CacheWrite( Device_HD );
}




//-----------------------------------------------------------------------------
// Name: RunRegionSuite()
// Desc: Evaluate speeds of various hard drive regions
//-----------------------------------------------------------------------------
VOID BenchStorage::RunRegionSuite()
{
    RegionRead();
    RegionWrite();
}




//-----------------------------------------------------------------------------
// Name: RunEnumerationSuite()
// Desc: Enumerate storage items like saved games, directories, soundtracks,
//       nicknames
//-----------------------------------------------------------------------------
VOID BenchStorage::RunEnumerationSuite()
{
    EnumSaves( Device_MU );
    EnumSaves( Device_HD_User );

    EnumDirs( Device_MU );
    EnumDirs( Device_HD_User );

    EnumSoundtracks();
    EnumNicknames();

    EnumOpen( Device_MU );
    EnumOpen( Device_HD_User );
}




//-----------------------------------------------------------------------------
// Name: RunScatterGatherSuite()
// Desc: Evaluate scatter and gather routines
//-----------------------------------------------------------------------------
VOID BenchStorage::RunScatterGatherSuite()
{
    Scatter( Device_MU );
    Scatter( Device_HD );
    Scatter( Device_DVD );

    Gather( Device_MU );
    Gather( Device_HD );
}




//-----------------------------------------------------------------------------
// Name: RunInterleavedSuite()
// Desc: Evaluate speed of interleaved I/O between hard drive and DVD
//-----------------------------------------------------------------------------
VOID BenchStorage::RunInterleavedSuite()
{
    InterleavedRead();
    InterleavedWrite();
}




//-----------------------------------------------------------------------------
// Name: FileBuffersRead()
// Desc: Evaluate file buffer size for reading
//-----------------------------------------------------------------------------
VOID BenchStorage::FileBuffersRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strBUFFERS_READ_FILE, 
                  "FileBuffersRead", L"File Buffer Size for Read",
                  "Buffer Size (bytes)", "Read Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( TEST_FILE_SIZE );

    // Read the file using various buffer sizes
    FLOAT fBest = 0.0f;
    for( DWORD dwBufferSize = MIN_BUFFER_SIZE; dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        // Open the test file
        File fileRead;
        VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ ) );

        // Read the entire file
        DWORD dwTotalRead = 0;
        FLOAT fTotal = 0.0f;
        for( ;; )
        {
            DWORD dwRead;
            FLOAT fElapsed;
            VERIFY( fileRead.Read( pBuffer, dwBufferSize, dwRead, fElapsed ) );
            fTotal += fElapsed;
            assert( TestFile::IsValid( pBuffer, dwRead ) );
            dwTotalRead += dwRead;
            if( dwTotalRead >= TEST_FILE_SIZE )
                break;

            ShowStatus( dwBufferSize, FLOAT(dwTotalRead) / FLOAT(TEST_FILE_SIZE) );
        }

        fileResults.Write( dwBufferSize, fTotal );

        // Save the best hard drive buffer size for later
        if( devType == Device_HD )
        {
            if( fBest == 0.0f || fTotal < fBest )
            {
                fBest = fTotal;
                m_dwHdBufferSize = dwBufferSize;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FileBuffersWrite()
// Desc: Evaluate file buffer size for writing
//-----------------------------------------------------------------------------
VOID BenchStorage::FileBuffersWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strBUFFERS_WRITE_FILE, 
                  "FileBuffersWrite", L"File Buffer Size for Write",
                  "Buffer Size (bytes)", "Write Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( TEST_FILE_SIZE );

    // Write to the file using various buffer sizes
    for( DWORD dwBufferSize = MIN_BUFFER_SIZE; dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        // Open the test file
        File fileWrite;
        VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE ) );

        // Write the entire file
        FLOAT fTotal = 0.0f;
        DWORD dwTotalWritten = 0;
        for( ;; )
        {
            DWORD dwWritten;
            FLOAT fElapsed;
            VERIFY( fileWrite.Write( pBuffer, dwBufferSize, dwWritten, fElapsed ) );
            fTotal += fElapsed;
            dwTotalWritten += dwWritten;
            if( dwTotalWritten >= TEST_FILE_SIZE )
                break;

            ShowStatus( dwBufferSize, FLOAT(dwTotalWritten) / FLOAT(TEST_FILE_SIZE) );
        }

        fileResults.Write( dwBufferSize, fTotal );
    }
}




//-----------------------------------------------------------------------------
// Name: AsyncRead()
// Desc: Evaluate speed of asynchronous read
//-----------------------------------------------------------------------------
VOID BenchStorage::AsyncRead( DeviceType devType )
{
    AsyncReadNotify( devType );
    AsyncReadCallback( devType );
}




//-----------------------------------------------------------------------------
// Name: AsyncReadNotify()
// Desc: Evaluate speed of asynchronous read w/ notification
//-----------------------------------------------------------------------------
VOID BenchStorage::AsyncReadNotify( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strASYNC_READ_NOTIFY_FILE, 
                  "AsyncReadNotify", L"Asynchronous Read with Notify",
                  "Buffer Size (bytes)", "Read Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Buffer address must be DWORD aligned
    assert( (DWORD)pBuffer % sizeof(DWORD) == 0 );

    // Prepare the notification event
    m_Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    AutoHandle hEvent( m_Overlapped.hEvent );

    // Read the file using various buffer sizes.
    // Size must be integer multiple of device sector size
    CXBStorageDevice dev( GetDrive( devType ) );
    for( DWORD dwBufferSize = dev.GetSectorSize(); dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        // Open the test file in async mode
        File fileRead;
        VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ,
                                       FILE_FLAG_OVERLAPPED | 
                                       FILE_FLAG_NO_BUFFERING ) );

        // Start reading from beginning
        m_Overlapped.Offset = 0;
        m_Overlapped.OffsetHigh = 0;

        DWORD dwTotalRead = 0;
        FLOAT fTotal = 0.0f;
        for( ;; )
        {
            // Offset must be integer multiple of sector size
            assert( m_Overlapped.Offset % dev.GetSectorSize() == 0 );

            // Initiate the read
            FLOAT fElapsed;
            VERIFY( !fileRead.ReadAsyncNotify( pBuffer, dwBufferSize, 
                                               fElapsed, m_Overlapped ) );
            assert( GetLastError() == ERROR_IO_PENDING );
            fTotal += fElapsed;

            // Other work would normally occur here, but we're benchmarking, so
            // don't want to influence results

            // Wait for the read to complete
            DWORD dwRead;
            VERIFY( fileRead.GetOverlappedResult( m_Overlapped, dwRead, 
                                                  fElapsed ) );
            assert( TestFile::IsValid( pBuffer, dwRead ) );
            fTotal += fElapsed;
            dwTotalRead += dwRead;
            if( dwTotalRead >= TEST_FILE_SIZE )
                break;

            // Read from the next section of the file
            m_Overlapped.Offset += dwBufferSize;

            ShowStatus( dwBufferSize, FLOAT(dwTotalRead) / FLOAT(TEST_FILE_SIZE) );
        }
        fileResults.Write( dwBufferSize, fTotal );
    }
}




//-----------------------------------------------------------------------------
// Name: AsyncReadCallback()
// Desc: Evaluate speed of asynchronous read w/ callback
//-----------------------------------------------------------------------------
VOID BenchStorage::AsyncReadCallback( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strASYNC_READ_CALLBACK_FILE, 
                  "AsyncReadCallback", L"Asynchronous Read with Callback",
                  "Buffer Size (bytes)", "Read Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Buffer address must be DWORD aligned
    assert( (DWORD)pBuffer % sizeof(DWORD) == 0 );

    // Create a pseudo kernel event that we can wait on
    AutoHandle hTransferComplete( CreateEvent( NULL, FALSE, FALSE, NULL ) );

    // Read the file using various buffer sizes.
    // Size must be integer multiple of device sector size
    CXBStorageDevice dev( GetDrive( devType ) );
    for( DWORD dwBufferSize = dev.GetSectorSize(); dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        // Open the test file in async mode
        File fileRead;
        VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ,
                                       FILE_FLAG_OVERLAPPED | 
                                       FILE_FLAG_NO_BUFFERING ) );

        // Prepare the overlapped struct
        m_Overlapped.Offset = 0;
        m_Overlapped.OffsetHigh = 0;
        m_Overlapped.hEvent = this;

        DWORD dwTotalRead = 0;
        FLOAT fTotal = 0.0f;
        for( ;; )
        {
            // Offset must be integer multiple of sector size
            assert( m_Overlapped.Offset % dev.GetSectorSize() == 0 );

            // Initiate the read
            FLOAT fElapsed;
            VERIFY( fileRead.ReadAsyncCallback( pBuffer, dwBufferSize, 
                                                fElapsed, m_Overlapped, 
                                                BytesTransferred ) );
            assert( GetLastError() == ERROR_SUCCESS );
            fTotal += fElapsed;

            // Other work would normally occur here, but we're benchmarking, so
            // don't want to influence results

            // Wait for the read to complete. Note that hTransferComplete is never
            // signalled -- we're really waiting on the completion of the callback
            CXBStopWatch timer( TRUE );
            VERIFY( WaitForSingleObjectEx( hTransferComplete, INFINITE, TRUE )
                    == WAIT_IO_COMPLETION );

            assert( TestFile::IsValid( pBuffer, m_dwBytesTransferred ) );
            fTotal += timer.GetElapsedSeconds();
            dwTotalRead += m_dwBytesTransferred;
            if( dwTotalRead >= TEST_FILE_SIZE )
                break;

            // Read from the next section of the file
            m_Overlapped.Offset += dwBufferSize;

            ShowStatus( dwBufferSize, FLOAT(dwTotalRead) / FLOAT(TEST_FILE_SIZE) );
        }
        fileResults.Write( dwBufferSize, fTotal );
    }
}




//-----------------------------------------------------------------------------
// Name: AsyncWrite()
// Desc: Evaluate speed of asynchronous writes
//-----------------------------------------------------------------------------
VOID BenchStorage::AsyncWrite( DeviceType devType )
{
    AsyncWriteNotify( devType );
    AsyncWriteCallback( devType );
}




//-----------------------------------------------------------------------------
// Name: AsyncWriteNotify()
// Desc: Evaluate speed of asynchronous write w/ notification
//-----------------------------------------------------------------------------
VOID BenchStorage::AsyncWriteNotify( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strASYNC_WRITE_NOTIFY_FILE, 
                  "AsyncWriteNotify", L"Asynchronous Write with Notify",
                  "Buffer Size (bytes)", "Write Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Buffer address must be DWORD aligned
    assert( (DWORD)pBuffer % sizeof(DWORD) == 0 );

    // Prepare the notification event
    m_Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    AutoHandle hEvent( m_Overlapped.hEvent );

    // Write to the file using various buffer sizes.
    // Size must be integer multiple of device sector size
    CXBStorageDevice dev( GetDrive( devType ) );
    for( DWORD dwBufferSize = dev.GetSectorSize(); dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        // Open the test file in async mode
        File fileWrite;
        VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE,
                                FILE_FLAG_OVERLAPPED | 
                                FILE_FLAG_NO_BUFFERING ) );

        // Start writing from beginning
        m_Overlapped.Offset = 0;
        m_Overlapped.OffsetHigh = 0;

        DWORD dwTotalWritten = 0;
        FLOAT fTotal = 0.0f;
        for( ;; )
        {
            // Offset must be integer multiple of sector size
            assert( m_Overlapped.Offset % dev.GetSectorSize() == 0 );

            // Initiate the write
            FLOAT fElapsed;
            VERIFY( !fileWrite.WriteAsyncNotify( pBuffer, dwBufferSize, 
                                                 fElapsed, m_Overlapped ) );
            assert( GetLastError() == ERROR_IO_PENDING );
            fTotal += fElapsed;

            // Other work would normally occur here, but we're benchmarking, so
            // don't want to influence results

            // Wait for the write to complete
            DWORD dwWritten;
            VERIFY( fileWrite.GetOverlappedResult( m_Overlapped, dwWritten, 
                                                   fElapsed ) );
            fTotal += fElapsed;
            dwTotalWritten += dwWritten;
            if( dwTotalWritten >= TEST_FILE_SIZE )
                break;

            // Write to the next section of the file
            m_Overlapped.Offset += dwBufferSize;

            ShowStatus( dwBufferSize, FLOAT(dwTotalWritten) / FLOAT(TEST_FILE_SIZE) );
        }
        fileResults.Write( dwBufferSize, fTotal );
    }
}




//-----------------------------------------------------------------------------
// Name: AsyncWriteCallback()
// Desc: Evaluate speed of asynchronous write w/ callback
//-----------------------------------------------------------------------------
VOID BenchStorage::AsyncWriteCallback( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strASYNC_WRITE_CALLBACK_FILE, 
                  "AsyncWriteCallback", L"Asynchronous Write with Callback",
                  "Buffer Size (bytes)", "Write Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Buffer address must be DWORD aligned
    assert( (DWORD)pBuffer % sizeof(DWORD) == 0 );

    // Create a pseudo kernel event that we can wait on
    AutoHandle hTransferComplete( CreateEvent( NULL, FALSE, FALSE, NULL ) );

    // Write to the file using various buffer sizes.
    // Size must be integer multiple of device sector size
    CXBStorageDevice dev( GetDrive( devType ) );
    for( DWORD dwBufferSize = dev.GetSectorSize(); dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        // Open the test file in async mode
        File fileWrite;
        VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE,
                                FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING ) );

        // Prepare the overlapped struct
        m_Overlapped.Offset = 0;
        m_Overlapped.OffsetHigh = 0;
        m_Overlapped.hEvent = this;

        DWORD dwTotalWritten = 0;
        FLOAT fTotal = 0.0f;
        for( ;; )
        {
            // Offset must be integer multiple of sector size
            assert( m_Overlapped.Offset % dev.GetSectorSize() == 0 );

            // Initiate the write
            FLOAT fElapsed;
            VERIFY( fileWrite.WriteAsyncCallback( pBuffer, dwBufferSize, 
                                                  fElapsed, m_Overlapped, 
                                                  BytesTransferred ) );
            assert( GetLastError() == ERROR_SUCCESS );
            fTotal += fElapsed;

            // Other work would normally occur here, but we're benchmarking, so
            // don't want to influence results

            // Wait for the write to complete. Note that hTransferComplete is never
            // signalled -- we're really waiting on the completion of the callback
            CXBStopWatch timer( TRUE );
            VERIFY( WaitForSingleObjectEx( hTransferComplete, INFINITE, TRUE )
                    == WAIT_IO_COMPLETION );

            fTotal += timer.GetElapsedSeconds();
            dwTotalWritten += m_dwBytesTransferred;
            if( dwTotalWritten >= TEST_FILE_SIZE )
                break;

            // Write to the next section of the file
            m_Overlapped.Offset += dwBufferSize;

            ShowStatus( dwBufferSize, FLOAT(dwTotalWritten) / FLOAT(TEST_FILE_SIZE) );
        }
        fileResults.Write( dwBufferSize, fTotal );
    }
}




//-----------------------------------------------------------------------------
// Name: ApiCompare()
// Desc: Compare Xbox vs C vs C++ API overhead
//-----------------------------------------------------------------------------
VOID BenchStorage::ApiCompare( DeviceType devType )
{
    ApiOpen( devType );
    ApiClose( devType );
    ApiRead( devType );
    ApiWrite( devType );
    ApiSeek( devType );
}




//-----------------------------------------------------------------------------
// Name: ApiOpen()
// Desc: Compare open routines
//-----------------------------------------------------------------------------
VOID BenchStorage::ApiOpen( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strAPI_OPEN_FILE, 
                  "ApiOpen", L"Compare open APIs",
                  "Number of attempts", "Native CreateFile (seconds)",
                  "C fopen (seconds)", "C++ filebuf open (seconds)" ) )
        return;

    CXBStopWatch NativeTimer( FALSE );
    CXBStopWatch CTimer( FALSE );
    CXBStopWatch CppTimer( FALSE );
    for( DWORD i = 0; i < API_PASSES; ++i )
    {
        // Xbox API
        NativeTimer.Start();
        HANDLE hFile = CreateFile( fileTest.GetFileName(), 
                                   GENERIC_READ | GENERIC_WRITE, 0,
                                   NULL, OPEN_ALWAYS, 0, NULL );
        NativeTimer.Stop();
        assert( hFile != INVALID_HANDLE_VALUE );
        CloseHandle( hFile );

        // Standard C
        CTimer.Start();
        FILE* pFile = fopen( fileTest.GetFileName(), "rb+" );
        CTimer.Stop();
        assert( pFile != NULL );
        fclose( pFile );

        // Standard C++
        using namespace std;
        basic_fstream<BYTE> file;
        CppTimer.Start();
        file.open( fileTest.GetFileName(), ios::in | ios::out | ios::binary );
        CppTimer.Stop();
        assert( file.is_open() );
        file.close();

        ShowStatus( FLOAT( i ) / FLOAT( API_PASSES ) );
    }
    fileResults.Write( API_PASSES, NativeTimer.GetElapsedSeconds(),
                       CTimer.GetElapsedSeconds(), CppTimer.GetElapsedSeconds() );
}




//-----------------------------------------------------------------------------
// Name: ApiClose()
// Desc: Compare close routines
//-----------------------------------------------------------------------------
VOID BenchStorage::ApiClose( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strAPI_CLOSE_FILE, 
                  "ApiClose", L"Compare close APIs", "Number of attempts",
                  "Native CloseHandle (seconds)", "C fclose (seconds)", 
                  "C++ filebuf close (seconds)" ) )
        return;

    CXBStopWatch NativeTimer( FALSE );
    CXBStopWatch CTimer( FALSE );
    CXBStopWatch CppTimer( FALSE );
    for( DWORD i = 0; i < API_PASSES; ++i )
    {
        // Xbox API
        HANDLE hFile = CreateFile( fileTest.GetFileName(), 
                                   GENERIC_READ | GENERIC_WRITE, 0,
                                   NULL, OPEN_ALWAYS, 0, NULL );
        assert( hFile != INVALID_HANDLE_VALUE );
        NativeTimer.Start();
        CloseHandle( hFile );
        NativeTimer.Stop();

        // Standard C
        FILE* pFile = fopen( fileTest.GetFileName(), "rb+" );
        assert( pFile != NULL );
        CTimer.Start();
        fclose( pFile );
        CTimer.Stop();

        // Standard C++
        using namespace std;
        basic_fstream<BYTE> file;
        file.open( fileTest.GetFileName(), ios::in | ios::out | ios::binary );
        assert( file.is_open() );
        CppTimer.Start();
        file.close();
        CppTimer.Stop();

        ShowStatus( FLOAT( i ) / FLOAT( API_PASSES ) );
    }
    fileResults.Write( API_PASSES, NativeTimer.GetElapsedSeconds(),
                       CTimer.GetElapsedSeconds(), CppTimer.GetElapsedSeconds() );
}




//-----------------------------------------------------------------------------
// Name: ApiRead()
// Desc: Compare read routines
//-----------------------------------------------------------------------------
VOID BenchStorage::ApiRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strAPI_READ_FILE, 
                  "ApiRead", L"Compare read APIs", "Buffer Size (bytes)",
                  "Native ReadFile (seconds)", "C fread (seconds)", 
                  "C++ fstream read (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( TEST_FILE_SIZE );

    for( DWORD dwBufferSize = MIN_BUFFER_SIZE_API; dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        DWORD dwTotalRead = 0;

        // Xbox method
        DWORD dwXboxTotalRead = 0;
        FLOAT fTotal = 0.0f;
        File fileRead;
        VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ ) );
        for( ;; )
        {
            // ReadFile API
            DWORD dwBytesRead;
            FLOAT fElapsed;
            VERIFY( fileRead.Read( pBuffer, dwBufferSize, 
                                   dwBytesRead, fElapsed ) );
            assert( dwBytesRead == dwBufferSize );
            assert( TestFile::IsValid( pBuffer, dwBytesRead ) );
            fTotal += fElapsed;
            dwXboxTotalRead += dwBytesRead;
            if( dwXboxTotalRead >= TEST_FILE_SIZE )
                break;

            dwTotalRead += dwBytesRead;
            ShowStatus( dwBufferSize, FLOAT(dwTotalRead) / FLOAT(TEST_FILE_SIZE*3) );
        }
        fileRead.Close();

        // Standard C
        DWORD dwCTotalRead = 0;
        CXBStopWatch CTimer( FALSE );
        FILE* pFile = fopen( fileTest.GetFileName(), "rb+" );
        assert( pFile != NULL );
        for( ;; )
        {
            // fread API
            CTimer.Start();
            size_t nBytes = fread( pBuffer, 1, dwBufferSize, pFile );
            CTimer.Stop();
            assert( nBytes == dwBufferSize );
            assert( TestFile::IsValid( pBuffer, nBytes ) );
            dwCTotalRead += nBytes;
            if( dwCTotalRead >= TEST_FILE_SIZE )
                break;

            dwTotalRead += nBytes;
            ShowStatus( dwBufferSize, FLOAT(dwTotalRead) / FLOAT(TEST_FILE_SIZE*3) );
        }
        fclose( pFile );

        // Standard C++
        DWORD dwCppTotalRead = 0;
        CXBStopWatch CppTimer( FALSE );
        using namespace std;
        basic_fstream<BYTE> file;
        file.open( fileTest.GetFileName(), ios::in | ios::out | ios::binary );
        assert( file.is_open() );
        for( ;; )
        {
            // read API
            CppTimer.Start();
            file.read( pBuffer, dwBufferSize );
            CppTimer.Stop();
            assert( file.good() );
            assert( TestFile::IsValid( pBuffer, dwBufferSize ) );
            dwCppTotalRead += dwBufferSize;
            if( dwCppTotalRead >= TEST_FILE_SIZE )
                break;

            dwTotalRead += dwBufferSize;
            ShowStatus( dwBufferSize, FLOAT(dwTotalRead) / FLOAT(TEST_FILE_SIZE*3) );
        }
        file.close();

        fileResults.Write( dwBufferSize, fTotal, CTimer.GetElapsedSeconds(), 
                           CppTimer.GetElapsedSeconds() );
    }
}




//-----------------------------------------------------------------------------
// Name: ApiWrite()
// Desc: Compare write routines
//-----------------------------------------------------------------------------
VOID BenchStorage::ApiWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strAPI_WRITE_FILE, 
                  "ApiWrite", L"Compare write APIs", "Buffer Size (bytes)",
                  "Native WriteFile (seconds)", "C fwrite (seconds)", 
                  "C++ fstream write (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( TEST_FILE_SIZE );

    for( DWORD dwBufferSize = MIN_BUFFER_SIZE_API; dwBufferSize <= MAX_BUFFER_SIZE; 
         dwBufferSize *= 2 )
    {
        DWORD dwTotalWritten = 0;

        // Xbox method
        DWORD dwXboxTotalWritten = 0;
        FLOAT fTotal = 0.0f;
        File fileWrite;
        VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE ) );
        for( ;; )
        {
            // WriteFile API
            DWORD dwBytesWritten;
            FLOAT fElapsed;
            VERIFY( fileWrite.Write( pBuffer, dwBufferSize, 
                                     dwBytesWritten, fElapsed ) );
            assert( dwBytesWritten == dwBufferSize );
            fTotal += fElapsed;
            dwXboxTotalWritten += dwBytesWritten;
            if( dwXboxTotalWritten >= TEST_FILE_SIZE )
                break;

            dwTotalWritten += dwBytesWritten;
            ShowStatus( dwBufferSize, FLOAT(dwTotalWritten) / FLOAT(TEST_FILE_SIZE*3) );
        }
        fileWrite.Close();

        // Standard C
        DWORD dwCTotalWritten = 0;
        CXBStopWatch CTimer( FALSE );
        FILE* pFile = fopen( fileTest.GetFileName(), "rb+" );
        assert( pFile != NULL );
        for( ;; )
        {
            // fwrite API
            CTimer.Start();
            size_t nBytes = fwrite( pBuffer, 1, dwBufferSize, pFile );
            CTimer.Stop();
            assert( nBytes == dwBufferSize );
            dwCTotalWritten += nBytes;
            if( dwCTotalWritten >= TEST_FILE_SIZE )
                break;

            dwTotalWritten += nBytes;
            ShowStatus( dwBufferSize, FLOAT(dwTotalWritten) / FLOAT(TEST_FILE_SIZE*3) );
        }
        fclose( pFile );

        // Standard C++
        DWORD dwCppTotalWritten = 0;
        CXBStopWatch CppTimer( FALSE );
        using namespace std;
        basic_fstream<BYTE> file;
        file.open( fileTest.GetFileName(), ios::in | ios::out | ios::binary );
        assert( file.is_open() );
        for( ;; )
        {
            // write API
            CppTimer.Start();
            file.write( pBuffer, dwBufferSize );
            CppTimer.Stop();
            assert( file.good() );
            dwCppTotalWritten += dwBufferSize;
            if( dwCppTotalWritten >= TEST_FILE_SIZE )
                break;

            dwTotalWritten += dwBufferSize;
            ShowStatus( dwBufferSize, FLOAT(dwTotalWritten) / FLOAT(TEST_FILE_SIZE*3) );
        }
        file.close();

        fileResults.Write( dwBufferSize, fTotal, CTimer.GetElapsedSeconds(), 
                           CppTimer.GetElapsedSeconds() );
    }
}




//-----------------------------------------------------------------------------
// Name: ApiSeek()
// Desc: Compare seek routines
//-----------------------------------------------------------------------------
VOID BenchStorage::ApiSeek( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strAPI_SEEK_FILE, 
                  "ApiSeek", L"Compare seek APIs", "Number of attempts",
                  "Native SetFilePos (seconds)", "C fseek (seconds)", 
                  "C++ fstream seek (seconds)" ) )
        return;

    // Construct a list of random seek offsets to be used for all test passes
    std::vector<DWORD> SeekList;
    SeekList.reserve( API_PASSES );
    srand( m_dwSeed );
    DWORD dwLastOffset = 0;
    for( DWORD i = 0; i < API_PASSES; ++i )
    {
        // Generate a random new seek position
        INT iPos = rand() * rand();

        // Determine if we should seek forward or backward.
        // Tend to progress forward more often than backward
        BOOL bForward = ( rand() % 3 ) > 0;

        // Wrap to beginning if go past the end of the file
        DWORD dwOffset = dwLastOffset + ( bForward ? iPos : -iPos );
        if( dwOffset > TEST_FILE_SIZE )
            dwOffset = 0;
        dwLastOffset = dwOffset;

        SeekList.push_back( dwOffset );
    }

    // Create a small buffer
    BYTE pBuffer[4];

    DWORD dwPasses = 0;

    // Xbox method
    CXBStopWatch XboxTimer( FALSE );
    File fileRead;
    VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ ) );
    for( DWORD i = 0; i < API_PASSES; ++i, ++dwPasses )
    {
        DWORD dwOffset = SeekList[i];

        // SetFilePos
        XboxTimer.Start();
        fileRead.SetPos( dwOffset );
        XboxTimer.Stop();

        // Do a read to force the seek to occur
        DWORD dwBytesRead;
        FLOAT fElapsed;
        VERIFY( fileRead.Read( pBuffer, 4, dwBytesRead, fElapsed ) );
        ShowStatus( FLOAT(dwPasses) / FLOAT(API_PASSES*3) );
    }
    fileRead.Close();

    // Standard C
    CXBStopWatch CTimer( FALSE );
    FILE* pFile = fopen( fileTest.GetFileName(), "rb+" );
    assert( pFile != NULL );
    for( DWORD i = 0; i < API_PASSES; ++i, ++dwPasses )
    {
        DWORD dwOffset = SeekList[i];

        // fseek API
        CTimer.Start();
        VERIFY( fseek( pFile, dwOffset, SEEK_SET ) == 0 );
        CTimer.Stop();

        // Do a read to force the seek to occur
        VERIFY( fread( pBuffer, 1, 4, pFile ) == 4 );
        ShowStatus( FLOAT(dwPasses) / FLOAT(API_PASSES*3) );
    }
    fclose( pFile );

    // Standard C++
    CXBStopWatch CppTimer( FALSE );
    using namespace std;
    basic_fstream<BYTE> file;
    file.open( fileTest.GetFileName(), ios::in | ios::out | ios::binary );
    assert( file.is_open() );
    for( DWORD i = 0; i < API_PASSES; ++i, ++dwPasses )
    {
        DWORD dwOffset = SeekList[i];

        // seek API
        CppTimer.Start();
        file.seekg( dwOffset );
        CppTimer.Stop();
        assert( file.good() );

        // Do a read to force the seek to occur
        file.read( pBuffer, 4 );
        assert( file.good() );
        ShowStatus( FLOAT(dwPasses) / FLOAT(API_PASSES*3) );
    }
    file.close();

    fileResults.Write( API_PASSES, XboxTimer.GetElapsedSeconds(), 
                       CTimer.GetElapsedSeconds(),
                       CppTimer.GetElapsedSeconds() );
}




//-----------------------------------------------------------------------------
// Name: RandomSeek()
// Desc: Evaluate random seek time within a file
//-----------------------------------------------------------------------------
VOID BenchStorage::RandomSeek( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strRANDOM_SEEK_FILE, 
                  "RandomSeek", L"Random Seek within a File", 
                  "Seeks", "Total Seek Time (seconds)" ) )
        return;

    File fileRead;
    VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ ) );

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    DWORD dwSeeks = ( devType == Device_MU ) ? MAX_RANDOM_SEEKS / 10 :
                                               MAX_RANDOM_SEEKS;

    // Seek to various positions
    srand( m_dwSeed );
    FLOAT fTotal = 0.0f;
    for( DWORD i = 0; i < dwSeeks; ++i )
    {
        // Get random position
        INT iPos = rand() * rand();

        // Restrict offset to file size
        DWORD dwOffset = iPos % TEST_FILE_SIZE;

        // Time the seek
        CXBStopWatch timer( TRUE );
        fileRead.SetPos( dwOffset );
        fTotal += timer.GetElapsedSeconds();

        // Do a read to "force" the seek
        DWORD dwBytesRead;
        FLOAT fElapsed;
        VERIFY( fileRead.Read( pBuffer, 1, dwBytesRead, fElapsed ) );

        swprintf( m_strStatus, L"Progress: %.0f %%",
                  100.0f * FLOAT(i) / FLOAT(dwSeeks) );
        ShowStatus();
    }

    fileResults.Write( dwSeeks, fTotal );
}




//-----------------------------------------------------------------------------
// Name: SeqSeek()
// Desc: Evaluate random seek time within a file
//-----------------------------------------------------------------------------
VOID BenchStorage::SeqSeek( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strSEQ_SEEK_FILE, 
                  "SeqSeek", L"Sequential Seek within a File", 
                  "Seeks", "Total Seek Time (seconds)" ) )
        return;

    File fileRead;
    VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ ) );

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    DWORD dwSeeks = ( devType == Device_MU ) ? MAX_SEQUENTIAL_SEEKS / 10 :
                                               MAX_SEQUENTIAL_SEEKS;

    // Seek to various positions
    srand( m_dwSeed );
    FLOAT fTotal = 0.0f;
    DWORD dwLastOffset = 0;
    for( DWORD i = 0; i < dwSeeks; ++i )
    {
        // Generate a random new sequential position.
        // Wrap to beginning if go past the end of the file.
        INT iPos = rand();
        DWORD dwOffset = dwLastOffset + iPos;
        if( dwOffset > TEST_FILE_SIZE )
            dwOffset = 0;
        dwLastOffset = dwOffset;

        // Time the seek
        CXBStopWatch timer( TRUE );
        fileRead.SetPos( dwOffset );
        fTotal += timer.GetElapsedSeconds();

        // Do a read to "force" the seek
        DWORD dwBytesRead;
        FLOAT fElapsed;
        VERIFY( fileRead.Read( pBuffer, 1, dwBytesRead, fElapsed ) );

        swprintf( m_strStatus, L"Progress: %.0f %%",
                  100.0f * FLOAT(i) / FLOAT(dwSeeks) );
        ShowStatus();
    }

    fileResults.Write( dwSeeks, fTotal );
}




//-----------------------------------------------------------------------------
// Name: RandomRead()
// Desc: Evaluate random seeks/reads within a file with and without the
//       FILE_FLAG_RANDOM_ACCESS setting
//-----------------------------------------------------------------------------
VOID BenchStorage::RandomRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strRANDOM_READ_FILE, 
                  "RandomRead", L"Random Read within a File",
                  "Read Time w/ no flags (seconds)", 
                  "Read Time w/ FILE_FLAG_SEQUENTIAL_SCAN (seconds)", 
                  "Read Time w/ FILE_FLAG_RANDOM_ACCESS (seconds)" ) )
        return;

    DWORD dwReads = ( devType == Device_MU ) ? MAX_RANDOM_READS / 10 :
                                               MAX_RANDOM_READS;

    FLOAT fTotalNone = RandomRead( fileTest, dwReads, 0, L"<empty>" );
    FLOAT fTotalSeq  = RandomRead( fileTest, dwReads, FILE_FLAG_SEQUENTIAL_SCAN, 
                                   L"FILE_FLAG_SEQUENTIAL_SCAN" );
    FLOAT fTotalRand = RandomRead( fileTest, dwReads, FILE_FLAG_RANDOM_ACCESS, 
                                   L"FILE_FLAG_RANDOM_ACCESS" );

    fileResults.Write( fTotalNone, fTotalSeq, fTotalRand );
}




//-----------------------------------------------------------------------------
// Name: RandomRead()
// Desc: Perform random seeks and reads within a file and return the
//       elapsed time
//-----------------------------------------------------------------------------
FLOAT BenchStorage::RandomRead( const TestFile& fileTest, DWORD dwReads,
                                DWORD dwFlags, const WCHAR* strFlag, 
                                DWORD dwCache )
{
    File fileRead;
    VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ, dwFlags ) );

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Read various positions and buffer sizes
    srand( m_dwSeed );
    FLOAT fTotal = 0.0f;
    for( DWORD i = 0; i < dwReads; ++i )
    {
        // Get random position and size
        INT iPos = rand() * rand();
        INT iSize = rand() * rand();

        // Restrict offset and size
        DWORD dwOffset = iPos % TEST_FILE_SIZE;
        DWORD dwLength = iSize % MAX_BUFFER_SIZE;

        // Time the seek
        CXBStopWatch timer( TRUE );
        fileRead.SetPos( dwOffset );
        fTotal += timer.GetElapsedSeconds();

        // Time the read
        DWORD dwBytesRead;
        FLOAT fElapsed;
        VERIFY( fileRead.Read( pBuffer, dwLength, dwBytesRead, fElapsed ) );
        fTotal += fElapsed;

        if( dwCache )
        {
            swprintf( m_strStatus, L"Cache size: %lu\nProgress: %.0f %%",
                      dwCache, 100.0f * FLOAT(i) / FLOAT(dwReads) );
        }
        else
        {
            swprintf( m_strStatus, L"Flag: %s\nProgress: %.0f %%",
                      strFlag, 100.0f * FLOAT(i) / FLOAT(dwReads) );
        }
        ShowStatus();
    }
    return fTotal;
}




//-----------------------------------------------------------------------------
// Name: RandomWrite()
// Desc: Evaluate random seeks/writes within a file with and without the
//       FILE_FLAG_RANDOM_ACCESS setting
//-----------------------------------------------------------------------------
VOID BenchStorage::RandomWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strRANDOM_WRITE_FILE, 
                  "RandomWrite", L"Random Write within a File",
                  "Write Time w/ no flags (seconds)", 
                  "Write Time w/ FILE_FLAG_SEQUENTIAL_SCAN (seconds)", 
                  "Write Time w/ FILE_FLAG_RANDOM_ACCESS (seconds)" ) )
        return;

    DWORD dwWrites = ( devType == Device_MU ) ? MAX_RANDOM_WRITES / 10 :
                                                MAX_RANDOM_WRITES;

    FLOAT fTotalNone = RandomWrite( fileTest, dwWrites, 0, L"<empty>" );
    FLOAT fTotalSeq  = RandomWrite( fileTest, dwWrites, FILE_FLAG_SEQUENTIAL_SCAN, 
                                    L"FILE_FLAG_SEQUENTIAL_SCAN" );
    FLOAT fTotalRand = RandomWrite( fileTest, dwWrites, FILE_FLAG_RANDOM_ACCESS, 
                                    L"FILE_FLAG_RANDOM_ACCESS" );

    fileResults.Write( fTotalNone, fTotalSeq, fTotalRand );
}




//-----------------------------------------------------------------------------
// Name: RandomWrite()
// Desc: Perform random seeks and writes within a file and return the
//       elapsed time
//-----------------------------------------------------------------------------
FLOAT BenchStorage::RandomWrite( const TestFile& fileTest, DWORD dwWrites,
                                 DWORD dwFlags, const WCHAR* strFlag, 
                                 DWORD dwCache )
{
    File fileWrite;
    VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE, dwFlags ) );

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Write various positions and buffer sizes
    srand( m_dwSeed );
    FLOAT fTotal = 0.0f;
    for( DWORD i = 0; i < dwWrites; ++i )
    {
        // Get random position and size
        INT iPos = rand() * rand();
        INT iSize = rand() * rand();

        // Restrict offset and size
        DWORD dwOffset = iPos % TEST_FILE_SIZE;
        DWORD dwLength = iSize % MAX_BUFFER_SIZE;

        // Time the seek
        CXBStopWatch timer( TRUE );
        fileWrite.SetPos( dwOffset );
        fTotal += timer.GetElapsedSeconds();

        // Time the write
        DWORD dwBytesWritten;
        FLOAT fElapsed;
        VERIFY( fileWrite.Write( pBuffer, dwLength, dwBytesWritten, fElapsed ) );
        fTotal += fElapsed;

        if( dwCache )
        {
            swprintf( m_strStatus, L"Cache size: %lu\nProgress: %.0f %%",
                      dwCache, 100.0f * FLOAT(i) / FLOAT(dwWrites) );
        }
        else
        {
            swprintf( m_strStatus, L"Flag: %s\nProgress: %.0f %%",
                      strFlag, 100.0f * FLOAT(i) / FLOAT(dwWrites) );
        }
        ShowStatus();
    }
    return fTotal;
}




//-----------------------------------------------------------------------------
// Name: SeqRead()
// Desc: Evaluate sequential reads within a file with and without the
//       FILE_FLAG_SEQUENTIAL_SCAN setting
//-----------------------------------------------------------------------------
VOID BenchStorage::SeqRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strSEQ_READ_FILE, 
                  "SequentialRead", L"Sequential Read within a File",
                  "Read Time w/ no flags (seconds)", 
                  "Read Time w/ FILE_FLAG_SEQUENTIAL_SCAN (seconds)", 
                  "Read Time w/ FILE_FLAG_RANDOM_ACCESS (seconds)" ) )
        return;

    DWORD dwReads = ( devType == Device_MU ) ? MAX_SEQUENTIAL_READS / 10 :
                                               MAX_SEQUENTIAL_READS;

    FLOAT fTotalNone = SeqRead( fileTest, dwReads, 0, L"<empty>" );
    FLOAT fTotalSeq  = SeqRead( fileTest, dwReads, FILE_FLAG_SEQUENTIAL_SCAN, 
                                L"FILE_FLAG_SEQUENTIAL_SCAN" );
    FLOAT fTotalRand = SeqRead( fileTest, dwReads, FILE_FLAG_RANDOM_ACCESS, 
                                L"FILE_FLAG_RANDOM_ACCESS" );

    fileResults.Write( fTotalNone, fTotalSeq, fTotalRand );
}




//-----------------------------------------------------------------------------
// Name: SeqRead()
// Desc: Perform sequential seeks and reads within a file and return the
//       elapsed time
//-----------------------------------------------------------------------------
FLOAT BenchStorage::SeqRead( const TestFile& fileTest, DWORD dwReads,
                             DWORD dwFlags, const WCHAR* strFlag, DWORD dwCache )
{
    File fileRead;
    VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ, dwFlags ) );

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Read various sequential positions and buffer sizes
    srand( m_dwSeed );
    FLOAT fTotal = 0.0f;
    DWORD dwLastOffset = 0;
    for( DWORD i = 0; i < dwReads; ++i )
    {
        // Generate a random new sequential position.
        // Wrap to beginning if go past the end of the file.
        INT iPos = rand();
        DWORD dwOffset = dwLastOffset + iPos;
        if( dwOffset > TEST_FILE_SIZE )
            dwOffset = 0;
        dwLastOffset = dwOffset;

        // Get random size
        INT iSize = rand();
        DWORD dwLength = iSize % MAX_BUFFER_SIZE;

        // Time the seek
        CXBStopWatch timer( TRUE );
        fileRead.SetPos( dwOffset );
        fTotal += timer.GetElapsedSeconds();

        // Time the read
        DWORD dwBytesRead;
        FLOAT fElapsed;
        VERIFY( fileRead.Read( pBuffer, dwLength, dwBytesRead, fElapsed ) );
        fTotal += fElapsed;

        if( dwCache )
        {
            swprintf( m_strStatus, L"Cache size: %lu\nProgress: %.0f %%",
                      dwCache, 100.0f * FLOAT(i) / FLOAT(dwReads) );
        }
        else
        {
            swprintf( m_strStatus, L"Flag: %s\nProgress: %.0f %%",
                      strFlag, 100.0f * FLOAT(i) / FLOAT(dwReads) );
        }
        ShowStatus();
    }
    return fTotal;
}




//-----------------------------------------------------------------------------
// Name: SeqWrite()
// Desc: Evaluate sequential writes within a file with and without the
//       FILE_FLAG_SEQUENTIAL_SCAN setting
//-----------------------------------------------------------------------------
VOID BenchStorage::SeqWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strSEQ_WRITE_FILE, 
                  "SequentialWrite", L"Sequential Write within a File",
                  "Write Time w/ no flags (seconds)", 
                  "Write Time w/ FILE_FLAG_SEQUENTIAL_SCAN (seconds)", 
                  "Write Time w/ FILE_FLAG_RANDOM_ACCESS (seconds)" ) )
        return;

    DWORD dwWrites = ( devType == Device_MU ) ? MAX_SEQUENTIAL_WRITES / 10 :
                                                MAX_SEQUENTIAL_WRITES;

    FLOAT fTotalNone = SeqWrite( fileTest, dwWrites, 0, L"<empty>" );
    FLOAT fTotalSeq  = SeqWrite( fileTest, dwWrites, FILE_FLAG_SEQUENTIAL_SCAN, 
                                 L"FILE_FLAG_SEQUENTIAL_SCAN" );
    FLOAT fTotalRand = SeqWrite( fileTest, dwWrites, FILE_FLAG_RANDOM_ACCESS, 
                                 L"FILE_FLAG_RANDOM_ACCESS" );

    fileResults.Write( fTotalNone, fTotalSeq, fTotalRand );
}




//-----------------------------------------------------------------------------
// Name: SeqWrite()
// Desc: Perform sequential seeks and writeswithin a file and return the
//       elapsed time
//-----------------------------------------------------------------------------
FLOAT BenchStorage::SeqWrite( const TestFile& fileTest, DWORD dwWrites,
                              DWORD dwFlags, const WCHAR* strFlag, DWORD dwCache )
{
    File fileWrite;
    VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE, dwFlags ) );

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( MAX_BUFFER_SIZE );

    // Write various sequential positions and buffer sizes
    srand( m_dwSeed );
    FLOAT fTotal = 0.0f;
    DWORD dwLastOffset = 0;
    for( DWORD i = 0; i < dwWrites; ++i )
    {
        // Generate a random new sequential position.
        // Wrap to beginning if go past the end of the file.
        INT iPos = rand();
        DWORD dwOffset = dwLastOffset + iPos;
        if( dwOffset > TEST_FILE_SIZE )
            dwOffset = 0;
        dwLastOffset = dwOffset;

        // Get random size
        INT iSize = rand();
        DWORD dwLength = iSize % MAX_BUFFER_SIZE;

        // Time the seek
        CXBStopWatch timer( TRUE );
        fileWrite.SetPos( dwOffset );
        fTotal += timer.GetElapsedSeconds();

        // Time the write
        DWORD dwBytesWritten;
        FLOAT fElapsed;
        VERIFY( fileWrite.Write( pBuffer, dwLength, dwBytesWritten, fElapsed ) );
        fTotal += fElapsed;

        if( dwCache )
        {
            swprintf( m_strStatus, L"Cache size: %lu\nProgress: %.0f %%",
                      dwCache, 100.0f * FLOAT(i) / FLOAT(dwWrites) );
        }
        else
        {
            swprintf( m_strStatus, L"Flag: %s\nProgress: %.0f %%",
                      strFlag, 100.0f * FLOAT(i) / FLOAT(dwWrites) );
        }
        ShowStatus();
    }
    return fTotal;
}




//-----------------------------------------------------------------------------
// Name: CacheRead()
// Desc: Evaluate cache performance for various read situations
//-----------------------------------------------------------------------------
VOID BenchStorage::CacheRead( DeviceType devType )
{
    CacheRandomRead( devType );
    CacheSeqRead( devType );
}




//-----------------------------------------------------------------------------
// Name: CacheRandomRead()
// Desc: Evaluate cache performance for random reads
//-----------------------------------------------------------------------------
VOID BenchStorage::CacheRandomRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strCACHE_RANDOM_READ_FILE, 
                  "CacheRandomRead", L"Cache Random Read within a File",
                  "Read Time w/ FILE_FLAG_RANDOM_ACCESS (seconds)" ) )
        return;

    DWORD dwReads = ( devType == Device_MU ) ? MAX_RANDOM_READS / 10 :
                                               MAX_RANDOM_READS;

    // Use default size first
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
    FLOAT fElapsed = RandomRead( fileTest, dwReads, FILE_FLAG_RANDOM_ACCESS, L"",
                                 m_dwDefaultCacheSize );
    fileResults.Write( m_dwDefaultCacheSize, fElapsed );

    // Try some different sizes    
    for( DWORD i = MIN_CACHE_SIZE; i <= MAX_CACHE_SIZE; i *= 2 )
    {
        VERIFY( XSetFileCacheSize( i ) );
        fElapsed = RandomRead( fileTest, dwReads, FILE_FLAG_RANDOM_ACCESS, 
                               L"", i );
        fileResults.Write( i, fElapsed );
    }

    // Restore default
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
}




//-----------------------------------------------------------------------------
// Name: CacheSeqRead()
// Desc: Evaluate cache performance for sequential reads
//-----------------------------------------------------------------------------
VOID BenchStorage::CacheSeqRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strCACHE_SEQ_READ_FILE, 
                  "CacheSeqRead", L"Cache Sequential Read within a File",
                  "Read Time w/ FILE_FLAG_SEQUENTIAL_SCAN (seconds)" ) )
        return;

    DWORD dwReads = ( devType == Device_MU ) ? MAX_SEQUENTIAL_READS / 10 :
                                               MAX_SEQUENTIAL_READS;

    // Use default size first
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
    FLOAT fElapsed = SeqRead( fileTest, dwReads, FILE_FLAG_SEQUENTIAL_SCAN, L"",
                              m_dwDefaultCacheSize );
    fileResults.Write( m_dwDefaultCacheSize, fElapsed );

    // Try some different sizes    
    for( DWORD i = MIN_CACHE_SIZE; i <= MAX_CACHE_SIZE; i *= 2 )
    {
        VERIFY( XSetFileCacheSize( i ) );
        fElapsed = SeqRead( fileTest, dwReads, FILE_FLAG_SEQUENTIAL_SCAN, L"", i );
        fileResults.Write( i, fElapsed );
    }

    // Restore default
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
}




//-----------------------------------------------------------------------------
// Name: CacheWrite()
// Desc: Evaluate cache performance for various write situations
//-----------------------------------------------------------------------------
VOID BenchStorage::CacheWrite( DeviceType devType )
{
    CacheRandomWrite( devType );
    CacheSeqWrite( devType );
}




//-----------------------------------------------------------------------------
// Name: CacheRandomWrite()
// Desc: Evaluate cache performance for random writes
//-----------------------------------------------------------------------------
VOID BenchStorage::CacheRandomWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strCACHE_RANDOM_WRITE_FILE, 
                  "CacheRandomWrite", L"Cache Random Write within a File",
                  "Write Time w/ FILE_FLAG_RANDOM_ACCESS (seconds)" ) )
        return;

    DWORD dwWrites = ( devType == Device_MU ) ? MAX_RANDOM_WRITES / 10 :
                                                MAX_RANDOM_WRITES;

    // Use default size first
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
    FLOAT fElapsed = RandomWrite( fileTest, dwWrites, FILE_FLAG_RANDOM_ACCESS, 
                                  L"", m_dwDefaultCacheSize );
    fileResults.Write( m_dwDefaultCacheSize, fElapsed );

    // Try some different sizes    
    for( DWORD i = MIN_CACHE_SIZE; i <= MAX_CACHE_SIZE; i *= 2 )
    {
        VERIFY( XSetFileCacheSize( i ) );
        fElapsed = RandomWrite( fileTest, dwWrites, FILE_FLAG_RANDOM_ACCESS, 
                                L"", i );
        fileResults.Write( i, fElapsed );
    }

    // Restore default
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
}




//-----------------------------------------------------------------------------
// Name: CacheSeqWrite()
// Desc: Evaluate cache performance for sequential writes
//-----------------------------------------------------------------------------
VOID BenchStorage::CacheSeqWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strCACHE_SEQ_WRITE_FILE, 
                  "CacheSeqWrite", L"Cache Sequential Write within a File",
                  "Write Time w/ FILE_FLAG_SEQUENTIAL_SCAN (seconds)" ) )
        return;

    DWORD dwWrites = ( devType == Device_MU ) ? MAX_SEQUENTIAL_WRITES / 10 :
                                                MAX_SEQUENTIAL_WRITES;

    // Use default size first
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
    FLOAT fElapsed = SeqWrite( fileTest, dwWrites, FILE_FLAG_SEQUENTIAL_SCAN, L"",
                               m_dwDefaultCacheSize );
    fileResults.Write( m_dwDefaultCacheSize, fElapsed );

    // Try some different sizes    
    for( DWORD i = MIN_CACHE_SIZE; i <= MAX_CACHE_SIZE; i *= 2 )
    {
        VERIFY( XSetFileCacheSize( i ) );
        fElapsed = SeqWrite( fileTest, dwWrites, FILE_FLAG_SEQUENTIAL_SCAN, 
                             L"", i );
        fileResults.Write( i, fElapsed );
    }

    // Restore default
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );
}




//-----------------------------------------------------------------------------
// Name: RegionRead()
// Desc: Evaluate the read speed of the different regions on the hard drive
//-----------------------------------------------------------------------------
VOID BenchStorage::RegionRead()
{
    RegionRead( Device_HD_User );
    RegionRead( Device_HD_Persist );
    RegionRead( Device_HD_Utility );
}




//-----------------------------------------------------------------------------
// Name: RegionRead()
// Desc: Evaluate the read speed of the given drive (region)
//-----------------------------------------------------------------------------
VOID BenchStorage::RegionRead( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strREGION_READ_FILE, 
                  "RegionRead", L"Region Read Speed",
                  "Buffer Size (bytes)", "Read Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( m_dwHdBufferSize );

    FLOAT fTotal = 0.0f;
    for( DWORD i = 0; i < REGION_PASSES; ++i )
    {
        // Open the test file
        File fileRead;
        VERIFY( fileRead.Open( fileTest.GetFileName(), GENERIC_READ ) );

        // Read the entire file sequentially
        DWORD dwTotalRead = 0;
        for( ;; )
        {
            DWORD dwRead;
            FLOAT fElapsed;
            VERIFY( fileRead.Read( pBuffer, m_dwHdBufferSize, dwRead, 
                                   fElapsed ) );
            fTotal += fElapsed;
            assert( TestFile::IsValid( pBuffer, dwRead ) );
            dwTotalRead += dwRead;
            if( dwTotalRead >= TEST_FILE_SIZE )
                break;
        }
        ShowStatus( FLOAT(i) / FLOAT(REGION_PASSES) );
    }

    fileResults.Write( m_dwHdBufferSize, fTotal );
}




//-----------------------------------------------------------------------------
// Name: RegionWrite()
// Desc: Evaluate the write speed of the different regions on the hard drive
//-----------------------------------------------------------------------------
VOID BenchStorage::RegionWrite()
{
    RegionWrite( Device_HD_User );
    RegionWrite( Device_HD_Persist );
    RegionWrite( Device_HD_Utility );
}




//-----------------------------------------------------------------------------
// Name: RegionWrite()
// Desc: Evaluate the write speed of the given drive (region)
//-----------------------------------------------------------------------------
VOID BenchStorage::RegionWrite( DeviceType devType )
{
    TestFile fileTest( GetDrive( devType ) );
    ResultsFile fileResults;
    if( !Prepare( devType, fileTest, fileResults, strREGION_WRITE_FILE, 
                  "RegionWrite", L"Region Write Speed",
                  "Buffer Size (bytes)", "Write Time (seconds)" ) )
        return;

    // Create a large buffer
    AutoHeapPtr Buffer;
    BYTE* pBuffer = Buffer.Alloc( m_dwHdBufferSize );

    FLOAT fTotal = 0.0f;
    for( DWORD i = 0; i < REGION_PASSES; ++i )
    {
        // Open the test file
        File fileWrite;
        VERIFY( fileWrite.Open( fileTest.GetFileName(), GENERIC_WRITE ) );

        // Write the entire file sequentially
        DWORD dwTotalWritten = 0;
        for( ;; )
        {
            DWORD dwWritten;
            FLOAT fElapsed;
            VERIFY( fileWrite.Write( pBuffer, m_dwHdBufferSize, 
                                     dwWritten, fElapsed ) );
            fTotal += fElapsed;
            dwTotalWritten += dwWritten;
            if( dwTotalWritten >= TEST_FILE_SIZE )
                break;
        }
        ShowStatus( FLOAT(i) / FLOAT(REGION_PASSES) );
    }

    fileResults.Write( m_dwHdBufferSize, fTotal );
}




//-----------------------------------------------------------------------------
// Name: EnumSaves()
// Desc: Evaluate the speed of enumerating saved games
//-----------------------------------------------------------------------------
VOID BenchStorage::EnumSaves( DeviceType devType )
{
    assert( devType != Device_DVD );
    CHAR chDrive = GetDrive( devType );
    ResultsFile fileResults;
    VERIFY( fileResults.Create( strENUM_SAVES_FILE, chDrive, "Saved games", 
                                "Enum speed (seconds)" ) );

    lstrcpyW( m_strStatusHdr, L"Saved Game Enumeration Speed" );
    swprintf( m_strStatus, L"Drive %c", chDrive );
    ShowStatus( TRUE );

    // Generate some fake saved games
    SavedGames savedGames( m_dwSeed, ENUM_SAVE_GAMES, chDrive );
    VERIFY( savedGames.Create() );

    // Enumerate the saves
    CHAR strDrive[4] = "x:\\";
    strDrive[0] = chDrive;

    DWORD dwSaves = 0;
    XGAME_FIND_DATA SaveGameData;
    CXBStopWatch timer( TRUE );
    HANDLE hSaveGame = XFindFirstSaveGame( strDrive, &SaveGameData );
    assert( hSaveGame != INVALID_HANDLE_VALUE );
    if( hSaveGame != INVALID_HANDLE_VALUE )
    {
        do
        {
            ++dwSaves;
            // Would normally do something with SaveGameData here,
            // but we're just evaluating the overhead of enumeration
        } while( XFindNextSaveGame( hSaveGame, &SaveGameData ) );
        VERIFY( XFindClose( hSaveGame ) );
    }
    FLOAT fElapsed = timer.GetElapsedSeconds();
    fileResults.Write( ENUM_SAVE_GAMES, fElapsed );
    assert( dwSaves == ENUM_SAVE_GAMES );
}




//-----------------------------------------------------------------------------
// Name: EnumDirs()
// Desc: Evaluate the speed of enumerating directory trees
//-----------------------------------------------------------------------------
VOID BenchStorage::EnumDirs( DeviceType devType )
{
    assert( devType != Device_DVD );
    CHAR chDrive = GetDrive( devType );
    ResultsFile fileResults;
    VERIFY( fileResults.Create( strENUM_DIRS_FILE, chDrive, 
                                "Files/Directories", 
                                "Enum speed (seconds)" ) );

    lstrcpyW( m_strStatusHdr, L"Directory Enumeration Speed" );
    swprintf( m_strStatus, L"Drive %c", chDrive );
    ShowStatus( TRUE );

    // Generate a directory tree
    SavedGames dirTree( m_dwSeed, ENUM_DIR_TREE, chDrive );
    VERIFY( dirTree.Create() );

    // Enumerate the directories
    CHAR strDrive[4] = "x:\\";
    strDrive[0] = chDrive;

    CXBStopWatch timer( TRUE );
    DWORD dwCount = EnumFiles( strDrive );
    FLOAT fElapsed = timer.GetElapsedSeconds();

    // Record the results
    fileResults.Write( dwCount, fElapsed );
}




//-----------------------------------------------------------------------------
// Name: EnumFiles()
// Desc: Recursive enumeration function; returns number of files
//-----------------------------------------------------------------------------
DWORD BenchStorage::EnumFiles( const CHAR* strDir ) // static
{
    assert( strDir != NULL );

    // Append wildcard specifier to folder
    WIN32_FIND_DATA FileData;
    lstrcpyA( FileData.cFileName, strDir );
    lstrcatA( FileData.cFileName, "*" );

    // Count all files in strDir and all subdirectories
    DWORD dwCount = 0;

    HANDLE hFile = FindFirstFile( FileData.cFileName, &FileData );
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
            // Recurse into subdirectories
            if( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                // subdir = strDir + FileData.cFileName + '\'
                CHAR strSubDir[ MAX_PATH ];
                lstrcpyA( strSubDir, strDir );
                lstrcatA( strSubDir, FileData.cFileName );
                lstrcatA( strSubDir, "\\" );
                dwCount += EnumFiles( strSubDir );
            }
            else
            {
                // We have a file
                ++dwCount;
            }

        } while( FindNextFile( hFile, &FileData ) );
        VERIFY( FindClose( hFile ) );
    }
    return dwCount;
}




//-----------------------------------------------------------------------------
// Name: EnumSoundtracks()
// Desc: Evaluate the speed of enumerating soundtracks
//-----------------------------------------------------------------------------
VOID BenchStorage::EnumSoundtracks()
{
    CHAR chDrive = GetDrive( Device_HD );
    ResultsFile fileResults;
    VERIFY( fileResults.Create( strENUM_SOUNDTRACKS_FILE, chDrive, 
                                "Songs", 
                                "Enum speed (seconds)" ) );

    lstrcpyW( m_strStatusHdr, L"Soundtrack Enumeration Speed" );
    swprintf( m_strStatus, L"Drive %c", chDrive );
    ShowStatus( TRUE );
    DWORD dwCount = 0;

    // Enumerate the soundtracks
    XSOUNDTRACK_DATA SoundtrackData;
    CXBStopWatch timer( TRUE );
    HANDLE hSoundtrack = XFindFirstSoundtrack( &SoundtrackData );
    if( hSoundtrack != INVALID_HANDLE_VALUE )
    {
        do
        {
            for( DWORD i = 0; i < SoundtrackData.uSongCount; ++i, ++dwCount )
            {
                DWORD dwSongId;
                DWORD dwSongLength;
                WCHAR strSongName[ MAX_SOUNDTRACK_NAME ];
                VERIFY( XGetSoundtrackSongInfo( 
                                    SoundtrackData.uSoundtrackId, i, 
                                    &dwSongId, &dwSongLength,
                                    strSongName, MAX_SOUNDTRACK_NAME ) );
            }        
        } while( XFindNextSoundtrack( hSoundtrack, &SoundtrackData ) );
        VERIFY( XFindClose( hSoundtrack ) );
    }

    // Record the results
    FLOAT fElapsed = timer.GetElapsedSeconds();
    fileResults.Write( dwCount, fElapsed );
}




//-----------------------------------------------------------------------------
// Name: EnumNicknames()
// Desc: Evaluate the speed of enumerating nicknames
//-----------------------------------------------------------------------------
VOID BenchStorage::EnumNicknames()
{
    CHAR chDrive = GetDrive( Device_HD );
    ResultsFile fileResults;
    VERIFY( fileResults.Create( strENUM_NICKNAMES_FILE, chDrive, 
                                "Nicknames", 
                                "Enum speed (seconds)" ) );

    lstrcpyW( m_strStatusHdr, L"Nickname Enumeration Speed" );
    swprintf( m_strStatus, L"Drive %c", chDrive );
    ShowStatus( TRUE );

    WCHAR strNickname[ MAX_NICKNAME ];

    // Generate some fake nicknames
    for( DWORD i = 0; i < MAX_NICKNAMES; ++i )
    {
        WCHAR strNum[32];
        lstrcpyW( strNickname, strNICKNAME_PREFIX );
        lstrcatW( strNickname, _itow( i, strNum, 10 ) );
        VERIFY( XSetNickname( strNickname, FALSE ) );
    }

    // Enumerate the nicknames
    DWORD dwCount = 0;
    CXBStopWatch timer( TRUE );
    HANDLE hNickname = XFindFirstNickname( FALSE, strNickname, MAX_NICKNAME );
    if( hNickname != INVALID_HANDLE_VALUE )
    {
        do
        {
            ++dwCount;
        } while ( XFindNextNickname( hNickname, strNickname, MAX_NICKNAME ) );
        VERIFY( XFindClose( hNickname ) );
    }

    // Record the results
    FLOAT fElapsed = timer.GetElapsedSeconds();
    fileResults.Write( dwCount, fElapsed );
}




//-----------------------------------------------------------------------------
// Name: EnumOpen()
// Desc: Evaluate the speed of enumerating and opening files
//-----------------------------------------------------------------------------
VOID BenchStorage::EnumOpen( DeviceType devType )
{
    assert( devType != Device_DVD );
    CHAR chDrive = GetDrive( devType );
    ResultsFile fileResults;
    VERIFY( fileResults.Create( strENUM_OPEN_FILE, chDrive, 
                                "Files/Directories", 
                                "Enum/open speed (seconds)",
                                "Enum/open optimized speed (seconds)" ) );

    lstrcpyW( m_strStatusHdr, L"File Enum/Open Speed" );
    swprintf( m_strStatus, L"Drive %c", chDrive );
    ShowStatus( TRUE );

    // Generate a directory tree
    SavedGames dirTree( m_dwSeed, ENUM_OPEN_TREE, chDrive );
    VERIFY( dirTree.Create() );

    CHAR strDrive[4] = "x:\\";
    strDrive[0] = chDrive;

    // Get a list of all the files
    FileList fileList;
    FLOAT fElapsed = EnumFiles( strDrive, fileList );

    // Open each file
    CXBStopWatch FileOpenTimer( FALSE );
    for( FileList::const_iterator i = fileList.begin(); i != fileList.end(); ++i )
    {
        FileOpenTimer.Start();
        HANDLE hFile = CreateFile( *i, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                   OPEN_ALWAYS, 0, NULL );
        FileOpenTimer.Stop();

        assert( hFile != INVALID_HANDLE_VALUE );
        BOOL bSuccess = CloseHandle( hFile );
        (VOID)bSuccess;
    }

    // Record the time to enum and open the files
    fElapsed += FileOpenTimer.GetElapsedSeconds();

    // Enumerate and open all the files in one pass
    OpenFileList openFileList;
    FLOAT fOptimized = EnumFiles( strDrive, openFileList );

    // Record the results
    fileResults.Write( DWORD( fileList.size() ), fElapsed, fOptimized );
}




//-----------------------------------------------------------------------------
// Name: EnumFiles()
// Desc: Recursive enumeration function; returns enumeration time and
//       list of files
//-----------------------------------------------------------------------------
FLOAT BenchStorage::EnumFiles( const CHAR* strDir, FileList& fileList ) // static
{
    FLOAT fElapsed = 0.0f;
    CXBStopWatch timer( FALSE );

    assert( strDir != NULL );

    timer.Start();

    // Append wildcard specifier to folder
    WIN32_FIND_DATA FileData;
    lstrcpyA( FileData.cFileName, strDir );
    lstrcatA( FileData.cFileName, "*" );

    // Enum all files in strDir and all subdirectories
    HANDLE hFile = FindFirstFile( FileData.cFileName, &FileData );
    timer.Stop();
    if( hFile != INVALID_HANDLE_VALUE )
    {
        BOOL bHaveFile = FALSE;
        do
        {
            // Ignore fileResults
            if( strstr( FileData.cFileName, strENUM_OPEN_FILE ) == NULL )
            {
                // name = strDir + FileData.cFileName
                timer.Start();
                CHAR strName[ MAX_PATH ];
                lstrcpyA( strName, strDir );
                lstrcatA( strName, FileData.cFileName );
                timer.Stop();

                // Recurse into subdirectories
                if( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                {
                    lstrcatA( strName, "\\" );
                    fElapsed += EnumFiles( strName, fileList );
                }
                else
                {
                    CHAR* pName = new CHAR [ lstrlenA( strName ) + 1 ];
                    lstrcpyA( pName, strName );
                    fileList.push_back( pName );
                }
            }

            timer.Start();
            bHaveFile = FindNextFile( hFile, &FileData );
            timer.Stop();

        } while( bHaveFile );

        timer.Start();
        VERIFY( FindClose( hFile ) );
        timer.Stop();
    }

    fElapsed += timer.GetElapsedSeconds();
    return fElapsed;
}




//-----------------------------------------------------------------------------
// Name: EnumFiles()
// Desc: Recursive enumeration function; returns enumeration time and
//       list of opened files
//-----------------------------------------------------------------------------
FLOAT BenchStorage::EnumFiles( const CHAR* strDir, OpenFileList& openFileList ) // static
{
    FLOAT fElapsed = 0.0f;
    CXBStopWatch timer( FALSE );

    assert( strDir != NULL );

    timer.Start();

    // Append wildcard specifier to folder
    WIN32_FIND_DATA FileData;
    lstrcpyA( FileData.cFileName, strDir );
    lstrcatA( FileData.cFileName, "*" );

    // Enum all files in strDir and all subdirectories
    HANDLE hFile = FindFirstFile( FileData.cFileName, &FileData );
    timer.Stop();
    if( hFile != INVALID_HANDLE_VALUE )
    {
        BOOL bHaveFile = FALSE;
        do
        {
            // Ignore fileResults
            if( strstr( FileData.cFileName, strENUM_OPEN_FILE ) == NULL )
            {
                // name = strDir + FileData.cFileName
                timer.Start();
                CHAR strName[ MAX_PATH ];
                lstrcpyA( strName, strDir );
                lstrcatA( strName, FileData.cFileName );
                timer.Stop();

                // Recurse into subdirectories
                if( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                {
                    lstrcatA( strName, "\\" );
                    fElapsed += EnumFiles( strName, openFileList );
                }
                else
                {
                    timer.Start();
                    HANDLE hFile = CreateFile( strName, GENERIC_READ, 
                                               FILE_SHARE_READ, NULL,
                                               OPEN_ALWAYS, 0, NULL );
                    timer.Stop();
                    assert( hFile != INVALID_HANDLE_VALUE );
                    openFileList.push_back( hFile );
                }
            }

            timer.Start();
            bHaveFile = FindNextFile( hFile, &FileData );
            timer.Stop();

        } while( bHaveFile );

        timer.Start();
        VERIFY( FindClose( hFile ) );
        timer.Stop();
    }

    fElapsed += timer.GetElapsedSeconds();
    return fElapsed;
}




//-----------------------------------------------------------------------------
// Name: Scatter()
// Desc: Evaluate the speed of 
//-----------------------------------------------------------------------------
VOID BenchStorage::Scatter( DeviceType devType )
{
    // !!!
    (VOID)devType;
}




//-----------------------------------------------------------------------------
// Name: Gather()
// Desc: Evaluate the speed of
//-----------------------------------------------------------------------------
VOID BenchStorage::Gather( DeviceType devType )
{
    // !!!
    (VOID)devType;
}




//-----------------------------------------------------------------------------
// Name: InterleavedRead()
// Desc: Evaluate the performance of interleaving reads from HD and DVD
//-----------------------------------------------------------------------------
VOID BenchStorage::InterleavedRead()
{
    // !!!
}




//-----------------------------------------------------------------------------
// Name: InterleavedWrite()
// Desc: Evaluate the performance of interleaving writes to HD and DVD
//-----------------------------------------------------------------------------
VOID BenchStorage::InterleavedWrite()
{
    // !!!
}




//-----------------------------------------------------------------------------
// Name: BytesTransferred()
// Desc: Standard Read/WriteFileEx callback function
//-----------------------------------------------------------------------------
VOID CALLBACK BenchStorage::BytesTransferred( DWORD dwErrorCode,
                                              DWORD dwBytesTransferred,
                                              OVERLAPPED* pOverlapped ) // static
{
    assert( dwErrorCode == 0 );
    assert( pOverlapped != NULL );
    (VOID)dwErrorCode;

    // Extract the "this" pointer that we tucked away in hEvent
    BenchStorage* pThis = (BenchStorage*)( pOverlapped->hEvent );
    assert( pThis != NULL );
    pThis->OnBytesTransferred( dwBytesTransferred );
}




//-----------------------------------------------------------------------------
// Name: OnBytesTransferred()
// Desc: Custom callback for this class
//-----------------------------------------------------------------------------
VOID BenchStorage::OnBytesTransferred( DWORD dwBytesTransferred )
{
    // Store the number of bytes read/written and trigger the event
    m_dwBytesTransferred = dwBytesTransferred;
}




//-----------------------------------------------------------------------------
// Name: IsValidDevice()
// Desc: TRUE if the given device is available for benchmarking
//-----------------------------------------------------------------------------
BOOL BenchStorage::IsValidDevice( DeviceType devType ) const
{
    switch( devType )
    {
        case Device_MU:          return TEST_MU  && m_chMemUnit   != '\0';
        case Device_DVD:         return TEST_DVD && m_chDvd       != '\0';
        case Device_HD:          return TEST_HD  && m_chHardDrive != '\0';
        case Device_HD_User:     return TEST_HD;
        case Device_HD_Persist:  return TEST_HD;
        case Device_HD_Utility:  return TEST_HD;
        default:assert( FALSE ); return FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Get the logical drive matching the device
//-----------------------------------------------------------------------------
CHAR BenchStorage::GetDrive( DeviceType devType ) const
{
    switch( devType )
    {
        case Device_MU:          return m_chMemUnit;
        case Device_DVD:         return m_chDvd;
        case Device_HD:          return m_chHardDrive;
        case Device_HD_User:     return 'U';
        case Device_HD_Persist:  return 'T';
        case Device_HD_Utility:  return 'Z';
        default:assert( FALSE ); return '\0';
    }
}




//-----------------------------------------------------------------------------
// Name: ShowStatus()
// Desc: Show the current benchmarking status percent
//-----------------------------------------------------------------------------
VOID BenchStorage::ShowStatus( FLOAT fPercent )
{
    swprintf( m_strStatus, L"Progress: %.0f %%", 100.0f * fPercent );
    ShowStatus();
}




//-----------------------------------------------------------------------------
// Name: ShowStatus()
// Desc: Show the current benchmarking status percent
//-----------------------------------------------------------------------------
VOID BenchStorage::ShowStatus( DWORD dwBufferSize, FLOAT fPercent )
{
    swprintf( m_strStatus, L"Buffer size: %lu\nProgress: %.0f %%",
              dwBufferSize, 100.0f * fPercent );
    ShowStatus();
}




//-----------------------------------------------------------------------------
// Name: ShowStatus()
// Desc: Show the current benchmarking status
//-----------------------------------------------------------------------------
VOID BenchStorage::ShowStatus( BOOL bForceRefresh )
{
    if( !bForceRefresh )
    {
        // Only update status screen ten times per second, because this
        // function has considerable overhead
        if( m_StatusTimer.GetElapsedSeconds() < 0.1f )
            return;
    }

    m_StatusTimer.StartZero();
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x000A0A6A, 1.0f, 0L );

    m_Font.DrawText( 320, 140, 0xFFFFFFFF, m_strStatusHdr, XBFONT_CENTER_X );
    m_Font.DrawText( 320, 240, 0xFFFFFFFF, m_strStatus, XBFONT_CENTER_X );

    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: Prepare()
// Desc: Prepare for profiling
//-----------------------------------------------------------------------------
BOOL BenchStorage::Prepare( DeviceType devType, TestFile& fileTest, 
                            ResultsFile& fileResults, const CHAR* strResultsFile,
                            const CHAR* strFuncName, const WCHAR* strDesc, 
                            const CHAR* strResultsHdr1, const CHAR* strResultsHdr2,
                            const CHAR* strResultsHdr3, const CHAR* strResultsHdr4 )
{
    CHAR chDrive = GetDrive( devType );
    if( !IsValidDevice( devType ) )
        return FALSE;

    lstrcpyW( m_strStatusHdr, L"Preparing next benchmark" );
    swprintf( m_strStatus, L"Writing %lu MB test file to %c", 
              TEST_FILE_SIZE / 1024 / 1024, GetDrive( devType ) );
    ShowStatus( TRUE );

    // Create a large file for reading
    if( !fileTest.Create() )
    {
        CHAR strDebug[1024];
        wsprintfA( strDebug, "Test file create failure in %s Drive %c\n",
                   strFuncName, chDrive );
        OUTPUT_DEBUG_STRING( strDebug );
        return FALSE;
    }

    // Create results file
    if( !fileResults.Create( strResultsFile, chDrive, strResultsHdr1, 
                             strResultsHdr2, strResultsHdr3, strResultsHdr4 ) )
    {
        CHAR strDebug[1024];
        wsprintfA( strDebug, "Results file create failure in %s Drive %c\n",
                   strFuncName, chDrive );
        return FALSE;
    }

    // Flush the file cache
    VERIFY( XSetFileCacheSize( 0 ) );
    VERIFY( XSetFileCacheSize( m_dwDefaultCacheSize ) );

    wsprintfW( m_strStatusHdr, L"%s, Drive %c", strDesc, chDrive );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\storage\Bench\File.cpp ===
//-----------------------------------------------------------------------------
// File: File.cpp
//
// Desc: Common file operations for benchmarking
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "File.h"
#include <XbStopWatch.h>
#include <cassert>




//-------------------------------------------------------------------------
// Name: File()
// Desc: Construct file object
//-------------------------------------------------------------------------
File::File( HANDLE hFile )
: 
    m_hFile( hFile )
{
}




//-------------------------------------------------------------------------
// Name: ~File()
// Desc: Close file object
//-------------------------------------------------------------------------
File::~File()
{
    Close();
}




//-------------------------------------------------------------------------
// Name: Open()
// Desc: Open the given file; fails if file doesn't exist
//-------------------------------------------------------------------------
BOOL File::Open( const CHAR* strFile, DWORD dwAccess, DWORD dwAttributes )
{
    Close();
    m_hFile = CreateFile( strFile, dwAccess, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, dwAttributes, NULL );
    return( m_hFile != INVALID_HANDLE_VALUE );
}




//-------------------------------------------------------------------------
// Name: Create()
// Desc: Create the given file
//-------------------------------------------------------------------------
BOOL File::Create( const CHAR* strFile, DWORD dwAccess, DWORD dwAttributes )
{
    Close();
    m_hFile = CreateFile( strFile, dwAccess, FILE_SHARE_READ, NULL, 
                          CREATE_ALWAYS, dwAttributes, NULL );
    return( m_hFile != INVALID_HANDLE_VALUE );
}




//-------------------------------------------------------------------------
// Name: Close()
// Desc: Close the file handle
//-------------------------------------------------------------------------
VOID File::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        BOOL bSuccess = CloseHandle( m_hFile );
        assert( bSuccess != 0 );
        (VOID)bSuccess;
        m_hFile = INVALID_HANDLE_VALUE;
    }
}




//-------------------------------------------------------------------------
// Name: IsOpen()
// Desc: TRUE if file is open
//-------------------------------------------------------------------------
BOOL File::IsOpen() const
{
    return( m_hFile != INVALID_HANDLE_VALUE );
}




//-------------------------------------------------------------------------
// Name: GetSize()
// Desc: Returns the file size in bytes
//-------------------------------------------------------------------------
DWORD File::GetSize() const
{
    assert( IsOpen() );
    return GetFileSize( m_hFile, NULL );
}




//-------------------------------------------------------------------------
// Name: SetPos()
// Desc: Set the file pointer to the given position (relative to the
//       beginning of the file)
//-------------------------------------------------------------------------
VOID File::SetPos( DWORD dwFilePos ) const
{
    assert( IsOpen() );
    assert( LONG(dwFilePos) >= 0 );
    DWORD dwPos = SetFilePointer( m_hFile, LONG(dwFilePos), NULL, FILE_BEGIN );
    assert( dwPos == dwFilePos );
    (VOID)dwPos;
}




//-------------------------------------------------------------------------
// Name: SetEOF()
// Desc: Resize the file to the current position
//-------------------------------------------------------------------------
BOOL File::SetEOF() const
{
    assert( IsOpen() );
    return SetEndOfFile( m_hFile );
}




//-------------------------------------------------------------------------
// Name: Read()
// Desc: Read data from an open file (synchronous)
//-------------------------------------------------------------------------
BOOL File::Read( VOID* pBuffer, DWORD dwBytesToRead, DWORD& dwBytesRead,
                 FLOAT& fElapsed ) const
{
    return Read( pBuffer, dwBytesToRead, &dwBytesRead, fElapsed, NULL );
}




//-------------------------------------------------------------------------
// Name: ReadAsyncNotify()
// Desc: Read data from an open file asynchronously with notification
//-------------------------------------------------------------------------
BOOL File::ReadAsyncNotify( VOID* pBuffer, DWORD dwBytesToRead, 
                            FLOAT& fElapsed, OVERLAPPED& Overlapped ) const
{
    return Read( pBuffer, dwBytesToRead, NULL, fElapsed, &Overlapped );
}




//-------------------------------------------------------------------------
// Name: ReadAsyncCallback()
// Desc: Read data from an open file asynchronously with callback
//-------------------------------------------------------------------------
BOOL File::ReadAsyncCallback( VOID* pBuffer, DWORD dwBytesToRead, 
                              FLOAT& fElapsed, OVERLAPPED& Overlapped,
                              LPOVERLAPPED_COMPLETION_ROUTINE pCallback ) const
{
    return ReadEx( pBuffer, dwBytesToRead, fElapsed, Overlapped, pCallback );
}




//-------------------------------------------------------------------------
// Name: Write()
// Desc: Write data synchronously. Returns FALSE if all bytes could not
//       be written.
//-------------------------------------------------------------------------
BOOL File::Write( const VOID* pBuffer, DWORD dwBytesToWrite, FLOAT& fElapsed ) const
{
    DWORD dwBytesWritten;
    BOOL bSuccess = Write( pBuffer, dwBytesToWrite, &dwBytesWritten, fElapsed, NULL );
    return( bSuccess && dwBytesToWrite == dwBytesWritten );
}




//-------------------------------------------------------------------------
// Name: Write()
// Desc: Write data synchronously
//-------------------------------------------------------------------------
BOOL File::Write( const VOID* pBuffer, DWORD dwBytesToWrite, DWORD& dwBytesWritten,
                  FLOAT& fElapsed ) const
{
    return Write( pBuffer, dwBytesToWrite, &dwBytesWritten, fElapsed, NULL );
}




//-------------------------------------------------------------------------
// Name: WriteAsyncNotify()
// Desc: Write asynchronously with notification
//-------------------------------------------------------------------------
BOOL File::WriteAsyncNotify( const VOID* pBuffer, DWORD dwBytesToWrite, 
                             FLOAT& fElapsed, OVERLAPPED& Overlapped ) const
{
    return Write( pBuffer, dwBytesToWrite, NULL, fElapsed, &Overlapped );
}




//-------------------------------------------------------------------------
// Name: WriteAsyncCallback()
// Desc: Write asynchronously with callback
//-------------------------------------------------------------------------
BOOL File::WriteAsyncCallback( const VOID* pBuffer, DWORD dwBytesToWrite,
                               FLOAT& fElapsed, OVERLAPPED& Overlapped, 
                               LPOVERLAPPED_COMPLETION_ROUTINE pCallback ) const
{
    return WriteEx( pBuffer, dwBytesToWrite, fElapsed, Overlapped, pCallback );
}




//-------------------------------------------------------------------------
// Name: GetOverlappedResult()
// Desc: Determine if async operation has completed
//-------------------------------------------------------------------------
BOOL File::GetOverlappedResult( OVERLAPPED& Overlapped, 
                                DWORD& dwBytesWritten, FLOAT& fElapsed,
                                BOOL bWait ) const
{
    assert( IsOpen() );

    CXBStopWatch timer( TRUE );
    BOOL bSuccess = ::GetOverlappedResult( m_hFile, &Overlapped, 
                                           &dwBytesWritten, bWait );
    fElapsed = timer.GetElapsedSeconds();
    return bSuccess;
}




//-------------------------------------------------------------------------
// Name: Read()
// Desc: Read data -- wrapper around ReadFile()
//-------------------------------------------------------------------------
BOOL File::Read( VOID* pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead,
                 FLOAT& fElapsed, OVERLAPPED* pOverlapped ) const
{
    assert( IsOpen() );
    assert( pBuffer != NULL );
    CXBStopWatch timer( TRUE );
    BOOL bSuccess = ReadFile( m_hFile, pBuffer, dwBytesToRead, 
                              pdwBytesRead, pOverlapped );
    fElapsed = timer.GetElapsedSeconds();
    return bSuccess;
}




//-------------------------------------------------------------------------
// Name: ReadEx()
// Desc: Read data asynchronously -- wrapper around ReadFileEx()
//-------------------------------------------------------------------------
BOOL File::ReadEx( VOID* pBuffer, DWORD dwBytesToRead, 
                   FLOAT& fElapsed, OVERLAPPED& Overlapped, 
                   LPOVERLAPPED_COMPLETION_ROUTINE pCallback ) const
{
    assert( IsOpen() );
    assert( pBuffer != NULL );
    assert( pCallback != NULL );

    CXBStopWatch timer( TRUE );
    BOOL bSuccess = ReadFileEx( m_hFile, pBuffer, dwBytesToRead, 
                                &Overlapped, pCallback );
    fElapsed = timer.GetElapsedSeconds();
    return bSuccess;
}




//-------------------------------------------------------------------------
// Name: Write()
// Desc: Write data -- wrapper around WriteFile
//-------------------------------------------------------------------------
BOOL File::Write( const VOID* pBuffer, DWORD dwBytesToWrite, 
                  DWORD* pdwBytesWritten, FLOAT& fElapsed, 
                  OVERLAPPED* pOverlapped ) const
{
    assert( IsOpen() );
    assert( pBuffer != NULL );

    CXBStopWatch timer( TRUE );
    BOOL bSuccess = WriteFile( m_hFile, pBuffer, dwBytesToWrite, 
                               pdwBytesWritten, pOverlapped );
    fElapsed = timer.GetElapsedSeconds();
    return bSuccess;
}




//-------------------------------------------------------------------------
// Name: WriteEx()
// Desc: Write data asynchronously -- wrapper around WriteFileEx
//-------------------------------------------------------------------------
BOOL File::WriteEx( const VOID* pBuffer, DWORD dwBytesToWrite, 
                    FLOAT& fElapsed, OVERLAPPED& Overlapped,
                    LPOVERLAPPED_COMPLETION_ROUTINE pCallback ) const
{
    assert( IsOpen() );
    assert( pBuffer != NULL );
    assert( pCallback != NULL );

    CXBStopWatch timer( TRUE );
    BOOL bSuccess = WriteFileEx( m_hFile, pBuffer, dwBytesToWrite, 
                                 &Overlapped, pCallback );
    fElapsed = timer.GetElapsedSeconds();
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\template\template.cpp ===
//-----------------------------------------------------------------------------
// File: %%NAME%%.cpp
//
// Desc: [TODO: Describe source file here]
//
// Hist: %%DATE%% - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object
    BOOL        m_bDrawHelp;        // TRUE to draw help screen
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"%%NAME%%" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\storage\Bench\BenchStorage.h ===
//-----------------------------------------------------------------------------
// File: BenchStorage.h
//
// Desc: Benchmark Xbox storage
//
// Hist: 04.25.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XB_BENCH_STORAGE_H
#define XB_BENCH_STORAGE_H

#include <xtl.h>
#include <XbApp.h>
#include <XbFont.h>
#include <XbMemUnit.h>
#include <XbStopWatch.h>

class File;
class TestFile;
class ResultsFile;
class FileList;
class OpenFileList;




//-----------------------------------------------------------------------------
// Name: class BenchStorage
// Desc: Application object for Xbox storage benchmarking
//-----------------------------------------------------------------------------
class BenchStorage : public CXBApplication
{
    CXBPackedResource   m_xprResource;          // Packed resource for the app
    CXBFont             m_Font;                 // Font renderer
    WCHAR               m_strStatusHdr[96];     // Benchmark status header
    WCHAR               m_strStatus[96];        // Benchmark statusf
    CXBStopWatch        m_StatusTimer;          // Don't display status too often
    CXBMemUnit          m_MemUnit;              // MU
    OVERLAPPED          m_Overlapped;           // struct for async read/write
    DWORD               m_dwBytesTransferred;   // for async read/write
    DWORD               m_dwHdBufferSize;       // best HD buffer size
    DWORD               m_dwDefaultCacheSize;   // default file system cache size
    DWORD               m_dwSeed;               // RNG seed
    CHAR                m_chHardDrive;          // Hard drive logical partition
    CHAR                m_chMemUnit;            // MU logical partition
    CHAR                m_chDvd;                // DVD drive

public:

    enum DeviceType
    {
        Device_MU,
        Device_HD,
        Device_DVD,

        Device_HD_User,
        Device_HD_Persist,
        Device_HD_Utility
    };

public:

    BenchStorage();

    virtual HRESULT Initialize();

    VOID RunBenchSuite();
    VOID ShowComplete();

private:

    CHAR FindBestMu();

    VOID RunGetDeviceChangesSuite();
    VOID RunFileBuffersSuite();
    VOID RunAsyncSuite();
    VOID RunApiComparisonSuite();
    VOID RunRandomSeekSuite();
    VOID RunSequentialSeekSuite();
    VOID RunRandomAccessSuite();
    VOID RunSequentialAccessSuite();
    VOID RunCacheSuite();
    VOID RunRegionSuite();
    VOID RunEnumerationSuite();
    VOID RunScatterGatherSuite();
    VOID RunInterleavedSuite();

    VOID FileBuffersRead( DeviceType );
    VOID FileBuffersWrite( DeviceType );

    VOID AsyncRead( DeviceType );
    VOID AsyncReadNotify( DeviceType );
    VOID AsyncReadCallback( DeviceType );
    VOID AsyncWrite( DeviceType );
    VOID AsyncWriteNotify( DeviceType );
    VOID AsyncWriteCallback( DeviceType );

    VOID ApiCompare( DeviceType );
    VOID ApiOpen( DeviceType );
    VOID ApiClose( DeviceType );
    VOID ApiRead( DeviceType );
    VOID ApiWrite( DeviceType );
    VOID ApiSeek( DeviceType );

    VOID RandomSeek( DeviceType );
    VOID SeqSeek( DeviceType );

    VOID RandomRead( DeviceType );
    FLOAT RandomRead( const TestFile&, DWORD, DWORD, const WCHAR*, DWORD = 0 );
    VOID RandomWrite( DeviceType );
    FLOAT RandomWrite( const TestFile&, DWORD, DWORD, const WCHAR*, DWORD = 0 );

    VOID SeqRead( DeviceType );
    FLOAT SeqRead( const TestFile&, DWORD, DWORD, const WCHAR*, DWORD = 0 );
    VOID SeqWrite( DeviceType );
    FLOAT SeqWrite( const TestFile&, DWORD, DWORD, const WCHAR*, DWORD = 0 );

    VOID CacheRead( DeviceType );
    VOID CacheRandomRead( DeviceType );
    VOID CacheSeqRead( DeviceType );
    VOID CacheWrite( DeviceType );
    VOID CacheRandomWrite( DeviceType );
    VOID CacheSeqWrite( DeviceType );

    VOID RegionRead();
    VOID RegionRead( DeviceType );
    VOID RegionWrite();
    VOID RegionWrite( DeviceType );

    VOID EnumSaves( DeviceType );
    VOID EnumDirs( DeviceType );
    static DWORD EnumFiles( const CHAR* );
    VOID EnumSoundtracks();
    VOID EnumNicknames();
    VOID EnumOpen( DeviceType );
    static FLOAT EnumFiles( const CHAR*, FileList& );
    static FLOAT EnumFiles( const CHAR*, OpenFileList& );

    VOID EnumDirSize( DeviceType );

    VOID Scatter( DeviceType );
    VOID Gather( DeviceType );
    VOID InterleavedRead();
    VOID InterleavedWrite();

    static VOID CALLBACK BytesTransferred( DWORD, DWORD, OVERLAPPED* );
    VOID OnBytesTransferred( DWORD );

    BOOL IsValidDevice( DeviceType ) const;
    CHAR GetDrive( DeviceType ) const;
    VOID ShowStatus( FLOAT );
    VOID ShowStatus( DWORD, FLOAT );
    VOID ShowStatus( BOOL = FALSE );
    BOOL Prepare( DeviceType, TestFile&, ResultsFile&, const CHAR*, const CHAR*,
                  const WCHAR*, const CHAR*, const CHAR* = NULL, const CHAR* = NULL,
                  const CHAR* = NULL );
};

#endif // XB_BENCH_STORAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\storage\Bench\File.h ===
//-----------------------------------------------------------------------------
// File: File.h
//
// Desc: Common file operations for benchmarking
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BENCH_STORAGE_FILE_H
#define BENCH_STORAGE_FILE_H

#include <xtl.h>




//-------------------------------------------------------------------------
// Name: class File
// Desc: Common file operations
//-------------------------------------------------------------------------
class File
{

    HANDLE m_hFile;

public:

    explicit File( HANDLE = INVALID_HANDLE_VALUE );
    ~File();

    BOOL  Open( const CHAR* strFile, DWORD dwAccess, DWORD dwAttribs = 0 );
    BOOL  Create( const CHAR* strFile, 
                  DWORD dwAccess = GENERIC_WRITE | GENERIC_READ,
                  DWORD dwAttribs = 0 );
    VOID  Close();
    BOOL  IsOpen() const;
    DWORD GetSize() const;
    VOID  SetPos( DWORD ) const;
    BOOL  SetEOF() const;

    BOOL  Read( VOID*, DWORD dwBytesToRead, DWORD& dwBytesRead,
                FLOAT& fElapsed ) const;
    BOOL  ReadAsyncNotify( VOID*, DWORD dwBytesToRead, FLOAT& fElapsed, 
                           OVERLAPPED& ) const;
    BOOL  ReadAsyncCallback( VOID*, DWORD dwBytesToRead, FLOAT& fElapsed, 
                             OVERLAPPED&, LPOVERLAPPED_COMPLETION_ROUTINE ) const;

    BOOL  Write( const VOID*, DWORD dwBytesToWrite, FLOAT& fElapsed ) const;
    BOOL  Write( const VOID*, DWORD dwBytesToWrite, DWORD& dwBytesWritten,
                 FLOAT& fElapsed ) const;
    BOOL  WriteAsyncNotify( const VOID*, DWORD dwBytesToWrite, FLOAT& fElapsed,
                            OVERLAPPED& ) const;
    BOOL  WriteAsyncCallback( const VOID*, DWORD dwBytesToWrite, FLOAT& fElapsed,
                              OVERLAPPED&, LPOVERLAPPED_COMPLETION_ROUTINE ) const;

    BOOL  GetOverlappedResult( OVERLAPPED&, DWORD& dwBytesWritten, 
                               FLOAT& fElapsed, BOOL bWait = TRUE ) const;

private:

    BOOL  Read( VOID*, DWORD, DWORD*, FLOAT&, OVERLAPPED* ) const;
    BOOL  ReadEx( VOID*, DWORD, FLOAT&, OVERLAPPED&, 
                  LPOVERLAPPED_COMPLETION_ROUTINE ) const;
    BOOL  Write( const VOID*, DWORD, DWORD*, FLOAT&, OVERLAPPED* ) const;
    BOOL  WriteEx( const VOID*, DWORD, FLOAT&, OVERLAPPED&,
                   LPOVERLAPPED_COMPLETION_ROUTINE ) const;
};




#endif // BENCH_STORAGE_FILE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\SimpleWMV\SimpleWMV.cpp ===
//-----------------------------------------------------------------------------
// File: SimpleWMV.cpp
//
// Desc: [TODO: Describe source file here]
//
// Hist: 9.27.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <assert.h>
#include <dsound.h>
#include <wmvxmo.h>

#define VIDEO 1
#define AUDIO 1

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS 1

// Vertex definition for the screen-space quad
typedef struct {
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
} CUSTOMVERTEX;
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)

typedef struct {
    LPDIRECT3DTEXTURE8  pTexture;
    REFERENCE_TIME      rtTimestamp;
    BYTE*               pBits;
} VIDEOFRAME;

DWORD g_Num = 0;

// You'll need to adjust NUM_PACKETS based off your video content
// to ensure that you never run out during the course of playback
// Packet Size needs to be large enough to hold at least 2048
// decoded samples
#define NUM_PACKETS 32
#define PACKET_SIZE 2048 * 2 * 2

#define DUMP 0
#define RECORDAUDIO 0

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT PrepareDecoder();
    HRESULT CleanupDecoder();

    HRESULT DownloadEffectsImage();
    BOOL FindFreePacket( DWORD * pdwIndex );    // Find a free audio packet

#if DUMP
    void DumpAudio( XMEDIAPACKET& xmp );
    void DumpVideo( XMEDIAPACKET& xmp );
#endif // _DEBUG

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;

    LPWMVDECODER        m_pWMVDecoder;              // WMV Decoder XMO
    WMVVIDEOINFO        m_wmvVideoInfo;             // Video info
    WAVEFORMATEX        m_wfx;                      // Audio waveformat
    REFERENCE_TIME      m_rtDuration;               // Duration of video

    VIDEOFRAME          m_aVideoFrames[2];          // 2 frames to ping-pong
    DWORD               m_dwDisplayFrame;           // Which to display
    LPDIRECT3DVERTEXBUFFER8 m_pvbQuad;                  // Quad for rendering video

    LPDIRECTSOUND8      m_pDSound;                  // DirectSound object
    DWORD               m_adwStatus[NUM_PACKETS];   // Audio packet status
    BYTE*               m_pbSampleData;             // Audio sample data
    LPDIRECTSOUNDSTREAM m_pStream;                  // DirectSound stream

    BOOL                m_bGotVideo;               // Reset start time
    REFERENCE_TIME      m_rtStart;                  // Time at start of video
    REFERENCE_TIME      m_rtCurrent;                // Current time

#if RECORDAUDIO
    HANDLE              m_hAudioFile;               // Dump audio to file
#endif
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;

    m_pWMVDecoder       = NULL;
    m_pbSampleData      = NULL;
    m_pStream           = NULL;
    m_dwDisplayFrame    = 0;

    m_bGotVideo        = TRUE;

    m_rtCurrent = 0;
    m_aVideoFrames[0].rtTimestamp = 0;
    m_aVideoFrames[1].rtTimestamp = 0;

    // m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
}



HRESULT CXBoxSample::PrepareDecoder()
{
    char strFilename[100];
    sprintf( strFilename, "d:\\media\\videos\\test%02d.wmv", g_Num++ );

    // Create the decoder
    if( FAILED( WmvCreateDecoder( strFilename,
                                  NULL,
                                  WMVVIDEOFORMAT_RGB32,
                                  NULL,
                                  &m_pWMVDecoder ) ) )
    {
        CHAR str[100];
        sprintf( str, "Couldn't open video file %s.\n", strFilename );
        OUTPUT_DEBUG_STRING( str );
        return E_FAIL;
    }

    // Get information about the video
    REFERENCE_TIME rtPreroll;
    m_pWMVDecoder->GetVideoInfo( &m_wmvVideoInfo );
    m_pWMVDecoder->GetAudioInfo( &m_wfx );
    m_pWMVDecoder->GetPlayDuration( &m_rtDuration, &rtPreroll );
    m_rtDuration -= rtPreroll;

    // Create our video frames
    for( int i = 0; i < 2; i++ )
    {
        m_pd3dDevice->CreateTexture( m_wmvVideoInfo.dwWidth,
                                     m_wmvVideoInfo.dwHeight,
                                     0,
                                     0,
                                     D3DFMT_LIN_X8R8G8B8,
                                     NULL,
                                     &m_aVideoFrames[i].pTexture );

        D3DLOCKED_RECT lr;
        m_aVideoFrames[i].pTexture->LockRect( 0, &lr, NULL, 0 );
        m_aVideoFrames[i].pBits = (BYTE *)lr.pBits;
        m_aVideoFrames[i].pTexture->UnlockRect( 0 );
        m_aVideoFrames[i].rtTimestamp = 0;
    }
    
    // Create a stream for audio playback
    DSSTREAMDESC dssd = {0};
    dssd.dwFlags = 0;
    dssd.dwMaxAttachedPackets = NUM_PACKETS;
    dssd.lpwfxFormat = &m_wfx;

    DirectSoundCreateStream( &dssd, &m_pStream );
    m_pStream->Pause( DSSTREAMPAUSE_PAUSE );

    // Allocate sample data
    m_pbSampleData = new BYTE[ NUM_PACKETS * PACKET_SIZE ];

    for( int j = 0; j < NUM_PACKETS; j++ )
        m_adwStatus[ j ] = XMEDIAPACKET_STATUS_SUCCESS;
    
    // Create a vertex buffer for the quad
    FLOAT fLeft = 320.0f - m_wmvVideoInfo.dwWidth / 2;
    FLOAT fRight = fLeft + m_wmvVideoInfo.dwWidth;
    FLOAT fTop = 240.0f - m_wmvVideoInfo.dwHeight / 2;
    FLOAT fBottom = fTop + m_wmvVideoInfo.dwHeight;

    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), 0, 0, 0, &m_pvbQuad );
    CUSTOMVERTEX * pVertices;
    m_pvbQuad->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[ 0 ].p = D3DXVECTOR4(  fLeft-0.5f,    fTop-0.5f, 1.0f, 1.0f ); pVertices[0].t = D3DXVECTOR2( 0.0f, 0.0f );
    pVertices[ 1 ].p = D3DXVECTOR4( fRight-0.5f,    fTop-0.5f, 1.0f, 1.0f ); pVertices[1].t = D3DXVECTOR2( (FLOAT)m_wmvVideoInfo.dwWidth, 0.0f );
    pVertices[ 2 ].p = D3DXVECTOR4( fRight-0.5f, fBottom-0.5f, 1.0f, 1.0f ); pVertices[2].t = D3DXVECTOR2( (FLOAT)m_wmvVideoInfo.dwWidth, (FLOAT)m_wmvVideoInfo.dwHeight );
    pVertices[ 3 ].p = D3DXVECTOR4(  fLeft-0.5f, fBottom-0.5f, 1.0f, 1.0f ); pVertices[3].t = D3DXVECTOR2( 0.0f, (FLOAT)m_wmvVideoInfo.dwHeight );
    m_pvbQuad->Unlock();

#if RECORDAUDIO
    CHAR strPCMFile[MAX_FILE];
    sprintf( strPCMFile, "%s.pcm", strFilename );
    m_hAudioFile = CreateFile( strPCMFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
#endif

    m_bGotVideo = FALSE;

    return S_OK;
}



HRESULT CXBoxSample::CleanupDecoder()
{
    if( m_pWMVDecoder )
    {
        m_pWMVDecoder->Release();
        m_pWMVDecoder = NULL;
    }

    for( int i = 0; i < 2; i++ )
    {
        if( m_aVideoFrames[i].pTexture )
        {
            m_aVideoFrames[i].pTexture->Release();
            m_aVideoFrames[i].pTexture = NULL;
            m_aVideoFrames[i].pBits    = NULL;
        }
    }

    if( m_pStream )
    {
        m_pStream->Release();
        m_pStream = NULL;
    }

    if( m_pbSampleData )
    {
        delete[] m_pbSampleData;
        m_pbSampleData = NULL;
    }

    if( m_pvbQuad )
    {
        m_pvbQuad->Release();
        m_pvbQuad = NULL;
    }

#if RECORDAUDIO
    if( m_hAudioFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hAudioFile );
        m_hAudioFile = INVALID_HANDLE_VALUE;
    }
#endif

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    if( FAILED( PrepareDecoder() ) )
        return E_FAIL;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Attempts to find a free audio packet (one that isn't currently 
//       submitted to the stream).  Returns TRUE if it found one
//-----------------------------------------------------------------------------
BOOL
CXBoxSample::FindFreePacket( DWORD * pdwIndex )
{
    // Check the status of each packet
    for( int i = 0; i < NUM_PACKETS; i++ )
    {
        // If we find a non-pending packet, return it
        if( m_adwStatus[ i ] != XMEDIAPACKET_STATUS_PENDING )
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}


#if DUMP
void CXBoxSample::DumpAudio( XMEDIAPACKET& xmp )
{
    static DWORD dwPacket = 0;
    static FLOAT fTotal = 0.0f;
    CHAR sz[100];
    fTotal += 1000.0f * *xmp.pdwCompletedSize / (float)m_wfx.nAvgBytesPerSec;
    sprintf( sz, "Audio [%d]: %d bytes = %.1fms\ttimestamp: %I64d(%.1fms)\tTotal: %.1fms\n", 
             dwPacket++,
             *xmp.pdwCompletedSize,
             1000.0f * *xmp.pdwCompletedSize / (float)m_wfx.nAvgBytesPerSec,
             *xmp.prtTimestamp,
             *xmp.prtTimestamp / 10000.0f,
             fTotal );
    OUTPUT_DEBUG_STRING( sz );
}

void CXBoxSample::DumpVideo( XMEDIAPACKET& xmp )
{
    static DWORD dwPacket = 0;
    CHAR sz[100];
    sprintf( sz, "\tVideo [%d]: timestamp: %I64d(%.1fms)\n", dwPacket++, *xmp.prtTimestamp, *xmp.prtTimestamp / 10000.0f );
    OUTPUT_DEBUG_STRING( sz );
}
#endif


//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    HRESULT hr;

    DirectSoundDoWork();
    static bool bSkip = TRUE;

    // This will generally not be necessary.  This is to get around the CPU
    // stall that happens on the very first call to present().  We don't want
    // to start our audio before that, otherwise we might glitch.
    if( bSkip )
    {
        bSkip = FALSE;
        return S_OK;
    }


    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // If the timestamp of the frame we're displaying is greater than
    // the timestamp of the other frame, then we can fill the other
    // frame.  
    do
    {
        if( m_bGotVideo )
        {
            // Update timing
            m_pDSound->GetTime( &m_rtCurrent );
            m_rtCurrent -= m_rtStart;
#if VIDEO
            if( m_rtCurrent >= m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp )
                m_dwDisplayFrame ^= 1;
#endif
#if DUMP
            CHAR sz[100];
            sprintf( sz, "Time is: %.1fms\n", m_rtCurrent / 10000.0f );
            OUTPUT_DEBUG_STRING( sz );
#endif // DUMP
    
        }

        DWORD dwConsecutiveAudio = 0;
        BOOL  bCanDecodeVideo = FALSE;
        DWORD dwIndex;

        // Audio packet
        DWORD audStat, audSize = 0;
        XMEDIAPACKET xmpAudio = {0};
        REFERENCE_TIME rtAudio;

        // Video packet
        DWORD vidStat, vidSize = 0;
        XMEDIAPACKET xmpVideo = {0};
        REFERENCE_TIME rtVideo;
        XMEDIAPACKET* pxmpVideo = NULL;

        // See if we have space to decode video
        if( m_aVideoFrames[ m_dwDisplayFrame ].rtTimestamp >=
            m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp )
        {
            bCanDecodeVideo = TRUE;
#if VIDEO
             while( m_aVideoFrames[ !m_dwDisplayFrame ].pTexture->IsBusy() );
#endif
            pxmpVideo = &xmpVideo;
        }

        // Verify that we can decode audio
        BOOL bCanDecodeAudio = FindFreePacket( &dwIndex );
        assert( bCanDecodeAudio );

        xmpAudio.dwMaxSize        = PACKET_SIZE;
        xmpAudio.pvBuffer         = m_pbSampleData + dwIndex * PACKET_SIZE;
        xmpAudio.pdwStatus        = &audStat;
        xmpAudio.pdwCompletedSize = &audSize;
        xmpAudio.prtTimestamp     = &rtAudio;

        xmpVideo.dwMaxSize        = m_wmvVideoInfo.dwWidth *
                                    m_wmvVideoInfo.dwHeight *
                                    m_wmvVideoInfo.dwOutputBitsPerPixel / 8;
        xmpVideo.pdwStatus        = &vidStat;
        xmpVideo.pdwCompletedSize = &vidSize;
        xmpVideo.prtTimestamp     = &rtVideo;
        xmpVideo.pvBuffer         = m_aVideoFrames[ !m_dwDisplayFrame ].pBits;

        hr = m_pWMVDecoder->ProcessMultiple( pxmpVideo, &xmpAudio );
        if( S_FALSE == hr )
        {
            OUTPUT_DEBUG_STRING( "Done!\n" );
#if RECORDAUDIO
            if( m_hAudioFile != INVALID_HANDLE_VALUE )
                CloseHandle( m_hAudioFile );
#endif
            m_pStream->Discontinuity();

            do
            {
                CleanupDecoder();
                hr = PrepareDecoder();
            } while( FAILED( hr ) );

            // Spin
            // while( 1 );
        }

        if( vidSize > 0 )
        {
#if DUMP
            DumpVideo( xmpVideo );
#endif // DUMP
            static DWORD dwFrame = 0;
            
            ++dwFrame;
            m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp = rtVideo;
            if( !m_bGotVideo )
            {
                m_bGotVideo = TRUE;
                m_pStream->Pause( DSSTREAMPAUSE_RESUME );
                m_pDSound->GetTime( &m_rtStart );
            }
        }

        if( audSize > 0 )
        {
#if DUMP
            XMEDIAPACKET xmpClone = xmpAudio;
#endif // DUMP
#if RECORDAUDIO
            if( m_hAudioFile != INVALID_HANDLE_VALUE )
            {
                DWORD dw;
                WriteFile( m_hAudioFile, xmpAudio.pvBuffer, audSize, &dw, NULL );
            }
#endif
            ++dwConsecutiveAudio;
            xmpAudio.dwMaxSize        = audSize;
            xmpAudio.pdwCompletedSize = NULL;
            xmpAudio.pdwStatus        = &m_adwStatus[ dwIndex ];
            xmpAudio.prtTimestamp     = NULL;
#if AUDIO
            m_pStream->Process( &xmpAudio, NULL );
#endif
#if DUMP
            DumpAudio( xmpClone );
#endif // DUMP
        }
    } while( DS_OK == hr );
    
/*    if( E_PENDING == hr )
        OUTPUT_DEBUG_STRING( "E_PENDING\n" );
    else
        OUTPUT_DEBUG_STRING( "Bailed for some other reason?" );*/

    assert( m_aVideoFrames[ m_dwDisplayFrame ].rtTimestamp <=
            m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp );
    assert( m_aVideoFrames[ m_dwDisplayFrame ].rtTimestamp <= m_rtCurrent );
//    assert( m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp >= m_rtCurrent );

    DWORD dwTimeToSleep = DWORD( ( m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp - m_rtCurrent ) / 10000 );
    if( dwTimeToSleep < 6 )
        dwTimeToSleep = 0;
    else
        dwTimeToSleep -= 6;
#if 0 // DUMP
    CHAR sz[100];
    sprintf( sz, "->Current: %ldms, next: %ldms, sleeping for %ldms\n", DWORD(m_rtCurrent / 10000), DWORD(m_aVideoFrames[ !m_dwDisplayFrame ].rtTimestamp / 10000), dwTimeToSleep );
    OUTPUT_DEBUG_STRING( sz );
#endif
    // Sleep( dwTimeToSleep );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Set up for rendering
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTexture( 0, m_aVideoFrames[ m_dwDisplayFrame ].pTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetStreamSource( 0, m_pvbQuad, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );

    // Render the quad
    m_pd3dDevice->DrawVertices( D3DPT_QUADLIST, 0, 4 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"SimpleWMV" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVPlayBack\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\WMVPlayer.h ===
//-----------------------------------------------------------------------------
// File: WMVPlayer.h
//
// Desc: Definition of WMV playback helper class
//
// Hist: 10.10.01 - New for Novermber XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <xtl.h>
#include <wmvxmo.h>


// This structure is used to hold data about a video frame
typedef struct {
    LPDIRECT3DTEXTURE8  pTexture;
    REFERENCE_TIME      rtTimestamp;
    BYTE*               pBits;
} VIDEOFRAME;

// You'll need to adjust NUM_PACKETS based off your video content
// to ensure that you never run out during the course of playback
// There is an assert that will fire if the class runs out of 
// packets
// Packet Size needs to be large enough to hold at least 2048
// decoded samples
#define NUM_PACKETS 64
#define PACKET_SIZE 2048 * 2 * 2


class CWMVPlayer
{
public:
    CWMVPlayer();
    ~CWMVPlayer();

    HRESULT Initialize( LPDIRECT3DDEVICE8 pd3dDevice, 
                        LPDIRECTSOUND8 pDSound );       // Initialize the player
    HRESULT OpenFile( CHAR* strFilename );              // Open a file for playback
    HRESULT CloseFile();                                // Close file
    HRESULT GetVideoInfo( WMVVIDEOINFO* pVideoInfo );   // Get video info

    BOOL    IsReady();                                  // Ready to switch?
    HRESULT GetTexture( LPDIRECT3DTEXTURE8 pTexture );  // Copy to texture
    HRESULT DecodeNext();                               // Decode next frame

private:
    BOOL FindFreePacket( DWORD * pdwIndex );            // Find a free audio packet

    LPDIRECT3DDEVICE8   m_pd3dDevice;                   // Direct3D device
    LPWMVDECODER        m_pWMVDecoder;                  // WMV Decoder XMO
    WMVVIDEOINFO        m_wmvVideoInfo;                 // Video format info
    WAVEFORMATEX        m_wfx;                          // Audio format info
    REFERENCE_TIME      m_rtDuration;                   // Video duration

    REFERENCE_TIME      m_rtStartTime;                  // Start time
    BOOL                m_bFirstFrame;                  // BOOL to track first frame

    VIDEOFRAME          m_VideoFrame;                   // Video frame

    LPDIRECTSOUND8      m_pDSound;                      // DirectSound object
    LPDIRECTSOUNDSTREAM m_pStream;                      // Stream for playback
    DWORD               m_adwStatus[NUM_PACKETS];       // Packet status
    BYTE*               m_pbSampleData;                 // Audio buffer
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\WMVCutScene.cpp ===
//-----------------------------------------------------------------------------
// File: WMVCutScene.cpp
//
// Desc: This sample demonstrates how to play back WMV cut scenes using the
//       Direct3D overlay surface
//
// Hist: 10.10.01 - New for Novermber XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "wmvplayer.h"
#include <assert.h>
#include <d3d8perf.h>


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Play video" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Stop playback" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )

#define WMV_FILE "d:\\media\\videos\\bike.wmv"

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    
    HRESULT PlayVideo( CHAR* strFilename );

    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object
    BOOL        m_bDrawHelp;        // TRUE to draw help screen

    LPDIRECTSOUND8      m_pDSound;      // DirectSound object
    CWMVPlayer          m_WMVPlayer;    // WMV Player object
    LPDIRECT3DTEXTURE8  m_pOverlay[2];  // Overlay textures
    LPDIRECT3DSURFACE8  m_pSurface[2];  // Overlay Surfaces
    DWORD               m_dwCurrent;    // Current surface
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create DirectSound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    // Initialize the player
    if( FAILED( m_WMVPlayer.Initialize( m_pd3dDevice, m_pDSound ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PlayVideo
// Desc: Plays the specified video file.  Pressing the B button will stop
//       playback
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::PlayVideo( CHAR* strFilename )
{
    // Open the video file to be played
    if( FAILED( m_WMVPlayer.OpenFile( strFilename ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get information about the video format
    WMVVIDEOINFO videoInfo;
    m_WMVPlayer.GetVideoInfo( &videoInfo );

    // Create two textures based off the video format.  We need to
    // use two textures because the overlay surface reads directly
    // from the texture.  Updating a texture while it's being used
    // by the overlay will cause tearing
    for( int i = 0; i < 2; i++ )
    {
        m_pd3dDevice->CreateTexture( videoInfo.dwWidth,
                                     videoInfo.dwHeight,
                                     1,
                                     0,
                                     D3DFMT_YUY2,
                                     0,
                                     &m_pOverlay[i] );
        m_pOverlay[i]->GetSurfaceLevel( 0, &m_pSurface[i] );
    }
    m_dwCurrent = 0;

    // Set up source and destination rectangles
    // TODO: Adjust for different aspect ratios?
    RECT SrcRect;
    RECT DestRect;

    SrcRect.left    = 0;
    SrcRect.top     = 0;
    SrcRect.right   = videoInfo.dwWidth;
    SrcRect.bottom  = videoInfo.dwHeight;

    DestRect.left   = 0;
    DestRect.top    = 0;
    DestRect.right  = 640;
    DestRect.bottom = 480;

    // Timing statistics
    DWORD dwMaxCycles = 0;
    DWORD dwFrame = 0;
    DWORD dwMaxFrame = 0xFFFFFFFF;

    // Enable the Direct3D overlay surface
    m_pd3dDevice->EnableOverlay( TRUE );

    // Playback video.  This is done in its own loop to avoid wasting time
    // waiting for buffer swaps, etc, when we don't need to.
    for( ; ; )
    {
        // If we're ready for the next frame...
        if( m_WMVPlayer.IsReady() )
        {
            dwFrame++;

            // Get the next frame into our texture
            m_WMVPlayer.GetTexture( m_pOverlay[m_dwCurrent] );

            // Update the overlay surface to use this texture
            m_pd3dDevice->UpdateOverlay( m_pSurface[m_dwCurrent], &SrcRect, &DestRect, FALSE, 0 );

            // Decode the next frame
            if( S_FALSE == m_WMVPlayer.DecodeNext() )
            {
                break;
            }

            // We'll use the other texture next time
            m_dwCurrent ^= 1;
        }
        
        // Check for B button to stop playback here
        BOOL bInput = FALSE;
        XBInput_GetInput();
        for( int i = 0; i < 4; i++ )
        {
            if( g_Gamepads[i].hDevice &&
                g_Gamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
                bInput = TRUE;
        }

        if( bInput )
            break;
    }

    // We're done!
    OUTPUT_DEBUG_STRING( "Done!\n" );

    // When disabling the overlay, you should wait until just after a 
    // vertical blank to avoid any flickering
    m_pd3dDevice->BlockUntilVerticalBlank();
    m_pd3dDevice->EnableOverlay( FALSE );

    for( int i = 0; i < 2; i++ )
    {
        m_pSurface[i]->Release();
        m_pOverlay[i]->Release();
    }
    m_WMVPlayer.CloseFile();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        PlayVideo( WMV_FILE );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"WMVCutScene" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText( 200, 220, 0xffffffff, L"Press 'A' to play cut scene" );
        
        WCHAR str[100];
        swprintf( str, L"%S", WMV_FILE );
        m_Font.DrawText( 200, 250, 0xffffff00, str );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVCutScene\WMVPlayer.cpp ===
//-----------------------------------------------------------------------------
// File: WMVPlayer.cpp
//
// Desc: This helper class provides simple WMV decoding and playback 
//       functionality.  It will be expanded as new playback methods are 
//       exposed
//
// Hist: 10.10.01 - New for Novermber XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "wmvplayer.h"
#include <assert.h>
#include <stdio.h>
#include <tchar.h>




//-----------------------------------------------------------------------------
// Name: CWMVPlayer (ctor)
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CWMVPlayer::CWMVPlayer()
{
    m_pWMVDecoder   = NULL;
    m_pDSound       = NULL;
    m_pStream       = NULL;
    m_pbSampleData  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CWMVPlayer (dtor)
// Desc: Performs whatever cleanup is necessary
//-----------------------------------------------------------------------------
CWMVPlayer::~CWMVPlayer()
{
    // Calling code should have already called CloseFile, which would 
    // release and NULL out these pointers
    assert( !m_pWMVDecoder );
    assert( !m_pStream );

    if( m_pDSound )
        m_pDSound->Release();
    if( m_pbSampleData )
        delete[] m_pbSampleData;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Initializes the player, using the given d3d device and directsound
//       object
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::Initialize( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTSOUND8 pDSound )
{
    assert( pd3dDevice );
    m_pd3dDevice = pd3dDevice;
    m_pd3dDevice->AddRef();

    assert( pDSound );
    m_pDSound = pDSound;
    m_pDSound->AddRef();

    m_pbSampleData = new BYTE[ NUM_PACKETS * PACKET_SIZE ];
    assert( m_pbSampleData );

    for( int j = 0; j < NUM_PACKETS; j++ )
        m_adwStatus[ j ] = XMEDIAPACKET_STATUS_SUCCESS;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OpenFile
// Desc: Opens the specified WMV file.  This involves:
//       1) Creating the decoder XMO
//       2) Creating a texture to decode to based off the video size
//       3) Creating a direct sound stream for playback
//       4) Decoding the first chunk of video
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::OpenFile( CHAR* strFilename )
{
    HRESULT hr;
    
    hr = WmvCreateDecoder( strFilename,
                           NULL,
                           WMVVIDEOFORMAT_YUY2,
                           NULL,
                           &m_pWMVDecoder );
    if( FAILED( hr ) )
        return hr;

    // Get information about the video
    REFERENCE_TIME rtPreroll;
    m_pWMVDecoder->GetVideoInfo( &m_wmvVideoInfo );
    m_pWMVDecoder->GetAudioInfo( &m_wfx );
    m_pWMVDecoder->GetPlayDuration( &m_rtDuration, &rtPreroll );
    m_rtDuration -= rtPreroll;

    // Create our video frame
    m_pd3dDevice->CreateTexture( m_wmvVideoInfo.dwWidth,
                                 m_wmvVideoInfo.dwHeight,
                                 0,
                                 0,
                                 D3DFMT_YUY2,
                                 NULL,
                                 &m_VideoFrame.pTexture );

    D3DLOCKED_RECT lr;
    m_VideoFrame.pTexture->LockRect( 0, &lr, NULL, 0 );
    m_VideoFrame.pBits = (BYTE *)lr.pBits;
    m_VideoFrame.pTexture->UnlockRect( 0 );
    m_VideoFrame.rtTimestamp = 0;
    
    // Create a stream for audio playback
    DSSTREAMDESC dssd = {0};
    dssd.dwFlags = 0;
    dssd.dwMaxAttachedPackets = NUM_PACKETS;
    dssd.lpwfxFormat = &m_wfx;

    DirectSoundCreateStream( &dssd, &m_pStream );
    m_pStream->Pause( DSSTREAMPAUSE_PAUSE );

    m_bFirstFrame = TRUE;
    m_rtStartTime = 0;

    DecodeNext();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CloseFile
// Desc: Closes the currently opened WMV file.  This releases the decoder, the
//       video texture, and the directsound stream
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::CloseFile()
{
    if( m_pWMVDecoder )
    {
        m_pWMVDecoder->Release();
        m_pWMVDecoder = NULL;
    }

    if( m_VideoFrame.pTexture )
    {
        m_VideoFrame.pTexture->Release();
        m_VideoFrame.pTexture = NULL;
    }

    if( m_pStream )
    {
        m_pStream->Pause( DSSTREAMPAUSE_RESUME );
        m_pStream->Release();
        m_pStream = NULL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetVideoInfo
// Desc: Returns information on the currently opened video file
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::GetVideoInfo( WMVVIDEOINFO* pVideoInfo )
{
    assert( m_pWMVDecoder );

    *pVideoInfo = m_wmvVideoInfo;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: IsReady
// Desc: Returns TRUE when the next video frame is ready to be displayed.
//-----------------------------------------------------------------------------
BOOL CWMVPlayer::IsReady()
{
    assert( m_pWMVDecoder );

    DirectSoundDoWork();

    // Calculate current time
    REFERENCE_TIME rtCurrent;
    m_pDSound->GetTime( &rtCurrent );
    rtCurrent -= m_rtStartTime;

    // If we're ready to display next frame, then let the caller know
    if( rtCurrent >= m_VideoFrame.rtTimestamp )
    {
        return TRUE;
    }
    
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetTexture
// Desc: Copies the texture that should currently be displayed into the 
//       new texture that is passed in.  When the first frame is retrieved, the
//       audio begins to play
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::GetTexture( LPDIRECT3DTEXTURE8 pTexture )
{
    assert( m_pWMVDecoder );

    D3DLOCKED_RECT lr;
    pTexture->LockRect( 0, &lr, NULL, 0 );
    memcpy( lr.pBits, m_VideoFrame.pBits, m_wmvVideoInfo.dwHeight * lr.Pitch );
    pTexture->UnlockRect( 0 );

    if( m_bFirstFrame )
    {
        m_bFirstFrame = FALSE;
        m_pStream->Pause( DSSTREAMPAUSE_RESUME );
        m_pDSound->GetTime( &m_rtStartTime );
    }

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: DecodeNext
// Desc: Decodes the next video frame, and all audio up to the following video
//       frame.  Except for the first time this is called (when opening the 
//       video), the first thing to be decoded should always be a video frame
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::DecodeNext()
{
    assert( m_pWMVDecoder );

    HRESULT hr;
    BOOL    bGotVideo = FALSE;

    do
    {
        DWORD dwIndex;

        // Verify that we can decode audio.  If this assert fires, then you
        // need to increase the amount of audio buffer for the stream by
        // increasing the #define NUM_PACKETS in wmvplayer.h
        BOOL bCanDecodeAudio = FindFreePacket( &dwIndex );
        assert( bCanDecodeAudio );

        // Audio packet
        DWORD audStat, audSize = 0;
        XMEDIAPACKET xmpAudio = {0};
        REFERENCE_TIME rtAudio;

        // Video packet
        DWORD vidStat, vidSize = 0;
        XMEDIAPACKET xmpVideo = {0};
        REFERENCE_TIME rtVideo;

        // Set up audio packet
        xmpAudio.dwMaxSize        = PACKET_SIZE;
        xmpAudio.pvBuffer         = m_pbSampleData + dwIndex * PACKET_SIZE;
        xmpAudio.pdwStatus        = &audStat;
        xmpAudio.pdwCompletedSize = &audSize;
        xmpAudio.prtTimestamp     = &rtAudio;

        // Set up video packet
        xmpVideo.dwMaxSize        = m_wmvVideoInfo.dwWidth *
                                    m_wmvVideoInfo.dwHeight *
                                    m_wmvVideoInfo.dwOutputBitsPerPixel / 8;
        xmpVideo.pdwStatus        = &vidStat;
        xmpVideo.pdwCompletedSize = &vidSize;
        xmpVideo.prtTimestamp     = &rtVideo;
        xmpVideo.pvBuffer         = m_VideoFrame.pBits;

        hr = m_pWMVDecoder->ProcessMultiple( bGotVideo ? NULL : &xmpVideo, &xmpAudio );
        if( hr == S_FALSE )
        {
            // Tell the stream we're done
            m_pStream->Discontinuity();
        }

        if( audSize > 0 )
        {
            xmpAudio.dwMaxSize        = audSize;
            xmpAudio.pdwCompletedSize = NULL;
            xmpAudio.pdwStatus        = &m_adwStatus[ dwIndex ];
            xmpAudio.prtTimestamp     = NULL;
            m_pStream->Process( &xmpAudio, NULL );
        }

        if( vidSize > 0 )
        {
            m_VideoFrame.rtTimestamp = rtVideo;
            bGotVideo = TRUE;
        }

        assert( audSize == 0 || vidSize == 0 );
        assert( hr == DS_OK || ( audSize == 0 && vidSize == 0 ) );

    } while( DS_OK == hr );

    if( DS_OK == hr || E_PENDING == hr )
        return S_OK;
    else
        return S_FALSE;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Attempts to find a free audio packet (one that isn't currently 
//       submitted to the stream).  Returns TRUE if it found one
//-----------------------------------------------------------------------------
BOOL CWMVPlayer::FindFreePacket( DWORD * pdwIndex )
{
    // Check the status of each packet
    for( int i = 0; i < NUM_PACKETS; i++ )
    {
        // If we find a non-pending packet, return it
        if( m_adwStatus[ i ] != XMEDIAPACKET_STATUS_PENDING )
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\basetexture.cpp ===
//-----------------------------------------------------------------------------
// File: BaseTexture.cpp
//
// Desc: Contains the basic texture-specific logic for the bundler tool
//
// Hist: 04.13.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "BaseTexture.h"
#include "Bundler.h"
#include "LoadImage.h"
#include "xgraphics.h"
#include "cd3dxblt.h"
#include <d3d8.h>
#include <d3d8types.h>


// Texture formats
const FORMATSPEC g_TextureFormats[] = 
{
    // Format name           Xbox save format        Type           #alphabits
    { "D3DFMT_A8R8G8B